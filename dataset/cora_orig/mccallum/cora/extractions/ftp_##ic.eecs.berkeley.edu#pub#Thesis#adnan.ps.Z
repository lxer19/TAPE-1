URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/adnan.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/Thesis/thesis.html
Root-URL: http://www.cs.berkeley.edu
Title: Formal Methods in VLSI System Design  
Author: by Adnan Aziz B. 
Degree: (Indian Institute of Technology at Kanpur) 1989 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto Sangiovanni-Vincentelli Professor John W. Addison Jr.  
Date: 1996  
Affiliation: Tech.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Filip Van Aelten, Jonathan Allen, and Srinivas Devadas. </author> <title> Verification of relations between synchronous machines. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 12(12) </volume> <pages> 1947-1959, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Determining the class of properties common to designs for which a string relationship <ref> [1] </ref> holds would also be of interest. A certain class of hybrid systems (systems with discrete and continuous variables) has been shown to be decidable; this is done by reducing the hybrid system to a purely discrete system. <p> of probabilistic temporal logic has not been explored in the past. 8.2 Finite Markov chains Definition 24 A Markov chain (MC) is a 4-tuple (AP; S; T; L) where AP is a finite set of atomic propositions, S is a countable set of states, T : S fi S ! <ref> [0; 1] </ref> is the transition probability matrix satisfying the condition (8s 2 S) s 0 2S T (s; s 0 ) = 1, and L : S ! 2 AP is a labeling function. Define = 2 AP to be the alphabet of the FMC. <p> The transition probability matrix T yields the probability measure s 0 : C s 0 ! <ref> [0; 1] </ref>; by the measure extension theorem [99], s 0 : C s 0 ! [0; 1] is well defined. <p> The transition probability matrix T yields the probability measure s 0 : C s 0 ! <ref> [0; 1] </ref>; by the measure extension theorem [99], s 0 : C s 0 ! [0; 1] is well defined. Given a set fi of sequences over the alphabet 2 AP , we will abuse notation and refer to the probability of fi when we mean the probability of the set of all state sequences starting at s 0 which give words in fi. <p> which uniquely identify the SCC DAG of compatible Markov chains, derive the formula s (x 11 ; : : : ; x nn ) in the language of Real Closed Fields (RCF) which defines the set of "satisfying assignments" i.e. the set of all T : S fi S ! <ref> [0; 1] </ref> such that whenever T is compatible with the constraints of G then s; (S; AP; L; T ) j= . s is derived inductively from the subformulas of .
Reference: [2] <author> B. Alpern and F. Schneider. </author> <title> Recognizing safety and liveness. </title> <journal> Distributed Computing, </journal> <volume> 2, </volume> <year> 1987. </year>
Reference-contexts: A detailed description of this treatment of properties is available in <ref> [2, 114] </ref>. 3.1 Verification paradigms In this section we describe three approaches that can be used to specify properties of designs. We also describe algorithms for checking these properties. 3.1.1 Invariant checking A very simple yet fundamental verification problem is that of checking invariants.
Reference: [3] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model Checking for Probabilistic Real Time Systems. </title> <booktitle> In Proc. of the Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 115-126, </pages> <year> 1991. </year>
Reference-contexts: In such paradigms, it is proved that verification can be reduced to performing conventional temporal logic analysis on a model with fairness constraints that eliminate events of measure zero; the actual probabilities of events are immaterial. Examples of such approaches are given in <ref> [56, 91, 117, 3] </ref>. Penuli and Zuck [91] introduce the notion CHAPTER 8. <p> Vardi and Wolper [117] follows an approach in which nondeterministic behavior is differentiated from stochastic behavior. Again, verifying such systems reduces to conventional PLTL checking on a Kripke structure with appropriate fairness constraints, which can be done by automata theoretic techniques. Alur et al <ref> [3] </ref> verifies timed stochastic systems; again in this approach randomness is modeled by fairness. Verification is performed on a fair timed automaton; the proof of correctness is nontrivial due to the density of the underlying model of time. Formulations of quantitative approaches to probabilistic verification also exist.
Reference: [4] <author> Rajeev Alur. </author> <title> Techniques for Automatic Verification of Real-Time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, Department of Computer Sciences, Stanford University, </institution> <month> August </month> <year> 1991. </year>
Reference: [5] <author> A. Aziz, F. Balarin, M. DiBenedetto, R. K. Brayton, A. Saldanha, and A. Sangiovanni-Vincentelli. </author> <title> Supervisory Control of Finite State Machines. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1995. </year>
Reference-contexts: For example, there may be applications of the paradigms developed for hardware verification to database query optimization [116]. Similarly, results from finite state CHAPTER 9. CONCLUSIONS 110 machine synthesis can be used in control theory <ref> [5] </ref>; the analysis of stochastic systems may lead to a better understanding of performance optimization. Many engineers and scientists are not aware of the power of logic.
Reference: [6] <author> A. Aziz, K. Sanwal, V. Singhal, and R. K. Brayton. </author> <title> Verifying Continuous Time Markov Chains. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: It is not clear though that these would be significantly different from the corresponding results for CTL fl . Timing and fairness can also be analyzed in conjunction with probabilities; an extension of the results in this chapter have been made to continuous time Markov chains <ref> [6] </ref>. Several issues related to general Markov chains remain open. We would like to study restricted classes of general Markov chains in which the transition probabilities CHAPTER 8. STOCHASTIC SYSTEMS 105 constraints are simply intervals. <p> We recently developed the logic ptCTL which is capable of expressing properties of continuous time stochastic systems; we proved the problem of model checking ptCTL formulas over continuous time finite Markov chains to be decidable <ref> [6] </ref>. The extension to real time Markov processes remains open. We believe a formal treatment of the problems arising in the performance analysis and performance optimization of stochastic systems may shed some new light on these issues.
Reference: [7] <author> A. Aziz, T. R. Shiple, V. Singhal, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Formula-Dependent Equivalence for Compositional CTL Model Checking. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1994. </year>
Reference-contexts: This technique has been used by [31]. However, in general we are interested in model checking a design with respect to a few formulas, and hence preserving all CTL formulas is unnecessary. In <ref> [7] </ref> we investigate a formula dependent equivalence that preserves the truth of a particular formula, but possibly not of other formulas. This leads to a coarser equivalence, and hence the possibility of greater simplification. Consider for example the FSM M described in Figure 5.4.
Reference: [8] <author> A. Aziz, V. Singhal, F. Balarin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Equivalences for Fair Kripke Structures. </title> <booktitle> In International Colloquium on Automata, Languages and Programming. </booktitle> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1994. </year> <note> BIBLIOGRAPHY 112 </note>
Reference-contexts: The conservativeness of fair bisimulation with respect to I/O-equivalence can be seen in Figure 2.2. 2 E fair-bis has interesting theoretical properties. In particular, we proved that it is the weakest equivalence that preserves the logic CTL fl interpreted on the fair paths <ref> [8] </ref>. We demonstrated that E fair-bis could be decided in PSPACE, and conjectured that it was also hard for PSPACE; this was recently proved [69]. Thus it is not of much help in finding equivalent states. <p> C i ) = T (t; C i )] Thus E 1 lies in E prob and so E 1 = E prob . 2 It should be noted that the states were characterized in pCTL; this is surprising given that bisimulation under fairness can not be characterized by CTL <ref> [8] </ref>, and that probabilistic transitions are in some loose sense "fair" transitions.
Reference: [9] <author> A. Aziz, V. Singhal, and R. K. Brayton. </author> <title> Verifying Interacting Finite State Machines. </title> <type> Technical Report UCB/ERL M93/52, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: This approach is doomed to CHAPTER 3. FORMAL VERIFICATION 33 failure for even moderately sized designs, since a netlist with k binary-valued latches has 2 k states. This is referred to as the state explosion phenomenon. In <ref> [9] </ref> we categorize the precise computational complexity of various problems related to the analysis of netlists.
Reference: [10] <author> A. Aziz, V. Singhal, G. M. Swamy, and R. K. Brayton. </author> <title> Minimizing Interacting Finite State Machines. </title> <type> Technical Report UCB/ERL M93/68, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: CHAPTER 5. COMPOSITIONAL METHODS 47 As stated in the introduction, large sequential designs arise as the composition of smaller components. Identifying these components in large sequential netlists is a major problem in its own right; in <ref> [10] </ref> we describe heuristics for this problem. 5.1 Language emptiness In the language emptiness approach, the input is a netlist with a Buchi fairness constraint. As described in Section 3.1.3, the property passes if and only if there is no path to a fair cycle from an initial state.
Reference: [11] <author> A. Aziz, S. Tasiran, and R. K. Brayton. </author> <title> BDD Variable Ordering for Interacting Finite State Machines. </title> <type> Technical Report UCB/ERL M93/71, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: In practice we found that for most circuits constructing a permutation by greedily selecting the gate that minimized the additional communication yielded gate orderings that were close to optimal and took very little time to compute. Details of the implementation are available in <ref> [11] </ref>. Correlating the bound to BDD size For assessing the usefulness of our bound as a measure of the actual BDD size, and checking the validity of assumptions, we needed a set of representative examples to test our algorithms. We artificially constructed several designs according to various interconnection schemes. <p> In all cases, using a random ordering resulted in space-outs when constructing the BDD. Results are reported in Figure 4.3. In all cases, our method yielded significantly smaller BDDs for the transition relation. Note that Mesh20, which has high communication complexity (as shown in <ref> [11] </ref>) had a large BDD compared to Tree31 which has low communication, corroborating the fact CHAPTER 4. SYMBOLIC METHODS 41 that BDD size correlates well with communication.
Reference: [12] <author> R. I. Bahar, E. A. Frohm, C. M. Gaona, G. D. Hachtel, E. Macii, A. Pardo, and F. Somenzi. </author> <title> Algebraic Decision Diagrams and their Applications . In Proc. </title> <booktitle> Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 188-192, </pages> <year> 1993. </year>
Reference-contexts: BDD based symbolic techniques have been successful as a heuristic for coping with state explosion; analogs of the BDD such as the ADD of <ref> [12] </ref>, may similarly prove successful in dealing with composed Markov chains. <p> This analysis was extended to parameterized finite Markov chains. There are a number of potential applications for a probabilistic model checker. Building such a tool should be straightforward; the power of symbolic data structures is already available <ref> [12] </ref>. We recently developed the logic ptCTL which is capable of expressing properties of continuous time stochastic systems; we proved the problem of model checking ptCTL formulas over continuous time finite Markov chains to be decidable [6]. The extension to real time Markov processes remains open.
Reference: [13] <author> Felice Balarin. </author> <title> Iterative Methods for Formal Verification of Digital Systems. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1995. </year>
Reference-contexts: Other approaches rely on restricting the verification to special cases, such as inductively reasoning about networks of identical components, or automatically "abstracting" the design <ref> [13] </ref>. One approach which has enjoyed exceptional success is the use of "symbolic representations". In this approach the STG is encoded as a logic function; verification then proceeds by manipulating these functions.
Reference: [14] <author> M. Ben-Or, D. Kozen, and J. Reif. </author> <title> The Complexity of Elementary Algebra and Geometry. </title> <booktitle> In Proc. ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 457-464, </pages> <year> 1984. </year>
Reference-contexts: Using characterizations of discrete Markov chains developed in [88] and results on the decidability of real closed fields (RCF) <ref> [14] </ref> we derive an elementary decision procedure for model checking pCTL fl over generalized discrete Markov chains. There is a body of past work on applying formal methods to stochastic systems. An early approach is [57] which computes the expected time for a probabilistic program to terminate. <p> A detailed analysis, exploiting the elementary nature of RCF <ref> [14] </ref>, shows that the procedure is in fact elementary.
Reference: [15] <author> S. S. Bhattacharyya, P. K. Murthy, and E. A. Lee. </author> <title> Software Synthesis from Dataflow Graphs. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1996. </year>
Reference-contexts: The model depends on the context; for example, it could be a Turing machine program [76], a finite state transducer [90], or a dataflow graph <ref> [15] </ref>. The issues involved in this discipline include decidability, complexity, and expressiveness of the specification language. In this chapter we will be mostly concerned with the optimization problem; we will make the connection to program synthesis in Section 6.5.1.
Reference: [16] <author> R. Boppana and M. Sipser. </author> <title> The complexity of finite functions. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <editor> Ed. Jan van Leeuwen (Volume A: </editor> <booktitle> Algorithms and Complexity), </booktitle> <volume> volume 1. </volume> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Succinctness issues related to the definability of finite relations are an area of deep research; Boppana and Sipser <ref> [16] </ref> provide a good survey of this subject. Below, we discuss some elementary facts about representing functions definable in FOE k -logic. <p> The relation is precisely the set of inputs for which the output is 1. Similarly, relations can be represented by formulas in FOE k -logic, or programs on Turing machines. These issues are described in <ref> [16, 87] </ref>. While these representations are compact, the computational complexity of checking elementary properties (such as nonemptiness) of the relation starting from such representations is high. CHAPTER 4.
Reference: [17] <author> A. Bouajjani, J.C. Fernandez, and N. Halbwachs. </author> <title> Minimal Model Generation. </title> <editor> In E. Clarke and R. Kurshan, editors, </editor> <booktitle> Proc. of CAV 1990, volume 531 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We have applied these ideas to both the language emptiness and model checking paradigms. The formulation for language containment is given in Section 5.1; extensions to model checking are sketched in Section 5.2. Many other compositional strategies exist for forming a reduced product e.g. <ref> [72, 29, 50, 17] </ref>. In the language containment paradigm our primary contribution is defining equivalences in the presence of fairness, and identifying a subset of these that can be easily computed.
Reference: [18] <author> R. K. Brayton, G. D. Hachtel, C. T. McMullen, and A. L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year> <note> BIBLIOGRAPHY 113 </note>
Reference-contexts: Symbolic trajectory evaluation [103] is less expressive than CTL, but allows for more efficient verification. The PSPACE completeness of the model checking problem, (often referred to as state explosion) even in its simplest forms, simply reinforces the need for heuristics <ref> [18] </ref>. Other approaches rely on restricting the verification to special cases, such as inductively reasoning about networks of identical components, or automatically "abstracting" the design [13]. One approach which has enjoyed exceptional success is the use of "symbolic representations". <p> In particular logic synthesis, the science of optimizing gate level designs for measures such as area, speed, or power, has shifted to the forefront of CAD research. Logic synthesis algorithms originally targeted the optimization of PLA implementations <ref> [18] </ref>; this was followed by research in synthesizing more general multilevel logic implementations. Currently, the central thrust in logic synthesis is sequential synthesis, i.e. the automatic optimization of the entire system.
Reference: [19] <author> R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. K. Ranjan, S. Sarwary, T. R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A system for Verification and Synthesis. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: These took the form of finite state machines and netlists. We discussed issues related to composing designs, and also introduced the concept of fairness. These models are essentially the data structures used to internally represent designs in the tool VIS <ref> [19] </ref>. Trivial though it may seem, FOE k -logic has many applications. As we saw, it provided a natural way of logically characterizing hardware designs specified in the form of netlists. <p> More pragmatically, it is not clear which of the two are easier for designers to use. The underlying computational techniques and issues are very similar, making an argument for providing both, an approach taken by the tool VIS <ref> [19] </ref>. 3.2 Complexity issues Clarke and Emerson [30] describes an efficient procedure for determining all states in an FSM that satisfy a formula f . The running time is proportional to j M j fi j f j. <p> It CHAPTER 4. SYMBOLIC METHODS 42 has been experimentally determined that the min comm ordering coupled with the use of dynamic reordering leads to the best overall results [108]; this is the approach taken by <ref> [19] </ref>. 4.2 Optimizing image computations Often there is no variable ordering that will lead to a small BDD for the transition relation. However, there are a number of techniques that can be employed to make it feasible to compute the image and preimage without forming the full transition relation. <p> Summary In summary, it can safely be said that the use of symbolic methods has enabled the verification of a regime of designs that was previously impossible. Example of designs that were successfully verified using a BDD based approach include <ref> [19, 78, 26, 54] </ref>. These results underline the importance of an approach which can be easily used by designers. Since model checking can operate on descriptions similar to those which designers build for synthesis and simulation, it is gaining acceptance amongst designers. Additionally, there have been CHAPTER 4. <p> In order to get designers to start using formal verification, it is essential to make the learning curve as gentle as possible. The tool VIS <ref> [19] </ref> addresses some of these concerns - it accepts designs specified in Verilog HDL, properties expressed in a number of formalisms, and has an intuitive user interface. Additionally, the underlying algorithms are fairly robust.
Reference: [20] <author> M. C. Browne, E. M. Clarke, and O. Grumberg. </author> <title> Characterizing Finite Kripke Structures in Propositional Temporal Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 115-131, </pages> <year> 1988. </year>
Reference-contexts: When no inputs and/or outputs are projected, it is identical to trace equivalence. It is the weakest equivalence preserving CTL fl , i.e. states in an FSM agree on all properties expressible in CTL fl if and only if they are bisimilar <ref> [20] </ref>. These properties suggest defining an equivalence akin to bisimulation, which incorporates fairness; ideally, it would be fast to compute, and still be reasonably coarse. Below we define the natural extension of bisimulation to FSMs with fairness constraints. <p> the bisimulation equivalence, the reduction was modest; this may be in part to the lack of good BDD minimization routines. 5.2 Model checking It is well known that bisimulation equivalence is the coarsest (or weakest) equivalence that preserves the truth of all CTL fl formula on a finite state machine <ref> [20] </ref>. Hence CHAPTER 5. COMPOSITIONAL METHODS 54 bisimulation equivalence can be used to identify equivalent states to derive smaller component machines. This technique has been used by [31]. <p> STOCHASTIC SYSTEMS 100 2 Lemma 9 (Completeness) States which agree in their truth values on all formulas are probabilistically bisimilar i.e. (8 2 pCTL fl ) s j= $ t j= ) E prob (s; t) Proof. We proceed in the spirit of <ref> [20] </ref>.
Reference: [21] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: CHAPTER 4. SYMBOLIC METHODS 36 A data structure that can compactly represent a large class of useful relations succinctly, while allowing efficient manipulation of these relations, is the reduced ordered many-valued decision diagram [111]. This is an extension on the reduced ordered binary decision diagram <ref> [21] </ref>. In order to keep the exposition in this chapter simple, we will restrict our attention to binary decision diagrams, while noting that the results immediately generalize to the many-valued case.
Reference: [22] <author> R. Bryant. </author> <title> On the complexity of VLSI implementations and graph representations of boolean functions with application to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40, </volume> <year> 1991. </year>
Reference-contexts: BDDs do not work well on designs with a large data-path component. For example, it has been proved that representing the bits of the output of a circuit for an n bit multiplier takes fi (2 n ) BDD nodes for any variable ordering <ref> [22] </ref>. Bryant [23] has recently reported promising results on BDD-like data structures that can represent arithmetical relations on n-bit words efficiently. Similarly, Jones et al. [63] describe techniques for representing designs with uninterpreted functions. BDDs are not the only approach for coping with state explosion.
Reference: [23] <author> R. Bryant and Y.A. Chen. </author> <title> Verification of Arithmetic Circuits with Binary Moment Diagrams. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 535-541, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: BDDs do not work well on designs with a large data-path component. For example, it has been proved that representing the bits of the output of a circuit for an n bit multiplier takes fi (2 n ) BDD nodes for any variable ordering [22]. Bryant <ref> [23] </ref> has recently reported promising results on BDD-like data structures that can represent arithmetical relations on n-bit words efficiently. Similarly, Jones et al. [63] describe techniques for representing designs with uninterpreted functions. BDDs are not the only approach for coping with state explosion. There are many other approaches [51]. <p> Another promising area of research is the use of BDD-like data structures which can efficiently represent special relations on which BDDs perform badly; preliminary work has been done in this area, e.g. <ref> [23] </ref>. We believe verification strategies which use BDDs in addition to simulation and/or explicit state enumeration may be able to share the benefits of both approaches. An approach to verifying compositional designs was introduced in Chapter 5.
Reference: [24] <author> J. R. Buchi. </author> <title> On a Decision Method in Restricted Second Order Arithmetic. </title> <booktitle> In International Congress on Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 1-11, </pages> <year> 1960. </year>
Reference-contexts: It was studied in detail by Buchi in <ref> [24] </ref>; in particular it was shown to be decidable. S1S provides an extremely powerful mechanism for analyzing and manipulating sequential systems - the expressiveness of logic (conjunction, negation, and quantification) is available to define constraints on sets.
Reference: [25] <author> J. R. Burch, D. L. Dill, E. Wolf, and G. D. </author> <title> Micheli. Modeling Hierarchical Combinational Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 612-617, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Our modeling of hardware in terms of finite state machines is not rich enough; the correct models require knowledge of the ternary behavior of the design <ref> [25, 73, 107] </ref> A Moore netlist is a netlist where there is no path from an input to an output which does not pass through a latch. <p> Note CHAPTER 2. DIGITAL SYSTEMS 23 that some subset of the outputs of a netlist may be driven only by latches, in which case one can define the notion of Moore outputs. Issues related to such netlists have been treated in <ref> [25, 73, 106] </ref>. In this chapter we will assume that we will never encounter combinational cycles. This means we will refer to the composition of designs only when the composition does not create combinational loops.
Reference: [26] <author> B. Chen, M. Yamazaki, and M. Fujita. </author> <title> Bug Identification of a Real Chip Design by Symbolic Model Checking. </title> <booktitle> In Proc. European Conf. on Design Automation, </booktitle> <pages> pages 132-136, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Summary In summary, it can safely be said that the use of symbolic methods has enabled the verification of a regime of designs that was previously impossible. Example of designs that were successfully verified using a BDD based approach include <ref> [19, 78, 26, 54] </ref>. These results underline the importance of an approach which can be easily used by designers. Since model checking can operate on descriptions similar to those which designers build for synthesis and simulation, it is gaining acceptance amongst designers. Additionally, there have been CHAPTER 4.
Reference: [27] <author> Szu Tsung Cheng. </author> <title> Compiling Verilog into Automata. </title> <type> Master's thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1994. </year>
Reference: [28] <author> M. Chiodo, P. Giusto, A. Jurecska, L. Lavagno, H. H. Hsieh, K. Suzuki, A. L. Sangiovanni-Vincentelli, and E. Sentovitch. </author> <title> Synthesis of Software Programs for Em BIBLIOGRAPHY 114 bedded Control Applications. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> San Francisco, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Partitioning for synthesis, i.e. identifying components in large flat netlists, may be necessary when optimizing large designs. This approach should be applicable to optimization of software synthesis, which could have applications to embedded controller design and hardware-software co-design <ref> [28] </ref>.
Reference: [29] <author> M. Chiodo, T. R. Shiple, and A. L. Sangiovanni-Vincentelli. </author> <title> Automatic Compositional Minimization in CTL Model Checking. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 172-178, </pages> <year> 1992. </year>
Reference-contexts: We have applied these ideas to both the language emptiness and model checking paradigms. The formulation for language containment is given in Section 5.1; extensions to model checking are sketched in Section 5.2. Many other compositional strategies exist for forming a reduced product e.g. <ref> [72, 29, 50, 17] </ref>. In the language containment paradigm our primary contribution is defining equivalences in the presence of fairness, and identifying a subset of these that can be easily computed.
Reference: [30] <author> E. M. Clarke and E. A. Emerson. </author> <title> Design and Synthesis of Synchronization Skeletons Using Branching Time Logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: More pragmatically, it is not clear which of the two are easier for designers to use. The underlying computational techniques and issues are very similar, making an argument for providing both, an approach taken by the tool VIS [19]. 3.2 Complexity issues Clarke and Emerson <ref> [30] </ref> describes an efficient procedure for determining all states in an FSM that satisfy a formula f . The running time is proportional to j M j fi j f j. <p> The apparent conundrum is resolved by the observation that designs are hierarchical, and as a result, a naive algorithm for the model checking problem would proceed by extracting the underlying FSM and the applying the procedure of <ref> [30] </ref>. This approach is doomed to CHAPTER 3. FORMAL VERIFICATION 33 failure for even moderately sized designs, since a netlist with k binary-valued latches has 2 k states. This is referred to as the state explosion phenomenon.
Reference: [31] <author> Edmund M. Clarke, David E. Long, and Kenneth L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In 4th Annual Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Hence CHAPTER 5. COMPOSITIONAL METHODS 54 bisimulation equivalence can be used to identify equivalent states to derive smaller component machines. This technique has been used by <ref> [31] </ref>. However, in general we are interested in model checking a design with respect to a few formulas, and hence preserving all CTL formulas is unnecessary. In [7] we investigate a formula dependent equivalence that preserves the truth of a particular formula, but possibly not of other formulas.
Reference: [32] <author> R. Cleavland, S. A. Smolka, and A. Zwarico. </author> <title> Testing Preorders for Probabilistic Processes. </title> <booktitle> In Proc. of the Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 708-719, </pages> <year> 1992. </year>
Reference-contexts: Definitions of probabilistic simulation and/or bisimulation exist in the CCS and CSP communities <ref> [32] </ref>, which are essentially the same as ours. <p> A complete analysis of the pCTL model checking algorithm yields a polynomial bound on the running time. 2 8.4 Equivalences for finite Markov chains Developing a notion of bisimulation is integral to the analysis of state based dynamical systems. Notions of probabilistic bisimulation exist in CCS/CSP literature <ref> [32] </ref>. In this section we show that the logic pCTL fl is expressive with respect to probabilistic bisimulation (essentially the one defined in [32]). <p> Notions of probabilistic bisimulation exist in CCS/CSP literature <ref> [32] </ref>. In this section we show that the logic pCTL fl is expressive with respect to probabilistic bisimulation (essentially the one defined in [32]). Notation: Given an equivalence relation E S fi S, C E = fC 1 ; C 2 ; : : : ; C l g is the corresponding partition of S. We will write T (s; C i ) for t2C i (T (s; t)).
Reference: [33] <author> T. H. Cormen, C. E. Leiserson, and R. H. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: This is easily answered by checking CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 60 the existence an accepting state which is reachable from the initial state; this can be tested in linear time using depth first search <ref> [33] </ref>. For a language L over 1 fi 2 defined by a fl-automaton M , it is natural to ask if L projected down to 1 is also definable by a fl-automaton. The answer is in the affirmative. <p> Properties of Buchi automata The nonemptiness problem for Buchi automata can be answered by checking the existence an accepting state which lies on a loop and is reachable from the initial state; as was the case for fl-automata, this can be tested in linear time using depth first search <ref> [33] </ref>. For a language L over 1 fi 2 defined by a Buchi automaton, L projected down to 1 is also definable; the construction is the same as for fl-automata.
Reference: [34] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proc. of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In this way, BDDs can be viewed as providing a decision procedure for FOE 2 -logic, which heuristically performs well on a number of applications related to verifying netlists. This observation was made independently by a number of researchers <ref> [34, 79, 89, 115] </ref>. 4.1 BDD variable ordering Recall that the graph of the transition function of a netlist can be defined by a formula ffi (x 1 ; x 2 ; : : : ; x n ; u 1 ; u 2 ; : : : ; u k
Reference: [35] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Verifying Temporal Properties of Finite State Probabilistic Programs. </title> <booktitle> In Proc. IEEE Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 338-345, </pages> <year> 1988. </year>
Reference-contexts: Formulations of quantitative approaches to probabilistic verification also exist. Hansson and Jonsson [53] describes an extension of CTL, referred to as PCTL, capable of expressing numerical bounds on the probability of specified properties; it is essentially identical to the logic pCTL defined in Section 8.3. Courcoubetis and Yannakakis <ref> [35] </ref> describes an algorithm for determining the measure of a set of paths in a discrete Markov chains satisfying a PLTL [41] formula; this immediately provides a procedure for model checking the logic pCTL fl , defined in Section 8.3. <p> CHAPTER 8. STOCHASTIC SYSTEMS 96 pCTL/pCTL fl Model Checking Lemma 6 Model checking of CTL fl over finite Markov chains is decidable. This lemma follows immediately from the results of Courcoubetis <ref> [35] </ref> where a PSPACE procedure is given for computing the probability that a discrete Markov chain satisfies a specification in PLTL [41].
Reference: [36] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Automatic Verification of Finite State Programs. </title> <booktitle> In Proc. of the Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 326-347, </pages> <year> 1990. </year>
Reference-contexts: There is a body of past work on applying formal methods to stochastic systems. An early approach is [57] which computes the expected time for a probabilistic program to terminate. Programs are modeled as Markov chains; the techniques are standard in Markov chain theory. <ref> [36] </ref> describes an approach to the control of finite state Markov chains subject to !-regular specifications. Criteria for optimality are developed; finding an optimal control strategy reduces to solving a linear program.
Reference: [37] <author> S. Devadas. </author> <title> Optimizing Interacting Finite State Machines Using Sequential Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <pages> pages 1473-1484, </pages> <month> December </month> <year> 1991. </year> <note> BIBLIOGRAPHY 115 </note>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation.
Reference: [38] <author> D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang. </author> <title> Protocol Verification as a Hardware Design Aid. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 522-525, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: BDD based approaches to verification do have major shortcomings. For example, there is some evidence that for loosely coupled asynchronous systems, such as cache coherency protocols, careful use of explicit data structures may be superior to BDD based methods <ref> [38] </ref>. This is because constants count asymptotically BDDs are as good as truth tables for representing relations; however the overhead associated with the underlying data structures results in the BDD for a set taking up substantially more memory than an explicit representation when there is little sharing in the BDD.
Reference: [39] <author> D. L. Dill, A. J. Hu, and H. Wong-Toi. </author> <title> Checking for Language Inclusion Using Simulation Preorder. </title> <booktitle> In Proc. of the Third Workshop on Computer-Aided Verification, </booktitle> <year> 1991. </year>
Reference-contexts: We demonstrated that E fair-bis could be decided in PSPACE, and conjectured that it was also hard for PSPACE; this was recently proved [69]. Thus it is not of much help in finding equivalent states. Dill et al. <ref> [39] </ref> gave techniques for language containment by simulation relations for Buchi automaton. We extend his definitions to obtain conservative approximations to E fair-bis which are polytime computable.
Reference: [40] <author> C. C. Elgot. </author> <title> Decision Problems of Finite Automaton Design and Related Decision Problems. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 98 </volume> <pages> 21-52, </pages> <year> 1961. </year>
Reference-contexts: Given the relative ease with which fl-automata can be complemented, it is not surprising that the proof of this theorem is much easier than that for Buchi's theorem; in fact it pre-dates Buchi's result <ref> [40] </ref>. 6.2.3 Applications to synthesis identify a formula with it; this formula may be in S1S or WS1S depending on the context. We will cast and solve the problem of characterizing permissible solutions in logic; essentially this amounts to writing down a system of logical constraints.
Reference: [41] <author> E. A. Emerson. </author> <title> Temporal and Modal Logic. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 996-1072. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: In this dissertation, we will take a very simple approach to fairness; we will restrict our attention to Buchi fairness conditions. A Buchi fairness condition is a subset of the state space of the FSM. More complex ways of specifying fairness exist; for example refer to <ref> [41] </ref>. An infinite path satisfies a Buchi fairness condition f iff there are states occurring infinitely often in the path which are contained in the fairness condition. <p> Similarly, initializability, which is the property that a sequence of inputs can always be applied to a design to bring it back to an initial state falls into this category. Computational Tree Logic (CTL) <ref> [41] </ref> is a logical formalism which can be used to express a very rich class of properties of digital designs. <p> An equivalence relation for a CTL formula is complete iff it is the coarsest equivalence with the property that no environment module can differentiate equivalent states with respect to . It is readily seen by a reduction from CTL validity <ref> [41] </ref> that deciding complete equivalence for CTL is EXPTIME-complete. We have defined a bisimulation like equivalence constructed inductively from the given CTL formula which can be computed in polynomial time. <p> Various methodologies have been proposed; some of the most fruitful, in both theory and practice, have been based on temporal logic <ref> [41] </ref>. Properties are expressed using formulas which are built out of operators on the computation paths. The goal of this chapter is to take verification techniques developed for temporal logic, and apply them to stochastic systems, i.e. systems in which there is a certain probability associated with events. <p> In this chapter several contributions are made towards formal reasoning about stochastic systems. We define pCTL fl , a probabilistic variant of Computational Tree Logic <ref> [41] </ref>. The logic expresses quantitative stochastic properties of systems, which are themselves modeled as discrete Markov chains; furthermore, it exhibits an elementary model checking procedure. Discrete Markov chains exhibit a natural notion of bisimulation; this is shown to be sound and complete with respect to pCTL fl . <p> Courcoubetis and Yannakakis [35] describes an algorithm for determining the measure of a set of paths in a discrete Markov chains satisfying a PLTL <ref> [41] </ref> formula; this immediately provides a procedure for model checking the logic pCTL fl , defined in Section 8.3. Definitions of probabilistic simulation and/or bisimulation exist in the CCS and CSP communities [32], which are essentially the same as ours. <p> This lemma follows immediately from the results of Courcoubetis [35] where a PSPACE procedure is given for computing the probability that a discrete Markov chain satisfies a specification in PLTL <ref> [41] </ref>. The procedure is based on obtaining a deterministic !-automaton accepting the language defined by the linear specification, and composing it with the Markov chain the measure of the set of accepting states of this composed structure can be computed using accumulation techniques [97].
Reference: [42] <author> E. A. Emerson and J. Y. Halpern. </author> <title> "Sometimes" and "Not Never" Revisited: on Branching versus Linear Time Temporal Logic. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: Emerson and Lei <ref> [42] </ref> have shown that a general form of fairness for which this check can be done in polynomial time is canonical fairness. <p> This amounts to performing path quantification with respect to fair paths. Model checking under canonical fairness constraints is described in <ref> [42] </ref>; the underlying algorithms are very similar to those above. 3.1.3 Language containment Another popular paradigm for verifying finite state systems is language containment.
Reference: [43] <author> Ioannis Emiris. </author> <title> Sparse Elimination and Applications in Kinematics. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: BDD based symbolic techniques have been successful as a heuristic for coping with state explosion; analogs of the BDD such as the ADD of [12], may similarly prove successful in dealing with composed Markov chains. The advent of efficient packages for finding roots of multi-variate polynomial systems <ref> [43] </ref> and fragments of RCF [96] is evidence that model checking general Markov chains may be feasible. 106 Chapter 9 Conclusions We have presented applications of mathematical logic to VLSI design automation.
Reference: [44] <author> H. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: We particularly stressed the notions of formulas, definability, and quantifier elimination. There are many aspects of logic which were not discussed, such as a precise axiomatization for the logic, formal notions of proof, model theoretic results such as compactness, etc. Enderton <ref> [44] </ref> and Monk [85] provide excellent detailed descriptions of these and much more. We then developed formal models for hardware designs specified at the logic level. These took the form of finite state machines and netlists. We discussed issues related to composing designs, and also introduced the concept of fairness. <p> Implications and future work are sketched in Section 7.5. 7.2 The linear logic of IR The linear logic of IR is logistic system concerned with set of real numbers with the operators plus and less than. A detailed treatment is given in <ref> [44] </ref>.
Reference: [45] <author> Steven J. Friedman and Kenneth J. Supowit. </author> <title> Finding the optimal variable ordering for binary decision diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(5) </volume> <pages> 710-713, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: SYMBOLIC METHODS 37 truth table, it is NP-complete to determine if an ordering exists which leads to a BDD of less than a specified size <ref> [45] </ref>. * A BDD representation is canonical; thus comparing two relations for equality is as simple as comparing two pointers. * Representation of the universal relation, and of the relation x i = 0 takes a constant number of nodes. * The BDD for the complement of f can be computed
Reference: [46] <author> J. Fron, J. C.-Y. Yang, M. Damiani, and G. De Micheli. </author> <title> A Synthesis Framework Based on Trace and Automata Theory. </title> <booktitle> In Workshop Notes of Intl. Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: [98, 37, 67, 119, 120, 121]. One attempt at a formal synthesis framework based on trace and automata theory is given in <ref> [46] </ref>. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation.
Reference: [47] <author> H. Fujii, G. Ootomo, and C. Hori. </author> <title> Interleaving Variable Ordering Methods for Ordered Binary Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 38-41, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: One of the limiting factors in performing BDD based verification computations is the size of the BDD for the transition relation. The size of the BDD can critically depend on variable ordering; much work has gone into developing heuristics for variable ordering <ref> [74, 47, 62, 100] </ref>. Below, we describe a heuristic for deriving a variable order which often leads to a small BDD for the transition relation.
Reference: [48] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <year> 1979. </year> <note> BIBLIOGRAPHY 116 </note>
Reference-contexts: A path is fair iff for some i, for each j inf () " A ij 6= ; or inf () B ij . Emerson and Lei also proved by a reduction from 3-CNF-SAT <ref> [48] </ref> that for nontrivial extensions of canonical fairness, simply checking CHAPTER 2. DIGITAL SYSTEMS 25 the existence of a fair path starting at a given state is NP-complete. <p> It should be noted that complementing a nondeterministic finite automaton is inherently a complex operation. This is due to the fact that determining if the complement defines a nonempty language is PSPACE-complete <ref> [48] </ref>; once an automaton defining the complement is constructed, the emptiness check is trivial. Certainly, the worst case need not always occur in practice. We illustrate the construction for the E-machine by means of an example. Consider the design specified in Figure 6.7.
Reference: [49] <author> P. Gray and R. Meyer. </author> <title> Analysis and Design of Analog Integrated Circuits. </title> <publisher> John-Wiley, </publisher> <year> 1993. </year>
Reference: [50] <author> O. Grumberg and D. E. </author> <title> Long. Model Checking and Modular Verification. </title> <editor> In J. C. M. Baeten and J. F. Groote, editors, </editor> <booktitle> Proc. of CONCUR '91: 2nd Inter. Conf. on Con-currency Theory, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: We have applied these ideas to both the language emptiness and model checking paradigms. The formulation for language containment is given in Section 5.1; extensions to model checking are sketched in Section 5.2. Many other compositional strategies exist for forming a reduced product e.g. <ref> [72, 29, 50, 17] </ref>. In the language containment paradigm our primary contribution is defining equivalences in the presence of fairness, and identifying a subset of these that can be easily computed.
Reference: [51] <author> A. Gupta. </author> <title> Formal Hardware Verification Methods: A Survey. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 151-238, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Bryant [23] has recently reported promising results on BDD-like data structures that can represent arithmetical relations on n-bit words efficiently. Similarly, Jones et al. [63] describe techniques for representing designs with uninterpreted functions. BDDs are not the only approach for coping with state explosion. There are many other approaches <ref> [51] </ref>. In the next Chapter we describe an approach that attempts to exploit the property being checked to simplify the design during the verification process. 45 Chapter 5 Compositional Methods In this chapter we present heuristics for verifying compositional designs which attempt to simplify the system prior to performing verification.
Reference: [52] <author> G. D. Hachtel, J.-K. Rho, F. Somenzi, and R. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <booktitle> In Proc. European Conf. on Design Automation, </booktitle> <pages> pages 184-191, </pages> <address> Amsterdam, The Netherlands, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: SYNTHESIZING FINITE STATE MACHINES 76 criteria for optimality such as area, timing, power consumption, etc. One starting point is determining a replacement whose underlying finite state machine is minimum state. Not surprisingly, this is closely related to the problem of minimizing incompletely specified finite state machines <ref> [52] </ref>. However, there is a subtle distinction, in that for incompletely specified finite state machines, for a particular input, any output and/or next-state is allowable. In the context of the E-machine, at a particular state, for a specific input, a subset of all possible outputs and next-states may be allowable.
Reference: [53] <author> H. Hansson and B. Jonsson. </author> <title> A Logic for Reasoning about Time and Reliability. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6 </volume> <pages> 512-535, </pages> <year> 1994. </year>
Reference-contexts: Verification is performed on a fair timed automaton; the proof of correctness is nontrivial due to the density of the underlying model of time. Formulations of quantitative approaches to probabilistic verification also exist. Hansson and Jonsson <ref> [53] </ref> describes an extension of CTL, referred to as PCTL, capable of expressing numerical bounds on the probability of specified properties; it is essentially identical to the logic pCTL defined in Section 8.3.
Reference: [54] <author> C. Harkness and E. Wolf. </author> <title> Verifying the Summit Bus Converter Protocols with Symbolic Model Checking. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4 </volume> <pages> 83-99, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Summary In summary, it can safely be said that the use of symbolic methods has enabled the verification of a regime of designs that was previously impossible. Example of designs that were successfully verified using a BDD based approach include <ref> [19, 78, 26, 54] </ref>. These results underline the importance of an approach which can be easily used by designers. Since model checking can operate on descriptions similar to those which designers build for synthesis and simulation, it is gaining acceptance amongst designers. Additionally, there have been CHAPTER 4.
Reference: [55] <author> D. Harrison, A. R. Newton, R. Spickelmier, and T. J. Barnes. </author> <title> Electronic CAD Frameworks. </title> <journal> Proc. of the IEEE, </journal> <volume> 78(2), </volume> <month> February </month> <year> 1990. </year>
Reference: [56] <author> S. Hart and M. Shamir. </author> <title> Probabilistic Temporal Logics for Finite and Bounded Models. </title> <booktitle> In Proc. ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 1-13, </pages> <year> 1984. </year>
Reference-contexts: In such paradigms, it is proved that verification can be reduced to performing conventional temporal logic analysis on a model with fairness constraints that eliminate events of measure zero; the actual probabilities of events are immaterial. Examples of such approaches are given in <ref> [56, 91, 117, 3] </ref>. Penuli and Zuck [91] introduce the notion CHAPTER 8.
Reference: [57] <author> S. Hart, M. Sharir, and A. Pnueli. </author> <title> Verification of Probabilistic Programs. </title> <journal> SIAM Journal of Computation, </journal> <volume> 13 </volume> <pages> 292-314, </pages> <year> 1984. </year>
Reference-contexts: There is a body of past work on applying formal methods to stochastic systems. An early approach is <ref> [57] </ref> which computes the expected time for a probabilistic program to terminate. Programs are modeled as Markov chains; the techniques are standard in Markov chain theory. [36] describes an approach to the control of finite state Markov chains subject to !-regular specifications.
Reference: [58] <editor> L. Henkin, J. D. Monk, and A. Tarski. Cylindric Algebras. </editor> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1971. </year>
Reference: [59] <author> T. Henzinger. </author> <title> Hybrid Automata with Finite Bisimulations. </title> <booktitle> In Proc. of the Colloquium on Automata, Languages, and Programming, </booktitle> <address> Szeged, Hungary, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: On a more speculative note, we believe that it should be possible to perform a formal analysis of dynamical systems whose evolution over time follows analytic laws. There has been much progress in the understanding of hybrid systems <ref> [59] </ref>; however these systems evolve according to very simple dynamics. The recent seminal results of Wilkie [122] on the decidability of the theory of the reals numbers with plus, times, and exponentiation may be a good starting point for such an analysis.
Reference: [60] <author> Pei-Hsin Ho and Howard Wong-Toi. </author> <title> Automated analysis of an audio control protocol. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <year> 1995. </year> <note> BIBLIOGRAPHY 117 </note>
Reference-contexts: TIMED SYSTEMS 90 7.5 Summary As it stands, the procedure for testing timing-safe replaceability described in this paper is highly inefficient. Part of this complexity is inherent, since the problem is trivially NP-hard (reduction from SAT). Given the existence of highly efficient packages for the linear theory of IR <ref> [60] </ref>, it may be possible to successfully perform the check on medium sized designs; this would cover a fair number of asynchronous modules which tend to be small (10-15 gates). <p> Specifically, comparisons should be made of BDD based algorithms with a careful implementation of the algorithm proposed in Chapter 5. Another application of compositional minimization is the verification of hybrid systems <ref> [60] </ref>; the "region automaton" constructed in the conventional approach has a very large number of states, which contributes heavily to the high complexity of verification. There are other approaches to formal verification that are not covered by the ones given in Chapter 3.
Reference: [61] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The proof proceeds by constructing an automaton for the complement, by first constructing a deterministic Streett automaton accepting the same language, following which complementation is straightforward. The determinization step, while similar in spirit to the subset construction for fl-automata <ref> [61] </ref>, is extremely complex. The best known (and essentially optimum) procedure of Safra [102] starts on a nondeterministic Buchi automaton on n states, and yields an automaton with 2 O (nlog (n)) states in the worst case. CHAPTER 6.
Reference: [62] <author> S.-W. Jeong, B. Plessier, G. D. Hachtel, and F. Somenzi. </author> <title> Variable Ordering for FSM Traversal. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: One of the limiting factors in performing BDD based verification computations is the size of the BDD for the transition relation. The size of the BDD can critically depend on variable ordering; much work has gone into developing heuristics for variable ordering <ref> [74, 47, 62, 100] </ref>. Below, we describe a heuristic for deriving a variable order which often leads to a small BDD for the transition relation.
Reference: [63] <author> Robert B. Jones, David Dill, and Jerry R. Burch. </author> <title> Efficient Validity Checking for Processor Validation. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 2-6, </pages> <year> 1995. </year>
Reference-contexts: Bryant [23] has recently reported promising results on BDD-like data structures that can represent arithmetical relations on n-bit words efficiently. Similarly, Jones et al. <ref> [63] </ref> describe techniques for representing designs with uninterpreted functions. BDDs are not the only approach for coping with state explosion. There are many other approaches [51]. <p> For example, the second order theory of the reals, which superficially at least, is the natural logic for synthesis of timed systems is undecidable by results of Shelah [104]. The challenge then would be to find fragments which are tractable, e.g. <ref> [63] </ref>. There is a deep relationship between synthesis and verification. Some of the theoretical aspects of this nexus are seen in Chapter 6, where we give techniques for synthesizing properties.
Reference: [64] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A Fully Implicit Algorithm for Exact State Minimization. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 684-690, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year>
Reference: [65] <author> Tim Kam. </author> <title> State Minimization of Finite State Machines using Implicit Techniques. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1995. </year>
Reference: [66] <author> Randy Katz. </author> <title> Contemporary logic design. </title> <publisher> Benjamin/Cummings Pub. Co., </publisher> <year> 1993. </year>
Reference: [67] <author> J. Kim and M. M. Newborne. </author> <title> The Simplification of Sequential Machines With Input Restrictions. </title> <journal> IRE Transactions on Electronic Computers, </journal> <pages> pages 1440-1443, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation.
Reference: [68] <author> Phokion G. Kolaitis and Moshe Y. Vardi. </author> <title> Fixpoint logic vs. infinitary logic in finite-model theory. </title> <booktitle> In Proceedings, Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 46-57, </pages> <address> Santa Cruz, California, 22-25 June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: It turns out that there is no such formula; reachability is expressible in existential second order logic. The proof of this makes use of model theory, specifically the upward Lowenheim-Skolem theorem. These issues are studied extensively in fixed point logic <ref> [68] </ref>. 3.1.2 CTL model checking Many interesting properties cannot be expressed as invariants. For example, the class of properties referred to as liveness properties, which assert that certain events can eventually happen cannot be specified in this manner.
Reference: [69] <author> O. Kupferman and M. Vardi. </author> <title> Verification of Fair Transition Systems. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: In particular, we proved that it is the weakest equivalence that preserves the logic CTL fl interpreted on the fair paths [8]. We demonstrated that E fair-bis could be decided in PSPACE, and conjectured that it was also hard for PSPACE; this was recently proved <ref> [69] </ref>. Thus it is not of much help in finding equivalent states. Dill et al. [39] gave techniques for language containment by simulation relations for Buchi automaton. We extend his definitions to obtain conservative approximations to E fair-bis which are polytime computable.
Reference: [70] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year>
Reference-contexts: FORMAL VERIFICATION 32 containment becomes PSPACE-complete [110]; the only known ways require a construction (the subset construction) exponential in the number of states in M P . One approach to avoiding this complexity is the specification of the complement of the property, as is done in the tool COSPAN <ref> [70] </ref>. This takes the form of an FSM M P with an initial state, no outputs, and a fairness constraint f ; an input sequence for which there is a corresponding fair path corresponds to "bad" behavior. <p> For a large class of interesting properties, such reductions are conservative i.e. the property holds of the original design if it is true of the reduced design; however the converse it not necessarily true <ref> [70, 72, 101] </ref>. Intuitively, this class consists of "universal" properties, i.e. properties which make some claim about all computational paths in the design satisfying some constraint. <p> For example, there have been proposals to use a subset of the edges rather than the states; an !-word ff is accepted just in case there is a run corresponding to ff on which the designated edges are visited infinitely often. Similarly, the acceptance condition for L-automata <ref> [70] </ref> consists of a set of subsets of the states; a path is accepting if its infinitary set has a nonempty intersection with at least one subset in this set. Such automata are trivial enhancements of Buchi automata since they can be translated in polynomial time to Buchi automata.
Reference: [71] <author> W. Lam and R. K. Brayton. </author> <title> Timed Boolean Functions A Unified Framework for Exact Timing Analysis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year> <note> BIBLIOGRAPHY 118 </note>
Reference-contexts: Hence a design is a set of implementations with each implementation having a set of fixed delays. Each implementation has a timing behavior, a Boolean function of time (TBF <ref> [71] </ref>) which characterizes for any set of input waveforms the set of output waveforms. A design D 1 will be considered a timing-safe replacement for design D 2 iff every implementation of D 1 is an implementation of D 2 . <p> This is denoted a timed Boolean function (TBF) in <ref> [71] </ref>.
Reference: [72] <author> David E. </author> <title> Long. Model Checking, </title> <type> Abstraction and Compositional Verification . PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: For a large class of interesting properties, such reductions are conservative i.e. the property holds of the original design if it is true of the reduced design; however the converse it not necessarily true <ref> [70, 72, 101] </ref>. Intuitively, this class consists of "universal" properties, i.e. properties which make some claim about all computational paths in the design satisfying some constraint. <p> We have applied these ideas to both the language emptiness and model checking paradigms. The formulation for language containment is given in Section 5.1; extensions to model checking are sketched in Section 5.2. Many other compositional strategies exist for forming a reduced product e.g. <ref> [72, 29, 50, 17] </ref>. In the language containment paradigm our primary contribution is defining equivalences in the presence of fairness, and identifying a subset of these that can be easily computed.
Reference: [73] <author> S. Malik. </author> <title> Analysis of Cyclic Combinational Circuits. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(7) </volume> <pages> 950-956, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Our modeling of hardware in terms of finite state machines is not rich enough; the correct models require knowledge of the ternary behavior of the design <ref> [25, 73, 107] </ref> A Moore netlist is a netlist where there is no path from an input to an output which does not pass through a latch. <p> Note CHAPTER 2. DIGITAL SYSTEMS 23 that some subset of the outputs of a netlist may be driven only by latches, in which case one can define the notion of Moore outputs. Issues related to such netlists have been treated in <ref> [25, 73, 106] </ref>. In this chapter we will assume that we will never encounter combinational cycles. This means we will refer to the composition of designs only when the composition does not create combinational loops.
Reference: [74] <author> S. Malik, A. R. Wang, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Logic Verification using Binary Decision Diagrams in a Logic Synthesis Environment. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 6-9, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: One of the limiting factors in performing BDD based verification computations is the size of the BDD for the transition relation. The size of the BDD can critically depend on variable ordering; much work has gone into developing heuristics for variable ordering <ref> [74, 47, 62, 100] </ref>. Below, we describe a heuristic for deriving a variable order which often leads to a small BDD for the transition relation.
Reference: [75] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [76] <author> Z. Manna and J. Waldinger. </author> <title> Toward automatic program synthesis. </title> <journal> Communications of the ACM, </journal> <volume> 14(3) </volume> <pages> 151-165, </pages> <month> March </month> <year> 1971. </year>
Reference-contexts: As mentioned in the introduction, the term synthesis is used in certain communities to describe the process of taking a logical specification, and checking if there exists a model which satisfies it. The model depends on the context; for example, it could be a Turing machine program <ref> [76] </ref>, a finite state transducer [90], or a dataflow graph [15]. The issues involved in this discipline include decidability, complexity, and expressiveness of the specification language. In this chapter we will be mostly concerned with the optimization problem; we will make the connection to program synthesis in Section 6.5.1.
Reference: [77] <author> P. McGeer, K. McMillan, A. Saldanha, A. Sangiovanni-Vincentelli, and P. Scaglia. </author> <title> Fast Discrete Function Evaluation. </title> <booktitle> In Proc. of the MCNC Intl. Workshop on Logic Synthesis, </booktitle> <volume> volume 1, </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: Since model checking can operate on descriptions similar to those which designers build for synthesis and simulation, it is gaining acceptance amongst designers. Additionally, there have been CHAPTER 4. SYMBOLIC METHODS 44 spin-offs from BDD based ideas that are proving useful in synthesis and simulation, e.g. <ref> [77] </ref>. Progress on BDD technology and BDD techniques is being made on a regular basis [94]. BDD based approaches to verification do have major shortcomings.
Reference: [78] <author> K. L. McMillan and J. Schwalbe. </author> <title> Formal Verification of the Encore Gigamax Cache Consistency Protocols. </title> <booktitle> In International Symposium on Shared Memory Multiprocessors, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: Summary In summary, it can safely be said that the use of symbolic methods has enabled the verification of a regime of designs that was previously impossible. Example of designs that were successfully verified using a BDD based approach include <ref> [19, 78, 26, 54] </ref>. These results underline the importance of an approach which can be easily used by designers. Since model checking can operate on descriptions similar to those which designers build for synthesis and simulation, it is gaining acceptance amongst designers. Additionally, there have been CHAPTER 4.
Reference: [79] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: In this way, BDDs can be viewed as providing a decision procedure for FOE 2 -logic, which heuristically performs well on a number of applications related to verifying netlists. This observation was made independently by a number of researchers <ref> [34, 79, 89, 115] </ref>. 4.1 BDD variable ordering Recall that the graph of the transition function of a netlist can be defined by a formula ffi (x 1 ; x 2 ; : : : ; x n ; u 1 ; u 2 ; : : : ; u k <p> Below, we describe a heuristic for deriving a variable order which often leads to a small BDD for the transition relation. Bounding BDD size McMillan <ref> [79] </ref> proved upper bounds on the size of BDDs for the outputs of Boolean circuits in terms of the number of wires crossing partitions of the gates. This argument is reproduced below. CHAPTER 4. <p> In a design with many latches, iteration over each latch as described above, while being space efficient, is often time consuming. By preconjoining the transition relations of a set of latches we can reduce the number of iterations substantially, while paying a small space penalty. The approach taken in <ref> [95, 79] </ref> is to group together latches, while ensuring that the groups remain tractable.
Reference: [80] <author> C. Mead and L. Conway. </author> <title> An Introduction to VLSI Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference: [81] <author> A. R. Meyer and L. J. Stockmeyer. </author> <title> The equivalence problem for regular expressions with squaring requires exponential space. </title> <booktitle> In Proc. 13th IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 125-129, </pages> <year> 1972. </year>
Reference-contexts: Trace containment: Given netlists ; 0 and states s; s 0 , are the (possibly projected) lan guages L (;s) and L ( 0 ;s 0 ) equal? Complexity: EXPSPACE-complete; hardness follows by a reduction from a word problem, namely universality of regular expressions with exponentiation <ref> [81] </ref>. In each case, the complexity of verifying a compositional design is substantially higher than that of verifying a singe "flattened" component. Summary In this chapter we introduced several paradigms for formal verification of hardware designs specified as netlists.
Reference: [82] <author> Giovanni De Micheli. </author> <title> Synthesis and Optimization of Digital Circuits. </title> <publisher> McGraw Hill, </publisher> <year> 1994. </year>
Reference-contexts: Currently, the central thrust in logic synthesis is sequential synthesis, i.e. the automatic optimization of the entire system. This is for designs specified at the structural level in the form of netlists, or at the behavioral level, i.e. in the form of finite state machines. DiMicheli <ref> [82] </ref> gives an excellent introduction to logic synthesis. Designs invariably consist of a set of interacting components. The environment of a particular component gives rise to a certain amount of flexibility when implementing it; CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 57 this flexibility can be exploited by optimization tools.
Reference: [83] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: This motivates the search for conservative approximations to trace equivalence which are efficiently computable. We first studied the notion of bisimulation <ref> [83] </ref>, which can be viewed as a structural equivalence on the states of an FSM, when there are no fairness constraints. In Section 2.2 we defined bisimulation for different machines; this definition can be massaged to yield an equivalence relation on states of a single FSM.
Reference: [84] <author> R. Milner. </author> <title> Semantics of concurrent processes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science. </booktitle> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1989. </year> <note> BIBLIOGRAPHY 119 </note>
Reference: [85] <author> J. D. Monk. </author> <title> Mathematical Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: We particularly stressed the notions of formulas, definability, and quantifier elimination. There are many aspects of logic which were not discussed, such as a precise axiomatization for the logic, formal notions of proof, model theoretic results such as compactness, etc. Enderton [44] and Monk <ref> [85] </ref> provide excellent detailed descriptions of these and much more. We then developed formal models for hardware designs specified at the logic level. These took the form of finite state machines and netlists. We discussed issues related to composing designs, and also introduced the concept of fairness.
Reference: [86] <author> J. R. Munkres. </author> <title> Topology: A first course. </title> <publisher> Prentice-Hall, </publisher> <year> 1974. </year>
Reference-contexts: The notions of safety and liveness can be made mathematically precise. Observe that there is a natural isomorphism between the set of finite valued ! sequences and the Cantor discontinuum <ref> [86] </ref>. Technically, the class of safety properties is identified with the collection of sets which are closed with respect to the topology of the Cantor discontinuum, and the class of liveness properties is identified with the collection of sets which are dense in the Cantor discontinuum.
Reference: [87] <author> Christos H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The relation is precisely the set of inputs for which the output is 1. Similarly, relations can be represented by formulas in FOE k -logic, or programs on Turing machines. These issues are described in <ref> [16, 87] </ref>. While these representations are compact, the computational complexity of checking elementary properties (such as nonemptiness) of the relation starting from such representations is high. CHAPTER 4.
Reference: [88] <author> A. Paz. </author> <title> Introduction to Probabilistic Automata . Academic-Press, </title> <year> 1971. </year>
Reference-contexts: We also extend the universe of models to include generalized discrete Markov chains which can be used for modeling systems where the transition probabilities are not completely specified; these systems allow notions of abstraction and refinement. Using characterizations of discrete Markov chains developed in <ref> [88] </ref> and results on the decidability of real closed fields (RCF) [14] we derive an elementary decision procedure for model checking pCTL fl over generalized discrete Markov chains. There is a body of past work on applying formal methods to stochastic systems. <p> STOCHASTIC SYSTEMS 104 all rational events of length less than 2n + 1, then in fact their measures are identical. The proof of this fact is nontrivial; see <ref> [88] </ref>. This observation will allow us to reduce deciding tr to deciding validity in RCF. Let G 1 be a GMC such that all Markov chains compatible with G 1 have identical SCC DAGs. Similarly, let G 2 be a GMC with a unique SCC DAG.
Reference: [89] <author> C. Pixley. </author> <title> A Computational Theory and Implementation of Sequential Hardware Equivalence. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Proc. of the Workshop on Computer-Aided Verification, </booktitle> <pages> pages 293-320, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In this way, BDDs can be viewed as providing a decision procedure for FOE 2 -logic, which heuristically performs well on a number of applications related to verifying netlists. This observation was made independently by a number of researchers <ref> [34, 79, 89, 115] </ref>. 4.1 BDD variable ordering Recall that the graph of the transition function of a netlist can be defined by a formula ffi (x 1 ; x 2 ; : : : ; x n ; u 1 ; u 2 ; : : : ; u k
Reference: [90] <author> A. Pnueli and R. Rosner. </author> <title> On the Synthesis of a Reactive Module. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 179-190, </pages> <year> 1989. </year>
Reference-contexts: The model depends on the context; for example, it could be a Turing machine program [76], a finite state transducer <ref> [90] </ref>, or a dataflow graph [15]. The issues involved in this discipline include decidability, complexity, and expressiveness of the specification language. In this chapter we will be mostly concerned with the optimization problem; we will make the connection to program synthesis in Section 6.5.1. <p> More insidiously, for every input there may be an output, but a failure with causality: the component's output at a particular time t may depend on the value of the input at some future time t + k. In <ref> [90] </ref> it is argued that a necessary and sufficient condition for realizability of a language L over V fi U is that a strategy tree must exist for a player observing inputs over v and producing outputs over u while ensuring that the input-output behavior is compatible with the relation C <p> In this Rabin automaton, project the symbols of the alphabet V fi U down to V . Interpret the new structure as a Rabin automaton on trees and check for tree emptiness [92]. As is shown in <ref> [90] </ref>, an implementable controller (a netlist in our context) exists if and only if the tree emptiness check is negative. The algorithm of Pneuli and Rosner [90] derives an implementation if one exists. <p> Interpret the new structure as a Rabin automaton on trees and check for tree emptiness [92]. As is shown in <ref> [90] </ref>, an implementable controller (a netlist in our context) exists if and only if the tree emptiness check is negative. The algorithm of Pneuli and Rosner [90] derives an implementation if one exists. The complexity of this procedure is very high the construction of the deterministic Rabin automaton potentially yields an automaton whose state space is exponential in j S M j, and doubly exponential in j S S j. <p> The complexity of this procedure is very high the construction of the deterministic Rabin automaton potentially yields an automaton whose state space is exponential in j S M j, and doubly exponential in j S S j. Furthermore, the tree-emptiness check is NP complete; the algorithm of <ref> [90] </ref> has complexity polynomial in the number of states and exponential in the number of accepting pairs of the Rabin automaton. 6.6 Summary We have proposed the logic S1S as a formalism to describe permissible behaviors of an FSM interacting with other FSMs.
Reference: [91] <author> A. Pnueli and L. Zuck. </author> <title> Probabilistic verification. </title> <journal> Information and Computation, </journal> <volume> 103(1) </volume> <pages> 1-29, </pages> <year> 1993. </year>
Reference-contexts: In such paradigms, it is proved that verification can be reduced to performing conventional temporal logic analysis on a model with fairness constraints that eliminate events of measure zero; the actual probabilities of events are immaterial. Examples of such approaches are given in <ref> [56, 91, 117, 3] </ref>. Penuli and Zuck [91] introduce the notion CHAPTER 8. <p> Examples of such approaches are given in [56, 91, 117, 3]. Penuli and Zuck <ref> [91] </ref> introduce the notion CHAPTER 8. STOCHASTIC SYSTEMS 93 of ff-fairness; this construct embodies the fact that if a given state is visited infinitely often, then with probability one each state which the given state can make a transition to with nonzero probability is visited infinitely often.
Reference: [92] <author> M. O. Rabin. </author> <title> Automata on Infinite Objects and Church's Problem. </title> <publisher> American Mathematical Society, </publisher> <year> 1971. </year>
Reference-contexts: This is used in Section 6.4, to logically characterize the flexibility that can be used to optimize components in hierarchical designs. CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 58 The relationship to the more classical view of program synthesis in the form of Church's problem <ref> [92] </ref>, automata on trees, and fairness is described in Section 6.5.1. We summarize our contributions in Section 6.6 and suggest a number of ways of extending our results. 6.2 Finite state automata and S1S We start this section by defining finite state automata. <p> This problem was originally posed by Church (see for example <ref> [92] </ref>), and has come to be known as Church's problem. Note that this can be trivially answered in the affirmative when dealing with the optimization problem, since it would suffice to use the original component. When CHAPTER 6. <p> Determinize the automaton C fl to obtain a deterministic Rabin automaton [102]. 2. In this Rabin automaton, project the symbols of the alphabet V fi U down to V . Interpret the new structure as a Rabin automaton on trees and check for tree emptiness <ref> [92] </ref>. As is shown in [90], an implementable controller (a netlist in our context) exists if and only if the tree emptiness check is negative. The algorithm of Pneuli and Rosner [90] derives an implementation if one exists.
Reference: [93] <author> M. O. Rabin. </author> <booktitle> Handbook of Mathematical Logic, chapter Decidable Theories, </booktitle> <pages> pages 595-629. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year> <note> ed. by J. Barwise. </note>
Reference: [94] <author> R. Ranjan, J. Sanghavi, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> High Performance BDD Package Based on Exploiting Memory Hierarchy. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Additionally, there have been CHAPTER 4. SYMBOLIC METHODS 44 spin-offs from BDD based ideas that are proving useful in synthesis and simulation, e.g. [77]. Progress on BDD technology and BDD techniques is being made on a regular basis <ref> [94] </ref>. BDD based approaches to verification do have major shortcomings. For example, there is some evidence that for loosely coupled asynchronous systems, such as cache coherency protocols, careful use of explicit data structures may be superior to BDD based methods [38].
Reference: [95] <author> R. K. Ranjan, A. Aziz, B. Plessier, C. Pixley, and R. K. Brayton. </author> <title> Efficient Formal Design Verification: Data Structure + Algorithms. </title> <booktitle> In Workshop Notes of the Intl. Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: CHAPTER 4. SYMBOLIC METHODS 43 Many researchers have made this observation and have proposed heuristics that make use of this. These ideas are reflected in the work of Ranjan et al. <ref> [95] </ref>, which we describe below. The first observation is that the order in which latches are processed in iterative image computation can be crucial. Intuitively, latches which are strongly coupled with each other should be close in the order of existential quantification. <p> In a design with many latches, iteration over each latch as described above, while being space efficient, is often time consuming. By preconjoining the transition relations of a set of latches we can reduce the number of iterations substantially, while paying a small space penalty. The approach taken in <ref> [95, 79] </ref> is to group together latches, while ensuring that the groups remain tractable.
Reference: [96] <author> Ashutosh Rege. </author> <title> A Toolkit for Algebra and Geometry. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The advent of efficient packages for finding roots of multi-variate polynomial systems [43] and fragments of RCF <ref> [96] </ref> is evidence that model checking general Markov chains may be feasible. 106 Chapter 9 Conclusions We have presented applications of mathematical logic to VLSI design automation.
Reference: [97] <author> D. Revuz. </author> <title> Markov Chains. </title> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: The procedure is based on obtaining a deterministic !-automaton accepting the language defined by the linear specification, and composing it with the Markov chain the measure of the set of accepting states of this composed structure can be computed using accumulation techniques <ref> [97] </ref>. In order to give some intuition for the proof, we demonstrate the result for the pCTL model checking problem. We will abuse notation by implicitly extending the labeling of states to include subformulas true at the states. The model checking procedure proceeds recursively on the subformulas. <p> STOCHASTIC SYSTEMS 97 As is shown in <ref> [97] </ref>, the probability of remaining in S fi ft 3 g starting at (s 1 ; t 1 ) can be computed using accumulation techniques; furthermore this can be done in polynomial time.
Reference: [98] <author> J.-K. Rho, G. Hachtel, and F. Somenzi. </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 418-421, </pages> <month> November </month> <year> 1991. </year> <note> BIBLIOGRAPHY 120 </note>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation.
Reference: [99] <author> H. L. Royden. </author> <title> Real Analysis. </title> <publisher> Macmillan Publishing, </publisher> <year> 1989. </year>
Reference-contexts: The transition probability matrix T yields the probability measure s 0 : C s 0 ! [0; 1]; by the measure extension theorem <ref> [99] </ref>, s 0 : C s 0 ! [0; 1] is well defined.
Reference: [100] <author> R. Rudell. </author> <title> Dynamic Variable Ordering for Binary Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 42-47, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: One of the limiting factors in performing BDD based verification computations is the size of the BDD for the transition relation. The size of the BDD can critically depend on variable ordering; much work has gone into developing heuristics for variable ordering <ref> [74, 47, 62, 100] </ref>. Below, we describe a heuristic for deriving a variable order which often leads to a small BDD for the transition relation. <p> The fact that the variable ordering we derive, while being good for the transition relation, might be bad for compactly representing other relations arising in verification, naturally suggests the use of dynamic reordering <ref> [100] </ref>. In this scheme the program changes the variable ordering during the course of execution. This is done based on the growth in the size of the BDDs. It has the advantages of being robust it does not seek to minimize the size of one BDD over others.
Reference: [101] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property Preserving Simulations. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: For a large class of interesting properties, such reductions are conservative i.e. the property holds of the original design if it is true of the reduced design; however the converse it not necessarily true <ref> [70, 72, 101] </ref>. Intuitively, this class consists of "universal" properties, i.e. properties which make some claim about all computational paths in the design satisfying some constraint.
Reference: [102] <author> Shmuel Safra. </author> <title> Complexity of Automata on Infinite Objects. </title> <type> PhD thesis, </type> <institution> The Weiz-mann Institute of Science, Rehovot, Israel, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: The determinization step, while similar in spirit to the subset construction for fl-automata [61], is extremely complex. The best known (and essentially optimum) procedure of Safra <ref> [102] </ref> starts on a nondeterministic Buchi automaton on n states, and yields an automaton with 2 O (nlog (n)) states in the worst case. CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 62 More ! automata There have been many proposals for finite state automata that define !-languages. <p> Rabin automata arose in the theory of automata on trees. Streett automata were developed as a by-product of an efficient CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 63 fragment of dynamic logic; they play a crucial role in Safra's construction <ref> [102] </ref> for the determinization of Buchi automata. These automata are all "closed under complement", that is the complement of a language defined by such automata is definable by an automaton of the same type. All these automata define exactly the languages that are definable by Buchi automata. <p> The case of 9 is handled by automaton projection, ^ by automaton intersection, and : by automaton complementation. The latter lies at the heart of the proof the (essentially optimal) approach of Safra <ref> [102] </ref> is to first form a deterministic Rabin automaton defining the same language, which is then trivially complemented, and made into a nondeterministic Buchi automaton. WS1S With minor modifications, the formal treatment of !-languages done in S1S can be applied to fl-languages. <p> Determinize the automaton C fl to obtain a deterministic Rabin automaton <ref> [102] </ref>. 2. In this Rabin automaton, project the symbols of the alphabet V fi U down to V . Interpret the new structure as a Rabin automaton on trees and check for tree emptiness [92].
Reference: [103] <author> C.-J. H. Seger and R. E. Bryant. </author> <title> Formal Verification by Symbolic Evaluation of Partially-Ordered Trajectories. </title> <type> Technical Report TR-93-8, </type> <institution> University of British Columbia, Department of Computer Science, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: CHAPTER 3. FORMAL VERIFICATION 34 There are many other approaches which have been taken to formally verifying hardware. As mentioned previously, there are approaches which are rooted in theorem proving [112] which are more expressive, but harder to automate efficiently. Symbolic trajectory evaluation <ref> [103] </ref> is less expressive than CTL, but allows for more efficient verification. The PSPACE completeness of the model checking problem, (often referred to as state explosion) even in its simplest forms, simply reinforces the need for heuristics [18].
Reference: [104] <author> S. Shelah. </author> <title> The Monadic Theory of Order. </title> <journal> Annals of Mathematics, </journal> <volume> 102 </volume> <pages> 379-419, </pages> <year> 1975. </year>
Reference-contexts: Unlike S1S, the logics underlying these problems are undecidable. For example, the second order theory of the reals, which superficially at least, is the natural logic for synthesis of timed systems is undecidable by results of Shelah <ref> [104] </ref>. The challenge then would be to find fragments which are tractable, e.g. [63]. There is a deep relationship between synthesis and verification. Some of the theoretical aspects of this nexus are seen in Chapter 6, where we give techniques for synthesizing properties.
Reference: [105] <author> T. R. Shiple, R. Hojati, A. L. Sangiovanni-Vincentelli, and R. K. Brayton. </author> <title> Heuristic Minimization of BDDs Using Don't Cares. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Even if T is available, it is usually a good idea to simplify it with respect to A before computing the image of A. Simplification of BDDs with respect to a set of care points is an interesting problem in its own right; refer to Shiple et al. <ref> [105] </ref> for a comprehensive study on the subject. Another heuristic is the use of partitioned transition relations; this approach attempts to compute the image without ever computing the full transition relation. <p> When we did, the number of equivalence classes was much larger than when the monitor was used. These experiments were performed using BDDs. We used the knowledge of equivalent states to simplify the BDDs representing the transition relation <ref> [105] </ref>.
Reference: [106] <author> T. R. Shiple, V. Singhal, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Analysis of Combinational Cycles in Sequential Circuits. </title> <booktitle> In Proc. Intl. Symposium on Circuits and Systems, </booktitle> <address> Atlanta, GA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Note CHAPTER 2. DIGITAL SYSTEMS 23 that some subset of the outputs of a netlist may be driven only by latches, in which case one can define the notion of Moore outputs. Issues related to such netlists have been treated in <ref> [25, 73, 106] </ref>. In this chapter we will assume that we will never encounter combinational cycles. This means we will refer to the composition of designs only when the composition does not create combinational loops.
Reference: [107] <author> Thomas R. Shiple. </author> <title> Formal Analysis of Synchronous Hardware. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1996. </year>
Reference-contexts: Our modeling of hardware in terms of finite state machines is not rich enough; the correct models require knowledge of the ternary behavior of the design <ref> [25, 73, 107] </ref> A Moore netlist is a netlist where there is no path from an input to an output which does not pass through a latch. <p> COMPOSITIONAL METHODS 55 property when composed with any environment, and states which will fail the property when composed with any environment, and then perform a conventional bisimulation computation terminating with such states. A detailed exposition is given in <ref> [107] </ref>. Summary In some ways, the results in this chapter bring into question the usefulness of symbolic methods. We have observed that the true state complexity of many design is much less that than the apparent complexity, which is often raised by the presence of datapath.
Reference: [108] <author> Tom Shiple. </author> <type> Personal communication, </type> <year> 1996. </year>
Reference-contexts: The initial ordering has a significant impact on the overall performance, even in the presence of reordering. It CHAPTER 4. SYMBOLIC METHODS 42 has been experimentally determined that the min comm ordering coupled with the use of dynamic reordering leads to the best overall results <ref> [108] </ref>; this is the approach taken by [19]. 4.2 Optimizing image computations Often there is no variable ordering that will lead to a small BDD for the transition relation.
Reference: [109] <author> Vigyan Singhal. </author> <title> Design Replacements for Sequential Circuits. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1996. </year>
Reference-contexts: Conversely, if there were some input on which the composed design had an output differing from that in the original design, there is a surrounding environment which could observe the change and as a result function incorrectly. Following the parlance of Singhal <ref> [109] </ref>, we will refer to implementations satisfying this condition as being "safe replacements" for the component. However, this characterization is not well suited for synthesis; we want a finite structure, on which some kind of algorithmic search for simple solutions can be performed. <p> There is a deep relationship between synthesis and verification. Some of the theoretical aspects of this nexus are seen in Chapter 6, where we give techniques for synthesizing properties. On the more practical front, performing logic synthesis operations such as retim-ing <ref> [109] </ref> on a design can lead to faster verification. Conversely, feedback from verification can be used to drive synthesis. Richer systems The logic of the real numbers with plus and less than was employed in Chapter 7 to characterize the timing functionality of combinational logic circuits.
Reference: [110] <author> A. P. Sistla, M. Y. Vardi, and P. L. Wolper. </author> <title> The Complementation Problem for Buchi Automata, with Applications to Temporal Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year> <note> BIBLIOGRAPHY 121 </note>
Reference-contexts: When the language of M P is projected over inputs, deciding CHAPTER 3. FORMAL VERIFICATION 32 containment becomes PSPACE-complete <ref> [110] </ref>; the only known ways require a construction (the subset construction) exponential in the number of states in M P . One approach to avoiding this complexity is the specification of the complement of the property, as is done in the tool COSPAN [70]. <p> COMPOSITIONAL METHODS 49 5.1.1 Efficiently approximating trace equivalence Deciding if two states in an FSM with fairness are trace equivalent when some inputs have been projected is PSPACE-complete <ref> [110] </ref>. This motivates the search for conservative approximations to trace equivalence which are efficiently computable. We first studied the notion of bisimulation [83], which can be viewed as a structural equivalence on the states of an FSM, when there are no fairness constraints.
Reference: [111] <author> A. Srinivasan, T. Kam, S. Malik, and R. K. Brayton. </author> <title> Algorithms for Discrete Function Manipulation. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 92-95, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: CHAPTER 4. SYMBOLIC METHODS 36 A data structure that can compactly represent a large class of useful relations succinctly, while allowing efficient manipulation of these relations, is the reduced ordered many-valued decision diagram <ref> [111] </ref>. This is an extension on the reduced ordered binary decision diagram [21]. In order to keep the exposition in this chapter simple, we will restrict our attention to binary decision diagrams, while noting that the results immediately generalize to the many-valued case.
Reference: [112] <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We also categorized the precise computational complexity of verification in these paradigms. CHAPTER 3. FORMAL VERIFICATION 34 There are many other approaches which have been taken to formally verifying hardware. As mentioned previously, there are approaches which are rooted in theorem proving <ref> [112] </ref> which are more expressive, but harder to automate efficiently. Symbolic trajectory evaluation [103] is less expressive than CTL, but allows for more efficient verification.
Reference: [113] <author> A. Tarski. </author> <title> Introduction to Logic and to the Methodology of Deductive Sciences. </title> <publisher> Oxford University Press, </publisher> <year> 1965. </year>
Reference: [114] <author> W. Thomas. </author> <title> Automata on Infinite Objects. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 133-191. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: A detailed description of this treatment of properties is available in <ref> [2, 114] </ref>. 3.1 Verification paradigms In this section we describe three approaches that can be used to specify properties of designs. We also describe algorithms for checking these properties. 3.1.1 Invariant checking A very simple yet fundamental verification problem is that of checking invariants. <p> We will then develop S1S which is the logistical system concerned with second order properties of ! with the successor operation. We present a classical theorem of Buchi which shows a surprising relationship between finite state automata and S1S. Thomas <ref> [114] </ref> provides an excellent survey of the material covered in this section. 6.2.1 Finite state automata Finite state automata provide a natural way of formally analyzing dynamical systems in which the output depends on inputs seen in the past, when only a finite amount of information about the past can be <p> S1S provides an extremely powerful mechanism for analyzing and manipulating sequential systems - the expressiveness of logic (conjunction, negation, and quantification) is available to define constraints on sets. Definition 19 The logic S1S (the monadic second order theory of one successor) is a monadic second order logic <ref> [114] </ref>. <p> S1S formulas can be interpreted over the structure consisting of the set of natural numbers, where St is simply t + 1. Formal semantics of S1S can be found in <ref> [114] </ref>; below, we illustrate the interpretation of formulas by means of examples. <p> This can be checked using known algorithms for emptiness of tree automata <ref> [114] </ref>. Given L C fl ( V fi U ) ! , defined by a nondeterministic Buchi automaton over the alphabet V fi U the following is a procedure for determining if a finite state machine C exists which realizes L C fl : 1.
Reference: [115] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In this way, BDDs can be viewed as providing a decision procedure for FOE 2 -logic, which heuristically performs well on a number of applications related to verifying netlists. This observation was made independently by a number of researchers <ref> [34, 79, 89, 115] </ref>. 4.1 BDD variable ordering Recall that the graph of the transition function of a netlist can be defined by a formula ffi (x 1 ; x 2 ; : : : ; x n ; u 1 ; u 2 ; : : : ; u k <p> We artificially constructed several designs according to various interconnection schemes. To compare the effectiveness of our procedure (min comm), we compared it to the approach reported in <ref> [115] </ref>, referred to as (touati heur). In all cases, using a random ordering resulted in space-outs when constructing the BDD. Results are reported in Figure 4.3. In all cases, our method yielded significantly smaller BDDs for the transition relation.
Reference: [116] <author> M. Vardi. </author> <title> Non-traditional Applications of Automata Theory. </title> <booktitle> In Theoretical Aspects of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: Beyond VLSI Many of the ideas that we have put forth in this dissertation have a very broad applicability. For example, there may be applications of the paradigms developed for hardware verification to database query optimization <ref> [116] </ref>. Similarly, results from finite state CHAPTER 9. CONCLUSIONS 110 machine synthesis can be used in control theory [5]; the analysis of stochastic systems may lead to a better understanding of performance optimization. Many engineers and scientists are not aware of the power of logic.
Reference: [117] <author> M. Y. Vardi and P. L. Wolper. </author> <title> An Automata-Theoretic Approach to Program Verification. </title> <booktitle> In Proc. IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-334, </pages> <year> 1986. </year>
Reference-contexts: The design satisfies the property iff its language (possibly projected down to some subset of the inputs and/or outputs) is contained in L P . The property L P could be defined in various ways <ref> [117] </ref>. When it is the language of an FSM M P with an initial state and a Buchi fairness constraint, testing language containment can be performed in polynomial time provided the language of M P is not projected over any inputs. <p> In such paradigms, it is proved that verification can be reduced to performing conventional temporal logic analysis on a model with fairness constraints that eliminate events of measure zero; the actual probabilities of events are immaterial. Examples of such approaches are given in <ref> [56, 91, 117, 3] </ref>. Penuli and Zuck [91] introduce the notion CHAPTER 8. <p> STOCHASTIC SYSTEMS 93 of ff-fairness; this construct embodies the fact that if a given state is visited infinitely often, then with probability one each state which the given state can make a transition to with nonzero probability is visited infinitely often. Vardi and Wolper <ref> [117] </ref> follows an approach in which nondeterministic behavior is differentiated from stochastic behavior. Again, verifying such systems reduces to conventional PLTL checking on a Kripke structure with appropriate fairness constraints, which can be done by automata theoretic techniques.
Reference: [118] <author> Tiziano Villa. </author> <title> Encoding Problems in Logic Synthesis. </title> <type> PhD thesis, </type> <institution> University of Cali-fornia Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1995. </year>
Reference: [119] <author> H.-Y. Wang and R. K. Brayton. </author> <title> Input Don't Care Sequences in FSM Networks. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <year> 1993. </year>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation. <p> Let the result of applying fl to the composition of M and C be ^ff; ^ fi; and ^ ffi. The construction used in Theorem 5 can be applied in this case also, and the result follows immediately. 2 This is essentially the result of Wang <ref> [119] </ref>; the use of S1S logic considerably simplifies the derivation. Again, a closer analysis of the formula C IDC (U; V ) demonstrates that the corresponding automaton has 2 jS M jjS C j states.
Reference: [120] <author> H.-Y. Wang and R. K. Brayton. </author> <title> Permissible Observability Relations in FSM Networks. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation.
Reference: [121] <author> Y. Watanabe and R. K. Brayton. </author> <title> The Maximum Set of Permissible Behaviors for FSM Networks. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <year> 1993. </year> <note> BIBLIOGRAPHY 122 </note>
Reference-contexts: Previous work in the VLSI design automation community related to optimizing interacting sequential designs has tended to be ad hoc and/or incomplete. The constructions and proofs offered are often extremely cumbersome. This is witnessed in a number of previous papers: <ref> [98, 37, 67, 119, 120, 121] </ref>. One attempt at a formal synthesis framework based on trace and automata theory is given in [46]. However, the central theorem relating flexibility in a subcircuit to the specification and the environment is incorrect; we give the correct formulation. <p> In this section, we will show that the flexibility available for sequential synthesis can be characterized using a fl-automaton; in the next section we show how this structure is good for synthesis. This result was previously shown by Watanabe <ref> [121] </ref>, who referred to this automaton as the E-machine, the "E" standing for environment. His approach was based on CHAPTER 6. SYNTHESIZING FINITE STATE MACHINES 68 examining the design on a state-by-state basis; we derive this result using S1S. <p> In the context of the E-machine, at a particular state, for a specific input, a subset of all possible outputs and next-states may be allowable. This makes the problem of finding state minimal finite state machines compatible with a specification more difficult; Watanabe <ref> [121] </ref> describes a procedure for the same. Approximations to the full set of safe replacements We now again consider optimization of a compositional design with feedback as in will help us better understand previous work. Furthermore, the subsets are better suited for optimization.
Reference: [122] <author> A. J. Wilkie. </author> <title> On the Decidability of the Real Exponential Field. </title> <booktitle> In Conference on Order in Algebra and Logic, </booktitle> <address> Oxford, UK, </address> <year> 1995. </year>
Reference-contexts: There has been much progress in the understanding of hybrid systems [59]; however these systems evolve according to very simple dynamics. The recent seminal results of Wilkie <ref> [122] </ref> on the decidability of the theory of the reals numbers with plus, times, and exponentiation may be a good starting point for such an analysis. In Chapter 8 we devised a logic for specifying properties of discrete time stochastic systems.
Reference: [123] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Computation (formerly Information and Control), </journal> <volume> 56, </volume> <year> 1983. </year>
Reference-contexts: An example of the former is the property stating that a particular output is high at each even time step; an example of the latter is initializability. Wolper <ref> [123] </ref> describes the exact trade-offs involved. As we saw in Section 2.2, a language can be associated with an FSM with a specified initial state. In the language containment paradigm in its most general form, the property is a language L P .
References-found: 123

