URL: ftp://ftp.cs.cmu.edu/user/mootaz/papers/podc95.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/mootaz/ftp/html/pub.html
Root-URL: 
Email: mootaz@cs.cmu.edu  
Title: On the Relevance of Communication Costs of Rollback-Recovery Protocols  
Author: E.N. Elnozahy 
Address: Pittsburgh, PA 15213, USA  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: Communication overhead has been traditionally the primary metric for evaluating rollback-recovery protocols. This paper reexamines the prominence of this metric in light of the recent increases in processor and network speeds. We introduce a new recovery algorithm for a family of rollback-recovery protocols based on logging. The new algorithm incurs a higher communication overhead during recovery than previous algorithms, but it requires less access to stable storage and imposes no restrictions on the execution of live processes. Experimental results show that the new algorithm performs better than one that is optimized for low communication overhead. These results suggest that in modern environments, latency in accessing stable storage and intrusion of a particular algorithm on the execution of live processes are more important than the number of messages exchanged during recovery. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. </author> <title> Alvisi. </title> <type> Private communication, </type> <month> February </month> <year> 1995. </year>
Reference-contexts: The Manetho protocol requires that live processes refrain from accepting certain application messages while recovery is ongoing, and requires some synchronous logging to stable storage during recovery. The protocol published by Alvisi and Marzullo requires blocking the live processes to ensure safety <ref> [1] </ref>. This is an unfortunate fact, because FBL protocols go to a great length to protect live processes from becoming orphans. The new recovery algorithm presented in this paper solves this problem.
Reference: [2] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proceedings of the 23rd International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: The algorithm can be used in several rollback-recovery protocols based on logging. It does not depend on the particular technique used to gather dependency information during failure-free operation. To demonstrate this, we present the algorithm in the context of the Family-Based Logging protocols <ref> [2, 3, 4] </ref>. This family of protocols is a parameterized presentation of a set of recovery protocols that differ in the degree of failures they tolerate. We will describe the salient features of this protocol family as they relate to the purpose of this paper. <p> We review related work in Section 6 and conclude in Section 7. 2 Family-Based Logging Protocols We assume a distributed, asynchronous system where deterministic processes may fail by crashing. The new recovery algorithm is explained in the context of the Family Based Logging protocols (FBL) <ref> [2, 3, 4] </ref>. These protocols are based on a simple idea: To tolerate f process failures in a rollback-recovery system, it is sufficient to log each message in the volatile store of its sender and to log its receipt order in the volatile store of f + 1 different hosts. <p> The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies [8]. The protocol is designed to tolerate an arbitrary number of failures. FBL protocols introduced a family of parameterized logging protocols that can tolerate a variable number of failures <ref> [2, 3, 4] </ref>. Thus, the application pays only the price of providing the desired degree of fault tolerance. These protocols combine the advantages of pessimistic and optimistic protocols.
Reference: [3] <author> L. Alvisi and K. Marzullo. </author> <title> Message logging: Pessimistic, optimistic, causal and optimal. </title> <booktitle> In Proceed ings of the 15th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: The algorithm can be used in several rollback-recovery protocols based on logging. It does not depend on the particular technique used to gather dependency information during failure-free operation. To demonstrate this, we present the algorithm in the context of the Family-Based Logging protocols <ref> [2, 3, 4] </ref>. This family of protocols is a parameterized presentation of a set of recovery protocols that differ in the degree of failures they tolerate. We will describe the salient features of this protocol family as they relate to the purpose of this paper. <p> We review related work in Section 6 and conclude in Section 7. 2 Family-Based Logging Protocols We assume a distributed, asynchronous system where deterministic processes may fail by crashing. The new recovery algorithm is explained in the context of the Family Based Logging protocols (FBL) <ref> [2, 3, 4] </ref>. These protocols are based on a simple idea: To tolerate f process failures in a rollback-recovery system, it is sufficient to log each message in the volatile store of its sender and to log its receipt order in the volatile store of f + 1 different hosts. <p> The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies [8]. The protocol is designed to tolerate an arbitrary number of failures. FBL protocols introduced a family of parameterized logging protocols that can tolerate a variable number of failures <ref> [2, 3, 4] </ref>. Thus, the application pays only the price of providing the desired degree of fault tolerance. These protocols combine the advantages of pessimistic and optimistic protocols.
Reference: [4] <author> L. Alvisi and K. Marzullo. </author> <title> Trade-offs in implementing optimal message logging protocols. </title> <booktitle> In Submitted to the International Symposium on Fault Tolerant Computing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: The algorithm can be used in several rollback-recovery protocols based on logging. It does not depend on the particular technique used to gather dependency information during failure-free operation. To demonstrate this, we present the algorithm in the context of the Family-Based Logging protocols <ref> [2, 3, 4] </ref>. This family of protocols is a parameterized presentation of a set of recovery protocols that differ in the degree of failures they tolerate. We will describe the salient features of this protocol family as they relate to the purpose of this paper. <p> We review related work in Section 6 and conclude in Section 7. 2 Family-Based Logging Protocols We assume a distributed, asynchronous system where deterministic processes may fail by crashing. The new recovery algorithm is explained in the context of the Family Based Logging protocols (FBL) <ref> [2, 3, 4] </ref>. These protocols are based on a simple idea: To tolerate f process failures in a rollback-recovery system, it is sufficient to log each message in the volatile store of its sender and to log its receipt order in the volatile store of f + 1 different hosts. <p> Therefore, the receipt order of m need not be propagated further than r for f = 2 in the example shown in Figure 1. The actual protocol is more complicated than this simple description implies, and the reader is referred to the appropriate reference for a full explanation <ref> [4] </ref>. Now, consider what happens when process p fails. To recover to a state consistent with the rest of the system, process p needs to receive message m in the same order as before the failure. <p> from its sender, and because the execution is deterministic, it will reproduce m 0 for the benefit of the recovery of process q. 2.2 Protocol Intrusion and its Effects The recovery algorithm presented in the original description of FBL protocols requires live processes to block while recovery is in progress <ref> [4] </ref>. This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property [8, 9, 10, 12, 13, 16, 17]. <p> It could take the form of dependency vectors [17], a dependency matrix <ref> [4, 12] </ref>, or a dependency graph [8]. R: The set of failed processes that are recovering simulta neously with the process. L: The set of live processes. ord: A system-wide monotonic number that is incremented whenever a process starts recovery. <p> After gathering all the depinfo data, the recovery leader sends it to each recovering process. The recovering processes use this data to replay the execution and recover to a consistent state <ref> [4] </ref>. If a live process fails before replying to the recovery leader, the latter restarts the gathering of the depinfo data by resending the depinfo request after updating incvec-tor. This step ensures that the recovery leader gathers a consistent snapshot of the depinfo data despite concurrent failures during recovery. <p> The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies [8]. The protocol is designed to tolerate an arbitrary number of failures. FBL protocols introduced a family of parameterized logging protocols that can tolerate a variable number of failures <ref> [2, 3, 4] </ref>. Thus, the application pays only the price of providing the desired degree of fault tolerance. These protocols combine the advantages of pessimistic and optimistic protocols.
Reference: [5] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation <ref> [5, 15] </ref>. A new generation of protocols emerged that combine the advantages of both classes without the disadvantage. The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies [8]. The protocol is designed to tolerate an arbitrary number of failures.
Reference: [6] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> Febru-ary </month> <year> 1985. </year>
Reference: [7] <author> E.N. Elnozahy. Manetho: </author> <title> Fault Tolerance in Distributed Systems Using Rollback-Recovery and Process Replication. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> October </month> <year> 1993. </year> <note> Also available as technical report TR-93-212. </note>
Reference-contexts: Second, the implementation of such a protocol requires non-trivial modifications to the communication protocol to recognize the potentially unsafe messages <ref> [7] </ref>. A complex implementation reduces the performance of the communication subsystem during failure-free operation and reduces the confidence in its robustness. To appreciate the effect of intrusion on live processes, consider again the example shown in Figure 1.
Reference: [8] <author> E.N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback, and fast output commit. </title> <journal> IEEE Transactions on Computers Special Issue On Fault-Tolerant Computing, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: They can be thought of as a parameterized generalization over previous rollback-recovery protocols. For example, the instance of FBL where f = 1 corresponds to a variation on Sender-Based Message Logging [11], while the instance where f = n corresponds to the Manetho protocol <ref> [8] </ref>. For this reason, we picked FBL to ensure the generality of the results presented here. 2.1 An Example To illustrate the operation of FBL protocols, consider the example shown in Figure 1. In this example, there are three processes p, q and r represented by the vertical lines. <p> This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> For example, one protocol simply blocks the execution of the entire system pending the outcome of the recovery phase [12]. Another protocol prevents live processes from accepting any application message that could potentially create an inconsistency with its reply to a recovering process until the latter completes recovery <ref> [8] </ref>. Furthermore, this protocol requires each live process to record its replies to recovery requests on stable storage before it can send them, introducing further delays. <p> It does not depend on the particular method used to propagate and maintain the receipt orders of the messages during failure-free operation. Thus the results are applicable to other protocols which are instances of FBL <ref> [8, 11, 13] </ref>. 3 The New Algorithm 3.1 Rationale and Motivations A recovering process needs a consistent snapshot of the message receipt order information that is scattered throughout the system. This snapshot should be consistent despite failures that may occur during recovery. <p> It could take the form of dependency vectors [17], a dependency matrix [4, 12], or a dependency graph <ref> [8] </ref>. R: The set of failed processes that are recovering simulta neously with the process. L: The set of live processes. ord: A system-wide monotonic number that is incremented whenever a process starts recovery. <p> A new generation of protocols emerged that combine the advantages of both classes without the disadvantage. The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies <ref> [8] </ref>. The protocol is designed to tolerate an arbitrary number of failures. FBL protocols introduced a family of parameterized logging protocols that can tolerate a variable number of failures [2, 3, 4]. Thus, the application pays only the price of providing the desired degree of fault tolerance.
Reference: [9] <author> P. Jalote. </author> <title> Fault tolerant processes. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 187-195, </pages> <year> 1989. </year>
Reference-contexts: This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 .
Reference: [10] <author> D.B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic [17]. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans <ref> [10, 12, 13, 16, 17] </ref>. Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation [5, 15].
Reference: [11] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Proceedings of the 17th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In summary, FBL protocols have the low-overhead properties of optimistic protocols without having to make any optimistic assumptions. They can be thought of as a parameterized generalization over previous rollback-recovery protocols. For example, the instance of FBL where f = 1 corresponds to a variation on Sender-Based Message Logging <ref> [11] </ref>, while the instance where f = n corresponds to the Manetho protocol [8]. For this reason, we picked FBL to ensure the generality of the results presented here. 2.1 An Example To illustrate the operation of FBL protocols, consider the example shown in Figure 1. <p> It does not depend on the particular method used to propagate and maintain the receipt orders of the messages during failure-free operation. Thus the results are applicable to other protocols which are instances of FBL <ref> [8, 11, 13] </ref>. 3 The New Algorithm 3.1 Rationale and Motivations A recovering process needs a consistent snapshot of the message receipt order information that is scattered throughout the system. This snapshot should be consistent despite failures that may occur during recovery.
Reference: [12] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 171-181, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> The fundamental problem here is that failures that occur during recovery may throw the system into an inconsistent state. Previous protocols resorted to different ways to solve this problem. For example, one protocol simply blocks the execution of the entire system pending the outcome of the recovery phase <ref> [12] </ref>. Another protocol prevents live processes from accepting any application message that could potentially create an inconsistency with its reply to a recovering process until the latter completes recovery [8]. <p> It could take the form of dependency vectors [17], a dependency matrix <ref> [4, 12] </ref>, or a dependency graph [8]. R: The set of failed processes that are recovering simulta neously with the process. L: The set of live processes. ord: A system-wide monotonic number that is incremented whenever a process starts recovery. <p> The extra communication overhead required by the second phase of the new algorithm was negligible (about milliseconds) compared to the time that required for failure detection and to restore the state of the second process. 6 Related Work Rollback-recovery protocols based on logging have been the subject of active research <ref> [12, 13, 16, 17] </ref>. Most of this work has focused on the behavior of the system during failure-free operation, motivated by the understandable desire to optimize the performance for the most common case. Little is understood about the behavior of these protocols during failures. <p> Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic [17]. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans <ref> [10, 12, 13, 16, 17] </ref>. Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation [5, 15].
Reference: [13] <author> T. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 454-461, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> It does not depend on the particular method used to propagate and maintain the receipt orders of the messages during failure-free operation. Thus the results are applicable to other protocols which are instances of FBL <ref> [8, 11, 13] </ref>. 3 The New Algorithm 3.1 Rationale and Motivations A recovering process needs a consistent snapshot of the message receipt order information that is scattered throughout the system. This snapshot should be consistent despite failures that may occur during recovery. <p> The extra communication overhead required by the second phase of the new algorithm was negligible (about milliseconds) compared to the time that required for failure detection and to restore the state of the second process. 6 Related Work Rollback-recovery protocols based on logging have been the subject of active research <ref> [12, 13, 16, 17] </ref>. Most of this work has focused on the behavior of the system during failure-free operation, motivated by the understandable desire to optimize the performance for the most common case. Little is understood about the behavior of these protocols during failures. <p> Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic [17]. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans <ref> [10, 12, 13, 16, 17] </ref>. Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation [5, 15].
Reference: [14] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> Septem-ber </month> <year> 1979. </year>
Reference-contexts: q.incarnation; 5. for each process q 2 L do if q failed then goto 4; depinfo q.depinfo; q.incvector incvector; 6. for each process q 2 R do q.depinfo depinfo; 4 Correctness Proof 4.1 Definitions A message m is an antecedent of message m 0 if m happens before m 0 <ref> [14] </ref>. Message m 0 is also called a descendent of m. there exists a live process that received it. 4.2 Termination The algorithm restarts whenever a live process fails before responding to the recovery leader's depinfo request.
Reference: [15] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 100-109, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation <ref> [5, 15] </ref>. A new generation of protocols emerged that combine the advantages of both classes without the disadvantage. The Manetho protocol protects the live processes from the effect of failures without incurring large overhead to track dependencies [8]. The protocol is designed to tolerate an arbitrary number of failures.
Reference: [16] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The cost of communications has been traditionally the primary metric for evaluating distributed rollback-recovery protocols <ref> [16, 17] </ref>. This cost is typically expressed as a function of the number of nodes in the system, describing the number of required messages and their sizes. <p> This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> The extra communication overhead required by the second phase of the new algorithm was negligible (about milliseconds) compared to the time that required for failure detection and to restore the state of the second process. 6 Related Work Rollback-recovery protocols based on logging have been the subject of active research <ref> [12, 13, 16, 17] </ref>. Most of this work has focused on the behavior of the system during failure-free operation, motivated by the understandable desire to optimize the performance for the most common case. Little is understood about the behavior of these protocols during failures. <p> Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic [17]. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans <ref> [10, 12, 13, 16, 17] </ref>. Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation [5, 15].
Reference: [17] <author> R.E. Strom and S.A. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: 1 Introduction The cost of communications has been traditionally the primary metric for evaluating distributed rollback-recovery protocols <ref> [16, 17] </ref>. This cost is typically expressed as a function of the number of nodes in the system, describing the number of required messages and their sizes. <p> Examples of these secondary factors include the cost of accessing stable storage during recovery, whether a protocol requires live processes to block or refrain from exchanging messages during recovery, and whether a failure may result in some live processes becoming orphans <ref> [17] </ref>. fl Author was supported in part by the National Science Foundation under grants CCR 9410116 and CCR 9502933, and by the Advanced Research Project Agency under contract DABT63-93-C-0054. The views in this paper do not necessarily reflect those of the sponsors. <p> Therefore, applications pay only the overhead that corresponds to the number of failures they are willing to tolerate. Second, FBL protocols protect the live processes from the effects of failures. Specifically, no live process becomes an orphan because of a failure in another process <ref> [17] </ref>. Third, FBL protocols do not require any blocking during failure-free operation, thereby reducing the performance overhead. In summary, FBL protocols have the low-overhead properties of optimistic protocols without having to make any optimistic assumptions. They can be thought of as a parameterized generalization over previous rollback-recovery protocols. <p> This intrusion has the undesirable property of increasing the relative cost of a process failure and its impact on application performance. Many published protocols for rollback-recovery based on logging share this undesirable property <ref> [8, 9, 10, 12, 13, 16, 17] </ref>. To see why this intrusion is necessary, consider the example in Figure 1. Assume that process p fails after sending message m 0 . <p> It could take the form of dependency vectors <ref> [17] </ref>, a dependency matrix [4, 12], or a dependency graph [8]. R: The set of failed processes that are recovering simulta neously with the process. L: The set of live processes. ord: A system-wide monotonic number that is incremented whenever a process starts recovery. <p> The extra communication overhead required by the second phase of the new algorithm was negligible (about milliseconds) compared to the time that required for failure detection and to restore the state of the second process. 6 Related Work Rollback-recovery protocols based on logging have been the subject of active research <ref> [12, 13, 16, 17] </ref>. Most of this work has focused on the behavior of the system during failure-free operation, motivated by the understandable desire to optimize the performance for the most common case. Little is understood about the behavior of these protocols during failures. <p> Furthermore, a live process need not perform a synchronous write operation on stable storage during recovery as many recovery protocols require. Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic <ref> [17] </ref>. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans [10, 12, 13, 16, 17]. <p> Rollback-recovery protocols based on logging have been long classified as either optimistic or pessimistic [17]. Optimistic protocols reduce the overhead of tracking dependencies during failure-free operation at the expense of complicating recovery and the potential for processes that survive failures to become orphans <ref> [10, 12, 13, 16, 17] </ref>. Pessimistic protocols, on the other hand, simplify recovery and insulate live processes from the effects of failures, at the expense of higher overhead for dependency tracking during failure-free operation [5, 15].
References-found: 17

