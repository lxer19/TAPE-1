URL: ftp://ftp.cs.cmu.edu/project/mach/doc/published/multiserver_interface.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/mach/public/www/doc/publications.html
Root-URL: 
Email: pjg@osf.org dpj@cs.cmu.edu  
Title: Object-Oriented Interfaces in the Mach 3.0 Multi-Server System  
Author: Paulo Guedes Daniel P. Julin 
Address: Cambridge, MA 02142 Pittsburgh, PA 15213  
Affiliation: OSF Research Institute School of Computer Science 11 Cambridge Center Carnegie Mellon University  
Abstract: The Mach 3.0 multi-server system decomposes the functionality of the operating system between a micro-kernel, a set of system servers running in user-mode and an emulation library executing in the address space of applications. The interfaces provided by the system servers are object-oriented and both the servers and the emulation library are written in an object-oriented language. In this paper we present how the interfaces between the components are specified and implemented to guarantee consistency and early detection of errors, yet maintaining the flexibility to extend and configure the system by adding new or modified servers without affecting existing pieces. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Herrmann, F. Armand, M.Rozier, M. Gien, V. Abrossimov, I. Boule, M. Guillemont, P. Leonard, S. Langlois and W. Neuhauser, </author> <title> Chorus, a New Technology for Building UNIX Systems, </title> <booktitle> Proceedings of EUUG Autumn, </booktitle> <address> Cascais (Portugal) October 1988. </address>
Reference-contexts: 1 Introduction A current trend in operating system design is to attempt to distribute the complete system functionality between a micro-kernel and a set of system servers executing in user mode and communicating by message exchange <ref> [6, 1] </ref>. This approach provides a clean separation between the different parts of the system, thus easing their development, maintenance and extension. Most of the operating system functionality is provided by the servers and can be developed and tested like any user application.
Reference: [2] <author> P. Guedes, D. Julin, </author> <title> Writing the Mach 3 Multi-Server System in C++, </title> <booktitle> Design review of the Research Institute, Open Software Foundation, </booktitle> <month> Feb </month> <year> 1991. </year>
Reference-contexts: contains many other classes used for naming, authentication, buffer management, etc. and covers several other aspects, such as a C++ remote invocation package on top of Mach IPC, garbage-collection of objects between clients and servers and a mechanism for dynamic type conversion, which are outside the scope of this paper <ref> [2] </ref>. The basic structure of the library is as follows: a hierarchy of abstract C++ classes defines the interfaces to the various items; this hierarchy is shadowed in the client and in the server side by similar hierarchies with the classes that implement those interfaces.
Reference: [3] <author> D. Julin and R. Rashid, MachObjects, </author> <title> Internal document, Mach project, </title> <institution> Carnegie Mellon University, </institution> <year> 1989. </year>
Reference-contexts: As a result, the actual communication code is well separated from the code of the clients themselves. The service and the emulation layers were initially written in an object-oriented environment called MachObjects <ref> [3] </ref>, consisting of a package of C macros and library routines, and providing dynamic typed objects, delegation, default methods and a generic, transparent RPC mechanism. A partial prototype written in C++ is under development.
Reference: [4] <author> Keith Loepere, Ed. </author> <title> Mach 3 Kernel Interface, </title> <institution> Open Software Foundation and Carnegie Mellon University, </institution> <year> 1990. </year>
Reference-contexts: The current prototype provides binary compatibility with UNIX 1 BS-D 4.3. There are three major layers (see Figure 1.). At the bottom is a standard Mach 3.0 micro-kernel, providing the basic Mach abstractions: virtual memory management, inter-process communication, task management and device handling <ref> [4] </ref>. Next comes a collection of mostly generic servers executing as tasks in user mode, that implement all the high-level functionality required of a complete operating system, independent of any given system's interface: file management, process management, networking, etc.
Reference: [5] <author> Bruce Martin, </author> <title> The Separation of Interface and Implementation in C++, </title> <booktitle> Proceedings of Usenix C++ Conference, </booktitle> <address> Washington, D.C., </address> <month> April 22-25, </month> <year> 1991. </year>
Reference: [6] <author> R. Rashid, R. Baron, A. Forin, D. Golub, M. Jones, D. Julin, D. Orr, and R. Sanzi. </author> <title> Mach: A foundation for open systems, </title> <booktitle> Proceedings of the Second Workshop on Workstation Operating Systems, </booktitle> <pages> pages 109-113. </pages> <publisher> IEEE Computer Society, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: 1 Introduction A current trend in operating system design is to attempt to distribute the complete system functionality between a micro-kernel and a set of system servers executing in user mode and communicating by message exchange <ref> [6, 1] </ref>. This approach provides a clean separation between the different parts of the system, thus easing their development, maintenance and extension. Most of the operating system functionality is provided by the servers and can be developed and tested like any user application.
Reference: [7] <author> M. Shapiro, </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle, </title> <booktitle> Proceedings of the 6th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 198-204, </pages> <address> Cambridge, MA (USA), </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Communication between the emulation library and the servers, and between the servers, primarily uses Mach IPC, but optimized mechanisms such as shared memory and file mapping are also available. Those low-level communication facilities are accessed through special proxy objects <ref> [7] </ref> loaded within the address spaces of clients, that act as representatives for each server-side object with each particular client. As a result, the actual communication code is well separated from the code of the clients themselves.
Reference: [8] <author> D. Julin, J. Chew, P. Guedes, P. Neves, P. Roy and M. Stevenson, </author> <title> Generalized Emulation Services for Mach 3.0 Overview, Experiences and Current Status, </title> <booktitle> To appear in Proceedings of Usenix Mach Symposium, </booktitle> <address> Monterey, CA., Nov 20-22, </address> <year> 1991. </year>
Reference-contexts: to guarantee consistency and early detection of errors, yet the system is flexible enough to allow independent development of its components and can be extended and configured by adding new or modified servers without affecting other servers or the emulation library. 2 Architecture The "multi-server emulation system" for Mach 3.0 <ref> [8] </ref> is a research system that combines the use of several independent servers and an object-oriented approach. The primary goal of the project is to provide a generic architecture for the emulation of different operating systems. The current prototype provides binary compatibility with UNIX 1 BS-D 4.3.
References-found: 8

