URL: http://www.cs.ucsb.edu/~osuif/osuif/public/j2s.ps
Refering-URL: http://www.cs.ucsb.edu/~osuif/
Root-URL: http://www.cs.ucsb.edu
Email: fkienle,ursg@cs.ucsb.edu  
Title: j2s: A SUIF Java Compiler  
Author: Holger Kienle and Urs Holzle 
Address: Santa Barbara  
Affiliation: University of California,  
Abstract: We give a short overview of the Java bytecode-to-SUIF compiler that is currently being developed at UCSB. The goal of the compiler is to support the complete Java language specification, based on SUIF 2.0 and OSUIF. We expect to have a version of the compiler that is ready for release to the public at about the end of '97. 
Abstract-found: 1
Intro-found: 1
Reference: [BDW] <institution> Boehm-Demers-Weiser garbage collector. </institution> <note> URL: http://reality.sgi.com/boehm/gc.html. </note>
Reference-contexts: It operates on the control flow graph of the resolver. As the next step garbage collection will be supported. We plan to use a conservative garbage collector (e.g., the freely available Boehm-Demers-Weiser GC <ref> [BDW] </ref>) as a first approach. Furthermore, OSUIF optimization passes can be written that especially improve the code quality of object-oriented features. OSUIF passes are usually generic, which means that they can be used without modification to optimize OSUIF code that has been generated from other source languages.
Reference: [Bot97] <author> Per Bother. </author> <title> A Gcc-based Java implementation. </title> <booktitle> IEEE Compcon, </booktitle> <year> 1997. </year>
Reference-contexts: It includes a Java bytecode to C compiler that seems to cover the whole Java language specification. Harissa [MMBC97] tries to reconcile JIT and off-line compilers by permitting to mix compiled and interpreted code. Cygnus Solutions is developing a gcc-based Java implementation <ref> [Bot97] </ref>. A new gcc front-end, cc1java, translates Java bytecode or Java source to the intermediate representation of gcc [Sta96]. Colorado State University is developing a Java front-end for the SUIF 1.0 compiler system [MDG97]. Ironically, but not too surprisingly, they are calling it j2s as well.
Reference: [Cif96] <author> Cristina Cifuentes. </author> <title> Structuring decompiled graphs. </title> <booktitle> Lecture Notes in Computer Science Vol. 1060 | Compiler Construction, </booktitle> <pages> pages 91 - 105, </pages> <year> 1996. </year>
Reference-contexts: The optimization pass for short-circuit operators looks for certain patterns in the control flow graph that correspond to short-circuit evaluations of expressions. Our technique is similar to the one described in <ref> [Cif96] </ref>. The goto elimination pass checks first whether the control flow graph is reducible. If it is, we recover high-level constructs from the flow-graph. This step involves a transforma tion from the control flow graph to the state-ment list representation.
Reference: [CL97] <author> Michael Cierniak and Wei Li. Briki: </author> <title> An optimizing Java compiler. </title> <booktitle> IEEE Compcon, </booktitle> <month> February </month> <year> 1997. </year>
Reference-contexts: Mocha [vV] and Krakatoa [PW97] are Java bytecode to Java source decompilers. CACAO [KG97] and Briki <ref> [CL97] </ref> are both JIT-compilers for Java bytecode. Toba [PTB + 97] is a system for generating stand-alone Java applications developed at the University of Arizona. It includes a Java bytecode to C compiler that seems to cover the whole Java language specification.
Reference: [DCI + 97] <author> Andrew Duncan, Bog-dan Cocosel, Costin Iancu, Holger Kienle, Radu Rugina, Urs Holzle, and Martin Rinard. OSUIF: </author> <title> SUIF with objects. </title> <booktitle> Second SUIF Compiler Workshop, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: The SUIF 2.0 compiler infrastructure is part of the National Compiler Infrastructure project [NCI]. As part of this project, UCSB is building additional functionality for object-oriented languages on top of SUIF 2.0. This extended compiler system is called Object SUIF (OSUIF) <ref> [DCI + 97] </ref>. The idea of OSUIF is to provide a standardized library that allows researchers to express object-oriented behavior in SUIF, thus providing a framework that makes it possible to share optimizations that are specific to object-oriented languages.
Reference: [GHJV94] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlis-sides. </author> <title> Design Patterns Elements of Reusable Object-Oriented Soft--ware. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The only component that is kept in its original representation is the bytecode array, but the implementation hides this from the programmer by providing a bytecode iterator and various bytecode visitors <ref> [GHJV94] </ref>. The byte-code iterator traverses the bytecode array sequentially and calls for every bytecode the corresponding (virtual) method of the visitor. For example, the resolver makes use of this mechanism by subclassing a print visitor from the 2 Actually it is just a "type list." abstract visitor class.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: It is planned that j2s will eventually become part of the SUIF distribution. The goal of the compiler is to support the complete Java language specification <ref> [GJS96] </ref>. This requires the implementation of a run-time environment that includes garbage collection, threads, exception handling, Java monitors, object creation/finalization, class initialization, etc. The remaining sections are organized as follows. Section 2 discusses the j2s compiler in detail. Section 3 describes first experiences with SUIF 2.0. <p> The remaining sections are organized as follows. Section 2 discusses the j2s compiler in detail. Section 3 describes first experiences with SUIF 2.0. Section 4 gives the current status and future work of the project. We assume that the reader is familiar with Java <ref> [GJS96] </ref> and the Java Virtual Machine (JVM) [LY96], as well as the SUIF 1.0 and SUIF 2.0 compiler systems. 2 The j2s Compiler The j2s compiler expects a valid 1 Java class file (not Java source), analyzes the class file and produces (optimized) SUIF output.
Reference: [JNI97] <author> JavaSoft. </author> <title> Java Native Interface Specification, Release 1.1, </title> <month> Jan-uary </month> <year> 1997. </year>
Reference-contexts: The control flow graph has to be augmented with special "exception-edges" that correspond to exception handling dataflow. The runtime system must be able to unwind Java frames and to activate the proper exception handler. The runtime system will implement the Java Native Interface (JNI) <ref> [JNI97] </ref>. This allows interoperability with applications and libraries written in other languages, such as native method calls in the Java JDK. No work has been done for the actual SUIF passes that will perform the high-level control structure recovery.
Reference: [KG97] <author> Andreas Krall and Reinhard Grafl. </author> <title> CACAO a 64bit Java VM just-in-time compiler. </title> <booktitle> PPoPP Workshop on Java for Science and Engineering Computation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: This version will have no support for threads/synchronization and exception handling 5 . 5 Related Work Several (de)compilers that translate Java byte-code or Java source to other target languages are available or in development. Mocha [vV] and Krakatoa [PW97] are Java bytecode to Java source decompilers. CACAO <ref> [KG97] </ref> and Briki [CL97] are both JIT-compilers for Java bytecode. Toba [PTB + 97] is a system for generating stand-alone Java applications developed at the University of Arizona. It includes a Java bytecode to C compiler that seems to cover the whole Java language specification.
Reference: [LY96] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Section 2 discusses the j2s compiler in detail. Section 3 describes first experiences with SUIF 2.0. Section 4 gives the current status and future work of the project. We assume that the reader is familiar with Java [GJS96] and the Java Virtual Machine (JVM) <ref> [LY96] </ref>, as well as the SUIF 1.0 and SUIF 2.0 compiler systems. 2 The j2s Compiler The j2s compiler expects a valid 1 Java class file (not Java source), analyzes the class file and produces (optimized) SUIF output. <p> If control flow merges (i.e., more than one edge reaches a basic block) then the local variable array and operand stack must also be merged. The merging procedure is briefly described in <ref> [LY96] </ref>. The bytecode array can contain dead code inside of a basic block. This is detected and the dead code is eliminated.
Reference: [MDG97] <author> Sumith Mathew, Eric Dahlman, and Sandeep Gupta. </author> <title> Compiling Java to SUIF: Incorporating support for object-oriented languages. </title> <type> Technical Report CS-97-114, </type> <institution> Computer Science Department, Colorado State University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Cygnus Solutions is developing a gcc-based Java implementation [Bot97]. A new gcc front-end, cc1java, translates Java bytecode or Java source to the intermediate representation of gcc [Sta96]. Colorado State University is developing a Java front-end for the SUIF 1.0 compiler system <ref> [MDG97] </ref>. Ironically, but not too surprisingly, they are calling it j2s as well. Because SUIF 1.0 has no support to describe object-oriented constructs, annotation 5 Maybe we provide an inefficient exception handling implementation based on setjump/longjump. have been used to model them.
Reference: [MMBC97] <author> Gilles Muller, Barbara Moura, Fabrice Bellard, and Charles Con-sel. Harissa: </author> <title> a flexible and efficient Java environment mixing bytecode and compiled code. </title> <type> COOTS '97, </type> <month> June </month> <year> 1997. </year>
Reference-contexts: CACAO [KG97] and Briki [CL97] are both JIT-compilers for Java bytecode. Toba [PTB + 97] is a system for generating stand-alone Java applications developed at the University of Arizona. It includes a Java bytecode to C compiler that seems to cover the whole Java language specification. Harissa <ref> [MMBC97] </ref> tries to reconcile JIT and off-line compilers by permitting to mix compiled and interpreted code. Cygnus Solutions is developing a gcc-based Java implementation [Bot97]. A new gcc front-end, cc1java, translates Java bytecode or Java source to the intermediate representation of gcc [Sta96].
Reference: [NCI] <institution> The national compiler infrastructure project. </institution> <note> URL: http://suif.stanford.edu/suif/NCI. </note>
Reference-contexts: Currently the development of a "better" SUIF | SUIF 2.0 | is underway. The basic principles and functionality will stay the same, but the underlying object-oriented design and implementation is completely different. The SUIF 2.0 compiler infrastructure is part of the National Compiler Infrastructure project <ref> [NCI] </ref>. As part of this project, UCSB is building additional functionality for object-oriented languages on top of SUIF 2.0. This extended compiler system is called Object SUIF (OSUIF) [DCI + 97].
Reference: [PTB + 97] <author> T. Proebsting, G. Townsend, P. Bridges, J. Hartman, and T. Newsham ans S. Watterson. Toba: </author> <title> Java for applications | a way ahead of time (WAT) compiler. </title> <type> COOTS '97, </type> <month> June </month> <year> 1997. </year>
Reference-contexts: Mocha [vV] and Krakatoa [PW97] are Java bytecode to Java source decompilers. CACAO [KG97] and Briki [CL97] are both JIT-compilers for Java bytecode. Toba <ref> [PTB + 97] </ref> is a system for generating stand-alone Java applications developed at the University of Arizona. It includes a Java bytecode to C compiler that seems to cover the whole Java language specification.
Reference: [PW97] <author> Todd Proebsting and Scott Wat-terson. </author> <title> Krakatoa: Decompilation in Java. </title> <type> COOTS '97, </type> <month> June </month> <year> 1997. </year>
Reference-contexts: This version will have no support for threads/synchronization and exception handling 5 . 5 Related Work Several (de)compilers that translate Java byte-code or Java source to other target languages are available or in development. Mocha [vV] and Krakatoa <ref> [PW97] </ref> are Java bytecode to Java source decompilers. CACAO [KG97] and Briki [CL97] are both JIT-compilers for Java bytecode. Toba [PTB + 97] is a system for generating stand-alone Java applications developed at the University of Arizona.
Reference: [Sta96] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Sofware Foundation, </title> <address> Boston, MA, </address> <year> 1996. </year>
Reference-contexts: Harissa [MMBC97] tries to reconcile JIT and off-line compilers by permitting to mix compiled and interpreted code. Cygnus Solutions is developing a gcc-based Java implementation [Bot97]. A new gcc front-end, cc1java, translates Java bytecode or Java source to the intermediate representation of gcc <ref> [Sta96] </ref>. Colorado State University is developing a Java front-end for the SUIF 1.0 compiler system [MDG97]. Ironically, but not too surprisingly, they are calling it j2s as well.
Reference: [vV] <author> H. P. van Vliet. </author> <note> The Mocha de-compiler. URL: http://www.brouhaha.com/ ~eric/computers/mocha.html. </note>
Reference-contexts: This version will have no support for threads/synchronization and exception handling 5 . 5 Related Work Several (de)compilers that translate Java byte-code or Java source to other target languages are available or in development. Mocha <ref> [vV] </ref> and Krakatoa [PW97] are Java bytecode to Java source decompilers. CACAO [KG97] and Briki [CL97] are both JIT-compilers for Java bytecode. Toba [PTB + 97] is a system for generating stand-alone Java applications developed at the University of Arizona.
Reference: [WFW + 94] <author> R. Wilson, R. French, C. Wil-son, S. Amarasinghe, J. Ander-son, S. Tjiang, S. Liao, C. Tseng, M. Hall, M. Lam, and J. Hen-nessy. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM SIG-PLAN Notices, </journal> <pages> pages 31 - 37, </pages> <month> De-cember </month> <year> 1994. </year>
Reference-contexts: The j2s compiler can take full advantage of the OSUIF/SUIF compiler framework, especially optimization passes and native code back ends. Thus, our compiler will hopefully serve as a useful tool for object-oriented compiler research. The SUIF 1.0 compiler system <ref> [WFW + 94] </ref> developed at Stanford University is a platform that supports experimental research on new compiler techniques. It consists of various tools and standard optimization passes that operate on a standardized and well doc umented intermediate format. The intermediate format of SUIF 1.0 only provides support for imperative languages.
References-found: 18

