URL: http://www.eecs.umich.edu/techreports/cse/1994/CSE-TR-217-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse94.html
Root-URL: http://www.eecs.umich.edu
Email: fsdawson,farnamg@eecs.umich.edu  
Title: Probing and Fault Injection of Protocol Implementations  
Author: Scott Dawson and Farnam Jahanian 
Keyword: distributed systems, communication protocol, fault injection, protocol testing, executable specifications  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: This paper presents a technique for probing and fault injection of distributed protocols. The proposed technique, called script-driven probing and fault injection, can be used for studying the behavior of distributed systems and for detecting design and implementation errors of fault-tolerant protocols. The focus of this work is on fault injection techniques that can be used to demonstrate three aspects of a target protocol: i) detection of design or implementation errors, ii) identification of violations of protocol specifications, and iii) insight into design decisions made by the implementors. The emphasis of our approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage. To demonstrate the capabilities of this technique, the paper describes a probing and fault injection tool, called the PFI tool (Probe/Fault Injection Tool), and several experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) [4, 25] and the Group Membership Protocol (GMP) [18]. The tool can be used to delay, drop, reorder, duplicate, and modify messages. It can also introduce new messages into the system to probe participants. In the case of TCP, we used the PFI tool to duplicate the experiments reported in [7] on several TCP implementations without access to the vendors' TCP source code in a very short time. We also ran several new experiments that are difficult to perform using past approaches based on packet monitoring and filtering. In the case of GMP, we used the tool to test the fault-tolerance capabilities of an implementation under various failure models including daemon/link crash, send/receive omissions, and timing failures. Furthermore, by selective reordering of messages and spontaneous transmission of new messages, we were able to guide a distributed computation into hard to reach global states without instrumenting the protocol implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie. </author> <title> Fault injection for dependability validation of fault-tolerant computing systems. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 12, 28] </ref> and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27].
Reference: [2] <author> J. Arlat et al. </author> <title> Experimental evaluation of the fault tolerance of an atomic multicast system. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 15]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [2] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [3, 10].
Reference: [3] <author> D. Avresky, J. Arlat, J.C. Laprie, and Yves Crouzet. </author> <title> Fault injection for the formal testing of fault tolerance. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 15] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 10] </ref>. The work reported in [15] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [4] <author> R. Braden. RFC-1122: </author> <title> Requirements for internet hosts. Request for Comments, </title> <month> October </month> <year> 1989. </year> <institution> Network Information Center. </institution>
Reference-contexts: Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 [25] and was updated in RFC-1122 <ref> [4] </ref>. In order to meet the TCP standard, an implementation must follow both RFCs. For testing TCP, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. We call this layer the PFI layer. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the window has reopened). Probing of zero (offered) windows MUST be supported <ref> [4, 25] </ref> because an ACK segment which reopens the window may be 11 Results Comments SunOS 4.1.3 First keep-alive arrived at about 7200 second mark. When dropped, the keep-alive was retransmitted eight times before the connection was dropped.
Reference: [5] <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding large system failures | a fault injection experiment. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 27] </ref>. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 15].
Reference: [6] <author> G. Choi, R. Iyer, and V. Carreno. </author> <title> Simulated fault injection: A methodology to evaluate fault tolerant microprocessor architectures. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 486-490, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures <ref> [6, 9, 13] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires.
Reference: [7] <author> Douglas E. Comer and John C. Lin. </author> <title> Probing TCP implementations. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The send script of the fault injection layer was set up to delay each outgoing ACK for 30 ACKs in a row. After doing this, the receive filter started dropping all incoming packets. Each incoming packet was logged. Approaches which depend on monitoring and filtering packets <ref> [7, 21] </ref> cannot perform tests like this one because they do not have the ability to manipulate messages. <p> M1 was retransmitted six times before the original ACK arrived. M2 was then transmitted three times before the connection was dropped. The active probing method proposed by Comer & Lin <ref> [7] </ref> cannot discover behaviors such as this one. In their approach, only crash failures are generated. Long delays of specific messages are not possible and so a situation where the initial packet is retransmitted multiple times before the ACK is received does not occur 2 . <p> Another closely related work is the active probing approach proposed in a recent paper by Comer and Lin <ref> [7] </ref> to study five TCP implementations. Active probing treats a TCP implementation as a black box, and it uses a set of user-level procedures to probe the black box. Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. <p> Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. In addition to repeating TCP experiments similar to those reported in <ref> [7] </ref>, our approach allows other tests that are not possible with techniques that are based primarily on monitoring and gathering trace data. In particular, our approach differs from the active probing technique in four major aspects.
Reference: [8] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> (4):175-187, 1991. 
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 22, 26] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [18], ensures that membership changes are seen in the same order by all members.
Reference: [9] <author> E. Czeck and D. Siewiorek. </author> <title> Effects of transient gate-level faults on program behaviour. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures <ref> [6, 9, 13] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires.
Reference: [10] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 15] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 10] </ref>. The work reported in [15] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. <p> The work reported in [15] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. Finally, the work reported in <ref> [10] </ref> is closest to the approach proposed here. Rather than estimating fault coverages for evaluating dependability of distributed systems, this work focuses on techniques for identifying violations of protocol specifications and for detecting design or implementations errors.
Reference: [11] <author> Klaus Echtle and Martin Leu. </author> <title> The EFA fault injector for fault-tolerant distributed system testing. </title> <booktitle> In Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 15] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [12] <author> G. Finelli. </author> <title> Characterization of fault recovery through fault injection on ftmp. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 36(2) </volume> <pages> 164-170, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 12, 28] </ref> and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27].
Reference: [13] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behaviour under hardware faults. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures <ref> [6, 9, 13] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires.
Reference: [14] <author> Vassos Hadzilacos and Sam Toueg. </author> <title> Fault-tolerant broadcasts and related problems. In Sape Mullender, editor, Distributed Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: Although a formal treatment of different failure models is beyond the scope of this presentation <ref> [14] </ref>, a brief outline of various failure assumptions that can be tested by our technique is described below. Process crash failures: A process/processor fails by halting prematurely and doing nothing from that point on. Before stopping, however, it behaves correctly.
Reference: [15] <author> Seungjae Han, Harold A. Rosenberg, and Kang G. Shin. DOCTOR: </author> <title> An integrateD sOftware fault injeCTOn enviRonment. </title> <type> Technical Report CSE-TR-192-93, </type> <institution> The University of Michigan, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 10, 11, 15] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Other work can be characterized as probabilistic approaches to test generation [3, 10]. The work reported in <ref> [15] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. Finally, the work reported in [10] is closest to the approach proposed here.
Reference: [16] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Section 6 presents concluding remarks and describes future directions of this work. 2 Approach 2.1 Script-Driven Probing and Fault Injection The proposed approach views a distributed protocol as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-Kernel <ref> [16] </ref>. In this model, we make no distinction between application-level protocols, interprocess communication protocols, network protocols, or device layer protocols.
Reference: [17] <author> Van Jacobson. </author> <title> Congestion avoidance and control. </title> <booktitle> In Proc. of ACM SIGCOMM, </booktitle> <pages> pages 314-329, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The retransmission timeout value (RTO) for a TCP connection is calculated based on measured round trip time (RTT) from the time each packet is sent until the ACK for the packet is received. RFC-1122 specifies that a TCP must use Jacobson's algorithm <ref> [17] </ref> for computing the retransmission timeout coupled with Karn's algorithm [20] for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. We ran two variations on the same experiment.
Reference: [18] <author> Farnam Jahanian, Ragunathan Rajkumar, and Sameh Fakhouri. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: When the data from the first segment arrived at the receiver, the receiver acked the data from both segments. 4.2 Testing of GMP The objective of the experiments described in this subsection is to test the fault-tolerance capabilities of a prototype implementation of the strong group membership protocol <ref> [18] </ref> using the probe and fault injection technique presented earlier. In a distributed environment, a collection of processes (or processors) can be grouped together to provide a service. <p> The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., [8, 22, 26]. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in <ref> [18] </ref>, ensures that membership changes are seen in the same order by all members. In this protocol, a group of processors have a unique leader based on the processor id of each member.
Reference: [19] <author> G.A Kanawati, N.A. Kanawati, and J.A. Abraham. FERRARI: </author> <title> A tool for the validation of system dependability properties. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 336-344. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27]. Others have emulated fault-injection into CPU components <ref> [19] </ref>, typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 15]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [20] <author> Phil Karn and Craig Partridge. </author> <title> Round trip time estimation. </title> <booktitle> In Proc. SIGCOMM 87, </booktitle> <address> Stowe, Vermont, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: RFC-1122 specifies that a TCP must use Jacobson's algorithm [17] for computing the retransmission timeout coupled with Karn's algorithm <ref> [20] </ref> for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. We ran two variations on the same experiment.
Reference: [21] <author> Steven McCanne and Van Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The send script of the fault injection layer was set up to delay each outgoing ACK for 30 ACKs in a row. After doing this, the receive filter started dropping all incoming packets. Each incoming packet was logged. Approaches which depend on monitoring and filtering packets <ref> [7, 21] </ref> cannot perform tests like this one because they do not have the ability to manipulate messages. <p> Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [23], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [21] </ref>, and the Mach Packet Filter (MPF) [29] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [22] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 22, 26] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [18], ensures that membership changes are seen in the same order by all members.
Reference: [23] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [23] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [21], and the Mach Packet Filter (MPF) [29] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [24] <author> John K. Ousterhout. </author> <title> Tcl: An embeddable command language. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 133-146, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Figure 2 illustrates the various components of the PFI tool: send/receive scripts, filters (or interpreters), recognition/generation stubs, user-defined procedures, and system utilities. Send/receive scripts are the instructions for orchestrating a computation into a particular path and for injecting faults into a system. We chose Tcl <ref> [24] </ref> as the language for writing the scripts. Filters are the interpreters that execute the scripts as messages pass through the PFI layer. In Tcl, an interpreter is simply an object which contains some state about variables and procedures which have been defined.
Reference: [25] <author> Jon Postel. RFC-793: </author> <title> Transmission control protocol. Request for Comments, </title> <month> September </month> <year> 1981. </year> <institution> Network Information Center. </institution>
Reference-contexts: TCP is connection-oriented protocol and it uses flow-control between protocol participants to operate over network connections that are inherently unreliable. Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 <ref> [25] </ref> and was updated in RFC-1122 [4]. In order to meet the TCP standard, an implementation must follow both RFCs. For testing TCP, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. We call this layer the PFI layer. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the window has reopened). Probing of zero (offered) windows MUST be supported <ref> [4, 25] </ref> because an ACK segment which reopens the window may be 11 Results Comments SunOS 4.1.3 First keep-alive arrived at about 7200 second mark. When dropped, the keep-alive was retransmitted eight times before the connection was dropped.
Reference: [26] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 22, 26] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [18], ensures that membership changes are seen in the same order by all members.
Reference: [27] <author> Z. Segall et al. </author> <title> Fiat fault injection based automated testing environment. </title> <booktitle> In FTCS-18, </booktitle> <pages> pages 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection [1, 12, 28] and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 27] </ref>. Others have emulated fault-injection into CPU components [19], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 10, 11, 15].
Reference: [28] <author> K. G. Shin and Y. H. Lee. </author> <title> Measurement and application of fault latency. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35(4):370-375, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 12, 28] </ref> and simulation approaches for injecting hardware failures [6, 9, 13] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 27].
Reference: [29] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient packet demultiplex-ing for multiple endpoints and large messages. </title> <booktitle> In Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. 21 </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [23], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [21], and the Mach Packet Filter (MPF) <ref> [29] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
References-found: 29

