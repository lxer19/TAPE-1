URL: http://www.daimi.aau.dk/~beta/Mli/dynslot.ps.Z
Refering-URL: http://www.daimi.aau.dk/~beta/Mli/mli.html
Root-URL: http://www.daimi.aau.dk
Email: email: rws@daimi.aau.dk  
Title: Dynamically Extensible Objects in a Class-Based Language  
Author: Rene W. Schmidt 
Address: DK-8000 Aarhus C, Denmark  
Affiliation: Department of Computer Science University of Aarhus  
Abstract: Object-oriented programming techniques allow the construction of reusable and extensible code. However, class-based languages have poor support for implementing type-orthogonal be-haviour and extending non-leaf classes, which result in implementations with poor performance or limited functionality. This paper presents dynamic slots, a mechanism for extending objects at runtime. We show how this mechanism can be used to build efficient implementations of type-orthogonal abstractions. Dynamic slots can be statically type-checked and have been integrated into the BETA programming language. Measurements of a persistent store show that they significantly improve performance. 
Abstract-found: 1
Intro-found: 1
Reference: [Brandt & Madsen 94] <author> S. Brandt and O. L. Madsen. </author> <title> Object-Oriented Distributed Programming in BETA. </title> <editor> In R. Guerraoui, O. Nierstrasz, and M. Riveill, editors, </editor> <booktitle> Lecture Notes in Computer Science 791, </booktitle> <pages> pages 185 - 212. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: The first two examples are based on the current implementations of object persistence [Brandt 94] and distribution <ref> [Brandt & Madsen 94] </ref> for the Mjolner BETA System. The last example describes how dynamic slots make it possible to extend an existing framework in a way that is not possible by using subclassing alone. Persistent Storage The persistence model for BETA is based on reachability.
Reference: [Brandt & Schmidt 96] <author> S. Brandt and R. W. Schmidt. </author> <title> The Design of a Metalevel Architecture for the BETA Language. </title> <editor> In C. Zimmermann, editor, </editor> <title> Metaobject Protocols. </title> <publisher> CRC Press Inc, </publisher> <address> Boca Raton, Florida, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Recently, metalevel interfaces have been constructed for several class-based languages, including CLOS [Kiczales et al. 91], Open C++ [Chiba 95], and BETA <ref> [Brandt & Schmidt 96] </ref>, and there has been an increased interest in Open Implementations [Kiczales 92]. One of the goals of these approaches is to make it possible to implement type-orthogonal abstractions directly in a programming environment, without relying on implementation details or require changes to the language implementation. <p> That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ [Chiba 95], Napier88 [Kirby et al. 94], and BETA <ref> [Brandt & Schmidt 96] </ref>. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all such abstractions can associate additional information to the objects they work on. A type-orthogonal facility to extend objects is therefore needed to allow maximum flexibility and efficiency of metalevel programs.
Reference: [Brandt 94] <author> S. Brandt. </author> <title> Implementing Shared and Persistent Objects in BETA | Progress Report. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The first two examples are based on the current implementations of object persistence <ref> [Brandt 94] </ref> and distribution [Brandt & Madsen 94] for the Mjolner BETA System. The last example describes how dynamic slots make it possible to extend an existing framework in a way that is not possible by using subclassing alone. Persistent Storage The persistence model for BETA is based on reachability. <p> FirstSlot reference will introduce no performance overhead for applications that do not use dynamic slots, at the expense of slightly larger prototypes. 5.3 Persistent Store Benchmark Finally, to evaluate the performance increase provided by dynamic slots when implementing type-orthogonal abstractions, we have modified the existing implementation of a persistent store <ref> [Brandt 94] </ref> to use dynamic slots. We compare that implementation against the original type-orthogonal implementation and against a "static" implementation. In the "static" implementation the OID attribute is pre-allocated for all objects so it can be accessed directly.
Reference: [Chiba 95] <author> S. Chiba. </author> <title> A Metaobject Protocol for C++. </title> <booktitle> In Proceedings of the 10th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> Octo-ber </month> <year> 1995. </year>
Reference-contexts: Recently, metalevel interfaces have been constructed for several class-based languages, including CLOS [Kiczales et al. 91], Open C++ <ref> [Chiba 95] </ref>, and BETA [Brandt & Schmidt 96], and there has been an increased interest in Open Implementations [Kiczales 92]. <p> That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ <ref> [Chiba 95] </ref>, Napier88 [Kirby et al. 94], and BETA [Brandt & Schmidt 96]. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all such abstractions can associate additional information to the objects they work on.
Reference: [Goldberg & Robson 89] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80. The Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: For example, Figure 1 shows a BETA fragment defining two classes A and B, where B is a subclass of A. Instances of A contains the integer attribute i, where as instances of B contains the two integer 1 Slots are similar to instance variables in Smalltalk <ref> [Goldberg & Robson 89] </ref>, and dynamic object references in BETA. We use the term dynamic slot to disambiguate them from standard BETA references. 2 attributes i and j.
Reference: [Grarup & Seligmann 93] <author> S. Grarup and J. Seligmann. </author> <title> Incremental Mature Garbage Collection. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> August </month> <year> 1993. </year>
Reference: [Holzle & Ungar 94] <author> U. Holzle and D. Ungar. </author> <title> A Third Generation Self Implementation: Reconciling Responsiveness with Performance. </title> <booktitle> In Proceedings of the 9th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 229 - 243, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: If a large number of slots are in use for individual objects, it might be feasible to store the dynamic slot values in a hash table instead. The dynamic slot implementation could at runtime choose the optimal representation of the slot values to maximize its performance. The Self system <ref> [Holzle & Ungar 94] </ref> allows objects to be dynamically extended during runtime using the addSlot method. They allocate a new object with the additional slot, copy the contents of the old object to the new object, and update all pointers to point to the new object.
Reference: [Jul et al. 88] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: as a class is required to be of a certain (sub)type to be used by a particular abstraction; (ii) unsatisfactory performance, because the extra information must be found in auxiliary data-structures; or (iii) the design of special-purpose programming languages, that include tailored support for a specific feature, e.g., the Emerald <ref> [Jul et al. 88] </ref> language is designed and implemented with compiler and runtime support for distribution.
Reference: [Kiczales 92] <author> G. Kiczales. </author> <title> Towards a new model of Abstraction in Software Engineering. </title> <editor> In A. Yonezawa and B. C. Smith, editors, </editor> <booktitle> Proceedings of International Workshop on Reflection and Meta-level Architecture (IMSA), </booktitle> <pages> pages 1-11, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Recently, metalevel interfaces have been constructed for several class-based languages, including CLOS [Kiczales et al. 91], Open C++ [Chiba 95], and BETA [Brandt & Schmidt 96], and there has been an increased interest in Open Implementations <ref> [Kiczales 92] </ref>. One of the goals of these approaches is to make it possible to implement type-orthogonal abstractions directly in a programming environment, without relying on implementation details or require changes to the language implementation.
Reference: [Kiczales et al. 91] <author> G. Kiczales, J. Rivieres, and D. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Recently, metalevel interfaces have been constructed for several class-based languages, including CLOS <ref> [Kiczales et al. 91] </ref>, Open C++ [Chiba 95], and BETA [Brandt & Schmidt 96], and there has been an increased interest in Open Implementations [Kiczales 92]. <p> Also, static type-checking is not an issue in LISP. In LISP implementations, property-list are typically not stored with the symbol, but in an external hash table hashed on the symbol's hash value. Dynamic slots have also been proposed for CLOS <ref> [Kiczales et al. 91] </ref>, where they denote statically declared attributes but for which memory is allocated on demand.
Reference: [Kirby et al. 94] <author> G. Kirby, R. Connor, and R. Morrison. </author> <title> START: A Linguistic Reflection Tool Using Hyper-Program Technology. </title> <booktitle> In Proceedings of the 6th International Workshop on Persistent Object Systems, </booktitle> <pages> pages 346 - 365, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ [Chiba 95], Napier88 <ref> [Kirby et al. 94] </ref>, and BETA [Brandt & Schmidt 96]. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all such abstractions can associate additional information to the objects they work on.
Reference: [Madsen et al. 93] <author> O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year> <month> 15 </month>
Reference-contexts: A dynamic slot can be added to any object without regard to its type. Dynamic slots are statically declared in the source code, hence statically type-checking is possible, but storage is not allocated until their first use. We have incorporated dynamic slots into the statically-typed and compiled language BETA <ref> [Madsen et al. 93] </ref>. The implementation required no change to the compiler, and only minor changes to the runtime system. Furthermore, it provides virtually no overhead for existing program, while providing efficient access to and creation of dynamic slots.
Reference: [Meyer 92] <author> B. Meyer. </author> <title> Eiffel, The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: The object layout used by the Mjolner BETA System is fairly standard for a garbage-collected object-oriented language. A similar implementation can be used for languages such as Eiffel <ref> [Meyer 92] </ref> and Modula-3 [Nelson 91]. The memory layout is split into two areas. The static part which contains immutable information about each class in a program execution, and a dynamic part which contains the dynamically created objects during program execution.
Reference: [Nelson 91] <author> G. Nelson, </author> <title> editor. System Programming with Modula-3. </title> <publisher> Prentice Hall Series in Innovative Technology, </publisher> <year> 1991. </year>
Reference-contexts: The object layout used by the Mjolner BETA System is fairly standard for a garbage-collected object-oriented language. A similar implementation can be used for languages such as Eiffel [Meyer 92] and Modula-3 <ref> [Nelson 91] </ref>. The memory layout is split into two areas. The static part which contains immutable information about each class in a program execution, and a dynamic part which contains the dynamically created objects during program execution. Class information is stored in a structure called a prototype.
Reference: [Shapiro 86] <author> M. Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of The Sixth International Conference on Distributed Computing Systems., </booktitle> <pages> pages 198 - 204, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: The implementation using link-time analysis will then in general require a larger memory overhead than the implementation using dynamic slots. Distribution The distribution library provides transparent access to remote objects, i.e., objects located in another process that possibly exists on another physical machine. Transparency is provided by proxies <ref> [Shapiro 86] </ref>. A remote object is represented by a proxy object in the caller's address-space, which forwards all calls to the remote object. For the caller, the proxy is indistinguishable from the remote object.
Reference: [Steele 84] <author> G. L. Steele. </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: In a language that supports operation overloading, e.g., C++, this could potentially be avoided. Another approach could be to extend the language definition with a special syntactical construct for dynamic slot declaration. Our approach is similar to LISP property lists <ref> [Steele 84] </ref>, which also uses special access methods. 2 This is the case for both Smalltalk and BETA. 3 This is the BETA terminology for a C++ pointer. 4 In BETA assignment (-&gt;) goes from the left to the right.
Reference: [Stroustrup 93] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: Dynamic Slots are statically typed, but dynamically allocated. Notice that it is the ability to have generics that makes it possible to implement the dynamic slot interface using a class and still have static type-checking. In BETA, this is done using a virtual class. In C++ <ref> [Stroustrup 93] </ref>, the template mechanism could be used. The drawback of modelling dynamic slots as a class is that access to dynamic slots and ordinary BETA attributes are different. In a language that supports operation overloading, e.g., C++, this could potentially be avoided.
Reference: [Ungar 84] <author> D. Ungar. </author> <title> Generation Scavenging: A Non-Disruptive High Performance Storage Reclamation Algorithm. </title> <booktitle> In Proceedings of the First Symposium of Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <month> April </month> <year> 1984. </year> <month> 16 </month>
Reference-contexts: Notice, that the attribute i is located at the same offset in instances of both class A and B, so the compiler can generate direct memory references to access the attributes of an object. The BETA garbage-collector is a variant of a generation-based scavenging collector <ref> [Ungar 84] </ref>. Memory is divided up into two main areas, the Infant Object Area (IOA) and the Adult Object Area (AOA). New objects are allocated sequentially in IOA. When the IOA area is full, all the live objects are copied from IOA to To-Space, and IOA and To-Space swap roles.
References-found: 18

