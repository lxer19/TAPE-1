URL: ftp://st.cs.uiuc.edu/pub/papers/refactoring/refactor-aggregation.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/johnson/professional.html
Root-URL: http://www.cs.uiuc.edu
Email: johnson@cs.uiuc.edu  opdyke@iexist.att.com  
Title: Refactoring and Aggregation  
Author: Ralph E. Johnson William F. Opdyke 
Address: Urbana, Illinois 61801  60566  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  AT&T Bell Laboratories Naperville, Illinois  
Abstract: Object-oriented programs evolve by means other than just the addition of new classes. The changes to object-oriented programs that have been most studied are those based on inheritance, on reorganizing a class hierarchy. However, aggregation is a relationship between classes that is just as important as inheritance, and many changes to an object-oriented design involve the aggregate/component relationship. This paper describes some common refactorings based on aggregation, including how to convert from inheritance to an aggregation, and how to reorganize an aggregate/component hierarchy just as one might reorganize a class inheritance hierarchy.
Abstract-found: 1
Intro-found: 1
Reference: [BC87] <author> E. Blake and S. Cook. </author> <title> On including part hierarchies in object-oriented languages, with an implementation in smalltalk. </title> <booktitle> In Proceedings of ECOOP '87, Special Issue of BIGRE, </booktitle> <pages> pages 45-54, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Current programming languages provide poor support for aggregations. Delega--tion based languages and some database languages emphasize aggregations more than conventional languages, and there have been a few other examinations of aggregation <ref> [BC87, WP91] </ref>, but we feel that aggregation is not appreciated as much as it should be.
Reference: [Ber91] <author> Paul L. Bergstein. </author> <title> Object-preserving class transformations. </title> <booktitle> In Proceedings of OOPSLA `91, </booktitle> <year> 1991. </year>
Reference-contexts: Consider the problem of finding a common superclass for two classes. It is not hard to move identically implemented operations and variables to the new superclass. In fact, it is possible to find a set of superclasses that minimize code duplication <ref> [Ber91, Cas91, Cas92, GM93] </ref>. These algorithms assume that operations will not change their name or be rewritten in any way, so the problem is one of deciding on a class hierarchy and where operations and variables are placed in it. <p> Previous work on refactorings for object-oriented programs focused on reorganizing inheritance hierarchies and moving variables and functions within inheritance hierarchies <ref> [Ber91, Cas91, Cas92, OJ93] </ref>. But it is possible to move variables and functions between aggregates and components just like they can be moved between subclasses and super-classes.
Reference: [BK87] <author> Jay Banerjee and Won Kim. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: Smalltalk has only the third technique. None of these techniques exactly matches what is needed to express the aggregate/component relationship. What is needed is something like the exclusive composite references of ORION <ref> [BK87, Kim90] </ref>. A one-for-one mapping also implies that each instance of the aggregate class contains a unique component; that is, that a component object is exclusive to one aggregate object.
Reference: [Cas91] <author> Eduardo Casais. </author> <title> Managing Evolution in Object Oriented Environments: An Algorithmic Approach. </title> <type> PhD thesis, </type> <institution> University of Geneva, </institution> <year> 1991. </year>
Reference-contexts: Consider the problem of finding a common superclass for two classes. It is not hard to move identically implemented operations and variables to the new superclass. In fact, it is possible to find a set of superclasses that minimize code duplication <ref> [Ber91, Cas91, Cas92, GM93] </ref>. These algorithms assume that operations will not change their name or be rewritten in any way, so the problem is one of deciding on a class hierarchy and where operations and variables are placed in it. <p> Previous work on refactorings for object-oriented programs focused on reorganizing inheritance hierarchies and moving variables and functions within inheritance hierarchies <ref> [Ber91, Cas91, Cas92, OJ93] </ref>. But it is possible to move variables and functions between aggregates and components just like they can be moved between subclasses and super-classes. <p> Schema evolution has been studied for several OODB systems [PS87, WP91, DZ91] in addition to the work on ORION cited above, which is the work that influenced us the most. Casais <ref> [Cas91] </ref> compares schema evolution features of these object-oriented database systems. ORION represents aggregations as complex objects. A composite link represents a relationship between a composite object and its component. A composite link can carry special semantics, such as that the component is exclusive to one composite object.
Reference: [Cas92] <author> Eduardo Casais. </author> <title> An incremental class reorganization approach. </title> <booktitle> In Proceedings of ECOOP '92: European Conference on Object-Oriented Programming, </booktitle> <pages> pages 114-132, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Consider the problem of finding a common superclass for two classes. It is not hard to move identically implemented operations and variables to the new superclass. In fact, it is possible to find a set of superclasses that minimize code duplication <ref> [Ber91, Cas91, Cas92, GM93] </ref>. These algorithms assume that operations will not change their name or be rewritten in any way, so the problem is one of deciding on a class hierarchy and where operations and variables are placed in it. <p> Previous work on refactorings for object-oriented programs focused on reorganizing inheritance hierarchies and moving variables and functions within inheritance hierarchies <ref> [Ber91, Cas91, Cas92, OJ93] </ref>. But it is possible to move variables and functions between aggregates and components just like they can be moved between subclasses and super-classes.
Reference: [CH86] <author> Brad Cox and Bill Hunt. </author> <title> Objects, </title> <journal> icons, and software-ICs. Byte, </journal> <pages> pages 161-176, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: This has an impact on what we consider a refactoring. 3 Aggregation Inheritance models the is-a relation, while aggregation models the has-a relation. However, these relations are less distinct than might be thought at first. Is a window a rectangle with extra behavior <ref> [CH86, Kay84] </ref>, or does a window have a shape, which is a rectangle? Is a pixel a point, or does a pixel have a location, which is a point [Ros92]? Different people give different answers to these questions, and it is common for a person's answer to change over time.
Reference: [DZ91] <author> Christing Delcourt and Roberto Zicari. </author> <title> The design of an integrity consistency checker for an object oriented database system. </title> <booktitle> In Proceedings of ECOOP '91: European Conference on Object-Oriented Programming, </booktitle> <pages> pages 97-117, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Performing these changes automatically eliminates the possibility of introducing errors and should encourage programmers to refactor programs more often. 5 Discussion 5.1 Related Research in Object-Oriented Databases This work is related to research in schema evolution in object-oriented databases (OODBs). Schema evolution has been studied for several OODB systems <ref> [PS87, WP91, DZ91] </ref> in addition to the work on ORION cited above, which is the work that influenced us the most. Casais [Cas91] compares schema evolution features of these object-oriented database systems. ORION represents aggregations as complex objects. <p> OODB schema evolution research has placed less emphasis upon member functions, only ensuring that functions are recompiled when their class is changed, but not ensuring that they behave the same. One way to say this is that they ensure structural consistency, but not behavioral consistency, which is our goal <ref> [DZ91] </ref>. A Smalltalk refactory must deal with live instances. Current Smalltalk systems already support adding and removing functions, so it is only moving variables that is a problem.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: There are many ways to model aggregation in current programming languages. In C++, for example, there are three ways; having the class of the component as a "private" superclass <ref> [ES90] </ref>, having a member variable of the class of the component, and having a member variable that points to the class of the component.
Reference: [GHJV93] <author> Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <booktitle> In Proceedings of ECOOP '93, European Conference on Object-Oriented Programming, </booktitle> <pages> pages 406-431, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Whatever the reason, it is well known that programs are often made more reusable by replacing a use of inheritance with aggregation. Many design patterns, such as Wrapper and Strategy, are essentially ways of using aggregation instead of inheritance <ref> [GHJV93] </ref>. Components can be changed dynamically, so using components instead of inheritance often makes it easier for a user to customize a system at run-time.
Reference: [GM93] <author> Robert Godin and Hafedh Mili. </author> <title> Building and maintaining analysis-level class hierarchies using galois lattices. </title> <booktitle> In Proceedings of OOPSLA `93, </booktitle> <month> September </month> <year> 1993. </year> <note> to be presented. </note>
Reference-contexts: Consider the problem of finding a common superclass for two classes. It is not hard to move identically implemented operations and variables to the new superclass. In fact, it is possible to find a set of superclasses that minimize code duplication <ref> [Ber91, Cas91, Cas92, GM93] </ref>. These algorithms assume that operations will not change their name or be rewritten in any way, so the problem is one of deciding on a class hierarchy and where operations and variables are placed in it.
Reference: [Hol93] <author> Urs Holzle. </author> <title> Integrating indepently-developed components in object-oriented languages. </title> <booktitle> In Proceedings of ECOOP '93, European Conference on Object-Oriented Programming, </booktitle> <pages> pages 36-56, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Nevertheless, there are many times that even object-oriented programs must be changed. Object-oriented programs must sometimes be changed to reuse them. Consider the problem of integrating two independently developed class libraries <ref> [Hol93] </ref>. <p> The inconsistencies can be hard to eliminate without changing either library. The usual strategy, to use wrappers to try to make objects from one library act like objects from the other library, has many disadvantages <ref> [Hol93] </ref>. Changes to requirements often require changes to a design. Consider adding a new formatting algorithm to a text editor, or a new interest calculation algorithm to a bank's accounting system.
Reference: [JF88] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: A refactoring is a program transformation that reorganizes a program without changing its behavior. We have noticed that programs are often refactored to make them more reusable and easier to maintain <ref> [JF88, OJ90] </ref>. Not all program changes are refactorings, but refactorings are often used to make other program changes easier.
Reference: [JZ91] <author> Ralph E. Johnson and Jonathon Zweig. </author> <title> Delegation in C++. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 4(7) </volume> <pages> 31-34, </pages> <month> November/December </month> <year> 1991. </year>
Reference-contexts: Passing a reference as an argument to F results in delegation, which is a general technique for replacing inheritance with aggregation <ref> [Lie86, JZ91] </ref>. If an extra argument is added to F then the interface to F will change when it is moved. All accesses to variables in A by F should be abstracted before F is moved.
Reference: [Kay84] <author> Alan Kay. </author> <title> Computer software. </title> <journal> Scientific American, </journal> <volume> 251(3) </volume> <pages> 53-59, </pages> <month> Septem-ber </month> <year> 1984. </year>
Reference-contexts: This has an impact on what we consider a refactoring. 3 Aggregation Inheritance models the is-a relation, while aggregation models the has-a relation. However, these relations are less distinct than might be thought at first. Is a window a rectangle with extra behavior <ref> [CH86, Kay84] </ref>, or does a window have a shape, which is a rectangle? Is a pixel a point, or does a pixel have a location, which is a point [Ros92]? Different people give different answers to these questions, and it is common for a person's answer to change over time.
Reference: [Kim90] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Smalltalk has only the third technique. None of these techniques exactly matches what is needed to express the aggregate/component relationship. What is needed is something like the exclusive composite references of ORION <ref> [BK87, Kim90] </ref>. A one-for-one mapping also implies that each instance of the aggregate class contains a unique component; that is, that a component object is exclusive to one aggregate object.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object-oriented systems. </title> <booktitle> In Proceedings of OOPSLA `86, </booktitle> <pages> pages 214-223, </pages> <month> November </month> <year> 1986. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 21(11). </volume>
Reference-contexts: Passing a reference as an argument to F results in delegation, which is a general technique for replacing inheritance with aggregation <ref> [Lie86, JZ91] </ref>. If an extra argument is added to F then the interface to F will change when it is moved. All accesses to variables in A by F should be abstracted before F is moved. <p> This has been shown by work on delegation <ref> [Lie86] </ref>. The refactoring described in this section usually, but not always, results in delegation, and can be seen as an algorithm for transforming a program to use delegation in a language that does not support it directly.
Reference: [Mad92] <author> Peter W. Madany. </author> <title> An Object-Oriented Framework for Filesystems. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <note> Also Technical Report No. </note> <institution> UIUCDCS-R-92-1751, Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: These refactorings allow the program to be expanded later to support multiple representations for multiple uses. For example, a sparse matrix could be implemented using a different type (class) of matrixRepr. 4.2 MemoryObjectContainer Example The Choices file system framework <ref> [Mad92, MCRL89] </ref> is one of several interlocking frameworks that are part of the Choices object-oriented operating system project at the University of Illinois.
Reference: [MCRL89] <author> Peter W. Madany, Roy H. Campbell, Vincent F. Russo, and Doublas E. Leyens. </author> <title> A class hierarchy for building stream-oriented file systems. </title> <booktitle> In Proceedings of ECOOP '89: European Conference on Object-Oriented Programming, </booktitle> <pages> pages 311-328, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: These refactorings allow the program to be expanded later to support multiple representations for multiple uses. For example, a sparse matrix could be implemented using a different type (class) of matrixRepr. 4.2 MemoryObjectContainer Example The Choices file system framework <ref> [Mad92, MCRL89] </ref> is one of several interlocking frameworks that are part of the Choices object-oriented operating system project at the University of Illinois.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Object-oriented programming is advertised as leading to more extensible programs than conventional programming <ref> [Mey88] </ref>. Modifications to a system that would require many changes in conventional programming often can be carried out in an object-oriented program by simply adding new classes. Nevertheless, there are many times that even object-oriented programs must be changed. Object-oriented programs must sometimes be changed to reuse them.
Reference: [OJ90] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Refactoring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> In Proceedings of Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: A refactoring is a program transformation that reorganizes a program without changing its behavior. We have noticed that programs are often refactored to make them more reusable and easier to maintain <ref> [JF88, OJ90] </ref>. Not all program changes are refactorings, but refactorings are often used to make other program changes easier.
Reference: [OJ93] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Creating abstract superclasses by refactoring. </title> <booktitle> In Proceedings of CSC '93: The ACM 1993 Computer Science Conference, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: If operations have to be renamed, split into pieces, or rewritten, then the problem becomes much harder <ref> [OJ93] </ref>, and that is what happens when abstract superclasses are discovered in practice. This paper describes high-level refactorings based on aggregations. These include how to reorganize an aggregate/component hierarchy just as one might reorganize a class inheritance hierarchy and how to convert from inheritance to an aggregation. <p> Previous work on refactorings for object-oriented programs focused on reorganizing inheritance hierarchies and moving variables and functions within inheritance hierarchies <ref> [Ber91, Cas91, Cas92, OJ93] </ref>. But it is possible to move variables and functions between aggregates and components just like they can be moved between subclasses and super-classes. <p> However, some of the refactorings are much more complicated, and this paper has focused on some of them. In addition to the refactorings involving aggregations, we have investigated refactorings for refining object-oriented programs by generalizing or specializing a class <ref> [Opd92, OJ93] </ref> and for eliminating case analysis [Opd92]. Although this paper has focused on refactoring programs, refactoring designs or other object-oriented models would be essentially the same. Current programming languages provide poor support for aggregations.
Reference: [Opd92] <author> William F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <note> Also Technical Report No. </note> <institution> UIUCDCS-R-92-1759, Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: We developed one of our own, but, due to the complexity of C++, we were not able to make it handle all of C++ in the time that we had. Nevertheless, it was sufficient for prototyping some of the refactoring algorithms <ref> [Opd92] </ref>. Currently we are developing a refactory for Smalltalk-80 that we hope will be a useful tool. Smalltalk-80 makes it easy to manipulate programs, and has classes for representing classes, methods, and parse trees. The major problem with refactoring Smalltalk-80 programs is its lack of a type system. <p> There are some conservative dataflow algorithms that can detect the most common situations in which a variable holds an exclusive component and that will detect the most common situations. However, it is not hard to invent programs that these algorithms cannot handle <ref> [Opd92] </ref>. It is probably better to check that a component is an exclusive component dynamically, by setting a component's aggregate variable to nil when the component is removed from an aggregate, and checking that a component has no aggregate when it is inserted into an aggregate. <p> However, some of the refactorings are much more complicated, and this paper has focused on some of them. In addition to the refactorings involving aggregations, we have investigated refactorings for refining object-oriented programs by generalizing or specializing a class <ref> [Opd92, OJ93] </ref> and for eliminating case analysis [Opd92]. Although this paper has focused on refactoring programs, refactoring designs or other object-oriented models would be essentially the same. Current programming languages provide poor support for aggregations. <p> However, some of the refactorings are much more complicated, and this paper has focused on some of them. In addition to the refactorings involving aggregations, we have investigated refactorings for refining object-oriented programs by generalizing or specializing a class [Opd92, OJ93] and for eliminating case analysis <ref> [Opd92] </ref>. Although this paper has focused on refactoring programs, refactoring designs or other object-oriented models would be essentially the same. Current programming languages provide poor support for aggregations.
Reference: [PS87] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented dbms. </title> <booktitle> In Proceedings of OOPSLA `87, </booktitle> <year> 1987. </year>
Reference-contexts: Performing these changes automatically eliminates the possibility of introducing errors and should encourage programmers to refactor programs more often. 5 Discussion 5.1 Related Research in Object-Oriented Databases This work is related to research in schema evolution in object-oriented databases (OODBs). Schema evolution has been studied for several OODB systems <ref> [PS87, WP91, DZ91] </ref> in addition to the work on ORION cited above, which is the work that influenced us the most. Casais [Cas91] compares schema evolution features of these object-oriented database systems. ORION represents aggregations as complex objects.
Reference: [Ros92] <author> J. P. Rosen. </author> <title> What orientation should Ada objects take? Communications of the ACM, </title> <booktitle> 35(11) </booktitle> <pages> 71-76, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: However, these relations are less distinct than might be thought at first. Is a window a rectangle with extra behavior [CH86, Kay84], or does a window have a shape, which is a rectangle? Is a pixel a point, or does a pixel have a location, which is a point <ref> [Ros92] </ref>? Different people give different answers to these questions, and it is common for a person's answer to change over time. On the one hand, both points of view can lead to working programs.
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of OOPSLA `86, </booktitle> <pages> pages 38-45, </pages> <month> November </month> <year> 1986. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 21(11). </volume>
Reference-contexts: It is harder in Smalltalk, because initialization of new objects is done by convention rather than being a part of the language. 1 Looking at classes from the client/server point of view is described, for example, in <ref> [Sny86, WBWW90] </ref>. A superclass is a server to its (client) subclasses, as is a component a server to its (client) aggregate classes. The Smalltalk Refactory treats methods labeled as the "initialization method" like a constructor in C++.
Reference: [WBWW90] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: It is harder in Smalltalk, because initialization of new objects is done by convention rather than being a part of the language. 1 Looking at classes from the client/server point of view is described, for example, in <ref> [Sny86, WBWW90] </ref>. A superclass is a server to its (client) subclasses, as is a component a server to its (client) aggregate classes. The Smalltalk Refactory treats methods labeled as the "initialization method" like a constructor in C++.
Reference: [WP91] <author> Francis Wolinski and Jean-Francois Perrot. </author> <title> Representation of complex objects: Multiple facets with part-whole hierarchies. </title> <booktitle> In Proceedings of ECOOP '91: European Conference on Object-Oriented Programming, </booktitle> <pages> pages 288-306, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Performing these changes automatically eliminates the possibility of introducing errors and should encourage programmers to refactor programs more often. 5 Discussion 5.1 Related Research in Object-Oriented Databases This work is related to research in schema evolution in object-oriented databases (OODBs). Schema evolution has been studied for several OODB systems <ref> [PS87, WP91, DZ91] </ref> in addition to the work on ORION cited above, which is the work that influenced us the most. Casais [Cas91] compares schema evolution features of these object-oriented database systems. ORION represents aggregations as complex objects. <p> Current programming languages provide poor support for aggregations. Delega--tion based languages and some database languages emphasize aggregations more than conventional languages, and there have been a few other examinations of aggregation <ref> [BC87, WP91] </ref>, but we feel that aggregation is not appreciated as much as it should be.
References-found: 27

