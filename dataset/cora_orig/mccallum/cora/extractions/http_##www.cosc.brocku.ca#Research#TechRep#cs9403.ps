URL: http://www.cosc.brocku.ca/Research/TechRep/cs9403.ps
Refering-URL: http://www.cosc.brocku.ca/Research/TechRep/
Root-URL: 
Title: Running Programs Backwards: The Logical Inversion of Imperative Computation  
Author: BRIAN J. ROSS 
Keyword: Key words: inversion, abduction, reverse computation, program testing  
Note: Submitted for publication.  
Address: St. Catharines, Ontario, Canada L2S 3A1  
Affiliation: Brock University Department of Computer Science  
Email: email: bross@sandbanks.cosc.brocku.ca  
Phone: phone: (905) 688-5550 ext. 4284 fax: (905) 688-3255  
Date: February 2, 1998  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [Ben73] <author> C.H. Bennett. </author> <title> Logical reversibility of computation. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 17 </volume> <pages> 525-532, </pages> <year> 1973. </year>
Reference-contexts: Despite the computational limits of the gen-eralised program inversion problem, the intractability of many algorithmic inversions should not prevent the study of the multitude of algorithms that have useful and tractable inversions. Related theoretical work is that in reversible computations and cellular automata <ref> [Ben73, Ben82, TN90] </ref>. A reversible Turing machine is one in which the direction of computation can be reversed at any time. To do this, the Turing machine is constructed with an extra tape for retaining the step-by-step history of the computation. <p> Then, given a final state of b = c = 1, both the test constraints a 0 and a 0 will be valid. A CLP interpreter can then deduce that these constraints reduce to a = 0. Bennett discusses logical reversibility of computation in <ref> [Ben73] </ref>, in which he compares biochemical DNA reactions with reversible computations: [...] we can see that here the reactions form a branching structure, with a main trunk corresponding to the desired computation path, and side branches corresponding to incorrect or "extraneous" reverse computations. [...] A few such extraneous states would pose
Reference: [Ben82] <author> C.H. Bennett. </author> <title> The thermodynamics of computation a review. </title> <journal> International Journal of Theoretical Physics, </journal> <volume> 21(12) </volume> <pages> 905-940, </pages> <year> 1982. </year>
Reference-contexts: Despite the computational limits of the gen-eralised program inversion problem, the intractability of many algorithmic inversions should not prevent the study of the multitude of algorithms that have useful and tractable inversions. Related theoretical work is that in reversible computations and cellular automata <ref> [Ben73, Ben82, TN90] </ref>. A reversible Turing machine is one in which the direction of computation can be reversed at any time. To do this, the Turing machine is constructed with an extra tape for retaining the step-by-step history of the computation. <p> This tape records information that would normally have been destroyed in a forward execution. Hence each forward computation step has an inverse defined for it. Bennett makes a fascinating analogy between reversible computations and the reproductive activity of organic DNA in <ref> [Ben82] </ref>, in which which forward and reverse DNA reactions are analogous to forward and backward computation steps. 3 Other work using program inversion includes the following. Broy uses program inverses to simplify the derivation of particular types of recursive structures during program synthesis [BKB80].
Reference: [BH86] <author> D. Brough and C.J. </author> <title> Hogger. The Treatment of Loops in Logic Programming. </title> <type> Technical Report 86/16, </type> <institution> Imperial College, </institution> <year> 1986. </year>
Reference-contexts: An abductive inference strategy could be implemented in a specialised logic program interpreter. However, a better approach is to encode abduction in the inverted logical semantics itself. Brough and Hogger describe a logic program transformation which parallels the Greibach-Foster transformation used in formal grammar theory <ref> [BH86] </ref>. Given a logic program which matches the schema on the left, they propose the following logically sound transformation: P : T: =) S: Presuming standard Prolog's left-first-depth-first control, the idea is that, for P on the left to successfully terminate, the goal T must succeed at some time.
Reference: [BKB80] <author> M. Broy and B. Krieg-Bruckner. </author> <title> Derivation of invariant assertions during program development by transformation. </title> <journal> TOPLAS, </journal> <volume> 2(3) </volume> <pages> 321-337, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Broy uses program inverses to simplify the derivation of particular types of recursive structures during program synthesis <ref> [BKB80] </ref>. Program inversion is useful for enhancing the declarative power of functional programming languages, for example, to allow (n : 1) functions to be treated as inverse (1 : n) relations.
Reference: [CM87] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog (3rd ed). </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The logic program syntax normally adopted for such clauses is "H : G 1 ; :::; G n :", where H is the clause head, and the goals G i comprise the body <ref> [CM87] </ref>. Clauses with non-empty bodies are rules, while those with empty bodies are facts. A procedure or predicate is a collection of clauses labelled by the same head name (we assume the arity is consistent). <p> Backtracking represents the nondeterministic execution of alternate computation paths or branches in the tree. Hence, where imperative programs have one deterministic computation path, a logic program has multiple nondeterministic computation paths. Consider the following declarative description of a sort program <ref> [CM87] </ref>: sort (L1; L2) : permutation (L1; L2); sorted (L2); !: permutation ([ ]; [ ]): permutation (L; [HjT ]) : append (V; [JjU ]; L); append (V; U; W ); permutation (W; T ): sorted ([ ]): sorted ([X]): sorted ([X; Y jL]) : X &lt; Y; sorted ([Y jL]):
Reference: [CU90] <author> W. Chen and J.T. Udding. </author> <title> Program inversion: more than fun! Science of Computer Programming, </title> <booktitle> 15 </booktitle> <pages> 1-13, </pages> <year> 1990. </year>
Reference-contexts: The inversions of imperative and logic programs are discussed in the following sections. 2.2 Imperative program inversion Dijkstra [Dij82] and Gries [Gri81] introduced the step-wise derivation of inverted imperative programs from forward-executing algorithms, and others have investigated this idea further <ref> [CU90, vW91] </ref>. Consider a program that has a computationally useful inverse, and in which the problem is more intuitively specified and implemented in its forward-executing form. For example, symbolic differentiation is more conceptually intuitive for many people than symbolic integration.
Reference: [CvE81] <author> K.L. Clark and M.H. van Emden. </author> <title> Consequence verification of flowcharts. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(1):52-60, </volume> <month> January </month> <year> 1981. </year>
Reference-contexts: If the Horn clause subset of first-order logic is used as the semantic language, then a program's logical semantics can be interpreted as a logic program <ref> [Llo87, CvE81] </ref>. Because logic programs have associated models of computation, the logic program description of the imperative program can have an inference strategy applied to it, resulting in a simple interpreter for the language. <p> Clark and van Emden apply the Horn clause subset of first-order logic towards modelling imperative computations <ref> [CvE81] </ref>. This semantics is a relational semantics like Hehner's, but restricted to Horn clause logic. An advantage of restricting the logical model in this way is that logic programming models of computation can be applied to the semantic descriptions of programs.
Reference: [CW88] <author> M. Carlsson and J. Widen. </author> <title> SICStus Prolog User's Manual, </title> <month> October </month> <year> 1988. </year>
Reference-contexts: Nevertheless, in many instances programs do allow the automatic deduction of useful control information. Recent enhanced implementations of Prolog have control mechanisms which conform to the dynamic state of the inference. For example, SICStus Prolog allows the delaying of goals whose arguments are not sufficiently instantiated <ref> [CW88] </ref>. This permits the execution of programs which would normally have required an altered computation rule, such as those studied by Shoham and Mc-Dermott. Many Prolog utilities, such as those for arithmetic, are strictly deterministic. <p> Each test in the program has a uniquely named predicate (as is done for loop relations in (v) and (vi)). In (iii), assignments are modelled by an equality operator = fl =, which solves simple arithmetic equalities as in <ref> [SM84, CW88] </ref>. <p> This will not necessarily work with all inversions, however, since data instantiation will often change dynamically as a nondeterministic inversion computation space is explored. A better solution is to use a coroutining or goal-blocking mechanism, such as that in SICStus Prolog <ref> [CW88] </ref>. <p> Failure to satisfy the state means that new branches of the search tree are immediately explored. This control presupposes the use of a logic program interpreter with goal delaying or coroutining, such as in <ref> [CW88] </ref>, which allows control to be determined by the dataflow patterns of the program. Of course, this does not mean that infinite or nonterminating branches can be avoided. Many inverted algorithms have exponential or infinitely branching computation trees. This technique is therefore effective with well-behaved inverted algorithms.
Reference: [Dar81] <author> J. Darlington. </author> <title> An experimental program transformation and synthesis system. </title> <journal> Artificial Intelligence, </journal> <volume> 16 </volume> <pages> 1-46, </pages> <year> 1981. </year>
Reference-contexts: Program inversion is useful for enhancing the declarative power of functional programming languages, for example, to allow (n : 1) functions to be treated as inverse (1 : n) relations. To this end, program inversions have been introduced to Lisp [Kor81], fold and unfold transformation systems <ref> [Dar81] </ref>, and Hope+ [HH86]. Programming environments often make use of "undo" operations, which represent the inverses of atomic operations [Lee86].
Reference: [Dij75] <author> E.W. Dijkstra. </author> <title> Guarded commands, nondeterminacy, and the formal derivation of programs. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 453-457, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: A host of different programming logics have been suggested, two famous examples being Hoare's axiomatic semantics [Hoa69] and Dijkstra's predicate transformers <ref> [Dij75] </ref>. A newer logic is Hehner's relational semantics [Heh84a, Heh84b]. Hehner's logic is appealing because it reduces the distinction between the programming and specification languages both are directly translatable into one another. <p> This points out the limited algorithmic information encoded within an imperative program's logical semantics: these logical semantics are far more shallow in content than what is found within program specification logic as used in <ref> [Hoa69, Dij75, Heh84b] </ref>. For example , consider the infinite computation tree in figure 5. The logical relation for mult does not encode the fact that y can never be negative in this program. The deduction of this simple fact is not within the inferential power of SLDNF resolution.
Reference: [Dij82] <author> E.W. Dijkstra. EWD671: </author> <title> Program inversion. </title> <booktitle> In Selected Writings on Computing: A Personal Perspective, </booktitle> <pages> pages 351-354. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Programming environments often make use of "undo" operations, which represent the inverses of atomic operations [Lee86]. The inversions of imperative and logic programs are discussed in the following sections. 2.2 Imperative program inversion Dijkstra <ref> [Dij82] </ref> and Gries [Gri81] introduced the step-wise derivation of inverted imperative programs from forward-executing algorithms, and others have investigated this idea further [CU90, vW91]. Consider a program that has a computationally useful inverse, and in which the problem is more intuitively specified and implemented in its forward-executing form.
Reference: [Gri81] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <month> 26 </month>
Reference-contexts: Programming environments often make use of "undo" operations, which represent the inverses of atomic operations [Lee86]. The inversions of imperative and logic programs are discussed in the following sections. 2.2 Imperative program inversion Dijkstra [Dij82] and Gries <ref> [Gri81] </ref> introduced the step-wise derivation of inverted imperative programs from forward-executing algorithms, and others have investigated this idea further [CU90, vW91]. Consider a program that has a computationally useful inverse, and in which the problem is more intuitively specified and implemented in its forward-executing form.
Reference: [Har80] <author> David Harel. </author> <title> And/Or programs: a new approach to structured programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 1-17, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: The need for the angelic nondeterminism operator can be seen when one considers the AND/OR tree model of computation <ref> [Har80] </ref>. The left-most diagram in figure 1 shows some computation paths for different inputs of a terminating imperative program. Each arc represents the modification of the computation state.
Reference: [Heh84a] <author> E.C.R. Hehner. </author> <title> Predicative Programming Part I. </title> <journal> Communications of the ACM, </journal> <volume> 27(2) </volume> <pages> 134-143, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: A host of different programming logics have been suggested, two famous examples being Hoare's axiomatic semantics [Hoa69] and Dijkstra's predicate transformers [Dij75]. A newer logic is Hehner's relational semantics <ref> [Heh84a, Heh84b] </ref>. Hehner's logic is appealing because it reduces the distinction between the programming and specification languages both are directly translatable into one another. Hehner's logic treats all program language constructs as relations over the observable environment, which is usually taken to be the program variable values.
Reference: [Heh84b] <author> E.C.R. Hehner. </author> <title> The Logic of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: This paper proposes that imperative programs are indeed conducive to inverse computation if we loosen the requirement that the source and inverse programs are written in the same imperative language. It is well known from work in logical program semantics (eg. <ref> [LS84, Heh84b] </ref>) that an imperative program is modellable by a logical relation which declaratively describes the computational behaviour with respect to the observable environment. <p> A host of different programming logics have been suggested, two famous examples being Hoare's axiomatic semantics [Hoa69] and Dijkstra's predicate transformers [Dij75]. A newer logic is Hehner's relational semantics <ref> [Heh84a, Heh84b] </ref>. Hehner's logic is appealing because it reduces the distinction between the programming and specification languages both are directly translatable into one another. Hehner's logic treats all program language constructs as relations over the observable environment, which is usually taken to be the program variable values. <p> This points out the limited algorithmic information encoded within an imperative program's logical semantics: these logical semantics are far more shallow in content than what is found within program specification logic as used in <ref> [Hoa69, Dij75, Heh84b] </ref>. For example , consider the infinite computation tree in figure 5. The logical relation for mult does not encode the fact that y can never be negative in this program. The deduction of this simple fact is not within the inferential power of SLDNF resolution.
Reference: [HH86] <author> P.G. Harrison and H.Khoshnevisan. </author> <title> On the Synthesis of Function Inverses. </title> <type> Technical report, </type> <institution> Imperial College, </institution> <year> 1986. </year>
Reference-contexts: Program inversion is useful for enhancing the declarative power of functional programming languages, for example, to allow (n : 1) functions to be treated as inverse (1 : n) relations. To this end, program inversions have been introduced to Lisp [Kor81], fold and unfold transformation systems [Dar81], and Hope+ <ref> [HH86] </ref>. Programming environments often make use of "undo" operations, which represent the inverses of atomic operations [Lee86].
Reference: [HHNT86] <author> J.H. Holland, K.J. Holyoak, R.E. Nisbett, and P.R. Thagard. </author> <title> Induction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: We retain the exit test at all times, since we know it must have triggered the loop's termination. Should the positive loop test or loop body fail during loop unwinding, then the possible inverse iterations for the loop have been exhausted. This reasoning strategy is an example of abduction <ref> [HHNT86] </ref>. Abduction is a type of logical inference which first conjectures a particular hypothesis, and then attempts to establish its premises. This is precisely what happens when inverting a while loop (or inverting the entire program for that matter). We conjecture that the loop has terminated.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: A host of different programming logics have been suggested, two famous examples being Hoare's axiomatic semantics <ref> [Hoa69] </ref> and Dijkstra's predicate transformers [Dij75]. A newer logic is Hehner's relational semantics [Heh84a, Heh84b]. Hehner's logic is appealing because it reduces the distinction between the programming and specification languages both are directly translatable into one another. <p> This points out the limited algorithmic information encoded within an imperative program's logical semantics: these logical semantics are far more shallow in content than what is found within program specification logic as used in <ref> [Hoa69, Dij75, Heh84b] </ref>. For example , consider the infinite computation tree in figure 5. The logical relation for mult does not encode the fact that y can never be negative in this program. The deduction of this simple fact is not within the inferential power of SLDNF resolution.
Reference: [Knu81] <author> Donald E. Knuth. </author> <title> Seminumerical Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1981. </year>
Reference-contexts: The program in figure 8 is an implementation of Knuth's Algorithm P <ref> [Knu81] </ref>. Given a permutation of n different integers, the forward program calculates a unique number k (0 k &lt; n!) based on the relative ordering of integers in the permutation.
Reference: [Kor81] <author> R.E. Korf. </author> <title> Inversion of applicative programs. </title> <booktitle> In IJCAI, </booktitle> <pages> pages 1007-1009, </pages> <year> 1981. </year>
Reference-contexts: Program inversion is useful for enhancing the declarative power of functional programming languages, for example, to allow (n : 1) functions to be treated as inverse (1 : n) relations. To this end, program inversions have been introduced to Lisp <ref> [Kor81] </ref>, fold and unfold transformation systems [Dar81], and Hope+ [HH86]. Programming environments often make use of "undo" operations, which represent the inverses of atomic operations [Lee86].
Reference: [Kow79] <author> R. Kowalski. </author> <title> Algorithm = Logic + Control. </title> <journal> Communications of the ACM, </journal> <volume> 22(7) </volume> <pages> 424-436, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: ; :::; G m :" represents a query Q for the logic program, and is solved by applying SLDNF resolution to refute P rog [ fQg [Llo87]. 6 The conceptual distinction between a program's declarative semantics and procedural semantics is one of the characterising features of the logic programming paradigm <ref> [Kow79] </ref>. A logic program has a declarative semantics, which is the program's relational interpretation when the program predicates are interpreted as comprising a first-order Horn clause theory.
Reference: [Lee86] <author> G.B. Leeman. </author> <title> A formal approach to undo operations in programming languages. </title> <journal> Journal of the ACM, </journal> <volume> 8(1) </volume> <pages> 50-87, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: To this end, program inversions have been introduced to Lisp [Kor81], fold and unfold transformation systems [Dar81], and Hope+ [HH86]. Programming environments often make use of "undo" operations, which represent the inverses of atomic operations <ref> [Lee86] </ref>. The inversions of imperative and logic programs are discussed in the following sections. 2.2 Imperative program inversion Dijkstra [Dij82] and Gries [Gri81] introduced the step-wise derivation of inverted imperative programs from forward-executing algorithms, and others have investigated this idea further [CU90, vW91].
Reference: [Llo87] <author> J.W. Lloyd. </author> <booktitle> Foundations of Logic Programming (2nd ed). </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: If the Horn clause subset of first-order logic is used as the semantic language, then a program's logical semantics can be interpreted as a logic program <ref> [Llo87, CvE81] </ref>. Because logic programs have associated models of computation, the logic program description of the imperative program can have an inference strategy applied to it, resulting in a simple interpreter for the language. <p> A goal clause ": G 1 ; :::; G m :" represents a query Q for the logic program, and is solved by applying SLDNF resolution to refute P rog [ fQg <ref> [Llo87] </ref>. 6 The conceptual distinction between a program's declarative semantics and procedural semantics is one of the characterising features of the logic programming paradigm [Kow79].
Reference: [LS84] <author> J. Loeckx and K. Sieber. </author> <title> The Foundations of Program Verification. </title> <address> Wiley-Teubner, </address> <year> 1984. </year>
Reference-contexts: This paper proposes that imperative programs are indeed conducive to inverse computation if we loosen the requirement that the source and inverse programs are written in the same imperative language. It is well known from work in logical program semantics (eg. <ref> [LS84, Heh84b] </ref>) that an imperative program is modellable by a logical relation which declaratively describes the computational behaviour with respect to the observable environment.
Reference: [McC56] <author> J. McCarthy. </author> <title> The inversion of functions defined by turing machines. </title> <editor> In C.E. Shannon and J. McCarthy, editors, </editor> <booktitle> Automata Studies, </booktitle> <pages> pages 177-181. </pages> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: McCarthy approaches generalised computational inversions from the standpoint of computing and testing Turing machine computations over the enumerated values of the program's data, in essence exhaustively searching for an inverse <ref> [McC56] </ref>. Although this technique will find an inverse if it exists, the Halting Problem implies that it is impossible for the program to determine if one does not exist. In addition, exhaustive enumeration is hopelessly inefficient as a practical tool.
Reference: [Ros89] <author> B.J. Ross. </author> <title> The partial evaluation of imperative programs using prolog. </title> <booktitle> In Meta-programming in Logic Programming, </booktitle> <pages> pages 341-363. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: An advantage of restricting the logical model in this way is that logic programming models of computation can be applied to the semantic descriptions of programs. Ross applies this idea by using Horn clause logic in a source-to-source program transformation system <ref> [Ros89] </ref>. Imperative programs have Horn clause descriptions transliterated for them (see figure 2), which are treated as pure Prolog programs. Each predicate tuple has two arguments - the initial and final states as represented by variable store environment.
Reference: [RW89] <author> B.J. Ross and P.F. </author> <title> Wilk. The Logical Inversion of Imperative Computations. </title> <type> Technical Report DAI 414, </type> <institution> Dept. of AI, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Section 3 presents a logic-based inversion methodology that can compute imperative program inverses. Some example program inversions are given in section 4. A discussion concludes the paper in section 5. 1 1 A preliminary version of this work appeared in <ref> [RW89] </ref>. 2 2 The inversion problem 2.1 General overview Inversion is a fundamental concept in mathematics and theoretical computer science.
Reference: [Sic79] <author> S. Sickel. </author> <title> Invertibility of logic programs. </title> <booktitle> In 4th Workshop on Automated Deduction, </booktitle> <pages> pages 103-109, </pages> <address> Austin, Texas, </address> <month> February 1-3 </month> <year> 1979. </year>
Reference-contexts: Work in abstract interpretation is also useful in this regards. The dataflow patterns inherent within a program can be ascertained, and the control scheme appropriately adapted. Sickel studies the modes of predicate arguments in order to determine the computability of particular inversions <ref> [Sic79] </ref>. 3 Logically computing imperative inverses This section gives an informal illustration of how logic programming can be used to invert imperative algorithms. Given an imperative program to be inverted, a logic program representing its relational semantics is automatically derivable for it.
Reference: [SM84] <author> Y. Shoham and D.V. McDermott. </author> <title> Directed relations and inversion of prolog programs. </title> <booktitle> In International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 307-316, </pages> <year> 1984. </year>
Reference-contexts: Truly nondeterministic predicates of course have no mode restrictions, but are too inefficient to be practical in many applications. Shoham and McDermott experiment with inverting logic programs by deriving meta-interpreters incorporating a number of different control schemes <ref> [SM84] </ref>. Some logic programs require slightly modified inference strategies in order to infer their inverses. For example, the inverses of some logic programs is obtained by reversing the order of goal selection. <p> Each test in the program has a uniquely named predicate (as is done for loop relations in (v) and (vi)). In (iii), assignments are modelled by an equality operator = fl =, which solves simple arithmetic equalities as in <ref> [SM84, CW88] </ref>. <p> Besides encoding abductive reasoning, a practical use of this transformation is to remove left-recursive looping a phenomena which often results when a right-to-left goal reordering is attempted (this problem was often encountered by Shoham and McDermott <ref> [SM84] </ref>). After applying the Griebach-Foster transformation on the forward semantics above, we get the inverted loop semantics in (v) of figure 3. With respect to the transformation scheme in [1], T is mapped to the test :b, and R to the test b and the body Q of the loop.
Reference: [Tar77] <author> S. </author> <title> Tarnlund. Horn Clause Computability. </title> <journal> BIT, </journal> <volume> 17 </volume> <pages> 215-226, </pages> <year> 1977. </year>
Reference-contexts: Because first-order Horn clauses are Turing machine powerful, there is not an effective decision procedure for generalised logic programs <ref> [Tar77] </ref>. Nevertheless, in many instances programs do allow the automatic deduction of useful control information. Recent enhanced implementations of Prolog have control mechanisms which conform to the dynamic state of the inference. For example, SICStus Prolog allows the delaying of goals whose arguments are not sufficiently instantiated [CW88].
Reference: [TJ85] <author> T.Vasak and J.Potter. </author> <title> Metalogical control for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 203-220, </pages> <month> October </month> <year> 1985. </year> <month> 27 </month>
Reference-contexts: This strategy is suggested by Vasak and Potter, in which additional termination conditions are encoded within logic programs to stop execution down fruitless paths of the computation <ref> [TJ85] </ref>. Of course, knowing how to control inference in such a manner is not always feasible knowing such heuristics for particular algorithms would resolve many outstanding unsolved mathematical and computational problems (and paradoxes).
Reference: [TN90] <author> T. Toffoli and N.Margolus. </author> <title> Invertible cellular automata: a review. </title> <journal> Physica D, Non--linear Phenomena, </journal> <pages> 45(1-3), </pages> <year> 1990. </year>
Reference-contexts: Despite the computational limits of the gen-eralised program inversion problem, the intractability of many algorithmic inversions should not prevent the study of the multitude of algorithms that have useful and tractable inversions. Related theoretical work is that in reversible computations and cellular automata <ref> [Ben73, Ben82, TN90] </ref>. A reversible Turing machine is one in which the direction of computation can be reversed at any time. To do this, the Turing machine is constructed with an extra tape for retaining the step-by-step history of the computation.
Reference: [vH90] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: As theorem proving and logic programming technology advances, the need for such programmer intervention will diminish. Advanced logic programming languages can directly contribute to the inversion problem in both imperative and logic programming domains. The use of constraint logic programming (CLP) <ref> [vH90] </ref> for inversion is a very promising approach currently under investigation. CLP permits arithmetic reasoning to be performed on contraints, which are inequalities over arithmetic and other domains. An example of the type of analysis possible with CLP is the following.
Reference: [vW91] <author> J. von Wright. </author> <title> Program inversion in the refinement calculus. </title> <journal> Information Processing letters, </journal> <volume> 37 </volume> <pages> 95-100, </pages> <month> January </month> <year> 1991. </year> <month> 28 </month>
Reference-contexts: The inversions of imperative and logic programs are discussed in the following sections. 2.2 Imperative program inversion Dijkstra [Dij82] and Gries [Gri81] introduced the step-wise derivation of inverted imperative programs from forward-executing algorithms, and others have investigated this idea further <ref> [CU90, vW91] </ref>. Consider a program that has a computationally useful inverse, and in which the problem is more intuitively specified and implemented in its forward-executing form. For example, symbolic differentiation is more conceptually intuitive for many people than symbolic integration. <p> The inverse of a forward algorithm can be step-wise derived from the program's code and specification. Von Wright suggests that program S 1 is the inverse of program S under precondition P if the following total correctness formula holds for all predicates Q <ref> [vW91] </ref>: (P ^ Q) [S; S 1 ] Q We can think of S 1 as reversing or undoing the computation done by S before it. <p> This is problematic because that prior value has been destroyed. The above logical expression uses angelic nondeterminism <ref> [vW91] </ref> to determine the prior value d that u contained before the assignment. Since d must exist, the expression essentially uses an oracle to select it.
References-found: 34

