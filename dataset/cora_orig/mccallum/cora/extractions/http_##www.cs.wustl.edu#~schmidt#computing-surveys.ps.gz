URL: http://www.cs.wustl.edu/~schmidt/computing-surveys.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: 
Email: schmidt@cs.wustl.edu  jxh@cs.wustl.edu  
Phone: (314) 935-7538 (TEL)  
Title: Developing Flexible and High-performance Web Servers with Frameworks and Patterns  
Author: Douglas C. Schmidt James C. Hu 
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Abstract: A subset of this paper will appear in ACM Computing Surveys, volume 30, 1998. Abstract The goal of this paper is to illustrate how frameworks and patterns address complexities that arise in the design and implementation of high-performance distributed software systems. These complexities are both inherent (e.g., latency reduction and throughput preservation), and accidental (e.g., the continuous reinvention of key concepts and components). This paper explains how complexities occurring in the development of high-performance Web servers can be alleviated with the use of design patterns and object-oriented application frameworks. These techniques were applied to the development our high-performance adaptive Web server framework, JAWS. JAWS exemplifies how a framework can remain flexible without sacrificing performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and C. Cleeland, </author> <title> Applying Patterns to Develop Extensible and Maintainable ORB Middleware, </title> <journal> Communications of the ACM, </journal> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: Unfortunately, native OS APIs are not an effective way to develop Web servers or other types of communication middle-ware and applications <ref> [1] </ref>. The following are common pitfalls associated with the use of native OS APIs: Excessive low-level details: Building Web servers with native OS APIs requires developers to have intimate knowledge of low-level OS details.
Reference: [2] <author> M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-man, </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: High potential for errors: Programming to low-level OS APIs is tedious and error-prone due to their lack of type-safety. For example, most Web servers are programmed with the Socket API <ref> [2] </ref>. However, endpoints of communication in the Socket API are represented as untyped handles. This increases the potential for subtle programming mistakes and run-time errors. Lack of portability: Low-level OS APIs are notoriously non-portable, even across releases of the same OS.
Reference: [3] <institution> Information Technology Portable Operating System Interface (POSIX) Part 1: System Application: Program Interface (API) [C Language], </institution> <year> 1995. </year>
Reference-contexts: Steep learning curve: Due to the excessive level of detail, the effort required to master OS-level APIs can be very high. For instance, it is hard to learn how to program POSIX asynchronous I/O <ref> [3] </ref> correctly. It is even harder to learn how to write a portable application using asynchronous I/O mechanisms since they differ widely across OS platforms. Inability to handle increasing complexity: OS APIs define basic interfaces to mechanisms like process and thread management, interprocess communication, file systems, and memory management.
Reference: [4] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: However, these basic interfaces do not scale up gracefully as applications grow in size and complexity. For instance, a typical UNIX process allows a backlog of only ~7 pending connections <ref> [4] </ref>. This number is inadequate for heavily accessed Web servers that process hundreds of simultaneous clients. 1.2 Overcoming Web Server Pitfalls with Pat terns and Frameworks Software reuse is a a widely touted method of reducing development effort. Reuse leverages the application domain knowledge and prior effort of experienced developers.
Reference: [5] <author> M. E. Fayad and D. C. Schmidt, </author> <title> Object-Oriented Application Frameworks, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: A more powerful way to overcome the pitfalls described above is to identify the patterns that underlie proven Web servers and to reify these patterns in object-oriented application frameworks <ref> [5] </ref>. Patterns and frameworks help alleviate the continual rediscovery and reinvention of key Web server concepts and components by capturing solutions to common software development problems [6]. The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. <p> As a result, the framework reifies an integrated set of patterns, which are pre-applied into collaborating components. This design reduces the burden for software developers. In practice, frameworks, class libraries, and components are complementary technologies <ref> [5] </ref>. Frameworks often utilize class libraries and components internally to simplify the development of the framework. For instance, portions of the JAWS framework use the string and vector containers provided by the C++ Standard Template Library [11] to manage connection maps and other search structures.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Patterns and frameworks help alleviate the continual rediscovery and reinvention of key Web server concepts and components by capturing solutions to common software development problems <ref> [6] </ref>. The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor [7] and Active Object [8] patterns are widely used as Web server dispatching and concurrency strategies, respectively. <p> In contrast to class libraries, components in a framework are more active. In particular, they manage the canonical flow of control within an application via event dispatching patterns like Reactor [7] and Observer <ref> [6] </ref>. The callback-driven run-time architecture of a framework is shown in Figure 2. inversion of control at run-time. <p> As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [6] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [6] or pre-determined at initialization-time. The Service Configurator pattern [14] is used to configure a particular concurrency strategy into a Web server at run-time. <p> JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [6] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [6] or pre-determined at initialization-time. The Service Configurator pattern [14] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. This is illustrated in Figure 5. <p> Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asynchronous Completion Token [15] pattern and Proactor [16] pattern, as illustrated in Figure 6. Reactive I/O is accomplished through the Reactor pattern [7]. Reactive I/O utilizes the Memento pattern <ref> [6] </ref> to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. <p> Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. A Protocol Handler is parameterized by a con-currency strategy and an I/O strategy. These strategies are de-coupled from the protocol handler using the Adapter <ref> [6] </ref> pattern. In JAWS, this component implements the parsing and 4 handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP [17]) to be incorporated easily into JAWS. <p> Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access. Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [6] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern, as shown in Figure 7. The cache for each Web server is instantiated using the Singleton pattern [6]. <p> following the Strategy pattern <ref> [6] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern, as shown in Figure 7. The cache for each Web server is instantiated using the Singleton pattern [6]. Tilde Expander: This component is another cache component that uses a perfect hash table [19] that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [7] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Patterns and frameworks help alleviate the continual rediscovery and reinvention of key Web server concepts and components by capturing solutions to common software development problems [6]. The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor <ref> [7] </ref> and Active Object [8] patterns are widely used as Web server dispatching and concurrency strategies, respectively. Traditionally, these types of patterns have either been locked in the heads of the expert developers or buried deep within the source code. <p> In contrast to class libraries, components in a framework are more active. In particular, they manage the canonical flow of control within an application via event dispatching patterns like Reactor <ref> [7] </ref> and Observer [6]. The callback-driven run-time architecture of a framework is shown in Figure 2. inversion of control at run-time. <p> Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asynchronous Completion Token [15] pattern and Proactor [16] pattern, as illustrated in Figure 6. Reactive I/O is accomplished through the Reactor pattern <ref> [7] </ref>. Reactive I/O utilizes the Memento pattern [6] to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications.
Reference: [8] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor [7] and Active Object <ref> [8] </ref> patterns are widely used as Web server dispatching and concurrency strategies, respectively. Traditionally, these types of patterns have either been locked in the heads of the expert developers or buried deep within the source code. Allowing this valuable information to reside only in these locations is risky and expensive. <p> The Service Configurator pattern [14] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern <ref> [8] </ref>. This is illustrated in Figure 5. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously.
Reference: [9] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: However, reuse of patterns alone is not sufficient to create flexible and efficient Web server software. While patterns enable reuse of abstract design and architecture knowledge, abstractions documented as patterns do not directly yield reusable code <ref> [9] </ref>.
Reference: [10] <author> R. Johnson, </author> <title> Frameworks = Patterns + Components, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: reinvention of standard Web server components by implementing common design patterns and factoring out common implementation roles. 1.3 Relationship Between Frameworks, Pat terns, and Other Reuse Techniques Frameworks provide reusable software components for applications by integrating sets of abstract classes and defining standard ways that instances of these classes collaborate <ref> [10] </ref>. In general, the components are not self-contained, since they usually depend upon functionality provided by other components within the framework. However, the collection of these components forms a partial implementation, i.e., an application skeleton.
Reference: [11] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Rep. </type> <institution> HPL-94-34, Hewlett-Packard Laboratories, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In practice, frameworks, class libraries, and components are complementary technologies [5]. Frameworks often utilize class libraries and components internally to simplify the development of the framework. For instance, portions of the JAWS framework use the string and vector containers provided by the C++ Standard Template Library <ref> [11] </ref> to manage connection maps and other search structures.
Reference: [12] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The overall JAWS framework contains the following components and frameworks: an Event Dispatcher, Concurrency Strategy, I/O Strategy, Protocol Pipeline, Protocol Handlers, and Cached Virtual Filesystem. Each framework is structured as a set of collaborating objects implemented using components in ACE <ref> [12] </ref>. The collaborations among JAWS components and frameworks are guided by a family of patterns, which are listed along the borders in Figure 3.
Reference: [13] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The references provide additional information on each pattern mentioned below. As illustrated in Figure 4, the passive establishment of connection events with Web clients follows the Acceptor pattern <ref> [13] </ref>. New incoming HTTP request events are serviced by a concurrency strategy. As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy.
Reference: [14] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [6] or pre-determined at initialization-time. The Service Configurator pattern <ref> [14] </ref> is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. This is illustrated in Figure 5.
Reference: [15] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: This is illustrated in Figure 5. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asynchronous Completion Token <ref> [15] </ref> pattern and Proactor [16] pattern, as illustrated in Figure 6. Reactive I/O is accomplished through the Reactor pattern [7]. Reactive I/O utilizes the Memento pattern [6] to capture and externalize the state of a request so that it can be restored at a later time.
Reference: [16] <author> T. Harrison, I. Pyarali, D. C. Schmidt, and T. Jordan, </author> <title> Proac-tor An Object Behavioral Pattern for Dispatching Asynchronous Event Handlers, </title> <booktitle> in The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year> <month> 6 </month>
Reference-contexts: This is illustrated in Figure 5. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asynchronous Completion Token [15] pattern and Proactor <ref> [16] </ref> pattern, as illustrated in Figure 6. Reactive I/O is accomplished through the Reactor pattern [7]. Reactive I/O utilizes the Memento pattern [6] to capture and externalize the state of a request so that it can be restored at a later time.
Reference: [17] <institution> Object Management Group, Control and Management of Au--dio/Video Streams: OMG RFP Submission, 1.2 ed., </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: These strategies are de-coupled from the protocol handler using the Adapter [6] pattern. In JAWS, this component implements the parsing and 4 handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP <ref> [17] </ref>) to be incorporated easily into JAWS. To add a new protocol, developers simply write a new Protocol Handler implementation, which is then configured into the JAWS framework. Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler.
Reference: [18] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler. This integration is achieved by employing the Adapter pattern. Pipelines follow the Pipes and Filters pattern <ref> [18] </ref> for input processing. Pipeline components can be linked dynamically at run-time using the Service Configurator pattern, as shown in Figure 7. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access.
Reference: [19] <author> D. C. Schmidt, GPERF: </author> <title> A Perfect Hash Function Generator, </title> <booktitle> in Proceedings of the 2 nd C++ Conference, </booktitle> <address> (San Francisco, California), </address> <pages> pp. 87102, </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern, as shown in Figure 7. The cache for each Web server is instantiated using the Singleton pattern [6]. Tilde Expander: This component is another cache component that uses a perfect hash table <ref> [19] </ref> that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [20] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: By virtue of the Service Configurator pattern, the Tilde Expander can be unlinked and relinked dynamically into the server when a new user is added to the system. 2.2 JAWS Web Server Performance Our research <ref> [20, 21] </ref> demonstrates that it is possible to improve server performance through superior server design (a similar observation was made in [22]).
Reference: [21] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: By virtue of the Service Configurator pattern, the Tilde Expander can be unlinked and relinked dynamically into the server when a new user is added to the system. 2.2 JAWS Web Server Performance Our research <ref> [20, 21] </ref> demonstrates that it is possible to improve server performance through superior server design (a similar observation was made in [22]). <p> We achieved this level of performance through systematic benchmarking of different configurations of JAWS under different server load conditions. We then selected the combination of features that yielded the best overall performance <ref> [21] </ref>. 3 Concluding Remarks Computing power and network bandwidth has increased dramatically over the past decade. However, the development of high-performance Web servers has remained expensive and error-prone. Much of the cost and effort stems from the repeated rediscovery and reinvention of fundamental design patterns and framework components.
Reference: [22] <author> H. F. Nielsen, J. Gettys, A. Baird-Smith, E. Prud'hommeaux, H. W. Lie, and C. Lilley, </author> <title> Network Performance Effects of HTTP/1.1, CSS1, </title> <journal> and PNG, </journal> <note> in To appear in Proceedings of ACM SIGCOMM '97, </note> <year> 1997. </year>
Reference-contexts: pattern, the Tilde Expander can be unlinked and relinked dynamically into the server when a new user is added to the system. 2.2 JAWS Web Server Performance Our research [20, 21] demonstrates that it is possible to improve server performance through superior server design (a similar observation was made in <ref> [22] </ref>). Thus, while a hard-coded server, i.e., one that uses fixed concurrency, I/O, and caching strategies, can provide excellent performance, a flexible server framewor like JAWS need necessarily not perform poorly.
Reference: [23] <author> D. C. Schmidt and M. E. Fayad, </author> <title> Lessons Learned: Building Reusable OO Frameworks for Distributed Software, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> October </month> <year> 1997. </year> <month> 7 </month>
Reference-contexts: Moreover, the growing heterogeneity of hardware architectures and diversity of OS and network platforms makes it hard to build correct, portable, and efficient Web servers from scratch. In general, OO application frameworks and patterns help to reduce the cost and improve the quality of communication software <ref> [23] </ref>. In the context of Web servers, these benefits 5 accrue from leveraging proven software designs and reusable components that can be customized to meet new application requirements. The JAWS framework described in this article exemplifies how high-performance Web server software development can be simplified and unified.
References-found: 23

