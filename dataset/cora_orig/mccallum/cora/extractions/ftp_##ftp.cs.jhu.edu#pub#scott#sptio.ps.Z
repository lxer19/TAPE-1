URL: ftp://ftp.cs.jhu.edu/pub/scott/sptio.ps.Z
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Email: trifonovg@cs.jhu.edu  
Title: Sound Polymorphic Type Inference for Objects  
Author: Jonathan Eifrig Scott Smith Valery Trifonov feifrig, scott, 
Affiliation: Department of Computer Science, The Johns Hopkins University  
Abstract: A polymorphic, constraint-based type inference algorithm for an object-oriented language is defined. A generalized form of type, polymorphic recursively constrained types, are inferred. These types are expressive enough for typing objects, since they generalize recursive types and F-bounded polymorphism. The well-known tradeoff between inheritance and subtyping is mitigated by the type inference mechanism. Soundness and completeness of type inference are established. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-341, </pages> <year> 1994. </year>
Reference-contexts: I-Soop has been defined and proven sound in [11]. It would also be possible to give a soundness proof for I-Loop directly, but at this stage in the project we feel the insights gained by a translational approach are worth the costs. See for instance <ref> [1] </ref> for ideas on how objects may be directly given meaning.
Reference: [2] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: We define an algorithm to automatically infer a generalized form of type, recursively constrained (rc) types of the form t n C, with " n " reading "where." Types of similar expressive power have been defined by Curtis [10], and Aiken and Wimmers <ref> [2] </ref>. t here is a type, and C is a set of type constraints, each of the form t 1 t 2 . These constraints may be recursive in that a variable t could occur free in both t 1 and t 2 . <p> The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. His work has not received widespread circulation, however. We learned of these richer types through the work of Aiken and Wimmers <ref> [2] </ref>, which demonstrates soundness of a full type inference algorithm for a simple functional language; Curtis only showed soundness of a weaker inference algorithm (he however conjectured soundness of a full algorithm). <p> I-Loop is capable of expressing some glb types, as above, as well as some lub types. Including lub and glb as general type operators presents significant difficulty <ref> [2] </ref>, however, and these restricted forms fulfill most of the need for lub and glb type operations. The type schemes are either monomorphic types or quantified rc types: ::= t j 8ff: These types are a straightforward generalization of Hindley-Milner let-polymorphic types to incorporate constraint sets. <p> In rules with multiple assumptions, the conclusion type constraints are the union of the branches. Since all constraint systems in rule conclusions must be consistent, these unions are required to yield consistent constraint sets if the rule is to be applicable. Other presentations of constrained type systems <ref> [18, 2, 14] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component: they are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent. <p> Some comments are in order about let-polymorphism. (Let) gives let-bound variables polymorphic types in the assumption list, and (PVar) in turn allows instantia-tion of these polymorphic types. This is a straightforward generalization of ML-style let-polymorphism 6 to constrained type systems <ref> [10, 14, 2] </ref>. The technical restriction of quantification over imperative types to the nonexpansive expressions is the standard solution [27] recast in this setting, first shown sound in [11]. The let construct is very important for defining classes.
Reference: [3] <author> K. B. Bruce, J. Crabtree, T. P. Murtagh, R. van Gent, A. Di-mock, and R. Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In OOPSLA '93 Conference Proceedings, </booktitle> <year> 1993. </year>
Reference-contexts: Compared to standard interpretations of object types, this type may seem unusual: since the self type may be used in objects, object types are usually interpreted as recursive types (see e.g. <ref> [12, 3] </ref>). In I-Soop there are no recursive types; the recursion is implicitly found in the constraints imposed on the individual method types, and these constraints may be circular.
Reference: [4] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hop-kins Objects Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <type> Technical Report TR95-08, </type> <institution> Department of Computer Science, Iowa State University, Ames, </institution> <address> Iowa 50011-1040 USA. ftp://ftp.cs.iastate.edu/ pub/techreports/TR95-08/TR.ps.Z, </address> <year> 1995. </year>
Reference-contexts: The multi-method approach has the advantage of avoiding the tradeoff between inheritance and subtyping. One advantage of our rich type language is Ingalls' solution [13] can be used to encode multiple dispatch in our single-dispatch framework. A fuller discussion of these topics is found in <ref> [4] </ref>.
Reference: [5] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. Poly-TOIL: </author> <title> A type-safe polymorphic object-oriented language. </title> <booktitle> In ECOOP '95, </booktitle> <year> 1995. </year>
Reference-contexts: In particular, there is a well-known trade-off between subtyping and inheritance. Most object-oriented languages require the choice of one approach exclusive of the other. For instance in C++ and Object Pascal, inheritance is sub-typing, so binary methods will not inherit properly. In PolyTOIL <ref> [5] </ref> and our Loop language [12], inheritance is not subtyping, so binary methods inherit properly but object subtyping may be limited. <p> This paper presents the first object-oriented language to incorporate rc types and type inference, and shows the soundness and completeness of such a type discipline. state in particular poses difficulty to requires a new proof technique. In the realm of object-oriented languages, Bruce et al. <ref> [5] </ref> have developed an expressive object-oriented programming language, PolyTOIL, with decidable type-checking (not inference), which is similar to our Loop language [12] in that it properly types binary methods in the presence of inheritance. PolyTOIL in addition has a form of higher-order polymorphism. <p> This would increase the usefulness of programming in a mixin-style methodology in I-Loop|mixins are often fragments that are ill-formed as classes per se. The (Class) rule still allows more flexibility than most class typing principles. There is no requirement that the subclass type match its superclass type (s) <ref> [5] </ref>. <p> The function passed to doall should be able to invoke all of the methods defined in GView, in particular draw. This is what is gained from the "inheritance is not subtyping" philosophy, not requiring the type of dep to be fixed as a View <ref> [5, 9] </ref>. In previous work [12] we gave a typing system which allowed the programmer to choose between these two behaviors by the type given to the doall method. <p> This type system also makes contributions to the issue of typing object-oriented programs. The precision of the types allows the "inheritance vs subtyping" decision to be postponed, increasing flexibility. Bruce's PolyTOIL language <ref> [5] </ref> has stronger form of polymorphism that al-lows many of the same notions to be expressed, but the price is the programmer must come up with the complicated PolyTOIL typings, a potentially daunting task.
Reference: [6] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: The problems arise when classes containing binary methods are subclassed: in this process the type of "self" changes, and some notion of operator polymorphism or F-bounded polymorphism is needed to capture this behavior type-theoretically <ref> [9, 6] </ref>. In addition the object types are self-referential (e.g. the type of the argument to add is the same as the object's type), so a form of recursive/self-referential type is also needed. We define a polymorphic, constraint-based type inference algorithm for an object-oriented language, I-Loop. <p> The type schemes are either monomorphic types or quantified rc types: ::= t j 8ff: These types are a straightforward generalization of Hindley-Milner let-polymorphic types to incorporate constraint sets. Since = t n C can contain an arbitrary collection of constraints C, an F-bounded quantified type <ref> [6] </ref> written 8t t : t 0 may be expressed by a polymorphic rc type 8t: t 0 n ft t g. Next we need to define when a set of constraints C is consistent. If C is consistent, t n C is a sensible type.
Reference: [7] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are <ref> [24, 7, 18] </ref>. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages [28, 14, 25]. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. <p> We formally define consistency by first defining a closure operation on a constraint set that performs these simple deductions. The definition of a closed set of constraints C appears in subtyping principles <ref> [7] </ref>. In condition (v), if one instance variable is a subtype of another, the types must in fact be the same; this is because instance variables may be both read and written. In condition (vii), the self-types st are contravariantly related.
Reference: [8] <author> Giuseppe Castagna. </author> <title> Covariance and contravariance: conflict without a cause. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3), </volume> <year> 1995. </year>
Reference-contexts: Our system also allows some union and intersection types to be expressed, a feature absent from PolyTOIL. Poly-TOIL types on the other hand do not suffer from the readability problem of I-Loop constrained types. An alternate school of thought is to use multi-methods instead of binary methods <ref> [8, 19] </ref>. The multi-method approach has the advantage of avoiding the tradeoff between inheritance and subtyping. One advantage of our rich type language is Ingalls' solution [13] can be used to encode multiple dispatch in our single-dispatch framework. A fuller discussion of these topics is found in [4].
Reference: [9] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: The problems arise when classes containing binary methods are subclassed: in this process the type of "self" changes, and some notion of operator polymorphism or F-bounded polymorphism is needed to capture this behavior type-theoretically <ref> [9, 6] </ref>. In addition the object types are self-referential (e.g. the type of the argument to add is the same as the object's type), so a form of recursive/self-referential type is also needed. We define a polymorphic, constraint-based type inference algorithm for an object-oriented language, I-Loop. <p> Class types are thus akin to type operators on st, giving the appropriate "open-ended" view of self <ref> [9, 12] </ref>. The type system of I-Loop assigns expressions recursively constrained (rc) types of the form ::= t n C where C is a set of type constraints|subtyping assertions about pairs of (monomorphic) types, written t 1 t 2 . <p> The function passed to doall should be able to invoke all of the methods defined in GView, in particular draw. This is what is gained from the "inheritance is not subtyping" philosophy, not requiring the type of dep to be fixed as a View <ref> [5, 9] </ref>. In previous work [12] we gave a typing system which allowed the programmer to choose between these two behaviors by the type given to the doall method.
Reference: [10] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <institution> XEROX Palo Alto Research Center, CSLPubs.parc@xerox.com, </institution> <year> 1990. </year>
Reference-contexts: We define an algorithm to automatically infer a generalized form of type, recursively constrained (rc) types of the form t n C, with " n " reading "where." Types of similar expressive power have been defined by Curtis <ref> [10] </ref>, and Aiken and Wimmers [2]. t here is a type, and C is a set of type constraints, each of the form t 1 t 2 . These constraints may be recursive in that a variable t could occur free in both t 1 and t 2 . <p> Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages [28, 14, 25]. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language <ref> [10] </ref>. His work has not received widespread circulation, however. <p> Some comments are in order about let-polymorphism. (Let) gives let-bound variables polymorphic types in the assumption list, and (PVar) in turn allows instantia-tion of these polymorphic types. This is a straightforward generalization of ML-style let-polymorphism 6 to constrained type systems <ref> [10, 14, 2] </ref>. The technical restriction of quantification over imperative types to the nonexpansive expressions is the standard solution [27] recast in this setting, first shown sound in [11]. The let construct is very important for defining classes.
Reference: [11] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proceedings of the 1995 Mathematical Foundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year>
Reference-contexts: We have previously defined a language, I-Soop, that is the non-object-oriented analogue of I-Loop. I-Soop's features include rc types, let-polymorphism, and type inference <ref> [11] </ref>. The current paper shows how these ideas can be applied to an actual object-oriented language. We additionally consider issues of type simplification, since the number of constraints produced by the inference algorithm can be large. <p> In both that paper and the present one, the terms and types of (I-)Loop are translated into (I-)Soop, and soundness means that if an (I-)Loop program is typable, its translation into (I-)Soop is also typable. I-Soop has been defined and proven sound in <ref> [11] </ref>. It would also be possible to give a soundness proof for I-Loop directly, but at this stage in the project we feel the insights gained by a translational approach are worth the costs. See for instance [1] for ideas on how objects may be directly given meaning. <p> We first established completeness of type inference, i.e. that the inference algorithm will find a typing if there exists one, and were the first to incorporate state, which required a completely different proof technique for soundness <ref> [11] </ref>. Aiken and Wimmers have not addressed the problem of typing object-oriented programs, and their language also lacks important features such as state and records necessary for encoding objects. <p> This is a straightforward generalization of ML-style let-polymorphism 6 to constrained type systems [10, 14, 2]. The technical restriction of quantification over imperative types to the nonexpansive expressions is the standard solution [27] recast in this setting, first shown sound in <ref> [11] </ref>. The let construct is very important for defining classes. <p> We then prove these rules are complete: all proofs of typing using the general rules can be transformed into proofs in the restricted inference rules, meaning the inference algorithm will infer a result. A similar strategy was used to prove completeness of a type inference algorithm for I-Soop <ref> [11] </ref>. The I-Loop inference rules appear in inference rule is a restricted form of the combination of 6 Alternative systems for typing polymorphic references could be considered. <p> We give semantics to I-Loop by translation into a more basic language, I-Soop, which lacks object-oriented features but includes records and reference cells. We first define the I-Soop language and type rules. An operational semantics and type rules for I-Soop can be found in <ref> [11] </ref>, along with proofs of subject reduction and soundness of the I-Soop type system. In this paper we only present the I-Soop type rules, taking their soundness as given. We translate I-Loop terms, types, and judgements into I-Soop by three translation functions.
Reference: [12] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> Application of OOP type theory: State, decidability, integration. </title> <booktitle> In OOPSLA '94, </booktitle> <pages> pages 16-30, </pages> <year> 1994. </year>
Reference-contexts: In particular, there is a well-known trade-off between subtyping and inheritance. Most object-oriented languages require the choice of one approach exclusive of the other. For instance in C++ and Object Pascal, inheritance is sub-typing, so binary methods will not inherit properly. In PolyTOIL [5] and our Loop language <ref> [12] </ref>, inheritance is not subtyping, so binary methods inherit properly but object subtyping may be limited. <p> The main technical results of the paper are the soundness and completeness of the type inference system. The I-Loop language and typing rules are shown sound by translation into I-Soop. A similar methodology was carried out in a paper presented at a previous OOPSLA conference <ref> [12] </ref>. That paper was concerned with the problem of type checking for object-oriented languages, not type inference. There we developed a type-checking algorithm for Loop, and proved it sound by translation into the non-object-oriented Soop language. <p> In the realm of object-oriented languages, Bruce et al. [5] have developed an expressive object-oriented programming language, PolyTOIL, with decidable type-checking (not inference), which is similar to our Loop language <ref> [12] </ref> in that it properly types binary methods in the presence of inheritance. PolyTOIL in addition has a form of higher-order polymorphism. I-Loop allows for inference of higher-order polymorphic types in the form of rc types. <p> Class types are thus akin to type operators on st, giving the appropriate "open-ended" view of self <ref> [9, 12] </ref>. The type system of I-Loop assigns expressions recursively constrained (rc) types of the form ::= t n C where C is a set of type constraints|subtyping assertions about pairs of (monomorphic) types, written t 1 t 2 . <p> Compared to standard interpretations of object types, this type may seem unusual: since the self type may be used in objects, object types are usually interpreted as recursive types (see e.g. <ref> [12, 3] </ref>). In I-Soop there are no recursive types; the recursion is implicitly found in the constraints imposed on the individual method types, and these constraints may be circular. <p> For most of the I-Loop rules this fact follows directly. The (Class) rule has the added complication of needing a typing for x. ; with will require extra constraints be added to type this function, tional restrictions on the form of translation that may be used; in <ref> [12] </ref> we presented a simpler translation of classes that in addition allows s to be used in instance variable initializations. That translation could in theory be used here, but objects would necessarily have imperative type, restricting polymorphism. the source of the C 0 above. <p> The function passed to doall should be able to invoke all of the methods defined in GView, in particular draw. This is what is gained from the "inheritance is not subtyping" philosophy, not requiring the type of dep to be fixed as a View [5, 9]. In previous work <ref> [12] </ref> we gave a typing system which allowed the programmer to choose between these two behaviors by the type given to the doall method.
Reference: [13] <author> Daniel H. H. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <booktitle> In OOPSLA '86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <booktitle> volume 21(11), </booktitle> <pages> pages 347-349, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: An alternate school of thought is to use multi-methods instead of binary methods [8, 19]. The multi-method approach has the advantage of avoiding the tradeoff between inheritance and subtyping. One advantage of our rich type language is Ingalls' solution <ref> [13] </ref> can be used to encode multiple dispatch in our single-dispatch framework. A fuller discussion of these topics is found in [4].
Reference: [14] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, sub-typing and recursive types. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 193-204, </pages> <year> 1992. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are [24, 7, 18]. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages <ref> [28, 14, 25] </ref>. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. His work has not received widespread circulation, however. <p> In rules with multiple assumptions, the conclusion type constraints are the union of the branches. Since all constraint systems in rule conclusions must be consistent, these unions are required to yield consistent constraint sets if the rule is to be applicable. Other presentations of constrained type systems <ref> [18, 2, 14] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component: they are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent. <p> Some comments are in order about let-polymorphism. (Let) gives let-bound variables polymorphic types in the assumption list, and (PVar) in turn allows instantia-tion of these polymorphic types. This is a straightforward generalization of ML-style let-polymorphism 6 to constrained type systems <ref> [10, 14, 2] </ref>. The technical restriction of quantification over imperative types to the nonexpansive expressions is the standard solution [27] recast in this setting, first shown sound in [11]. The let construct is very important for defining classes.
Reference: [15] <author> Samuel N. Kamin and Uday S. Reddy. </author> <title> Two semantic models of object-oriented languages. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, chapter 13, </booktitle> <pages> pages 464-495. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The core idea of the translation is the classic encoding of objects as records, classes as functions from the self to a record, and new as a fixed-point operation <ref> [15] </ref>. However in order to get a general trans lation that works in a call-by-value setting, and incorpo rates instance variables and their initialization and hiding, more structure is required.
Reference: [16] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Type inference, the process of automatically inferring type information from untyped programs, is originally due to Hindley and Milner <ref> [16] </ref>. These ideas have found their way into some recent innovative programming languages, including Standard ML [17]. The type inference problem for object-oriented languages is a challenging one: even simple object-oriented programs require quite advanced features to be present in the type system.
Reference: [17] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Type inference, the process of automatically inferring type information from untyped programs, is originally due to Hindley and Milner [16]. These ideas have found their way into some recent innovative programming languages, including Standard ML <ref> [17] </ref>. The type inference problem for object-oriented languages is a challenging one: even simple object-oriented programs require quite advanced features to be present in the type system. One of the main sources of difficulty lies with binary methods, such as an add method on Number objects.
Reference: [18] <author> J. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are <ref> [24, 7, 18] </ref>. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages [28, 14, 25]. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. <p> In rules with multiple assumptions, the conclusion type constraints are the union of the branches. Since all constraint systems in rule conclusions must be consistent, these unions are required to yield consistent constraint sets if the rule is to be applicable. Other presentations of constrained type systems <ref> [18, 2, 14] </ref> do not require local consistency, so the constraints in the rules have both a hypothetical and assertional component: they are hypothetical in that they may be inconsistent, and they are assertional in that they assert properties of the type if they are consistent.
Reference: [19] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-methods in a statically-typed programming language. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP '91 Conference Proceedings, Geneva, Switzerland, volume 512 of Lecture notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Our system also allows some union and intersection types to be expressed, a feature absent from PolyTOIL. Poly-TOIL types on the other hand do not suffer from the readability problem of I-Loop constrained types. An alternate school of thought is to use multi-methods instead of binary methods <ref> [8, 19] </ref>. The multi-method approach has the advantage of avoiding the tradeoff between inheritance and subtyping. One advantage of our rich type language is Ingalls' solution [13] can be used to encode multiple dispatch in our single-dispatch framework. A fuller discussion of these topics is found in [4].
Reference: [20] <author> N. Oxhtj, J. Palsberg, and M. I. Schwartzbach. </author> <title> Type inference with subtypes. </title> <booktitle> In ECOOP'92 European Conference on Object-Oriented Programming, volume 615 of Lecture notes in Computer Science, </booktitle> <pages> pages 329-349. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This topic will be discussed in more detail in the body of the paper. Palsberg, Schwartzbach, et al. have a number of significant results concerning type inference for object-oriented languages <ref> [21, 20, 22] </ref>. They have developed a novel type inference procedure that is rooted in the ideas of flow analysis. They show how their approach may be used to infer the type-correctness of object-oriented programs. Other advantages of their approach include asymptotically efficient inference algorithms, and named class types.
Reference: [21] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: This topic will be discussed in more detail in the body of the paper. Palsberg, Schwartzbach, et al. have a number of significant results concerning type inference for object-oriented languages <ref> [21, 20, 22] </ref>. They have developed a novel type inference procedure that is rooted in the ideas of flow analysis. They show how their approach may be used to infer the type-correctness of object-oriented programs. Other advantages of their approach include asymptotically efficient inference algorithms, and named class types.
Reference: [22] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <pages> pages 175-180, </pages> <year> 1992. </year>
Reference-contexts: This topic will be discussed in more detail in the body of the paper. Palsberg, Schwartzbach, et al. have a number of significant results concerning type inference for object-oriented languages <ref> [21, 20, 22] </ref>. They have developed a novel type inference procedure that is rooted in the ideas of flow analysis. They show how their approach may be used to infer the type-correctness of object-oriented programs. Other advantages of their approach include asymptotically efficient inference algorithms, and named class types.
Reference: [23] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In Proceedings of the Ninth Annual ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 324-340, </pages> <year> 1994. </year>
Reference-contexts: Other advantages of their approach include asymptotically efficient inference algorithms, and named class types. Their system however has no polymorphism, and they take a code-expansion view of inheritance, requiring re-type-checking with each class extension. It also requires the whole program to be present, interfering with modularity. Plevyak and Chien <ref> [23] </ref> have extended this flow-based approach to incorporate a notion of polymorphism via the concept of splitting the flow graph. Their aims and approach are somewhat different than ours, but a comparison is nonetheless possible.
Reference: [24] <author> J. C. Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In TAP-SOFT proceedings, volume 185 of Lecture notes in Computer Science, </booktitle> <pages> pages 97-138, </pages> <year> 1985. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are <ref> [24, 7, 18] </ref>. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages [28, 14, 25]. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10].
Reference: [25] <author> T. Sekiguchi and A. Yonezawa. </author> <title> A complete type inference system for subtyped recursive types. </title> <booktitle> In Proc. Theoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 667-686. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are [24, 7, 18]. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages <ref> [28, 14, 25] </ref>. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. His work has not received widespread circulation, however.
Reference: [26] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The type and effect discipline. </title> <booktitle> In Proceedings of the Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-173. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: A similar strategy was used to prove completeness of a type inference algorithm for I-Soop [11]. The I-Loop inference rules appear in inference rule is a restricted form of the combination of 6 Alternative systems for typing polymorphic references could be considered. For instance inference of effect constraints <ref> [26] </ref> appears to be orthogonal to the inference of subtyping constraints in I-Loop. (Sub) with a single general rule. So, the inference rules are a restricted version of the general rules.
Reference: [27] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: A substitution on fffg is a map 2 TyVar ! Typ which is the identity on TyVar n fffg and maps ImpTyVar to imperative types; a renaming of fffg is a substitution on fffg with Codom () TyVar. Following Tofte <ref> [27] </ref> we form type schemes by making the sets of type variables we generalize over dependent on the expansiveness of the expression: an expression is expansive if and only if it is not a value; in I-Loop values are the identifiers, numerals, -abstractions, classes, and injections of values. <p> has type 4 Indeed in our example committing to result type Nat would prevent the subclass BoolOrd from type-checking: its method value should return a boolean, the type of its x. 5 Since the instance variables t j are mutable, their types must be imperative as per Tofte's type discipline <ref> [27] </ref>; Nat trivially satisfies this|it contains no type variables. st. We just finished proving these requirements for the two methods, value and leq. <p> This is a straightforward generalization of ML-style let-polymorphism 6 to constrained type systems [10, 14, 2]. The technical restriction of quantification over imperative types to the nonexpansive expressions is the standard solution <ref> [27] </ref> recast in this setting, first shown sound in [11]. The let construct is very important for defining classes.
Reference: [28] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the Second Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 37-44. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Three classic papers on subtyping and type constraints are [24, 7, 18]. Constrained type inference algorithms that are somewhat weaker than the approach we take have been developed for conventional languages <ref> [28, 14, 25] </ref>. The stronger version of types with recursive constraints, polymorphism, and type inference was first formulated by Curtis in his purely functional PLEAT language [10]. His work has not received widespread circulation, however.
References-found: 28

