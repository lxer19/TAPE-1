URL: http://www.cs.umd.edu/users/cml/work/pubs/1998-issre.ps.gz
Refering-URL: http://www.cs.umd.edu/users/cml/work/pubs/
Root-URL: 
Title: Model-Based Testing of a Highly Programmable System  
Author: S. R. Dalal, A. Jain, N. Karunanithi, J. M. Leaton, C. M. Lott fsid, jain, karun, jleaton, 
Keyword: software testing, model-based testing, automatic test-case generation, ISCP, AETG.  
Note: Contact: Christopher M. Lott,  
Address: 445 South Street, Morristown NJ 07960, USA  
Affiliation: Bellcore Applied Research,  
Email: lottg@bellcore.com  
Phone: tel. +1 973 829-2149, fax +1 973 829-2645  
Date: March 31, 1998  
Abstract: The paradigm of model-based testing shifts the focus of testing from writing individual test cases to developing a model from which a test suite can be generated automatically. We report on our experience with model-based testing of a highly programmable system that implements intelligent telephony services in the U.S. telephone network. Our approach used automatic test-case generation technology to develop sets of self-checking test cases based on a machine-readable specification of the messages in the protocol under test. We used the AETG System TM to select a minimal number of test-data tuples that covered pairwise combinations of tuple elements. Key lessons learned from our experience with model-based testing include the following. First, we found combinatorial approach of covering pairwise interactions between input fields to be highly effective. Our tests revealed failures that would have been difficult to detect using traditional test designs. Second, we note that the model is the key to success or failure of the effort. Third, technology transfer is difficult for several reasons. Automatic generation of cases is a significant departure from conventional testing practice due to the large number of tests (often thousands) and the considerable amount of development involved, so professional testers tend to view it with a fair amount of suspicion. 
Abstract-found: 1
Intro-found: 1
Reference: [BM83] <author> D. L. Bird and C. U. Munoz. </author> <title> Automatic generation of random self-checking test cases. </title> <journal> IBM Systems Journal, </journal> <volume> 22(3):229245, </volume> <year> 1983. </year>
Reference-contexts: Bird and Munoz discuss specific test-case generators with emphasis on generating self-checking code to support compiler testing <ref> [BM83] </ref>. Ince surveys previous work on selecting test data [Inc87]. Ostrand and Balcer discuss work that is quite close to ours, in that they generate functional test suites automatically using formal test specifications [OB88].
Reference: [Bur93] <author> C. J. Burgess. </author> <title> Software testing using an automatic generator of test data. </title> <editor> In M. Ross, editor, </editor> <booktitle> First International Conference on Software Quality Management (SQM93), </booktitle> <pages> pages 541556, </pages> <address> Southampton, UK, </address> <month> April </month> <year> 1993. </year> <institution> Comput. Mech. </institution>
Reference-contexts: Camuffo et al. report on an approach based on annotated grammars that seems especially suited to generating tests for compilers [CMM90]. Maurer reviews the advantages and disadvantages of generating test data with context-free grammars [Mau90]. Burgess reviews the main techniques in constructing systems to generate test data <ref> [Bur93] </ref>. The use of techniques from experimental design to choose test-case tuples is relatively new.
Reference: [CDFP97] <author> David M. Cohen, Siddhartha R. Dalal, Michael L. Fredman, and Gardner C. Patton. </author> <title> The AETG system: An approach to testing based 18 on combinatorial design. </title> <journal> IEEE Transactions on Software Engineer--ing, </journal> <volume> 23(7):437444, </volume> <month> July </month> <year> 1997. </year>
Reference-contexts: Second, we hypoth-esized that the use of pairwise-complete tuples generated by Bellcore's AETG System 1 would reveal more failures than tuples selected by the traditional, manual approach. Additionally, previous experience with model-based testing using AETG was highly promising <ref> [CDFP97] </ref>. The problems in the work of automatically generating test cases for a reactive system using a test model include at least the following items: 1. Selecting valid and invalid values for individual fields 2. <p> Values were selected based on the data type of the value, with emphasis on boundary and average values. This work used a novel approach for items 2 and 3, namely the AETG System that was developed in Bellcore's Applied Research division <ref> [CDFP97] </ref>. The AETG System supports the generation of input test data (tuples) in which every distinct value possible for each tuple element appears at least once with every other distinct value of every other tuple element, a notion called pairwise coverage. <p> input, and a test case includes both inputs and expected outputs. 6 Category Examples Arithmetic add, subtract, multiply String clrbit, setbit, concat, match Logical and, or, xor Time and date datestr, timestr, date+, time+ Table addrow, delrow, selrow Table 1: Basic manipulators tested in project 1 using the AETG system <ref> [CDKP94, CDPP96, CDFP97] </ref>.
Reference: [CDKP94] <author> D. M. Cohen, S. R. Dalal, A. Kajla, and G. C. Patton. </author> <title> The automatic efficient test generator (AETG) system. </title> <booktitle> In Proceedings of the Fifth International Symposium on Software Reliability Engineering, </booktitle> <pages> pages 303309. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: input, and a test case includes both inputs and expected outputs. 6 Category Examples Arithmetic add, subtract, multiply String clrbit, setbit, concat, match Logical and, or, xor Time and date datestr, timestr, date+, time+ Table addrow, delrow, selrow Table 1: Basic manipulators tested in project 1 using the AETG system <ref> [CDKP94, CDPP96, CDFP97] </ref>.
Reference: [CDPP96] <author> David M. Cohen, Siddhartha R. Dalal, Jesse Parelius, and Gardner C. Patton. </author> <title> The combinatorial design approach to automatic test generation. </title> <journal> IEEE Software, </journal> <volume> 13(5):8388, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: input, and a test case includes both inputs and expected outputs. 6 Category Examples Arithmetic add, subtract, multiply String clrbit, setbit, concat, match Logical and, or, xor Time and date datestr, timestr, date+, time+ Table addrow, delrow, selrow Table 1: Basic manipulators tested in project 1 using the AETG system <ref> [CDKP94, CDPP96, CDFP97] </ref>.
Reference: [CMM90] <author> M. Camuffo, M. Maiocchi, and M. Morselli. </author> <title> Automatic software test generation. </title> <journal> Information and Software Technology, </journal> <volume> 32(5):337346, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Ostrand and Balcer discuss work that is quite close to ours, in that they generate functional test suites automatically using formal test specifications [OB88]. Camuffo et al. report on an approach based on annotated grammars that seems especially suited to generating tests for compilers <ref> [CMM90] </ref>. Maurer reviews the advantages and disadvantages of generating test data with context-free grammars [Mau90]. Burgess reviews the main techniques in constructing systems to generate test data [Bur93]. The use of techniques from experimental design to choose test-case tuples is relatively new.
Reference: [DES + 97] <author> I. S. Dunietz, W. K. Ehrlich, B. D. Szablak, C. L. Mallows, and A. Ian-nino. </author> <title> Applying design of experiments to software testing. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Software Engineering, pages 205215. </booktitle> <publisher> ACM Press, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: Dunietz et al. report on their experience with attaining code coverage based on 2-way, 3-way, and higher coverage of values within test tuples <ref> [DES + 97] </ref>. 3 Project 1: Basic Manipulators The first project addressed the automatic generation of test cases for basic manipulators provided by the ISCP software. These manipulators are basic infrastructure used in every release of the software.
Reference: [DLS78] <author> Richard A. DeMillo, Richard J. Lipton, and Frederick G. Sayward. </author> <title> Hints on test data selection: help for the practicing programmer. </title> <journal> IEEE Computer, </journal> <volume> 11(4):3441, </volume> <month> April </month> <year> 1978. </year>
Reference-contexts: Developing scaffolding for running the tests 5. Calculating the expected results (i.e., an oracle) 6. Demonstrating the effectiveness of the effort (i.e., finding failures at an ac ceptable cost) A conventional approach was used to select individual values (item 1), much along the lines of that proposed in <ref> [DLS78] </ref>. Values were selected based on the data type of the value, with emphasis on boundary and average values. This work used a novel approach for items 2 and 3, namely the AETG System that was developed in Bellcore's Applied Research division [CDFP97].
Reference: [Inc87] <author> D. C. Ince. </author> <title> The automatic generation of test data. </title> <journal> Computer Journal, </journal> <volume> 30(1):6369, </volume> <year> 1987. </year>
Reference-contexts: Bird and Munoz discuss specific test-case generators with emphasis on generating self-checking code to support compiler testing [BM83]. Ince surveys previous work on selecting test data <ref> [Inc87] </ref>. Ostrand and Balcer discuss work that is quite close to ours, in that they generate functional test suites automatically using formal test specifications [OB88]. Camuffo et al. report on an approach based on annotated grammars that seems especially suited to generating tests for compilers [CMM90].
Reference: [Mau90] <author> Peter M. Maurer. </author> <title> Generating test data with enhanced context-free grammars. </title> <journal> IEEE Software, </journal> <volume> 7(4):5055, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Camuffo et al. report on an approach based on annotated grammars that seems especially suited to generating tests for compilers [CMM90]. Maurer reviews the advantages and disadvantages of generating test data with context-free grammars <ref> [Mau90] </ref>. Burgess reviews the main techniques in constructing systems to generate test data [Bur93]. The use of techniques from experimental design to choose test-case tuples is relatively new.
Reference: [OB88] <author> Thomas J. Ostrand and Marc J. Balcer. </author> <title> The category-partition method for specifying and generating functional tests. </title> <journal> Communications of the ACM, </journal> <volume> 31(6):676686, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: Ince surveys previous work on selecting test data [Inc87]. Ostrand and Balcer discuss work that is quite close to ours, in that they generate functional test suites automatically using formal test specifications <ref> [OB88] </ref>. Camuffo et al. report on an approach based on annotated grammars that seems especially suited to generating tests for compilers [CMM90]. Maurer reviews the advantages and disadvantages of generating test data with context-free grammars [Mau90]. Burgess reviews the main techniques in constructing systems to generate test data [Bur93].
Reference: [RHC76] <author> C. V. Ramamoorthy, Siu-bun F. Ho, and W. T. Chen. </author> <title> On the automated generation of program test data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(4):293300, </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: testing Much work has been done on automated generation of test data and test cases, with significant emphasis on testing compilers using automatically generated bits of code. 2 Ramamoorthy et al. discuss the use of symbolic execution to discover the test data that will achieve statement, branch, and path coverage <ref> [RHC76] </ref>. Bird and Munoz discuss specific test-case generators with emphasis on generating self-checking code to support compiler testing [BM83]. Ince surveys previous work on selecting test data [Inc87].
Reference: [Rob91] <author> Richard B. Robrock, </author> <title> II. </title> <booktitle> The intelligent networkchanging the face of telecommunciations. Proceedings of the IEEE, </booktitle> <address> 79(1):720, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: The ISCP implements telephony services made possible by features of the intelligent networks deployed in the telephone systems of the U.S. and elsewhere. The first phase of implementing an intelligent telephony network in the U.S. introduced centralized databases as a fundamental building block in the network infrastructure <ref> [Rob91] </ref>. The result was called the Intelligent Network. The centralized databases allowed telephone end offices (switches) in the U.S. to support new services without replicating and tailoring service logic for each end office. In other words, nearly every telephone subscriber gained access to the same service at the same time.
References-found: 13

