URL: file://theory.lcs.mit.edu/pub/people/rosario/eurocrypt95.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~rosario/research.html
Root-URL: 
Title: Verifiable Secret Sharing as Secure Computation  
Author: Rosario Gennaro and Silvio Micali 
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: Verifiable Secret Sharing is a fundamental primitive for secure cryptographic design. We present a stronger notion of verifiable secret sharing and exhibit a protocol implementing it. We show that our new notion is preferable to the old ones whenever verifiable secret sharing is used as a tool within larger protocols, rather than being a goal in itself. Indeed our definition, and so our protocol satisfying it, provably guarantees reducibilty. Applications of this new notion in the field of secure multiparty computation are also provided.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. </author> <title> Completeness theorems for non-cryptographic fault-tolerant distributed computation. </title> <booktitle> In 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1988. </year>
Reference-contexts: Email address: rosario@theory.lcs.mit.edu. Research supported by NSF grant no.9121466-CCR Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [4, 1, 3, 7, 10] </ref>.) We contend, however, that these notions and these protocols are of very limited use. <p> We propose a new definition of VSS casted as a special istance of secure function evaluation. 2. We compare our new notion with the previously proposed ones, and show that it is strictly and inherently stronger. 3. We modify earlier VSS protocols of <ref> [1, 10] </ref> and show that our new protocol is secure according to our notion. 4. Finally we present some applications that use VSS as a subroutine and need our stronger notion of VSS to be secure. <p> Finally we present some applications that use VSS as a subroutine and need our stronger notion of VSS to be secure. These include shared authentications and signatures and a very elegant proof of the security of the completeness theorem on multiparty secure computation by Ben-Or, Goldwasser and Wigderson. <ref> [1] </ref> 2 Prior work In order to focus on the difficulties that are proper of VSS, we shall deal with a simple computational model, both when reviewing prior work and when presenting our new one. Computational Model. We consider n players communicating via a very convenient synchronous network. <p> 2. (t-uniformity.) 8l t there exists an integer n l such that 8 s i 1 ; : : : ; s i l 2 and 8 v 1 ; : : : ; v n1 2 , 8 s 2 S, and 8x 2 n such that 8j 2 <ref> [1; l] </ref> x i j = s i j , there exist exactly n l values r 1 ; : : : ; r n l 2 R such that for i = 1; : : : ; n l , shar (v 1 ; : : : ; v n1 <p> Definition 4 is strictly stronger than Definition 1, that is, there are VSS protocols satisfying Definition 1, but not Definition 4. The proof of this theorem (see the appendix for a detailed proof) is based on the fact that usually VSS protocols (consider for example the one in <ref> [1] </ref>) reconstruct the secret by having each player distributing his own share to all other players. This does satisfy Definition 1 since there we do not put any requirement on the secrecy of the shares. <p> a t + 1-dimensional space and shares are random hyperplanes passing through that point. 5 A VSS protocol that satisfies our definition In this section we will exhibit a VSS protocol satisfying our definition and of fault-tolerance n 3 1, by modifying an older protocol of Ben-Or, Goldwasser, and Wigderson <ref> [1] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed by [1], but within their "computational protocol" rather than in their VSS protocol. <p> VSS protocol that satisfies our definition In this section we will exhibit a VSS protocol satisfying our definition and of fault-tolerance n 3 1, by modifying an older protocol of Ben-Or, Goldwasser, and Wigderson <ref> [1] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed by [1], but within their "computational protocol" rather than in their VSS protocol. We have also found a protocol of fault-tolerance n 2 1 based on Tal Rabin's protocol [10], but we will not describe it here for space limitations. Suppose we are dealing with a t-adversary A. <p> This is the well known Berlekamp-Welch variant of the Reed-Solomon error-correcting code. For details readers can refer to a standard text like [12]. Let K be a security parameter. With K=n we mean K The protocol appears in the boxes. The Share-Verify part is identical to the one in <ref> [1] </ref>. The Recover protocol is modified with respect to the one in [1] in order to make it a secure computation of the function rec. <p> For details readers can refer to a standard text like [12]. Let K be a security parameter. With K=n we mean K The protocol appears in the boxes. The Share-Verify part is identical to the one in <ref> [1] </ref>. The Recover protocol is modified with respect to the one in [1] in order to make it a secure computation of the function rec. <p> The proof uses a bivariate polynomial and it is out of the scope of this paper. Details can be found in <ref> [1, 7] </ref>. Notice that this is the first time a formal proof of the security of the protocol of [1] appeared. <p> The proof uses a bivariate polynomial and it is out of the scope of this paper. Details can be found in [1, 7]. Notice that this is the first time a formal proof of the security of the protocol of <ref> [1] </ref> appeared. <p> Protocol Share-Verify from <ref> [1] </ref> 1. The dealer chooses a random polynomial f 0 (x) of degree t + 1 with the only condition that f 0 (0) = s his secret. Then he sends to player P i the share s i = f 0 (i).
Reference: 2. <author> G.R. Blakley. </author> <title> Safeguarding cryptographic keys. </title> <booktitle> In National Computer Conference, </booktitle> <pages> pages 313-317, </pages> <year> 1979. </year>
Reference-contexts: It is thus needed that the knowledge gainable by an adversary at the end of a secure VSS protocol exactly coincides with the original secret whenever the dealer is honest. 3 For example consider Blakley secret sharing scheme <ref> [2] </ref> in which the secret is a point in a t + 1-dimensional space and shares are random hyperplanes passing through that point. 5 A VSS protocol that satisfies our definition In this section we will exhibit a VSS protocol satisfying our definition and of fault-tolerance n 3 1, by modifying
Reference: 3. <author> David Chaum, Claude Crepeau, and Ivan Damgard. </author> <title> Multiparty unconditionally secure protocols. </title> <booktitle> In 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 11-19, </pages> <year> 1988. </year>
Reference-contexts: Email address: rosario@theory.lcs.mit.edu. Research supported by NSF grant no.9121466-CCR Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [4, 1, 3, 7, 10] </ref>.) We contend, however, that these notions and these protocols are of very limited use.
Reference: 4. <author> Benny Chor, Shafi Goldwasser, Silvio Micali, and Baruch Awerbuch. </author> <title> Verifiable secret sharing and achieving simultaneity in the presence of faults. </title> <booktitle> In 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 383-395, </pages> <year> 1985. </year>
Reference-contexts: Unfortunately no prior notion of a VSS provably guarantees reducibility. Thus it is a goal of this paper to provide such a definition and a VSS protocol that satisfies it. The intuitive notion of a VSS. As first introduced by Chor, Goldwasser, Micali and Awerbuch in <ref> [4] </ref>, a VSS protocol consists of a two-stage protocol. Informally, there are n players, t of which may be bad and deviate from their prescribed instructions. One of the players, the dealer, possesses a value s as a secret input. <p> Email address: rosario@theory.lcs.mit.edu. Research supported by NSF grant no.9121466-CCR Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [4, 1, 3, 7, 10] </ref>.) We contend, however, that these notions and these protocols are of very limited use.
Reference: 5. <author> Yvo Desmedt and Yair Frankel. </author> <title> Shared generation of authentication and signatures. </title> <booktitle> In CRYPTO'91, Lecture Notes in Computer Science, </booktitle> <pages> pages 457-469. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: 6. <author> Yvo Desmedt, Yair Frankel, and Moti Yung. </author> <title> Multi-receiver/multi-sender network security: efficient authenticated multicast/feedback. </title> <booktitle> In INFOCOM, </booktitle> <pages> pages 2045-2054, </pages> <year> 1992. </year>
Reference: 7. <author> Paul Feldman and Silvio Micali. </author> <title> An optimal probabilistic protocol for synchronous byzan-tine agreement. </title> <booktitle> In 20th ACM Symposium on Theory of Computing, </booktitle> <year> 1988. </year>
Reference-contexts: Email address: rosario@theory.lcs.mit.edu. Research supported by NSF grant no.9121466-CCR Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [4, 1, 3, 7, 10] </ref>.) We contend, however, that these notions and these protocols are of very limited use. <p> In these cases the security of the entire protocol must be proven "from scratch" (for instance, this is the case in <ref> [7] </ref> where they use VSS as a tool to reach Byzantine agreement) rather than in a more natural and elegant "modular way." A notion of security that guarantees reducibility has been presented by Micali and Rogaway [9] for the problem of function evaluation, but not for general multiparty protocols. <p> We say that such an adversary is a t-adversary ( 0 t n ) if t is an upper bound on the number of processors she can corrupt (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in <ref> [7] </ref> and [9]. Prior definitions of VSS. To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. The definition reviewed below is that of [7], which relies on the notion of a fixed event: Definition: We say that an event X is fixed <p> (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in <ref> [7] </ref> and [9]. Prior definitions of VSS. To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. The definition reviewed below is that of [7], which relies on the notion of a fixed event: Definition: We say that an event X is fixed at a given round in an execution E of a protocol, if X occurs in any execution E 0 of the protocol coinciding with E up to the given round. <p> Theorem 7. The protocol P = (Share Verify; Recover) is a VSS protocol according to Definition 4 with fault-tolerance n 3 1 Remark: A completely error-free version of this protocol can be obtained as in <ref> [7] </ref> by running a different zero-knowledge proof that the shares lie on a single polynomial. The proof uses a bivariate polynomial and it is out of the scope of this paper. Details can be found in [1, 7]. <p> The proof uses a bivariate polynomial and it is out of the scope of this paper. Details can be found in <ref> [1, 7] </ref>. Notice that this is the first time a formal proof of the security of the protocol of [1] appeared.
Reference: 8. <author> Oded Goldreich, Silvio Micali, and Avi Wigderson. </author> <title> How to play any mental game. </title> <booktitle> In 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 218-229, </pages> <year> 1987. </year>
Reference-contexts: And she can still corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following <ref> [8] </ref>, [9] call a protocol for evaluating f secure if it 2 Notice that if we simply ask in the Verifiability condition that "all the good players output the same number at the end of the Recover phase" it would not be sufficient for our purposes.
Reference: 9. <author> Silvio Micali and Philip Rogaway. </author> <title> Secure computation. </title> <booktitle> In CRYPTO'91, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Current version available from the authors. </note>
Reference-contexts: entire protocol must be proven "from scratch" (for instance, this is the case in [7] where they use VSS as a tool to reach Byzantine agreement) rather than in a more natural and elegant "modular way." A notion of security that guarantees reducibility has been presented by Micali and Rogaway <ref> [9] </ref> for the problem of function evaluation, but not for general multiparty protocols. Our work. We extend reducibility-guaranteeing notions of security to verifiable secret sharing protocols and concretely exhibit VSS protocols that provably satisfy these notions. More precisely, in this paper we achieve the following goals: 1. <p> We say that such an adversary is a t-adversary ( 0 t n ) if t is an upper bound on the number of processors she can corrupt (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in [7] and <ref> [9] </ref>. Prior definitions of VSS. To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. <p> Let us summarize the definition of secure function evaluation of <ref> [9] </ref>. <p> And she can still corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following [8], <ref> [9] </ref> call a protocol for evaluating f secure if it 2 Notice that if we simply ask in the Verifiability condition that "all the good players output the same number at the end of the Recover phase" it would not be sufficient for our purposes. <p> In particular, the following one: the definition in <ref> [9] </ref> allows one to prove formally many desirable properties of secure protocols, the most interesting for us being reducibility: Theorem 3 [9]. Let f and g be two functions. <p> In particular, the following one: the definition in <ref> [9] </ref> allows one to prove formally many desirable properties of secure protocols, the most interesting for us being reducibility: Theorem 3 [9]. Let f and g be two functions. Suppose there is a protocol P that securely evaluates f in the model of computation in which it can perform ideal evaluations of g. Suppose also that there is a protocol Q that securely computes g. <p> Suppose also that there is a protocol Q that securely computes g. Denote with P Q the protocol in which the code for Q is substituted in P in the places where P ideally computes g. Then P Q is secure. Interested readers are referred to the original paper <ref> [9] </ref> for a proof of this statement and a complete and a formal description of their definition. 3 Our definition of VSS In this section we provide a new definition of VSS that guarantees reducibility. <p> The key idea for achieving this property is to cast VSS in terms of secure function evaluation. Accordingly, we shall define two special functions shar and rec, and demand that both of them be securely evaluated in the sense of <ref> [9] </ref>. We assume a network of n players P 1 ; : : : ; P n1 and P n , where P n = D the dealer. Let be a set.
Reference: 10. <author> Tal Rabin and Michael Ben-Or. </author> <title> Verifiable secret sharing and multiparty protocols with honest majority. </title> <booktitle> In 21st ACM Symposium on Theory of Computing, </booktitle> <year> 1989. </year>
Reference-contexts: Email address: rosario@theory.lcs.mit.edu. Research supported by NSF grant no.9121466-CCR Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [4, 1, 3, 7, 10] </ref>.) We contend, however, that these notions and these protocols are of very limited use. <p> We propose a new definition of VSS casted as a special istance of secure function evaluation. 2. We compare our new notion with the previously proposed ones, and show that it is strictly and inherently stronger. 3. We modify earlier VSS protocols of <ref> [1, 10] </ref> and show that our new protocol is secure according to our notion. 4. Finally we present some applications that use VSS as a subroutine and need our stronger notion of VSS to be secure. <p> The modification actually occurs only in the Recover part, and uses techniques also developed by [1], but within their "computational protocol" rather than in their VSS protocol. We have also found a protocol of fault-tolerance n 2 1 based on Tal Rabin's protocol <ref> [10] </ref>, but we will not describe it here for space limitations. Suppose we are dealing with a t-adversary A. Let n = 3t + 4 and P 1 ; : : : ; P n1 ; P n = D be the set of players, D being the dealer.
Reference: 11. <author> Adi Shamir. </author> <title> How to share a secret. </title> <journal> Communications of the ACM, </journal> <volume> 22(11) </volume> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: In the appendix we will show that protecting the secrecy of the shares is necessary for some applications in which VSS is used as a subroutine inside some specific protocols. Probably one of the reasons this point may appear somewhat moot is that in Shamir's secret sharing scheme <ref> [11] </ref> the shares consist of the value of a polynomial of degree t with free term s. For a t-adversary who corrupts exactly t players, knowing the secret is equivalent to knowing the shares of all players.
Reference: 12. <author> W.Peterson and E.Weldon. </author> <title> Error Correcting Codes. </title> <publisher> MIT Press, </publisher> <address> second edition, </address> <year> 1972. </year>
Reference-contexts: This is the well known Berlekamp-Welch variant of the Reed-Solomon error-correcting code. For details readers can refer to a standard text like <ref> [12] </ref>. Let K be a security parameter. With K=n we mean K The protocol appears in the boxes. The Share-Verify part is identical to the one in [1].
References-found: 12

