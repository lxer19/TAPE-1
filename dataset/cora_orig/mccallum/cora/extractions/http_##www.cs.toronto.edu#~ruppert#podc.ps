URL: http://www.cs.toronto.edu/~ruppert/podc.ps
Refering-URL: http://www.cs.toronto.edu/~ruppert/index.html
Root-URL: 
Email: ruppert@cs.utoronto.ca  
Title: Determining Consensus Numbers  
Author: Eric Ruppert 
Address: Toronto, Ontario, Canada, M5S 3G4  
Affiliation: Department of Computer Science University of Toronto  
Abstract: Conditions on a shared object type T are given that are both necessary and sufficient for wait-free n-process consensus to be solvable using objects of type T and registers. The conditions apply to two large classes of deterministic shared objects: read-modify-write objects [15] and readable objects, which have operations that allow processes to read the state of the object. These classes include most objects that are used as the primitives of practical distributed systems. When the sequential specification of T is finite, the conditions may be checked in a finite amount of time to decide the question "Is the consensus number of T at least n?" The conditions are also used to provide a clear proof of the robustness of the consensus hierarchy for read-modify-write and readable objects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, and Nir Shavit. </author> <title> Atomic snapshots of shared memory. </title> <journal> Journal of the ACM, </journal> <volume> 40(4), </volume> <pages> pages 873-890, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: It is known that the addition of the scan operation does not increase the power of an array of registers to solve consensus, since the snapshot object can be implemented from ordinary registers <ref> [1, 2, 3] </ref>. Here, it will be shown that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus.
Reference: [2] <author> James H. Anderson. </author> <title> Composite registers. </title> <journal> Distributed Computing, </journal> <volume> 6(3), </volume> <pages> pages 141-154, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: It is known that the addition of the scan operation does not increase the power of an array of registers to solve consensus, since the snapshot object can be implemented from ordinary registers <ref> [1, 2, 3] </ref>. Here, it will be shown that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus.
Reference: [3] <author> James Aspnes and Maurice Herlihy. </author> <title> Wait-free data structures in the asynchronous PRAM model. </title> <booktitle> In Proc. 2nd ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 340-349, </pages> <year> 1990. </year>
Reference-contexts: It is known that the addition of the scan operation does not increase the power of an array of registers to solve consensus, since the snapshot object can be implemented from ordinary registers <ref> [1, 2, 3] </ref>. Here, it will be shown that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus.
Reference: [4] <author> Ofer Biran, Shlomo Moran, and Shmuel Zaks. </author> <title> A combinatorial characterization of the distributed 1-solvable tasks. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3), </volume> <pages> pages 420-440, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Some work has been done on deciding whether a given task can be solved using some particular types of shared objects. Biran, Moran and Zaks <ref> [4] </ref> showed that one can decide whether a given task can be solved in a message-passing system if at most one process may fail. Chor and Moscovici [7] gave a decidable characterization of tasks that can be solved by randomized algorithms that use registers only.
Reference: [5] <author> Elizabeth Borowsky, Eli Gafni, and Yehuda Afek. </author> <title> Consensus power makes (some) sense! In Proc. </title> <booktitle> 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 363-372, </pages> <year> 1994. </year>
Reference-contexts: Two teams of researchers, Borowsky, Gafni and Afek <ref> [5] </ref> and Pe-terson, Bazzi and Neiger [19] claimed that the consensus hierarchy is robust for all deterministic objects. Full versions of these papers are not yet available. <p> Moran and Rappoport [18] showed that the consensus hierarchy is not robust for deterministic non-oblivious objects using the restricted hard-wired binding model. (See Jayanti's survey [13] for a description of binding models, which restrict the ways that processes can access non-oblivious objects.) Borowsky, Gafni and Afek <ref> [5] </ref> and Peterson, Bazzi and Neiger [19] claimed that the consensus hierarchy is robust for deterministic objects using less restrictive binding models. These papers are quite complex.
Reference: [6] <author> Tushar Chandra, Vassos Hadzilacos, Prasad Jayanti, and Sam Toueg. </author> <title> Wait-freedom vs. t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proc. 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <year> 1994. </year>
Reference-contexts: In the consensus hierarchy, h r m , the level of a type T is the consensus number of T . Jayanti showed that h r m is the (unique) tight wait-free hierarchy [12]. Chandra et al. <ref> [6] </ref> showed that the consensus hierarchy is not robust, if non-deterministic, non-oblivious objects are allowed. Schenk [22] proved that the consensus hierarchy is not robust, even for oblivious objects, if objects with unbounded non-determinism are allowed.
Reference: [7] <author> Benny Chor and L. Moscovici. </author> <title> Solvability in asynchronous environments. </title> <booktitle> In Proc. 30th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 422-433, </pages> <year> 1989. </year>
Reference-contexts: Biran, Moran and Zaks [4] showed that one can decide whether a given task can be solved in a message-passing system if at most one process may fail. Chor and Moscovici <ref> [7] </ref> gave a decidable characterization of tasks that can be solved by randomized algorithms that use registers only.
Reference: [8] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <pages> pages 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: These two conditions are called consistency and validity, respectively. The proofs that the n-universality conditions are necessary for the solvability of n-consensus are bivalency arguments. This type of proof was introduced by Fischer, Lynch and Paterson <ref> [8] </ref>. The following terminology will be used in the bivalency arguments. The configuration of a protocol at any moment in its execution consists of the state of every shared object, together with the internal state of every process.
Reference: [9] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1), </volume> <pages> pages 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Thus, a question about computability may be formulated as a question about implementations: Can one object type be implemented using a given set of primitive object types? Herlihy <ref> [9] </ref> showed that the consensus problem, in which each process begins with an input and all non-faulty processes must agree on one of the input values, plays a central role in the study of the power of object types. <p> He proved that objects that solve the consensus problem for n processes can be used, along with read/write registers, to obtain a wait-free implementation of any object for n or fewer processes. This leads to the idea of classifying object types according to their consensus number <ref> [9, 12] </ref>. An object type T has consensus number n if n-process consensus can be solved by using objects of type To appear in the 16th ACM Symposium on Principles of Distributed Computing, August 1997, Santa Bar-bara, California. T and read/write registers, but (n + 1)-process consensus cannot. <p> Previously, ad hoc arguments have been used to determine whether particular object types can be used along with registers to solve n-process consensus. An exception was Herlihy's proof <ref> [9] </ref> that 2-process consensus can be solved using registers and RMW objects, where the RMW operations apply functions from the set F , if and only if F contains a function different from the identity. <p> For simplicity, it is assumed that all objects are oblivious: The state transition and response for any operation do not depend on the process that invokes the operation and every process can invoke every operation. Processes are completely asynchronous and the wait-free model <ref> [9] </ref> of fault tolerance is used. This means that the algorithms executed by each process must work correctly even if all other processes experience stopping failures or if their speeds vary arbitrarily. <p> There is a critical configuration S 0 of the protocol. Otherwise, one could produce an execution of infinite length by always scheduling a process whose next step produces a multivalent configuration, and this is impossible in a wait-free protocol. A bivalency argument (see <ref> [9] </ref>) may be used to show that the next operation performed by any process when the system is in the configuration S 0 must be an operation on the same object, say X, and that X cannot be a register. <p> Proof: This follows from Theorems 3 and 9 and the fact that n-consensus objects can be used to obtain an implementation of any shared object in a system of n processes <ref> [9] </ref>. 2 Corollary 11 If the set of possible values for the RMW variables is finite, the following question is decidable: "Given an integer n and a set F of functions, can n-consensus be solved using registers and RMW variables if the RMW operations can apply functions from the set F <p> If n-process consensus can be solved using any combination of registers and objects of type T , then T is n-universal. Proof: A bivalency argument (see <ref> [9] </ref>) shows that any n-consensus protocol that uses registers and objects of type T must have a critical configuration S 0 , and that the next operation by each process will be applied to the same object of type T . <p> Proof: This follows from Theorems 15 and 18 and the fact that n-consensus objects can be used to obtain an implementation of any shared object in a system of n processes <ref> [9] </ref>. 2 Corollary 20 If the state set of object type T and the set of possible operations on object type T are both finite, then the following question is decidable: "Given a positive integer n and a readable type T , can n-consensus be solved using only objects of type <p> type T and registers. 2 It can be shown that, for each n &gt; 1, there is a readable object type, analogous to the RMW object defined in Proposition 12, that has consensus number n. 5 Robustness for RMW and Readable Objects Jayanti [12] formalized Herlihy's notion of a hierarchy <ref> [9] </ref> of shared object types and defined a number of desirable properties for hierarchies, including robustness. A wait-free hierarchy classifies object types according to their power to implement one another. <p> To derive a contradiction, suppose the claim is false. Then, since h r m (T ) n, there is a protocol using objects whose types are from the set S that solves consensus among n processes. A bivalency argument <ref> [9] </ref> shows that this protocol has a critical configuration, S 0 , and that the next operation taken by any process when the system is in this configuration must be an operation on the same object, X. Let T X be the type of object X.
Reference: [10] <author> Maurice Herlihy and Sergio Rajsbaum. </author> <title> The decidability of distributed decision tasks. </title> <booktitle> In Proc. 29th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 589-598, </pages> <year> 1997. </year>
Reference-contexts: Chor and Moscovici [7] gave a decidable characterization of tasks that can be solved by randomized algorithms that use registers only. Recently, Herlihy and Rajsbaum <ref> [10] </ref> gave decidability results for the question of whether a given task can be solved using various types of objects (registers, consensus objects and set consensus objects) in the presence of t process failures.
Reference: [11] <author> Maurice P. Herlihy and Jeannette M. Wing. Lin-earizability: </author> <title> A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3), </volume> <pages> pages 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: When an object is accessed by more than one process concurrently, its behaviour can be specified by insisting that operations appear to occur instantaneously at some time between their invocations and their responses. Such an object is called linearizable <ref> [11] </ref>. This paper deals only with deterministic, linearizable objects. It is assumed that the designer of a protocol may choose the initial states of the shared objects.
Reference: [12] <author> Prasad Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proc. 12th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 145-157, </pages> <year> 1993. </year>
Reference-contexts: He proved that objects that solve the consensus problem for n processes can be used, along with read/write registers, to obtain a wait-free implementation of any object for n or fewer processes. This leads to the idea of classifying object types according to their consensus number <ref> [9, 12] </ref>. An object type T has consensus number n if n-process consensus can be solved by using objects of type To appear in the 16th ACM Symposium on Principles of Distributed Computing, August 1997, Santa Bar-bara, California. T and read/write registers, but (n + 1)-process consensus cannot. <p> The n-universality conditions are also used to obtain a clear proof that the consensus hierarchy is robust <ref> [12] </ref> for RMW and readable objects. This means that if n-consensus can be solved using RMW and readable objects of types T 1 ; : : : ; T r and registers, then n-consensus can also be solved using objects of type T i and registers only, for some i. <p> possible to solve n-consensus using objects of type T and registers. 2 It can be shown that, for each n &gt; 1, there is a readable object type, analogous to the RMW object defined in Proposition 12, that has consensus number n. 5 Robustness for RMW and Readable Objects Jayanti <ref> [12] </ref> formalized Herlihy's notion of a hierarchy [9] of shared object types and defined a number of desirable properties for hierarchies, including robustness. A wait-free hierarchy classifies object types according to their power to implement one another. <p> In the consensus hierarchy, h r m , the level of a type T is the consensus number of T . Jayanti showed that h r m is the (unique) tight wait-free hierarchy <ref> [12] </ref>. Chandra et al. [6] showed that the consensus hierarchy is not robust, if non-deterministic, non-oblivious objects are allowed. Schenk [22] proved that the consensus hierarchy is not robust, even for oblivious objects, if objects with unbounded non-determinism are allowed.
Reference: [13] <author> Prasad Jayanti. </author> <title> Wait-free computing. </title> <booktitle> In Distributed Algorithms, 9th International Workshop, volume 972 of LNCS, </booktitle> <year> 1995. </year>
Reference-contexts: Moran and Rappoport [18] showed that the consensus hierarchy is not robust for deterministic non-oblivious objects using the restricted hard-wired binding model. (See Jayanti's survey <ref> [13] </ref> for a description of binding models, which restrict the ways that processes can access non-oblivious objects.) Borowsky, Gafni and Afek [5] and Peterson, Bazzi and Neiger [19] claimed that the consensus hierarchy is robust for deterministic objects using less restrictive binding models. These papers are quite complex.
Reference: [14] <author> Prasad Jayanti and Sam Toueg. </author> <title> Some results on the impossibility, universality and decidability of consensus. </title> <booktitle> In Distributed Algorithms, 6th International Workshop, volume 647 of LNCS, </booktitle> <pages> pages 69-84, </pages> <year> 1992. </year>
Reference-contexts: In this paper, a decision procedure is developed to determine whether given readable and RMW types with finite specifications can be used to solve n-process consensus. Jayanti and Toueg <ref> [14] </ref> showed that this question is undecidable for arbitrary object types if they are allowed to have infinite state sets.
Reference: [15] <author> Clyde P. Kruskal, Larry Rudolph, and Marc Snir. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4), </volume> <pages> pages 579-601, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: This paper addresses the problem of determining whether a given deterministic object type has consensus number n. Two important classes of objects that include most of the objects considered as primitives for practical distributed systems are studied: read-modify-write (RMW) objects <ref> [15] </ref> and readable objects. It is reasonable to assume that processes will be able to access the information stored in the data object in some simple way. If processes may read the information directly, without altering the object's state, then the object is called readable.
Reference: [16] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> All of us are smarter than any of us: wait-free hierarchies are not robust. </title> <booktitle> In Proc. 29th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 579-588, </pages> <year> 1997. </year>
Reference-contexts: Chandra et al. [6] showed that the consensus hierarchy is not robust, if non-deterministic, non-oblivious objects are allowed. Schenk [22] proved that the consensus hierarchy is not robust, even for oblivious objects, if objects with unbounded non-determinism are allowed. Lo and Hadzi-lacos <ref> [16] </ref> improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even when non-determinism is bounded.
Reference: [17] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms, chapter 8. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Formally, an object can be specified as an I/O automaton (see <ref> [17] </ref>). Each operation causes a state transition and returns a response. If the state transition and response are uniquely determined by the current state of the object and the operation applied, then the object is deterministic.
Reference: [18] <author> Shlomo Moran and Lihu Rappoport. </author> <title> On the robustness of h r m . In Distributed Algorithms, </title> <booktitle> 10th Inter national Workshop, volume 1151 of LNCS, </booktitle> <year> 1996. </year>
Reference-contexts: Schenk [22] proved that the consensus hierarchy is not robust, even for oblivious objects, if objects with unbounded non-determinism are allowed. Lo and Hadzi-lacos [16] improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even when non-determinism is bounded. Moran and Rappoport <ref> [18] </ref> showed that the consensus hierarchy is not robust for deterministic non-oblivious objects using the restricted hard-wired binding model. (See Jayanti's survey [13] for a description of binding models, which restrict the ways that processes can access non-oblivious objects.) Borowsky, Gafni and Afek [5] and Peterson, Bazzi and Neiger [19] claimed
Reference: [19] <author> Gary L. Peterson, Rida A. Bazzi, and Gil Neiger. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proc. 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 344-353, </pages> <year> 1994. </year>
Reference-contexts: Two teams of researchers, Borowsky, Gafni and Afek [5] and Pe-terson, Bazzi and Neiger <ref> [19] </ref> claimed that the consensus hierarchy is robust for all deterministic objects. Full versions of these papers are not yet available. <p> Peterson, Bazzi and Neiger <ref> [19] </ref> call objects that solve team-restricted n-consensus splitters. Lemma 4 If a set O of objects can be used to solve team-restricted (n + 1)-consensus, then O can be used to solve team-restricted n-consensus, for any n 2. <p> Rappoport [18] showed that the consensus hierarchy is not robust for deterministic non-oblivious objects using the restricted hard-wired binding model. (See Jayanti's survey [13] for a description of binding models, which restrict the ways that processes can access non-oblivious objects.) Borowsky, Gafni and Afek [5] and Peterson, Bazzi and Neiger <ref> [19] </ref> claimed that the consensus hierarchy is robust for deterministic objects using less restrictive binding models. These papers are quite complex.
Reference: [20] <author> Serge Plotkin. </author> <title> Sticky bits and universality of consensus. </title> <booktitle> In Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 159-175, </pages> <year> 1989. </year>
Reference-contexts: This can be shown by considering a RMW object that behaves like a sticky bit <ref> [20] </ref> that gets reset after n accesses. 4 Proposition 12 Let V = f?g [ (fA; Bg fi f1; : : : ; n 1g), for some n 2.
Reference: [21] <author> Eric Ruppert. </author> <title> Determining consensus numbers. </title> <type> Technical Report 303/96, </type> <institution> Department of Computer Science, University of Toronto, </institution> <month> November </month> <year> 1996. </year> <note> Available from http://www.cs.utoronto.ca/~ruppert. </note>
Reference-contexts: Here, it will be shown that the addition of an atomic scan operation does not increase the power of any readable object type to solve consensus. A more detailed version of this paper is also available <ref> [21] </ref>. 2 Preliminaries An object type is defined using a sequential specification, which describes the operations that may be performed on the object and the responses the object should return if the operations are performed sequentially. Formally, an object can be specified as an I/O automaton (see [17]).
Reference: [22] <author> Eric Schenk. </author> <title> The consensus hierarchy is not robust. </title> <booktitle> 1997. In these proceedings. </booktitle> <pages> 7 </pages>
Reference-contexts: Jayanti showed that h r m is the (unique) tight wait-free hierarchy [12]. Chandra et al. [6] showed that the consensus hierarchy is not robust, if non-deterministic, non-oblivious objects are allowed. Schenk <ref> [22] </ref> proved that the consensus hierarchy is not robust, even for oblivious objects, if objects with unbounded non-determinism are allowed. Lo and Hadzi-lacos [16] improved this, showing that the hierarchy h r m restricted to oblivious objects is not robust even when non-determinism is bounded.
References-found: 22

