URL: http://www-lsr.imag.fr/users/Didier.Bert/Papers/firstB.ps.gz
Refering-URL: http://www-lsr.imag.fr/Les.Groupes/scop/f-publi.html
Root-URL: http://www.imag.fr
Email: e-mail: Dider.Bert@Imag.fr, Marie-Laure.Potet@imag.fr, Yann.Rouzaud@imag.fr  
Phone: 9 Tel 33 4 76827214 Fax+ 33 4 76827287  
Title: A Study on Components and Assembly Primitives in B  
Author: Didier Bert, Marie-Laure Potet, Yann Rouzaud 
Address: BP 53, F-38041 Grenoble Cedex  
Affiliation: LSR-IMAG, Grenoble, France Laboratoire Logiciels Systemes Reseaux Institut IMAG (UJF INPG CNRS)  
Abstract: This paper is the result of a reflexion coming from the usage and learning of the language B. It tries to better explain and understand the assembly primitives includes and uses of the language. It presents a high-level notion of components and develops a "component algebra". This algebra is specialized to deal with the B-components. The B assembly primitives are re-expressed in this basic formalism. Some problems about independence of concepts in the B methodology are pointed out and are discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr96] <editor> J. R. Abrial. B Book. </editor> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: The following figure shows a simple machine, with no assembly clauses. Some features have been simplified 1 with respect to the full definition of machines given in the B-book <ref> [Abr96] </ref>. 1 In this paper, we do not describe all the elements of the abstract machines.
Reference: [BE95] <author> D. Bert and R. Echahed. </author> <title> Multiparadigm logic programming : the case of the language LPG. </title> <type> Technical report, </type> <institution> IMAG-LGI, </institution> <year> 1995. </year>
Reference-contexts: This has been formalized between theories and classes of algebras (models) in the framework of the Institutions [GB90]. Other attempts connect flattened specifications and algebras [EFH83], but for complex structuring primitives, the correspondence between several semantical views of modules can only be partial [Fey88] <ref> [BE95] </ref>. Because a component is an abstract notion, we can define operations on components in a mathematical way (component algebra). Assembly clauses on modules (e.g. includes) must have a semantic interpretation as operations on components.
Reference: [BG77] <author> R. M. Burstall and J. A. Goguen. </author> <title> Putting theories together to make specifications. </title> <booktitle> In Proc. of 5th Int. Joint Conference on Artificial Intelligence, </booktitle> <address> Cambridge, Mass., </address> <pages> pages 1045-1052, </pages> <year> 1977. </year>
Reference-contexts: At last, the notion of components can be entirely a semantical notion (without concrete representation) like in <ref> [BG77] </ref>, where the meaning of an assembly of modules is a theory and in [Wir86] [ST88], where the meaning of a structured algebraic specification is a class of algebras. Several views of components may coexist and can be related.
Reference: [BHK90] <author> J. A. Bergstra, J. Heering, and P. Klint. </author> <title> Module algebra. </title> <journal> J. ACM, </journal> <volume> 37(2) </volume> <pages> 335-372, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Specifications, like programs, must be modular because very large formal texts are not understandable for a human being. So, the study of modules and modularization is one of the issues in software engineering. The three main objectives of modularization <ref> [BHK90] </ref> are : information hiding, compositionality of module operations and reusability of modules. <p> The primitives of the language are: enrich, rename, union with implicit sharing, instantiate, quotient (which can be represented by our enrich), etc. One can found a complete study of meta-operations on algebraic specifications called "modules" in <ref> [BHK90] </ref>. Model-oriented specification formalisms provide examples of primitives to assemble specifications. The Z language [Spi88] is modular, because all the schemas can be specified separately. Bodies of component are texts of specification and can be obtained by replacement and copy of texts of the subcomponents.
Reference: [BL91] <author> D. Bert and Ch. Lafontaine. </author> <title> Integration of semantical verification conditions in a specification langage definition. </title> <booktitle> In Proc. of the 2nd Conf. on Algebraic Methodology and Software Technology (AMAST-91), </booktitle> <pages> pages 467-477. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The consistency conditions of C are not an element of the definition of the components, because we do not want to include the semantical conditions (proof obligations) and their proofs in the language of components. For example, this has been done for algebraic specifications in <ref> [BL91] </ref>. 2.2 Auxiliary operations Operations on signatures. Signatures essentially are sets of names. So the operations on sets (union, intersection, set difference, . . . ) can be applied to signatures or to signature parts (visible, hidden, etc.).
Reference: [EFH83] <author> H. Ehrig, W. Fey, and H. Hansen. </author> <title> ACT ONE: an algebraic specification language with two levels of semantics. </title> <type> Technical report 83-03, </type> <institution> TU Berlin, </institution> <year> 1983. </year>
Reference-contexts: Several views of components may coexist and can be related. This has been formalized between theories and classes of algebras (models) in the framework of the Institutions [GB90]. Other attempts connect flattened specifications and algebras <ref> [EFH83] </ref>, but for complex structuring primitives, the correspondence between several semantical views of modules can only be partial [Fey88] [BE95]. Because a component is an abstract notion, we can define operations on components in a mathematical way (component algebra).
Reference: [Fey88] <author> W. Fey. </author> <title> Pragmatics, Concepts, Syntax, Semantics and Correctness Notions of ACT TWO: an algebraic module specification and interconnection language. </title> <type> Technical report 88-26, </type> <institution> TU Berlin, </institution> <year> 1988. </year>
Reference-contexts: This has been formalized between theories and classes of algebras (models) in the framework of the Institutions [GB90]. Other attempts connect flattened specifications and algebras [EFH83], but for complex structuring primitives, the correspondence between several semantical views of modules can only be partial <ref> [Fey88] </ref> [BE95]. Because a component is an abstract notion, we can define operations on components in a mathematical way (component algebra). Assembly clauses on modules (e.g. includes) must have a semantic interpretation as operations on components.
Reference: [GB90] <author> J. A. Goguen and R. M. Burstall. Institutions: </author> <title> Abstract Model Theory for Specification and Programming. </title> <institution> Research Report ECS-LFCS-90-106, Lab. for Foundations of Computer Science, Univ. of Edin-burgh, </institution> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Several views of components may coexist and can be related. This has been formalized between theories and classes of algebras (models) in the framework of the Institutions <ref> [GB90] </ref>. Other attempts connect flattened specifications and algebras [EFH83], but for complex structuring primitives, the correspondence between several semantical views of modules can only be partial [Fey88] [BE95]. Because a component is an abstract notion, we can define operations on components in a mathematical way (component algebra).
Reference: [Ori96] <author> C. Oriat. </author> <title> Etude des specifications modulaires : constructions de colimites finies, </title> <institution> diagrammes, isomor-phismes. Doctorat d'Universite, INPG, Grenoble, </institution> <month> Janvier </month> <year> 1996. </year>
Reference-contexts: Sometimes, the component of a module M is defined as a flattened module, i.e. a module containing the text of the (inductively) flattened submodules concatenated with the text of the own declarations of M . In that case, a component is a basic large module. In other approaches [SJ95] <ref> [Ori96] </ref>, modules are seen as points in a categorical framework, where the assembly primitives are interpreted as morphisms, and a component is defined as the colimit of such a diagram of specifications.
Reference: [SJ95] <author> Y. V. Srinivas and R. Jullig. SPECWARE: </author> <title> Formal support for composing software. </title> <booktitle> In Proc. of the Conf. on Mathematics of Program Construction, </booktitle> <year> 1995. </year>
Reference-contexts: Sometimes, the component of a module M is defined as a flattened module, i.e. a module containing the text of the (inductively) flattened submodules concatenated with the text of the own declarations of M . In that case, a component is a basic large module. In other approaches <ref> [SJ95] </ref> [Ori96], modules are seen as points in a categorical framework, where the assembly primitives are interpreted as morphisms, and a component is defined as the colimit of such a diagram of specifications.
Reference: [Spi88] <author> M. Spivey. </author> <title> Understanding Z : a specification language and its formal semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: One can found a complete study of meta-operations on algebraic specifications called "modules" in [BHK90]. Model-oriented specification formalisms provide examples of primitives to assemble specifications. The Z language <ref> [Spi88] </ref> is modular, because all the schemas can be specified separately. Bodies of component are texts of specification and can be obtained by replacement and copy of texts of the subcomponents.
Reference: [ST88] <author> D. Sannella and A. Tarlecki. </author> <title> Towards formal development of programs from algebraic specifications : Implementations revisited. </title> <journal> Acta Informatica, </journal> <volume> 25 </volume> <pages> 233-281, </pages> <year> 1988. </year>
Reference-contexts: At last, the notion of components can be entirely a semantical notion (without concrete representation) like in [BG77], where the meaning of an assembly of modules is a theory and in [Wir86] <ref> [ST88] </ref>, where the meaning of a structured algebraic specification is a class of algebras. Several views of components may coexist and can be related. This has been formalized between theories and classes of algebras (models) in the framework of the Institutions [GB90].
Reference: [Wir86] <author> M. Wirsing. </author> <title> Structured Algebraic Specifications: A Kernel Language. </title> <journal> Theoretical Computer Science, </journal> <volume> 42 </volume> <pages> 123-249, </pages> <year> 1986. </year>
Reference-contexts: At last, the notion of components can be entirely a semantical notion (without concrete representation) like in [BG77], where the meaning of an assembly of modules is a theory and in <ref> [Wir86] </ref> [ST88], where the meaning of a structured algebraic specification is a class of algebras. Several views of components may coexist and can be related. This has been formalized between theories and classes of algebras (models) in the framework of the Institutions [GB90]. <p> Operations on components have been defined in several specification languages. In algebraic specifications, a formalism like ASL <ref> [Wir86] </ref> provides operations on specifications which could be expressed in the framework presented in the section 2.3, at least if they are not too specific and do not depend on the algebraic semantics of the components.
References-found: 13

