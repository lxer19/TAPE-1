URL: ftp://ftp.eecs.umich.edu/groups/gasm/steamboiler.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Email: christoph.beierle@fernuni-hagen.de  boerger@di.unipi.it  igor@uni-paderborn.de  glaesser@uni-paderborn.de  riccobene@dipmat.unict.it  
Phone: 2  3  4  5  
Title: Refining Abstract Machine Specifications of the Steam Boiler Control to Well Documented Executable Code  
Author: Christoph Beierle, Egon Borger, Igor D urd -anovic, Uwe Glasser, Elvinia Riccobene 
Address: Germany,  Pisa, Italy,  Germany,  Germany,  Italy,  
Affiliation: 1 Fernuniversitat-GH Hagen,  Universita di  Universitat-GH Paderborn,  Universitat-GH Paderborn,  Universita di Catania,  
Abstract: We use the steam boiler control specification problem to illustrate how the evolving algebra approach to the specification and the verification of complex systems can be exploited for a reliable and well documented development of executable, but formally inspectable and systematically modifiable code. A hierarchy of stepwise refined abstract machine models is developed, the ground version of which can be checked for whether it faithfully reflects the informally given problem. The sequence of machine models yields various abstract views of the system, making the various design decisions transparent, and leads to a C++ program. This program has been demonstrated during the Dagstuhl-Meeting on Methods for Semantics and Specification, in June 1995, to control the Karlsruhe steam boiler simulator satisfactorily. The abstract machines are evolving algebras and thereby have a rigorous semantical foundation, allowing us to formalize and prove, under precisely stated assumptions, some typical sample properties of the system. This provides insight into the structure of the system which supports easily maintainable extensions and modifications of both the abstract specification and the implementation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Wolfgang Ahrendt. </author> <title> Von Prolog zur WAM. Verifikation der Prozedurubersetzung mit KIV. </title> <type> Diploma thesis, </type> <institution> University of Karlsruhe, </institution> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: a model provides a transparent and faithful link between the customer's world where the application problem resides and the system designer's and programmer's world where the program has to be developed. 7 In particular the ground model allows one to "show" by 6 For an illustration of this point see <ref> [1, 16] </ref> which report on machine verifications for some of the refinement steps introduced for the evolving algebra based correctness proof of a general compilation scheme of Prolog programs to WAM code in [10]. 7 Obviously this "link" holds only for those system parts or properties which are specified in the
Reference: 2. <author> Egon Borger. </author> <title> A logical operational semantics for full Prolog. Part I: selection core and control. </title> <editor> In E. Borger, H. Kleine Buning, M.M. Richter, editors, CSL'89. </editor> <booktitle> 3rd Workshop on Computer Science Logic, Springer LNCS, </booktitle> <volume> vol. 440, </volume> <year> 1990, </year> <pages> pages 36-64. </pages>
Reference-contexts: The refinements also permit to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see <ref> [2, 10] </ref>) where it has been used since then extensively (see for ex. [7, 6, 8, 15, 14, 13, 11, 9], see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea).
Reference: 3. <author> Egon Borger. </author> <title> Logic programming: the evolving algebra approach. </title> <editor> In B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations, </address> <publisher> Elsevier, Amsterdam, </publisher> <pages> 391-395. </pages>
Reference-contexts: The most abstract model is a ground model in the sense of <ref> [3] </ref>, i.e. the result of a formalization process of the informally given description which remains conceptually and notationally as close as possible to the informal problem statement and thereby can be inspected by the user for its adequacy.
Reference: 4. <author> Egon Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 37-51. </pages>
Reference: 5. <author> Egon Borger. </author> <title> Why use evolving algebras for hardware and software engineering. </title> <booktitle> In Proc. </booktitle> <address> of SOFSEM'95 (Nov. 25 - Dec. 2, 1995, Bratislava, Czech Republic), </address> <publisher> LNCS 1012, Springer-Verlag, </publisher> <year> 1995, </year> <pages> pages 236-271. </pages>
Reference-contexts: level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. [7, 6, 8, 15, 14, 13, 11, 9], see also <ref> [5] </ref> for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). We investigate some typical sample properties of the system which we formulate and prove, under precisely stated assumptions, in the abstract models. <p> An example in this paper is the treatment of error handling for equipment failures; we cannot discuss it appropriately unless we explicitly identify and describe the relevant features, as we do here in the refinement section 5.2. See <ref> [5] </ref> for further discussion of this point. pointing to the model that it really reflects the informal description of the prob-lem. (See [5] for a discussion of the role of these ground models for the foundation of applications of programming to the real world.) We develop the model refinements up to <p> See <ref> [5] </ref> for further discussion of this point. pointing to the model that it really reflects the informal description of the prob-lem. (See [5] for a discussion of the role of these ground models for the foundation of applications of programming to the real world.) We develop the model refinements up to a point where it becomes evident how executable C++-code can be obtained by translating|almost mechanically| the abstract machine instructions into C++-procedures. <p> See <ref> [5] </ref>. 9 The term `distributed', as it is used here, actually refers to the distribution of control rather than the distribution of data. 3.1 Modeling of Timing Behaviour [ The program follows a cycle and a priori does not terminate.
Reference: 6. <author> Egon Borger and Igor D - urd -anovic. </author> <title> Correctness of compiling Occam to Transputer code. </title> <journal> Computer Journal, 1996, </journal> <volume> vol. 39, </volume> <pages> pages 52-92. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea).
Reference: 7. <author> E. Borger, I. Durdanovic, and D. Rosenzweig. </author> <title> Occam: Specification and compiler correctness. Part I: Simple mathematical interpreters. </title> <editor> In E.-R. Olderog (Ed.), </editor> <booktitle> Proc. PROCOMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <pages> pages 489-508, </pages> <publisher> North-Holland, </publisher> <year> 1994 </year>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea).
Reference: 8. <author> E. Borger, Y. Gurevich, and D. Rosenzweig. </author> <title> The bakery algorithm: yet another specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 231-243. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). <p> Our model is however abstract enough so that it could be refined to a distributed system which works in real-time, using the notions of distributed real-time evolving algebra runs developed in <ref> [12, 8, 14, 13] </ref>. As is to be expected from every seriously mathematical approach to system or program development, during the formalization process we have discovered numerous (probably deliberate) holes in the informal description which had to be filled in order to avoid inconsistencies or other unreasonable behaviour.
Reference: 9. <author> Egon Borger and Silvia Mazzanti. </author> <title> A correctness proof for pipelining in RISC architectures. </title> <note> In DIMACS TR 96-22, </note> <month> July </month> <year> 1996, </year> <pages> pages 1-60. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea).
Reference: 10. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In L. C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Series in Computer Science and Artificial Intelligence. El-sevier Science B.V./North-Holland, </booktitle> <year> 1995, </year> <pages> pages 20-90 (Chapter 2). </pages>
Reference-contexts: The refinements also permit to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see <ref> [2, 10] </ref>) where it has been used since then extensively (see for ex. [7, 6, 8, 15, 14, 13, 11, 9], see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). <p> particular the ground model allows one to "show" by 6 For an illustration of this point see [1, 16] which report on machine verifications for some of the refinement steps introduced for the evolving algebra based correctness proof of a general compilation scheme of Prolog programs to WAM code in <ref> [10] </ref>. 7 Obviously this "link" holds only for those system parts or properties which are specified in the ground model. Stated otherwise, a ground model should contain all those parameters, actions and conditions which are relevant for the customer.
Reference: 11. <author> G. Del Castillo, I. D - urd -anovic and U. Glasser. </author> <title> An evolving algebra abstract machine. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Computer Sience Logic (Proc. of CSL'95), </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1996, </year> <pages> pages 191-214. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). <p> is available at: http://www.uni-paderborn.de/fachbereich/ AG/agklbue/staff/igor/ea/dag/c++/. 6.1 Evolving Algebra Core Routines For the implementation of evolving algebra core routines we restrict here to those routines which are relevant for the controller specification effectively implementing a subclass of evolving algebras (whereas a complete model of executable evolving algebras can be found in <ref> [11] </ref>). The main aspect in the translation of evolving algebra states into C++ is the representation and handling of function values (see eav.H).
Reference: 12. <author> Yuri Gurevich. </author> <title> Evolving Algebra 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 9-36. </pages>
Reference-contexts: L. of this book) satisfactorily. The models are evolving algebras and thereby have a rigorous semantical foundation <ref> [12] </ref>. They are related by stepwise refinements which reflect the systematic use of strongest information hiding and modularization techniques offered by the abstraction mechanism built into the notion of evolving algebra. <p> Our model is however abstract enough so that it could be refined to a distributed system which works in real-time, using the notions of distributed real-time evolving algebra runs developed in <ref> [12, 8, 14, 13] </ref>. As is to be expected from every seriously mathematical approach to system or program development, during the formalization process we have discovered numerous (probably deliberate) holes in the informal description which had to be filled in order to avoid inconsistencies or other unreasonable behaviour. <p> The underlying semantic model ensures that the order in which the agents of A perform their operations is always such that no conflicts between the update sets computed for distinct agents can arise. For further details we refer to <ref> [12] </ref>. The evolving algebra defined below models the behaviour of the steam boiler control program from the point of view of a single agent.
Reference: 13. <author> Y. Gurevich and J. Huggins. </author> <title> The railroad crossing problem: an experiment with instantaneous actions and immediate reactions. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Proc. of Computer Sience Logic - CSL`95, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1996, </year> <pages> pages 266-290. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). <p> Our model is however abstract enough so that it could be refined to a distributed system which works in real-time, using the notions of distributed real-time evolving algebra runs developed in <ref> [12, 8, 14, 13] </ref>. As is to be expected from every seriously mathematical approach to system or program development, during the formalization process we have discovered numerous (probably deliberate) holes in the informal description which had to be filled in order to avoid inconsistencies or other unreasonable behaviour.
Reference: 14. <author> Y. Gurevich and R. Mani. </author> <title> Group membership protocol: specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 295-328. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea). <p> Our model is however abstract enough so that it could be refined to a distributed system which works in real-time, using the notions of distributed real-time evolving algebra runs developed in <ref> [12, 8, 14, 13] </ref>. As is to be expected from every seriously mathematical approach to system or program development, during the formalization process we have discovered numerous (probably deliberate) holes in the informal description which had to be filled in order to avoid inconsistencies or other unreasonable behaviour.
Reference: 15. <author> J. Huggins. </author> <title> Kermit: specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 247-293. </pages>
Reference-contexts: to state and prove interesting system properties at the appropriate level of abstraction; this is how the technique of building hierarchies of stepwise refined levels of abstraction has found its way into the evolving algebra methodology (see [2, 10]) where it has been used since then extensively (see for ex. <ref> [7, 6, 8, 15, 14, 13, 11, 9] </ref>, see also [5] for an explanation why evolving algebras provide the framework par excellence for the most general realization of the refinement idea).
Reference: 16. <author> Cornelia Pusch. </author> <title> Verification of compiler correctness for the WAM. </title> <note> In Proc. TPHOLs '96, LNCS, Springer-Verlag (to appear). </note>
Reference-contexts: a model provides a transparent and faithful link between the customer's world where the application problem resides and the system designer's and programmer's world where the program has to be developed. 7 In particular the ground model allows one to "show" by 6 For an illustration of this point see <ref> [1, 16] </ref> which report on machine verifications for some of the refinement steps introduced for the evolving algebra based correctness proof of a general compilation scheme of Prolog programs to WAM code in [10]. 7 Obviously this "link" holds only for those system parts or properties which are specified in the
Reference: 17. <author> C. Wallace. </author> <title> The semantics of the C++ programming language. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pages 131-164. </pages>
Reference-contexts: This is also the reason why we do not attempt to prove the "correctness" of the executable code with respect to the abstract evolving algebra models. Note however that in principle such a proof project could be carried through, using Wallace's <ref> [17] </ref> mathematical definition of the semantics of C++ as a reference model. The sequence of successfully refined abstract machine models can be turned into a systematic modular architectural design.
References-found: 17

