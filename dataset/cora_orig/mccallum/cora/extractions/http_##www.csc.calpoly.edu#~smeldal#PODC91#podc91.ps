URL: http://www.csc.calpoly.edu/~smeldal/PODC91/podc91.ps
Refering-URL: http://www.csc.calpoly.edu/~smeldal/tidbits.html
Root-URL: http://www.csc.calpoly.edu
Title: Exploiting Locality in Maintaining Potential Causality  
Author: Sigurd Meldal Sriram Sankar James Vera 
Address: Stanford, California 94305  
Affiliation: Program Analysis and Verification Group Computer Systems Laboratory Stanford University  
Abstract: In distributed systems it is often important to be able to determine the temporal relationships between events generated by different processes. An algorithm to determine such relationships is presented in [3] and [5]. This algorithm has many favorable attributes such as it allows for any kind of interprocess communication, and it requires no extra synchronization messages, additional communication links or central timestamping authority. The algorithm, however, requires O(n) space for each process (where n is the number of processes). i.e., it requires an overall space of O(n 2 ). This can be a large overhead especially when there are a very large number of processes. By cutting down on this generality, we can significantly decrease the amount of space required to determine temporal relationships. In this paper, we show how one may reduce the space requirements by assuming that the communication links between processes is static and known ahead of time; and also that one is interested only in determining the temporal ordering between messages arriving at the same process. We argue that these assumptions are reasonable to make for a large class of problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Frank Belz and David C. Luckham. </author> <title> A new approach to prototyping Ada-based hardware/software systems. </title> <booktitle> In Proceedings of the ACM Tri-Ada Conference, </booktitle> <address> Baltimore, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Since these algorithms are very similar, we shall refer to them collectively as Algorithm FM. In many applications, it is not necessary to be able to determine potential causality relationships between any two arbitrary events. During our work on prototyping language design <ref> [1] </ref>, we realized the need to determine potential causality information only between messages that were sent to the same process. Furthermore, the communication paths between processes are static and known ahead of time.
Reference: [2] <author> Bernadette Charron-Bost. </author> <title> Concerning the Size of Clocks, </title> <booktitle> volume 469 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-184. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This is because the algorithms require each process to maintain some information about each of the other processes. Hence the overall space requirement is O (n 2 ). This amount of space may seem excessive, but Charron-Bost <ref> [2] </ref> has shown that this space is necessary. Since these algorithms are very similar, we shall refer to them collectively as Algorithm FM. In many applications, it is not necessary to be able to determine potential causality relationships between any two arbitrary events.
Reference: [3] <author> Colin J. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <journal> Australian Computer Science Communications, </journal> <volume> 10(1) </volume> <pages> 55-66, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Lamport provides an algorithm to determine a total ordering of events that is a consistent extention of the "happened before" relation. Subsequently, Fidge <ref> [3] </ref> and Mat-tern [5] developed similar algorithms to determine potential causality relationships between events. These algorithms mark each event performed with timestamp information; and potential causality between two events can be determined by comparing their respective timestamps. <p> For a proof, please refer to <ref> [3] </ref>. 3 Exploiting Graph Connectivity Information Algorithm FM requires O ((1 + e p ) fi n) space for each process p, where e p is the number of events whose timestamps p needs to keep track of. <p> Each process has to maintain a counter set that includes all processes in the network. 6 Related Work Other work has been done to improve the efficiency of keeping track of potential causality. <ref> [3] </ref> and [5] have shown that in the case of a fixed number of processes, the F M mapping may be replaced by an array of counters where each process has a fixed index in the array. [6] have given an algorithm whereby each process keeps track of the clock information
Reference: [4] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction There are two general activities that take place in a distributed system: local activities that are performed independently by each process and synchronization activities during which two or more processes interact with each other and possibly exchange information. These two activities are collectively referred to as events. Lamport <ref> [4] </ref> shows that the temporal ordering of events in a distributed system execution is a partial order. It is sometimes impossible to say that one of two events occurred first, hence in general this ordering cannot be a total order.
Reference: [5] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Cosnard, editor, </editor> <booktitle> Proceedings of Parallel and Distributed Algorithms. </booktitle> <publisher> Elsevier Science Publishers, </publisher> <year> 1988. </year> <note> Also in: Report No. </note> <institution> SFB124P38/88, Dept. of Computer Science, University of Kaiserslautern. </institution>
Reference-contexts: If a "happened before" b and b "happened before" c, then a "happened before" c. We use the term potential causality <ref> [5] </ref> to denote the "happened before" relation | i.e., a potentially causes b is equivalent to a "happened before" b for the purposes of this paper. Lamport provides an algorithm to determine a total ordering of events that is a consistent extention of the "happened before" relation. <p> Lamport provides an algorithm to determine a total ordering of events that is a consistent extention of the "happened before" relation. Subsequently, Fidge [3] and Mat-tern <ref> [5] </ref> developed similar algorithms to determine potential causality relationships between events. These algorithms mark each event performed with timestamp information; and potential causality between two events can be determined by comparing their respective timestamps. <p> Each process has to maintain a counter set that includes all processes in the network. 6 Related Work Other work has been done to improve the efficiency of keeping track of potential causality. [3] and <ref> [5] </ref> have shown that in the case of a fixed number of processes, the F M mapping may be replaced by an array of counters where each process has a fixed index in the array. [6] have given an algorithm whereby each process keeps track of the clock information it has
Reference: [6] <author> M. Singhal and A. Kshemkalyani. </author> <title> An efficient implmen-tation of vector clocks. </title> <type> Technical report, </type> <institution> Department of Computer and Information Science, The Ohio State University, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: has been done to improve the efficiency of keeping track of potential causality. [3] and [5] have shown that in the case of a fixed number of processes, the F M mapping may be replaced by an array of counters where each process has a fixed index in the array. <ref> [6] </ref> have given an algorithm whereby each process keeps track of the clock information it has sent to other processes by maintaining two additional vectors. A message from p to q then need only carry clock information which has changed at p since the last message from p to q.
References-found: 6

