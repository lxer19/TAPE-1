URL: http://osl.cs.uiuc.edu/~w-kim4/call-return.ps
Refering-URL: http://osl.cs.uiuc.edu/~w-kim4/publications.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: fwooyoung j panwar j aghag@cs.uiuc.edu  
Phone: Phone: (217)244-3087 Fax: (217)333-3501  
Title: Optimization of Call/Return Communication for Concurrent Object-Based Programming (Extended Abstract)  
Author: WooYoung Kim Rajendra Panwar and Gul Agha 
Address: Urbana, IL 61801, USA  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Associated numbers denote the argument passed. utilization of processor resource, compromising the efficiency of non-blocking asynchronous communication. Another disadvantage of the RPC-based implementation is that it limits expressive power of call/return communication in computational models, such as the Actor model <ref> [1] </ref>, where an object cannot process the next message before it completes the execution of the current message.
Reference: [2] <author> G. Agha, C. Houck, and R. Panwar. </author> <title> Distributed Execution of Actor Systems. </title> <editor> In D. Gelernter, T. Gross, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 1-17. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science 589. </note>
Reference-contexts: The technique extracts join continuation <ref> [2] </ref> of mutually independent request message sends into a separate continuation object. <p> Note that the continuation method is dispatched through the JCC independently of the object. At the end of the continuation method, the object is made active using creator field and is allowed to process other incoming messages <ref> [2] </ref>. 7 Performance We present performance numbers for programs that use CCRC abstraction.
Reference: [3] <author> G. Agha, W. Kim, and R. Panwar. </author> <title> Actor Languages for Specification of Parallel Computations. </title> <editor> In G. E. Blel-loch, K. Mani Chandy, and S. Jagannathan, editors, </editor> <booktitle> DIMACS. Series in Discrete Mathematics and Theoretical Computer Science. </booktitle> <volume> vol 18. </volume> <booktitle> Specification of Parallel Algorithms, </booktitle> <pages> pages 239-258. </pages> <publisher> American Mathematical Society, </publisher> <year> 1994. </year> <booktitle> Proceedings of DIMACS '94 Workshop. </booktitle>
Reference-contexts: However, programming with non-blocking asynchronous communication necessitates explicit manipulation of continuation which may be very tedious and error-prone [5]. On the other hand, blocking asynchronous communications or call/return communication abstractions, such as ask [11], now [17] and request <ref> [3] </ref>, eliminate the need for explicit continuation manipulation to ease the task of programming; they allow an object to invoke a method on a remote object and use the value returned by the object. <p> The third example, Barnes Hut algorithm for solving n-body problems, shows how the use of CCRC avoids unnecessary sequentialization of the execution of parallel programs which may be caused in other models such as RPCs and futures. All examples discussed below are written in a High-Level Actor Language <ref> [3, 13] </ref>, although the transformations discussed in this paper can be implemented for any language based on concurrent objects. Example 1: Expression Evaluation Consider a program which evaluates expressions using concurrent objects. The expression is stored as a binary tree where a node represents either a function or a value.
Reference: [4] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesly, </publisher> <year> 1986. </year>
Reference-contexts: As a preprocessing step to the partitioning phase, each request message send in a method m is transformed and promoted to an assignment statement to a fresh compiler-generated temporary variable. After the transformation, the compiler computes def-use chain DU C d m <ref> [4] </ref> for each definition d 1 in m and 1 We use the terms definition and assignment interchangeably though definition subsumes assignment. 7 call/return communication. The small patterns (triangle, square and circle) represent the acceleration message corresponding to different bodies. <p> graph of a method which is a directed graph F G = (V; E) where V = fb j b is a basic block in the methodg and E = f (b i ; b j ) j b j can immediately follow b i in some execution sequence g <ref> [4] </ref>. One node is distinguished as initial: it is the block whose leader is the first statement in the method. The compiler traverses F G starting from the initial node.
Reference: [5] <author> R. D. Blumofe, C. F. Joerg, B. C. Kuszmaul, C. E. Leiserson, K. H. Randall, A. Shaw, and Y. Zhou. Cilk: </author> <title> An Efficient Multithreaded Runtime System. </title> <booktitle> In Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming PPOPP, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction The most efficient way to communicate with remote objects is using non-blocking asynchronous communication; it requires no context switch nor synchronization between a sender and a receiver. However, programming with non-blocking asynchronous communication necessitates explicit manipulation of continuation which may be very tedious and error-prone <ref> [5] </ref>.
Reference: [6] <author> S. Frtlund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> ECOOP'92 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 185-196. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year> <note> Lecture Notes in Computer Science 615. </note>
Reference-contexts: Note that the programmer should not make any specific assumption on the message delivery order when using CCRC abstraction; she must use local synchronization constraints <ref> [6] </ref> in the receiving object if it is necessary to impose a specific order on message reception.
Reference: [7] <author> R. H. Halstead Jr. </author> <title> A Language for Concurrent Symbolic Computation. </title> <journal> ACM TOPLAS, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <year> 1985. </year>
Reference-contexts: An efficient implementation scheme of continuation objects is proposed in Section 6. We present the preliminary evaluation results obtained from the implementation in Section 7 and conclude the paper in Section 8. 2 Background Existing techniques for implementing call/return communication abstractions include RPCs [15, 16] and futures <ref> [7, 14] </ref>. Both techniques introduce unnecessary sequentiality in the execution of concurrent programs which is eliminated by our technique. We compare the advantages of using our join continuation based implementation with RPCs and futures.
Reference: [8] <author> D. Kahaner, C. Moler, and S. Nash. </author> <title> Numerical Methods and Software. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The future-based implementation will sequentialize the evaluation of the expression for each input whereas the join continuation-based implementation is able to pipeline the execution of evaluation of the expression for different inputs. Example: Adaptive Quadrature The adaptive quadrature technique computes the integral of a given function <ref> [8] </ref> by dividing the given interval into subintervals. It recursively divides subintervals in which the local estimated error is greater than the given error bound and uses smaller step size for those subintervals.
Reference: [9] <author> W. Kim and G. Agha. </author> <title> An Efficient Implementation of Run-Time System with Locality Transparency for Concurrent Object Oriented Languages on Stock Hardware Multicomputers. preparing for submission, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: At the end of the continuation method, the object is made active using creator field and is allowed to process other incoming messages [2]. 7 Performance We present performance numbers for programs that use CCRC abstraction. The programs are written using a High-Level Actor Language, THAL <ref> [9, 13] </ref> which implements CCRC abstraction discussed in the paper. to the expression evaluation example given in Section 3), computing integral of a given function using the adaptive quadrature, and solving the N-Queen problem for N=13.
Reference: [10] <author> K. Mani Chandy and Stephen Taylor. </author> <title> An Introduction to Parallel Programming. </title> <publisher> Jones and Bartlett Publishers, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: It recursively divides subintervals in which the local estimated error is greater than the given error bound and uses smaller step size for those subintervals. The algorithm can be implemented using a manager-worker structure <ref> [10] </ref> such that the manager gives a subintervals to each worker for computing the corresponding partial integral. The following program segment shows how call/return abstraction can be used to express this.
Reference: [11] <author> C. Manning. ACORE: </author> <title> The Design of a Core Actor Language and its Compiler. </title> <type> Master's thesis, </type> <institution> MIT, Artificial Intelligence Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: However, programming with non-blocking asynchronous communication necessitates explicit manipulation of continuation which may be very tedious and error-prone [5]. On the other hand, blocking asynchronous communications or call/return communication abstractions, such as ask <ref> [11] </ref>, now [17] and request [3], eliminate the need for explicit continuation manipulation to ease the task of programming; they allow an object to invoke a method on a remote object and use the value returned by the object.
Reference: [12] <author> A Hierarchical O(nlogn) Force-Calculation ALgorithm. J. Barnes and P. </author> <title> Hut. </title> <journal> Nature, </journal> <volume> 324(4) </volume> <pages> 446-449, </pages> <year> 1986. </year>
Reference-contexts: As a result the program deadlocks. Our implementation of call/return abstraction automatically creates a separate continuation object which waits for the results to return from the workers leaving the manager ready to process the get proc request (Figure 4 (b)). Example: Barnes Hut Algorithm The Barnes Hut algorithm <ref> [12] </ref> for solving the N-body problem requires the construction of a quad tree representing bodies present in a region followed by the computation of certain interaction between the bodies (say gravitational interaction). Suppose each body is implemented as a concurrent object.
Reference: [13] <author> R. Panwar and W. Kim and G. Agha. </author> <title> Parallel Implementations of Irregular Problems Using High-level Actor Language. </title> <booktitle> In International Parallel Processing Symposium, </booktitle> <year> 1996. </year> <note> Submitted. </note>
Reference-contexts: The third example, Barnes Hut algorithm for solving n-body problems, shows how the use of CCRC avoids unnecessary sequentialization of the execution of parallel programs which may be caused in other models such as RPCs and futures. All examples discussed below are written in a High-Level Actor Language <ref> [3, 13] </ref>, although the transformations discussed in this paper can be implemented for any language based on concurrent objects. Example 1: Expression Evaluation Consider a program which evaluates expressions using concurrent objects. The expression is stored as a binary tree where a node represents either a function or a value. <p> At the end of the continuation method, the object is made active using creator field and is allowed to process other incoming messages [2]. 7 Performance We present performance numbers for programs that use CCRC abstraction. The programs are written using a High-Level Actor Language, THAL <ref> [9, 13] </ref> which implements CCRC abstraction discussed in the paper. to the expression evaluation example given in Section 3), computing integral of a given function using the adaptive quadrature, and solving the N-Queen problem for N=13.
Reference: [14] <author> K. Taura, S. Matsuoka, and A. Yonezawa. ABCL/f: </author> <title> A Future-Based Polymorphic Typed Concurrent Object-Oriented Language Its Design and Implementation. </title> <editor> In G. E. Blelloch, K. Mani Chandy, and S. Jagannathan, editors, </editor> <booktitle> DIMACS. Series in Discrete Mathematics and Theoretical Computer Science. </booktitle> <volume> vol 18. </volume> <booktitle> Specification of Parallel Algorithms, </booktitle> <pages> pages 275-291. </pages> <publisher> American Mathematical Society, </publisher> <year> 1994. </year> <booktitle> Proceedings of DIMACS '94 Workshop. </booktitle>
Reference-contexts: An efficient implementation scheme of continuation objects is proposed in Section 6. We present the preliminary evaluation results obtained from the implementation in Section 7 and conclude the paper in Section 8. 2 Background Existing techniques for implementing call/return communication abstractions include RPCs [15, 16] and futures <ref> [7, 14] </ref>. Both techniques introduce unnecessary sequentiality in the execution of concurrent programs which is eliminated by our technique. We compare the advantages of using our join continuation based implementation with RPCs and futures.
Reference: [15] <author> C. A. Thekkath, H. M. Levy, and E. D. Lazowska. </author> <title> Separating Data and Control Transfer in Distributed Operating Systems. </title> <booktitle> In ASPLOS VI, </booktitle> <pages> pages 2-11. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: An efficient implementation scheme of continuation objects is proposed in Section 6. We present the preliminary evaluation results obtained from the implementation in Section 7 and conclude the paper in Section 8. 2 Background Existing techniques for implementing call/return communication abstractions include RPCs <ref> [15, 16] </ref> and futures [7, 14]. Both techniques introduce unnecessary sequentiality in the execution of concurrent programs which is eliminated by our technique. We compare the advantages of using our join continuation based implementation with RPCs and futures.
Reference: [16] <author> D.A. Wallach, W.C. Hsieh, K.L. Johnson, M.F. Kaashoek, and W.E. Weihl. </author> <title> Optimistic Active Messages: A Mechanism for Scheduling Communication with Computation. </title> <booktitle> In ACM SIGPLAN Notices, Proceedings of PPOPP '95, </booktitle> <volume> volume 30(8), </volume> <pages> pages 217-226. </pages> <publisher> ACM, ACM Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: An efficient implementation scheme of continuation objects is proposed in Section 6. We present the preliminary evaluation results obtained from the implementation in Section 7 and conclude the paper in Section 8. 2 Background Existing techniques for implementing call/return communication abstractions include RPCs <ref> [15, 16] </ref> and futures [7, 14]. Both techniques introduce unnecessary sequentiality in the execution of concurrent programs which is eliminated by our technique. We compare the advantages of using our join continuation based implementation with RPCs and futures.
Reference: [17] <author> A. Yonezawa, </author> <title> editor. ABCL An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year> <month> 14 </month>
Reference-contexts: However, programming with non-blocking asynchronous communication necessitates explicit manipulation of continuation which may be very tedious and error-prone [5]. On the other hand, blocking asynchronous communications or call/return communication abstractions, such as ask [11], now <ref> [17] </ref> and request [3], eliminate the need for explicit continuation manipulation to ease the task of programming; they allow an object to invoke a method on a remote object and use the value returned by the object.
References-found: 17

