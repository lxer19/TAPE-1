URL: http://www.cs.chalmers.se/pub/cs-reports/techreports/TR-83.ps.Z
Refering-URL: http://www.cs.chalmers.se/pub/cs-reports/techreports/
Root-URL: 
Title: Programming Methodology Group  Semi-unification of Two Terms in Abelian Groups  
Author: Mikael Rittri 
Date: 83 July 1994  
Affiliation: Goteborg University and Chalmers University of Technology  
Pubnum: Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. H. Bradley, </author> <title> Algorithm and bound for the greatest common divisor of n integers, </title> <journal> Commun. </journal> <note> ACM 13 (1970) 433-436. </note>
Reference-contexts: : 8x: [x] real fl [x] real ! [x] real fl : 8xy: [x] real fl [y] real ! [x y] real = : 8xy: [x] real fl [y] real ! [x y 1 ] real sqrt : 8x: [x 2 ] real ! [x] real exp; ln; sin : <ref> [1] </ref> real ! [1] real There is also a polymorphic zero: zero : 8x: [x] real In Kennedy's system, the most general dimensions are derived automatically by unification in Abelian groups (AG-unification) [11]. That is, a unifier needs only make dimensions equal in the Abelian group, not syntactically equal. <p> real fl [x] real ! [x] real fl : 8xy: [x] real fl [y] real ! [x y] real = : 8xy: [x] real fl [y] real ! [x y 1 ] real sqrt : 8x: [x 2 ] real ! [x] real exp; ln; sin : <ref> [1] </ref> real ! [1] real There is also a polymorphic zero: zero : 8x: [x] real In Kennedy's system, the most general dimensions are derived automatically by unification in Abelian groups (AG-unification) [11]. That is, a unifier needs only make dimensions equal in the Abelian group, not syntactically equal. <p> This is because the computation of gcd (k 1 ; : : : ; k m ) can be done in O (m + minflog jk i jg) <ref> [1] </ref>. The complexity of (5) should then be dominated by the computation of ^e by iterated multiplication as in section 3, which requires at most log 2 (a) iterations, each of which needs O (log (a)) multiplications and divisions. Hence, ^e can be computed in O ((log (a)) 2 ).
Reference: [2] <author> L. Damas and R. Milner, </author> <title> Principal type-schemes for functional programs, </title> <booktitle> in: 9th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> Albuquerque, </address> <year> (1982) </year> <month> 207-212. </month>
Reference-contexts: Such errors can be prevented by giving dimension parameters to the numeric types. Flexibility similar to Milner's type system <ref> [2] </ref> is possible if the dimension parameters can be polymorphic, as has been suggested by House [6], Wand and O'Keefe [16], Goubault [4], and Kennedy [7]. House's type system is an extension of Pascal and does not derive the most general dimensions automatically. <p> But there are no problems with equation (2). 1.2 Polymorphic recursion A limitation of Milner's type system <ref> [2] </ref> is that inside mutually recursive definitions, all uses of a function must have the same type as its definition.
Reference: [3] <author> F. Fages and G. Huet, </author> <title> Complete sets of unifiers and matchers in equational theories, </title> <institution> Theor. Comput. Sci. </institution> <month> 43 </month> <year> (1986) </year> <month> 189-200. </month>
Reference-contexts: My algorithm can probably not improve dimension derivation until these restrictions are removed. 2 Semi-unification in equational theories 2.1 Terms, substitutions, and equivalence I assume familiarity with terms and substitutions <ref> [3, 11, 15] </ref>. V (t) is the set of variables in the term t, D () is the set of variables changed by the substitution , and I () is the set of variables introduced by (occurring in some term (x) where x 2 D ()). <p> To extend these relations to substitutions, add a variable set X as parameter: = X X E t for some ; X E t and t X 2.2 Semi-unification I am not aware of any earlier work on equational semi-unification. My definitions combine equational unification <ref> [3, 11, 15] </ref> with ordinary, or syntactic, semi unification [5, 8, 9]. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality). <p> The set of all E-semi-unifiers of S is written SemiU E (S). Definition 2 (inspired by Fages and Huet <ref> [3] </ref>) Let S be a system, let X be its variables, let X R be the variables in its right hand sides, and let W be a set of "protected" variables disjoint from X.
Reference: [4] <author> J. Goubault, </author> <title> Inference d'unites physiques en ML, </title> <editor> in: P. Cointe, C. Queinnec, and B. Serpette (eds.), Journees Francophones des Langages Applicatifs, Noirmoutier, </editor> <publisher> (INRIA, </publisher> <address> Collection Didactique, </address> <year> 1994) </year> <month> 3-20. </month>
Reference-contexts: Such errors can be prevented by giving dimension parameters to the numeric types. Flexibility similar to Milner's type system [2] is possible if the dimension parameters can be polymorphic, as has been suggested by House [6], Wand and O'Keefe [16], Goubault <ref> [4] </ref>, and Kennedy [7]. House's type system is an extension of Pascal and does not derive the most general dimensions automatically. The other three systems are extensions of ML and have automatic dimension derivation. All systems allow fractional dimension exponents except Kennedy's, which only allows integers.
Reference: [5] <author> F. Henglein, </author> <title> Type inference with polymorphic recursion, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <month> 15 </month> <year> (1993) </year> <month> 253-289. </month>
Reference-contexts: And there is an interesting type system with existentially quantified types [12], in which it is much more important to have polymorphic recursion. A type system that allows polymorphic recursion was designed by Mycroft, who showed that there exist most general types [14]. Type derivation is equivalent <ref> [5, 9] </ref> to semi-unification, an algebraic problem that will be described in section 2. Unfortunately, the general case is undecidable [8]. But type checking is possible, if the types are declared by the programmer. <p> Type derivation is equivalent [5, 9] to semi-unification, an algebraic problem that will be described in section 2. Unfortunately, the general case is undecidable [8]. But type checking is possible, if the types are declared by the programmer. And Henglein <ref> [5] </ref> has constructed an algorithm for type derivation, which quickly can give one of three results: 1. "no type exists", 2. "a most general type is the following. . . ", or 3. "a type, if it exists, takes more than n pages to write down." This looks like a satisfactory <p> My definitions combine equational unification [3, 11, 15] with ordinary, or syntactic, semi unification <ref> [5, 8, 9] </ref>. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality).
Reference: [6] <author> R. T. House, </author> <title> A proposal for an extended form of type checking of expressions, </title> <journal> Comput. J. </journal> <month> 26 </month> <year> (1983) </year> <month> 366-374. </month>
Reference-contexts: Such errors can be prevented by giving dimension parameters to the numeric types. Flexibility similar to Milner's type system [2] is possible if the dimension parameters can be polymorphic, as has been suggested by House <ref> [6] </ref>, Wand and O'Keefe [16], Goubault [4], and Kennedy [7]. House's type system is an extension of Pascal and does not derive the most general dimensions automatically. The other three systems are extensions of ML and have automatic dimension derivation.
Reference: [7] <author> A. Kennedy, </author> <title> Dimension types, </title> <editor> in: D. Sannella (ed.), </editor> <booktitle> Programming Languages and Systems | ESOP '94, 5th European Symp. on Programming, Edinburgh, Lecture Notes in Computer Science 788 (Springer, </booktitle> <year> 1994) </year> <month> 348-362. </month>
Reference-contexts: Such errors can be prevented by giving dimension parameters to the numeric types. Flexibility similar to Milner's type system [2] is possible if the dimension parameters can be polymorphic, as has been suggested by House [6], Wand and O'Keefe [16], Goubault [4], and Kennedy <ref> [7] </ref>. House's type system is an extension of Pascal and does not derive the most general dimensions automatically. The other three systems are extensions of ML and have automatic dimension derivation. All systems allow fractional dimension exponents except Kennedy's, which only allows integers. <p> quickly can give one of three results: 1. "no type exists", 2. "a most general type is the following. . . ", or 3. "a type, if it exists, takes more than n pages to write down." This looks like a satisfactory practical solution. 1.3 Polymorphic recursion for dimensions Kennedy <ref> [7] </ref> notes that polymorphic recursion becomes more important in a language with dimension types. The results cited earlier suggest that derivation of dimensions (with integer exponents) under polymorphic recursion is equivalent to semi-unification in Abelian groups. I have not proved this, though.
Reference: [8] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn, </author> <title> The undecidability of the semi-unification problem, </title> <institution> Inf. Comput. </institution> <month> 102 </month> <year> (1993) </year> <month> 83-101. </month>
Reference-contexts: A type system that allows polymorphic recursion was designed by Mycroft, who showed that there exist most general types [14]. Type derivation is equivalent [5, 9] to semi-unification, an algebraic problem that will be described in section 2. Unfortunately, the general case is undecidable <ref> [8] </ref>. But type checking is possible, if the types are declared by the programmer. <p> My definitions combine equational unification [3, 11, 15] with ordinary, or syntactic, semi unification <ref> [5, 8, 9] </ref>. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality).
Reference: [9] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn, </author> <title> Type reconstruction in the presence of polymorphic recursion, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <month> 15 </month> <year> (1993) </year> <month> 290-311. </month>
Reference-contexts: And there is an interesting type system with existentially quantified types [12], in which it is much more important to have polymorphic recursion. A type system that allows polymorphic recursion was designed by Mycroft, who showed that there exist most general types [14]. Type derivation is equivalent <ref> [5, 9] </ref> to semi-unification, an algebraic problem that will be described in section 2. Unfortunately, the general case is undecidable [8]. But type checking is possible, if the types are declared by the programmer. <p> My definitions combine equational unification [3, 11, 15] with ordinary, or syntactic, semi unification <ref> [5, 8, 9] </ref>. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality).
Reference: [10] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 2, </volume> <publisher> section 4.5.2, (Addison-Wesley, </publisher> <editor> 2nd ed. </editor> <year> 1981). </year>
Reference-contexts: We can compute gcd (c 1 ; : : : ; c m ) and possible values of d 1 ; : : : ; d m simultaneously by a well-known extension of Euclid's algorithm <ref> [10, 13] </ref>. The d i are not uniquely deter mined by the c i , but we can say something about the difference between alternative solutions. <p> This terminates, since each substitution either makes all but one of the exponents zero, or else decreases the smallest non-zero absolute value of the exponents. (This method is used by Knuth <ref> [10, pages 326-327] </ref> and is essentially Euclid's algorithm.) We will finally get an inequation of the form z h i2I i AG z g j=1 b j where h and g may be zero.
Reference: [11] <author> D. Lankford, G. Butler, and B. Brady, </author> <title> Abelian group unification algorithms for elementary terms, </title> <journal> Contemp. Math. </journal> <volume> 29 (1884) 193-199. </volume>
Reference-contexts: y 1 ] real sqrt : 8x: [x 2 ] real ! [x] real exp; ln; sin : [1] real ! [1] real There is also a polymorphic zero: zero : 8x: [x] real In Kennedy's system, the most general dimensions are derived automatically by unification in Abelian groups (AG-unification) <ref> [11] </ref>. That is, a unifier needs only make dimensions equal in the Abelian group, not syntactically equal. In the systems with fractional exponents, Gaussian elimination is used instead. Although fractional exponents are often used in dimensional analysis, I think Kennedy is right in that they can be avoided in programming. <p> My algorithm can probably not improve dimension derivation until these restrictions are removed. 2 Semi-unification in equational theories 2.1 Terms, substitutions, and equivalence I assume familiarity with terms and substitutions <ref> [3, 11, 15] </ref>. V (t) is the set of variables in the term t, D () is the set of variables changed by the substitution , and I () is the set of variables introduced by (occurring in some term (x) where x 2 D ()). <p> To extend these relations to substitutions, add a variable set X as parameter: = X X E t for some ; X E t and t X 2.2 Semi-unification I am not aware of any earlier work on equational semi-unification. My definitions combine equational unification <ref> [3, 11, 15] </ref> with ordinary, or syntactic, semi unification [5, 8, 9]. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality).
Reference: [12] <author> K. Laufer and M. Odersky, </author> <title> Polymorphic type inference and abstract data types, </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <note> to appear. </note>
Reference-contexts: We can say that recursion is not polymorphic in Milner's system. Polymorphic recursion is useful now and then. The bush datatype is not artificial; it was invented independently by C. Wadsworth and Conal Elliott for real applications. And there is an interesting type system with existentially quantified types <ref> [12] </ref>, in which it is much more important to have polymorphic recursion. A type system that allows polymorphic recursion was designed by Mycroft, who showed that there exist most general types [14]. Type derivation is equivalent [5, 9] to semi-unification, an algebraic problem that will be described in section 2.
Reference: [13] <author> R. J. Levit, </author> <title> A minumum solution of a Diophantine equation, </title> <journal> Amer. Math. Monthly, </journal> <month> 63 </month> <year> (1956) </year> <month> 646-651. </month>
Reference-contexts: We can compute gcd (c 1 ; : : : ; c m ) and possible values of d 1 ; : : : ; d m simultaneously by a well-known extension of Euclid's algorithm <ref> [10, 13] </ref>. The d i are not uniquely deter mined by the c i , but we can say something about the difference between alternative solutions. <p> theorem 8.2 and lemma 6 say that ^e = gcd (h^e; a)= gcd ((h g); h^e; a) j (b 0 j ): (13) If condition (12) holds for all j, pick any solution fb 0 j g (small or minimal solutions can be found by a method due to Levit <ref> [13] </ref>).
Reference: [14] <author> A. Mycroft, </author> <title> Polymorphic type schemes and recursive definitions, </title> <editor> in: M. Paul and B. Robinet (eds.), </editor> <booktitle> Int. Symp. on Programming, 6th Colloq., Toulouse, Lecture Notes in Computer Science 167 (Springer, </booktitle> <year> 1984) </year> <month> 217-228. </month>
Reference-contexts: Wadsworth and Conal Elliott for real applications. And there is an interesting type system with existentially quantified types [12], in which it is much more important to have polymorphic recursion. A type system that allows polymorphic recursion was designed by Mycroft, who showed that there exist most general types <ref> [14] </ref>. Type derivation is equivalent [5, 9] to semi-unification, an algebraic problem that will be described in section 2. Unfortunately, the general case is undecidable [8]. But type checking is possible, if the types are declared by the programmer.
Reference: [15] <author> J. H. Siekmann, </author> <title> Unification theory, </title> <journal> J. Symbolic Comput. </journal> <month> 7 </month> <year> (1989) </year> <month> 207-274. </month>
Reference-contexts: My algorithm can probably not improve dimension derivation until these restrictions are removed. 2 Semi-unification in equational theories 2.1 Terms, substitutions, and equivalence I assume familiarity with terms and substitutions <ref> [3, 11, 15] </ref>. V (t) is the set of variables in the term t, D () is the set of variables changed by the substitution , and I () is the set of variables introduced by (occurring in some term (x) where x 2 D ()). <p> To extend these relations to substitutions, add a variable set X as parameter: = X X E t for some ; X E t and t X 2.2 Semi-unification I am not aware of any earlier work on equational semi-unification. My definitions combine equational unification <ref> [3, 11, 15] </ref> with ordinary, or syntactic, semi unification [5, 8, 9]. If you let E = ; in my definitions, you get syntactic semi unification (since = E is then syntactic equality).
Reference: [16] <author> M. Wand and P. M. O'Keefe, </author> <title> Automatic dimensional inference, </title> <editor> in: J.-L. Lassez and G. Plotkin (eds.), </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <publisher> (MIT Press, </publisher> <year> 1991) </year> <month> 479-483. 13 </month>
Reference-contexts: Such errors can be prevented by giving dimension parameters to the numeric types. Flexibility similar to Milner's type system [2] is possible if the dimension parameters can be polymorphic, as has been suggested by House [6], Wand and O'Keefe <ref> [16] </ref>, Goubault [4], and Kennedy [7]. House's type system is an extension of Pascal and does not derive the most general dimensions automatically. The other three systems are extensions of ML and have automatic dimension derivation. All systems allow fractional dimension exponents except Kennedy's, which only allows integers.
References-found: 16

