URL: http://www.cs.rutgers.edu/~bvickers/672/papers/LGLA98.ps.gz
Refering-URL: http://www.cs.rutgers.edu/~bvickers/672/schedule.html
Root-URL: http://www.cs.rutgers.edu
Title: Multimedia Systems Manuscript-Nr. (will be inserted by hand later) A Comparison of Reliable Multicast Protocols  
Author: Brian Neil Levine and J.J. Garcia-Luna-Aceves 
Keyword: Key words: Reliable Multicast, Performance Evaluation, Transport Protocols, Collaboration, Internet.  
Address: Santa Cruz, CA 95064, USA  
Affiliation: Computer Engineering Department University of California,  
Abstract: We analyze the maximum throughput that known classes of reliable multicast transport protocols can attain. A new taxonomy of reliable multicast transport protocols is introduced based on the premise that the mechanisms used to release data at the source after correct delivery should be decoupled from the mechanisms used to pace the transmission of data and to effect error recovery. Receiver-initiated protocols, which are based entirely on negative acknowledgments (naks) sent from the receivers to the sender, have been proposed to avoid the implosion of acknowledgments (acks) to the source. However, these protocols are shown to require infinite buffers in order to prevent deadlocks. Two other solutions to the ack-implosion problem are tree-based protocols and ring-based protocols. The first organize the receivers in a tree and send acks along the tree; the latter send acks to the sender along a ring of receivers. These two classes of protocols are shown to operate correctly with finite buffers. It is shown that tree-based protocols constitute the most scalable class of all reliable multicast protocols proposed to date. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ballardie, A., Francis, P., and Crowcroft, J. </author> <title> Core based trees (CBT): An architecture for scalable inter-domain multi-cast routing. </title> <booktitle> In Proc. ACM SIGCOMM'93 (October 1993), </booktitle> <pages> pp. 85-95. </pages>
Reference-contexts: Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols. In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) <ref> [1] </ref>, Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past [17, 18], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> We make two additional assumptions: (1) no acknowledgments are ever lost, and (2) all loss events at any node in the multicast of a packet are mutually independent. Such multicast routing protocols as CBT, OCBT, PIM, MIP, and DVMRP <ref> [1, 20, 7, 14, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. Our first assumption benefits all classes, but especially favors protocols that multicast acknowledgments. <p> obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] r ] E [Y p ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (51) As shown previously [17, 18], E <ref> [M r jM r &gt; 1] </ref> = 1 p Substituting Equations 43, 52, and 32 into Eq. 51 we have E [Y R ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + p E [Y p ] p Assuming all operations <p> The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [17, 18] E [X A ] fi fi = A [1] 1 p 3 p : (58) Using Equations 18, 36, 48, and 58, we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X <p> if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [17, 18] E [X A ] fi fi = A [1] 1 p 3 p : (58) Using Equations 18, 36, 48, and 58, we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] + (E [M H1 ] 1)(2) + B E [M H1 ](1
Reference: 2. <author> Bertsekas, D., and Gallager, R. </author> <title> Data Networks, second ed. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: Because our analysis focuses on maximum attainable throughput of protocol classes, we will assume that the token is passed exactly once per message. 3 Protocol Correctness A protocol is considered correct if it is shown to be both safe and live <ref> [2] </ref>. Given the minimum definition of reliable service we have assumed, for any reliable multicast protocol to be live, no deadlock should occur at any receiver or the source. <p> The proof of correctness for ring-based protocols is given by Chang and Maxemchuk [3]. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gal-lager <ref> [2] </ref>). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity. <p> Therefore, the proof follows from the correctness proof of unicast retransmission protocols presented by Bertsekas and Gallager <ref> [2] </ref>. For h &gt; 1, assume the theorem holds for any t such that (1 t &lt; h). We must prove the theorem holds for some t = h. Liveness: We must prove that each member of a tree of height t is live. <p> The protocol is live and will not enter into deadlock if c 1 &lt; c 2 &lt; c 3 , and c 3 is finite. The rest of the proof follows from the proof by Bertsekas and Gallager <ref> [2] </ref> for unicast ARQ protocols, where the group leader takes the place of the source. Therefore, TRMP is live. Safety: The safety of TRMP follows directly, because our proof of liveness shows that any arbitrary packet i is delivered at each receiver within a finite time. <p> For clarity, we assume a single ack tree rooted at a single source in the analysis of tree-based protocols. A selective repeat retransmission strategy is assumed in all the protocol classes since it is well known to be the retransmission strategy with the highest throughput <ref> [2] </ref>, and its requirement of keeping buffers at the receivers is a non-issue given the small cost of memory. Assumptions specific to each protocol are listed in Section 2, and are in the interest of modeling maximum throughput. <p> Taking expectations of Eq. 30, + (E [M H1 ]1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E <ref> [M r jM r &gt; 2] </ref>2) E [Y t ]: (31) It follows from the distribution of M r that [17, 18] E [M r jM r &gt; 2] = 1 p Therefore, noting Eq. 32 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 31 <p> Taking expectations of Eq. 30, + (E [M H1 ]1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E <ref> [M r jM r &gt; 2] </ref>2) E [Y t ]: (31) It follows from the distribution of M r that [17, 18] E [M r jM r &gt; 2] = 1 p Therefore, noting Eq. 32 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 31 the expected cost as E [Y H2 ] = E [M H1 ](1 p) E [Y p ] + E [Y f ] <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] r ] E [Y p ] + p 2 (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ]: (51) As shown previously [17, 18], E [M r jM r &gt; 1] = 1 p Substituting Equations 43, 52, and 32 into Eq. 51 we have E [Y R ] = E [X a ] + (1 p) E
Reference: 3. <author> Chang, J.-M., and Maxemchuk, N. F. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems 2, </journal> <month> 3 (August </month> <year> 1984), </year> <pages> 251-273. </pages>
Reference-contexts: Although reliable broadcast protocols have existed for quite some time <ref> [3] </ref>, viable approaches on the provision of end-to-end reliable multicas-ting over the Internet are just emerging. <p> One of the first proposals for reliable multicasting is the token ring protocol (TRP) <ref> [3] </ref>; its aim was to combine the throughput advantages of naks with the reliability of acks. The Reliable Multicast Protocol (RMP) [23] discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings. <p> We assume that there exists some non-zero probability that a packet is received error-free, and that all senders and receivers have finite memory. The proof of correctness for ring-based protocols is given by Chang and Maxemchuk <ref> [3] </ref>. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gal-lager [2]). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity.
Reference: 4. <author> Clark, D. D., Lambert, M. L., and Zhang, L. NETBLT: </author> <title> A high throughput transport protocol. </title> <booktitle> In Proc. ACM SIG-COMM'93 (Aug. </booktitle> <year> 1987), </year> <pages> pp. 353-359. </pages>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP [10]) or separate windows (e.g., NETBLT <ref> [4] </ref>). Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols.
Reference: 5. <author> Deering, S. </author> <title> Multicast routing in a datagram internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, Palo Alto, California, </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: We make two additional assumptions: (1) no acknowledgments are ever lost, and (2) all loss events at any node in the multicast of a packet are mutually independent. Such multicast routing protocols as CBT, OCBT, PIM, MIP, and DVMRP <ref> [1, 20, 7, 14, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. Our first assumption benefits all classes, but especially favors protocols that multicast acknowledgments.
Reference: 6. <author> Deering, S., and Cheriton, D. </author> <title> Multicast routing in data-gram inter-networks and extended lans. </title> <journal> ACM Transactions on Computer Systems 8, </journal> <month> 2 (May </month> <year> 1990), </year> <pages> 85-110. </pages>
Reference-contexts: Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols. In the Internet, these trees will be built using such protocols as DVMRP <ref> [6] </ref>, Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past [17, 18], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender.
Reference: 7. <author> Deering, S., et al. </author> <title> An architecture for wide-area multicast routing. </title> <booktitle> In Proc. ACM SIGCOMM'94 (1994), </booktitle> <pages> pp. 126-135. </pages>
Reference-contexts: Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols. In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) <ref> [7] </ref>, or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past [17, 18], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> We make two additional assumptions: (1) no acknowledgments are ever lost, and (2) all loss events at any node in the multicast of a packet are mutually independent. Such multicast routing protocols as CBT, OCBT, PIM, MIP, and DVMRP <ref> [1, 20, 7, 14, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. Our first assumption benefits all classes, but especially favors protocols that multicast acknowledgments.
Reference: 8. <author> Floyd, S., et al. </author> <title> A reliable multicast framework for lightweight sessions and application level framing. </title> <booktitle> In Proc. ACM SIGCOMM'95. </booktitle> <month> (August </month> <year> 1995), </year> <pages> pp. 342-356. </pages>
Reference-contexts: Section 6 provides concluding remarks. 2 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [8, 17, 18, 22] </ref> addressing receiver-initiated strategies for reliable mul-ticasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> However, as suggested by the results reported by Floyd et al. <ref> [8] </ref>, a better approach for pacing a multicast session is for each receiver to set its own timeout. <p> Because receivers communicate naks back to the source, receiver-initiated protocols have the possibility of experiencing a nak-implosion problem at the source if many receivers detect transmission errors. To remedy this problem, previous work on receiver-initiated protocols <ref> [17, 18, 8] </ref> adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown [17, 18, 22] to have better performance than the basic receiver-initiated protocol. <p> Nodes farther away from the source might not even get a chance to request a retransmission. The generic protocol does not describe how timers are set accurately. The generic RINA protocol we have just described constitutes the basis for the operation of the scalable reliable multicasting (SRM) algorithm <ref> [8] </ref>. SRM has been embedded into an internet collaborative whiteboard application called wb. SRM sets timers based on low-rate, periodic "session-messages" multicast by every member of the group. <p> Approaches to limit the scope of naks and retransmission are still evolving <ref> [8] </ref>. However, current proposals still rely on session messages that reach all group members. Another example of a receiver-initiated protocol is the "log-based receiver-reliable multicast" (LBRM) [9], which uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. <p> Because we have assumed that a single nak reaches the source, that naks are never lost, and that session messages incur no processing load, we implicitly assume the optimum behavior of RINA protocols. The simulation results reported for SRM by Floyd et al. <ref> [8] </ref> agree with our model and result from assuming no nak losses and a single packet loss in the experiments. Figure 7 shows that tree-NAPP protocols can be made to perform better than the best possible RINA protocol by limiting the size of the local groups. <p> On the other hand, while the scope of naks and retransmissions can be reduced without establishing a structure in the receiver set <ref> [8] </ref>, limiting the scope of the session messages needed to set nak -avoidance timers and to contain the scope of naks and retransmissions require the aggregation of these messages. This leads to organizing receivers into local groups that must aggregate sessions messages sent to the source (and local groups).
Reference: 9. <author> Holbrook, H., S.Singhal, and Cheriton, D. </author> <title> Log-based receiver-reliable multicast for distributed interactive simulation. </title> <booktitle> In Proc. ACM SIGCOMM'95 (August 1995), </booktitle> <pages> pp. 328-341. </pages>
Reference-contexts: Approaches to limit the scope of naks and retransmission are still evolving [8]. However, current proposals still rely on session messages that reach all group members. Another example of a receiver-initiated protocol is the "log-based receiver-reliable multicast" (LBRM) <ref> [9] </ref>, which uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. Using log servers is feasible only for applications that can afford the servers and leaves many issues unresolved.
Reference: 10. <author> Jon B. Postel, ed. </author> <title> Transmission control protocol. Request For Comments 793, </title> <month> September </month> <year> 1981. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP <ref> [10] </ref>) or separate windows (e.g., NETBLT [4]). Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols.
Reference: 11. <author> Levine, B. N., and Garcia-Luna-Aceves, J. </author> <title> A comparison of known classes of reliable multicast protocols. </title> <booktitle> In Proc. IEEE International Conference on Network Protocols (Octo-ber 1996). </booktitle>
Reference-contexts: This is because the basic nak-avoidance algorithm requires that timers be set based on updates multicast by every node. As the num 2 Multiple sources are supported in SRM, we focus on the single-source case for simplicity. 3 Our prior description of SRM <ref> [12, 11] </ref> incorrectly assumed that session messages contained the highest sequence number heard from the source.
Reference: 12. <author> Levine, B. N., Lavo, D., and Garcia-Luna-Aceves, J. </author> <title> The case for reliable concurrent multicasting using shared ack trees. </title> <booktitle> In Proc. ACM Multimedia (November 1996), </booktitle> <pages> pp. 365-376. </pages>
Reference-contexts: This is because the basic nak-avoidance algorithm requires that timers be set based on updates multicast by every node. As the num 2 Multiple sources are supported in SRM, we focus on the single-source case for simplicity. 3 Our prior description of SRM <ref> [12, 11] </ref> incorrectly assumed that session messages contained the highest sequence number heard from the source. <p> A group leader cannot send an aggregate ack until all its children have sent an aggregate ack. Using aggregate acks is necessary to ensure that the protocol operates correctly even if group leaders fail, or if the ack tree is partitioned for long periods of time <ref> [12] </ref>. <p> group leader only waits for all its children to send local acks before advancing the mw , then correct operation after group leaders fail can only be guaranteed by not allowing nodes to delete packets; this is the approach used in all tree-based protocols [13, 16, 24] other than lorax <ref> [12] </ref>. The lorax protocol [12] is the first tree-based protocol to build a single shared ack tree for use by multiple sources in a single session, and to use aggregate acks to ensure correct operation after hosts in the ack tree fail. <p> for all its children to send local acks before advancing the mw , then correct operation after group leaders fail can only be guaranteed by not allowing nodes to delete packets; this is the approach used in all tree-based protocols [13, 16, 24] other than lorax <ref> [12] </ref>. The lorax protocol [12] is the first tree-based protocol to build a single shared ack tree for use by multiple sources in a single session, and to use aggregate acks to ensure correct operation after hosts in the ack tree fail. <p> For tree-based protocols, it can be shown that deleting packets from memory after a node receives local acks from its children is not live. Aggregate acks are necessary to ensure correct operation of tree-based protocols in the presence of failures. Lorax <ref> [12] </ref> is the only tree-based protocol that uses aggregate acks and can operate with finite memory in the presence of node failures or network partitions. 4 Maximum Throughput Analysis 4.1 Assumptions To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Section 2 can achieve, we <p> The number of tree-hops from the receiver to the source is also a factor in how quickly the source can release data from memory in the presence of node failures, as discussed by Levine, Lavo, and Garcia-Luna-Aceves <ref> [12] </ref>. by each of the different classes, relative to processor speed requirements. This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. [17, 18].
Reference: 13. <author> Lin, J., and Paul, S. RMTP: </author> <title> A reliable multicast transport protocol. </title> <booktitle> In Proc. IEEE Infocom (March 1996), </booktitle> <pages> pp. 1414-1425. </pages>
Reference-contexts: are not used, i.e., if a group leader only waits for all its children to send local acks before advancing the mw , then correct operation after group leaders fail can only be guaranteed by not allowing nodes to delete packets; this is the approach used in all tree-based protocols <ref> [13, 16, 24] </ref> other than lorax [12]. The lorax protocol [12] is the first tree-based protocol to build a single shared ack tree for use by multiple sources in a single session, and to use aggregate acks to ensure correct operation after hosts in the ack tree fail. <p> The first application of tree-based protocols to reliable multicasting over an internet was reported by Paul et al. [15], who compared three basic schemes for reliable point-to-multipoint multicasting using hierarchical structures. Their results have been fully developed as the reliable multicast transport protocol (RMTP) <ref> [13, 16] </ref>. While our generic protocol sends a local ack for every packet sent by the source, RMTP sends local acks only periodically, so as to conserve bandwidth and to reduce processing at each group leader, increasing attainable throughput.
Reference: 14. <author> Parsa, M., and Garcia-Luna-Aceves, J. </author> <title> A protocol for scalable loop-free multicast routing. </title> <journal> IEEE Journal on Selected Areas in Communications 15, </journal> <month> 3 (April </month> <year> 1997), </year> <pages> 316-331. </pages>
Reference-contexts: In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) <ref> [14] </ref>. 2.1 Sender-Initiated Protocols In the past [17, 18], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> We make two additional assumptions: (1) no acknowledgments are ever lost, and (2) all loss events at any node in the multicast of a packet are mutually independent. Such multicast routing protocols as CBT, OCBT, PIM, MIP, and DVMRP <ref> [1, 20, 7, 14, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. Our first assumption benefits all classes, but especially favors protocols that multicast acknowledgments.
Reference: 15. <author> Paul, S., Sabnani, K., and Kristol, D. </author> <title> Multicast transport protocols for high speed networks. </title> <booktitle> In International Conference on Network Protocols (October 1994), </booktitle> <pages> pp. 4-14. </pages>
Reference-contexts: If there is a timeout before all local acks have been received, the packet is assumed to be lost and is retransmitted by the source or group leader to its children. The first application of tree-based protocols to reliable multicasting over an internet was reported by Paul et al. <ref> [15] </ref>, who compared three basic schemes for reliable point-to-multipoint multicasting using hierarchical structures. Their results have been fully developed as the reliable multicast transport protocol (RMTP) [13, 16].
Reference: 16. <author> Paul, S., Sabnani, K. K., Lin, J. C., and Bhattacharyya, S. </author> <title> Reliable multicast transport protocol (RMTP). </title> <journal> IEEE Journal on Selected Areas in Communications 15, </journal> <month> 3 (April </month> <year> 1997), </year> <pages> 407-421. </pages>
Reference-contexts: are not used, i.e., if a group leader only waits for all its children to send local acks before advancing the mw , then correct operation after group leaders fail can only be guaranteed by not allowing nodes to delete packets; this is the approach used in all tree-based protocols <ref> [13, 16, 24] </ref> other than lorax [12]. The lorax protocol [12] is the first tree-based protocol to build a single shared ack tree for use by multiple sources in a single session, and to use aggregate acks to ensure correct operation after hosts in the ack tree fail. <p> The first application of tree-based protocols to reliable multicasting over an internet was reported by Paul et al. [15], who compared three basic schemes for reliable point-to-multipoint multicasting using hierarchical structures. Their results have been fully developed as the reliable multicast transport protocol (RMTP) <ref> [13, 16] </ref>. While our generic protocol sends a local ack for every packet sent by the source, RMTP sends local acks only periodically, so as to conserve bandwidth and to reduce processing at each group leader, increasing attainable throughput.
Reference: 17. <author> Pingali, S. </author> <title> Protocol and Real-Time Scheduling Issues for Multimedia Applications. </title> <type> PhD thesis, </type> <institution> University of Mas-sachusetts Amherst, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: The first comparative analysis of ideal sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [17, 18] </ref>. <p> To address this question, the previous analysis by Pingali et al. <ref> [17, 18, 22] </ref> is extended to consider the maximum throughput of generic ring-based protocols, which organize receivers into a ring, and two classes of tree-based protocols, which organize receivers into acknowledgment trees. These classes are the other three known approaches that can be used to solve the ack-implosion problem. <p> Section 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy. Section 4 extends the analysis by Pingali et al. <ref> [17, 18, 22] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local nak-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Section 6 provides concluding remarks. 2 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [8, 17, 18, 22] </ref> addressing receiver-initiated strategies for reliable mul-ticasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past <ref> [17, 18] </ref>, sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. However, this characterization is overly restrictive and does not reflect the way in which several reliable multicast protocols that rely on positive acknowledgments from the receivers to the source have been designed. <p> Fig. 2. A basic diagram of a receiver-initiated protocol. mission responsibility to members of the receiver set by organizing the receivers into a ring or a tree. We discuss both approaches subsequently. 2.2 Receiver-Initiated Protocols Previous work <ref> [17, 18] </ref> characterizes receiver-initiated protocols as placing the responsibility for ensuring reliable packet delivery at each receiver. The critical aspect of these protocols for our taxonomy is that no acks are used. <p> Because receivers communicate naks back to the source, receiver-initiated protocols have the possibility of experiencing a nak-implosion problem at the source if many receivers detect transmission errors. To remedy this problem, previous work on receiver-initiated protocols <ref> [17, 18, 8] </ref> adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown [17, 18, 22] to have better performance than the basic receiver-initiated protocol. <p> To remedy this problem, previous work on receiver-initiated protocols [17, 18, 8] adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown <ref> [17, 18, 22] </ref> to have better performance than the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [17, 18]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> Receiver-initiated with nak-avoidance (RINA) protocols have been shown [17, 18, 22] to have better performance than the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows <ref> [17, 18] </ref>: The sender multicasts all packets and state information, giving priority to retransmissions. Whenever a receiver detects a packet loss, it waits for a random time period and then multicasts a nak to the sender and all other receivers. <p> and can operate with finite memory in the presence of node failures or network partitions. 4 Maximum Throughput Analysis 4.1 Assumptions To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Section 2 can achieve, we use the same model used by Pin-gali et al. <ref> [17, 18] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. Our results clearly show that tree-NAPP protocols constitute the most scalable alternative. 4.2 Sender- and Receiver-Initiated Protocols Following the notation introduced by Pingali et al. <ref> [17, 18] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. The maximum throughput of the protocols for a constant stream of packets to R receivers is [17, 18]: p ln <p> Pingali et al. <ref> [17, 18] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. The maximum throughput of the protocols for a constant stream of packets to R receivers is [17, 18]: p ln R ) (1) pR 1=fl N2 2 O 1 + 1 p (3) Even as the probability of packet loss goes to zero, the throughput of the sender-initiated protocol is inversely dependent on R, the size of the receiver set, because an ack must be sent by <p> have E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] + E [L H1 ] E [X h ]: (5) What we have derived so far is extremely similar to Equations (1) and (2) in the analysis by Pingali et al. <ref> [17, 18] </ref>. In fact, we can use all of their analysis, with the understanding that B is the size of the receiver subset from which the source collects local acks. <p> into Eq. 5, we can rewrite the expected cost at the source node as E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] A Comparison of Reliable Multicast Protocols 9 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [17, 18] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [17, 18] O 1p O (ln R) O (1) Ring-based (unicast retrans.) O 1 + (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p O (1) O (1) Table 1. <p> as E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] A Comparison of Reliable Multicast Protocols 9 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [17, 18] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [17, 18] O 1p O (ln R) O (1) Ring-based (unicast retrans.) O 1 + (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p O (1) O (1) Table 1. <p> Analytical bounds. + E [M H1 ]B (1 p) E [X h ]: (7) Pingali et al. <ref> [17, 18] </ref> have shown that the expected number of transmissions per packet in A, N 1, and N 2 equals E [M ] = m=1 1 1 p (m1) Because in H1 the number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is <p> and N 2 equals E [M ] = m=1 1 1 p (m1) Because in H1 the number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is E [M H1 ] = m=1 1 1 p (m1) which can be simplified to <ref> [17, 18, 19] </ref> E [M H1 ] = i=1 B (1 p i ) Pingali et al. [17, 18] provide a bound of E [M ], that we apply to E [M H1 ] with R = B to obtain E [M H1 ] 2 O 1 + 1 p Using <p> number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is E [M H1 ] = m=1 1 1 p (m1) which can be simplified to [17, 18, 19] E [M H1 ] = i=1 B (1 p i ) Pingali et al. <ref> [17, 18] </ref> provide a bound of E [M ], that we apply to E [M H1 ] with R = B to obtain E [M H1 ] 2 O 1 + 1 p Using Eq. 11, we can bound Eq. 7 as follows E [X H1 ] 2 O B (1 <p> Notice that leaf nodes in theH1 protocol will process fewer retransmissions and thus send fewer acknowledgments than receivers in the A protocol. We can again use an analysis similar to the one by Pingali et al. <ref> [17, 18] </ref> for receivers using a sender initiated protocol. <p> Taking expectations of Eq. 30, + (E [M H1 ]1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E [M r jM r &gt; 2]2) E [Y t ]: (31) It follows from the distribution of M r that <ref> [17, 18] </ref> E [M r jM r &gt; 2] = 1 p Therefore, noting Eq. 32 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 31 the expected cost as E [Y H2 ] = E [M H1 ](1 p) E [Y p ] + E <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] r ] E [Y p ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (51) As shown previously <ref> [17, 18] </ref>, E [M r jM r &gt; 1] = 1 p Substituting Equations 43, 52, and 32 into Eq. 51 we have E [Y R ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + p E [Y p ] p <p> The graph represents the inverse of Equations 19, 36, and 48, respectively, which are the throughputs for the tree-based, tree-NAPP, and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [17, 18] </ref> for sender- and receiver-initiated protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet Fig. 6. The throughput graph from the exact equations for each protocol. The probability of packet loss is 1%, 10%, and 25% respectively. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [17, 18] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [17, 18] </ref> E [X A ] fi fi = A [1] 1 p 3 p : (58) Using Equations 18, 36, 48, and 58, we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] + (E <p> ((4 p) E [M H1 ] 1:9 + 0:1B 1 p R [R] = E [X A ] = E [X A ] 1 + 1 + 1 + (1 p) 1 2 (R 1)p The number of supportable receivers derived for sender and receiver-initiated protocols are shown to be <ref> [17, 18] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] From Figures 6 and 7, it is clear that tree-based protocols can support any number of receivers for the same processor speed bound at each node, and that
Reference: 18. <author> Pingali, S., Towsley, D., and Kurose, J. </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast protocols. In Performance Evaluation Review (May 1994), </title> <journal> vol. </journal> <volume> 22, </volume> <pages> pp. 221-230. </pages> <note> 16 Brian Neil Levine and J.J. Garcia-Luna-Aceves </note>
Reference-contexts: The first comparative analysis of ideal sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [17, 18] </ref>. <p> To address this question, the previous analysis by Pingali et al. <ref> [17, 18, 22] </ref> is extended to consider the maximum throughput of generic ring-based protocols, which organize receivers into a ring, and two classes of tree-based protocols, which organize receivers into acknowledgment trees. These classes are the other three known approaches that can be used to solve the ack-implosion problem. <p> Section 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy. Section 4 extends the analysis by Pingali et al. <ref> [17, 18, 22] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local nak-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Section 6 provides concluding remarks. 2 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [8, 17, 18, 22] </ref> addressing receiver-initiated strategies for reliable mul-ticasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) [20], Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past <ref> [17, 18] </ref>, sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. However, this characterization is overly restrictive and does not reflect the way in which several reliable multicast protocols that rely on positive acknowledgments from the receivers to the source have been designed. <p> Fig. 2. A basic diagram of a receiver-initiated protocol. mission responsibility to members of the receiver set by organizing the receivers into a ring or a tree. We discuss both approaches subsequently. 2.2 Receiver-Initiated Protocols Previous work <ref> [17, 18] </ref> characterizes receiver-initiated protocols as placing the responsibility for ensuring reliable packet delivery at each receiver. The critical aspect of these protocols for our taxonomy is that no acks are used. <p> Because receivers communicate naks back to the source, receiver-initiated protocols have the possibility of experiencing a nak-implosion problem at the source if many receivers detect transmission errors. To remedy this problem, previous work on receiver-initiated protocols <ref> [17, 18, 8] </ref> adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown [17, 18, 22] to have better performance than the basic receiver-initiated protocol. <p> To remedy this problem, previous work on receiver-initiated protocols [17, 18, 8] adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown <ref> [17, 18, 22] </ref> to have better performance than the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [17, 18]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> Receiver-initiated with nak-avoidance (RINA) protocols have been shown [17, 18, 22] to have better performance than the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows <ref> [17, 18] </ref>: The sender multicasts all packets and state information, giving priority to retransmissions. Whenever a receiver detects a packet loss, it waits for a random time period and then multicasts a nak to the sender and all other receivers. <p> and can operate with finite memory in the presence of node failures or network partitions. 4 Maximum Throughput Analysis 4.1 Assumptions To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Section 2 can achieve, we use the same model used by Pin-gali et al. <ref> [17, 18] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. Our results clearly show that tree-NAPP protocols constitute the most scalable alternative. 4.2 Sender- and Receiver-Initiated Protocols Following the notation introduced by Pingali et al. <ref> [17, 18] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. The maximum throughput of the protocols for a constant stream of packets to R receivers is [17, 18]: p ln <p> Pingali et al. <ref> [17, 18] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. The maximum throughput of the protocols for a constant stream of packets to R receivers is [17, 18]: p ln R ) (1) pR 1=fl N2 2 O 1 + 1 p (3) Even as the probability of packet loss goes to zero, the throughput of the sender-initiated protocol is inversely dependent on R, the size of the receiver set, because an ack must be sent by <p> have E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] + E [L H1 ] E [X h ]: (5) What we have derived so far is extremely similar to Equations (1) and (2) in the analysis by Pingali et al. <ref> [17, 18] </ref>. In fact, we can use all of their analysis, with the understanding that B is the size of the receiver subset from which the source collects local acks. <p> into Eq. 5, we can rewrite the expected cost at the source node as E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] A Comparison of Reliable Multicast Protocols 9 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [17, 18] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [17, 18] O 1p O (ln R) O (1) Ring-based (unicast retrans.) O 1 + (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p O (1) O (1) Table 1. <p> as E [X H1 ] = E [X f ] + E [M H1 ] E [X p ] A Comparison of Reliable Multicast Protocols 9 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [17, 18] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [17, 18] O 1p O (ln R) O (1) Ring-based (unicast retrans.) O 1 + (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p O (1) O (1) Table 1. <p> Analytical bounds. + E [M H1 ]B (1 p) E [X h ]: (7) Pingali et al. <ref> [17, 18] </ref> have shown that the expected number of transmissions per packet in A, N 1, and N 2 equals E [M ] = m=1 1 1 p (m1) Because in H1 the number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is <p> and N 2 equals E [M ] = m=1 1 1 p (m1) Because in H1 the number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is E [M H1 ] = m=1 1 1 p (m1) which can be simplified to <ref> [17, 18, 19] </ref> E [M H1 ] = i=1 B (1 p i ) Pingali et al. [17, 18] provide a bound of E [M ], that we apply to E [M H1 ] with R = B to obtain E [M H1 ] 2 O 1 + 1 p Using <p> number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is E [M H1 ] = m=1 1 1 p (m1) which can be simplified to [17, 18, 19] E [M H1 ] = i=1 B (1 p i ) Pingali et al. <ref> [17, 18] </ref> provide a bound of E [M ], that we apply to E [M H1 ] with R = B to obtain E [M H1 ] 2 O 1 + 1 p Using Eq. 11, we can bound Eq. 7 as follows E [X H1 ] 2 O B (1 <p> Notice that leaf nodes in theH1 protocol will process fewer retransmissions and thus send fewer acknowledgments than receivers in the A protocol. We can again use an analysis similar to the one by Pingali et al. <ref> [17, 18] </ref> for receivers using a sender initiated protocol. <p> Taking expectations of Eq. 30, + (E [M H1 ]1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E [M r jM r &gt; 2]2) E [Y t ]: (31) It follows from the distribution of M r that <ref> [17, 18] </ref> E [M r jM r &gt; 2] = 1 p Therefore, noting Eq. 32 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 31 the expected cost as E [Y H2 ] = E [M H1 ](1 p) E [Y p ] + E <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] r ] E [Y p ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (51) As shown previously <ref> [17, 18] </ref>, E [M r jM r &gt; 1] = 1 p Substituting Equations 43, 52, and 32 into Eq. 51 we have E [Y R ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + p E [Y p ] p <p> The graph represents the inverse of Equations 19, 36, and 48, respectively, which are the throughputs for the tree-based, tree-NAPP, and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [17, 18] </ref> for sender- and receiver-initiated protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet Fig. 6. The throughput graph from the exact equations for each protocol. The probability of packet loss is 1%, 10%, and 25% respectively. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [17, 18] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [17, 18] </ref> E [X A ] fi fi = A [1] 1 p 3 p : (58) Using Equations 18, 36, 48, and 58, we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] + (E <p> ((4 p) E [M H1 ] 1:9 + 0:1B 1 p R [R] = E [X A ] = E [X A ] 1 + 1 + 1 + (1 p) 1 2 (R 1)p The number of supportable receivers derived for sender and receiver-initiated protocols are shown to be <ref> [17, 18] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] From Figures 6 and 7, it is clear that tree-based protocols can support any number of receivers for the same processor speed bound at each node, and that
Reference: 19. <author> Ramakrishnan, S., and Jain, B. N. </author> <title> A negative acknowledgment with periodic polling protocol for multicast over lan. </title> <booktitle> In Proc. IEEE Infocom (March 1987), </booktitle> <pages> pp. 502-511. </pages>
Reference-contexts: A protocol similar to NETBLT is the "Negative Acknowledgments with Periodic Polling" (NAPP) protocol <ref> [19] </ref>. This protocol is a broadcast protocol for local area networks (LANs). Like NETBLT, NAPP groups together large partitions of the data that are periodically acked, while lost packets within the partition are naked. NAPP advances the cw by naks and periodically advances the mw by acks. <p> Although session messages implement a "polling" function <ref> [19] </ref>, they cannot be used to advance the mw, as in a sender-initiated protocol because a sender specifies its highest sequence number as a source, not the highest sequence number heard from the source. 3 In practice, the persistence of session messages forces the source to process the same number of <p> We define a tree-NAPP protocol as a tree-based protocol that uses nak-avoidance and periodic polling <ref> [19] </ref> in the local groups. Naks alone are not sufficient to guarantee reliability with finite memory, so receivers send a periodic positive local ack to their parents to advance the cw. <p> and N 2 equals E [M ] = m=1 1 1 p (m1) Because in H1 the number of receivers R = B, the expected number of transmissions per packet in the H1 protocol is E [M H1 ] = m=1 1 1 p (m1) which can be simplified to <ref> [17, 18, 19] </ref> E [M H1 ] = i=1 B (1 p i ) Pingali et al. [17, 18] provide a bound of E [M ], that we apply to E [M H1 ] with R = B to obtain E [M H1 ] 2 O 1 + 1 p Using <p> TRP and RMP limit their throughput by requiring retransmissions to be unicast. It would be possible to reduce the cost bound to O (ln R), assuming p to be a constant, if the nak-avoidance techniques presented by Ramakrishnan and Jain <ref> [19] </ref> were used. Our analysis shows that ack trees are a good answer to the scalability problem for reliable multicast-ing.
Reference: 20. <author> Shields, C., and Garcia-Luna-Aceves, J. </author> <title> The ordered core based tree protocol. </title> <note> In IEEE Infocom'97 (April 1997). </note>
Reference-contexts: Each reliable protocol assumes the existence of multi-cast routing trees provided by underlying multicast routing protocols. In the Internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1], Ordered Core Based Trees (OCBT) <ref> [20] </ref>, Protocol Independent Multicast (PIM) [7], or the Multicast Internet Protocol (MIP) [14]. 2.1 Sender-Initiated Protocols In the past [17, 18], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> We make two additional assumptions: (1) no acknowledgments are ever lost, and (2) all loss events at any node in the multicast of a packet are mutually independent. Such multicast routing protocols as CBT, OCBT, PIM, MIP, and DVMRP <ref> [1, 20, 7, 14, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. Our first assumption benefits all classes, but especially favors protocols that multicast acknowledgments.
Reference: 21. <author> Strayer, T., Dempsey, B., and Weaver, A. XTP: </author> <title> The Xpress Transfer Protocol. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: The use of periodic polling limits NAPP to LANs, because the source can still suffer from an ack-implosion problem even if acks occur less often. Other sender-initiated protocols, like the Xpress Transfer Protocol (XTP) <ref> [21] </ref>, were created for use on an internet, but still suffer from the ack-implosion problem. The main limitation of sender-initiated protocols is not that acks are used, but the need for the source to process all of the acks and to know the receiver set.
Reference: 22. <author> Towsley, D., Kurose, J., and Pingal, S. </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast protocols. </title> <journal> IEEE Journal on Selected Areas in Communications 15, </journal> <month> 3 (April </month> <year> 1997), </year> <pages> 398-406. </pages>
Reference-contexts: To address this question, the previous analysis by Pingali et al. <ref> [17, 18, 22] </ref> is extended to consider the maximum throughput of generic ring-based protocols, which organize receivers into a ring, and two classes of tree-based protocols, which organize receivers into acknowledgment trees. These classes are the other three known approaches that can be used to solve the ack-implosion problem. <p> Section 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy. Section 4 extends the analysis by Pingali et al. <ref> [17, 18, 22] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local nak-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Section 6 provides concluding remarks. 2 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [8, 17, 18, 22] </ref> addressing receiver-initiated strategies for reliable mul-ticasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> To remedy this problem, previous work on receiver-initiated protocols [17, 18, 8] adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown <ref> [17, 18, 22] </ref> to have better performance than the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [17, 18]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> The branching factor for trees is set at 10. loss, 1%, 10%, and 25%, respectively. Exact values of E [M H1 ] were calculated using a finite version of Eq. 9; Exact values of E [M ] were similarly calculated <ref> [22] </ref>. The performance of nak-avoidance protocols, especially tree-NAPP protocols, is clearly superior. However, our assumptions place these two sub-classes at an advantage over their base classes. First, we assume that no acknowledgments are lost or are received in error.
Reference: 23. <author> Whetten, B., Kaplan, S., and Montgomery, T. </author> <title> A high performance, totally ordered multicast protocol. </title> <note> In Theory and Practice in Distributed Systems, International Workshop, LNCS 938 (September 1994). </note>
Reference-contexts: One of the first proposals for reliable multicasting is the token ring protocol (TRP) [3]; its aim was to combine the throughput advantages of naks with the reliability of acks. The Reliable Multicast Protocol (RMP) <ref> [23] </ref> discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings. Therefore, RMP has the same throughput bounds as TRP.
Reference: 24. <author> Yavatkar, R., Griffioen, J., and Sudan, M. </author> <title> A reliable dissemination protocol for interactive collaborative applications. </title> <booktitle> In Proc. ACM Multimedia (November 1995), </booktitle> <pages> pp. </pages> <month> 333-44. </month> <title> This article was processed by the author using the L a T E X style file cljour2 from Springer-Verlag. </title>
Reference-contexts: are not used, i.e., if a group leader only waits for all its children to send local acks before advancing the mw , then correct operation after group leaders fail can only be guaranteed by not allowing nodes to delete packets; this is the approach used in all tree-based protocols <ref> [13, 16, 24] </ref> other than lorax [12]. The lorax protocol [12] is the first tree-based protocol to build a single shared ack tree for use by multiple sources in a single session, and to use aggregate acks to ensure correct operation after hosts in the ack tree fail. <p> Note that messages sent for the setting of timers needed for nak-avoidance are limited to the local group, which is scalable. The tree-based multicast transport protocol (TMTP) <ref> [24] </ref> is an example of a tree-NAPP protocol. 2.4 Ring-Based Protocols Ring based protocols for reliable multicast were originally developed to provide support for applications that require an atomic and total ordering of transmissions at all receivers.
References-found: 24

