URL: http://www.cs.columbia.edu/~kar/pubsk/hilog.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: On Negation in HiLog  
Author: Kenneth A. Ross 
Keyword: Logic Programming, Deductive Databases, Negation, Second Order Logic, Domain Independence, Stratification, Magic Sets.  
Date: 1, 1994, pp.27-54  
Note: Journal of Logic Programming, Vol. 18, No.  
Affiliation: Columbia University  
Abstract: fl This research was performed while the author was at Stanford University, and was supported under NSF grant IRI-87-22886, a grant from IBM Corporation, and AFOSR contract 88-0266. A preliminary abstract of this paper appeared at the 1991 ACM Conference on Principles of Database Systems [17]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from being defined recursively in terms of itself through negation <ref> [1, 2, 18] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned. <p> There are many situations in which two truth values, namely true and false, suffice. For normal programs the class of stratified programs is a well-known class of programs with a two-valued semantics <ref> [1, 2, 18] </ref>.
Reference: [2] <author> A. Chandra and D. Harel. </author> <title> Horn clause queries and generalizations. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from being defined recursively in terms of itself through negation <ref> [1, 2, 18] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned. <p> There are many situations in which two truth values, namely true and false, suffice. For normal programs the class of stratified programs is a well-known class of programs with a two-valued semantics <ref> [1, 2, 18] </ref>.
Reference: [3] <author> W. Chen, M. Kifer, and D. S. Warren. HiLog: </author> <title> A first order semantics for higher-order logic programming constructs. </title> <booktitle> In Proc. North American Logic Programming Conference, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction A number of "higher order" logics for programming languages and database systems have been recently proposed. One of these proposals is HiLog <ref> [3, 4] </ref>. HiLog provides a declarative framework for incorporating second order features in logic programming. HiLog has also been chosen by the NAIL! group at Stanford University as the basis for its deductive database system [11]. <p> HiLog allows arbitrary terms to be relation names. Hence, in the formal development, there is no distinction between function, constant and predicate symbols. In rules, variables may appear not only in argument positions, but also in predicate names. In <ref> [3, 4] </ref> the semantics of HiLog is defined, and it is shown that unification is decidable and that resolution is both sound and complete for HiLog. <p> terms is defined according to the rules: * Every symbol is a term, as is every variable. * For each n 0, if t 1 ; ; t n and t are terms then so is t (t 1 ; : : : ; t n ). 1 1 In <ref> [3, 4] </ref> the restriction n 1 is made, excluding 0-ary predicates (but without losing any expressive power). In this paper, we distinguish between variables appearing in predicate names and those appearing in arguments, and so we shall allow 0-ary predicates. <p> 2.1: The following HiLog program implements a generic transitive closure operation commonly needed in database applications. tc (G)(X; Y ) G (X; Y ) One may call the predicate tc (e)(X; Y ) (for some ground term e) to obtain the transitive closure of the e relation. 2 Example 2.2: <ref> [3, 4] </ref> The following HiLog program implements the Lisp-style maplist operation. maplist (F )([]; []) maplist (F )([XjR]; [Y jZ]) F (X; Y ); maplist (F )(R; Z) One calls the predicate maplist (f ) (for some ground term f ), with lists as arguments. maplist (f ) succeeds, possibly binding
Reference: [4] <author> W. Chen, M. Kifer, and D. S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> Journal of Logic Programming, </journal> <note> 1992. to appear. </note>
Reference-contexts: 1 Introduction A number of "higher order" logics for programming languages and database systems have been recently proposed. One of these proposals is HiLog <ref> [3, 4] </ref>. HiLog provides a declarative framework for incorporating second order features in logic programming. HiLog has also been chosen by the NAIL! group at Stanford University as the basis for its deductive database system [11]. <p> HiLog allows arbitrary terms to be relation names. Hence, in the formal development, there is no distinction between function, constant and predicate symbols. In rules, variables may appear not only in argument positions, but also in predicate names. In <ref> [3, 4] </ref> the semantics of HiLog is defined, and it is shown that unification is decidable and that resolution is both sound and complete for HiLog. <p> terms is defined according to the rules: * Every symbol is a term, as is every variable. * For each n 0, if t 1 ; ; t n and t are terms then so is t (t 1 ; : : : ; t n ). 1 1 In <ref> [3, 4] </ref> the restriction n 1 is made, excluding 0-ary predicates (but without losing any expressive power). In this paper, we distinguish between variables appearing in predicate names and those appearing in arguments, and so we shall allow 0-ary predicates. <p> 2.1: The following HiLog program implements a generic transitive closure operation commonly needed in database applications. tc (G)(X; Y ) G (X; Y ) One may call the predicate tc (e)(X; Y ) (for some ground term e) to obtain the transitive closure of the e relation. 2 Example 2.2: <ref> [3, 4] </ref> The following HiLog program implements the Lisp-style maplist operation. maplist (F )([]; []) maplist (F )([XjR]; [Y jZ]) F (X; Y ); maplist (F )(R; Z) One calls the predicate maplist (f ) (for some ground term f ), with lists as arguments. maplist (f ) succeeds, possibly binding <p> To understand the semantics of HiLog one can imagine transforming a HiLog program into a normal program having a generic unary predicate name call and generic functions u i of each arity i. For details of this universal relation transformation the reader is referred to <ref> [4] </ref>, where u i is called apply i .
Reference: [5] <author> R. A. DiPaola. </author> <title> The recursive unsolvability of the decision problem for the class of definite formulas. </title> <journal> JACM, </journal> <volume> 16(2):p.324, </volume> <year> 1969. </year>
Reference-contexts: For example if P is the range-restricted program X (a) X (X); :X (a) and Q contains the single fact r (r), then P [ Q has no stable model even though each of P and Q have stable models. Since domain independence is undecidable for normal programs <ref> [5] </ref> it follows that preservation under extensions for HiLog programs is also undecidable.
Reference: [6] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: This observation led to the development of the well-founded semantics [19] and the stable-model semantics <ref> [6] </ref> which provide an intuitive semantics for logic programs that are not necessarily stratified. In general the well-founded semantics is three-valued: an atom may be true, false, or undefined. Nevertheless, the well-founded semantics is well defined for all programs. <p> Since u is neither true nor false in I 3 , it is considered undefined. 2 3.2 The Stable Model Semantics Rather than give the original definition from <ref> [6] </ref> of what constitutes a stable model of a program, we present a formulation that is shown to be equivalent in [19]. Definition 3.6: Let P be a normal program.
Reference: [7] <author> D. Kemp, P. Stuckey, and D. Srivastava. </author> <title> Query restricted bottom-up evaluation of normal logic programs. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 288-302, </pages> <year> 1992. </year>
Reference-contexts: For a detailed discussion of this point on normal programs, see [16]. Subsequent to [16], several other magic-set procedures have been proposed for normal programs <ref> [7, 9, 15] </ref>. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is not guaranteed to terminate for programs with recursively applied function symbols.
Reference: [8] <author> P. G. Kolaitis. </author> <title> The expressive power of stratified programs. </title> <journal> Information and Computation, </journal> <volume> 90 </volume> <pages> 50-66, </pages> <year> 1991. </year> <month> 26 </month>
Reference-contexts: call (u 2 (p; X)) call (u 2 (q; X)); :call (u 2 (r; X)): 5 In general U can be any fixed universe that includes the Herbrand universe of the whole program. 6 In fact, Kolaitis has shown that there is no stratified program that can express this game <ref> [8] </ref>. 17 Similarly, strongly connected components used in the definition of modular stratification are merged under the universal relation model, and so the level at which predicates are used is lost in the universal version of the program.
Reference: [9] <author> S. Morishita. </author> <title> An alternating fixpoint tailored to magic programs. </title> <booktitle> In Proceedings of the Workshop on Deductive Databases, Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: For a detailed discussion of this point on normal programs, see [16]. Subsequent to [16], several other magic-set procedures have been proposed for normal programs <ref> [7, 9, 15] </ref>. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is not guaranteed to terminate for programs with recursively applied function symbols.
Reference: [10] <author> J.-M. Nicolas. </author> <title> Logic for improving integrity checking in relational databases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: However, there does exist a large class of normal programs for which the HiLog semantics and the normal semantics coincide, namely the class of range restricted programs. Range restricted programs are guaranteed to be domain independent for normal programs <ref> [10] </ref>.
Reference: [11] <author> G. Phipps, M. Derr, and K. A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: One of these proposals is HiLog [3, 4]. HiLog provides a declarative framework for incorporating second order features in logic programming. HiLog has also been chosen by the NAIL! group at Stanford University as the basis for its deductive database system <ref> [11] </ref>. A distinguishing feature of HiLog is that it has a "first order semantics" even though its syntax is second order. The crucial feature that reduces the semantics to first order is that nested relations are modeled by having relation names as arguments rather than the relations themselves as arguments.
Reference: [12] <author> H. Przymusinska and T. C. Przymusinski. </author> <title> Weakly stratified logic programs. </title> <journal> Fundamenta Informaticae, </journal> <volume> 13 </volume> <pages> 51-65, </pages> <year> 1990. </year> <note> Preliminary version appeared in Proc. Fifth International Conference and Symposium on Logic Programming, </note> <year> 1988. </year>
Reference-contexts: Hence the program is not modularly stratified, even though it has a two-valued well-founded semantics, in which p (b) is true and p (a) is false. 2 One may wonder why one should disallow programs like those of Example 6.4. An extension of the notion of weak stratification <ref> [12] </ref> might allow such a program, since it defines components based on ground atoms rather than predicates. The main reason is that the magic sets technique we discuss in Section 6.1 does not work when applied to programs like that of Example 6.4.
Reference: [13] <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: of the program * the predicate in the head has greater level than every predicate appearing negatively in the body, and * the predicate in the head has at least as great a level as every predicate appearing positively in the body. 2 Stratification can be generalized to "local stratification" <ref> [13] </ref>.
Reference: [14] <author> T. C. Przymusinski. </author> <title> On the declarative and procedural semantics of logic programs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 167-205, </pages> <year> 1989. </year>
Reference-contexts: Adding an unrelated fact such as r (b) would change the answer to the query ? p by supplying an additional constant to the vocabulary. This issue is related to the universal query problem discussed in <ref> [14, 19] </ref>. One solution is to augment the program with extra function and constant symbols so that this problem does not occur [19]. 9 must be some positive subgoal with a non-normal argument in r.
Reference: [15] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 273-287, </pages> <year> 1992. </year>
Reference-contexts: For a detailed discussion of this point on normal programs, see [16]. Subsequent to [16], several other magic-set procedures have been proposed for normal programs <ref> [7, 9, 15] </ref>. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is not guaranteed to terminate for programs with recursively applied function symbols.
Reference: [16] <author> K. A. Ross. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year> <note> Full version submitted for journal publication. </note>
Reference-contexts: Stratification is such a condition, although not the most general. In any case, with variables in predicate names defining levels on predicates can be problematic. Recently, Ross <ref> [16] </ref> has described the class of "modularly stratified programs" which ensure a two-valued semantics while allowing a broader class of programs than just the stratified ones. <p> We generalize the techniques of <ref> [16] </ref> to obtain a magic sets method for modularly stratified HiLog programs. This rewriting method allows the efficient evaluation of queries over a large class of HiLog programs. HiLog has applications in logic programming where, for example, it provides a declarative way to represent the call meta-predicate of Prolog. <p> in every Herbrand instantiated rule of the program * the atom in the head has greater level than every atom appearing negated in the body, and * the atom in the head has at least as great a level as every atom appearing positively in the body. 2 Recently, Ross <ref> [16] </ref> has defined the class of "modularly stratified programs," and shown that the well-founded semantics (and hence also the stable model semantics) are two-valued for this class of normal programs. Modular stratification was used there as a basis for defining a magic-sets transformation to evaluate normal programs with negation. <p> As in <ref> [16] </ref>, one can extend the idea of modular stratification to operators such as aggregation that have traditionally been stratified to avoid semantic difficulties. <p> This is the aggregate analog of modular stratification. By using HiLog rather than normal programs, we can write a solution to the parts-explosion problem once, rather than once for each particular part relation. 6.1 Magic Sets In <ref> [16] </ref>, modular stratification was used as a basis for defining a magic sets transformation for range-restricted programs. We can use the same observations to define a similar magic sets transformation for strongly range-restricted programs that are modularly stratified for HiLog. <p> We can use the same observations to define a similar magic sets transformation for strongly range-restricted programs that are modularly stratified for HiLog. We do not have space to present a full description of the method. We assume some familiarity with <ref> [16] </ref>, and describe only the differences here. Firstly, we require that a program satisfies an analog of "modular stratification from left to right." The appropriate refinement of modular stratification for HiLog is in the construction of the graph G described in Figure 1. <p> ) dn 0 (Q) magic (Q; ); Q dn 0 (Q) magic (Q; ); 2Q 2P magic (P; ); 8Q (dn (P; Q) ) dn 0 (Q)); ~ P These rules, together with some rewritten rules for m and g, can be executed bottom-up (in a particular order) as in <ref> [16] </ref>. <p> In order to be able to handle rules like the one for p (a) above, one would need a more general, nonsequential method for maintaining negative dependencies, that would be less efficient in general. For a detailed discussion of this point on normal programs, see <ref> [16] </ref>. Subsequent to [16], several other magic-set procedures have been proposed for normal programs [7, 9, 15]. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is <p> In order to be able to handle rules like the one for p (a) above, one would need a more general, nonsequential method for maintaining negative dependencies, that would be less efficient in general. For a detailed discussion of this point on normal programs, see <ref> [16] </ref>. Subsequent to [16], several other magic-set procedures have been proposed for normal programs [7, 9, 15]. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is not guaranteed to <p> For a detailed discussion of this point on normal programs, see <ref> [16] </ref>. Subsequent to [16], several other magic-set procedures have been proposed for normal programs [7, 9, 15]. Extending these techniques to HiLog programs is an interesting direction for future research. While the transformation of [16] is well-defined for all range-restricted, modularly stratified normal programs, the evaluation of the transformed program is not guaranteed to terminate for programs with recursively applied function symbols. For Datalog programs, though, termination is guaranteed. <p> We have considered conditions under which the well-founded semantics is guaranteed to be two-valued, and have generalized modular stratification to HiLog programs. Using this extension, we have described a generalization of the magic sets method of Ross <ref> [16] </ref> to modularly stratified HiLog programs.
Reference: [17] <author> K. A. Ross. </author> <title> On negation in HiLog. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference: [18] <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1989. </year> <note> Preliminary versions appeared in Third IEEE Symp. on Logic Programming (1986), and Foundations of Deductive Databases and Logic Programming, </note> <editor> J. Minker, ed., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from being defined recursively in terms of itself through negation <ref> [1, 2, 18] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned. <p> There are many situations in which two truth values, namely true and false, suffice. For normal programs the class of stratified programs is a well-known class of programs with a two-valued semantics <ref> [1, 2, 18] </ref>.
Reference: [19] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year> <month> 27 </month>
Reference-contexts: A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned. This observation led to the development of the well-founded semantics <ref> [19] </ref> and the stable-model semantics [6] which provide an intuitive semantics for logic programs that are not necessarily stratified. In general the well-founded semantics is three-valued: an atom may be true, false, or undefined. Nevertheless, the well-founded semantics is well defined for all programs. <p> It is not important whether I 0 is true for predicates not constructible from the symbols in I. 2 3 Semantics for Normal Programs 3.1 The Well-Founded Semantics In this section we briefly review the definition of the well-founded semantics for normal programs, from <ref> [19] </ref>. For this section only, terms such as "Herbrand universe" and "literal" refer to normal program definitions. Definition 3.1: Let S be a set of literals. <p> Since u is neither true nor false in I 3 , it is considered undefined. 2 3.2 The Stable Model Semantics Rather than give the original definition from [6] of what constitutes a stable model of a program, we present a formulation that is shown to be equivalent in <ref> [19] </ref>. Definition 3.6: Let P be a normal program. A stable model of P is a two-valued fixpoint of W P , as defined in Definition 3.5. 2 2 For a justification that it is a partial model see [19]. 7 As can easily be seen from this definition, if the <p> we present a formulation that is shown to be equivalent in <ref> [19] </ref>. Definition 3.6: Let P be a normal program. A stable model of P is a two-valued fixpoint of W P , as defined in Definition 3.5. 2 2 For a justification that it is a partial model see [19]. 7 As can easily be seen from this definition, if the well-founded model is two-valued, then that model is the unique stable model. (For examples of programs with unique stable models, but a three-valued well-founded model, see [19].) While Gelfond and Lifschitz consider that only programs with a unique stable <p> 2 2 For a justification that it is a partial model see <ref> [19] </ref>. 7 As can easily be seen from this definition, if the well-founded model is two-valued, then that model is the unique stable model. (For examples of programs with unique stable models, but a three-valued well-founded model, see [19].) While Gelfond and Lifschitz consider that only programs with a unique stable model have a well-defined semantics, we take the slightly more general view that the semantics of a program is given by the set of its stable models. <p> Adding an unrelated fact such as r (b) would change the answer to the query ? p by supplying an additional constant to the vocabulary. This issue is related to the universal query problem discussed in <ref> [14, 19] </ref>. One solution is to augment the program with extra function and constant symbols so that this problem does not occur [19]. 9 must be some positive subgoal with a non-normal argument in r. <p> This issue is related to the universal query problem discussed in [14, 19]. One solution is to augment the program with extra function and constant symbols so that this problem does not occur <ref> [19] </ref>. 9 must be some positive subgoal with a non-normal argument in r. Since that positive subgoal must be false by the above reasoning, instantiated rules with non-normal terms will not contribute to the well-founded model.
References-found: 19

