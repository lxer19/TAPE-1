URL: http://www.ite.mh.se/~justin/traceability.ps
Refering-URL: http://www.csd.uu.se/~justin/index.html
Root-URL: 
Email: Egham  justin@dcs.rhbnc.ac.uk  
Phone: Tel. +44 (0) 1784 443426  
Title: Requirements, Traceability and Formal Software Development or a Further Analysis of Requirements Traceability  
Author: Justin K. Pearson 
Note: The work described here forms part of the DATUM project (grant GR/H8994, project number IED4/19314) in the UK Safety Critical Systems Research programme supported by the EPSRC and DTI.  
Date: October 1, 1996  
Address: London  mail:  
Affiliation: Computer Science Department Royal Holloway University of  e  
Pubnum: Surrey TW20 0EX  
Abstract: This paper is concerned with the interaction between formal software development and the issue of requirements traceability. The paper offers an analysis of the requirements traceability problem (see [1]) which takes into account software development using formal methods. Starting from the observation that formal software development is not an infallible method of producing error free and `correct' code (see [2]); sources of error identified as in [3] are used to motivate a new analysis of the requirements traceability problem. Traceability is divided into: Pre-Requirements Specification, Pre-Formal Requirements Specification and Post-Formal Requirements traceability, a finer distinction than is made by Gotel and Finkelstein in [1]. This distinction is motivated by the problems associated with the process of formalizing a prose requirements specification document together with an 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Orlena C.Z. Gotel and Anthony C.W. Finkelstein. </author> <title> An analysis of the requirements traceability problem. </title> <booktitle> In Proceedings of the IEEE International Conference on Requirements Engineering (ICRE '94), </booktitle> <pages> pages 94-101, </pages> <address> Colorado Springs, Colorado, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: This process of feedback led to further refinements and revisions of the specifications. For a more detailed discussion, see Section IV of [22]. 4 Requirements Traceability The following definition is presented in <ref> [1] </ref>: Requirements traceability refers to the ability to describe and follow the life of a requirement, in both the forward and back <p>- 5 wards direction (i.e. from its origins, through its development and specification, to its subsequent deployment and use, and through periods of on-going refinement and iteration in any <p> After much empirical data gathering and analysis Gotel and Finkelstein <ref> [1, 5] </ref> refined RT into Pre-Requirements traceability and Post-Requirements traceability, again from [1]: Pre-requirements specification (pre-RS) traceability, which is concerned with those aspects of a requirement's life prior to its inclusion in the RS (requirement production) Post-requirements specification (post-RS) traceability, which is concerned with those aspects of a requirement's life that <p> After much empirical data gathering and analysis Gotel and Finkelstein [1, 5] refined RT into Pre-Requirements traceability and Post-Requirements traceability, again from <ref> [1] </ref>: Pre-requirements specification (pre-RS) traceability, which is concerned with those aspects of a requirement's life prior to its inclusion in the RS (requirement production) Post-requirements specification (post-RS) traceability, which is concerned with those aspects of a requirement's life that result from its inclusion in the RS (requirement deployment). <p> This will be elucidated in section 5. Central to understanding the issue of traceability in formal software development is a refining of the Pre-RS and Post-RS traceability definitions from <ref> [1] </ref>, to take into account the production of a formal requirements specification document. <p> Again this stage should involve consultation with the customer to refine, understand the user requirements and to uncover any possible inconsistencies. Finally in the Post-FRS stage the FRS-document is used to refine or guide development of code. The analysis offered here, in the terminology of <ref> [1] </ref> is information driven: traceability is defined in terms of what information is to be made traceable, with special reference to the differences between Formal Software Engineering and traditional Software Engineering. 5 Use and Abuse of Formal Methods and Re <p>- quirements Traceability There are many sources of potential error in <p> For example communication between developers and management, can result in needless errors being introduced. Not all of the problems above are restricted to formal software development. Most importantly the communication aspects between the developer and the user in the requirements acquisition stage, is one of the aspects treated in <ref> [1] </ref> in their analysis of the Pre-RS traceability problem. Both knowledge and communication based uncertainties affect Pre-FRS and Post-FRS traceability. First, with knowledge based uncertainties, lack of knowledge in the problem domain will affect Pre-FRS traceability requirements. <p> Making the quality process as painless 15 as possible and as paperless as possible is an important goal to be pursued for the success of any quality development procedures. Gotel and Finkelstein <ref> [1] </ref> divide the available tool support into four areas: General purpose traceability tools, such as hypertext editors, word processors or databases; special purpose tools, such as tools designed for requirements engineering such as RTM of Marconi, which provide some support for requirements traceability; workbenches i.e. integrated tool support to cover many
Reference: [2] <author> S. Gerhart and Yelowitz L. </author> <title> Observations of fallibility in applications of modern programming methodologies. </title> <journal> IEEE Transactions in Software Engineering, </journal> <volume> SE-2(3):195-207, </volume> <year> 1976. </year>
Reference-contexts: 1 Introduction The formal methods community has for a long time recognized that it is naive to assume that given a formal specification, a fully working and correct program will appear solely by the use of formal methods. Perhaps the earliest example is the paper <ref> [2] </ref> concerning the way incorrect programs can be derived from incorrect or incomplete specifications. The observations in [2] arose from an exercise given to students, where the authors specified that a sorting program should be produced from a formal specification, but the specification omitted to include that the final sorted list <p> Perhaps the earliest example is the paper <ref> [2] </ref> concerning the way incorrect programs can be derived from incorrect or incomplete specifications. The observations in [2] arose from an exercise given to students, where the authors specified that a sorting program should be produced from a formal specification, but the specification omitted to include that the final sorted list must be a permutation of the original only that it is an ordered list.
Reference: [3] <author> Shaoying Liu, Victoria Stavridou, and Bruno Dutertre. </author> <title> Formal methods and dependability assessment. </title> <booktitle> In Proceedings of Compass 94, </booktitle> <address> Wasington DC, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: While this work does not have the empirical backing of [4, 5] it offers a theoretical contribution based on the analysis of fallibility of formal methods as in <ref> [3] </ref> of what sort of data and problems constitute RT for formal software development. <p> This paper assumes some familiarity with how formal methods might be applied, but no detailed knowledge is required of any particular formal method or technique (for an introduction see <ref> [3] </ref> or [14]). 3 Requirements Engineering This section is intended only as a short introduction to Requirements Engi- neering (for a more detailed introduction see [15, 16]). A significant proportion of software development is usually done for other parties. <p> Many other sources of error can be identified. Recent papers that address the issue of possible errors in software development include <ref> [23, 24, 25, 3] </ref>. <p> Many other sources of error can be identified. Recent papers that address the issue of possible errors in software development include [23, 24, 25, 3]. I will concentrate on the sources of uncertainty identified in <ref> [3] </ref>, and try to show how attention to such sources leads to a finer analysis of RT. [3] identifies several classes of uncertainty in the use of formal methods: human ability, physical model, consistency of theories, tool quality and availability, process maturity, management pressure, and notation quality. <p> Recent papers that address the issue of possible errors in software development include [23, 24, 25, 3]. I will concentrate on the sources of uncertainty identified in <ref> [3] </ref>, and try to show how attention to such sources leads to a finer analysis of RT. [3] identifies several classes of uncertainty in the use of formal methods: human ability, physical model, consistency of theories, tool quality and availability, process maturity, management pressure, and notation quality. The 7 following subsections summarize and expand Section 5 of [3] with a view as to how various sources of error <p> to such sources leads to a finer analysis of RT. <ref> [3] </ref> identifies several classes of uncertainty in the use of formal methods: human ability, physical model, consistency of theories, tool quality and availability, process maturity, management pressure, and notation quality. The 7 following subsections summarize and expand Section 5 of [3] with a view as to how various sources of error contribute to the analysis of requirements traceability. <p> One management issue that would have to be addressed include the management of RT data over distributed environments. But many (if not most) of the management issues are not primarily problems with formal software development and would have to be addressed in any project employing RT. <ref> [3] </ref> talks about the problem of software process maturity with respect to the use of formal methods. Most individual formal methods at present do not cover the complete spectrum of the software development process. Integration with other techniques is often haphazard, (for an exception see [18]). <p> traceability of requirements is an attempt to enable the developer to understand how the quality and maturity of a particular formal method and associated tools affects the whole development process. 5.1 Human Ability Software Engineering involves, at least to some degree, human beings, who are for the most part fallible. <ref> [3] </ref> rightly observes that the use of formal methods typically, at present, involves more human effort than traditional software engineering. Typically that is because formal methods force such a detailed level of analysis, so that many assumptions which would go unchallenged in traditional development have to be addressed. <p> A further problem is that many software engineers are untrained in the sort of discrete mathematics 8 needed for the effective use of formal methods. Therefore, the understanding of human ability is important in assessing the role of traceability in both formal and non-formal software development. 4 <ref> [3] </ref> identifies two sets of uncertainties related to human ability, knowledge and communication. <p> This is part of a wider problem, that the process of producing software using formal methods is still not as well understood as traditional software engineering processes. <ref> [3] </ref> divides communication, again into three aspects: (i) Communication between the user and the developer may not be accurate, leading them to misunderstand each other during the acquisition of requirements. <p> This paper has given a further analysis of RT, refining the work of Gotel and Finkelstein [4, 5]. The analysis has been driven by potential sources of error in formal software development as identified in <ref> [3] </ref>. This analysis is merely a start it is intended to be both a contribution to the formal software development community and to requirements traceability. The use of traceability in formal software development will hopefully contribute to the validation and management of large projects.
Reference: [4] <author> Orlena C.Z. Gotel and Anthony C.W. Finkelstein. </author> <title> Modelling the contri-bution structure underlying requirements. </title> <booktitle> In Proceedings of the First International Workshop on Requirements Engineering: Foudation of Software Quality (REFSQ '94), </booktitle> <pages> pages 71-81, </pages> <address> Utrecht, The Netherlands, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Requirements traceability (RT) is the ability to trace user requirements through the development process, from the requirements elicitation stage through to the final software product. The work of Finkelstein and Go- tel in <ref> [4, 5] </ref> gives analysis of requirements traceability starting with empirical research through interviews, discussion and focus groups with practitioners in industry. It was found although people felt the need for requirement traceability they felt that there was a problem with what exactly constituted requirements traceability. <p> The diagnosis offered by Finkel- stein and Gotel was that there are two phases of requirements traceability, Pre-Requirements specification (Pre-RS) and Post-requirements specification (Post-RS)traceability (to be defined below) and that the essential problem lay in the Pre-requirements specification phase. This paper builds on the analysis of <ref> [4, 5] </ref> and offers a further refinement of RT, when formal methods are used in development, into Pre-RS, Pre-Formal requirements specification and Post-Formal requirements specification. While this work does not have the empirical backing of [4, 5] it offers a theoretical contribution based on the analysis of fallibility of formal methods <p> This paper builds on the analysis of <ref> [4, 5] </ref> and offers a further refinement of RT, when formal methods are used in development, into Pre-RS, Pre-Formal requirements specification and Post-Formal requirements specification. While this work does not have the empirical backing of [4, 5] it offers a theoretical contribution based on the analysis of fallibility of formal methods as in [3] of what sort of data and problems constitute RT for formal software development. <p> Further traceability in general allows the developer to cope with and understand the demands of changing user requirements during the project. However there is little empirical evidence that the use of quality oriented techniques in software development will lead to more reliable software. Gotel and Finkelstein <ref> [4] </ref> discuss why quality methods have not led to the dramatic improvement in software quality that might have been expected. <p> Further, because the use of formal methods does not cover the whole of the software development life cycle, it seems that integration of available tools in workbenches and environments is desirable. Gotel and Finkelstein <ref> [4] </ref> discuss the relation between modeling the artifacts used in the requirements engineering process (such as programs, pieces of paper, faxes etc.) and databases of personnel and groups involved in the design process. <p> This whole framework would to be codified in an open structure so that tool builders can easily hook into a standard traceability environment. This paper has given a further analysis of RT, refining the work of Gotel and Finkelstein <ref> [4, 5] </ref>. The analysis has been driven by potential sources of error in formal software development as identified in [3]. This analysis is merely a start it is intended to be both a contribution to the formal software development community and to requirements traceability.
Reference: [5] <author> Orlena Cara Zena Gotel. </author> <title> Contribution Structures for Requirements Traceability. </title> <type> PhD thesis, </type> <institution> University of London, Imperial College, </institution> <year> 1995. </year>
Reference-contexts: Requirements traceability (RT) is the ability to trace user requirements through the development process, from the requirements elicitation stage through to the final software product. The work of Finkelstein and Go- tel in <ref> [4, 5] </ref> gives analysis of requirements traceability starting with empirical research through interviews, discussion and focus groups with practitioners in industry. It was found although people felt the need for requirement traceability they felt that there was a problem with what exactly constituted requirements traceability. <p> The diagnosis offered by Finkel- stein and Gotel was that there are two phases of requirements traceability, Pre-Requirements specification (Pre-RS) and Post-requirements specification (Post-RS)traceability (to be defined below) and that the essential problem lay in the Pre-requirements specification phase. This paper builds on the analysis of <ref> [4, 5] </ref> and offers a further refinement of RT, when formal methods are used in development, into Pre-RS, Pre-Formal requirements specification and Post-Formal requirements specification. While this work does not have the empirical backing of [4, 5] it offers a theoretical contribution based on the analysis of fallibility of formal methods <p> This paper builds on the analysis of <ref> [4, 5] </ref> and offers a further refinement of RT, when formal methods are used in development, into Pre-RS, Pre-Formal requirements specification and Post-Formal requirements specification. While this work does not have the empirical backing of [4, 5] it offers a theoretical contribution based on the analysis of fallibility of formal methods as in [3] of what sort of data and problems constitute RT for formal software development. <p> After much empirical data gathering and analysis Gotel and Finkelstein <ref> [1, 5] </ref> refined RT into Pre-Requirements traceability and Post-Requirements traceability, again from [1]: Pre-requirements specification (pre-RS) traceability, which is concerned with those aspects of a requirement's life prior to its inclusion in the RS (requirement production) Post-requirements specification (post-RS) traceability, which is concerned with those aspects of a requirement's life that <p> This whole framework would to be codified in an open structure so that tool builders can easily hook into a standard traceability environment. This paper has given a further analysis of RT, refining the work of Gotel and Finkelstein <ref> [4, 5] </ref>. The analysis has been driven by potential sources of error in formal software development as identified in [3]. This analysis is merely a start it is intended to be both a contribution to the formal software development community and to requirements traceability.
Reference: [6] <author> L.M. Barroca and J.A. McDermid. </author> <title> Formal methods: Use and relevance for the development of saftey-critical systems. </title> <journal> The Computer Journal, </journal> <volume> 35(6) </volume> <pages> 579-599, </pages> <year> 1992. </year>
Reference-contexts: 3 and 4 gives an introduction to Gotel and Finkelstein's work on requirements traceability, section 5 is the main body of the paper which refines the classification of Requirements traceability 2 to take into account formal methods, last there is a conclusion. 2 Formal Methods As with Barroca and McDermid <ref> [6] </ref> the term `formal methods' is used here to refer to methods which have a sound basis in mathematics. Which in terms of software development means that programs, environments and specifications are, or in principle, treated as mathematical entities.
Reference: [7] <author> Kevin Lano. </author> <title> The B Language and Method: A Guide to Practical Formal Development. </title> <publisher> FACIT. Springer Verlag, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: The treatment as mathematical entities allows transformations to be carried out which preserve the behavior and meaning of programs. Programs can be checked against specifications and can be shown to meet or fail to meet specifications. Examples of such methods include B <ref> [7] </ref> or VDM [8]. A distinction can be made between formal methods and rigorous methods.
Reference: [8] <author> C. Jones. </author> <title> Systematic Software Development using VDM. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: The treatment as mathematical entities allows transformations to be carried out which preserve the behavior and meaning of programs. Programs can be checked against specifications and can be shown to meet or fail to meet specifications. Examples of such methods include B [7] or VDM <ref> [8] </ref>. A distinction can be made between formal methods and rigorous methods. <p> Worse still many of the theorems purported to be proved are actually false. 2 Judging from the Principia experience fully formal techniques are only practicable when there is adequate machine assistance. Thus the use of rigorous methods, such as advocated by the VDM community (see <ref> [8] </ref>), is appealing, or is said to be appealing, because of lower development costs but mistakes can be made, e.g. steps in proofs such as "it is obvious that P " can be wrong and often are. <p> In some cases it is desirable, or perhaps it is forced by contractual reasons, to have a RS-document expressed in a formal notation (such as Z [19], or VDM <ref> [8] </ref>). Such a document from now on will be referred so as a Formal Requirements Specification document (a FRS-document).
Reference: [9] <author> Edmund Landau. </author> <title> Grundlagen der Analysis. </title> <address> Akademische Verlagsgesellschaft, Leipzig, Germany, </address> <year> 1930. </year> <title> English translation Foundations of Analysis, </title> <publisher> Chelsea Publishing Company, </publisher> <year> 1951. </year> <month> 17 </month>
Reference-contexts: An example, highlighting the difference between rigorous and formal mathematics, is the formalization of Landau's <ref> [9] </ref> analysis text book in the AUTOMATH 1 system of N.G. de Bruijn [10] (see [11]).
Reference: [10] <author> N.G. de Bruijn. </author> <title> The mathematical language AUTOMATH, its usage, and some of its extensions. </title> <editor> In M. Laudet, editor, </editor> <booktitle> Proceedings of the Symposium on Automatic Demonstration, </booktitle> <pages> pages 29-61, </pages> <address> Versailles, France, </address> <month> December </month> <year> 1968. </year> <note> Springer-Verlag LNM 125. </note>
Reference-contexts: An example, highlighting the difference between rigorous and formal mathematics, is the formalization of Landau's [9] analysis text book in the AUTOMATH 1 system of N.G. de Bruijn <ref> [10] </ref> (see [11]). Landau's text book was already of a much higher degree of rigour than would normally be expected in standard mathematical texts, but when the book was formalized in AUTOMATH, its length was increased ten fold.
Reference: [11] <editor> L.S. van Benthem Jutting. </editor> <title> Checking Landau's "Grundlagen" in the AUTOMATH System. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1977. </year>
Reference-contexts: An example, highlighting the difference between rigorous and formal mathematics, is the formalization of Landau's [9] analysis text book in the AUTOMATH 1 system of N.G. de Bruijn [10] (see <ref> [11] </ref>). Landau's text book was already of a much higher degree of rigour than would normally be expected in standard mathematical texts, but when the book was formalized in AUTOMATH, its length was increased ten fold.
Reference: [12] <author> B. </author> <title> Russell and A.N. Whitehead. Principia mathematica. </title> <publisher> Cambridge University Press, </publisher> <pages> 1910-13. </pages>
Reference-contexts: Landau's text book was already of a much higher degree of rigour than would normally be expected in standard mathematical texts, but when the book was formalized in AUTOMATH, its length was increased ten fold. A historical example, the Principia Mathematica of Russell and Whitehead <ref> [12] </ref>, which attempted to formalize the whole of mathematics, in terms of first order logic, this work took over 500 pages to assert that 1 + 1 = 2. Also because of the length and complexity of the proofs, Principia Mathematica is full of mistakes.
Reference: [13] <author> J. Rushby and P. Lincoln. </author> <title> A formally verified algorithm for interac-tive consistency under a hybrid fault model. </title> <type> Technical Report CSL-9302, </type> <institution> SRI International Computer Science Laboratory, </institution> <month> March </month> <year> 1993. </year> <note> Also available as NASA Contractor Report 4527, </note> <month> July </month> <year> 1993. </year>
Reference-contexts: When the set theorist looked through the later volumes of the Principia (which deals with higher cardinals) he found to his surprise many of the theorems false. 3 in the machine assisted formal system PVS and the subsequent errors found in formalization see <ref> [13] </ref>. The comments in this paper apply equally well to rigorous and formal methods. Because machine assistance is not feasible for rigorous proofs the possibility of error is greater.
Reference: [14] <author> Doanld Sannela. </author> <title> A survey of formal software development methods. </title> <editor> In A. McGettrick and R. Thayer, editors, </editor> <booktitle> Software Engineering: A European Prospective, </booktitle> <pages> pages 281-297. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper assumes some familiarity with how formal methods might be applied, but no detailed knowledge is required of any particular formal method or technique (for an introduction see [3] or <ref> [14] </ref>). 3 Requirements Engineering This section is intended only as a short introduction to Requirements Engi- neering (for a more detailed introduction see [15, 16]). A significant proportion of software development is usually done for other parties. <p> The resulting code would be in general non-deterministic. This could be a perfectly formally correct refinement, but inappropriate for the user requirements (see section 3 of <ref> [14] </ref> for a discussion of refinement in formal software development methods). (iii) Lack of Knowledge in the management domain. For example communication between developers and management, can result in needless errors being introduced. Not all of the problems above are restricted to formal software development.
Reference: [15] <author> Roger S Pressman. </author> <title> Software engineering : a practitioner's approach. </title> <address> New York : McGraw-Hill, </address> <year> 1987. </year>
Reference-contexts: familiarity with how formal methods might be applied, but no detailed knowledge is required of any particular formal method or technique (for an introduction see [3] or [14]). 3 Requirements Engineering This section is intended only as a short introduction to Requirements Engi- neering (for a more detailed introduction see <ref> [15, 16] </ref>). A significant proportion of software development is usually done for other parties. To be able to write such software the developer must find out what the customer wants the program to do. The process of finding out what the customer wants is called Requirements Engineering.
Reference: [16] <author> Hubert F. Hofman. </author> <title> Requirements engineering. </title> <type> Technical report, </type> <institution> Institut fur Informatik der Universitat Zurich, </institution> <address> Marz 93. </address>
Reference-contexts: familiarity with how formal methods might be applied, but no detailed knowledge is required of any particular formal method or technique (for an introduction see [3] or [14]). 3 Requirements Engineering This section is intended only as a short introduction to Requirements Engi- neering (for a more detailed introduction see <ref> [15, 16] </ref>). A significant proportion of software development is usually done for other parties. To be able to write such software the developer must find out what the customer wants the program to do. The process of finding out what the customer wants is called Requirements Engineering.
Reference: [17] <author> Anthony Finkelstein and Jeff Kramer. TARA: </author> <title> Tool assisted requireements analysis. </title> <editor> In P Loucopoulos and R. Zicari, editors, </editor> <title> Conceptual Modelling, Databases and CASE: </title> <booktitle> an intergrated view of information sys-tems development, </booktitle> <pages> pages 413-432. </pages> <publisher> John Wiley, </publisher> <year> 1991. </year>
Reference-contexts: Such a document from now on will be referred so as a Formal Requirements Specification document (a FRS-document). The process of obtaining a formal requirements document 3 In some requirements capture methods such as CORE <ref> [17] </ref> there is no provision for the recording of complicated functional requirements between data items. Often these functional requirements are specified in high level languages, which can force data representation at an early stage in the requirements, which is on the whole undesirable.
Reference: [18] <author> Fiona Polack and Keith C. Mander. </author> <title> Software quality assurance using the SAZ method. </title> <editor> In J. Bowen and J.A. Hall, editors, </editor> <booktitle> Z User Meeting Cambridge, </booktitle> <pages> pages 231-249. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Often these functional requirements are specified in high level languages, which can force data representation at an early stage in the requirements, which is on the whole undesirable. The use of Z as in the SAZ method, which integrates formal methods in to a large software development context, <ref> [18] </ref> would improve matters. 4 from a prose requirements document is here referred to as the process of Formal Requirements Engineering. It is to be emphasized that, at least in the author's opinion, the process of producing formal specifications should be in two stages. <p> Most individual formal methods at present do not cover the complete spectrum of the software development process. Integration with other techniques is often haphazard, (for an exception see <ref> [18] </ref>). If effective management of the software development process is not exercised with attention to the needs of formal methods then the quality of the final software can not be guaranteed.
Reference: [19] <author> J.M. Spivey. </author> <title> The Z notation : a reference manual. </title> <booktitle> Prentice-Hall International Series in computer science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: In some cases it is desirable, or perhaps it is forced by contractual reasons, to have a RS-document expressed in a formal notation (such as Z <ref> [19] </ref>, or VDM [8]). Such a document from now on will be referred so as a Formal Requirements Specification document (a FRS-document).
Reference: [20] <author> J.S. Fitzgerald, T.M. Brookes, M.A. Green, and P.G. Larsen. </author> <title> Formal and informal specifications of a secure system component: First results in a comparative study. </title> <editor> In Maurice Naftalin, Tim Denvir, and Miquel Bertran, editors, FME'94: </editor> <booktitle> Industrial Benefit of Formal Methods, volume 873 of Lecutre Notes in Comuter Science, </booktitle> <pages> pages 35-45. </pages> <address> Springer-Verleg, </address> <year> 1994. </year>
Reference-contexts: First a prose requirement specification document should be produced and then this document should be formalized. This formalization will produce a separate set of inconsistencies and queries to be resolved with the customer. See <ref> [20, 21] </ref> for examples. For documented examples of producing FRS-documents (in this case Z specifications) see the book [22]. One of the largest examples in the book, is the formalization of parts of IBM's CICS transaction processing system. CICS is a system that has been under continuous development since 1969.
Reference: [21] <author> Joshua D. Guttman and Dale M. Johnson. </author> <title> Three applications of formal methods at MITRE. </title> <editor> In Maurice Naftalin, Tim Denvir, and Miquel Bertran, editors, FME'94: </editor> <booktitle> Industrial Benefit of Formal Methods, volume 873 of Lecutre Notes in Comuter Science, </booktitle> <pages> pages 35-45. </pages> <address> Springer-Verleg, </address> <year> 1994. </year>
Reference-contexts: First a prose requirement specification document should be produced and then this document should be formalized. This formalization will produce a separate set of inconsistencies and queries to be resolved with the customer. See <ref> [20, 21] </ref> for examples. For documented examples of producing FRS-documents (in this case Z specifications) see the book [22]. One of the largest examples in the book, is the formalization of parts of IBM's CICS transaction processing system. CICS is a system that has been under continuous development since 1969.
Reference: [22] <author> I. Hayes. </author> <title> Specification Case Studies. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: This formalization will produce a separate set of inconsistencies and queries to be resolved with the customer. See [20, 21] for examples. For documented examples of producing FRS-documents (in this case Z specifications) see the book <ref> [22] </ref>. One of the largest examples in the book, is the formalization of parts of IBM's CICS transaction processing system. CICS is a system that has been under continuous development since 1969. <p> Many of these inconsistencies were due to the inexperience of the people writing the specifications, but some were real inconsistencies in the system. This process of feedback led to further refinements and revisions of the specifications. For a more detailed discussion, see Section IV of <ref> [22] </ref>. 4 Requirements Traceability The following definition is presented in [1]: Requirements traceability refers to the ability to describe and follow the life of a requirement, in both the forward and back <p>- 5 wards direction (i.e. from its origins, through its development and specification, to its subsequent deployment and use, <p> Of course, there is an `extreme' view that software failures are really management failures [26]. Indeed one of the reasons cited for the success of the CICS example in <ref> [22] </ref> is that there was management backing for the use of formal methods. There are also wider management issues in the implementation of RT. This paper does not attempt to address these management issues in any depth.
Reference: [23] <author> J.A. Hall. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Many other sources of error can be identified. Recent papers that address the issue of possible errors in software development include <ref> [23, 24, 25, 3] </ref>.
Reference: [24] <author> J Bowen and M Hinchey. </author> <title> Seven more myths of formal methods. </title> <type> Technical Report 357, </type> <institution> University of Cambridge Computer Labratory, </institution> <year> 1995. </year> <note> To appear in IEEE Software. </note>
Reference-contexts: Many other sources of error can be identified. Recent papers that address the issue of possible errors in software development include <ref> [23, 24, 25, 3] </ref>.
Reference: [25] <author> J.P. Bowen and M.G. </author> <title> Hinchey. Ten commandments of formal methods. </title> <type> Technical Report 350, </type> <institution> University of Cambridge, </institution> <year> 1994. </year>
Reference-contexts: Many other sources of error can be identified. Recent papers that address the issue of possible errors in software development include <ref> [23, 24, 25, 3] </ref>. <p> Various models can be made, and various approximations to reality used (see commandment II of <ref> [25] </ref>). The use of formal methods does not guarantee that the model of the software environment is any better than without the use of formal methods. <p> Modeling real-time behavior with a model based approach such as Z or VDM, would be possible, but difficult (see commandment I of <ref> [25] </ref> for a fuller discussion). Further, changing the representation of a problem can make it easier to understand and solve.
Reference: [26] <author> A. Wingrove. </author> <title> Software failures are management failures. </title> <editor> In B. Littlewood, editor, </editor> <booktitle> Software Reliability, Achievments and Assessment, </booktitle> <pages> pages 56-68. </pages> <publisher> Blackwell Scientific Publications, </publisher> <year> 1989. </year>
Reference-contexts: It is enough to say that a requirement for the successful use of formal methods is that a conducive management culture exists (and of course a conducive development culture). Of course, there is an `extreme' view that software failures are really management failures <ref> [26] </ref>. Indeed one of the reasons cited for the success of the CICS example in [22] is that there was management backing for the use of formal methods. There are also wider management issues in the implementation of RT.
Reference: [27] <author> Alistair Sutcliffe and Gordon Rugg. </author> <title> A taxonomy of error types for failure analysis and risk assessment. </title> <year> 1994. </year>
Reference-contexts: As an example, suppose that the specification does not constrain the representation of a data type used, but does require that the final piece of code to be completely deterministic. A developer 4 More recent studies <ref> [27, 28] </ref> have been carried out on the psychological classification of design errors, which influence the issue of traceability not only for formal software development, but also for traditional software engineering. 9 misunderstanding the user requirement for deterministic code might re-fine the data structures to a representation requiring dynamic memory allocation.
Reference: [28] <author> Alistair Sutcliffe, Gordon Rugg, and Peter Ayton. </author> <title> Pitfalls in the de-sign process: Assessing the potential for experts' errors. </title> <note> Draft to be submmitted to J.High Integrity Systems (1994). </note>
Reference-contexts: As an example, suppose that the specification does not constrain the representation of a data type used, but does require that the final piece of code to be completely deterministic. A developer 4 More recent studies <ref> [27, 28] </ref> have been carried out on the psychological classification of design errors, which influence the issue of traceability not only for formal software development, but also for traditional software engineering. 9 misunderstanding the user requirement for deterministic code might re-fine the data structures to a representation requiring dynamic memory allocation.
Reference: [29] <author> N.G. Leveson and C.S. Turner. </author> <title> An investigation of the THERAC-25 accidents. </title> <journal> Computer, </journal> <volume> 26(7) </volume> <pages> 18-41, </pages> <year> 1993. </year>
Reference-contexts: The lack of attention even to basic software engineering practice can have disastrous consequences, for example in the case of Therac-25, a safety critical application for administering radiation treatment to cancer victims, where there was no use of any software engineering principles, with a resulting loss of lives (see <ref> [29] </ref>). (iii) Management might not have the knowledge to control the process of formal software development.
Reference: [30] <author> Marvin Schaefer. </author> <title> Symbol security condition considered harmful. </title> <booktitle> In 1989 IEEE SYMPOSIUM ON SECURITY AND PRIVACY, pages 2046. IEEE, </booktitle> <year> 1989. </year>
Reference-contexts: But the process of formal 11 modeling has problems as well, sometimes the formal modeling process can impinge on reality and enforce unacceptable abstractions, see the discussion of <ref> [30] </ref> below. Outside the problems with human error in modeling the environment, which has been discussed above under Pre-FRS traceability, further aspects of Pre-FRS traceability have to be taken into account. <p> A more concrete example would be the formalization of a requirement for continuous delivery of service. Depending on the method and style used some formalizations would already force certain design decisions. In the paper `Symbol Security Condition Considered Harmful' <ref> [30] </ref> an analysis of the role of formal methods in security systems is given. Examples of formally verified systems which have gone wrong are presented (see below). But further, the paper offers an analysis of specification problems for secure systems. To understand the points made in [30], the process of modeling <p> Security Condition Considered Harmful' <ref> [30] </ref> an analysis of the role of formal methods in security systems is given. Examples of formally verified systems which have gone wrong are presented (see below). But further, the paper offers an analysis of specification problems for secure systems. To understand the points made in [30], the process of modeling can be visualized as in figure 2. Schaefer produces many examples which can be seen as breakdowns of the top arrow in figure 2 (modeling assumptions). <p> For example the use of fictional specification conveniences such lumping together hardware registers or adding adding extra reference conditions to simplify proofs of systems. While sometimes these maybe valid moves, their blind and unchecked use can lead to the introduction of security flaws in formally verified systems. See <ref> [30] </ref> again for formally verified systems which were later found to contain security flaws 5 . Another problem, alluded to in [30], in the security community is the use of off the self models. The use of formal methods was mandated very early (1970's) on for secure systems. <p> While sometimes these maybe valid moves, their blind and unchecked use can lead to the introduction of security flaws in formally verified systems. See <ref> [30] </ref> again for formally verified systems which were later found to contain security flaws 5 . Another problem, alluded to in [30], in the security community is the use of off the self models. The use of formal methods was mandated very early (1970's) on for secure systems. At the time there was not much experience of formal specification and verification. <p> It is surprising how easy it is to construct proofs based on inconsistent assumptions which appear not to be consistent. In <ref> [30] </ref> a case is quoted of a data access control system AUTODIN II [32] which was supposedly formally 6 For any formal system a contradiction can be used to prove anything, thus if 0 = 1 is introduced as an axiom then every possible statement is true in the formal system.
Reference: [31] <author> D.E. Bell and L.J. La Padula. </author> <title> Secure computer systems. </title> <type> Technical Report 2547, </type> <institution> The MITRE Corporation, </institution> <month> May-Dec </month> <year> 1973 1973. </year> <note> vol I-III. </note>
Reference-contexts: The use of formal methods was mandated very early (1970's) on for secure systems. At the time there was not much experience of formal specification and verification. Bell and La Padula introduced a model <ref> [31] </ref> of security access in file-type systems. While this model covered a large number of cases, its popularity caused some designers to simply take the model and attempt to fit it to the situation at hand. Consequently it was applied to inappropriate systems.
Reference: [32] <author> S. Bergman. </author> <title> A system description of AUTODIN ii. </title> <type> Technical report, </type> <institution> MITRE Corporation, Bedford, </institution> <address> Mass, </address> <month> May </month> <year> 1978. </year>
Reference-contexts: It is surprising how easy it is to construct proofs based on inconsistent assumptions which appear not to be consistent. In [30] a case is quoted of a data access control system AUTODIN II <ref> [32] </ref> which was supposedly formally 6 For any formal system a contradiction can be used to prove anything, thus if 0 = 1 is introduced as an axiom then every possible statement is true in the formal system. 13 verified, later the specification was found to be inconsistent.
Reference: [33] <author> Z Standards Review Committe. </author> <title> Z base standard, version 1.0. </title> <type> Technical report, </type> <institution> PRG Group Oxford, </institution> <year> 1992. </year> <month> 19 </month>
Reference-contexts: The use of languages such as SGML, which annotate the semantic nature of documents, has already been applied to Z (see Annex D of <ref> [33] </ref>). This could be expanded to produce a standard interchange format for traceability requirements data and in itself requires further research, as well as how such data can be integrated in a relational database.
References-found: 33

