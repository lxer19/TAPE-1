URL: http://www.cs.toronto.edu/~avigal/tcu.ps
Refering-URL: http://www.cs.toronto.edu/~avigal/publications.html
Root-URL: http://www.cs.toronto.edu
Title: A Multi-Agent Update Process in a Database with Temporal Data Dependencies and Schema Versioning  
Author: Avigdor Gal Opher Etzion 
Keyword: temporal databases, data dependencies, database updates, parallel pro cessing, schema versioning, high-level languages.  
Date: September 8, 1994  June 16, 1996  
Note: Original Submission:  Revised Version:  The work was conducted while the author was in the Technion. He is currently at the  This author's work was supported by the fund for the promotion of research at the Technion.  
Address: Haifa, 32000, Israel  Toronto, Toronto, Ontario, M5S 1A4 CANADA.  
Affiliation: Technion Israel Institute of Technology Faculty of Industrial Engineering and Management Information Systems Engineering Group  Department of Computer Science, University of  
Abstract: Temporal data dependencies are high-level linguistic constructs that define relationships among values of data-elements in temporal databases. These constructs enable the support of schema versioning as well as the definition of consistency requirements for a single time-point and among values in different time-points. In this paper we present a multi-agent update process in a database with temporal data dependencies and schema versioning. The update process supports the evolution of dependencies over time and the use of temporal operators within temporal data dependencies. The temporal dependency language is presented, along with the temporal dependency graph, which serves as the executable data structure. A thorough discussion of the feasibility, performance, and consistency of the presented model is provided. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal and N.H. Gehani. </author> <title> Ode (object database and environment): The language and the data model. </title> <booktitle> In Proceedings of the 1989 ACM-SIGMOD conference on Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: However, existing temporal query languages offer a weaker model of temporal data dependencies than presented in this paper. 29 Conventional active databases (e.g. HiPac [7], Ode <ref> [1] </ref>, Starburst [47] and Sybase [25], [43]) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. [2]) cannot capture temporal semantics.
Reference: [2] <author> A. Aiken, J. Widom, and J.M. Hellerstein. </author> <title> Behavior of database production rules: Termination, confluence and observable determinism. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <pages> pages 59-68, </pages> <month> June </month> <year> 1992. </year> <month> 31 </month>
Reference-contexts: As shown in <ref> [2] </ref>, the execution of an acyclic dependency graph is guaranteed to terminate, while the execution of a cyclic dependency graph is not. In the temporal data dependency context, detection of cycles should be done both at the schema level and at the temporal level. <p> The unified temporal dependency graph represents the global dependencies of the database D. Using conventional graph analysis, cycles in the unified dependency graph imply the existence of temporal cycles in the multi-version system. Following <ref> [2] </ref>, it is easy to show that: 1. If the unified temporal dependency graph has no cycles, then the multi-version update process would terminate in a finite number of steps. 2. <p> HiPac [7], Ode [1], Starburst [47] and Sybase [25], [43]) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. <ref> [2] </ref>) cannot capture temporal semantics. For example, the use of connectors based on valid time as defined in temporal data dependencies is disabled since these models do not provide a support for history maintenance.
Reference: [3] <author> E. Baralis, S. Ceri, and J. Widom. </author> <title> Better termination analysis for active databases. </title> <booktitle> In Proceedings of the 1st International Workshop on Rules in Database Systems, </booktitle> <pages> pages 163-179, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: However, the temporal consistency is violated, since (ffi 1 ) is not satisfied during [Apr 1994, May 1994). 4.3 Operations Termination and Confluence One of the main issues in systems that support data dependencies, such as production systems or active databases, is the issue of confluence and termination <ref> [3] </ref>. As shown in [2], the execution of an acyclic dependency graph is guaranteed to terminate, while the execution of a cyclic dependency graph is not. In the temporal data dependency context, detection of cycles should be done both at the schema level and at the temporal level.
Reference: [4] <author> J. Blakeley, N. Cobourn, </author> <title> and P.A. Larson. Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 14(3) </volume> <pages> 322-368, </pages> <year> 1989. </year>
Reference: [5] <author> D. Botzer and O. Etzion. </author> <title> Optimization of materialization strategies for derived data-elements. </title> <journal> to appear in IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1996. </year>
Reference: [6] <author> S. Chakravarthy and D. Mishra. </author> <title> An expressive event specification language for active databases. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 13(3), </volume> <month> Oct. </month> <year> 1994. </year>
Reference: [7] <author> U.S. Chakravarthy. </author> <title> Rule management and evaluation: An active DBMS perspective. </title> <journal> ACM SIGMOD Record, </journal> <volume> 18(3) </volume> <pages> 20-28, </pages> <month> Sep </month> <year> 1989. </year>
Reference-contexts: A more detailed discussion of the simulation is presented in [23]. 5 Related Work The linguistic and execution aspects of data dependencies have been thoroughly investigated using both event driven techniques <ref> [7] </ref> and data driven techniques [34], [30], [18]. A comparison among different approaches for executable specifications of data dependencies can be found in [22]. <p> However, existing temporal query languages offer a weaker model of temporal data dependencies than presented in this paper. 29 Conventional active databases (e.g. HiPac <ref> [7] </ref>, Ode [1], Starburst [47] and Sybase [25], [43]) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. [2]) cannot capture temporal semantics.
Reference: [8] <author> J. Chomicki and D. Toman. </author> <title> Implementing temporal integrity constraints using an active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(4) </volume> <pages> 566-581, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Our model can express more complicated relationships among general types of operations, using temporal semantic knowledge to ensure a correct update of the database under schema versioning. An architecture for implementing temporal integrity constraints by compiling them into a set of active DBMS rules was suggested in <ref> [8] </ref>. This approach is limited and do not support rules that update the temporal database valid time history. In addition, the paper assumes a single set of temporal constraints. Hence, no support of schema versioning is discussed in this work.
Reference: [9] <author> CODASYL. </author> <title> Database task group report. </title> <year> 1971. </year>
Reference: [10] <author> M. P. Consens and A. O. Mendelzon. </author> <title> Graphlog: A visual formalism for real life recursion. </title> <booktitle> In Proc. ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Sys., </booktitle> <address> Nashville, TN, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: While many graph-based data models represent data as well as metadata, this work uses graph techniques for meta-data modeling solely, and therefore many of the techniques that are given in these models are redundant. Most of the graph based data models (e.g. LDM [35], Graphlog <ref> [10] </ref>, and GOOD [27]) use a single digraph. Hence, the presentation of several schema versions is awkward. While the Hypernode model [36] make use of a finite set of digraphs, it is not evident that the connectivity among these digraphs is expressive enough to define connectors.
Reference: [11] <author> D.J. Dewitt and J. Gray. </author> <title> Parallel database systems: the future of high performance database systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6) </volume> <pages> 85-98, </pages> <year> 1992. </year>
Reference: [12] <author> K.R. Dittrich and S. Gatziu. </author> <title> Time issues in active database systems. In R.T. </title> <editor> Snod-grass, editor, </editor> <booktitle> Proceedings of the International Workshop on Infrastructure for Temporal Databases, </booktitle> <address> Arlington, TX, </address> <month> June </month> <year> 1993. </year>
Reference: [13] <author> D. Dori, A. Gal, and O. Etzion. </author> <title> Temporal active database: a key to computer integrated manufacturing. </title> <journal> International Journal of CIM, </journal> <volume> 9(2), </volume> <year> 1996. </year>
Reference-contexts: of the meta-data is much smaller than the size of data and does not change the magnitude of the space complexity relative to any schema knowledge representation. 26 The number of schema versions is assumed to be relatively small, since it is assumed that meta-data changes are grouped into versions <ref> [13] </ref>. Consequently, the number of interacting agents is relatively small. The time complexity of the graph generation is O (V 3 ), where V stands for the number of nodes that represent meta-data elements. This process is performed during the initialization of the first schema version.
Reference: [14] <author> M.L. Edara and S.K. Gadia. </author> <title> Updates and incremental recomputation of active relational expressions in temporal databases. </title> <booktitle> In Proceedings of the International Workshop on an Infrastructure for Temporal Database, </booktitle> <address> Arlington,TX, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Several works in the temporal database research area were published on topics related to the combination of temporal aspects and rules, e.g. [33], [46], <ref> [14] </ref> and [40]. These models possess temporal capabilities, but they neither support explicit data dependencies nor do they enable retroactive and proactive updates in a database that supports schema versioning.
Reference: [15] <author> M. H. Eich. </author> <title> Graph directed locking. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(2):133, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, none of the graph-based data models have an explicit notion of time. Transaction data flow graphs (e.g. <ref> [15] </ref> and [39]) can represent data precedence as a result of read/write conflicts in a transaction. Our model can express more complicated relationships among general types of operations, using temporal semantic knowledge to ensure a correct update of the database under schema versioning.
Reference: [16] <author> O. Etzion. </author> <title> Active interdatabase dependencies. </title> <journal> Information Sciences, </journal> <volume> 75 </volume> <pages> 133-163, </pages> <year> 1993. </year>
Reference: [17] <author> O. Etzion. </author> <title> PARDES | a data-driven oriented active database model. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 22(1) </volume> <pages> 7-14, </pages> <month> Mar </month> <year> 1993. </year> <month> 32 </month>
Reference-contexts: These features are update minimality, incremental updates and parallel processing. * Update minimality: Update minimality is achieved when the number of update operations is minimal, i.e. each update operation is unavoidable and none of the operations 28 is redundant. This property is inherited from the PARDES execution model <ref> [17] </ref> and is based upon the fact that the execution model accumulates relevant triggers and activates each update operation only when all its predecessors in the graph that are updated in the transaction have been activated.
Reference: [18] <author> O. Etzion. </author> <title> The reflective approach for data-driven rules. </title> <journal> International Journal of Intelligent and Cooperative Information Systems, </journal> <volume> 2(4) </volume> <pages> 399-424, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Temporal data dependencies add a temporal consistency requirement, whereby a value val 0 with valid 8 A stable state is a state that is created when a transaction commits <ref> [18] </ref>. 24 time t 0 v , that is derived from a value val with a valid time t v is consistent with respect to the value of val and the dependency that derives val 0 . All of the dependencies presented in consistency as well. <p> A more detailed discussion of the simulation is presented in [23]. 5 Related Work The linguistic and execution aspects of data dependencies have been thoroughly investigated using both event driven techniques [7] and data driven techniques [34], [30], <ref> [18] </ref>. A comparison among different approaches for executable specifications of data dependencies can be found in [22]. <p> It is worth noting that despite the fact that, in general, the maintenance of data dependencies can be performed using active database systems, these two disciplines do not overlap. On the one hand, the required semantics of dependencies is not easily expressible in active databases <ref> [18] </ref>. On the other hand, the support of data dependencies does not require all the capabilities of active databases. Graph-based data models (e.g. [26] and [36]) serve as an alternative to conventional data models.
Reference: [19] <author> O. Etzion, A. Gal, and A. Segev. </author> <booktitle> Retroactive and proactive processing. In Proceedings of Research Issues in Data Engineering Active Database Systems, </booktitle> <pages> pages 126-131, </pages> <month> Feb </month> <year> 1994. </year>
Reference: [20] <author> S.K. Gadia. </author> <title> The role of temporal elements in temporal databases. </title> <journal> Data Engineering Bulletin, </journal> <volume> 7 </volume> <pages> 197-203, </pages> <year> 1988. </year>
Reference: [21] <author> A. Gal. </author> <title> TALE | A Temporal Active Language and Execution Model. </title> <type> PhD thesis, </type> <institution> Technion|Israel Institute of Technology, Technion City, Haifa, Israel, </institution> <month> May </month> <year> 1995. </year> <note> Available through the author's WWW home page, http://www.cs.toronto.edu/avigal. </note>
Reference-contexts: Therefore, connectors are added to the temporal dependency graphs. The generation of the temporal dependency graph is inferred from the schema and the dependency definitions. The time-complexity of generating the temporal dependency graph is bounded by O (max ((jVj + jEj ), (jVj jEj)) <ref> [21] </ref>, where O (jVj jEj) is the time complexity of generating the trigger and request relationships. In terms of the number of nodes in the graph, the algorithm is bounded by O (jVj 3 ), where jVj denotes the number of meta-data entities (properties, operations, connectors and events).
Reference: [22] <author> A. Gal and O. Etzion. </author> <title> Maintaining data driven rules in databases. </title> <journal> IEEE Computer, </journal> <volume> 28(1) </volume> <pages> 28-38, </pages> <month> Jan </month> <year> 1995. </year>
Reference-contexts: A comparison among different approaches for executable specifications of data dependencies can be found in <ref> [22] </ref>. While existing models support various types of data dependencies, none of them accommodate evolution of data dependencies over time and the use of temporal operators within the definition of data dependencies, as required in this paper.
Reference: [23] <author> A. Gal and O. Etzion. </author> <title> A parallel execution model for updating temporal databases. </title> <note> to appear in the International Journal of Computer Systems Science and Engineering, </note> <year> 1995. </year>
Reference-contexts: A thorough discussion of incremental computation of data dependencies can be found in [34]. * Parallel processing: The partition of the application time domain enables the support of parallel processing. The contribution of parallel processing vs. the communication overhead has been investigated by simulation <ref> [23] </ref>. As stated above, the major cost of parallel processing is the overhead generated by the need to coordinate and to transfer information among agents. The communication overhead in Figure 9 was assumed to be a constant (12%). <p> Thus, these results show the benefits of using the multi-agent model due to time considerations only, while increasing the capabilities of the supporting database. A more detailed discussion of the simulation is presented in <ref> [23] </ref>. 5 Related Work The linguistic and execution aspects of data dependencies have been thoroughly investigated using both event driven techniques [7] and data driven techniques [34], [30], [18]. A comparison among different approaches for executable specifications of data dependencies can be found in [22].
Reference: [24] <author> A. Gal, O. Etzion, and A. Segev. </author> <title> Representation of highly-complex knowledge in a database. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 3(2) </volume> <pages> 185-203, </pages> <month> Mar </month> <year> 1994. </year>
Reference: [25] <author> A. Gorelik, Y. Wang, and M. Deppe. </author> <title> Sybase replication server. </title> <booktitle> ACM SIGMOD Record, </booktitle> <address> 23(2):469, </address> <year> 1994. </year>
Reference-contexts: However, existing temporal query languages offer a weaker model of temporal data dependencies than presented in this paper. 29 Conventional active databases (e.g. HiPac [7], Ode [1], Starburst [47] and Sybase <ref> [25] </ref>, [43]) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. [2]) cannot capture temporal semantics.
Reference: [26] <author> R. L. Griffith. </author> <title> Three principles of representation for semantic networks. </title> <journal> ACM Transactions on Database Systems, p.666, </journal> <volume> 25(9), </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: On the one hand, the required semantics of dependencies is not easily expressible in active databases [18]. On the other hand, the support of data dependencies does not require all the capabilities of active databases. Graph-based data models (e.g. <ref> [26] </ref> and [36]) serve as an alternative to conventional data models. While many graph-based data models represent data as well as metadata, this work uses graph techniques for meta-data modeling solely, and therefore many of the techniques that are given in these models are redundant.
Reference: [27] <author> M. Gyssens, J. Paredaens, and D. Van Gucht. </author> <title> A graph-oriented object database model. </title> <journal> Ieee transactions on knowledge and data engineer, </journal> <volume> 6(4):572, </volume> <year> 1994. </year>
Reference-contexts: While many graph-based data models represent data as well as metadata, this work uses graph techniques for meta-data modeling solely, and therefore many of the techniques that are given in these models are redundant. Most of the graph based data models (e.g. LDM [35], Graphlog [10], and GOOD <ref> [27] </ref>) use a single digraph. Hence, the presentation of several schema versions is awkward. While the Hypernode model [36] make use of a finite set of digraphs, it is not evident that the connectivity among these digraphs is expressive enough to define connectors.
Reference: [28] <author> M. Hammer and D. McLeod. </author> <title> Data base description with SDM: a semantic data base model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(3), </volume> <year> 1981. </year>
Reference: [29] <author> E.N. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proceedings of SIGMOD, </booktitle> <pages> pages 440-453, </pages> <month> June </month> <year> 1987. </year>
Reference: [30] <author> S. Hudson and R. King. CACTIS: </author> <title> A database system for specification functionality defined data. </title> <booktitle> In Proceedings of the IEEE OOBDS Workshop, </booktitle> <pages> pages 26-37, </pages> <month> Sep </month> <year> 1986. </year>
Reference-contexts: This accumulation eliminates the redundancy update problem that is common in data driven systems <ref> [30] </ref>. * Incremental updates: A substantial amount of computation can be performed in an incremental fashion. For example, in the data dependency y := sum (x), a modification in one of the relevant instances of x does not require the re-calculation of the sum, which can be done incrementally. <p> A more detailed discussion of the simulation is presented in [23]. 5 Related Work The linguistic and execution aspects of data dependencies have been thoroughly investigated using both event driven techniques [7] and data driven techniques [34], <ref> [30] </ref>, [18]. A comparison among different approaches for executable specifications of data dependencies can be found in [22].
Reference: [31] <author> C.S. Jensen, J. Clifford, S.K. Gadia, A. Segev, and R.T. Snodgrass. </author> <title> A glossary of temporal database concepts. </title> <journal> ACM SIGMOD Record, </journal> <volume> 21(3) </volume> <pages> 35-43, </pages> <year> 1992. </year>
Reference: [32] <author> C.S. Jensen et al. </author> <title> A consensus glossary of temporal database concepts. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1) </volume> <pages> 52-63, </pages> <year> 1994. </year> <month> 33 </month>
Reference-contexts: The database uses a single "active" schema at all valid time points. Using this method, the active schema is normally the schema that is the result of the last schema modification. This method supports schema evolution, by allowing changes in the schema level, but does not support schema versioning <ref> [32] </ref>. It should be noted that this strategy does not meet the requirements posed in this paper. 2. The database supports schema versioning by handling each schema version separately, in a sequential manner. This method uses a simple update algorithm, with no need for communication protocols. 3.
Reference: [33] <author> M.R. </author> <title> Klopprogge and P.C. Lockemann. Modeling information preserving databases; consequences of the concept of time. </title> <booktitle> In Proceedings of the International Conference of VLDB, </booktitle> <address> Florance, Italy, </address> <year> 1983. </year>
Reference-contexts: Several works in the temporal database research area were published on topics related to the combination of temporal aspects and rules, e.g. <ref> [33] </ref>, [46], [14] and [40]. These models possess temporal capabilities, but they neither support explicit data dependencies nor do they enable retroactive and proactive updates in a database that supports schema versioning.
Reference: [34] <author> S. Koenig and R. Paige. </author> <title> A transformational framework for the automatic control of derived data. </title> <booktitle> In Proceedings of the 7th Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufman pubs. </publisher> <address> (Los Altos CA), </address> <publisher> Zaniolo and Delobel(eds), </publisher> <pages> pages 306-318, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: For example, in the data dependency y := sum (x), a modification in one of the relevant instances of x does not require the re-calculation of the sum, which can be done incrementally. A thorough discussion of incremental computation of data dependencies can be found in <ref> [34] </ref>. * Parallel processing: The partition of the application time domain enables the support of parallel processing. The contribution of parallel processing vs. the communication overhead has been investigated by simulation [23]. <p> A more detailed discussion of the simulation is presented in [23]. 5 Related Work The linguistic and execution aspects of data dependencies have been thoroughly investigated using both event driven techniques [7] and data driven techniques <ref> [34] </ref>, [30], [18]. A comparison among different approaches for executable specifications of data dependencies can be found in [22].
Reference: [35] <author> G. M. Kuper and M. Vardi. </author> <title> On the Expressive Power of the Logical Data Model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 180-187, </pages> <address> Austin, Texas, 1985. </address> <publisher> ACM Press. </publisher>
Reference-contexts: While many graph-based data models represent data as well as metadata, this work uses graph techniques for meta-data modeling solely, and therefore many of the techniques that are given in these models are redundant. Most of the graph based data models (e.g. LDM <ref> [35] </ref>, Graphlog [10], and GOOD [27]) use a single digraph. Hence, the presentation of several schema versions is awkward. While the Hypernode model [36] make use of a finite set of digraphs, it is not evident that the connectivity among these digraphs is expressive enough to define connectors.
Reference: [36] <author> M. Levene and G. Loizou. </author> <title> A graph-based data model and its ramifications. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(5) </volume> <pages> 809-823, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: On the one hand, the required semantics of dependencies is not easily expressible in active databases [18]. On the other hand, the support of data dependencies does not require all the capabilities of active databases. Graph-based data models (e.g. [26] and <ref> [36] </ref>) serve as an alternative to conventional data models. While many graph-based data models represent data as well as metadata, this work uses graph techniques for meta-data modeling solely, and therefore many of the techniques that are given in these models are redundant. <p> Most of the graph based data models (e.g. LDM [35], Graphlog [10], and GOOD [27]) use a single digraph. Hence, the presentation of several schema versions is awkward. While the Hypernode model <ref> [36] </ref> make use of a finite set of digraphs, it is not evident that the connectivity among these digraphs is expressive enough to define connectors. To the best of our knowledge, none of the graph-based data models have an explicit notion of time.
Reference: [37] <author> J. Mylopoulos and E. Yu. </author> <title> Aligning information system strategy with business strategy: A technical perspective. A Keynote Address in the Int. </title> <booktitle> Workshop on Next Generation Technologies and Systems, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1993. </year>
Reference: [38] <author> G. Ozsoyoglu and R. Snodgrass. </author> <title> Temporal and real-time databases: A survey. </title> <journal> IEEE Transaction on Knowledge and Data Engineeringe, </journal> <volume> 7(4), </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: This approach is limited and do not support rules that update the temporal database valid time history. In addition, the paper assumes a single set of temporal constraints. Hence, no support of schema versioning is discussed in this work. Real time databases <ref> [38] </ref> enforce temporal consistency and handle mutliversion data [45]. These models assume a database with no schema versioning, and their treatment of multi-version data is strict. For example, in [45], it is assumed that a new data value replaces an older one.
Reference: [39] <author> P.K. Reddy and S. Bhalla. </author> <title> A nonblocking transaction data flow graph based protocol for replicated databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(5) </volume> <pages> 829-834, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: To the best of our knowledge, none of the graph-based data models have an explicit notion of time. Transaction data flow graphs (e.g. [15] and <ref> [39] </ref>) can represent data precedence as a result of read/write conflicts in a transaction. Our model can express more complicated relationships among general types of operations, using temporal semantic knowledge to ensure a correct update of the database under schema versioning.
Reference: [40] <author> N.L. Sarda. HSQL: </author> <title> Historical query language. In Temporal Databases, </title> <booktitle> chapter 5, </booktitle> <pages> pages 110-140. </pages> <publisher> The Benjamin/Commings Publishing Company, Inc., </publisher> <address> Redwood City, CA., </address> <year> 1993. </year>
Reference-contexts: Several works in the temporal database research area were published on topics related to the combination of temporal aspects and rules, e.g. [33], [46], [14] and <ref> [40] </ref>. These models possess temporal capabilities, but they neither support explicit data dependencies nor do they enable retroactive and proactive updates in a database that supports schema versioning.
Reference: [41] <author> A. Segev and J.L. Zaho. </author> <title> Data management for large rule systems. </title> <booktitle> In proceedings of VLDB 91, </booktitle> <year> 1991. </year>
Reference: [42] <author> A. Sheth, M. Rusinkiewicz, and G. Karabatis. </author> <title> Using polytransactions to manage interdependent data. </title> <editor> In A. Elmagarmid, editor, </editor> <title> Transaction Models for Advanced Database Applications, chapter 14. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference: [43] <author> A. Sistla and O. Wolfson. </author> <title> Temporal triggers in active databases. </title> <journal> IEEE Transaction on Knowledge and Data Engineering, </journal> <volume> 7(3) </volume> <pages> 471-486, </pages> <month> Jun 95. </month>
Reference-contexts: However, existing temporal query languages offer a weaker model of temporal data dependencies than presented in this paper. 29 Conventional active databases (e.g. HiPac [7], Ode [1], Starburst [47] and Sybase [25], <ref> [43] </ref>) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. [2]) cannot capture temporal semantics.
Reference: [44] <author> R. Snodgrass et al. </author> <title> TSQL2 language specification. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1) </volume> <pages> 65-86, </pages> <month> Mar </month> <year> 1994. </year>
Reference-contexts: These models possess temporal capabilities, but they neither support explicit data dependencies nor do they enable retroactive and proactive updates in a database that supports schema versioning. Temporal query languages (e.g. <ref> [44] </ref>) support time characteristics such as valid time and transaction time as part of the language, and the use of defaults in defining these characteristics, in case the user does not provide them.
Reference: [45] <author> X.C. Song and J.W.S. Liu. </author> <title> Maintaining temporal consistency: Pessimistic vs. optimistic concurrency control. </title> <journal> IEEE Transacions on Knowledge and Data Engineering, </journal> <volume> 7(5) </volume> <pages> 786-796, </pages> <month> October </month> <year> 1995. </year> <month> 34 </month>
Reference-contexts: In addition, the paper assumes a single set of temporal constraints. Hence, no support of schema versioning is discussed in this work. Real time databases [38] enforce temporal consistency and handle mutliversion data <ref> [45] </ref>. These models assume a database with no schema versioning, and their treatment of multi-version data is strict. For example, in [45], it is assumed that a new data value replaces an older one. <p> Hence, no support of schema versioning is discussed in this work. Real time databases [38] enforce temporal consistency and handle mutliversion data <ref> [45] </ref>. These models assume a database with no schema versioning, and their treatment of multi-version data is strict. For example, in [45], it is assumed that a new data value replaces an older one.
Reference: [46] <author> S.Y.W. Su and H.M. Chen. </author> <title> A temporal knowledge representation model OSAM*/T and its query language OQL/T. </title> <booktitle> In Proceedings of the International Conference on VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: Several works in the temporal database research area were published on topics related to the combination of temporal aspects and rules, e.g. [33], <ref> [46] </ref>, [14] and [40]. These models possess temporal capabilities, but they neither support explicit data dependencies nor do they enable retroactive and proactive updates in a database that supports schema versioning.
Reference: [47] <author> J. Widom. </author> <title> The Starburst rule system: Language design, implementation, </title> <journal> and applications. IEEE Bulletin of the Technical Committee on Data Engineering, </journal> <pages> 15(1-4), </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: However, existing temporal query languages offer a weaker model of temporal data dependencies than presented in this paper. 29 Conventional active databases (e.g. HiPac [7], Ode [1], Starburst <ref> [47] </ref> and Sybase [25], [43]) support temporal functionality up to a limited extent by supporting only limited types of temporal events. Therefore, the use of existing graph based tools (e.g. [2]) cannot capture temporal semantics.
Reference: [48] <author> G. Wiederhold. </author> <title> From data engineering to information engineering, </title> <booktitle> Feb 1994. A keynote address in International Conference on Data Engineering ICDE '94. </booktitle> <pages> 35 </pages>
References-found: 48

