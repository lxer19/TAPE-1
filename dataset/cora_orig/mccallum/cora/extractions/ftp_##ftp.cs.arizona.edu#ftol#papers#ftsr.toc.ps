URL: ftp://ftp.cs.arizona.edu/ftol/papers/ftsr.toc.ps
Refering-URL: http://www.cs.arizona.edu/cactus/public.html
Root-URL: http://www.cs.arizona.edu
Title: Programming Language Support for Writing Fault-Tolerant Distributed Software  
Author: Richard D. Schlichting and Vicraj T. Thomas 
Abstract: Good programming language support can simplify the task of writing fault-tolerant distributed software. Here, an approach to providing such support is described in which a general high-level distributed programming language is augmented with mechanisms for fault tolerance. Unlike approaches based on sequential languages or specialized languages oriented towards a given fault-tolerance technique, this approach gives the programmer a high level of abstraction, while still maintaining flexibility and execution efficiency. The paper first describes a programming model that captures the important characteristics that should be supported by a programming language of this type. It then presents a realization of this approach in the form of FT-SR, a programming language that augments the SR distributed programming language with features for replication, recovery, and failure notification. In addition to outlining these extensions, an example program consisting of a data manager and its associated stable storage is given. Finally, an implementation of the language that uses the x-kernel and runs standalone on a network of Sun workstations is discussed. The overall structure and several of the algorithms used in the runtime are interesting in their own right.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Birman, A. Schiper, and P. Stephenson, </author> <title> Lightweight causal and atomic group multicast, </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 272-314, </pages> <month> Aug </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: At one end of the spectrum are relatively low-level choices such as assembly language or C, often coupled with a fault-tolerance library such as ISIS <ref> [1] </ref>. Such an approach can result in good execution efficiency, yet forces the programmer to deal with the complexities of distributed execution and fault-tolerance in a language that is fundamentally sequential. <p> These considerations 13 resource main imports transManager, dataManager, stableStore, lockManager body main var virtMachines [3] : cap vm # array of virtual machine capabilities dataSS [2], tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines <ref> [1] </ref> := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () <p> dataManager # capabilities to lock and data managers virtMachines <ref> [1] </ref> := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] dataSS [2] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines <p> () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) on virtMachines [i] af tm = create transManager (dm <ref> [1] </ref>, dm [2], tmSS) on virtMachines [1] end main preserve the semantic integrity of the language and at the same time keep it relatively simple and therefore, easy to understand and use. We illustrate these points with several examples. <p> virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) on virtMachines [i] af tm = create transManager (dm <ref> [1] </ref>, dm [2], tmSS) on virtMachines [1] end main preserve the semantic integrity of the language and at the same time keep it relatively simple and therefore, easy to understand and use. We illustrate these points with several examples.
Reference: [2] <author> B. Liskov, </author> <title> The Argus language and system, in Distributed Systems: Methods and Tools for Specification, </title> <note> LNCS, Vol. 190 (M. </note> <editor> Paul and H. Siegert, eds.), ch. </editor> <volume> 7, </volume> <pages> pp. 343-430, </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: At fl This work supported in part by the National Science Foundation under grant CCR-9003161 and the Office of Naval Research under grant N00014-91-J-1015. 1 the other end of the spectrum are high-level languages specifically intended for constructing fault-tolerant applications using a given technique. Examples here include Argus <ref> [2] </ref> and Plits [3], which support a programming model based on atomic actions. Such languages simplify the problems considerably, yet can be overly constraining if the programmer desires to use fault-tolerance techniques other than the one supported by the language [4]. <p> The second is that, whenever possible, these mechanisms use or form natural extensions to existing SR mechanisms. These considerations 13 resource main imports transManager, dataManager, stableStore, lockManager body main var virtMachines [3] : cap vm # array of virtual machine capabilities dataSS <ref> [2] </ref>, tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines [1] := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # <p> These considerations 13 resource main imports transManager, dataManager, stableStore, lockManager body main var virtMachines [3] : cap vm # array of virtual machine capabilities dataSS <ref> [2] </ref>, tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines [1] := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager <p> dataManager, stableStore, lockManager body main var virtMachines [3] : cap vm # array of virtual machine capabilities dataSS <ref> [2] </ref>, tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines [1] := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] dataSS <p> := create vm () on ``host2'' virtMachines [3] := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] dataSS <ref> [2] </ref> := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] <p> <ref> [2] </ref> := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) on virtMachines [i] af tm = create transManager (dm [1], dm [2], tmSS) on virtMachines [1] end main preserve the semantic integrity of the language and at the same time keep it relatively simple <p> virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines <ref> [2] </ref> fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) on virtMachines [i] af tm = create transManager (dm [1], dm [2], tmSS) on virtMachines [1] end main preserve the semantic integrity of the language and at the same time keep it relatively simple and therefore, easy to understand and use. We illustrate these points with several examples. <p> Examples of new languages include Argus <ref> [2] </ref>, Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada.
Reference: [3] <author> C. Ellis, J. Feldman, and J. Heliotis, </author> <title> Language constructs and support systems for distributed computing, </title> <booktitle> in ACM Symp. on Prin. of Dist. Comp., </booktitle> <pages> pp. 1-9, </pages> <month> Aug </month> <year> 1982. </year>
Reference-contexts: Examples here include Argus [2] and Plits <ref> [3] </ref>, which support a programming model based on atomic actions. Such languages simplify the problems considerably, yet can be overly constraining if the programmer desires to use fault-tolerance techniques other than the one supported by the language [4]. <p> The second is that, whenever possible, these mechanisms use or form natural extensions to existing SR mechanisms. These considerations 13 resource main imports transManager, dataManager, stableStore, lockManager body main var virtMachines <ref> [3] </ref> : cap vm # array of virtual machine capabilities dataSS [2], tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines [1] := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines <p> : cap vm # array of virtual machine capabilities dataSS [2], tmSS: cap stableStore # capabilities to stable stores lm: cap lockManager; dm [2]: cap dataManager # capabilities to lock and data managers virtMachines [1] := create vm () on ``host1'' virtMachines [2] := create vm () on ``host2'' virtMachines <ref> [3] </ref> := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] dataSS [2] := create (i := 1 to 2) <p> virtMachines [2] := create vm () on ``host2'' virtMachines <ref> [3] </ref> := create vm () on ``host3'' # backup machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] dataSS [2] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on <p> machine # create stable storage for use by the data managers and the transaction manager dataSS [1] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines <ref> [3] </ref> dataSS [2] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) <p> := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines <ref> [3] </ref> dataSS [2] := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] tmSS := create (i := 1 to 2) stableStore () on virtMachines [i] backups on virtMachines [3] # create lock manager, data managers, and transaction manager lm := create lockManager () on virtMachines [2] fa i := 1 to 2 -&gt; dm [i] = create dataManager (i, lm, dataSS [i]) on virtMachines [i] af tm = create transManager (dm [1], dm [2], tmSS) on virtMachines [1] end <p> Examples of new languages include Argus [2], Aeolus [26] and Plits <ref> [3] </ref>. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada.
Reference: [4] <author> H. Bal, </author> <title> A comparative study of five parallel programming languages, </title> <booktitle> in Proc. EurOpen Conf. on Open Dist. Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Examples here include Argus [2] and Plits [3], which support a programming model based on atomic actions. Such languages simplify the problems considerably, yet can be overly constraining if the programmer desires to use fault-tolerance techniques other than the one supported by the language <ref> [4] </ref>. The net result is that neither option provides the ideal combination of features.
Reference: [5] <author> U. S. Dept. </author> <title> of Defense, Reference Manual for the Ada Programming Language. </title> <address> Washington D.C., </address> <year> 1983. </year>
Reference-contexts: The net result is that neither option provides the ideal combination of features. In this paper, we advocate an intermediate approach based on taking a general high-level concurrent or distributed programming language such as Ada <ref> [5] </ref>, CSP [6], or SR [7] and augmenting it with additional mechanisms to facilitate fault-tolerance. Starting with a language of this type offers a number of advantages.
Reference: [6] <author> C. A. R. Hoare, </author> <title> Communicating sequential processes, </title> <journal> Commun. ACM, </journal> <volume> vol. 21, </volume> <pages> pp. 666-677, </pages> <month> Aug </month> <year> 1978. </year>
Reference-contexts: The net result is that neither option provides the ideal combination of features. In this paper, we advocate an intermediate approach based on taking a general high-level concurrent or distributed programming language such as Ada [5], CSP <ref> [6] </ref>, or SR [7] and augmenting it with additional mechanisms to facilitate fault-tolerance. Starting with a language of this type offers a number of advantages.
Reference: [7] <author> G. R. Andrews and R. A. Olsson, </author> <title> The SR Programming Language: Concurrency in Practice. </title> <address> Benjamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: The net result is that neither option provides the ideal combination of features. In this paper, we advocate an intermediate approach based on taking a general high-level concurrent or distributed programming language such as Ada [5], CSP [6], or SR <ref> [7] </ref> and augmenting it with additional mechanisms to facilitate fault-tolerance. Starting with a language of this type offers a number of advantages. <p> To support the model, the language has provisions for encapsulation based on SR resources, resource replication, recovery protocols, and both synchronous and asynchronous failure notification. Familiarity with SR is assumed, although many of its constructs should be intuitive; details can be found in <ref> [7, 15] </ref>. 3.1 Simple FS Modules Most distributed programming languages, including SR, have module constructs that provide many of the properties needed to realize a simple FS module. In SR, these modules are called resources.
Reference: [8] <author> N. Hutchinson and L. L. Peterson, </author> <title> The x-Kernel: An architecture for implementing network protocols, </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Second, we describe a realization of this approach in the form of FT-SR, a programming language based on augmenting the SR distributed programming language with additional mechanisms for fault-tolerance. FT-SR has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols <ref> [8] </ref>, and runs standalone on a network of Sun workstations. The implementation structure and several of the algorithms used in the runtime system are also interesting in their own right.
Reference: [9] <author> F. Schneider, </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, </volume> <pages> pp. 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Replicating a module N times on separate processors to create a high-level abstract module that can survive N-1 failures is an example of the former <ref> [9] </ref>, while including a recovery protocol that reads a checkpointed state from stable storage [10] is an example of the latter. The other key aspect of FS modules is failure notification. <p> A distinguishing feature of these languages is the programming model they support. For example, the transaction model is supported by Aeolus, Argus, Avalon, HOPS, Plits, and Arjuna, while the replicated state machine approach <ref> [9] </ref> is supported by HOPS and FTCC. FT-SR differs from all the above languages in supporting a model based on FS modules, which 19 allows any of these other approaches to be programmed easily.
Reference: [10] <author> B. Lampson, </author> <title> Atomic transactions, in Distributed SystemsArchitecture and Implementation (B. </title> <editor> Lampson, M. Paul, and H. Seigert, eds.), ch. </editor> <volume> 11, </volume> <pages> pp. 246-265, </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Replicating a module N times on separate processors to create a high-level abstract module that can survive N-1 failures is an example of the former [9], while including a recovery protocol that reads a checkpointed state from stable storage <ref> [10] </ref> is an example of the latter. The other key aspect of FS modules is failure notification. Notification is generated whenever a failure exhausts the redundancy of a (simple or complex) FS module, resulting in complete failure of the abstraction being implemented.
Reference: [11] <author> R. Schlichting and F. Schneider, </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems, </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 222-238, </pages> <month> Aug </month> <year> 1983. </year>
Reference-contexts: We refer to a failure that exhausts redundancy in this way as a catastrophic failure. Notification is also generated if a module is explicitly destroyed by programmer action. Note that the analogy to fail-stop processors <ref> [11] </ref> implied by the term fail-stop modules is strong: in both cases, either the abstraction is maintained (processor or module) or notification is provided. FS modules are also similar in some respects to the Ideal Fault-Tolerant Components described in [12].
Reference: [12] <author> P. Lee and T. Anderson, </author> <title> Fault Tolerance: </title> <booktitle> Principles and Practice. </booktitle> <address> Vienna: </address> <publisher> Springer-Verlag, </publisher> <editor> second ed., </editor> <year> 1990. </year>
Reference-contexts: Note that the analogy to fail-stop processors [11] implied by the term fail-stop modules is strong: in both cases, either the abstraction is maintained (processor or module) or notification is provided. FS modules are also similar in some respects to the Ideal Fault-Tolerant Components described in <ref> [12] </ref>. FS modules form the building blocks out of which a fault-tolerant distributed program can be constructed. As an example, consider the simple distributed banking system shown in 3 resented by arrows [13].
Reference: [13] <author> F. Cristian, </author> <title> Understanding fault-tolerant distributed systems, </title> <journal> Commun. ACM, </journal> <volume> vol. 34, </volume> <pages> pp. 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: FS modules are also similar in some respects to the Ideal Fault-Tolerant Components described in [12]. FS modules form the building blocks out of which a fault-tolerant distributed program can be constructed. As an example, consider the simple distributed banking system shown in 3 resented by arrows <ref> [13] </ref>. User accounts are assumed to be partitioned across two processors, with each data manager module managing the collection of accounts on its machine.
Reference: [14] <author> J. Gray, </author> <title> Notes on data base operating systems, in Operating Systems, An Advanced Course (R. </title> <editor> Bayer, R. Graham, and G. Seegmuller, eds.), ch. </editor> <booktitle> 3.F, </booktitle> <pages> pp. 393-481, </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: The user interacts with the transaction manager, which in turn uses the data managers and a stable storage module to implement transactions using, for example, the two-phase commit protocol <ref> [14] </ref> and logging. The data managers export operations to read and write user accounts, and to implement the two-phase commit protocol. The stable storage modules are used to store the user data and to maintain key values for recovery purposes. The lock managers are used to control concurrent access.
Reference: [15] <author> G. Andrews et al., </author> <title> An overview of the SR language and implementation, </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> vol. 10, </volume> <pages> pp. 51-86, </pages> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: To support the model, the language has provisions for encapsulation based on SR resources, resource replication, recovery protocols, and both synchronous and asynchronous failure notification. Familiarity with SR is assumed, although many of its constructs should be intuitive; details can be found in <ref> [7, 15] </ref>. 3.1 Simple FS Modules Most distributed programming languages, including SR, have module constructs that provide many of the properties needed to realize a simple FS module. In SR, these modules are called resources.
Reference: [16] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev, </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement, </title> <booktitle> in Proc. 15th Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 200-206, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Moreover, the multicast is also done atomically, so that either all functioning replicas receive the invocation or none do. This combination of properties means that a multicast invocation is equivalent to an atomic broadcast, a facility that has proven useful for constructing many types of fault-tolerant distributed systems <ref> [16, 17, 18, 19] </ref>. Provisions are also made for coordinating outgoing invocations generated within a resource group. There are two kinds of invocations that can be generated by a group member.
Reference: [17] <author> H. Kopetz et al., </author> <title> Distributed fault-tolerant real-time systems: The Mars approach, </title> <journal> IEEE Micro, </journal> <volume> vol. 9, </volume> <pages> pp. 25-40, </pages> <month> Feb </month> <year> 1989. </year>
Reference-contexts: Moreover, the multicast is also done atomically, so that either all functioning replicas receive the invocation or none do. This combination of properties means that a multicast invocation is equivalent to an atomic broadcast, a facility that has proven useful for constructing many types of fault-tolerant distributed systems <ref> [16, 17, 18, 19] </ref>. Provisions are also made for coordinating outgoing invocations generated within a resource group. There are two kinds of invocations that can be generated by a group member.
Reference: [18] <author> P. Melliar-Smith, L. Moser, and V. Agrawala, </author> <title> Broadcast protocols for distributed systems, </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 17-25, </pages> <month> Jan </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: Moreover, the multicast is also done atomically, so that either all functioning replicas receive the invocation or none do. This combination of properties means that a multicast invocation is equivalent to an atomic broadcast, a facility that has proven useful for constructing many types of fault-tolerant distributed systems <ref> [16, 17, 18, 19] </ref>. Provisions are also made for coordinating outgoing invocations generated within a resource group. There are two kinds of invocations that can be generated by a group member.
Reference: [19] <author> D. Powell, ed., Delta-4: </author> <title> A Generic Architecture for Dependable Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Moreover, the multicast is also done atomically, so that either all functioning replicas receive the invocation or none do. This combination of properties means that a multicast invocation is equivalent to an atomic broadcast, a facility that has proven useful for constructing many types of fault-tolerant distributed systems <ref> [16, 17, 18, 19] </ref>. Provisions are also made for coordinating outgoing invocations generated within a resource group. There are two kinds of invocations that can be generated by a group member.
Reference: [20] <author> F. Cristian, </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems, </title> <journal> Distributed Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 175-187, </pages> <year> 1991. </year>
Reference-contexts: These include a fault-tolerant version of the Dining Philosophers problem that shows how a single monitor statement can be used to implement a group membership service <ref> [20, 21] </ref>, and a distributed word game that exploits multiple processors for increased performance as well as fault-tolerance. A description of all these examples together with complete code can be found in [22]. 3.4 Language Design Issues The fault-tolerance mechanisms of FT-SR are designed with two important considerations in mind.
Reference: [21] <author> H. Kopetz, G. Grunsteidl, and J. Reisinger, </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system, in Dependable Computing for Critical Applications (A. </title> <editor> Avi zienis and J.-C. Laprie, </editor> <booktitle> eds.), </booktitle> <pages> pp. 411-429, </pages> <publisher> Wien: Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: These include a fault-tolerant version of the Dining Philosophers problem that shows how a single monitor statement can be used to implement a group membership service <ref> [20, 21] </ref>, and a distributed word game that exploits multiple processors for increased performance as well as fault-tolerance. A description of all these examples together with complete code can be found in [22]. 3.4 Language Design Issues The fault-tolerance mechanisms of FT-SR are designed with two important considerations in mind.
Reference: [22] <author> V. Thomas, FT-SR: </author> <title> A Programming Language for Constructing Fault-Tolerant Distributed Systems. </title> <type> PhD thesis, </type> <institution> Dept. of CS, Univ. of Arizona, </institution> <year> 1993. </year>
Reference-contexts: A description of all these examples together with complete code can be found in <ref> [22] </ref>. 3.4 Language Design Issues The fault-tolerance mechanisms of FT-SR are designed with two important considerations in mind. The first is that the mechanisms be orthogonal, so that any interplay between these mechanisms not result in unexpected behavior.
Reference: [23] <author> J. Chang and N. Maxemchuk, </author> <title> Reliable broadcast protocols, </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 251-273, </pages> <month> Aug </month> <year> 1984. </year>
Reference-contexts: Group Communication. Perhaps the most interesting aspect of replication is the algorithm used to implement multicast invocations. The technique we use is similar to <ref> [23, 24] </ref>, where one replica is a primary through which all messages are funneled. Another max sf replicas are designated as primary-group members, with the remaining being considered ordinary members. Upon receiving a message, the primary adds a sequence number and multicasts it to all replicas.
Reference: [24] <author> M. F. Kaashoek, A. Tanenbaum, S. Hummel, and H. Bal, </author> <title> An efficient reliable broadcast protocol, </title> <journal> Operating Systems Review, </journal> <volume> vol. 23, </volume> <pages> pp. 5-19, </pages> <month> Oct </month> <year> 1989. </year>
Reference-contexts: Group Communication. Perhaps the most interesting aspect of replication is the algorithm used to implement multicast invocations. The technique we use is similar to <ref> [23, 24] </ref>, where one replica is a primary through which all messages are funneled. Another max sf replicas are designated as primary-group members, with the remaining being considered ordinary members. Upon receiving a message, the primary adds a sequence number and multicasts it to all replicas.
Reference: [25] <author> J. Gray, </author> <title> Why do computers stop and what can be done about it, </title> <booktitle> in Proc. 5th Symp. on Reliability in Dist. Software and Database Systems, </booktitle> <pages> pp. 3-12, </pages> <month> Jan </month> <year> 1986. </year>
Reference-contexts: As can be seen, for groups larger than max sf + 1, the cost of an invocation to the group is independent of group size, a direct result of the above algorithm. This is especially significant given that a max sf of one is sufficient for most systems <ref> [25] </ref>. This gives FT-SR a considerable advantage over systems such as ISIS where the cost of an invocation grows linearly with the size of the group. Group Reconfiguration after Failure. The Group Manager at each site is responsible for determining the primary and the members of the primary-group set.
Reference: [26] <author> R. LeBlanc and C. T. Wilkes, </author> <title> Systems programming with objects and actions, </title> <booktitle> in Proc. 5th Conf. on Distributed Computing Systems, (Denver), </booktitle> <pages> pp. 132-139, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus <ref> [26] </ref> and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada.
Reference: [27] <author> R. Cmelik, N. Gehani, and W. D. Roome, </author> <title> Fault Tolerant Concurrent C: A tool for writing fault tolerant distributed programs, </title> <booktitle> in Proc. 18th Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 55-61, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) <ref> [27] </ref>, HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [28] <author> H. Madduri, </author> <title> Fault-tolerant distributed computing, </title> <journal> Scientific Honeyweller, </journal> <volume> vol. </volume> <pages> Winter 1986-87, pp. 1-10, </pages> <year> 1986. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS <ref> [28] </ref>, and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [29] <author> J. Knight and J. Urquhart, </author> <title> On the implementation and use of Ada on fault-tolerant distributed systems, </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. SE-13, </volume> <pages> pp. 553-563, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in <ref> [29] </ref>, [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [30] <author> M. F. Kaashoek, R. Michiels, H. Bal, and A. Tanenbaum, </author> <title> Transparent fault-tolerance in parallel Orca programs, </title> <booktitle> in Proc. USENIX Symp. on Exper. with Distributed and Multiprocessor Systems, </booktitle> <pages> pp. 297-311, </pages> <month> Mar </month> <year> 1992. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], <ref> [30] </ref> and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [31] <author> R. Schlichting, F. Cristian, and T. Purdin, </author> <title> A linguistic approach to failure-handling in distributed systems, in Dependable Computing for Critical Applications (A. </title> <editor> Avi zienis and J.-C. Laprie, </editor> <booktitle> eds.), </booktitle> <pages> pp. 387-409, </pages> <publisher> Wien: Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and <ref> [31] </ref>. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [32] <author> S. Shrivastava, G. Dixon, and G. Parrington, </author> <title> An overview of the Arjuna distributed programming system, </title> <journal> IEEE Software, </journal> <volume> vol. 8, </volume> <pages> pp. 66-73, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna <ref> [32] </ref> for C++, and Avalon [33] for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support.
Reference: [33] <author> M. Herlihy and J. Wing, </author> <title> Avalon: Language support for reliable distributed systems, </title> <booktitle> in Proc. 17th Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 89-94, </pages> <month> July </month> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Examples of new languages include Argus [2], Aeolus [26] and Plits [3]. Examples of extensions include Fault-Tolerant Concurrent C (FTCC) [27], HOPS [28], and languages described in [29], [30] and [31]. Finally, fault-tolerance library support is provided by Arjuna [32] for C++, and Avalon <ref> [33] </ref> for C++, Common Lisp and Ada. A distinguishing feature of these languages is the programming model they support. For example, the transaction model is supported by Aeolus, Argus, Avalon, HOPS, Plits, and Arjuna, while the replicated state machine approach [9] is supported by HOPS and FTCC.
References-found: 33

