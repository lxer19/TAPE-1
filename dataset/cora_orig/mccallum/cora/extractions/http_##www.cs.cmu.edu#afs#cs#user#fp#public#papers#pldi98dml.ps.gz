URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/pldi98dml.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: hwxi@cs.cmu.edu  fp@cs.cmu.edu  
Title: Eliminating Array Bound Checking Through Dependent Types  
Author: Hongwei Xi Frank Pfenning 
Affiliation: Department of Mathematical Sciences Carnegie Mellon University  Department of Computer Science Carnegie Mellon University  
Abstract: We present a type-based approach to eliminating array bound checking and list tag checking by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable in theory and can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Blelloch, G. E. </author> <year> (1993, </year> <month> April). </month> <title> NESL: A nested data-parallel language (version 2.6). </title> <type> Technical Report CMU-CS-93-129, </type> <institution> School of Computer Science, Carnegie Mellon University. </institution>
Reference: <author> Chow, F. </author> <year> (1983). </year> <title> A portable machine-independent global optimizer design and measurements. </title> <publisher> Ph. </publisher> <address> D. </address> <institution> dissertation, Stanford University. </institution> <type> Technical Report 83-254. </type>
Reference: <author> Constable, R. L. et al. </author> <year> (1986). </year> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <address> Englewood Cliffs, New Jersey: </address> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Dependent types also form the basis of general theorem proving and verified program development environments such as Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), Nuprl <ref> (Constable et al. 1986) </ref>, or PVS (Owre, Rajan, Rushby, Shankar, and Srivas 1996). 2 We have not not yet explored this possibility in our prototype implementation, which is restricted to the core language.
Reference: <author> Corman, T. H., C. E. Leiserson, and R. L. </author> <title> Rivest (1989). Introduction to Algorithms. </title> <address> Cambridge, Mas-sachusetts: </address> <publisher> The MIT Press. </publisher>
Reference: <author> Davies, R. </author> <year> (1997, </year> <month> November). </month> <title> Practical refinement-type checking. </title> <type> Thesis Proposal. </type>
Reference: <author> Dowek, G., A. Felty, H. Herbelin, G. Huet, C. Murthy, C. Parent, C. Paulin-Mohring, and B. </author> <title> Werner (1993). The Coq proof assistant user's guide. Rapport Techniques 154, </title> <institution> INRIA, Rocquencourt, France. </institution> <note> Version 5.8. </note>
Reference-contexts: We believe that their approach is well-suited for languages such as NESL (Blel-loch 1993), but that it is too restrictive to be practical for ML. Dependent types also form the basis of general theorem proving and verified program development environments such as Coq <ref> (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993) </ref>, Nuprl (Constable et al. 1986), or PVS (Owre, Rajan, Rushby, Shankar, and Srivas 1996). 2 We have not not yet explored this possibility in our prototype implementation, which is restricted to the core language.
Reference: <author> Freeman, T. </author> <year> (1994, </year> <month> March). </month> <title> Refinement Types for ML. </title>
Reference: <author> Ph. D. </author> <type> dissertation, </type> <institution> Carnegie Mellon University. </institution> <note> Available as Technical Report CMU-CS-94-110. </note>
Reference: <author> Freeman, T. and F. </author> <title> Pfenning (1991). Refinement types for ML. </title> <booktitle> In ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pp. 268-277. </pages>
Reference-contexts: Since we extend ML conservatively, dependent types can be used sparingly, and existing ML programs will work as before if there is no keyword conflict. Hayashi proposed a type system ATTT (Hayashi 1991), which allows a notion of refinement types as in <ref> (Freeman and Pfenning 1991) </ref>, plus union and singleton types. He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of the corresponding logical operators on constraints.
Reference: <author> Gupta, R. </author> <year> (1994). </year> <title> Optimizing array bound checks using flow analysis. </title> <journal> ACM Letters on Programming Languages and Systems 2 (1-4), </journal> <pages> 135-150. </pages>
Reference-contexts: We list some sample constraints generated from type-checking the above code in Figure 4. All of these can be solved easily. Note that if we program binary search in C, the array bound check cannot be hoisted out of loops using the algorithm presented in <ref> (Gupta 1994) </ref> since it is neither increasing nor decreasing in terms of the definition given there. On the other hand, the method in (Susuki and Ishihata 1977) could eliminate this array bound check by synthesizing an induction hypothesis similar to our annotated type for look.
Reference: <author> Hayashi, S. </author> <year> (1991). </year> <title> Singleton, union and intersection types for program extraction. </title> <editor> In A. R. Meyer (Ed.), </editor> <booktitle> Proceedings of the International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pp. 701-730. </pages>
Reference-contexts: i)) where loop &lt;| -n:nat- -i:nat | i &lt;= n- int (i) * int (n) * int -&gt; int in loop (0, length v1, 0) end where dotprod &lt;| -p:nat- -q:nat | p &lt;= q - int array (p) * int array (q) -&gt; int * We employ singleton types <ref> (Hayashi 1991) </ref> to allow the necessary interaction between the index and term lan guages. * We only consider programs which are already well-typed in ML. <p> Since we extend ML conservatively, dependent types can be used sparingly, and existing ML programs will work as before if there is no keyword conflict. Hayashi proposed a type system ATTT <ref> (Hayashi 1991) </ref>, which allows a notion of refinement types as in (Freeman and Pfenning 1991), plus union and singleton types. He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of the corresponding logical operators on constraints.
Reference: <author> Jay, C. and M. </author> <month> Sekanina </month> <year> (1996). </year> <title> Shape checking of array programs. </title> <type> Technical Report 96.09, </type> <institution> University of Technology, </institution> <address> Sydney, Australia. </address>
Reference-contexts: Dependent types allow program invariants and properties to be communicated and checked across module boundaries if they are included in signatures. 2 Most closely related to our work is the work on shape checking by Jay and Sekanina <ref> (Jay and Sekanina 1996) </ref>. They also pursue a language-based approach with a restricted form of dependent types. However, their language and programs are rather restricted and different from the kind of programs typically written in ML (including, for example, explicit shape conditionals). <p> Furthermore, these methods provide no feedback to the programmer regarding the correctness of his code, which is an important component of our solution. We also deal with advanced features of ML such as higher-order functions and polymorphism. The work by Jay and Sekanina <ref> (Jay and Sekanina 1996) </ref> which includes these features and has similar goals and approach to ours is more restrictive in the design and seems more promising for languages based on iteration schemas rather than general recursion.
Reference: <author> Markstein, V., C. J. and P. </author> <title> Markstein (1982). Optimization of range checking. </title> <booktitle> In SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pp. 114-119. </pages>
Reference: <author> Martin-Lof, P. </author> <year> (1980). </year> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science VI, </booktitle> <pages> pp. 153-175. </pages> <publisher> North-Holland. </publisher>
Reference: <author> Michaylov, S. </author> <year> (1992, </year> <month> August). </month> <title> Design and Implementation of Practical Constraint Logic Programming Systems. </title>
Reference-contexts: We currently reject non-linear constraints rather than postponing them as hard constraints <ref> (Michaylov 1992) </ref>, which is planned for future work. If the constraints are linear, we negate them and test for unsatisfiability.
Reference: <author> Ph. D. </author> <type> thesis, </type> <institution> Carnegie Mellon University. </institution> <note> Available as Technical Report CMU-CS-92-168. </note>
Reference: <author> Necula, G. </author> <year> (1997). </year> <title> Proof-carrying code. </title> <booktitle> In Conference Record of 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 106-119. </pages> <publisher> ACM press. </publisher>
Reference-contexts: In statically typed languages such as ML, one would like to provide strong guarantees about the safety of all operations, so array bound checks cannot be omitted in general. The same is true for Java bytecode interpreters or compilers (Sun Microsystems 1995) and proof-carrying code <ref> (Necula 1997) </ref>, which are aimed at providing safety when transmitting code across a network to be executed at a remote site. Tag checking in functional languages is similar to array bound checking. <p> Also related is the work on a certifying compiler by Nec-ula and Lee, which introduces precondition annotations for a type-safe subset of C in order to eliminate array bound checks (Necula and Lee 1998) and generate proof-carrying code <ref> (Necula 1997) </ref>. Their language is significantly simpler (for example, it does not include higher-order functions or polymorphism), which allows them to formulate their extensions without constructing a full type system. <p> We can propagate program properties (including array bound information) through a compiler where they can be used for optimizations or safety certificates in proof-carrying code <ref> (Necula 1997) </ref>. This work arose from a larger effort to incorporate a more general form of dependent types into ML (Xi 1998). Our extended type checking algorithm is robust (in the sense that it can collect constraints independently of their domain), because we separated the language of indices and programs.
Reference: <author> Necula, G. and P. Lee (1998, </author> <month> June). </month> <title> The design and implementation of a certifying compiler. </title> <booktitle> In ACM SIGPLAN '98 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM press. </publisher>
Reference-contexts: Also related is the work on a certifying compiler by Nec-ula and Lee, which introduces precondition annotations for a type-safe subset of C in order to eliminate array bound checks <ref> (Necula and Lee 1998) </ref> and generate proof-carrying code (Necula 1997). Their language is significantly simpler (for example, it does not include higher-order functions or polymorphism), which allows them to formulate their extensions without constructing a full type system. <p> We would also like to incorporate the ideas and observations from (Pugh and Wonnacott 1994) into our constraint solver and improve its efficiency. We also plan to pursue using our language as a front-end for a certifying compiler for ML along the lines of work by Necula and Lee <ref> (Necula and Lee 1998) </ref> for a safe subset of C. We can propagate program properties (including array bound information) through a compiler where they can be used for optimizations or safety certificates in proof-carrying code (Necula 1997).
Reference: <author> Owre, S., S. Rajan, J. Rushby, N. Shankar, and M. </author> <month> Srivas </month> <year> (1996, </year> <title> July/August). PVS: Combining specification, proof checking, and model checking. </title> <editor> In R. Alur and T. A. Henzinger (Eds.), </editor> <booktitle> Computer-Aided Verification, CAV '96, Volume 1102 of LNCS, </booktitle> <address> New Brunswick, NJ, </address> <pages> pp. 411-414. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Dependent types also form the basis of general theorem proving and verified program development environments such as Coq (Dowek, Felty, Herbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), Nuprl (Constable et al. 1986), or PVS <ref> (Owre, Rajan, Rushby, Shankar, and Srivas 1996) </ref>. 2 We have not not yet explored this possibility in our prototype implementation, which is restricted to the core language. <p> Parent, Paulin-Mohring, and Werner 1993) or systems such as PVS <ref> (Owre, Rajan, Rushby, Shankar, and Srivas 1996) </ref>, and traditional type systems for programming languages. When compared to verification, our system is less expressive but more automatic, when compared to traditional programming languages our system is more expressive, but also more verbose.
Reference: <author> Pugh, W. and D. </author> <title> Wonnacott (1992). Eliminating false data dependences using the Omega test. </title> <booktitle> In ACM SIG-PLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 140-151. </pages> <publisher> ACM Press. </publisher>
Reference-contexts: conservative, that is, without the use of dependent types, programs will elaborate and evaluate exactly as in ML. * We use bi-directional type analysis to generate linear inequality constraints with a minimum of annotations. * The resulting constraints can be solved efficiently in practice with a variant of Fourier's method <ref> (Pugh and Wonnacott 1992) </ref>. Besides the fact that programs run faster (which tends to be a strong motivator for programmers), our system enhances many of the benefits one derives from static typing.
Reference: <author> Pugh, W. and D. </author> <title> Wonnacott (1994, November). Experience with constraint-based array dependence analysis. </title> <type> Technical Report CS-TR-3371, </type> <institution> University of Mary-land. </institution>
Reference-contexts: Our immediate goal is to extend our system to accommodate full Standard ML which involves treating exceptions and module-level constructs. We would also like to incorporate the ideas and observations from <ref> (Pugh and Wonnacott 1994) </ref> into our constraint solver and improve its efficiency. We also plan to pursue using our language as a front-end for a certifying compiler for ML along the lines of work by Necula and Lee (Necula and Lee 1998) for a safe subset of C.
Reference: <author> Shostak, R. E. </author> <year> (1977, </year> <month> October). </month> <title> On the SUP-INF method for proving Presburger formulas. </title> <journal> Journal of the ACM 24 (4), </journal> <month> 529-543. </month> <title> Sun Microsystems (1995). The Java language specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/javaspec.ps.zip. </note>
Reference-contexts: If the constraints are linear, we negate them and test for unsatisfiability. Our technique for solving linear constraints is mainly based on Fourier variable elimination, but there are many other methods available for this purpose such as the SUP-INF method <ref> (Shostak 1977) </ref> and the well-known simplex method. We have chosen Fourier's method mainly for its simplicity. We now briefly explain this method. We use x for integer variables, a for integers, and l for linear expressions.
Reference: <author> Susuki, N. and K. </author> <title> Ishihata (1977). Implementation of array bound checker. </title> <booktitle> In 4th ACM Symposium on Prici-ples of Programming Languages, </booktitle> <pages> pp. 132-143. </pages>
Reference-contexts: C533. grammer annotations and are thus limited by their ability to synthesize loop invariants|a problem that is in theory undecidable and in practice very difficult <ref> (Susuki and Ishi-hata 1977) </ref>. In contrast, we pursue a type-based approach within a language already statically typed, namely ML. We rely on the programmer to supply some additional type information, which is then used by the compiler to reduce static array bound checking to constraint satisfiability. <p> Note that if we program binary search in C, the array bound check cannot be hoisted out of loops using the algorithm presented in (Gupta 1994) since it is neither increasing nor decreasing in terms of the definition given there. On the other hand, the method in <ref> (Susuki and Ishihata 1977) </ref> could eliminate this array bound check by synthesizing an induction hypothesis similar to our annotated type for look. Unfortunately, synthesizing induction hypotheses is often prohibitively expensive in practice.
Reference: <author> Xi, H. </author> <year> (1997, </year> <month> November). </month> <title> Some examples of DML programming. </title> <note> Available at http://www.cs.cmu.edu/~hwxi/DML/examples/. </note>
Reference-contexts: For example, int is interpreted as i : int :int (i) (or [i:int] int (i), in concrete syntax). Thus existential types provide a smooth boundary between annotated and unannotated programs in the context of a larger implementation. For larger and more interesting examples, we refer the reader to <ref> (Xi 1997) </ref>. 3 Elaboration The elaboration process transforms a program written in the source language into an expression in an explicitly typed internal language, performing type-checking along the way. <p> The first set of experiments were done on a Dec Alpha 3000/600 using SML of New Jersey version 109.32. The second set of experiments were done on a Sun Sparc 20 using MLWorks version 1.0. Sources of the programs can be found in <ref> (Xi 1997) </ref>. Table 1 summarizes some characteristics of the programs. We show the number of constraints generated during type-checking and the time taken for generating and solving them using SML of New Jersey and MLWorks.
Reference: <author> Xi, H. </author> <year> (1998). </year> <title> Dependent Types in Practical Programming. </title>
Reference-contexts: In this way, our work is also related to work on refinement types (Freeman 1994; Davies 1997) in which ML types are refined into finitely many inductively defined sorts. This work is part of a larger effort to introduce dependent types over tractable constraint domains into ML <ref> (Xi 1998) </ref>. In particular, the basic language architecture and the elaboration algorithm which generates index constraints do not depend on particular properties of linear arithmetic and can be used to capture other program invariants. 2 Preliminaries In this section we sketch our type system and give some illustrative examples. <p> In particular, the basic language architecture and the elaboration algorithm which generates index constraints do not depend on particular properties of linear arithmetic and can be used to capture other program invariants. 2 Preliminaries In this section we sketch our type system and give some illustrative examples. Please see <ref> (Xi 1998) </ref> for a formal description. 2.1 An introductory example The code in Figure 1 is an implementation of the dot product on integer arrays. <p> A system of dependent types allows types to be indexed by terms. For the purpose of this paper, indices are restricted to the integer and boolean expressions given above, with the additional constraint of linearity. We have considered a more general language schema in <ref> (Xi 1998) </ref>. <p> We can propagate program properties (including array bound information) through a compiler where they can be used for optimizations or safety certificates in proof-carrying code (Necula 1997). This work arose from a larger effort to incorporate a more general form of dependent types into ML <ref> (Xi 1998) </ref>. Our extended type checking algorithm is robust (in the sense that it can collect constraints independently of their domain), because we separated the language of indices and programs.
Reference: <author> Ph. D. </author> <type> thesis, </type> <institution> Carnegie Mellon University. Forthcoming. </institution>
References-found: 26

