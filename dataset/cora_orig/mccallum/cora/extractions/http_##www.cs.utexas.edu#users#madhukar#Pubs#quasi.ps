URL: http://www.cs.utexas.edu/users/madhukar/Pubs/quasi.ps
Refering-URL: http://www.cs.utexas.edu/users/madhukar/Pubs/pubs.html
Root-URL: 
Title: Quasi-Fully Dynamic Algorithms for Two-Connectivity, Cycle Equivalence and Related Problems  
Author: Madhukar Reddy Korupolu Vijaya Ramachandran 
Date: June 2, 1997  
Note: An Extended Abstract will appear in Proc. European Symp. on Algorithms (ESA'97)  
Abstract: In this paper we introduce a new class of dynamic graph algorithms called quasi-fully dynamic algorithms, which are much more general than the backtracking algorithms and are much simpler than the fully dynamic algorithms. These algorithms are especially suitable for applications in which a certain core connected portion of the graph remains fixed, and fully dynamic updates occur on the remaining edges in the graph. We present very simple quasi-fully dynamic algorithms with O(log n) worst case time, per operation, for 2-edge connectivity and cycle equivalence. The former is deterministic while the latter is Monte-Carlo type randomized. For 2-vertex connectivity, we give a randomized Las Vegas algorithm with O(log 4 n) expected amortized time per operation. We introduce the concept of quasi-k-edge-connectivity, which is a slightly relaxed version of k-edge connectivity, and show that it can be maintained in O(log n) worst case time per operation. We also analyze the performance of a natural extension of our quasi-fully dynamic algorithms to fully dynamic algorithms. The quasi-fully dynamic algorithm we present for cycle equivalence (which has several applications in optimizing compilers) is of special interest since the algorithm is quite simple, and no special-purpose incremental or backtracking algorithm is known for this problem.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David Alberts, Giuseppe Cattaneo, and Giuseppe F. </author> <title> Italiano. An empirical study of dynamic graph algorithms. </title> <booktitle> In Proceedings of the Seventh Annual ACM SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 192-201, </pages> <year> 1996. </year>
Reference-contexts: An empirical study of the dynamic connectivity algorithms is presented in <ref> [1] </ref>. 2-Edge Connectivity and Quasi-k-Edge Connectivity: An incremental algorithm with O (ff (m; n)) amortized time per operation was given in [23, 16]. A backtracking algorithm with O (log n) worst case time per operation is presented in [17].
Reference: [2] <author> David A. Aldous. </author> <title> The random walk construction of uniform spanning trees and uniform labelled trees. </title> <journal> Siam J. Disc. Math., </journal> <volume> 3(4) </volume> <pages> 450-465, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: All these edges will be nontree edges and form the CoverSet (e). Hence jCoverSet (e)j is (m). Interestingly, a similar result holds even if F were chosen uniformly at random from the set of all labeled spanning trees of G (see, e.g., <ref> [2] </ref> for properties and construction of random spanning trees). Lemma 7 Let U be the uniform distribution on the set F of all labeled spanning forests of G = (V; E) (i.e., U [F i ] = 1=jF j).
Reference: [3] <author> D. Eppstein, Z. Galil, and G. </author> <title> Italiano. Improved sparsification. </title> <type> Technical Report 93-20, </type> <institution> University of California at Irvine, Dept of Information and Computer Science, </institution> <year> 1993. </year>
Reference-contexts: This research was supported in part by the NSF grant CCR/GER-90-23059. E-mail: fmadhukar,vlrg@cs.utexas.edu. An extended abstract of this work will appear in [14]. 1 Fully dynamic algorithms tend to involve complicated data structures and are quite difficult to implement. The deterministic fully dynamic algorithms for 2-edge connectivity (given in <ref> [3] </ref>), 2-vertex connectivity (given in [10]) and cycle equivalence (given in [8]) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in [9, 15]) and 2-vertex connectivity (given in [11]) are pretty involved too. <p> Currently the best deterministic fully dynamic connectivity algorithm takes O ( p n) time per update and O (1) per query <ref> [3] </ref>. <p> A backtracking algorithm with O (log n) worst case time per operation is presented in [17]. The best known deterministic fully dynamic algorithm takes O ( p n) time per update and O (log n) time per query <ref> [3] </ref>. A randomized fully dynamic algorithm with an O (log 4 n) expected amortized time per update and O (log n= log log n) worst case time per query is claimed in [9]: the details of the algorithm presented there are rather sketchy.
Reference: [4] <author> J. Feigenbaum and Sampath Kannan. </author> <title> Handbook of Discrete and Combinatorial Mathematics, </title> <booktitle> chapter Dynamic Graph Algorithms, </booktitle> <pages> pages 583-591. </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Dynamic graph algorithms have received a great deal of attention in the last few years (see e.g., <ref> [4] </ref>). These algorithms maintain a property of a given graph under a sequence of suitably restricted updates and queries. Throughout this paper we will be concerned with edge updates (insertions/deletions) only: insertion/deletion of isolated vertices can be implemented trivially in all the known dynamic graph algorithms.
Reference: [5] <author> G.N. Frederickson. </author> <title> Ambivalent data structures for dynamic 2-edge connectivity and k smallest spanning trees. </title> <booktitle> In Proceedings of 32nd Symp. on Foundations of Computer Science, </booktitle> <pages> pages 632-641, </pages> <year> 1991. </year>
Reference-contexts: We sometimes use cover F (e) to denote jCoverSet F (e)j. Throughout this paper, unless otherwise mentioned, covering will be with respect to F only and the subscript F will be dropped when there is no ambiguity. Fact 1 <ref> [5] </ref> Two vertices u and v are 2-edge connected iff cover F (e) 1 for every edge e 2 F uv . We store F in a dynamic tree data structure ([19]) with edge costs representing the cover values.
Reference: [6] <author> R. Gupta and M.L. Soffa. </author> <title> Region scheduling. </title> <booktitle> In Proc. 2nd International Conference on Supercomputing, </booktitle> <pages> pages 141-148, </pages> <year> 1987. </year>
Reference-contexts: Finding the cycle equivalence classes is central to several compilation problems. (See <ref> [12, 20, 6] </ref> for some applications of cycle equivalence.) As mentioned in [8], dynamic algorithms for this problem can speed up incremental compilers. No special-purpose incremental or backtracking algorithms are known for this problem.
Reference: [7] <author> M. Rauch Henzinger. </author> <title> Fully dynamic biconnectivity in graphs. </title> <booktitle> In Proceedings of 33rd Symp. on Foundations of Computer Science, </booktitle> <pages> pages 50-59, </pages> <year> 1992. </year>
Reference-contexts: Otherwise (i.e., if v has atmost one solid edge incident on it) cost (v) is arbitrary. Fact 2 <ref> [7] </ref> Two vertices u and v are biconnected iff after making F uv a solid path, no internal vertex on F uv has cost 0. 8 4.1 Overview of the Algorithm To determine whether u and v are biconnected, we will transform the tree path F uv into a solid path,
Reference: [8] <author> M. Rauch Henzinger. </author> <title> Fully dynamic cycle equivalence in graphs. </title> <booktitle> In Proceedings of 35th Symposium on Foundations of Computer Science, </booktitle> <pages> pages 744-755, </pages> <year> 1994. </year>
Reference-contexts: E-mail: fmadhukar,vlrg@cs.utexas.edu. An extended abstract of this work will appear in [14]. 1 Fully dynamic algorithms tend to involve complicated data structures and are quite difficult to implement. The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in [10]) and cycle equivalence (given in <ref> [8] </ref>) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in [9, 15]) and 2-vertex connectivity (given in [11]) are pretty involved too. <p> Finding the cycle equivalence classes is central to several compilation problems. (See [12, 20, 6] for some applications of cycle equivalence.) As mentioned in <ref> [8] </ref>, dynamic algorithms for this problem can speed up incremental compilers. No special-purpose incremental or backtracking algorithms are known for this problem. The only dynamic algorithms known for handling an incremental or a backtracking sequence of updates are the fully dynamic algorithms. <p> The only dynamic algorithms known for handling an incremental or a backtracking sequence of updates are the fully dynamic algorithms. A deterministic fully dynamic algorithm with O ( p n log n) time per update and O (log 2 n) time per query is presented in <ref> [8] </ref>. A randomized fully dynamic algorithm with O (log 3 n) amortized expected time for updates and queries is given in [9]. In this paper, we present a very simple randomized quasi-fully dynamic algorithm which takes O (log n) worst case time per operation. This algorithm is Monte-Carlo type. <p> A pair of edges (e 1 ; e 2 ) will be called a cut-edge pair iff the removal of e 1 and e 2 increases the number of connected components in the graph. As observed in <ref> [8] </ref> two edges are cycle equivalent iff they are a cut-edge pair in the graph. 3.1 Isolating Lemma In this subsection, we describe a simple probabilistic lemma which is the basis for our cycle equivalence algorithm. <p> Condition (2) accounts for cut edge pairs (e; f ) where both e and f are tree edges. By the result in <ref> [8] </ref>, two edges e and f are cycle equivalent iff they are cut edge pair. A cut edge pair (e; f ), of tree edges, separates vertices u and v iff one of them lies on F uv and the other lies on F F uv .
Reference: [9] <author> M. Rauch Henzinger and V. King. </author> <title> Randomized dynamic algorithms with polylogarithmic time per operation. </title> <booktitle> In Proceedings of 27th Annual Symp. on Theory of Computing, </booktitle> <pages> pages 519-527, </pages> <year> 1995. </year>
Reference-contexts: The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in [10]) and cycle equivalence (given in [8]) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in <ref> [9, 15] </ref>) and 2-vertex connectivity (given in [11]) are pretty involved too. In fact, the 2-vertex connectivity algorithm of [11] does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]). <p> Currently the best deterministic fully dynamic connectivity algorithm takes O ( p n) time per update and O (1) per query [3]. In <ref> [9] </ref> a randomized fully dynamic algorithm, taking O (log 3 n) amortized expected time per update and O (log n= log log n) worst case time per query, is presented. 2 This paper also gives a simpler deterministic fully dynamic connectivity algorithm with O ( p time per update. <p> A randomized fully dynamic algorithm with an O (log 4 n) expected amortized time per update and O (log n= log log n) worst case time per query is claimed in <ref> [9] </ref>: the details of the algorithm presented there are rather sketchy. A somewhat different randomized fully dynamic algorithm with polylog time per operation is given in [15]. <p> A deterministic fully dynamic algorithm with O ( p n log n) time per update and O (log 2 n) time per query is presented in [8]. A randomized fully dynamic algorithm with O (log 3 n) amortized expected time for updates and queries is given in <ref> [9] </ref>. In this paper, we present a very simple randomized quasi-fully dynamic algorithm which takes O (log n) worst case time per operation. This algorithm is Monte-Carlo type. We also show some connection of cycle equivalence to 3-edge connectivity. <p> Note that N G 0 F (v) changes if the solid edges incident on v change. For each vertex v, we store the modified neighborhood graph, N G 0 F (v), in a randomized fully dynamic connectivity data structure <ref> [9] </ref>. For each vertex v, we also use a dictionary DDS v to store the nonzero D v (x; y) values. To keep the space requirements small, the zero D v (x; y) values are not stored. <p> Proof: In our proof we will make use of the following result: Fact 3 (Fully Dynamic Connectivity Data Structure) <ref> [9] </ref> Let G = (V; E) be a graph with n vertices and m 0 initial edges. Then the expected time for a sequence of k insert, delete and connectivity queries on G is O (k log 3 n + m 0 log n). <p> Finding CoverSet (e): We store G in a randomized fully dynamic connectivity data structure (<ref> [9] </ref>) with F as the spanning forest. For a tree edge e, the CoverSet (e) can be found as follows: let e 0 be the random edge found by the algorithm in [9] to replace e in F . Remove e 0 and find its next replacement, remove that and so on until no more replacements exist. All these removed replacement edges form the CoverSet (e).
Reference: [10] <author> M. Rauch Henzinger and J. A. La Poutre. </author> <title> Certificates and fast algorithms for biconnectivity in fully-dynamic graphs. </title> <booktitle> In Proceedings of Third Annual European Symposium on Algorithms (ESA), </booktitle> <pages> pages 171-184, </pages> <year> 1995. </year>
Reference-contexts: E-mail: fmadhukar,vlrg@cs.utexas.edu. An extended abstract of this work will appear in [14]. 1 Fully dynamic algorithms tend to involve complicated data structures and are quite difficult to implement. The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in <ref> [10] </ref>) and cycle equivalence (given in [8]) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in [9, 15]) and 2-vertex connectivity (given in [11]) are pretty involved too. <p> A backtracking algorithm with O (log n) worst case time per operation is presented in [17]. The best known deterministic fully dynamic algorithm takes O ( p n log 2 n) amortized time per update and O (1) worst case time per query <ref> [10] </ref>. A randomized fully dynamic algorithm with an O (log 4 n) expected amortized time per update and O (log 2 n) worst case time per query is stated in [11]: however, this algorithm does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]).
Reference: [11] <author> M.R Henzinger and Valerie King. </author> <title> Fully dynamic biconnectivity and transitive closure. </title> <booktitle> In Proceedings 36th Symp. on Foundations of Computer Science, </booktitle> <pages> pages 664-672, </pages> <year> 1995. </year>
Reference-contexts: The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in [10]) and cycle equivalence (given in [8]) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in [9, 15]) and 2-vertex connectivity (given in <ref> [11] </ref>) are pretty involved too. In fact, the 2-vertex connectivity algorithm of [11] does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]). <p> The randomized fully dynamic algorithms for 2-edge connectivity (given in [9, 15]) and 2-vertex connectivity (given in <ref> [11] </ref>) are pretty involved too. In fact, the 2-vertex connectivity algorithm of [11] does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]). In view of this, simpler algorithms will be more useful for applications which do not require the generality of the fully dynamic algorithms. <p> A randomized fully dynamic algorithm with an O (log 4 n) expected amortized time per update and O (log 2 n) worst case time per query is stated in <ref> [11] </ref>: however, this algorithm does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]). In this paper, we present a randomized quasi-fully dynamic algorithm that takes O (log 4 n) amortized expected time per operation.
Reference: [12] <author> Richard Johnson, David Pearson, and Keshav Pingali. </author> <title> Finding regions fast: Single entry single exit and control regions in linear time. </title> <booktitle> In Proceedings of ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 171-185, </pages> <year> 1994. </year>
Reference-contexts: Finding the cycle equivalence classes is central to several compilation problems. (See <ref> [12, 20, 6] </ref> for some applications of cycle equivalence.) As mentioned in [8], dynamic algorithms for this problem can speed up incremental compilers. No special-purpose incremental or backtracking algorithms are known for this problem.
Reference: [13] <author> Valerie King. </author> <type> Personal communication, </type> <month> July </month> <year> 1996. </year>
Reference: [14] <author> Madhukar R. Korupolu and Vijaya Ramachandran. </author> <title> Quasi-fully dynamic algorithms for two-connectivity, cycle equivalence and related problems. </title> <booktitle> In Proceedings of the Fifth Annual Euro-pean Symposium on Algorithms (ESA'97. </booktitle> <publisher> Springer-Verlag LNCS. </publisher> <month> September </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: This research was supported in part by the NSF grant CCR/GER-90-23059. E-mail: fmadhukar,vlrg@cs.utexas.edu. An extended abstract of this work will appear in <ref> [14] </ref>. 1 Fully dynamic algorithms tend to involve complicated data structures and are quite difficult to implement. The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in [10]) and cycle equivalence (given in [8]) are good examples of this.
Reference: [15] <author> Madhukar R. Korupolu. </author> <title> Randomized fully dynamic two edge connectivity: A variant of the Henzinger-King sketch. </title> <type> Manuscript, </type> <institution> Univ of Texas at Austin, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: The deterministic fully dynamic algorithms for 2-edge connectivity (given in [3]), 2-vertex connectivity (given in [10]) and cycle equivalence (given in [8]) are good examples of this. The randomized fully dynamic algorithms for 2-edge connectivity (given in <ref> [9, 15] </ref>) and 2-vertex connectivity (given in [11]) are pretty involved too. In fact, the 2-vertex connectivity algorithm of [11] does not work for some graphs in which the maximum degree is !(polylog (n)) ([13]). <p> A somewhat different randomized fully dynamic algorithm with polylog time per operation is given in <ref> [15] </ref>. In this paper, we present a simple quasi-fully dynamic algorithm with the same time bounds as the backtracking case: O (log n) worst case time per operation.
Reference: [16] <author> J.A. La Poutre. </author> <title> Maintenance of 2- and 3- connected components of graphs, part ii: 2- and 3-edge connected components and 2-vertex connected components. </title> <type> Technical Report RUU-CS-90-27, </type> <institution> Utrecht University, </institution> <year> 1990. </year>
Reference-contexts: An empirical study of the dynamic connectivity algorithms is presented in [1]. 2-Edge Connectivity and Quasi-k-Edge Connectivity: An incremental algorithm with O (ff (m; n)) amortized time per operation was given in <ref> [23, 16] </ref>. A backtracking algorithm with O (log n) worst case time per operation is presented in [17]. The best known deterministic fully dynamic algorithm takes O ( p n) time per update and O (log n) time per query [3]. <p> We also show some connection of cycle equivalence to 3-edge connectivity. Our quasi-fully dynamic algorithm for cycle-equivalence is of special interest because of the absence of special-purpose incremental/backtracking algorithms for this problem. 2-Vertex Connectivity: Incremental algorithms with O (ff (m; n)) amortized time per operation are given in <ref> [23, 16] </ref>. A backtracking algorithm with O (log n) worst case time per operation is presented in [17]. The best known deterministic fully dynamic algorithm takes O ( p n log 2 n) amortized time per update and O (1) worst case time per query [10].
Reference: [17] <author> J.A. La Poutre and J. Westbrook. </author> <title> Dynamic two-connectivity with backtracking. </title> <booktitle> In Proceedings of 4th Symp. on Discrete Algorithms, </booktitle> <pages> pages 204-212, </pages> <year> 1994. </year>
Reference-contexts: The existing dynamic algorithms can be classified into three types depending on the nature of (edge) updates allowed: * Partially Dynamic: Only insertions are allowed (Incremental) or only deletions are al lowed (Decremental). * Backtracking: Arbitrary insertions are allowed. But only backtracking deletions (Undo operation) are allowed <ref> [17] </ref>. * Fully Dynamic: Arbitrary insertions and arbitrary deletions are allowed. fl Department of Computer Sciences, The University of Texas at Austin, Austin, TX 78712. This research was supported in part by the NSF grant CCR/GER-90-23059. E-mail: fmadhukar,vlrg@cs.utexas.edu. <p> Another useful feature of the quasi-fully dynamic algorithms is the following: these algorithms can be extended to handle the invalid deletions in a way which is more efficient than rebuilding the entire data structure. On the other hand, in the backtracking algorithm of <ref> [17] </ref>, performing an invalid operation requires the rebuild of the entire data structure. As expected, these invalid deletions can be very expensive in the worst case. Section 5 discusses this feature. Secondly, these algorithms are much simpler than the fully dynamic algorithms. <p> An empirical study of the dynamic connectivity algorithms is presented in [1]. 2-Edge Connectivity and Quasi-k-Edge Connectivity: An incremental algorithm with O (ff (m; n)) amortized time per operation was given in [23, 16]. A backtracking algorithm with O (log n) worst case time per operation is presented in <ref> [17] </ref>. The best known deterministic fully dynamic algorithm takes O ( p n) time per update and O (log n) time per query [3]. <p> A backtracking algorithm with O (log n) worst case time per operation is presented in <ref> [17] </ref>. The best known deterministic fully dynamic algorithm takes O ( p n log 2 n) amortized time per update and O (1) worst case time per query [10].
Reference: [18] <author> Ketan Mulmuley, U.V. Vazirani, and V.V. Vazirani. </author> <title> Matching is as easy as matrix inversion. </title> <journal> Combinatorica, </journal> <volume> 7(1) </volume> <pages> 105-113, </pages> <year> 1987. </year>
Reference-contexts: We assign a weight w (x i ) to each element x i 2 S, and define the weight of a subset S j to be P Lemma 2 <ref> [18] </ref> (Unique Set Isolating Lemma) Let (S; Q) be a set system. If the elements in S are assigned integer weights chosen randomly and uniformly from [1 : : :2jSj], then P r [Minimum weight subset in Q is unique] 1=2.
Reference: [19] <author> D.D. Sleator and R.E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. System Sci., </journal> <volume> 26 </volume> <pages> 362-391, </pages> <year> 1983. </year>
Reference-contexts: This query is equivalent to asking whether there exists a cut edge in the entire graph. To answer this query, it suffices to find the global minimum cover value (i.e., min e2F cover F (e)) and check whether it is zero. The original dynamic tree data structure (of <ref> [19] </ref>) supports the path minimum operation but does not support the global minimum operation.
Reference: [20] <author> R.E Tarjan and Valdes Jacobo. </author> <title> Prime subprogram parsing of a program. </title> <booktitle> In Conference record of the Seventh Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 28-30, </pages> <year> 1980. </year>
Reference-contexts: Finding the cycle equivalence classes is central to several compilation problems. (See <ref> [12, 20, 6] </ref> for some applications of cycle equivalence.) As mentioned in [8], dynamic algorithms for this problem can speed up incremental compilers. No special-purpose incremental or backtracking algorithms are known for this problem.
Reference: [21] <author> J. Westbrook. </author> <title> Algorithms and Data Structures for Dynamic Graph Problems. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, Princeton University, Princeton, NJ, </institution> <year> 1989. </year>
Reference-contexts: The current status of the dynamic algorithms for connectivity, 2-connectivity and cycle equivalence is summarized below. Connectivity: Backtracking connectivity can be solved in fi (log n= log log n) time per operation by a straightforward application of the backtracking algorithm for the union-find problem (see <ref> [22, 21] </ref>). Currently the best deterministic fully dynamic connectivity algorithm takes O ( p n) time per update and O (1) per query [3].
Reference: [22] <author> J. Westbrook and R.E. Tarjan. </author> <title> Amortized analysis of algorithms for set union with backtracking. </title> <journal> SIAM Jl. Computing, </journal> <volume> 18 </volume> <pages> 1-11, </pages> <year> 1989. </year>
Reference-contexts: The current status of the dynamic algorithms for connectivity, 2-connectivity and cycle equivalence is summarized below. Connectivity: Backtracking connectivity can be solved in fi (log n= log log n) time per operation by a straightforward application of the backtracking algorithm for the union-find problem (see <ref> [22, 21] </ref>). Currently the best deterministic fully dynamic connectivity algorithm takes O ( p n) time per update and O (1) per query [3].

References-found: 22

