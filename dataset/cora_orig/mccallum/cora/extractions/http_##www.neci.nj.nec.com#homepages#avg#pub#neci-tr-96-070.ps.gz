URL: http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-96-070.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/avg/webpub/node5.html
Root-URL: 
Email: cher@cemi.msk.su  avg@research.nj.nec.com  csilvers@theory.stanford.edu  
Title: Buckets, Heaps, Lists, and Monotone Priority Queues  
Author: Boris V. Cherkassky Andrew V. Goldberg Craig Silverstein NECI TR #- 
Note: This work was done while the author was visiting NEC Research Institute. Supported by the Department of Defense, with partial support from NSF Award CCR-9357849, with match ing funds from IBM, Schlumberger Foundation, Shell Foundation, and Xerox Corporation.  
Date: June 1996; revised November 1996  
Address: Krasikova St. 32 117418, Moscow, Russia  4 Independence Way Princeton, NJ 08540  Stanford, CA 94305  
Affiliation: Central Econ. and Math. Inst.  NEC Research Institute  Computer Science Department Stanford University  
Abstract: We introduce the heap-on-top (hot) priority queue data structure that combines the multi-level bucket data structure of Denardo and Fox and a heap. Our data structure improves operation bounds. We use the new data structure to obtain a better bound for Dijkstra's shortest path algorithm. We also discuss a practical implementation of hot queues. Our experimental results in the context of Dijkstra's algorithm show that this implementation of hot queues performs very well and is more robust than implementations based only on heap or multi-level bucket data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: In particular, implementations of Dijkstra's shortest path algorithm produce balanced operation sequences. All logarithms in this paper are base two. In this paper we use the word RAM model of computation <ref> [1] </ref> and assume that integers fit in one machine word. In particular, this implies that log C does not exceed the word size. The only nonobvious result about the model we use directly appears in [8], where it is attributed to B. Schieber.
Reference: [2] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tarjan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. <p> In the following discussion, n is the number of vertices, m the number of arcs, C the largest arc length, and * any positive constant. Using Fibonacci heaps [12], we match the radix heap bounds of <ref> [2] </ref>. Our data structure, however, is simpler. Using the s-heap explicitly described by Thorup [17], we obtain better bounds. In [14], it is noted that a version of Thorup's result implicit in [17] gives even better bounds for monotone s-heaps. <p> This improves the deterministic bound of O (m + n log 1 2 C) achieved using radix heaps <ref> [2] </ref>. Space bounds. Suppose n it the maximum number of elements in a k-level hot queue and assume that the underlying s-heap requires constant space per element. Then the additional space needed for the hot queue is O (kC 1=k + n).
Reference: [3] <author> P. Van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and Implementation of an Efficient Priority Queue. </title> <journal> Math. Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: Alternative implementations of priority queues use buckets (e.g. [2, 7, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. See <ref> [3] </ref> for a related data structure. s-heaps are particularly efficient when the number of elements on the s-heap is small. Bucket-based priority queues are particularly efficient when the maximum event duration C is small. <p> These bounds are currently the best for a wide range of parameter values. For the competitive bounds in the same RAM model of computation that we use, see <ref> [3, 14, 15, 17] </ref>. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure [6], based on the same ideas as those described in this paper, did not perform well in practice.
Reference: [4] <author> G. S. Brodal. </author> <title> Worst-Case Efficient Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 52-58, </pages> <year> 1996. </year> <month> 37 </month>
Reference-contexts: queue is small as s-heaps. 1 For example, in a binary heap containing n elements, all priority queue operations take O (n) time, so the binary heap is an s-heap. (Operation bounds may depend on parameters other than the number of elements.) The fastest implementations of s-heaps are described in <ref> [4, 12, 17] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 7, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements.
Reference: [5] <author> R. Brown. </author> <title> Calandar Queues: A Fast O(1) Priority Queue Implementation for the Simu-lation Event Set Problem. </title> <journal> Comm. ACM, </journal> <volume> 31 </volume> <pages> 1220-1227, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [12]) and event simulation (e.g. <ref> [5] </ref>). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm [11], is the class of monotone priority queues. In monotone priority queues, the extracted keys form a monotone, nondecreasing sequence.
Reference: [6] <author> B. V. Cherkassky and A. V. Goldberg. </author> <title> Heap-on-Top Priority Queues. </title> <type> Technical Report 96-042, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year> <note> Available via URL http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-96-042.ps. </note>
Reference-contexts: For the competitive bounds in the same RAM model of computation that we use, see [3, 14, 15, 17]. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure <ref> [6] </ref>, based on the same ideas as those described in this paper, did not perform well in practice. Based on experimental feedback, we modified the data structure to be more practical. We also developed implementation techniques that make hot queues more efficient in practice.
Reference: [7] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <booktitle> In Proc. 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 516-525, </pages> <year> 1994. </year>
Reference-contexts: Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. <p> Our experimental results show that hot queues perform best overall and are more robust than either of the other two data structures. This is especially significant because a multi-level bucket implementation of Dijkstra's algorithm compared favorably with other implementations of the algorithm in a previous study <ref> [7] </ref> and was shown to be very robust. For many problem classes, the hot queue implementation of Dijkstra's algorithm is the best both in theory and in practice. This paper is organized as follows. Section 2 introduces basic definitions. <p> For example, for the log C-level hot queue using Fibonacci heaps, the per-element bound is O ( p The corresponding space bounds for the faster hot queues described above are even better. 5 Implementation Details Our previous papers <ref> [7, 13] </ref> describe implementations of multi-level buckets. Our implementation of hot queues augments the multi-level bucket implementation of [13]. See [13] for details of the multi-level bucket implementation. Consider a k-level hot queue. <p> Most of the problem families we use are the same as in our previous paper [13]. The next two sections describe the problem families. 6.1 The Graph Types Two types of graphs we explored were grids produced using the GRIDGEN generator <ref> [7] </ref>. These graphs can be characterized by a length x and width y. The graph is formed by constructing x layers, each of which is a path of length y. <p> Our implementation uses carefully chosen parameter values as well as the sorted list data structure for small heaps. Our experiments show that, in the context of Dijkstra's algorithm, the resulting implementation is more robust than the heap or the multi-level bucket data structures. Our previous studies <ref> [7, 13] </ref> have shown that multi-level bucket implementations of Dijkstra's algorithm compare favorably with other implementations.
Reference: [8] <author> R. Cole and U. Vishkin. </author> <title> Deterministic Coin Tossing with Applications to Optimal Parallel List Ranking. </title> <journal> Information and Control, </journal> <volume> 70 </volume> <pages> 32-53, </pages> <year> 1986. </year>
Reference-contexts: In this paper we use the word RAM model of computation [1] and assume that integers fit in one machine word. In particular, this implies that log C does not exceed the word size. The only nonobvious result about the model we use directly appears in <ref> [8] </ref>, where it is attributed to B. Schieber. The result is that given two machine words, we can find, in constant time, the 3 index of the most significant bit in which the two words differ. <p> It is straightforward to see that if we use appropriate masks and the fact that the index of the first bit in which two words differ can be computed in constant time <ref> [8] </ref>, we can compute the position in constant time. Iterating through the levels, we can find the lowest nonempty level in O (k) time. Using binary search, we can find the level in O (log k) time.
Reference: [9] <author> E. V. Denardo and B. L. Fox. </author> <title> Shortest-Route Methods: 1. Reaching, Pruning, </title> <journal> and Buckets. Oper. Res., </journal> <volume> 27 </volume> <pages> 161-186, </pages> <year> 1979. </year>
Reference-contexts: Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. <p> In this sense, s-heaps and buckets complement each other. We introduce heap-on-top priority queues (hot queues), which combine the multi-level bucket data structure of Denardo and Fox <ref> [9] </ref> and a monotone s-heap. 2 The resulting im <p>- 1 Here "s" stands for "size." 2 Actually, our data structure can use any heap. <p> In the context of Dijkstra's algorithm, we assume that we are given a graph with n vertices, m arcs, and integral arc lengths in the range [0; : : : ; C]. 3 Multi-Level Buckets In this section we describe the k-level bucket data structure of Denardo and Fox <ref> [9] </ref>. We give a simpler description of this data structure by treating the element keys as base- numbers for a certain parameter . Consider a bucket structure B that contains k levels of buckets, where k is a positive integer. <p> A simple way of finding the first nonempty bucket at level i is to go through the buckets. This takes O () time. Lemma 3.4 We can find the first nonempty bucket at a level in O () time. Remark. One can do better <ref> [9] </ref>. Divide buckets at every level into groups of size dlog Ce, each group containing consecutive buckets. For each group, maintain a dlog Ce-bit number with bit j equal to 1 if and only if the j-th bucket in the group is not empty.
Reference: [10] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: Alternative implementations of priority queues use buckets (e.g. <ref> [2, 7, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements.
Reference: [11] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connexion with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [12]) and event simulation (e.g. [5]). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm <ref> [11] </ref>, is the class of monotone priority queues. In monotone priority queues, the extracted keys form a monotone, nondecreasing sequence. In this paper we develop a new data structure for monotone priority queues.
Reference: [12] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. <ref> [12] </ref>) and event simulation (e.g. [5]). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm [11], is the class of monotone priority queues. In monotone priority queues, the extracted keys form a monotone, nondecreasing sequence. <p> queue is small as s-heaps. 1 For example, in a binary heap containing n elements, all priority queue operations take O (n) time, so the binary heap is an s-heap. (Operation bounds may depend on parameters other than the number of elements.) The fastest implementations of s-heaps are described in <ref> [4, 12, 17] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 7, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. <p> We illustrate efficiency of hot queues by implied bounds for Dijkstra's shortest path algorithm; detailed operation bounds appear in Section 4. In the following discussion, n is the number of vertices, m the number of arcs, C the largest arc length, and * any positive constant. Using Fibonacci heaps <ref> [12] </ref>, we match the radix heap bounds of [2]. Our data structure, however, is simpler. Using the s-heap explicitly described by Thorup [17], we obtain better bounds. In [14], it is noted that a version of Thorup's result implicit in [17] gives even better bounds for monotone s-heaps. <p> The result follows from Lemma 4.1, Theorem 3.5, and the fact that the number of elements on H never exceeds t. Remark. All bounds are valid only when t N . For t &gt; N , one should use an s-heap instead of a hot queue. For Fibonacci heaps <ref> [12] </ref>, the amortized time bounds are I (N ) = D (N ) = O (1), and X (N ) = O (log N ).
Reference: [13] <author> A. V. Goldberg and C. Silverstein. </author> <title> Implementations of Dijkstra's Algorithm Based on Multi-Level Buckets. </title> <type> Technical Report 95-187, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1995. </year>
Reference-contexts: For example, for the log C-level hot queue using Fibonacci heaps, the per-element bound is O ( p The corresponding space bounds for the faster hot queues described above are even better. 5 Implementation Details Our previous papers <ref> [7, 13] </ref> describe implementations of multi-level buckets. Our implementation of hot queues augments the multi-level bucket implementation of [13]. See [13] for details of the multi-level bucket implementation. Consider a k-level hot queue. <p> Our implementation of hot queues augments the multi-level bucket implementation of <ref> [13] </ref>. See [13] for details of the multi-level bucket implementation. Consider a k-level hot queue. As in the multi-level bucket implementation, we set to the smallest power of two greater or equal to C 1=k . <p> Our implementation of hot queues augments the multi-level bucket implementation of <ref> [13] </ref>. See [13] for details of the multi-level bucket implementation. Consider a k-level hot queue. As in the multi-level bucket implementation, we set to the smallest power of two greater or equal to C 1=k . <p> Each of these has parameters to tune, and the results we show are for the best parameter values we tested. Most of the problem families we use are the same as in our previous paper <ref> [13] </ref>. The next two sections describe the problem families. 6.1 The Graph Types Two types of graphs we explored were grids produced using the GRIDGEN generator [7]. These graphs can be characterized by a length x and width y. <p> C was the same as for long grids. The third type of graphs includes random graphs with uniform arc length distribution. A random graph with n vertices has 4n arcs. The fourth type of graphs is the only type that is new compared to <ref> [13] </ref>. These are based on a cycle of n vertices, numbered 1 to n. <p> Our implementation uses carefully chosen parameter values as well as the sorted list data structure for small heaps. Our experiments show that, in the context of Dijkstra's algorithm, the resulting implementation is more robust than the heap or the multi-level bucket data structures. Our previous studies <ref> [7, 13] </ref> have shown that multi-level bucket implementations of Dijkstra's algorithm compare favorably with other implementations.
Reference: [14] <author> R. Raman. </author> <title> A Summary of Shortest-Path Results. </title> <type> Technical Report TR 96-13, </type> <address> King's Colledge, London, </address> <year> 1996. </year>
Reference-contexts: Using Fibonacci heaps [12], we match the radix heap bounds of [2]. Our data structure, however, is simpler. Using the s-heap explicitly described by Thorup [17], we obtain better bounds. In <ref> [14] </ref>, it is noted that a version of Thorup's result implicit in [17] gives even better bounds for monotone s-heaps. When used in hot queues, this implicit result gives an O (m + n (log C) 1 4 +* ) expected time implementation of Dijkstra's shortest path algorithm. <p> These bounds are currently the best for a wide range of parameter values. For the competitive bounds in the same RAM model of computation that we use, see <ref> [3, 14, 15, 17] </ref>. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure [6], based on the same ideas as those described in this paper, did not perform well in practice. <p> Setting k = log 1 2 O (log 3 C), O (1), and O ((log C log log C) 3 ) amortized time bounds. For randomized monotone heaps of <ref> [14, 17] </ref>, the expected amortized time bounds are I (N ) = D (N ) = O (1), and X (N ) = O (1 + log N (log C) (1=2)* ). <p> Using deterministic heaps of Raman and setting k = log 1 2 O (1), and O ((log C log log C) 3 ) amortized time bounds. Using randomized heaps of <ref> [14, 17] </ref> and setting k = log 1 3 O (1), and O ((log C log log C) 4 ) expected amortized time bounds. The above time bounds allow us to get an improved bound on Dijkstra's shortest path 11 algorithm.
Reference: [15] <author> R. Raman. </author> <title> Priority Queues: Small, Monotone and Trans-Dichotomous. </title> <booktitle> In Proc. 4th Annual European Symposium Algorithms, </booktitle> <pages> pages 121-137. </pages> <publisher> Springer-Verlag, </publisher> <address> Lect. </address> <note> Notes in CS 1136, </note> <year> 1996. </year>
Reference-contexts: In order to describe hot queues, we give an alternative and more insightful description of the multi-level bucket data structure. Independently, a similar description has been given in <ref> [15] </ref>. Efficiency of a hot queue depends on that of the heap used to implement it. We illustrate efficiency of hot queues by implied bounds for Dijkstra's shortest path algorithm; detailed operation bounds appear in Section 4. <p> When used in hot queues, this implicit result gives an O (m + n (log C) 1 4 +* ) expected time implementation of Dijkstra's shortest path algorithm. In a recent paper, Raman <ref> [15] </ref> describes a monotone s-heap with deterministic time bounds. When used in hot queues, it gives an O (m + n (log C log log C) 1 3 ) time deterministic implementation of Dijkstra's algorithm. These bounds are currently the best for a wide range of parameter values. <p> These bounds are currently the best for a wide range of parameter values. For the competitive bounds in the same RAM model of computation that we use, see <ref> [3, 14, 15, 17] </ref>. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure [6], based on the same ideas as those described in this paper, did not perform well in practice. <p> Here * is any positive constant. Setting k = log 1 2 we get O (log 3 C), O (1), and O (log 3 +* C) expected amortized time bounds. For deterministic monotone heaps of Raman <ref> [15] </ref>, the amortized time bounds are I (N ) = D (N ) = O (1), and X (N ) = O ((log N log log N ) 2 ).
Reference: [16] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: The above time bounds allow us to get an improved bound on Dijkstra's shortest path 11 algorithm. The running time of Dijkstra's algorithm is dominated by a balanced sequence of priority queue operations that includes O (n) insert and extract-min operations and O (m) decrease-key operations (see e.g. <ref> [16] </ref>). The maximum event duration for this sequence of operations is C. The hot queue bounds immediately imply the following result.
Reference: [17] <author> M. </author> <title> Thorup. On RAM Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year> <month> 38 </month>
Reference-contexts: queue is small as s-heaps. 1 For example, in a binary heap containing n elements, all priority queue operations take O (n) time, so the binary heap is an s-heap. (Operation bounds may depend on parameters other than the number of elements.) The fastest implementations of s-heaps are described in <ref> [4, 12, 17] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 7, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2, and are not very sensitive to the number of elements. <p> Using Fibonacci heaps [12], we match the radix heap bounds of [2]. Our data structure, however, is simpler. Using the s-heap explicitly described by Thorup <ref> [17] </ref>, we obtain better bounds. In [14], it is noted that a version of Thorup's result implicit in [17] gives even better bounds for monotone s-heaps. <p> Using Fibonacci heaps [12], we match the radix heap bounds of [2]. Our data structure, however, is simpler. Using the s-heap explicitly described by Thorup <ref> [17] </ref>, we obtain better bounds. In [14], it is noted that a version of Thorup's result implicit in [17] gives even better bounds for monotone s-heaps. When used in hot queues, this implicit result gives an O (m + n (log C) 1 4 +* ) expected time implementation of Dijkstra's shortest path algorithm. In a recent paper, Raman [15] describes a monotone s-heap with deterministic time bounds. <p> These bounds are currently the best for a wide range of parameter values. For the competitive bounds in the same RAM model of computation that we use, see <ref> [3, 14, 15, 17] </ref>. We believe that data structures are especially interesting if they work well both in theory and in practice. A preliminary version of the hot queue data structure [6], based on the same ideas as those described in this paper, did not perform well in practice. <p> Radix heaps achieve the same bounds but are more complicated. For Thorup's heaps <ref> [17] </ref>, the expected amortized time bounds are I (N ) = D (N ) = O (1), and X (N ) = O (log 2 +* N ). Here * is any positive constant. <p> Setting k = log 1 2 O (log 3 C), O (1), and O ((log C log log C) 3 ) amortized time bounds. For randomized monotone heaps of <ref> [14, 17] </ref>, the expected amortized time bounds are I (N ) = D (N ) = O (1), and X (N ) = O (1 + log N (log C) (1=2)* ). <p> Using deterministic heaps of Raman and setting k = log 1 2 O (1), and O ((log C log log C) 3 ) amortized time bounds. Using randomized heaps of <ref> [14, 17] </ref> and setting k = log 1 3 O (1), and O ((log C log log C) 4 ) expected amortized time bounds. The above time bounds allow us to get an improved bound on Dijkstra's shortest path 11 algorithm.
References-found: 17

