URL: http://www.cs.colorado.edu/~hal/Papers/stoc.ps
Refering-URL: http://www.cs.colorado.edu/~hal/Home.html
Root-URL: http://www.cs.colorado.edu
Title: Unique Maximum Matching Algorithms  
Author: Harold N. Gabow Haim Kaplan Robert E. Tarjan 
Abstract: We consider the problem of testing the uniqueness of maximum matchings, both in the unweighted and in the weighted case. For the unweighted case, we have two results. Given a graph with n vertices and m edges, we can test whether the graph has a unique perfect matching, and find it if it exists, in O(m log 4 n) time. This algorithm uses a recent dynamic connectivity algorithm and an old result of Kotzig characterizing unique perfect matchings in terms of bridges. Also, given one perfect matching, we can test for the existence of another in linear time. This algorithm is a modification of Edmonds' blossom-shrinking algorithm implemented using depth-first search. We prove a generalization of Kotzig's theorem characterizing unique f-factors in terms of bridges. This theorem allows us to give a modification of the first algorithm that tests whether a given graph has a unique f-factor, and find it if it exists. We also show how to modify the second algorithm to check whether a given f-factor is unique. Both extensions have the same time bounds as their perfect matching counterparts. For the weighted case, we can test in linear time whether a maximum-weight matching is unique, given the output from Edmonds' algorithm for computing such a matching. The method is an extension of our algorithm for the unweighted case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.O. Ball and U. Derigs. </author> <title> An analysis of alternative strategies for implementing matching algorithms. </title> <journal> Networks, </journal> <volume> 13 </volume> <pages> 517-549, </pages> <year> 1983. </year>
Reference: [2] <author> T. C. Biedl, P. Bose, E. D. Demaine, and A. Lubiw. </author> <title> Efficient algorithms for Petersen's matching theorem. </title> <booktitle> In Proc. 10th Annual ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 130-139, </pages> <year> 1999. </year>
Reference-contexts: An improvement in dynamic connectivity testing, specifically for 2-components under edge deletion, would likely give an improvement in our algorithm. Dynamic 2-edge connectivity testing has also been used recently in an efficient algorithm for finding perfect matchings in 3-regular bridgeless graphs <ref> [2] </ref>. This gives an efficient constructive proof of Petersen's theorem, which states that any such graph has a perfect matching.
Reference: [3] <author> R.B. Carey and G.D. Stormo. </author> <title> Graph-theoretic approach to RNA modeling using comparative data. </title> <booktitle> In Proceedings 3rd International Conf. on Intelligent Systems for Molecular Biology, </booktitle> <pages> pages 75-80, </pages> <year> 1995. </year>
Reference-contexts: In Section 5 we show how, given the output of Ed-monds' algorithm, to test whether the maximum-weight matching is unique in O (m) time. The method is an application of the algorithm in Section 3. Our algorithm of Section 5 has an application to computational biology. References <ref> [3] </ref> and [17] describe an automated system that successfully predicts RNA structure. The system is based on a model in which the base pairs in an RNA molecule correspond to the edges of a maximum-weight matching in a certain graph.
Reference: [4] <author> J. Edmonds. </author> <title> Maximum matching and a polyhedron with 0,1-vertices. </title> <institution> J. Res. Nat. Bur. Standards, 69B:125-130, </institution> <year> 1965. </year>
Reference-contexts: For the weighted case, we consider the following problem. Suppose every edge e of G has a real-valued weight w (e). A maximum-weight matching is a matching whose total weight is maximum. Edmonds' well-known algorithm for finding a maximum-weight matching <ref> [4] </ref> produces not only such a matching but also additional information that allows verification that the solution is correct. In Section 5 we show how, given the output of Ed-monds' algorithm, to test whether the maximum-weight matching is unique in O (m) time. <p> For an edge e 2 E, we denote the corresponding edge in G (if it exists) also by e; similarly for sets of edges. This will cause no confusion. We now review some basic ideas of Edmonds' algorithm <ref> [4] </ref> (see also [15]) for finding a maximum-weight matching. <p> Note that Edmonds' algorithm for maximum-weight matching <ref> [4, 15] </ref> as well as all known variations (e.g. [9]) produce this information when finding M fl . We give an algorithm to solve this problem in time O (m).
Reference: [5] <author> J. Edmonds. </author> <title> Paths, trees, and flowers. </title> <journal> Canadian J. Math, </journal> <pages> pages 233-240, </pages> <year> 1965. </year>
Reference-contexts: finding an alternating cycle in the graph (See e.g. [12].) (An alternating cycle is a simple cycle alternating edges in M , called matched edges, with edges not in M , called unmatched edges.) This algorithm, described in Section 3, combines Edmonds' classical blossom-shrinking algorithm for finding a maximum-cardinality matching <ref> [5] </ref> with depth-first search. Let G = (V; E) be an undirected graph and let f be a function mapping each vertex v to an integer f (v). An f-factor in G is a set of edges such that exactly f (v) of them are incident to each vertex v. <p> Our algorithm for finding an alternating cycle performs a depth-first search [18] of G, traversing alternating paths (paths that alternate matched and unmatched edges). The search continues until it discovers an alternating cycle or runs out of edges to traverse. Like Edmonds' algorithm <ref> [5] </ref>, it occasionally shrinks a blossom (an odd-length simple cycle alternating matched and unmatched edges, with one extra unmatched edge). <p> In Section 3.2, we derive critical properties of the algorithm, leading to a proof of correctness in Section 3.3. Section 3.4 provides details of the implementation of blossom-shrinking. Throughout, we assume familiarity with depth-first search, as described e.g. in [18], and with Edmonds' algorithm <ref> [5] </ref>, as described e.g. in [19]. 3.1 The Algorithm We apply depth-first search to a directed version of the graph. (Every originally undirected edge is directed in both directions.) We represent the matched edges by a function mate (v) on vertices that gives the unique w such that fv; wg 2
Reference: [6] <author> H. N. Gabow. </author> <title> Algorithmic proofs of two relations between connectivity and the 1-factors of a graph. </title> <journal> Discrete Math, </journal> <volume> 26 </volume> <pages> 33-40, </pages> <year> 1979. </year>
Reference-contexts: Then every component of G is even, every odd bridge of G is in M , and every even bridge of G is not in M . Proof. By parity. 2 The usefulness to us of this observation comes from the following converse: Lemma 2.2 (Kotzig [14]; see also <ref> [6, 16] </ref> ) A unique perfect matching contains a bridge. Applied recursively, Lemmas 2.1 and 2.2 give the following algorithm for finding a unique perfect matching. Initialize M = ; and begin with G as the current graph.
Reference: [7] <author> H. N. Gabow. </author> <title> An efficient reduction technique for degree-constrained subgraph and bidirected network flow problems. </title> <booktitle> In Proc. 15th Annual ACM Symp. on Theory of Comp., </booktitle> <pages> pages 448-456, </pages> <year> 1983. </year>
Reference-contexts: The running time remains O (m log 4 n). We prove the generalization of Kotzig's theorem by reducing the unique f-factor problem to a unique perfect matching problem on a corresponding graph. This reduction, together with a technique of Gabow <ref> [7] </ref> for sparsifing the resulting graph, allows us to adapt our second algorithm to test whether a given f-factor is unique in linear time. For the weighted case, we consider the following problem. Suppose every edge e of G has a real-valued weight w (e). <p> It suffices to show how to construct a graph H with perfect matching M , such that H has an alternating cycle if and only if G 0 does, and H has O (m) edges. We follow the approach of <ref> [7] </ref>. There it is shown that a shortest alternating cycle in G 0 contains at most four external edges for any vertex v (two of these edges can be matched and two unmatched). Thus we can assume each multiplicity in G is at most two. Furthermore [7] shows that in G <p> follow the approach of <ref> [7] </ref>. There it is shown that a shortest alternating cycle in G 0 contains at most four external edges for any vertex v (two of these edges can be matched and two unmatched). Thus we can assume each multiplicity in G is at most two. Furthermore [7] shows that in G 0 the internal edges of v can be replaced by 3d (v) f (v) + 2 edges without changing the set of alternating cycles.
Reference: [8] <author> H. N. Gabow and R. E. Tarjan. </author> <title> A linear time algorithm for a special case of disjoint set union. </title> <journal> J. Computer and System Sciences, </journal> <volume> 30 </volume> <pages> 209-221, </pages> <year> 1985. </year>
Reference-contexts: need a data structure to represent disjoint sets subject to two operations: f ind (x), which returns the name of the set containing x, and unite (x; y), which forms the union of the sets named x and y, naming the new set x and destroying the old sets. (See <ref> [8, 19, 20] </ref>.) We store the graph vertices in this structure. Each vertex is initially in a self-named singleton set. <p> With this implementation, the algorithm runs in O (m) time, not counting set operations. If we use the incremental tree disjoint set union algorithm <ref> [8] </ref>, the set operations take a total of O (m) time as well. If we want the algorithm to actually produce an alternating cycle as well as just reporting one, we can add a mechanism for expanding blossoms, as described in [19].
Reference: [9] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Faster scaling algorithms for general graph matching problems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 38 </volume> <pages> 815-853, </pages> <year> 1991. </year>
Reference-contexts: Differences (4) and (5), restricting the search order and delaying blossom-shrinking, are crucial to the correctness of our algorithm. Essentially the same algorithm as ours is used in <ref> [9] </ref> to find a maximal set of augmenting paths. We describe the algorithm in Section 3.1. In Section 3.2, we derive critical properties of the algorithm, leading to a proof of correctness in Section 3.3. Section 3.4 provides details of the implementation of blossom-shrinking. <p> Note that Edmonds' algorithm for maximum-weight matching [4, 15] as well as all known variations (e.g. <ref> [9] </ref>) produce this information when finding M fl . We give an algorithm to solve this problem in time O (m). Let P (the "positive" blossoms) be the laminar family consisting of all blossoms B 2 B with z (B) &gt; 0. <p> settings where a unique maximum-weight matching is desired. (See Section 1.) A maximum-weight matching can be found from scratch in time O (n (m + n log n)) [11], or O ( nff (m; n) log n m log (nN )) when edge weights are integers between 0 and N <ref> [9] </ref>.
Reference: [10] <author> H.N. Gabow. </author> <title> A scaling algorithm for weighted matching on general graphs. </title> <booktitle> In Proc. 26th Annual Symp. on Found. of Comp. Sci., </booktitle> <pages> pages 90-100, </pages> <year> 1985. </year>
Reference: [11] <author> H.N. Gabow. </author> <title> Data structures for weighted matching and nearest common ancestors with linking. </title> <booktitle> In Proc. 1st Annual ACM-SIAM Symp. on Disc. Algorithms, </booktitle> <pages> pages 434-443, </pages> <year> 1990. </year>
Reference-contexts: Our algorithm is useful for sensitivity analysis in settings where a unique maximum-weight matching is desired. (See Section 1.) A maximum-weight matching can be found from scratch in time O (n (m + n log n)) <ref> [11] </ref>, or O ( nff (m; n) log n m log (nN )) when edge weights are integers between 0 and N [9].
Reference: [12] <author> M. C. Golumbic, T. Hirst, and M. Lewenstein. </author> <title> Uniquely restricted matchings. </title> <type> manuscript, </type> <year> 1998. </year>
Reference-contexts: Research at Princeton University partially supported by the NSF, Grant No. CCR-9626862. e-mail: ret@cs.princeton.edu. problem of testing whether G has a unique maximum matching, either in the unweighted or the weighted case. The unweighted case was considered by Golumbic, et al. <ref> [12] </ref>. They posed the question, given a matching M , of whether G has another matching on the same set of vertices. They proposed a simple O (nm)-time algorithm for this problem. <p> This problem is equivalent to finding an alternating cycle in the graph (See e.g. <ref> [12] </ref>.) (An alternating cycle is a simple cycle alternating edges in M , called matched edges, with edges not in M , called unmatched edges.) This algorithm, described in Section 3, combines Edmonds' classical blossom-shrinking algorithm for finding a maximum-cardinality matching [5] with depth-first search.
Reference: [13] <author> J. Holm, K. de Lichtenberg, and M. </author> <title> Thorup. Poly-logarithmic deterministic fully-dynamic algorithms for connectivity, minimum spanning tree, </title> <booktitle> 2-edge, and biconnectivity. In Proc. 30th Annual ACM Symp. on Theory of Comp., </booktitle> <pages> pages 79-89, </pages> <year> 1998. </year>
Reference-contexts: This algorithm relies for its correctness on an old theorem of Kotzig [14] characterizing perfect matchings in terms of bridges (edges whose removal increases the number of connected components). It relies for its efficiency on a recent dynamic 2-edge connectivity algorithm <ref> [13] </ref>. An improvement in dynamic connectivity testing, specifically for 2-components under edge deletion, would likely give an improvement in our algorithm. Dynamic 2-edge connectivity testing has also been used recently in an efficient algorithm for finding perfect matchings in 3-regular bridgeless graphs [2]. <p> We implement these steps using a data structure of <ref> [13] </ref>. <p> the graph; conn (v; w), which returns true exactly when v and w are in the same connected component of the graph; and comp size (v), which returns the number of vertices in the component containing v. (The last two operations are implemented in the dynamic connected component algorithm of <ref> [13] </ref>, although they are also easy to implement in the 2-component algorithm.) The time for each of these operations is O (log 4 n). This is an amortized bound for the first two operations and worst-case for the others. <p> We test if v and w are connected and in different 2-components using conn and 2-conn. It remains only to find a path P (v; w) and to find the bridges on P (v; w). This is done as follows. We assume some familiarity with <ref> [13] </ref>. The data structure of [13] represents a tree T in a spanning forest of G by a top-tree T . Each node of a top-tree represents a cluster. A cluster has one or two boundary nodes. <p> It remains only to find a path P (v; w) and to find the bridges on P (v; w). This is done as follows. We assume some familiarity with <ref> [13] </ref>. The data structure of [13] represents a tree T in a spanning forest of G by a top-tree T . Each node of a top-tree represents a cluster. A cluster has one or two boundary nodes. A cluster with boundary nodes a; b represents a subtree of T that contains both a and b. <p> Furthermore, as noted in the proof of Lemma 2.5, each bridge is discovered only once. Hence the total time for discovering bridges is O (n log n). The rest of the algorithm uses time O (m log 4 n) <ref> [13] </ref>. This gives the desired time bound. For the case of planar graphs, we can improve the running time to O (m log n). We omit the description of this result here. For the case of dense graphs, we can improve the running time by up to a polylogarithmic factor. <p> We omit here the straightforward proof that the graph induced by S has the same bridges and 2-edge components as G 0 . We initialize F 1 to be any spanning forest of G, and we use the dynamic connectivity algorithm of <ref> [13] </ref>, also used in Section 2.2, to maintain the connected components of G 0 F 1 . The spanning forest maintained by this algorithm is F 2 .
Reference: [14] <author> A. Kotzig. </author> <title> On the theory of finite graphs with a linear factor I. </title> <journal> Mat.-Fyz. Casopis Slovensk. Akad. Vied, </journal> <volume> 9 </volume> <pages> 73-91, </pages> <year> 1959. </year>
Reference-contexts: In Section 2 we describe an O (m log 4 n)-time algorithm to test whether a given graph has a unique perfect matching, and to find one if it exists. This algorithm relies for its correctness on an old theorem of Kotzig <ref> [14] </ref> characterizing perfect matchings in terms of bridges (edges whose removal increases the number of connected components). It relies for its efficiency on a recent dynamic 2-edge connectivity algorithm [13]. An improvement in dynamic connectivity testing, specifically for 2-components under edge deletion, would likely give an improvement in our algorithm. <p> Then every component of G is even, every odd bridge of G is in M , and every even bridge of G is not in M . Proof. By parity. 2 The usefulness to us of this observation comes from the following converse: Lemma 2.2 (Kotzig <ref> [14] </ref>; see also [6, 16] ) A unique perfect matching contains a bridge. Applied recursively, Lemmas 2.1 and 2.2 give the following algorithm for finding a unique perfect matching. Initialize M = ; and begin with G as the current graph.
Reference: [15] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Reinhart and Winston, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: For an edge e 2 E, we denote the corresponding edge in G (if it exists) also by e; similarly for sets of edges. This will cause no confusion. We now review some basic ideas of Edmonds' algorithm [4] (see also <ref> [15] </ref>) for finding a maximum-weight matching. <p> Note that Edmonds' algorithm for maximum-weight matching <ref> [4, 15] </ref> as well as all known variations (e.g. [9]) produce this information when finding M fl . We give an algorithm to solve this problem in time O (m).
Reference: [16] <author> L. Lovasz and M.D. Plummer. </author> <title> Matching Theory. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference-contexts: Then every component of G is even, every odd bridge of G is in M , and every even bridge of G is not in M . Proof. By parity. 2 The usefulness to us of this observation comes from the following converse: Lemma 2.2 (Kotzig [14]; see also <ref> [6, 16] </ref> ) A unique perfect matching contains a bridge. Applied recursively, Lemmas 2.1 and 2.2 give the following algorithm for finding a unique perfect matching. Initialize M = ; and begin with G as the current graph.
Reference: [17] <author> J.E. Tabaska, R.B. Cary, H.N. Gabow, and G.D. Stormo. </author> <title> An RNA folding method capable of identifying pseudoknots and base triples. </title> <journal> Bioinformatics, </journal> <volume> 14(8) </volume> <pages> 691-699, </pages> <year> 1998. </year>
Reference-contexts: In Section 5 we show how, given the output of Ed-monds' algorithm, to test whether the maximum-weight matching is unique in O (m) time. The method is an application of the algorithm in Section 3. Our algorithm of Section 5 has an application to computational biology. References [3] and <ref> [17] </ref> describe an automated system that successfully predicts RNA structure. The system is based on a model in which the base pairs in an RNA molecule correspond to the edges of a maximum-weight matching in a certain graph.
Reference: [18] <author> R. E. Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM J. Computing, </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: Each time we delete a bridge and the edges incident to its ends from G 0 , we first update the sparse certificate S. Then we perform a depth-first search to find new odd bridges of S. Since S contains O (n) edges, this step takes O (n) time <ref> [18] </ref>, and the total time for all such steps is O (n 2 ). The remaining detail is the definition and maintainance of S. <p> This is equivalent to testing for the existence of an alternating cycle. Our algorithm for finding an alternating cycle performs a depth-first search <ref> [18] </ref> of G, traversing alternating paths (paths that alternate matched and unmatched edges). The search continues until it discovers an alternating cycle or runs out of edges to traverse. <p> We describe the algorithm in Section 3.1. In Section 3.2, we derive critical properties of the algorithm, leading to a proof of correctness in Section 3.3. Section 3.4 provides details of the implementation of blossom-shrinking. Throughout, we assume familiarity with depth-first search, as described e.g. in <ref> [18] </ref>, and with Edmonds' algorithm [5], as described e.g. in [19]. 3.1 The Algorithm We apply depth-first search to a directed version of the graph. (Every originally undirected edge is directed in both directions.) We represent the matched edges by a function mate (v) on vertices that gives the unique w
Reference: [19] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <publisher> SIAM, </publisher> <address> Philadelphia, </address> <year> 1982. </year>
Reference-contexts: In Section 3.2, we derive critical properties of the algorithm, leading to a proof of correctness in Section 3.3. Section 3.4 provides details of the implementation of blossom-shrinking. Throughout, we assume familiarity with depth-first search, as described e.g. in [18], and with Edmonds' algorithm [5], as described e.g. in <ref> [19] </ref>. 3.1 The Algorithm We apply depth-first search to a directed version of the graph. (Every originally undirected edge is directed in both directions.) We represent the matched edges by a function mate (v) on vertices that gives the unique w such that fv; wg 2 M . <p> need a data structure to represent disjoint sets subject to two operations: f ind (x), which returns the name of the set containing x, and unite (x; y), which forms the union of the sets named x and y, naming the new set x and destroying the old sets. (See <ref> [8, 19, 20] </ref>.) We store the graph vertices in this structure. Each vertex is initially in a self-named singleton set. <p> If we want the algorithm to actually produce an alternating cycle as well as just reporting one, we can add a mechanism for expanding blossoms, as described in <ref> [19] </ref>. Producing such a cycle takes O (n) time once the algorithm halts in Case 2 (see [19]). 4 Unique f -factors Throughout this section we consider undirected multi-graphs, i.e., parallel edges with arbitrary multiplicities are allowed, as well as self-loops. <p> If we want the algorithm to actually produce an alternating cycle as well as just reporting one, we can add a mechanism for expanding blossoms, as described in <ref> [19] </ref>. Producing such a cycle takes O (n) time once the algorithm halts in Case 2 (see [19]). 4 Unique f -factors Throughout this section we consider undirected multi-graphs, i.e., parallel edges with arbitrary multiplicities are allowed, as well as self-loops. A self-loop (v; v) contributes two to the degree of v. <p> Now check if the new graph has an augmenting path. (No edge weights are involved here.) This takes linear time, as described in <ref> [19] </ref>. In summary, we have shown how to decide if G has a unique maximum-weight matching in time O (m). When the answer is "no", a simple extension of the algorithm can find another maximum-weight matching, in the same time bound.
Reference: [20] <author> R. E. Tarjan and J. van Leeuwen. </author> <title> Worst-case analysis of set union algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 31 </volume> <pages> 245-281, </pages> <year> 1984. </year>
Reference-contexts: need a data structure to represent disjoint sets subject to two operations: f ind (x), which returns the name of the set containing x, and unite (x; y), which forms the union of the sets named x and y, naming the new set x and destroying the old sets. (See <ref> [8, 19, 20] </ref>.) We store the graph vertices in this structure. Each vertex is initially in a self-named singleton set.
Reference: [21] <author> M. </author> <title> Thorup. </title> <type> Private communication, </type> <year> 1998. </year>
Reference-contexts: We note first that Thorup [22] has proposed a Las Vegas randomized algorithm for deletion-only connectivity that has a running time of O (m log (n 2 =m) + (nm) 1=2 log 2:5 n) = O (n 2 ) <ref> [21] </ref>. This algorithm can be adapted as in Section 2.2 to solve our problem in the same time bound. If we desire a deterministic algorithm, the following alternative approach results in an O (n 2 + m log 2 n)-time algorithm.
Reference: [22] <author> M. </author> <title> Thorup. Decremental dynamic connectivity. </title> <booktitle> In Proc. 8th Annual ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 305-313, </pages> <year> 1997. </year>
Reference-contexts: For the case of planar graphs, we can improve the running time to O (m log n). We omit the description of this result here. For the case of dense graphs, we can improve the running time by up to a polylogarithmic factor. We note first that Thorup <ref> [22] </ref> has proposed a Las Vegas randomized algorithm for deletion-only connectivity that has a running time of O (m log (n 2 =m) + (nm) 1=2 log 2:5 n) = O (n 2 ) [21].
References-found: 22

