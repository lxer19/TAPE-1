URL: http://www.cse.ogi.edu/~hongwei/academic/papers/padl99.ps
Refering-URL: http://www.cse.ogi.edu/~hongwei/academic/publications.html
Root-URL: http://www.cse.ogi.edu
Email: e-mail: hongwei@cse.ogi.edu  
Title: Dead Code Elimination through Dependent Types  
Author: Hongwei Xi 
Address: P.O. Box 91000 Portland, OR 97291, USA  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute  
Abstract: Pattern matching is an important feature in various functional programming languages such as SML, Caml, Haskell, etc. In these languages, unreachable or redundant matching clauses, which can be regarded as a special form of dead code, are a rich source for program errors. Therefore, eliminating unreachable matching clauses at compile-time can significantly enhance program error detection. Furthermore, this can also lead to significantly more efficient code at run-time. We present a novel approach to eliminating unreachable matching clauses through the use of the dependent type system of DML, a functional programming language that enriches ML with a restricted form of dependent types. We then prove the correctness of the approach, which consists of the major technical contribution of the paper. In addition, we demonstrate the applicability of our approach to dead code elimination through some realistic examples. This constitutes a practical application of dependent types to functional programming, and in return it provides us with further support for the methodology adopted in our research on dependent types in practical programming.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <title> Compilers. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction There is no precise definition of dead code in the literature. In this paper, we refer dead code as the code which can never be executed at run-time. Notice that this is essentially different from dead computation <ref> [1] </ref>, that is, the computation producing values which are never used. For instance, in the following C code, x = 1; x = 2; the part x = 1 is dead computation but not dead code since it is executed but its execution does not affect the entire computation. <p> The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 2. <author> Rowan Davies. </author> <title> Practical refinement-type checking. </title> <type> Thesis Proposal, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: Our approach is most closely related to the research on refinement types <ref> [4, 2] </ref>, which also aims for assigning programs more accurate types.
Reference: 3. <author> Manuel Fahndrich and Alexander Aiken. </author> <title> Program analysis using mixed term and set constraints. </title> <booktitle> In Proceedings of the 4th International Static Analysis Symposium, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: We plan to incorporate this approach into the compiler for DML which we are building on top of Caml-light. Clearly, our approach can also be readily adapted to detecting uncaught exceptions [21], and we expect it to work well in this direction when combined with the approach in <ref> [3] </ref>. We shall report the work in the future.
Reference: 4. <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277, </pages> <address> Toronto, Ontario, </address> <year> 1991. </year>
Reference-contexts: Our approach is most closely related to the research on refinement types <ref> [4, 2] </ref>, which also aims for assigning programs more accurate types.
Reference: 5. <author> F. Gecseg and M Steinb. </author> <title> Tree automata. </title> <publisher> Akademiai Kiado, </publisher> <year> 1991. </year>
Reference-contexts: Our approach is most closely related to the research on refinement types [4, 2], which also aims for assigning programs more accurate types. However, the restricted form of dependent types in DML allows the programmer to form types which are not captured by the regular tree grammar <ref> [5] </ref>, e.g., the type of all pairs of lists of equal length, but this is beyond the reach of refinement types. The price we pay is the loss of principal types, which may consequently lead to a more involved type-checking algorithm.
Reference: 6. <editor> Paul Hudak, S. L. Peyton Jones, and Philip Wadler. </editor> <title> Report on the programming language Haskell, a non-strict purely-functional programming language, Version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: not zero. ? The research reported in this paper was supported in part by the United States Air Force Materiel Command (F19628-93-C-0069). if (x == 0) - y = 1; - Pattern matching is an important feature in many functional programming languages such as Standard ML [12], Caml [16], Haskell <ref> [6] </ref>, etc. A particular form of dead code in these languages is unreachable or redundant matching clauses, that is, matching clauses which can never be chosen at run-time.
Reference: 7. <author> John Hughes. </author> <title> Compile-time analysis of functional programs. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 117-153. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 8. <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <booktitle> In Conference Record of 6th ACM SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 9. <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag LNCS 247, </publisher> <year> 1987. </year>
Reference-contexts: By induction hypothesis, v 0 does not match p 0 . This yields a contradiction, and therefore v does not match p. All other cases can be treated similarly. Dynamic Semantics The operational semantics of ML 0 (C) can be given as usual in the style of natural semantics <ref> [9] </ref>. Again we omit the standard evaluation rules, which can be found in [20] We use e ,! d v to mean that e reduces to a value v in this semantics. These evaluation rules are only needed for proving the correctness of our approach.
Reference: 10. <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Partial dead code elimination. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Implementation and Design, </booktitle> <pages> pages 147 - 158, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Also dead code is different from partially dead code, which is not executed only on some computation paths <ref> [10] </ref>. <p> The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 11. <author> Y. Liu and D. Stoller. </author> <title> Dead code elimination using program-based regular tree grammars. </title> <note> Available at http://ftp.cs.indiana.edu/pub/liu/ElimDeadRec-TR97.ps.Z. </note>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 12. <author> Robin Milner, Mads Tofte, Robert W. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: executed when x is not zero. ? The research reported in this paper was supported in part by the United States Air Force Materiel Command (F19628-93-C-0069). if (x == 0) - y = 1; - Pattern matching is an important feature in many functional programming languages such as Standard ML <ref> [12] </ref>, Caml [16], Haskell [6], etc. A particular form of dead code in these languages is unreachable or redundant matching clauses, that is, matching clauses which can never be chosen at run-time. <p> applied to a pair of lists of equal length. fun ('a,'b) zip_safe (nil, nil) = nil | zip_safe (x::xs, y::ys) = (x, y)::zip_safe (xs, ys) where zip_safe &lt;| -n:nat- 'a list (n)*'b list (n)-&gt;('a * 'b) list (n) The use of fun ('a,'b) is a recent feature of Standard ML <ref> [12] </ref>, which allows the programmer to explicitly control the scope of the type variables 'a and 'b.
Reference: 13. <author> Heintze Nevin. </author> <title> Set-based Program Analysis of ML programs. </title> <type> Ph. </type> <institution> D dissertation, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 14. <author> F. </author> <title> Tip. A survey of program slicing. </title> <journal> Journal of Programming Languages, </journal> <volume> 3(3) </volume> <pages> 121-189, </pages> <year> 1995. </year>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 15. <author> P. Wadler and J. Hughes. </author> <title> Projections for strictness analysis. </title> <booktitle> In Proceedings of the 3rd International Conference on Functional Programming and Computer Architecture, volume 274 of Lecture Notes in Computer Science, </booktitle> <pages> pages 385 - 407. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The reader can find further references in <ref> [8, 1, 7, 13, 10, 14, 11, 15] </ref>. Our approach to dead code elimination differs significantly from the previous approaches in several aspects. We have adopted a type-based approach while most of the previous approaches are based on flow analysis.
Reference: 16. <author> Pierre Weis and Xavier Leroy. </author> <title> Le langage Caml. </title> <address> InterEditions, Paris, </address> <year> 1993. </year>
Reference-contexts: x is not zero. ? The research reported in this paper was supported in part by the United States Air Force Materiel Command (F19628-93-C-0069). if (x == 0) - y = 1; - Pattern matching is an important feature in many functional programming languages such as Standard ML [12], Caml <ref> [16] </ref>, Haskell [6], etc. A particular form of dead code in these languages is unreachable or redundant matching clauses, that is, matching clauses which can never be chosen at run-time.
Reference: 17. <author> H. Xi and F. Pfenning. </author> <title> Eliminating array bound checking through dependent types. </title> <booktitle> In Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-257, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Let us call this version nth_safe, and we have measured that nth_safe is about 25% faster than nth on a Sparc 20 station running SML/NJ version 110. The use of a similar idea to eliminate array bound checks can be found in <ref> [17] </ref>. 4.2 An Evaluator for the Call-By-Value -Calculus The code in Figure 5 implements an evaluator for the pure call-by-value - calculus. We use de Bruijn's notation to represent -expressions. For example, x:y:y (x) is represented as Lam (Lam (App (One, Shift (One)))).
Reference: 18. <author> H. Xi and F. Pfenning. </author> <title> Dependent types in practical programming. </title> <booktitle> In Proceedings of ACM SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1999. </year> <note> (To appear) </note>
Reference-contexts: The rest of the paper discusses some related work and then concludes. 2 Preliminaries It is both infeasible and unnecessary to present in this paper the entire DML, which can be found in [20]. We refer the reader to <ref> [18] </ref> for an overview of DML. The essence of our approach will be fully captured in an core language ML 0 (C), which is a monomorphic extension of mini-ML with general pattern matching and universal dependent types.
Reference: 19. <author> Hongwei Xi. </author> <title> Some examples of DML programming. </title> <note> Available at http://www.cs.cmu.edu/~hwxi/DML/examples/, November 1997. </note>
Reference-contexts: An evaluator for the call-by-value -calculus 4.3 Other Examples So far all the presented examples involve the use of lists, but this is not necessary. We also have examples involving other data structures such as trees. For instance, the reader can find in <ref> [19] </ref> a red/black tree implementation containing unreachable matching clauses which can be eliminated in the same manner.
Reference: 20. <author> Hongwei Xi. </author> <title> Dependent Types in Practical Programming. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1998. </year> <pages> pp. </pages> <note> viii+189. Forthcoming. The current version is available as http://www.cs.cmu.edu/~hwxi/DML/thesis.ps. </note>
Reference-contexts: This partially motivated our research on strengthening the type system of ML with dependent types so that we can formulated more accurate types such as the type of all pairs of lists of equal length. The type system of DML (Dependent ML) in <ref> [20] </ref> enriches that of ML with a restricted form of dependent types. The primary goal of this enrichment is to provide for specification and inference of significantly more accurate information, facilitating both program error detection and compiler optimization. <p> In Section 4, we use some realistic examples to demonstrate the applicability of our approach. The rest of the paper discusses some related work and then concludes. 2 Preliminaries It is both infeasible and unnecessary to present in this paper the entire DML, which can be found in <ref> [20] </ref>. We refer the reader to [18] for an overview of DML. The essence of our approach will be fully captured in an core language ML 0 (C), which is a monomorphic extension of mini-ML with general pattern matching and universal dependent types. <p> Typing rules for patterns We omit the rest of typing rules for ML 0 (C), which can be found in <ref> [20] </ref>. The following lemma is at the heart of our approach to dead code elimination. Lemma 1. (Main Lemma) Suppose that p # t fl ; is derivable and j= ? satisfiable. If ind ; ` v : t is derivable, then v does not match the pattern p. Proof. <p> All other cases can be treated similarly. Dynamic Semantics The operational semantics of ML 0 (C) can be given as usual in the style of natural semantics [9]. Again we omit the standard evaluation rules, which can be found in <ref> [20] </ref> We use e ,! d v to mean that e reduces to a value v in this semantics. These evaluation rules are only needed for proving the correctness of our approach. The following type-preservation theorem is also needed for this purpose. <p> Theorem 1. (Type preservation in ML 0 (C)) Given e; v in ML 0 (C) such that e ,! d v is derivable. If ind ; ` e : t is derivable, then ind ; ` v : t is derivable. Proof. Please see Section 4.1.2 in <ref> [20] </ref> for details. Notice that there is some nondeterminism associated with the rule for evaluating a case statement. If more than one matching clauses can match the value, there is no order to determine which one should be chosen.
Reference: 21. <author> K. Yi and S. Ryu. </author> <title> Towards a cost-effective estimation of uncaught exceptions in standard ml programs. </title> <booktitle> In Proceedings of the 4th International Static Analysis Symposium, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: We have experimented our approach to dead code elimination in a prototype implementation of a type-checker for DML. We plan to incorporate this approach into the compiler for DML which we are building on top of Caml-light. Clearly, our approach can also be readily adapted to detecting uncaught exceptions <ref> [21] </ref>, and we expect it to work well in this direction when combined with the approach in [3]. We shall report the work in the future.
References-found: 21

