URL: http://polaris.cs.uiuc.edu/reports/1340.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: Practical Issues Related to Developing Object Oriented Numerical Libraries  
Author: K. Gallivan and B. Marsolf 
Address: 1308 West Main Street Urbana, Illinois 61801  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Date: April 1994  April 1994  
Note: In OON-SKI'94 Proceedings of the Second Annual Object-Oriented Numerics Conference pp 93-106, Sunriver, Oregon,  
Pubnum: CSRD Report No. 1340  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Sage++: </author> <title> A Class Library for Building Fortran 90 and C++ Restructuring Tools, </title> <month> August </month> <year> 1993. </year> <institution> From the Computer Science Department of Indiana University. </institution>
Reference: [2] <author> Ballance, R. A., Giancola, A. J., Luger, G. F., and Ross, T. J. </author> <title> A framework--based environment for object-oriented scientific codes. </title> <booktitle> In OON-SKI'93 Proceedings of the First Annual Object-Oriented Numerics Conference (April 1993), </booktitle> <pages> pp. 25-35. </pages>
Reference-contexts: With the second approach, researchers are developing new access methods to libraries through the use of programming environments. For example, MATLAB [18] provides access to subroutines to perform linear algebra. Larger scale projects, such as Frameworks <ref> [2] </ref> and //ELLPACK [15], provide a programming environment which can be used to generate code for an application. Our approach is to develop tools which will allow the library programmer access to the ease of use of interactive array languages while still providing the performance of traditional compiled languages.
Reference: [3] <author> Barrett, R., Berry, M., Chan, T., Demmel, J., Donato, J., Dongarra, J., Ei-jkhout, V., Pozo, R., Romine, C., and van der Vorst, H. </author> <title> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods. </title> <publisher> SIAM Publications, </publisher> <year> 1993. </year>
Reference-contexts: For example, Gropp [13] designed a standard interface for subroutines and data structures. Reverse communication is being used by Duff and Heroux [8, 14] to allow subroutines to access user supplied data structures. Templates are being provide by Dongarra and others <ref> [3, 7] </ref> which allow programmers to write the subroutines for iterative methods using data structures supplied by the programmer. With the second approach, researchers are developing new access methods to libraries through the use of programming environments. For example, MATLAB [18] provides access to subroutines to perform linear algebra.
Reference: [4] <author> Bodin, F., Beckman, P., Gannon, D., Narayana, S., and Yang, S. </author> <title> Distributed pC++: basic ideas for an object parallel language. </title> <booktitle> In OON-SKI'93 Proceedings of the First Annual Object-Oriented Numerics Conference (April 1993), </booktitle> <pages> pp. 1-24. </pages>
Reference: [5] <author> Char, B. W., Geddes, K. O., Gonnet, G. H., Leong, B. L., Monagan, M. B., and Watt, S. M. </author> <title> Maple V Language Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Moreover, by helping the designer write performance portable code, the library will work better when the library is moved to a new machine. This approach consists of combining four software systems, listed below, into a library development environment. First, MATLAB is used as the algorithm development environment, with Maple <ref> [5] </ref>, the second system, being used for symbolic optimizations. A MATLAB-to-C++ translator is the third part, combined with the fourth part, a performance database. The role of each of these systems is explained in detail in the remainder of this section.
Reference: [6] <author> DeRose, L., and Padua, D. </author> <title> An Inference Mechanism for the Compilation of Interactive Array Languages. </title> <type> Tech. Rep. 1335, </type> <institution> Center for Supercomputing Research and Development, University of Illinois, </institution> <year> 1994. </year> <booktitle> To be presented at WHPC '94 - IEEE/USP International Workshop on High Performance Computing Compilers and Tools for Parallel Processing, Sao Paulo, </booktitle> <address> Brazil, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: The first phase of the translator is the front end compiler which does the lexical and syntax analysis for the the MATLAB language. This front end compiler is already being developed by DeRose and Padua as part of project to develop a MATLAB to Fortran90 compiler <ref> [6] </ref>. The front end compiler reads in the MATLAB language and converts it into an abstract syntax tree. After the tree has been built, static type inference will be performed to add type information to the symbols present in the tree.
Reference: [7] <author> Dongarra, J. </author> <title> Linear Algebra Libraries for High-Performance Computers: A Personal Perspective. </title> <booktitle> IEEE Parallel and Distributed Technology 1, </booktitle> <month> 1 (February </month> <year> 1993), </year> <pages> 17-24. </pages>
Reference-contexts: For example, Gropp [13] designed a standard interface for subroutines and data structures. Reverse communication is being used by Duff and Heroux [8, 14] to allow subroutines to access user supplied data structures. Templates are being provide by Dongarra and others <ref> [3, 7] </ref> which allow programmers to write the subroutines for iterative methods using data structures supplied by the programmer. With the second approach, researchers are developing new access methods to libraries through the use of programming environments. For example, MATLAB [18] provides access to subroutines to perform linear algebra.
Reference: [8] <author> Duff, I. S., Marrone, M., and Radicati, G. </author> <title> A proposal for user level sparse BLAS. </title> <type> Tech. rep., </type> <institution> CERFACS, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: With the first approach researchers are trying to make the libraries easier to use or to make the libraries more adaptable. For example, Gropp [13] designed a standard interface for subroutines and data structures. Reverse communication is being used by Duff and Heroux <ref> [8, 14] </ref> to allow subroutines to access user supplied data structures. Templates are being provide by Dongarra and others [3, 7] which allow programmers to write the subroutines for iterative methods using data structures supplied by the programmer.
Reference: [9] <author> Gallivan, K., Jalby, W., Malony, A., and Wijshoff, H. </author> <title> Performance Prediction for Parallel Numerical Algorithms. </title> <journal> Int'l. Journal of High Speed Computing 3, </journal> <month> 1 (February </month> <year> 1991), </year> <pages> 31-62. </pages>
Reference-contexts: The performance data, therefore, should show the performance characteristics of primitives on the target architecture. At the present time, only basic primitives, and some basic performance characteristic information about the machine, such as those found in <ref> [9, 11, 17] </ref>, are planned to be included in the database, but these will hopefully be sufficient to show performance trends for the architectures. Working with the OOPACK benchmark from Robinson [16] we have already found examples where the compilers have difficulties with inlining functions and efficiently generating addresses.
Reference: [10] <author> Gallivan, K., Jalby, W., Marsolf, B., and Sameh, A. </author> <title> On the Development of Libraries and Their Use in Applications. </title> <type> Tech. Rep. 1341, </type> <institution> Center for Supercomputing Research and Development, University of Illinois, </institution> <year> 1994. </year>
Reference-contexts: This is followed in Section 3 by implementation details of our project. Section 4 provides the current status of our project and future work, along with some preliminary results, and Section 5 will present our conclusions. Further details, and motivation, about our approach can be found in <ref> [10] </ref>. 2 Our Proposed Approach Our approach to overcoming some of the shortcomings of libraries is to provide tools which help the library designer write better libraries and help port the libraries to new machines.
Reference: [11] <author> Gallivan, K., Jalby, W., Turner, S., Veidenbaum, A., and Wijshoff, H. </author> <title> Preliminary Basic Performance Analysis of the Cedar Multiprocessor Memory Systems. </title> <booktitle> Proceedings of ICPP'91, </booktitle> <address> St. Charles, IL I (August 12-16, </address> <year> 1991), </year> <pages> 71-75. </pages>
Reference-contexts: The performance data, therefore, should show the performance characteristics of primitives on the target architecture. At the present time, only basic primitives, and some basic performance characteristic information about the machine, such as those found in <ref> [9, 11, 17] </ref>, are planned to be included in the database, but these will hopefully be sufficient to show performance trends for the architectures. Working with the OOPACK benchmark from Robinson [16] we have already found examples where the compilers have difficulties with inlining functions and efficiently generating addresses.
Reference: [12] <author> Gallivan, K. A., Plemmons, R. J., and Sameh, A. H. </author> <title> Parallel Algorithms for Dense Linear Algebra Computations. </title> <note> SIAM Review 32, </note> <month> 1 (March </month> <year> 1990), </year> <pages> 54-135. </pages>
Reference-contexts: For example, the associative rule can be applied to transform a triangular solve with a column sweep, (L 1 4 (L 1 2 (L 1 1 fl f )))), into the product form <ref> [12] </ref>, (((L 1 4 fl L 1 2 fl L 1 1 ))f ). In applying the rules, however, one must decide what goal the optimizations should try to achieve: improved serial performance, improved parallelism, or improved numerical stability. It is also important to know the number of processors available.
Reference: [13] <author> Gropp, W., and Smith, B. </author> <title> Simplified Linear Equation Solvers Users Manual. </title> <type> Tech. Rep. </type> <institution> ANL-93/8-REV 1, Argonne National Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: With the first approach researchers are trying to make the libraries easier to use or to make the libraries more adaptable. For example, Gropp <ref> [13] </ref> designed a standard interface for subroutines and data structures. Reverse communication is being used by Duff and Heroux [8, 14] to allow subroutines to access user supplied data structures.
Reference: [14] <author> Heroux, M. A. </author> <title> A Proposal for a Sparse BLAS Toolkit. </title> <type> Tech. rep., </type> <institution> Cray Research, Inc., </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: With the first approach researchers are trying to make the libraries easier to use or to make the libraries more adaptable. For example, Gropp [13] designed a standard interface for subroutines and data structures. Reverse communication is being used by Duff and Heroux <ref> [8, 14] </ref> to allow subroutines to access user supplied data structures. Templates are being provide by Dongarra and others [3, 7] which allow programmers to write the subroutines for iterative methods using data structures supplied by the programmer.
Reference: [15] <author> Houstis, E. N., Rice, J. R., Chrisochoides, N. P., Karathanasis, H. C., Papachiou, P. N., Samartizs, M. K., Vavalis, E. A., Wang, K. Y., and Weerawarana, S. //ELL-PACK: </author> <title> A Numerical Simulation Programming Environment for Parallel MIMD Machines. </title> <booktitle> In Proceedings 1990 International Conference on Supercomputing (1990), </booktitle> <pages> pp. 96-107. </pages>
Reference-contexts: With the second approach, researchers are developing new access methods to libraries through the use of programming environments. For example, MATLAB [18] provides access to subroutines to perform linear algebra. Larger scale projects, such as Frameworks [2] and //ELLPACK <ref> [15] </ref>, provide a programming environment which can be used to generate code for an application. Our approach is to develop tools which will allow the library programmer access to the ease of use of interactive array languages while still providing the performance of traditional compiled languages.
Reference: [16] <author> Robinson, A. D. OOPACK: </author> <title> a benchmark for comparing OOP v.s. </title> <booktitle> C-style programming. From robinson@shell.com, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Working with the OOPACK benchmark from Robinson <ref> [16] </ref> we have already found examples where the compilers have difficulties with inlining functions and efficiently generating addresses. We have expanded these benchmarks to test other differences between C and C++ code and test different implementations with C++ code.
Reference: [17] <author> Saad, Y., and Wijshoff, H. </author> <title> A Benchmark Package for Sparse Matrix Computations. </title> <booktitle> Proceedings of 1988 Int'l. Conference on Supercomputing, </booktitle> <address> St. Malo, France (July 1988), </address> <pages> 500-509. </pages>
Reference-contexts: The performance data, therefore, should show the performance characteristics of primitives on the target architecture. At the present time, only basic primitives, and some basic performance characteristic information about the machine, such as those found in <ref> [9, 11, 17] </ref>, are planned to be included in the database, but these will hopefully be sufficient to show performance trends for the architectures. Working with the OOPACK benchmark from Robinson [16] we have already found examples where the compilers have difficulties with inlining functions and efficiently generating addresses.
Reference: [18] <author> The Math Works Inc. </author> <title> MATLAB Reference Guide, </title> <year> 1992. </year>
Reference-contexts: Templates are being provide by Dongarra and others [3, 7] which allow programmers to write the subroutines for iterative methods using data structures supplied by the programmer. With the second approach, researchers are developing new access methods to libraries through the use of programming environments. For example, MATLAB <ref> [18] </ref> provides access to subroutines to perform linear algebra. Larger scale projects, such as Frameworks [2] and //ELLPACK [15], provide a programming environment which can be used to generate code for an application.
References-found: 18

