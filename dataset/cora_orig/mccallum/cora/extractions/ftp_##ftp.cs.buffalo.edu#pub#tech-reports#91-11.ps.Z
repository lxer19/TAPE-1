URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/91-11.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: bharat@cs.buffalo.edu  
Phone: Telephone: (716) 636-3180/3194  
Title: Towards a Broader Basis for Logic Programmingy  
Author: Bharat Jayaraman 
Note: This research was supported in part by grant DCR-8603609 from the National Science Foundation.  
Address: Buffalo, NY 14260 U.S.A.  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: Logic programming is generally taken to be synonymous with relational programming; however, this paper argues why a broader basis for logic programming is needed, why existing combinations of equations, relations, and functions do not entirely meet the need, and a promising approach for the broader basis. The proposed broader basis consists of three logical forms: equations, relations, and subset assertions, along with an accompanying set of matching and unification operations. Equations provide the ability to define deterministic operations without Prolog's cut. Subset assertions can be used to define more declaratively Prolog's setof as well as transitive-closure operations, both of which are traditionally expressed using assert and retract. Because functions defined by subset assertions must be invoked with ground arguments, formulating relational clauses by subset assertions allows one to declaratively specify which arguments of a relation are ground, thereby obviating the need for mode declarations. Several examples are given to illustrate the approach. It is shown that this broader language is amenable to a very efficient implementation; in many cases, it will be potentially more efficient than Prolog. A language called SuRE|for Subsets, Relations, and Equations|is being implemented based on these ideas. 
Abstract-found: 1
Intro-found: 1
Reference: [AN87] <author> H. Ait-Kaci and R. Nasr, </author> <title> "Le Fun: Logic, equations and Functions," </title> <booktitle> In 1987 IEEE Symposium on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pp. 17-23, </pages> <year> 1987. </year>
Reference-contexts: Without this distinction, the potential efficiency of using equations is lost. * Functions and Relations <ref> [AN87] </ref> While functional programming languages, such as Miranda [T85], do provide the same advantages as equational languages, the problems with relational programming are not addressed by integrating functional and relational programming. <p> The problem with this combination is that using functional expressions within the relational sublanguage requires equality to be defined over infinite and higher-order objects. The needed higher-order unification here, unlike that in Prolog [NM88], is not even recursively eumerable. This problem is handled in Le Fun <ref> [AN87] </ref> by failing when two higher-order objects are tested for equality. While this might be a practical approach, it should be noted that this inference is, strictly speaking, unsound.
Reference: [AU77] <author> A. Aho and J.D. Ullman, </author> <title> "Principles of Compiler Design," </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: The following example illustrates the integration a little better; it is a program defining the reaching definitions in a program flow graph, which is computed by a compiler during its optimization phase <ref> [AU77] </ref>: out (b) diff (in (b), kill (b)) out (b) gen (b) in (b) allout (pred (b)) allout (fp j g) out (p) where kill (b), gen (b), and pred (b) are pre-defined set-valued functions specifying the relevant information for a given program flow graph and basic block b.
Reference: [B89] <author> D. Bowen, </author> <title> "Determinacy Checking: Choice Points Considered Harmful," </title> <booktitle> In Workshop on Logic Programming Environments, </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989, </year> <pages> pp. 17-33. </pages>
Reference-contexts: A substantial portion of most Prolog programs is deterministic <ref> [B89, DW89] </ref>; hence, these portions could be formulated more clearly using an equational or functional style without the cut to specify determinacy| note that clause-indexing obviates only some uses of the cut.
Reference: [BL86] <author> M. Bellia and G. Levi, </author> <title> "The Relation between Logic and Functional Languages: A Survey," </title> <journal> In J. of Logic Programming, </journal> <volume> vol. 3, pp.217-236, </volume> <year> 1986. </year>
Reference-contexts: Related Work and Desiderata Relational programming is not the only form of logic programming; as alluded to earlier, equations and functions are possible approaches. Below is a brief survey of the major logic programming paradigms that have been proposed|see references <ref> [BL86, DL86] </ref> for a survey of several specific approaches|and a discussion of why they do not completely suffice as a broader basis for logic programming.
Reference: [DL86] <author> D. DeGroot and G. Lindstrom, </author> <title> "Logic Programming : Functions, Equations and Relations," </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Related Work and Desiderata Relational programming is not the only form of logic programming; as alluded to earlier, equations and functions are possible approaches. Below is a brief survey of the major logic programming paradigms that have been proposed|see references <ref> [BL86, DL86] </ref> for a survey of several specific approaches|and a discussion of why they do not completely suffice as a broader basis for logic programming.
Reference: [DP85] <author> N. Dershowitz and D. A. Plaisted, </author> <title> "Applicative Programming cum Logic Programming," </title> <booktitle> In 1985 Symp. on Logic Programming, Boston, </booktitle> <pages> pp. 54-66. </pages>
Reference-contexts: Thus, deterministic computations can be formulated in this framework without resort to extra-logical operations such as the cut. However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. <p> However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. A thorough analysis of E-unification is given by Gallier and Raatz [GR86]. <p> Thus, it is very important for the compiler to know in advance the equational theory with respect to which unification must be performed, so that it can make necessary 3 optimizations. * Conditional Equations <ref> [DP85, F84, LP87, J88, DO88] </ref> A different way to enhance the equational programming paradigm is to use equations not just for simplifying (or reducing) an expression, but also for solving equational goals of the form expr 1 = expr 2 . <p> The term conditional equations was introduced by Dershowitz and Plaisted <ref> [DP85] </ref> to refer to programs of the form e = f :- p, where p is in general a conjunction of equational or relational goals.
Reference: [DW89] <author> S.K. Debray and D.S. Warren, </author> <title> "Functional Computations in Logic Programs," </title> <journal> In ACM TOPLAS, </journal> <volume> vol. 11, no. 3, </volume> <pages> pp. 451-481, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: A substantial portion of most Prolog programs is deterministic <ref> [B89, DW89] </ref>; hence, these portions could be formulated more clearly using an equational or functional style without the cut to specify determinacy| note that clause-indexing obviates only some uses of the cut.
Reference: [GM84] <author> J. A. Goguen and J. Meseguer, </author> <title> "Equality, Types, Modules, and (Why Not?) Generics for Logic Programming," </title> <journal> J. Logic Prog., </journal> <volume> Vol. 2, </volume> <pages> pp. 179-210, </pages> <year> 1984. </year>
Reference-contexts: Thus, deterministic computations can be formulated in this framework without resort to extra-logical operations such as the cut. However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. <p> However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. A thorough analysis of E-unification is given by Gallier and Raatz [GR86].
Reference: [GR86] <author> J.H. Gallier and S. Raatz, </author> <title> "SLD-Resolution Methods for Horn Clauses with Equality based on E-Unification," </title> <booktitle> In IEEE Symp. on Logic Programming, </booktitle> <address> Salt Lake City, </address> <year> 1986, </year> <pages> pp. 168-179. </pages>
Reference-contexts: However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. A thorough analysis of E-unification is given by Gallier and Raatz <ref> [GR86] </ref>. While the E-unification approach is very elegant from a theoretical standpoint, it is very difficult to realize in practice, even for the "well-behaved" case [GR86] where the program is partitioned into a set of relational clauses and a set of equations such that an equational term never appears in the <p> A thorough analysis of E-unification is given by Gallier and Raatz <ref> [GR86] </ref>. While the E-unification approach is very elegant from a theoretical standpoint, it is very difficult to realize in practice, even for the "well-behaved" case [GR86] where the program is partitioned into a set of relational clauses and a set of equations such that an equational term never appears in the head of a conditional clause. <p> A relational clause p :- q, r can be viewed as a conditional equation p = true :- q = true, r = true, and thus conditional equations provide a uniform approach to equational and relational programming. As noted in <ref> [GR86] </ref>, solving equational goals in these languages is essentially the E-unification problem, although approaches such as EqL [J88] and K-LEAF [LP87] make the problem more tractable by distinguishing constructors and functions. <p> However, the use of relational goals in equational assertions is not legal in SuRE, because it is not possible in general to guarantee that the relational goal in the body will not produce more than one solution. (This is precisely the restriction of "well-behavedness" referred to in <ref> [GR86] </ref>.) 5. Conclusions and Further Work The many shortcomings of Prolog when viewed as a pure logic programming language are well-known.
Reference: [J88] <author> B. Jayaraman, </author> <title> "Semantics of EqL," </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 372-380, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Thus, it is very important for the compiler to know in advance the equational theory with respect to which unification must be performed, so that it can make necessary 3 optimizations. * Conditional Equations <ref> [DP85, F84, LP87, J88, DO88] </ref> A different way to enhance the equational programming paradigm is to use equations not just for simplifying (or reducing) an expression, but also for solving equational goals of the form expr 1 = expr 2 . <p> As noted in [GR86], solving equational goals in these languages is essentially the E-unification problem, although approaches such as EqL <ref> [J88] </ref> and K-LEAF [LP87] make the problem more tractable by distinguishing constructors and functions.
Reference: [J89] <author> B. Jayaraman, </author> <note> "Subset-Equational Programing," Submitted for journal publication. 16 </note>
Reference-contexts: Because the declarative semantics makes a distinction between terms and expressions, i.e., variables may be quantified only over terms rather than expressions, it can be shown that depth-first search and innermost reduction are not semantic compromises, but indeed correct implementation techniques for the language <ref> [J89] </ref>.
Reference: [J90] <author> B. Jayaraman, </author> <title> "Implementation of Subset-Equational Programs," </title> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: This paper describes the integrated language informally, using several examples. A formal description of the language is easy to give|it is essentially a consolidation of our earlier semantic descriptions <ref> [JP89, J90] </ref>|but this is not the main goal of this paper. <p> by f, and specifies a limited form of lazy evaluation with the added benefit that intermediate sets are avoided| this capability has been implemented in simple subset-equational programs, but was used in the limited context when it is known that a function distributes over union in a certain argument position <ref> [JP87, JN88, J90] </ref>. One possible extension would be to allow a goal of the form f (terms) set-term, in order to allow more general lazy evaluation. The implementation issues of this feature have not yet been examined, hence this extension is not considered further in this paper. <p> The ability to treat these features in a declarative manner is an important advance of the proposed approach over previous work. Several examples are presented as evidence of the declarativeness and potential efficiency of the approach. An implementation for simple subset-equational programs has been developed <ref> [J90] </ref>, but not for the other features. The next step in this research is a more thorough description of the SuRE language along with a complete semantic definition. This will be followed by a sequential implementation of the language based on an extension of the WAM.
Reference: [J90a] <author> B. Jayaraman, </author> <title> "Subset-Equational Programming in Intelligent Decision Systems," </title> <note> Invited paper for a special issue of Journal of Computers and Mathematics with Applications, to appear 1990. </note>
Reference-contexts: In crossproduct, intersect and distr, there is no need to explicitly indicate the case when the argument sets are empty; the result is the empty set by virtue of an emptiness-as-failure assumption. The reference <ref> [J90a] </ref> also discusses the use of subset-equational programming in representing rules of an expert system, and shows how the collect-all capability is particularly useful in defining the results of exhaustive backchaining systems such as MYCIN [BS84]. * Stratified Subset-Equational Programs: We also showed how the paradigm of subset-equational programming can be
Reference: [JL87] <author> J. Jaffar, J.-L. Lassez, </author> <title> "Constraint Logic Programming," </title> <booktitle> In 14th ACM POPL, </booktitle> <pages> pp. 111-119, </pages> <address> Munich, West Germany, </address> <year> 1987. </year>
Reference-contexts: the computational difficulties with the aforementioned combinations of functions, relations and equations, we propose the criteria in designing a broader logic 4 programming language: (i) E-unification with respect to an arbitrary user-supplied theory should not be supported; it is too difficult to implement efficiently. (The success of languages like CLP <ref> [JL87] </ref> and Prolog [NM88] lend support to this criteria.) (ii) Relations cannot be combined with functions without compromising the correctness of equality; they can be combined with equations because the latter do not contain higher-order or infinite objects. (iii) Equational languages should make the distinction between constructors and other function symbols,
Reference: [JLM84] <author> J. Jaffar, J.-L. Lassez, M.J. Maher, </author> <title> "A theory of complete logic programs with equality," </title> <editor> In J. </editor> <booktitle> of Logic Programming, </booktitle> <pages> pp. 211-223, </pages> <year> 1984. </year>
Reference-contexts: Thus, deterministic computations can be formulated in this framework without resort to extra-logical operations such as the cut. However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. <p> However, this paradigm of equations is too restrictive to serve as a complete basis for logic programming. * Relations and Equations <ref> [GM84, JLM84, DP85] </ref> It seems natural to combine the efficiency of equations with the programming expressiveness of relations. However, existing combinations [GM84, JLM84, DP85] of these two logical forms extend the power of ordinary unification to unification modulo an equational theory, also known as E-unification or narrowing. A thorough analysis of E-unification is given by Gallier and Raatz [GR86].
Reference: [JN88] <author> B. Jayaraman and Nair, A., </author> <title> Subset-logic Programming: Application and Implementation, </title> <booktitle> In Fifth Int'l Logic Programming Conference, </booktitle> <address> Seattle, </address> <month> August </month> <year> 1988, </year> <pages> pp. 843-858. </pages>
Reference-contexts: The remainder of this paper is organized as follows. Section 2 briefly surveys previous work on equations, functions and relations, and shows why they do not completely suffice as 2 a broader basis for logic programming. Section 3 describes the basic approach, summarizing and clarifying our earlier papers <ref> [JP87, JN88, JP89] </ref>. Section 4 present several examples that elucidate how this broader language avoids many common uses of the extra-logical operations. Section 5 is devoted to conclusions, status, and further work. 2. <p> by f, and specifies a limited form of lazy evaluation with the added benefit that intermediate sets are avoided| this capability has been implemented in simple subset-equational programs, but was used in the limited context when it is known that a function distributes over union in a certain argument position <ref> [JP87, JN88, J90] </ref>. One possible extension would be to allow a goal of the form f (terms) set-term, in order to allow more general lazy evaluation. The implementation issues of this feature have not yet been examined, hence this extension is not considered further in this paper.
Reference: [JP87] <author> B. Jayaraman and D. A. Plaisted, </author> <title> "Functional Programming with Sets," </title> <booktitle> In 3rd Intl. Conf. on Functional Programming and Computer Architecture, </booktitle> <address> Port-land, </address> <month> Sept. </month> <year> 1987, </year> <pages> pp. 194-210. </pages>
Reference-contexts: The remainder of this paper is organized as follows. Section 2 briefly surveys previous work on equations, functions and relations, and shows why they do not completely suffice as 2 a broader basis for logic programming. Section 3 describes the basic approach, summarizing and clarifying our earlier papers <ref> [JP87, JN88, JP89] </ref>. Section 4 present several examples that elucidate how this broader language avoids many common uses of the extra-logical operations. Section 5 is devoted to conclusions, status, and further work. 2. <p> by f, and specifies a limited form of lazy evaluation with the added benefit that intermediate sets are avoided| this capability has been implemented in simple subset-equational programs, but was used in the limited context when it is known that a function distributes over union in a certain argument position <ref> [JP87, JN88, J90] </ref>. One possible extension would be to allow a goal of the form f (terms) set-term, in order to allow more general lazy evaluation. The implementation issues of this feature have not yet been examined, hence this extension is not considered further in this paper.
Reference: [JP89] <author> B. Jayaraman and D.A. Plaisted, </author> <title> "Programming with Equations, Subsets, and Relations," </title> <booktitle> In North American Logic Programming Conference, </booktitle> <address> Cleve-land, </address> <month> October </month> <year> 1989, </year> <pages> pp. 1051-1068. </pages>
Reference-contexts: Many uses of assert and retract correspond to implementations of transitive-closure operations, memoization, or collecting results from alternative search paths, as in the setof construct. In an earlier paper <ref> [JP89] </ref>, it was shown how subset assertions allow a more declarative formulation of such uses. <p> The remainder of this paper is organized as follows. Section 2 briefly surveys previous work on equations, functions and relations, and shows why they do not completely suffice as 2 a broader basis for logic programming. Section 3 describes the basic approach, summarizing and clarifying our earlier papers <ref> [JP87, JN88, JP89] </ref>. Section 4 present several examples that elucidate how this broader language avoids many common uses of the extra-logical operations. Section 5 is devoted to conclusions, status, and further work. 2. <p> Even with these restrictions, there are substantial technical problems to be solved before reaching a practical system. 3. Proposed Approach: Subsets, Relations and Equations The language to be described builds upon our earlier work on combining subsets, equations and relations <ref> [JP89] </ref>. We described two paradigms in these papers: subset-equational programming (combining subsets and equations) and subset-relational programming (combining subsets and relations). We also gave their formal model-theoretic and operational semantics. <p> This paper describes the integrated language informally, using several examples. A formal description of the language is easy to give|it is essentially a consolidation of our earlier semantic descriptions <ref> [JP89, J90] </ref>|but this is not the main goal of this paper. <p> In general, closure functions are useful in many areas, especially dataflow analysis in compilers. In order to give a simple declarative semantics and a corresponding correct operational semantics in terms of memo-tables [M68] (or extension tables), we introduced the class of stratified subset-equational programs <ref> [JP89, JP90] </ref>. <p> In general, not G will succeed when the search tree for G is finitely failed after considering the derivation from each clause as well as all possible choices (due to the set pattern fx j tg) within any particular clause. In <ref> [JP89] </ref>, we discussed stratified subset-relational programs, where it is permissible to have equality goals on the r.h.s. of a subset or relational assertion, provided such goals refer to subset assertions from a lower strata. This makes possible multi-level collect operations.
Reference: [JP90] <author> B. Jayaraman and D.A. Plaisted, </author> <title> "Semantics of Stratified Subset-Equational Programming," </title> <note> submitted for journal publication, </note> <year> 1990. </year>
Reference-contexts: In general, closure functions are useful in many areas, especially dataflow analysis in compilers. In order to give a simple declarative semantics and a corresponding correct operational semantics in terms of memo-tables [M68] (or extension tables), we introduced the class of stratified subset-equational programs <ref> [JP89, JP90] </ref>.
Reference: [L87] <author> J.W. Lloyd, </author> <title> "Foundations of Logic Programming," </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Furthermore, there should be only a finite number of derivations, because all sets in this framework are finite. Note that these conditions are analogous to those needed for the correctness of negation-as-failure in relational programming <ref> [L87] </ref>. A few examples will serve to illustrate the paradigm. * Setof: Simple subset-relational programs can be used to simulate Prolog's setof feature in a more declarative manner. <p> Consequently, the compiler can also determine that omission of the occurs-check for the second argument of dsort is safe. (In Prolog, omission of occurs-check when working with difference lists can give rise to wrong answers <ref> [L87] </ref>.) Since sort is deterministic, a typical goal using sort would be sort (ground-list) = fanswerg, indicating thereby that the resulting set is expected to have only one solution.
Reference: [LP87] <author> G. Levi, C. Palamidessi et al, </author> <title> "A Complete Semantic Characterization of K-LEAF, A Logic Language with Partial Functions," </title> <booktitle> In 1987 IEEE Symposium on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pp. 318-327, </pages> <year> 1987. </year>
Reference-contexts: Thus, it is very important for the compiler to know in advance the equational theory with respect to which unification must be performed, so that it can make necessary 3 optimizations. * Conditional Equations <ref> [DP85, F84, LP87, J88, DO88] </ref> A different way to enhance the equational programming paradigm is to use equations not just for simplifying (or reducing) an expression, but also for solving equational goals of the form expr 1 = expr 2 . <p> As noted in [GR86], solving equational goals in these languages is essentially the E-unification problem, although approaches such as EqL [J88] and K-LEAF <ref> [LP87] </ref> make the problem more tractable by distinguishing constructors and functions.
Reference: [NM88] <author> G. Nadathur and D. Miller, </author> <title> "An Overview of Prolog," </title> <booktitle> In 5th Int'l Logic Programming Conference, </booktitle> <address> Seattle, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The problem with this combination is that using functional expressions within the relational sublanguage requires equality to be defined over infinite and higher-order objects. The needed higher-order unification here, unlike that in Prolog <ref> [NM88] </ref>, is not even recursively eumerable. This problem is handled in Le Fun [AN87] by failing when two higher-order objects are tested for equality. While this might be a practical approach, it should be noted that this inference is, strictly speaking, unsound. <p> with the aforementioned combinations of functions, relations and equations, we propose the criteria in designing a broader logic 4 programming language: (i) E-unification with respect to an arbitrary user-supplied theory should not be supported; it is too difficult to implement efficiently. (The success of languages like CLP [JL87] and Prolog <ref> [NM88] </ref> lend support to this criteria.) (ii) Relations cannot be combined with functions without compromising the correctness of equality; they can be combined with equations because the latter do not contain higher-order or infinite objects. (iii) Equational languages should make the distinction between constructors and other function symbols, in order to
Reference: [N88] <author> Nair, A., </author> <title> Compilation of Subset-logic Programs, M.S. </title> <type> Thesis, </type> <institution> University of N. Carolina at Chapel Hill, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Before describing the integrated language in section 4, we briefly review the main features of subset-equational and subset-relational programming. 3.1 Subset-Equational Programming A program assertion in this paradigm may take one of two formsy: y The implementation <ref> [N88] </ref> actually uses the keyword contains instead of , and the keyword phi instead of 5 f (terms) = expression f (terms) expression where terms correspond to the data objects of the language, and are built up from atoms, variables, and constructors, whereas expressions may additionally contain user-defined functions.
Reference: [O85] <author> M.J. O'Donnell, </author> <title> "Equational Logic as a Programming Language," </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: In short, they are based on features that are either not amenable to efficient compilation or they do not address how the extra-logical features such as cut, assert, retract, setof, etc., can be avoided. * Equations <ref> [O85] </ref> The use of equations as a logic programming language has been advocated by O'Donnell [O85]. An important restriction on equational queries is that they may not contain any variables, i.e., they are ground queries. Thus, it is not necessary to use unification; a simpler, "one-way" matching suffices. <p> short, they are based on features that are either not amenable to efficient compilation or they do not address how the extra-logical features such as cut, assert, retract, setof, etc., can be avoided. * Equations <ref> [O85] </ref> The use of equations as a logic programming language has been advocated by O'Donnell [O85]. An important restriction on equational queries is that they may not contain any variables, i.e., they are ground queries. Thus, it is not necessary to use unification; a simpler, "one-way" matching suffices.
Reference: [O88] <author> R.A. O'Keefe, </author> <title> "Practical Prolog for Real Programmers," </title> <booktitle> Tutorial Notes from 5th Intl. Logic Programming Conference, </booktitle> <address> Seattle, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The closure functions are, as before, reach and allreach, and must be declared through suitable annotations. It is well-known that 11 defining transitive closures in Prolog efficiently requires the use of assert and retract <ref> [O88] </ref>. It should be mentioned that nested expressions in the body of a subset (or an equational) assertion are flattened to reflect the innermost reduction order.
Reference: [T85] <author> D. A. Turner, "Miranda: </author> <title> A non-strict functional language with polymorphic types," </title> <booktitle> in Conf. on Functional Prog. Langs. and Comp. Arch., </booktitle> <address> Nancy, France, </address> <month> Sep. </month> <year> 1985, </year> <pages> pp. 1-16. </pages>
Reference-contexts: Without this distinction, the potential efficiency of using equations is lost. * Functions and Relations [AN87] While functional programming languages, such as Miranda <ref> [T85] </ref>, do provide the same advantages as equational languages, the problems with relational programming are not addressed by integrating functional and relational programming. The reason for this claim is that a proper integration of these two forms must account for the higher-order and infinite objects of functional languages.
Reference: [W83] <author> D. H. D. Warren, </author> <title> "An Abstract Instruction Set for Prolog", </title> <type> Tech. Note 309, </type> <institution> SRI International, </institution> <year> 1983, </year> <pages> 28 pages. 18 </pages>
References-found: 27

