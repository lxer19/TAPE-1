URL: http://www.cs.man.ac.uk/~banach/some.pubs/TGR.Spec.Imp.FWork.COOL.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~banach/Recent.publications.html
Root-URL: http://www.cs.man.ac.uk
Title: mess:Read[ans] nxt] state] (The QMyCounter function runs round the queue looking for a message it
Author: =&gt; *QMyCounter[self qhd curr R. Banach, J. Balazs and G. A. Papadopoulos, R. Banach and G. A. Papadopoulos, Sofia, R. Banach and G. A. Papadopoulos, M. Henz, G. Smolka and J. Wurtz, O. Nierstrasz and M. Papathomas, [] M. R. Sleep, M. J. Plasmeijer and M. C. J. D. Eekelen (eds.), [] I. Watson, V. Woods, P. Watson, R. Banach, M. Greenberg and J. Sargeant, 
Address: Manchester, 1995.  New York, 1993.  
Date: Nov. 4-6, 1993,  May 30  
Note: 7. Using the Translations 8. Conclusions OOP languages operate and to  9. References [1] R.  in [10], pp. 243-252. [2] R. Banach, MONSTR I Fundamental Issues and the Design of MONSTR, submitted to the JUCS, 1995. [3]  Journal of Universal Computer Science, Springer Verlag, Vol. 1, No. 6, 1995, pp. 335-394. [4]  Bulgaria, May 4-7, 1993, pp. 303-322. [5]  ACM SAC 95, Nashville, TN, USA, Feb. 26-28, 1995, ACM Computer Society Press, pp. 157-163. [6]  Press, Cambridge, MA, 1994, pp. 27-48. [7]  90, ACM Computer Society Press, Ottawa, Canada, Oct. 21-25, 1990, pp. 38-43. [8] J. Sargeant, Uniting Functional and Object-Oriented Programming, 1st JSST, Kanazawa, Japan,  LNCS 742, Springer Verlag, pp. 1-26. [9] J. Sargeant, C. Kirkham and S. Hooton, UFO 1.0 Reference Manual (DRAFT), UFO  Term Graph Rewriting: Theory and Practice, John Wiley,  15th ISCA, Hawaii,  June 2, 1988, pp. 124-130.  
Affiliation: state], curr:=*nxt, *Assign[ans state]; where IF[True t e] =&gt; *OK, *t; IF[False t e] =&gt; *OK, *e;  Group, Department of Computer Science, University of  
Abstract: Note that the queue reduces concurrency . Until the result of the conditional test is known, we do not know whether to remove the current message from the queue or not; and we dare not launch a fresh QMyCounter early in case it runs right round the queue and processes the same message twice, ruining the main invariant (our simple queue suffers from a busy waiting overhead, though more sophisticated code can be written to avoid this). Above we have seen that the f inegrained rule based approach of MONSTR is well suited to discussing precise details of synchronisation for the primitives of higher level languages, due to its simple yet rigorous operational se mantic s. The stra tegy ma y be exte nded to give translations of the whole of (programs in) a high level language into collections of f inegrained rules. This has certainly been done in the past ([4,5]). However this approach, when carried out uncritically , can yield a mass of finegrained rules, which quickly become difficult to comprehend for humans, and inef ficient to execute by machine. Our recommendation is that apart from the use of MONSTR for clarifying f inegrained details of synchronisation etc., if appropriate justification in terms of locality of action is provided, larger granularity primitives may be designed to act as basic building blocks for implementations. All could have their semantics defined via translation into MONSTR rule collections, and their appropriateness could be judged by the ease or otherwise of the resulting serialisability proofs. Recently a number of proposals have been put forward with the aim of combining concurrency and object-orientation. They differ in many aspects regarding the way they handle the issues pertaining to this combination, such as degree of concurrency allowed not only between objects but also within an object (and how the internal state of the latter can be protected), synchronisation mechanisms e.g. locks, wait queues, synchronisation counters or activation conditions, process structures of and implementation techniques for objects, etc. In [7] it is argued that there is a need to develop semantic frameworks capable of allowing reasoning about the way various features of concurrent In this paper we have demonstrated the utility of MONSTR as such a framework. Although we have concentrated on a specific language model (UFO), we can show MONSTRs applicability to many semi-declarative languages (languages beyond the functional world, i.e. that support state), such as concurrent constraint ones ([6]). Language features mapped onto equivalent sets of MONSTR rewrite rules can be reasoned about in the same rigorous way as has already been done for process calculi ([3]), and as has been glimpsed above in the discussion of our object invariant. Furthermore, one is also able to reason precisely about variants of a single language, as can be done in our case by examining the dif ferent MONSTR code needed to describe different versions of UFO (e.g. [8,9], and as shown in our f leeting discussion of UFO ), especially wrt the interaction between concurrency, state and method invocation. Acknowledgment: The authors would like to thank John Sargeant for comments on an earlier version of the paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. </author> <title> Banach, MONSTR: Term Graph Rewriting for Parallel Machines, </title> <booktitle> in [10], </booktitle> <pages> pp. 243-252. </pages>
Reference: [2] <author> R. </author> <title> Banach, MONSTR I Fundamental Issues and the Design of MONSTR, </title> <note> submitted to the JUCS, </note> <year> 1995. </year>
Reference: [3] <author> R. Banach, J. Balazs and G. A. Papadopoulos, </author> <title> A Translation of the Pi-Calculus into MONSTR, </title> <journal> Journal of Universal Computer Science, Springer Verlag, </journal> <volume> Vol. 1, No. 6, </volume> <year> 1995, </year> <pages> pp. 335-394. </pages>
Reference: [4] <author> R. Banach and G. A. Papadopoulos, </author> <title> Parallel Term Graph Rewriting and Concurrent Logic Programs, </title> <address> WPDP 93, Sofia, Bulgaria, </address> <month> May 4-7, </month> <year> 1993, </year> <pages> pp. 303-322. </pages>
Reference: [5] <author> R. Banach and G. A. Papadopoulos, </author> <title> Linear Behaviour of Term Graph Rewriting Programs, </title> <booktitle> ACM SAC 95, </booktitle> <address> Nashville, TN, USA, </address> <month> Feb. </month> <pages> 26-28, </pages> <address> 1995, </address> <publisher> ACM Computer Society Press, </publisher> <pages> pp. 157-163. </pages>
Reference: [6] <author> M. Henz, G. Smolka and J. Wurtz, </author> <title> Object-Oriented Concurrent Constraint Programming in Oz, </title> <publisher> PPCP, MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994, </year> <pages> pp. 27-48. </pages>
Reference: [7] <author> O. Nierstrasz and M. Papathomas, </author> <title> Viewing Objects as Patterns of Communicating Agents, OOPSLA/ECOOP 90, </title> <publisher> ACM Computer Society Press, </publisher> <address> Ottawa, Canada, </address> <month> Oct. </month> <pages> 21-25, </pages> <year> 1990, </year> <pages> pp. 38-43. </pages>
Reference: [8] <editor> J. Sargeant, </editor> <booktitle> Uniting Functional and Object-Oriented Programming, 1st JSST, </booktitle> <address> Kanazawa, Japan, </address> <month> Nov. </month> <pages> 4-6, </pages> <address> 1993, </address> <publisher> LNCS 742, Springer Verlag, </publisher> <pages> pp. 1-26. </pages>
Reference: [9] <author> J. Sargeant, C. Kirkham and S. Hooton, </author> <title> UFO 1.0 Reference Manual (DRAFT), </title> <institution> UFO Group, Department of Computer Science, University of Manchester, </institution> <year> 1995. </year>
Reference: [10] <author> M. R. Sleep, M. J. Plasmeijer and M. C. J. D. Eekelen (eds.), </author> <title> Term Graph Rewriting: Theory and Practice, </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1993. </year>

References-found: 10

