URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-34.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Email: (boros@rutcor.rutgers.edu)  (cepek@ksi.ms.mff.cuni.cz)  (kogan@rutcor.rutgers.edu)  
Phone: 4  
Title: Horn Minimization by Iterative Decomposition 1  
Author: by Endre Boros ;; Ondrej Cepek Alexander Kogan ; 
Address: P.O. Box 5062, New Brunswick, NJ 08903, USA  25, 118 00 Praha 1, Czech Republic  Newark, NJ 07102,  P.O. Box 5062, New Brunswick, NJ 08903, USA  
Affiliation: RUTCOR, Rutgers University,  Dept. of Theoretical Informatics, Charles University, Malostranske nam.  Department of Accounting and Information Systems, Faculty of Management, Rutgers University,  and RUTCOR, Rutgers University,  
Date: 1997  
Note: July  N00014-92-J1375 and N00014-92-J4083). The first author also grateful for the partial support by NSF (grant INT 9321811) and NATO (grant CRG 931531). The second author thanks the travel support provided by DIMACS, the National Science Foundation Center for Discrete Mathematics and Theoretical Computer Science. 2 Permanent Member 3  5 Permanent Member 6  DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs, Bellcore, and Bell Labs. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 97-34 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Ausiello, A. D'Atri and D. Sacca. </author> <title> Minimal representation of directed hypergraphs. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(1986), </volume> <pages> 418-431. </pages>
Reference-contexts: Therefore, the computational expense of a single run of knowledge compression will be quickly amortized over a large number of queries to the knowledge base. Unfortunately, unlike satisfiability, the representation minimization problem is NP-hard not only in the general case, but also for Horn CNFs <ref> [1, 2, 3, 11, 16] </ref>. The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses.
Reference: [2] <author> E. Boros and O. Cepek. </author> <title> On the complexity of Horn minimization. </title> <institution> RUTCOR Research Report RRR 1-94 , Rutgers University, </institution> <address> New Brunswick, NJ, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Therefore, the computational expense of a single run of knowledge compression will be quickly amortized over a large number of queries to the knowledge base. Unfortunately, unlike satisfiability, the representation minimization problem is NP-hard not only in the general case, but also for Horn CNFs <ref> [1, 2, 3, 11, 16] </ref>. The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses.
Reference: [3] <author> O. Cepek. </author> <title> Structural Properties and Minimization of Horn Boolean Functions. </title> <type> Doctoral dissertation, </type> <institution> Rutgers University, </institution> <address> New Brunswick, NJ, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Therefore, the computational expense of a single run of knowledge compression will be quickly amortized over a large number of queries to the knowledge base. Unfortunately, unlike satisfiability, the representation minimization problem is NP-hard not only in the general case, but also for Horn CNFs <ref> [1, 2, 3, 11, 16] </ref>. The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses.
Reference: [4] <author> R. Dechter and J. Pearl. </author> <title> Structure identification in relational data. </title> <booktitle> Artificial Intelligence 58(1992), </booktitle> <pages> 237-270. </pages>
Reference-contexts: This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence <ref> [4, 11, 12] </ref> and database design [5, 16]. Horn clauses are by far the most popular type of knowledge representation which is due to both the computational efficiency of reasoning and their sufficient richness for capturing essential features of real-life problems.
Reference: [5] <author> C. Delobel and R.G. Casey. </author> <title> Decomposition of a Data Base and the Theory of Boolean Switching Functions. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 17(1973), </volume> <pages> 374-386. </pages>
Reference-contexts: This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence [4, 11, 12] and database design <ref> [5, 16] </ref>. Horn clauses are by far the most popular type of knowledge representation which is due to both the computational efficiency of reasoning and their sufficient richness for capturing essential features of real-life problems. <p> If such a clause is found, the propositional variable y is included into R, and the search is repeated as many times as possible. In the relational database terminology the propositional variables in R F (Q) are said to be "chained" to the subset Q (see e.g. <ref> [5] </ref>). In the expert system terminology the usage of the clause S _ y is called "firing the rule" V Forward Chaining Procedure Input: A pure Horn CNF F = V m i=1 (S i _ x j i ) and a subset Q of the propositional variables.
Reference: [6] <author> W.F. Dowling and J.H. Gallier. </author> <title> Linear time algorithms for testing the satisfiability of propositional Horn formulae. </title> <journal> Journal of Logic Programming, </journal> <volume> 3(1984), </volume> <pages> 267-284. </pages>
Reference-contexts: 1 Introduction Horn functions constitute a very important subclass of Boolean functions. Their importance stems from the fact that the satisfiability problem (SAT), which is NP-complete for general Boolean formulae (see e.g. [7]) is solvable in linear time for Horn formulae <ref> [6, 14, 17] </ref>. This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence [4, 11, 12] and database design [5, 16].
Reference: [7] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: 1 Introduction Horn functions constitute a very important subclass of Boolean functions. Their importance stems from the fact that the satisfiability problem (SAT), which is NP-complete for general Boolean formulae (see e.g. <ref> [7] </ref>) is solvable in linear time for Horn formulae [6, 14, 17]. This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn.
Reference: [8] <author> M.R. Genesereth and N.J. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference: [9] <author> P.L. Hammer and A. Kogan. </author> <title> Horn functions and their DNFs. </title> <journal> Information Processing Letters, </journal> <volume> 44(1992), </volume> <pages> 23-29. </pages>
Reference-contexts: The paper is structured as follows. In Section 2 we introduce the necessary notation and state several elementary results important for the subsequent presentation. We commence Section 3 by stating the decomposition theorems for Horn functions from <ref> [9] </ref>. <p> Finally, a Boolean function is called Horn if it has at least one representation by a Horn CNF, and similarly a Boolean function is called pure Horn if it has at least one representation by a pure Horn CNF. It is known (see <ref> [9] </ref>) that each prime implicate of a Horn function is either negative or pure Horn, and each prime implicate of a pure Horn function is pure Horn. <p> Thus, in particular, any prime CNF representing a Horn function is Horn, and any prime CNF representing a pure Horn function is pure Horn. The next statement was proved in <ref> [9] </ref>. Theorem 2.1 Given a Horn CNF F one can find in O (jF j 2 ` ) time an irredundant and prime CNF F 0 equivalent with F . <p> (C i ; C j ) 2 A 0 iff 9x 2 C i 9y 2 C j such that (x; y) 2 A - 7 - is called the acyclic condensation of the graph D. 3 Blind Switching We shall start this section by recalling two theorems proved in <ref> [9] </ref>. 2 Let f be a Horn function on a set S of propositional variables and let H denote the set of all pure Horn clauses on S and N the set of all negative clauses on S. <p> However, this problem can be handled by a simple procedure switch (see below) which performs the forced switching described above until it either succeeds to make T negative (while keeping F Horn) or gets stuck, the latter meaning that T cannot be switched. 2 These two theorems appear in <ref> [9] </ref> as Corollary 4.4 and Corollary 5.4.
Reference: [10] <author> P.L. Hammer and A. Kogan. </author> <title> Horn function minimization and knowledge compression in production rule bases. </title> <institution> RUTCOR Research Report RRR 8-92 , Rutgers University, </institution> <address> New Brunswick, NJ, </address> <month> March </month> <year> 1992. </year> <month> - 25 </month> - 
Reference: [11] <author> P.L. Hammer and A. Kogan. </author> <title> Optimal compression of propositional Horn knowledge bases: Complexity and approximation. </title> <journal> Artificial Intelligence, </journal> <volume> 64(1993), </volume> <pages> 131-145. </pages>
Reference-contexts: This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence <ref> [4, 11, 12] </ref> and database design [5, 16]. Horn clauses are by far the most popular type of knowledge representation which is due to both the computational efficiency of reasoning and their sufficient richness for capturing essential features of real-life problems. <p> In some applications an important problem is to find a shortest possible representation of a given Boolean function. For instance, in artificial intelligence this problem is equivalent to finding a most compact representation of a given knowledge base <ref> [11, 12] </ref>. Such transformation of a knowledge base accomplishes knowledge compression, since the actual knowledge does not change, while the size of the representation can be significantly reduced. <p> Therefore, the computational expense of a single run of knowledge compression will be quickly amortized over a large number of queries to the knowledge base. Unfortunately, unlike satisfiability, the representation minimization problem is NP-hard not only in the general case, but also for Horn CNFs <ref> [1, 2, 3, 11, 16] </ref>. The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses. <p> Initialization: Set R = Q. Main Step: while 9 i such that S i R and x j i 62 R do R = R [ fx j i g. Stop: Output R F (Q) = R. The following lemma was proved in <ref> [11] </ref>. Lemma 2.2 A pure Horn clause Q _ y is an implicate of a pure Horn function f given by a pure Horn CNF F if and only if y 2 R F (Q).
Reference: [12] <author> P.L. Hammer and A. Kogan. </author> <title> Knowledge compression logic minimization for expert systems. Computers As Our Better Partners. </title> <booktitle> Proceedings of the IISF/ACM Japan International Symposium. World Scientific, </booktitle> <address> Singapore, </address> <year> 1994, </year> <pages> 306-312. </pages>
Reference-contexts: This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence <ref> [4, 11, 12] </ref> and database design [5, 16]. Horn clauses are by far the most popular type of knowledge representation which is due to both the computational efficiency of reasoning and their sufficient richness for capturing essential features of real-life problems. <p> In some applications an important problem is to find a shortest possible representation of a given Boolean function. For instance, in artificial intelligence this problem is equivalent to finding a most compact representation of a given knowledge base <ref> [11, 12] </ref>. Such transformation of a knowledge base accomplishes knowledge compression, since the actual knowledge does not change, while the size of the representation can be significantly reduced.
Reference: [13] <author> P.L. Hammer and A. Kogan. </author> <title> Quasi-acyclic propositional Horn knowledge bases: Optimal compression. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(5)(1995), </volume> <pages> 751-762. </pages>
Reference-contexts: The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses. Paper <ref> [13] </ref> introduced two subclasses of Horn functions, acyclic and quasi-acyclic functions, for which HM is solvable in polynomial time. However, these subclasses are rather special, and therefore it is still desirable to find techniques for tackling HM for Horn functions in general. <p> We also design a naive algorithm performing this iterative decomposition. In Section 4 we prove an interesting property of Horn functions which rests on the correspondence between Horn CNFs and directed graphs first introduced in <ref> [13] </ref>. This property shows that every Horn function possesses a certain structure which is independent of the particular CNF representation of the function. <p> Lemma 2.2 shows how to verify whether a given clause is an implicate of a given CNF. The following statement proved in <ref> [13] </ref> shows that the forward chaining procedure can be efficiently implemented, i.e. that the complexity of performing the above mentioned verification is low. <p> The next section is devoted to this topic. 4 We skip a detailed complexity analysis of the procedures switch and decomposition. Later in this paper a "better" procedure performing the same task will be developed and analyzed in detail. - 10 - 4 Graph Properties of Horn Functions Following <ref> [13] </ref>, we associate with each Horn CNF a directed graph as follows : Definition 4.1 For a Horn CNF F let G F = (N; A F ) be the digraph defined by N = fxj x is a propositional variable in F g A F = f (x; y) j <p> The following lemma proved in <ref> [13] </ref> describes a useful property of the graph G F . <p> by induction, at each step of both procedures the same number of negative clauses will be eliminated. 7 Acyclic and Quasi-Acyclic CNFs In this section we shall investigate how the algorithm graph-algo performs on CNFs from the two classes, for which Horn Minimization is known to be polynomially solvable (see <ref> [13] </ref>). A Horn CNF F is said to be acyclic if the graph G F is acyclic. In such a case each node of G F constitutes a one-element strong component. Therefore, no inside or outside forks may exist and thus no strong component is blocked. <p> this case the partition of clauses in F looks as follows * B (F ) = ; * N 1 (F ) = fC = x _ y j x; y are from the same strong component of G F g 8 In fact, more is true (as shown in <ref> [13] </ref>). <p> This gives an alternative proof of the fact (see <ref> [13] </ref>) that a minimal CNF of a quasi-acyclic function can be obtained from an arbitrary irredundant and prime CNF by replacing the quadratic clauses in N 1 (F ) by a set of simple cycles of quadratic clauses, one cycle per strong component of G F (each cycle spanning the entire
Reference: [14] <author> A. Itai and J.A. Makowsky. </author> <title> Unification as a complexity measure for logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(1987), </volume> <pages> 105-117. </pages>
Reference-contexts: 1 Introduction Horn functions constitute a very important subclass of Boolean functions. Their importance stems from the fact that the satisfiability problem (SAT), which is NP-complete for general Boolean formulae (see e.g. [7]) is solvable in linear time for Horn formulae <ref> [6, 14, 17] </ref>. This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence [4, 11, 12] and database design [5, 16].
Reference: [15] <author> D.E. Knuth. </author> <title> Fundamental Algorithms. Vol.1 of The Art of Computer Programming, Addison-Wesley, </title> <note> 1968 (second edition 1973). </note>
Reference-contexts: The preprocessing phase where the graph G F is constructed and its strong components are discovered and topologically ordered can be implemented to have an O (`) complexity using the well-known algorithms of [18] and <ref> [15] </ref>. Each of the three main cycles in graph-algo examines every clause at most once, and the amount of work per clause is linear in the size of the clause (i.e. number of literals in the clause), which gives an overall O (`) complexity.
Reference: [16] <author> D. Maier. </author> <title> Minimal covers in the relational database model. </title> <journal> Journal of the ACM , 27(1980), </journal> <pages> 664-674. </pages>
Reference-contexts: This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence [4, 11, 12] and database design <ref> [5, 16] </ref>. Horn clauses are by far the most popular type of knowledge representation which is due to both the computational efficiency of reasoning and their sufficient richness for capturing essential features of real-life problems. <p> Therefore, the computational expense of a single run of knowledge compression will be quickly amortized over a large number of queries to the knowledge base. Unfortunately, unlike satisfiability, the representation minimization problem is NP-hard not only in the general case, but also for Horn CNFs <ref> [1, 2, 3, 11, 16] </ref>. The Horn Minimization (HM) problem can be stated as follows: given a Horn CNF F find a CNF F 0 representing the same function and such that F 0 consists of a minimum possible number of clauses.
Reference: [17] <author> M. Minoux. LTUR: </author> <title> A simplified linear time unit resolution algorithm for Horn formulae and computer implementation. </title> <journal> Information Processing Letters, </journal> <volume> 29(1988), </volume> <pages> 1-12. </pages>
Reference-contexts: 1 Introduction Horn functions constitute a very important subclass of Boolean functions. Their importance stems from the fact that the satisfiability problem (SAT), which is NP-complete for general Boolean formulae (see e.g. [7]) is solvable in linear time for Horn formulae <ref> [6, 14, 17] </ref>. This implies that certain real-life problems which require solving SAT become tractable if the underlying Boolean function in the problem is Horn. Such problems arise in several application areas, among others in artificial intelligence [4, 11, 12] and database design [5, 16].
Reference: [18] <author> R.E. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 2(1972), </volume> <pages> 146-160. </pages>
Reference-contexts: The preprocessing phase where the graph G F is constructed and its strong components are discovered and topologically ordered can be implemented to have an O (`) complexity using the well-known algorithms of <ref> [18] </ref> and [15]. Each of the three main cycles in graph-algo examines every clause at most once, and the amount of work per clause is linear in the size of the clause (i.e. number of literals in the clause), which gives an overall O (`) complexity.
References-found: 18

