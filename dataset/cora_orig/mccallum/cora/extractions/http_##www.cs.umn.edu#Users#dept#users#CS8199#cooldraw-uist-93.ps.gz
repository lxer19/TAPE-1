URL: http://www.cs.umn.edu/Users/dept/users/CS8199/cooldraw-uist-93.ps.gz
Refering-URL: http://www.cs.umn.edu/Users/dept/users/CS8199/
Root-URL: http://www.cs.umn.edu
Email: bnfb@cs.uvic.ca  
Title: Converting an Existing User Interface to Use Constraints  
Author: Bjorn N. Freeman-Benson 
Keyword: user interface toolkits, constraints, conversion, HotDraw, CoolDraw, direct manipulation  
Address: PO Box 3055, Victoria, BC, V8W 3P6, CANADA 1  
Affiliation: University of Victoria, Department of Computer Science,  
Note: page 1 of 9  
Abstract: Constraints have long been championed as a tool for user interface construction. However, while certain constraint systems have established a user community, constraint-based user interfaces have not yet been widely adopted. The premise of this paper is that a major stumbling block to their pervasive use has been the emphasis on designing new interface toolkits rather than augmenting existing ones. The thesis of the work described in this paper is that it is possible, and practical, to convert an existing user interface written in an imperative programming language into a similar user interface implemented with constraints. This thesis is proved by example: the conversion of HotDraw into CoolDraw. MOTIVATION Constraints have long been championed as a tool for user interface construction. The user interface research and development community has developed constraint algorithms, interface toolkits, and even complete systems based on constraints. And, while systems like Garnet [Myers et al. 90] have established a user community, constraint-based user interfaces have not yet been widely adopted. The premise of this paper is that a major stumbling block to their pervasive use has been the emphasis on designing new interface toolkits rather than augmenting existing ones. And, as the real demonstration of a toolkits utility is its use in full-scale applications, these new, edging toolkits are handicapped: developers cannot afford to adopt incomplete tools while researchers cannot afford to build full-scale ones. However, if existing tools could be adapted or converted to use the researchers ideas, these ideas could be explored in full-scale applications for significantly less cost. The thesis of the work described in this paper is that it is possible, and practical, to convert an existing user inter 
Abstract-found: 1
Intro-found: 1
Reference: [Beck & Cunningham 87] <author> Kent Beck and Ward Cun-ningham. </author> <title> Semantic Drawing with HotDraw. </title> <type> Technical Report CR-87-34, </type> <institution> Tektronix Computer Research Laboratory, </institution> <month> April </month> <year> 1987. </year> <title> Converting an Existing User Interface to Use Constraints page 9 of 9 </title>
Reference-contexts: This thesis is proved by example. The remainder of the paper describes both the general issues of such a conversion, and the specific details of the conversion that my students and I performed. The application we converted was HotDraw, a MacDraw-like object-oriented drawing system <ref> [Beck & Cunningham 87, Johnson 92] </ref>.
Reference: [Borning 81] <author> Alan Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4):353387, </volume> <month> October </month> <year> 1981. </year>
Reference-contexts: However, four points contain eight values whereas only four values are necessary to specify a rectangle. One obvious solution would be to actually create the four consistency constraints: topLeft x = bottomLeft x, topLeft y = topRight y, etc. However, as <ref> [Borning 81] </ref> noted, identity is a stronger and more efficiently computable condition than equality, so CoolDraw uses four constrainable variables (top, bottom, left, and right) to create the four corners each variable is shared by two of the points.
Reference: [Freeman-Benson & Borning 92] <author> Bjorn Freeman-Ben-son and Alan Borning. </author> <title> Integrating Constraints with an Object-Oriented Language. </title> <booktitle> Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268286, </pages> <address> Utrecht, The Nether-lands, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The simplest solution to this problem is to lower all constraints to the same level of abstraction, e.g., if some constraints are on points and some are on numbers, then the former should be transformed into constraints on numbers. This transformation is called splitting a constraint <ref> [Freeman-Benson & Borning 92] </ref>. Constraints on points are split into two constraints, one on each of their x and y components.
Reference: [Hill 93] <author> Ralph Hill. </author> <title> The Rendezvous Constraint Maintenance System for Multi-User Applications. To appear, </title> <booktitle> Proceedings of the ACM Symposium on User Interface Software and Technology, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Thus, once a part-whole object structure has been created and constrained, either it should not be restructured, or special care must be taken to reset the affected constraints. Note that this problem exists even when the underlying constraint solver supports pointer variables, e.g. <ref> [Hudson 93, Hill 93] </ref>. We encountered this problem during the conversion of the HotDraw figures that were subclasses of Polyline-Figure. These figures are defined by an internal array of point objects.
Reference: [Hudson 90] <author> Scott E. Hudson. </author> <title> Adaptive Semantic Snapping A Technique for Semantic Feedback at the Lexical Level. </title> <booktitle> Proceedings of the 1990 ACM SIG-CHI Conference, </booktitle> <pages> pages 6570, </pages> <address> Seattle, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: There are many outstanding projects exploring constraint-based user interfaces (e.g., <ref> [Hudson 90, Myers et al. 90, Olsen 90] </ref> and many of the chapters of [Myers 92]), however they all require that at least the user interface, and usually the application as well, be implemented in a specific language or within a specialized system.
Reference: [Hudson 93] <author> Scott Hudson. </author> <title> EVAL/vite Users Guide (v1.0). </title> <institution> Georgia Institute of Technology technical report GIT-GVU-93-xx, </institution> <year> 1993. </year>
Reference-contexts: Thus, once a part-whole object structure has been created and constrained, either it should not be restructured, or special care must be taken to reset the affected constraints. Note that this problem exists even when the underlying constraint solver supports pointer variables, e.g. <ref> [Hudson 93, Hill 93] </ref>. We encountered this problem during the conversion of the HotDraw figures that were subclasses of Polyline-Figure. These figures are defined by an internal array of point objects.
Reference: [Johnson 92] <author> Ralph E. Johnson. </author> <title> Documenting Frameworks using Patterns. </title> <booktitle> Proceedings of the 1992 ACM Conference on Object Oriented Programming, Systems, and Applications, </booktitle> <pages> pages 6376, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This thesis is proved by example. The remainder of the paper describes both the general issues of such a conversion, and the specific details of the conversion that my students and I performed. The application we converted was HotDraw, a MacDraw-like object-oriented drawing system <ref> [Beck & Cunningham 87, Johnson 92] </ref>.
Reference: [Kiczales et al. 91] <author> Gregor J. Kiczales, Jim des Rivires, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In return for the disadvantage of modifying all the variable reads, this technique provides reasonably efficient access to variables constraint information. Note that modifying the variable reads can either be done at the source code level (as in Table 1: Con-strainable Variable Options), or via a meta-object protocol <ref> [Kiczales et al. 91] </ref> which can alter the semantics of variable reads. However, although there are languages, such as C++, that allow the redefinition of many common operations (equality, assignment/variable writes, pointer indirection, etc.), currently only CLOS allows the redefinition of variable reads.
Reference: [Launchbury 91] <author> John Launchbury. </author> <title> Projection factori-sation in partial evaluation. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: While references [Born-ing 81] and [Maloney 91] disagree about the size of the performance increase due to plans, they do agree that an increase exists. Additionally, as described in other partial evaluation literature <ref> [Launchbury 91] </ref>, the use of plans can reduce overall runtime even when such plans are used just once. CHANGES NECESSARY There are a number of basic changes that convert an imperative user interface, e.g., HotDraw, into a constraint-based user interface, e.g., CoolDraw.
Reference: [Madsen et al. 93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <booktitle> ACM Press/Addison-Wesley, </booktitle> <address> New York, </address> <year> 1993. </year>
Reference-contexts: However, although there are languages, such as C++, that allow the redefinition of many common operations (equality, assignment/variable writes, pointer indirection, etc.), currently only CLOS allows the redefinition of variable reads. BETA <ref> [Madsen et al. 93] </ref> comes close, but still requires variable declarations to be altered. iii. Double Storage. A third technique is to modify the application implementation languages compiler and run-time system to allocate two (or more) memory cells for each variable.
Reference: [Maloney 91] <author> John Maloney. </author> <title> Using Constraints for User Interface Construction. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The Blue algorithms are structure-based rather than value-based, and thus can produce plans (partial evaluations of constraint hierarchies) which can be repeatedly reused to solve the same constraints without the expense of calling the constraint solver. While references [Born-ing 81] and <ref> [Maloney 91] </ref> disagree about the size of the performance increase due to plans, they do agree that an increase exists. Additionally, as described in other partial evaluation literature [Launchbury 91], the use of plans can reduce overall runtime even when such plans are used just once.
Reference: [Myers et al. 90] <author> Brad A. Myers, Dario Guise, Roger B. Dannenberg, Brad Vander Zanden, David Kosbie, Philippe Marchal, and Ed Pervin. </author> <title> Comprehensive Support for Graphics, Highly-Interactive User Interfaces: The Garnet User Interface Development Environment. </title> <journal> IEEE Computer, </journal> <volume> 23(11):7185, </volume> <month> November </month> <year> 1990. </year>
Reference-contexts: There are many outstanding projects exploring constraint-based user interfaces (e.g., <ref> [Hudson 90, Myers et al. 90, Olsen 90] </ref> and many of the chapters of [Myers 92]), however they all require that at least the user interface, and usually the application as well, be implemented in a specific language or within a specialized system.
Reference: [Myers 92] <author> Brad Myers, </author> <title> Editor, Languages for Developing User Interfaces. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: There are many outstanding projects exploring constraint-based user interfaces (e.g., [Hudson 90, Myers et al. 90, Olsen 90] and many of the chapters of <ref> [Myers 92] </ref>), however they all require that at least the user interface, and usually the application as well, be implemented in a specific language or within a specialized system. Other systems (e.g., [Telles 90]) have the goal of provide a new user interface wrapper for an existing, or legacy, system.
Reference: [Olsen 90] <author> Dan R. Olsen, Jr. </author> <title> Creating Interactive Techniques by Symbolically Solving Geometric Constraints. </title> <booktitle> Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 102107, </pages> <address> Snowbird, Utah, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: There are many outstanding projects exploring constraint-based user interfaces (e.g., <ref> [Hudson 90, Myers et al. 90, Olsen 90] </ref> and many of the chapters of [Myers 92]), however they all require that at least the user interface, and usually the application as well, be implemented in a specific language or within a specialized system.
Reference: [Sannella 93] <author> Michael Sannella. </author> <title> The SkyBlue Constraint Solver. </title> <type> Technical Report 92-07-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Using a 1D Handle). fi COLBALTBLUE CONSTRAINT SYSTEM The constraint system used in this conversion experiment was the ColbaltBlue incremental constraint solver, an enhancement of the SkyBlue solver <ref> [Sannella 93] </ref>. While this solver was chosen both because I was familiar with it and because it provides the necessary set of features, most of the design decisions and implementation problems outlined in the following sections are independent of the choice of constraint solver.
Reference: [Telles 90] <author> Marcy Telles. </author> <title> Updating an Older Interface. </title> <booktitle> Proceedings of the 1990 ACM SIGCHI Conference, </booktitle> <pages> pages 243247, </pages> <address> Seattle, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Other systems (e.g., <ref> [Telles 90] </ref>) have the goal of provide a new user interface wrapper for an existing, or legacy, system. The goal of the CoolDraw project was the exploration of a third alternative: the conversion of an existing imperative user interface.
References-found: 16

