URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-93-18.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Email: fjag,lieuweng@allegra.att.com  
Title: Multi-Granularity Locks in an Object-Oriented Database  
Author: H. V. Jagadish, Daniel F. Lieuwen 
Address: 600 Mountain Avenue Murray Hill, NJ 07974  
Affiliation: AT&T Bell Laboratories  
Abstract: Multi-granularity locking is widely accepted today as an important performance booster for concurrency control in relational databases. In this paper, we address the issues that arise in applying the same idea to an object-oriented database. First, with encapsulated implementations providing interfaces to objects, it is both possible and beneficial to define conflict relationships between pairs of operations allowed on objects of a particular class. This, in turn, translates into a need for a rich and extensible set of lock types that can be used at different granularities (e.g. object, file, database). Second, objects often participate in multiple collections. Thus, there may be no simple hierarchy of locking granules but rather an arbitrary graph with inclusion and intersection relationships. Moreover, updates to the database could result in modifications to this graph. Thus, this graph becomes a point of potential high contention and care is required to ensure that transactions lock it for the shortest duration possible. Keywords:[Object-Oriented Database, Transactions, Concurrency Control] 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal, A. El Abbadi, and R. Jeffers. </author> <title> Using delayed commitment in locking protocols for real-time databases. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 104-113, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Our work is in a more general 3 database context, where such restrictions on order may not be acceptable. Instead, we use intention locks. We make use of deferred updates in maintaining our lock graph. While no one has proposed the use of deferred updates for locking hierarchies, see <ref> [1, 24, 21] </ref> for some recent papers that use deferred updates for other purposes. 3 MOTIVATION Multi-granularity locking is used to resolve the tradeoff between concurrency and overhead|concurrency is increased if fine locking granules (e.g. records or fields) are used, but fine locking granules are very expensive for transactions that access
Reference: [2] <author> R. Agrawal and N. H. Gehani. </author> <title> Ode (Object Database and Environment): the language and the data model. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 36-45, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs). <p> applied to an object of a given class, determined by the set of public member functions defined for (including those inherited by) the class. 1 We assume that all accesses to an object are done through this interface. 2 1 The work here is performed in the context of Ode <ref> [2] </ref>. The data model is fundamentally that of C++. 2 In an implementation, when a public data member is modified or an OID is coerced to an object of another type, the corresponding object can be exclusively locked.
Reference: [3] <author> B. R. Badrinath and K. Ramamritham. </author> <title> Semantics-based concurrency control: Beyond commutativity. </title> <journal> ACM TODS, </journal> <volume> 17(1):163|199, </volume> <month> March </month> <year> 1992. </year> <month> 22 </month>
Reference-contexts: However, there are circumstances in which asymmetry is useful, depending on the order of operations. For instance, a read followed by a write introduces only a commit dependency whereas a write followed by a read introduces an abort dependency <ref> [3] </ref>. If any two rows of the matrix, and the corresponding columns, are identical, merge them into a single row, and single column, respectively. Assign a lock type for each row (or column) of this matrix.
Reference: [4] <author> E. Bertino. </author> <title> Query Processing for Advanced Database Applications, chapter A Survey of Indexing Techniques for Object-Oriented Databases. </title> <publisher> Morgan Kaufman, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: However, not all (significant) collections need be indexed, and there could be multiple indices defined on a collection. Multiple collections could have a common index structure defined over them (cf., <ref> [19, 4] </ref>). The system maintains information about the relationship between each pair of significant collections. The binary relations inclusion and conflict (intersection) are used by the system.
Reference: [5] <author> A. Biliris, S. Dar, N. H. Gehani, H. V. Jagadish, and K. Ramamritham. </author> <title> A flexible transaction facility for an object-oriented database. </title> <note> Submitted for publication. </note>
Reference-contexts: This matrix has an entry for each pair of operations, indicating whether the two conflict. In general, this matrix could be asymmetric and could use concepts such as recoverability to define various "partial conflict" situations, such as the creation of a commit dependency. See <ref> [5] </ref> for details on the specification and use of such conflict matrices. The techniques apply even when the conflict table creates dependencies or partial conflict relations, but for simplicity we will restrict our exposition to the binary framework where conflicts are either present or absent.
Reference: [6] <author> A. Biliris, N. H. Gehani, and H. V. Jagadish. </author> <title> Indexing in an object-oriented database. </title> <note> In preparation. </note>
Reference-contexts: Given an object o, it is possible to determine all the significant collections that o is a member of. This can be determined efficiently by maintaining appropriate information in the system catalog. In this paper, we do not explicitly specify the implementations for such a mechanism (see <ref> [6] </ref> for how it is done inexpensively in Ode); we merely assume the existence of one. A type extent, for our purposes is simply another collection.
Reference: [7] <author> Haran Boral, William Alexander, Larry Clay, George Copeland, Scott Danforth, Michael Franklin, Brian Hart, Marc Smith, , and Patrick Valduriez. </author> <title> Prototyping Bubba, a highly parallel database system. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 4-24, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Object-oriented databases (OODBs) have not taken full advantage of the experience of relational databases. Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. <ref> [11, 7, 18] </ref>). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems [7, 22, 8, 12, 10, 2, 18, 16, 11] include facilities to build collections consisting of lists of object identifiers (OIDs). <p> Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [8] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The GemStone object database management system. </title> <journal> CACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Rather than force a single locking granule for all transactions, multi-granularity allows a transaction to select a granularity at which to obtain locks. Object-oriented databases (OODBs) have not taken full advantage of the experience of relational databases. Some support only object-level locking (e.g. <ref> [8] </ref>). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. <p> Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [9] <author> Vinay Chaudhri, Vassos Hadzilacos, and John Mylopoulos. </author> <title> Concurrency control for knowledge bases. </title> <booktitle> In Proc. 3rd Int'l Conf. on Knowledge Representation and Reasoning, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Moreover, dynamic changes in a locking graph are not a concern in [17]. The only previous work we are aware of that considers a dynamically changing locking graph is in the context of a knowledge base <ref> [9] </ref>. Their solution is to restrict the order of user lock requests. Our work is in a more general 3 database context, where such restrictions on order may not be acceptable. Instead, we use intention locks. We make use of deferred updates in maintaining our lock graph.
Reference: [10] <author> Danette Chimenti, Ruben Gamboa, Ravi Krishnamurthy, Shamim Naqvi, Shalom Tsur, and Carlo Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [11] <editor> O. Deux et al. </editor> <title> The O 2 system. </title> <journal> CACM, </journal> <volume> 34(10) </volume> <pages> 34-48, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Object-oriented databases (OODBs) have not taken full advantage of the experience of relational databases. Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. <ref> [11, 7, 18] </ref>). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems [7, 22, 8, 12, 10, 2, 18, 16, 11] include facilities to build collections consisting of lists of object identifiers (OIDs). <p> Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [12] <author> D. Fishman, D. Beech, H. Cate, E. Chow, T. Connors, J. Davis, N. Derrett, C. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. Neimat, T. Ryan, and M. Shan. </author> <title> Iris: An object-oriented database management system. </title> <journal> ACM Trans. Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [13] <author> Jorge Garza and Won Kim. </author> <title> Transaction management in an object-oriented database system. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 37-45, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Two protocols for multi-granularity locking in an OODB are described in <ref> [13] </ref>. This work assumes that type extents are the only lockable collections and that locking the extent of class C implicitly locks the extents for all subclasses of C. <p> Therefore some heuristic may need to be used for this purpose even if the calculation is done off-line. 9.3 Lowering Object Locking Cost Some applications require both low cost object locking and multi-granularity concurrency control. An algorithm based on the second protocol in <ref> [13] </ref> can be used to accomplish this. As in Section 9.2, we need a database granule as the root of the locking graph. EOT processing is unchanged. However, in contrast to the algorithm described in this paper, object locks and collection locks are obtained using quite different protocols.
Reference: [14] <author> J. N. Gray, R. A. Lorie, G. R. Putzolu, and I. L. Traiger. </author> <title> Granularity of locks and degrees of consistency in a shared database. </title> <booktitle> In Proc. of the IFIP Working Conference on Modeling Database Management Systems, </booktitle> <pages> pages 1-29, </pages> <year> 1979. </year>
Reference-contexts: Section 8 describes how indexes can be included in our scheme. Section 9 briefly describes several extensions to the algorithms. Finally, Section 10 describes our conclusions and future work. 2 RELATED WORK A multi-granularity locking protocol on DAGs with a single root is described in <ref> [14] </ref>. The finest locking granules (e.g. records or fields) are only locked in S mode (to indicate that the granule will be read) or X mode (to indicate that the granule will be read and/or written). <p> In the second protocol, setting an X or S lock on an extent E requires locking only a single path to a root, just like setting an S lock in <ref> [14] </ref>. However, if E has any subclasses that have more than one superclass, locking E in S (X) mode requires locking all such subclasses in S (X) mode as well. <p> Rather than force a single locking granule for all transactions, multi-granularity allows a transaction to select a granularity at which to obtain locks. The same motivation holds for relational databases <ref> [14] </ref> and object-oriented databases. Our method can substantially reduce the number of locks required for database operations. As a simple example, consider a mail order company with 100,000,000 customers. Their 800-number receives 500,000 orders per day. <p> Thus, maintaining intersection views need not block the physical modification of the important collections for long. 9.2 Preferred Operations In many databases, read operations are much more frequent than write operations. To allow for this fact, standard multi-granularity locking protocols, such as <ref> [14] </ref> described in Sec. 2.1, discriminate between reads and writes in the intention locks required. Readers need obtain locks only along one path from root to leaf while writers must obtain locks along all paths. Our algorithm, on the other hand, is symmetric in its treatment of different operations.
Reference: [15] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: However, some of these collections may become very large. Transactions that process these collections will be forced to acquire a large number of locks. The typical cost to set a single lock is about 100 RISC instructions <ref> [15] </ref>, so the processing cost may be prohibitive. In addition, a large number of locks may overwhelm the lock manager, which may not even be able to acquire enough memory for all the locks. The only alternative is to set an extent lock (if available). <p> However, the overhead would probably outweigh the minor benefits of identifying a few collections as (temporarily) having an inclusion rather than an intersection relationship. Locking Background In addition to the standard commit duration locks, three locking variants are also needed. This description follows <ref> [15, 20] </ref>. Obtaining a standard lock is quite expensive as it involves hashing, following hash chains, etc. Sometimes, latches are used instead. A latch is a lock on some physical unit (like a page) and is used to maintain physical consistency. <p> Lock promotion (e.g. converting a read lock to a write lock) is the most common source of these deadlocks <ref> [15] </ref>. The standard avoidance technique is to request the stronger lock initially; this technique should be used here as well. <p> Of course, if the creator comes first, t 1 must block. Similarly, a transaction that wishes to change the salary of an employee from 55K to 61K, must obtain range locks in exclusive mode on both [55K,55K] and [61K,61K]. An efficient implementation of range locks is described in <ref> [20, 15] </ref>. The introduction of range locks requires very little change in the techniques described in this paper. In fact, the implementation of range locks described in [20] involves expressing each range lock as a set of regular locks on individual objects.
Reference: [16] <author> Won Kim, Jorge Garza, Nathaniel Ballou, and Darrell Woelk. </author> <title> Architecture of the ORION next-generation database system. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [17] <author> Henry Korth. </author> <title> Locking primitives in a database system. </title> <journal> JACM, </journal> <volume> 30(1):55|79, </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: For example, to lock the Telephone extent in S (X) mode, an IS (IX) lock must be obtained on the Object extent and S (X) locks must be obtained on the Telephone and PersonalCommunicator extents. Operation locks that can be applied at different granularities are considered by <ref> [17] </ref> in the context of a relational system. However, associating lock types with methods on classes gives opportunities for extensibility that do not exist in the relational context. Moreover, dynamic changes in a locking graph are not a concern in [17]. <p> that can be applied at different granularities are considered by <ref> [17] </ref> in the context of a relational system. However, associating lock types with methods on classes gives opportunities for extensibility that do not exist in the relational context. Moreover, dynamic changes in a locking graph are not a concern in [17]. The only previous work we are aware of that considers a dynamically changing locking graph is in the context of a knowledge base [9]. Their solution is to restrict the order of user lock requests.
Reference: [18] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> CACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Object-oriented databases (OODBs) have not taken full advantage of the experience of relational databases. Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. <ref> [11, 7, 18] </ref>). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems [7, 22, 8, 12, 10, 2, 18, 16, 11] include facilities to build collections consisting of lists of object identifiers (OIDs). <p> Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [19] <author> Chee Low, Beng Ooi, and Hongjun Lu. H-trees: </author> <title> A dynamic associative search index for oodb. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 134|143, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, not all (significant) collections need be indexed, and there could be multiple indices defined on a collection. Multiple collections could have a common index structure defined over them (cf., <ref> [19, 4] </ref>). The system maintains information about the relationship between each pair of significant collections. The binary relations inclusion and conflict (intersection) are used by the system.
Reference: [20] <author> C. Mohan and Frank Levine. ARIES/IM: </author> <title> An efficient and high concurrency index management method using write-ahead logging. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 371-380, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, the overhead would probably outweigh the minor benefits of identifying a few collections as (temporarily) having an inclusion rather than an intersection relationship. Locking Background In addition to the standard commit duration locks, three locking variants are also needed. This description follows <ref> [15, 20] </ref>. Obtaining a standard lock is quite expensive as it involves hashing, following hash chains, etc. Sometimes, latches are used instead. A latch is a lock on some physical unit (like a page) and is used to maintain physical consistency. <p> Of course, if the creator comes first, t 1 must block. Similarly, a transaction that wishes to change the salary of an employee from 55K to 61K, must obtain range locks in exclusive mode on both [55K,55K] and [61K,61K]. An efficient implementation of range locks is described in <ref> [20, 15] </ref>. The introduction of range locks requires very little change in the techniques described in this paper. In fact, the implementation of range locks described in [20] involves expressing each range lock as a set of regular locks on individual objects. <p> An efficient implementation of range locks is described in [20, 15]. The introduction of range locks requires very little change in the techniques described in this paper. In fact, the implementation of range locks described in <ref> [20] </ref> involves expressing each range lock as a set of regular locks on individual objects. These individual object locks can then be handled exactly as described above, with no change to our technique at all.
Reference: [21] <author> C. Mohan and Inderpal Narang. </author> <title> Algorithms for creating indexes for very large tables without quiescing updates. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 361-370, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Our work is in a more general 3 database context, where such restrictions on order may not be acceptable. Instead, we use intention locks. We make use of deferred updates in maintaining our lock graph. While no one has proposed the use of deferred updates for locking hierarchies, see <ref> [1, 24, 21] </ref> for some recent papers that use deferred updates for other purposes. 3 MOTIVATION Multi-granularity locking is used to resolve the tradeoff between concurrency and overhead|concurrency is increased if fine locking granules (e.g. records or fields) are used, but fine locking granules are very expensive for transactions that access <p> One key requirement is that the total order on collections defined using the intention relationship be changed only when no graph examiners are in the system. However, the new graph can be calculated while other transactions are proceedings by using techniques like those for on-line index construction <ref> [24, 21] </ref>.
Reference: [22] <author> Joel Richardson, Michael Carey, and Daniel Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM TOPLAS, </journal> <note> 1993. To appear. </note>
Reference-contexts: Some support only object-level locking (e.g. [8]). Many lack finer level locking granules than the page (e.g. [11, 7, 18]). However, multi-granularity locking is desirable for OODBs for the same reasons as for RDBs. Further, many systems <ref> [7, 22, 8, 12, 10, 2, 18, 16, 11] </ref> include facilities to build collections consisting of lists of object identifiers (OIDs).
Reference: [23] <author> A. Silberschatz and Z. Kedem. </author> <title> Consistency in hierarchical database systems. </title> <journal> JACM, </journal> <volume> 27(1):72|80, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: If t 2 acquires IL X (A) first, t 1 blocks and t 2 can get its locks. Using an ordering to reduce or eliminate deadlock is a standard technique <ref> [23, 25] </ref>.
Reference: [24] <author> V. Srinivasan and Michael Carey. </author> <title> Compensation-based on-line query processing. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 331-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Our work is in a more general 3 database context, where such restrictions on order may not be acceptable. Instead, we use intention locks. We make use of deferred updates in maintaining our lock graph. While no one has proposed the use of deferred updates for locking hierarchies, see <ref> [1, 24, 21] </ref> for some recent papers that use deferred updates for other purposes. 3 MOTIVATION Multi-granularity locking is used to resolve the tradeoff between concurrency and overhead|concurrency is increased if fine locking granules (e.g. records or fields) are used, but fine locking granules are very expensive for transactions that access <p> One key requirement is that the total order on collections defined using the intention relationship be changed only when no graph examiners are in the system. However, the new graph can be calculated while other transactions are proceedings by using techniques like those for on-line index construction <ref> [24, 21] </ref>.

References-found: 24

