URL: file://ftp.cs.wisc.edu/coral/doc/ruleord.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: fraghu,divesh,sudarshag@cs.wisc.edu.  
Title: Rule Ordering in Bottom-Up Fixpoint Evaluation of Logic Programs  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan 
Keyword: Index Terms: Bottom-up Evaluation, Control Expression, Cyclic Ordering, Deductive Database,  
Address: WI 53706,  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  
Note: The authors are with the  U.S.A. The authors' e-mail addresses are  
Abstract: Logic programs can be evaluated bottom-up by repeatedly applying all rules, in "iterations", until the fixpoint is reached. However, it is often desirable|and in some cases, e.g. programs with stratified negation, even necessary to guarantee the semantics|to apply the rules in some order. We present two algorithms that apply rules in a specified order without repeating inferences. One of them (GSN) is capable of dealing with a wide range of rule orderings but with a little more overhead than the well-known semi-naive algorithm (which we call BSN). The other (PSN) handles a smaller class of rule orderings, but with no overheads beyond those in BSN. We also demonstrate that by choosing a good ordering, we can reduce the number of rule applications (and thus joins). We present a theoretical analysis of rule orderings and identify orderings that minimize the number of rule applications (for all possible instances of the base relations) with respect to a class of orderings called fair orderings. We also show that while non-fair orderings may do a little better on some data sets, they can do much worse on others. The analysis is supplemented by performance results. This work was supported by a David and Lucile Packard Foundation Fellowship in Science and Engineering, a Presidential Young Investigator Award, with matching grants from Digital Equipment Corporation, Tandem and Xerox, NSF grants IRI-8804319 and IRI-9011563, and an IBM Faculty Development Award. A preliminary version of this paper appeared in the Proceedings of the Sixteenth International Conference on Very Large Data Bases, Brisbane, Australia, 1990. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: The first is a rewriting of the Pred-SCC S that defines "differential" versions of predicates, in order to distinguish facts that have been newly generated (and not yet used in inferences) from older facts. We present below a variant of the version described in <ref> [1] </ref>. For each predicate p defined in S, we have four predicates p; p old ; ffip old and ffip new .
Reference: [2] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and Mylopoulos, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [3] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Massachusetts, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: For example, in programs with stratified negation, lower strata must be evaluated before higher strata, and this simple ordering can become much more complex once we rewrite the program using Magic Sets <ref> [22, 3, 7, 20] </ref> (which is an important technique used widely to avoid inferences that are not "relevant" to the query). * Second, rule ordering can result in increased efficiency.
Reference: [4] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: In the second part of our paper, in Section 5, we study rule orderings in detail, and establish a close connection between cycles in rule graphs (which are a variant of rule/goal graphs defined in <ref> [4, 25] </ref>) and orderings that minimize the number of iterations and rule applications.
Reference: [5] <author> R. Bayer. </author> <title> Query evaluation and recursion in deductive database systems. </title> <note> Unpublished Memorandum, </note> <year> 1985. </year>
Reference: [6] <author> C. Beeri, S. Naqvi, R. Ramakrishnan, O. Shmueli, and S. Tsur. </author> <title> Sets and negation in a logic database language. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 21-37, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Thus, a derivation step consists of a non-leaf node and all its children in a derivation tree. 2 1 Our definitions and results can be extended to handle features such as negation, set grouping and aggrega tion <ref> [6] </ref>. 5 Note that the substitution is not applied to the children of p [] in the second part of the above definition.
Reference: [7] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: For example, in programs with stratified negation, lower strata must be evaluated before higher strata, and this simple ordering can become much more complex once we rewrite the program using Magic Sets <ref> [22, 3, 7, 20] </ref> (which is an important technique used widely to avoid inferences that are not "relevant" to the query). * Second, rule ordering can result in increased efficiency. <p> Rewriting the program P of Example 2.1 using Magic Sets, and evaluating the rewritten program also results in avoiding the derivation of anc (4; 5), since this is "irrelevant" to computing the answers to the query. Refer to <ref> [7, 20] </ref> for more details. 2 2.3 Control Expressions Helm [12, 11] introduced the notion of control on the bottom-up evaluation of logic programs using control expressions, and also looked at control as a way of increasing the efficiency of evaluation by eliminating some redundant derivations.
Reference: [8] <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Magic implementation of stratified programs. </title> <type> Manuscript, </type> <month> September 89. 44 </month>
Reference-contexts: The control expressions we use form a superset of those used by Imielinski and Naqvi [13]. It follows from [13] that our control expressions can be used to specify the inflationary semantics for negation ([14]). Our control expressions also form a superset of those used by Beeri et al. <ref> [8] </ref>. 3 General Semi-Naive Evaluation We now present a technique, General Semi-Naive, or GSN, evaluation, that makes facts computed by an application of a rule R available to all other rule applications immediately after the application of R, while maintaining the non-repetition property.
Reference: [9] <author> A. C. Fong and J. Ullman. </author> <title> Induction variables in very high-level languages. </title> <booktitle> In Proc. Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-112, </pages> <year> 1976. </year>
Reference: [10] <author> R. Gonzalez-Rubio, J. Rohmer, and A. Bradier. </author> <title> An overview of DDC: Delta Driven Computer. </title> <booktitle> In Parallel Architectures and Languages Europe, Volume 1: Parallel Architectures, Lecture Notes in Computer Science, </booktitle> <volume> No. 258, </volume> <pages> pages 414-433, </pages> <year> 1987. </year>
Reference-contexts: Schmidt [23] presents another 42 evaluation technique that allows for some ordering of rules; however, this technique also lacks the non-repetition property. Gonzalez-Rubio, Rohmer and Bradier <ref> [10] </ref> have independently proposed a parallel evaluation technique that has some similarity to GSN evaluation. The idea is to run a copy of the BSN algorithm on each processor, and to exchange facts as needed.
Reference: [11] <author> A. R. Helm. </author> <title> Detecting and eliminating redundant derivations in deductive database systems. </title> <type> Technical Report RC 14244 (#63767), </type> <institution> IBM Thomas Watson Research Center, </institution> <month> De-cember </month> <year> 1988. </year>
Reference-contexts: Although the orderings we consider for this purpose do not affect the number of inferences made, the processing becomes more set-oriented, with each rule application generating more tuples. * Finally, rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [12, 11, 13] </ref>. 2 In this paper, we use regular expressions over rules to specify orderings of the application of rules; we call these control expressions. <p> The algorithms we describe in this paper are independent of program rewriting techniques such as Magic Sets that also seek to reduce the number of derivations. We can apply such techniques (and other techniques that generate control expressions on rule applications <ref> [12, 11] </ref>) on a given program, and then evaluate the resultant program using our algorithms. <p> Rewriting the program P of Example 2.1 using Magic Sets, and evaluating the rewritten program also results in avoiding the derivation of anc (4; 5), since this is "irrelevant" to computing the answers to the query. Refer to [7, 20] for more details. 2 2.3 Control Expressions Helm <ref> [12, 11] </ref> introduced the notion of control on the bottom-up evaluation of logic programs using control expressions, and also looked at control as a way of increasing the efficiency of evaluation by eliminating some redundant derivations.
Reference: [12] <author> R. Helm. </author> <title> Inductive and deductive control of logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 488-511, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year>
Reference-contexts: Although the orderings we consider for this purpose do not affect the number of inferences made, the processing becomes more set-oriented, with each rule application generating more tuples. * Finally, rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [12, 11, 13] </ref>. 2 In this paper, we use regular expressions over rules to specify orderings of the application of rules; we call these control expressions. <p> The algorithms we describe in this paper are independent of program rewriting techniques such as Magic Sets that also seek to reduce the number of derivations. We can apply such techniques (and other techniques that generate control expressions on rule applications <ref> [12, 11] </ref>) on a given program, and then evaluate the resultant program using our algorithms. <p> Rewriting the program P of Example 2.1 using Magic Sets, and evaluating the rewritten program also results in avoiding the derivation of anc (4; 5), since this is "irrelevant" to computing the answers to the query. Refer to [7, 20] for more details. 2 2.3 Control Expressions Helm <ref> [12, 11] </ref> introduced the notion of control on the bottom-up evaluation of logic programs using control expressions, and also looked at control as a way of increasing the efficiency of evaluation by eliminating some redundant derivations.
Reference: [13] <author> T. Imielinski and S. Naqvi. </author> <title> Explicit control of logic programs through rule algebra. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 103-116, </pages> <year> 1988. </year>
Reference-contexts: Although the orderings we consider for this purpose do not affect the number of inferences made, the processing becomes more set-oriented, with each rule application generating more tuples. * Finally, rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [12, 11, 13] </ref>. 2 In this paper, we use regular expressions over rules to specify orderings of the application of rules; we call these control expressions. <p> The semantics of the control operators that we consider are different from those considered by Helm and we do not discuss the evaluation of Helm's control operators in this paper. The control expressions we use form a superset of those used by Imielinski and Naqvi <ref> [13] </ref>. It follows from [13] that our control expressions can be used to specify the inflationary semantics for negation ([14]). <p> The semantics of the control operators that we consider are different from those considered by Helm and we do not discuss the evaluation of Helm's control operators in this paper. The control expressions we use form a superset of those used by Imielinski and Naqvi <ref> [13] </ref>. It follows from [13] that our control expressions can be used to specify the inflationary semantics for negation ([14]).
Reference: [14] <author> P. Kolaitis and C. Papadimitriou. </author> <booktitle> Why not negation by fixpoint? In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 231-239, </pages> <year> 1988. </year>
Reference: [15] <author> J. Kuittinen, O. Nurmi, S. Sippu, and E. Soisalon-Soininen. </author> <title> Efficient implementation of loops in bottom-up evaluation of logic queries. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: In Section 5.4 we consider static orderings in which some rules can be applied more often than other rules. Such orderings are referred to as non-fair orderings. This class includes the class of nested orderings, such as those considered by Kuittinen et al. <ref> [15] </ref>. Non-fair orderings may perform somewhat better than fair orderings on some data sets, but, as we show in Section 5.4, such orderings may also perform considerably worse on other data sets. Hence, in the absence of any information about the kind of data sets, fair orderings are preferable. <p> Our performance study draws upon and extends the work of Kuittinen et al. <ref> [15] </ref>. We consider two programs, referred to as P 1 and P 2 in this section. 4 Mostly, we discuss P 1, and discuss P 2 only when it offers some additional insight. For a listing of these programs, our datasets, and further details of our performance evaluation, see [21]. <p> There is a cycle preserving fair ordering for each SCC of P 1 and P 2, and the column 4 P 1 is the same program that was used in <ref> [15] </ref>. 38 Data Set Basic Pred General 1 General 2 A10 3579 1535 1023 2812 F 10 23 10 7 18 Table 4: Program P 1: Number of Iterations "General 1" of the tables is for a GSN evaluation using such an ordering. <p> These numbers should not be used to directly compare different join techniques (i.e. the numbers in a single row of the table should not be compared). The performance study of Kuittinen et al. <ref> [15] </ref> only models the join cost in one way, the hashed join method. The performance results in Table 6 indicate that for the hash join strategy the total join cost closely parallels the number of non-null joins. PSN and GSN do consistently better than BSN under this metric. <p> The most closely related work is that of Kuittinen et al. <ref> [15] </ref>, who propose a fixpoint evaluation algorithm for logic programs based on the immediate utilization of facts. Their algorithm also reduces the number of iterations, and is dependent upon a choice of rule orderings. <p> Their algorithm also reduces the number of iterations, and is dependent upon a choice of rule orderings. They present a performance study of the effects of rule orderings, although they do not analyze the effect of rule orderings theoretically. The results presented in our paper and in <ref> [15] </ref> were obtained independently. (However, we have drawn upon and extended their performance evaluation.) Although the technique of Kuittinen et al. avoids repeating most derivations, it does not have the non-repetition property since it is possible for some derivations to be repeated. This can adversely affect performance.
Reference: [16] <author> T. S. Leask, K. Ramamohanarao, and P. J. Stuckey. </author> <title> Exploiting parallelism in bottom-up computation in Aditi. </title> <booktitle> In Proceedings of the Post ILPS'91 Workshop on Deductive Databases, </booktitle> <year> 1991. </year>
Reference-contexts: In a sequential evaluation of a program, PSN evaluation is always preferable to BSN evaluation, since it can be implemented with the same overheads per iteration, but can do better in terms of the number of iterations. The results of Leask et al. <ref> [16] </ref>, who did a performance evaluation of BSN, PSN and some parallel implementations of BSN using total elapsed time as a metric on a disk-based system, also indicate that PSN is the evaluation strategy of choice, in the absence of semantic information about the data in the base relations. <p> Since the overheads are implementation dependent and we currently lack an actual system to measure the overheads, we do not present the total cost. Some results comparing PSN with BSN using total elapsed time on a disk based system are presented in <ref> [16] </ref>. * The only comparisons that may be made from this table are the differences between the different evaluation strategies. These numbers should not be used to directly compare different join techniques (i.e. the numbers in a single row of the table should not be compared).
Reference: [17] <author> H. Lu. </author> <title> New strategies for computing the transitive closure of a database relation. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Databases, </booktitle> <pages> pages 267-274, </pages> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Other related work includes a scheme for ordering facts in a semi-naive evaluation proposed by Schmidt et al. [24]. In the context of transitive closure, Lu <ref> [17] </ref>, presents a technique for facts to be (partially) utilized in the same iteration that they were generated. There is also some connection to work on parallelizing transitive closure by using different expansions of the recursive rule.
Reference: [18] <author> M. J. Maher and R. Ramakrishnan. </author> <title> Deja vu in fixpoints of logic programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1990. </year> <month> 45 </month>
Reference-contexts: Thus, a derivation tree records which set of (previously generated) facts is used to generate a new fact using a rule, rather than the set of substitution instances of these facts that instantiated the rule. Derivation trees are important due to the following well-known property (see for example <ref> [18] </ref>): Proposition 2.1 For every fact t in the least Herbrand model, there is a derivation tree with root r, and a substitution such that t = r [], and for every fact r 0 that is the root of a derivation tree, each fact t 0 that is a ground <p> This can adversely affect performance. Further, it makes the algorithm inapplicable when the non-repetition property is used to perform further optimizations. (For example, if a program has the duplicate-freedom property, a fixpoint algorithm with the non-repetition property can be modified easily to eliminate run-time checks for duplicates <ref> [18] </ref>.) Finally, their technique handles only a subset of the rule orderings that GSN can handle. Schmidt [23] presents another 42 evaluation technique that allows for some ordering of rules; however, this technique also lacks the non-repetition property.
Reference: [19] <author> R. Paige and J. T. Schwatz. </author> <title> Reduction in strength of high level operations. </title> <booktitle> In Proc. Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 58-71, </pages> <year> 1977. </year>
Reference: [20] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: For example, in programs with stratified negation, lower strata must be evaluated before higher strata, and this simple ordering can become much more complex once we rewrite the program using Magic Sets <ref> [22, 3, 7, 20] </ref> (which is an important technique used widely to avoid inferences that are not "relevant" to the query). * Second, rule ordering can result in increased efficiency. <p> Rewriting the program P of Example 2.1 using Magic Sets, and evaluating the rewritten program also results in avoiding the derivation of anc (4; 5), since this is "irrelevant" to computing the answers to the query. Refer to <ref> [7, 20] </ref> for more details. 2 2.3 Control Expressions Helm [12, 11] introduced the notion of control on the bottom-up evaluation of logic programs using control expressions, and also looked at control as a way of increasing the efficiency of evaluation by eliminating some redundant derivations.
Reference: [21] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <type> Technical Report TR 1059, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison WI 53706, U.S.A., </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: The terminology used in the rest of this paper is introduced in Section 2, and related work is presented in Section 7. Due to space limitations, several proofs and details have been omitted. The performance study is also presented briefly. We direct the interested reader to <ref> [21] </ref> for a version of this paper with all proofs and additional discussion of several points. 3 2 Background 2.1 Definitions The language considered in this paper is that of Horn logic. <p> The intuition behind Claims 1 and 2 is that procedures GSN CE and Simple CE have the same recursive structure, and calls to GSN Rule make the same inferences as new inferences made by the corresponding naive rule application. For formal proofs see <ref> [21] </ref>. This ends the proof of the theorem. 2 Evaluating control expressions that contain the "+" operator using the GSN evaluation technique presents some difficulties. <p> Thus we have the following theorem (for a formal proof, see <ref> [21] </ref>). Theorem 3.3 Procedure GSN Prog has the non-repetition property, is sound, and if all the predicates defined in the program are safe, is complete wrt the least fixpoint semantics. 2 19 We illustrate GSN Prog using an example. Example 3.2 Consider again program P of Example 2.1. <p> Thus only one rule application can make any derivation. 2 For a full proof of this theorem, see <ref> [21] </ref>. 4.2 PSN for a Program Consider a program P . With each Pred-SCC S in P , we can associate all the (non-recursive and recursive) rules defining the predicates in S. <p> It is easy to show that the semantics of the control expression is equivalent to the fixpoint semantics of the program. From Theorem 4.1, it follows that the evaluation of the control expression is complete, and has the non-repetition property. Thus we have the following theorem (see <ref> [21] </ref> for a formal proof of correctness). <p> We now take any arbitrary O i r as above, and move elements after the last occurrence of R m to the head of the sequence, to get O i We present proof sketches for many of the results in this section. Full proofs may be found in <ref> [21] </ref>. For the class of fair orderings, we next show that cycle preserving fair orderings are optimal under the cost criterion of the number of iterations needed to compute the closure of an SCC, with an immediate update strategy. <p> As a heuristic, we suggest using the reverse of a depth-first search pop-out order of the rule graph as a rule ordering. This often generates cycle preserving orderings, but not always. For examples of depth-first search pop-out orders, see <ref> [21] </ref>. 5.4 Non-Fair Orderings In this section we consider static orderings in which some rules may be applied more often than other rules. <p> We consider two programs, referred to as P 1 and P 2 in this section. 4 Mostly, we discuss P 1, and discuss P 2 only when it offers some additional insight. For a listing of these programs, our datasets, and further details of our performance evaluation, see <ref> [21] </ref>. The above programs were hand-coded for each of the evaluation techniques, and measurements were made by running the resultant programs on several data sets (which are described in [21]. <p> For a listing of these programs, our datasets, and further details of our performance evaluation, see <ref> [21] </ref>. The above programs were hand-coded for each of the evaluation techniques, and measurements were made by running the resultant programs on several data sets (which are described in [21]. <p> There is also some connection to work on parallelizing transitive closure by using different expansions of the recursive rule. For a more detailed discussion of related work, see <ref> [21] </ref>. 8 Summary In this paper, we studied several aspects of rule ordering in the bottom-up evaluation of logic programs. Rule orderings are necessary for ensuring a desired semantics, such as the evaluation of the magic rewritten versions of stratified programs.
Reference: [22] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference-contexts: For example, in programs with stratified negation, lower strata must be evaluated before higher strata, and this simple ordering can become much more complex once we rewrite the program using Magic Sets <ref> [22, 3, 7, 20] </ref> (which is an important technique used widely to avoid inferences that are not "relevant" to the query). * Second, rule ordering can result in increased efficiency.
Reference: [23] <author> H. Schmidt. </author> <title> Meta-Level Control for Deductive Database Systems. </title> <booktitle> Lecture Notes in Computer Science, Number 479. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Schmidt <ref> [23] </ref> presents another 42 evaluation technique that allows for some ordering of rules; however, this technique also lacks the non-repetition property. Gonzalez-Rubio, Rohmer and Bradier [10] have independently proposed a parallel evaluation technique that has some similarity to GSN evaluation.
Reference: [24] <author> H. Schmidt, W. Kiessling, U. Guntzer, and R. Bayer. </author> <title> Compiling exploratory and goal-directed deduction into sloppy delta iteration. </title> <booktitle> In IEEE International Symposium on Logic Programming, </booktitle> <pages> pages 234-243, </pages> <year> 1987. </year>
Reference-contexts: It is possible to modify their technique and obtain an algorithm similar to GSN, although they do not address the issue of ordering rules. Other related work includes a scheme for ordering facts in a semi-naive evaluation proposed by Schmidt et al. <ref> [24] </ref>. In the context of transitive closure, Lu [17], presents a technique for facts to be (partially) utilized in the same iteration that they were generated. There is also some connection to work on parallelizing transitive closure by using different expansions of the recursive rule.
Reference: [25] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes I and II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: In the second part of our paper, in Section 5, we study rule orderings in detail, and establish a close connection between cycles in rule graphs (which are a variant of rule/goal graphs defined in <ref> [4, 25] </ref>) and orderings that minimize the number of iterations and rule applications.
Reference: [26] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year> <month> 46 </month>
Reference-contexts: This is important in the database context since the set of facts can be very large. However, the distinction is artificial, and we may choose to consider (a subset of) facts to be rules. The meaning of a logic program is given by its least Herbrand model <ref> [26] </ref>. From [26], this is equivalent to the least fixpoint semantics. A derived predicate p in a program P is said to be safe if, given any finite extension for each of the base predicates, p has a finite extension in the least Herbrand model of P . <p> This is important in the database context since the set of facts can be very large. However, the distinction is artificial, and we may choose to consider (a subset of) facts to be rules. The meaning of a logic program is given by its least Herbrand model <ref> [26] </ref>. From [26], this is equivalent to the least fixpoint semantics. A derived predicate p in a program P is said to be safe if, given any finite extension for each of the base predicates, p has a finite extension in the least Herbrand model of P .
References-found: 26

