URL: file://ftp.cs.wisc.edu/tech-reports/reports/94/tr1222.ps.Z
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Email: shore@cs.wisc.edu  
Title: Shoring Up Persistent Applications  
Author: Michael J. Carey, David J. DeWitt, Michael J. Franklin Nancy E. Hall, Mark L. McAuliffe, Jeffrey F. Naughton, Daniel T. Schuh, Marvin H. Solomon, C. K. Tan, Odysseas G. Tsatalos, Seth J. White, Michael J. Zwilling 
Address: Wisconsin|Madison  
Affiliation: Computer Sciences Department University of  
Abstract: SHORE (Scalable Heterogeneous Object REpository) is a persistent object system under development at the University of Wisconsin. SHORE represents a merger of object-oriented database and file system technologies. In this paper we give the goals and motivation for SHORE, and describe how SHORE provides features of both technologies. We also describe some novel aspects of the SHORE architecture, including a symmetric peer-to-peer server architecture, server customization through an extensible value-added server facility, and support for scalability on multiprocessor systems. An initial version of SHORE is already operational, and we expect a release of Version 1 in mid-1994. 
Abstract-found: 1
Intro-found: 1
Reference: [AS93] <author> Paul Adams and Marvin Solomon. </author> <title> An overview of the CAPITL software development environment. </title> <booktitle> In Proceedings of the Fourth International Workshop on Software Configuration Management, </booktitle> <address> Balti-more, MD, </address> <year> 1993. </year>
Reference-contexts: A typical example is provided by the CAPITL project <ref> [AS93] </ref>, which uses EXODUS. CAPITL improves on current software-development environments by maintaining a rich set of attributes and relationships for each object in its repository (program sources, object files, specifications, documents, etc.) It represents each object as a directed graph, with intra- and inter-object links represented by OIDs.
Reference: [BBKV87] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez. </author> <title> FAD, a powerful and simple database language. </title> <booktitle> In Proc. VLDB Conf., </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: A similar approach (in parallel, apply an arbitrary function to every member of a set) was used in the "filter" operation in the Bubba 10 project at MCC <ref> [BBKV87] </ref>. For Parallel SHORE, we distinguish between two forms of ParSets: primary and secondary. We use the terms "primary" and "secondary" by analogy to their common use with database indexes. Primary ParSets have a physical implication, in that primary ParSets are used for data partitioning.
Reference: [Cat93] <author> R. Cattell. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: At the time we designed EXODUS, we felt there was too much variability in type systems to legislate a common solution. Since then, there has been a growing consensus on the level of type support that an OODBMS system should provide <ref> [Cat93] </ref>. A second limitation of the EXODUS storage manager (ESM) is its client-server architecture. Users have constructed database servers or object servers as EXODUS client processes, leading to the "client-level server" problem illustrated in Figure 1. <p> to a more flexible process structure and support for typed objects, SHORE provides other services that end users should find attractive, including a name space and access 1 SDL is very closely related to ODL, a data definition language recently proposed as a standard by ODMG, an OODB vendor consortium <ref> [Cat93] </ref>. 2 control model similar to Unix, a Unix-compatible interface for legacy software tools, openness in the area of language bindings, and traditional database services such as associative data access, indexing, and clustering. The remainder of this paper is organized as follows. <p> SDL is quite similar in nature to the Object Definition Language (ODL) proposal from the ODMG consortium <ref> [Cat93] </ref>, which is descended from OMG's Interface Description Language (IDL), a dialect of the RPC interface language used in OSF's Distributed Computing Environment (DCE). Our work on SDL started at roughly the same time as ODMG's work, and we also used OMG's IDL as a starting point.
Reference: [CDF + 86] <author> Michael J. Carey, David J. Dewitt, Daniel Frank, Goetz Graefe, M. Muralikrishna, Joel E. Richardson, and Eugene J. Shekita. </author> <title> The architecture of the EXODUS Extensible DBMS. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <pages> pages 52-65, </pages> <year> 1986. </year>
Reference-contexts: We also expect many current OODB clients to find SHORE to be an attractive alternative. 1.1 EXODUS Many of us were involved in an earlier object-oriented database effort called EXODUS <ref> [CDF + 86] </ref>. Version 3.0 of EXODUS provides a client-server architecture with page-level locking, log-based recovery based on the ARIES algorithm [FZT + 92], and support for multiple servers and distributed transactions.
Reference: [CDN93] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: from our ftp site, it is used as the storage manager in the TI Open Object-Oriented Database System, it serves as the storage engine for at least one commercial product (MediaDB, a recently announced multi-media DBMS), and it has been shown to have commercially competitive performance on an OODBMS benchmark <ref> [CDN93] </ref>. 1 Nonetheless, EXODUS suffers from several limitations shared by many current persistent object stores. An exploration of these limitations may help to explain the motivation for SHORE. EXODUS storage objects are untyped arrays of bytes; correct interpretation of their contents is the responsibility of application programs. <p> We conclude in Section 5. The software described here is not simply "paperware." Much of the basic SHORE software is already operational; the system is now sufficiently complete that its C++ binding can run much of the OO7 benchmark <ref> [CDN93] </ref> in both client-server and parallel environments. We are expecting a full release of Version 1 of SHORE in mid-1994. 2 Basic SHORE System Concepts As a hybrid system, SHORE may be described as a file system augmented with database features or a DBMS with file-system features. <p> Finally, SHORE provides the notion of modules, to enable related types to be grouped together for name scoping and type management purposes. To provide a brief taste of SDL, Figure 5 shows how one of the OO7 benchmark <ref> [CDN93] </ref> types can be defined. 4 module oo7 - const long TypeSize = 10; enum BenchmarkOp - Trav1, Trav2, Trav3, etc -; // forward declarations interface Connection; interface CompositePart; interface AtomicPart - public: attribute char ptype [TypeSize]; attribute long x, y; relationship set&lt;Connection&gt; to inverse from; relationship set&lt;Connection&gt; from inverse to;
Reference: [CFZ93] <author> M. Carey, M. Franklin, and M. Zahari-oudakis. </author> <title> Fine-grained sharing in a page-server OODBMS. </title> <note> Submitted for publication., </note> <month> December </month> <year> 1993. </year>
Reference-contexts: To balance efficiency against the need for fine-grain concurrency, SHORE uses an adaptive version of call-back locking that can dynamically adjust the granularity (e.g., page vs. object) at which locking is performed depending on the presence of data conflicts <ref> [CFZ93] </ref>. This adaptive algorithm is based on the notion of lock de-escalation [LC89, Jos91]. 3.3.2 Transaction Management When an application wishes to commit a transaction, a commit request is sent to its local server.
Reference: [Deu91] <editor> O. Deux et al. </editor> <title> The o 2 system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Dynamic values can be linked together with local references, which are stored on disk as offsets from the start of the heap, but are swizzled in memory to actual memory addresses. The O2 commercial OODBMS <ref> [Deu91] </ref> provides a related facility with its objects/values distinction; the main difference is that in O2 the encapsulated values must 3 form a set, list, or array, whereas in SHORE the heap can contain an arbitrary data structure.
Reference: [DLPY93] <author> D. DeWitt, J. Luo, J. Patel, and J. Yu. </author> <title> Paradise | a parallel geographic information system. </title> <booktitle> In Proceedings of the ACM Workshop on Advances in Geographic Information Systems, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Second, SHORE supports the notion of a "value-added" server. The server code is modularly constructed to make it relatively simple for users to build application-specific servers without facing the "client-level server" problem. For example, the Paradise project <ref> [DLPY93] </ref> is already using the SHORE server to build a geographic information system. Finally, SHORE is intended to be much more of a complete system than ESM.
Reference: [DNSV93] <author> D. DeWitt, J. Naughton, J. Shafer, and S. Venkataraman. </author> <title> ParSet design document. </title> <type> Unpublished manuscript, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: contained within that composite part.) This will cause the master to send messages to all of the slaves, saying "apply T1 to all composite parts in your partition of the ParSet." The slaves will execute this request in parallel by talking to their local servers, 11 More detail appears in <ref> [DNSV93] </ref>. 12 CompositePart has an attribute called partID, which is separate from the OID of the composite part object fetching composite part objects into their object caches, and calling the T1 method on each one.
Reference: [FC92] <author> M. Franklin and M. Carey. </author> <title> Client-server caching revisited. </title> <booktitle> In Proceedings of the International Workshop on Distributed Object Management, </booktitle> <address> Edmonton, Canada, </address> <month> August </month> <year> 1992. </year> <note> (published as Distributed Object Management, </note> <editor> Ozsu, Dayal, Vaduriez, eds., </editor> <publisher> Mor-gan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993). </year>
Reference-contexts: These two types of caches are managed very differently. The SHORE servers' page caches are allowed to retain their contents across transaction boundaries (called inter-transaction caching). Cache consistency is maintained through the use of a callback locking protocol <ref> [HMN + 88, LLOW91, WR91, FC92] </ref>. The application/server interface, however does not support "upcalls." Requiring application processes to respond to remote procedure calls would interfere with other synchronization mechanisms used by many application programs such as threads packages, graphics (X11 or InterViews), and networking interfaces.
Reference: [FM92] <author> Edward W. Felten and Dylan McNamee. </author> <note> Newthreads 2.0 user's guide. </note> <month> August </month> <year> 1992. </year>
Reference-contexts: To support this goal, the ParSet implementation uses the "new threads" package <ref> [FM92] </ref>, which in turn uses PVM [Sun90] for interprocess communication. (PVM is a public-domain message passing library for writing parallel programs that runs on platforms ranging from networks of workstations to multiprocessors.) By using this portable parallel programming environment in the PSHORE implementation we hope to ensure that, like 11 SHORE,
Reference: [FZT + 92] <author> Michael J. Franklin, Michael J. Zwilling, C. K. Tan, Michael J. Carey, and David J. DeWitt. </author> <title> Crash recovery in client-server EXODUS. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 165-174, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Version 3.0 of EXODUS provides a client-server architecture with page-level locking, log-based recovery based on the ARIES algorithm <ref> [FZT + 92] </ref>, and support for multiple servers and distributed transactions. The EXODUS package includes the E programming language [RCS93], a variant of C++ that supports convenient creation and manipulation of persistent data structures. <p> In the future, we plan to implement the client-server extension to ARIES that was developed and implemented for the EXODUS Storage Manager <ref> [FZT + 92] </ref> and compare its performance to our simpler redo-at-server implementation. 3.3.3 OID Implementation The implementation of object identifiers (OIDs) has a considerable impact on how the rest of an object manager is implemented and on its performance. The SHORE Storage Manager uses two types of OIDs.
Reference: [HMN + 88] <author> J. Howard, M. Kazarand S. Menees, D. Nichols, M. Satyanarayanan, R. Side-botham, and M. West. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: These two types of caches are managed very differently. The SHORE servers' page caches are allowed to retain their contents across transaction boundaries (called inter-transaction caching). Cache consistency is maintained through the use of a callback locking protocol <ref> [HMN + 88, LLOW91, WR91, FC92] </ref>. The application/server interface, however does not support "upcalls." Requiring application processes to respond to remote procedure calls would interfere with other synchronization mechanisms used by many application programs such as threads packages, graphics (X11 or InterViews), and networking interfaces.
Reference: [Jos91] <author> A. Joshi. </author> <title> Adaptive locking strategies in a multi-node data sharing environment. </title> <booktitle> In Proc. 17th VLDB Conf., </booktitle> <address> Barcelona, Spain, </address> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: This adaptive algorithm is based on the notion of lock de-escalation <ref> [LC89, Jos91] </ref>. 3.3.2 Transaction Management When an application wishes to commit a transaction, a commit request is sent to its local server. If the transaction has modified data that is owned by multiple servers, then a two-phase commit protocol is used among the relevant servers.
Reference: [Kil92] <author> Michael F. Kilian. </author> <title> Parallel Sets: An Object-Oriented Methodology for Massively Parallel Programming. </title> <type> PhD thesis, </type> <institution> Harvard Center for Research in Computing Technology, </institution> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: target of our work in Parallel SHORE is to provide a framework under which operations over these large collections of objects can be run in parallel. 4.1 SHORE ParSets Currently, the basic parallel construct in SHORE is the ParSet (short for "Parallel Set.") The ParSet concept was proposed by Kilian <ref> [Kil92] </ref> as a way of adopting the data parallel approach to object-oriented parallel programming. There are two ways in which ParSets expose parallelism. First, set-oriented queries over ParSets can be parallelized in the same way that relational queries are parallelized in relational systems.
Reference: [LC89] <author> Tobin J. Lehman and Michael J. Carey. </author> <title> A concurrency control algorithm for memory-resident database systems. </title> <booktitle> In Proc. of the 3rd Int'l. Conf. on Foundations of Data Organization and Algorithms, </booktitle> <address> Paris, France, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: This adaptive algorithm is based on the notion of lock de-escalation <ref> [LC89, Jos91] </ref>. 3.3.2 Transaction Management When an application wishes to commit a transaction, a commit request is sent to its local server. If the transaction has modified data that is owned by multiple servers, then a two-phase commit protocol is used among the relevant servers.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: With demand-paging support for very large objects, each object heap closely resembles a small Object Store database <ref> [LLOW91] </ref>. 2.3 File System Features From a file system standpoint, SHORE provides two major services. First, to support object naming and space management in a world with many persistent objects, SHORE provides a flexible object namespace. <p> Ref&lt;AtomicPart p&gt; = ... ; p.update ()-&gt;swapXY (); The SHORE C++ binding implements collection types similarly to C++ OODBs <ref> [LLOW91, Obj92, Ont92, Ver92] </ref>: A template type such as Set&lt;Connection&gt; in Figure 6 contains a member function members that returns an iterator. <p> These two types of caches are managed very differently. The SHORE servers' page caches are allowed to retain their contents across transaction boundaries (called inter-transaction caching). Cache consistency is maintained through the use of a callback locking protocol <ref> [HMN + 88, LLOW91, WR91, FC92] </ref>. The application/server interface, however does not support "upcalls." Requiring application processes to respond to remote procedure calls would interfere with other synchronization mechanisms used by many application programs such as threads packages, graphics (X11 or InterViews), and networking interfaces.
Reference: [MHL + 92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pi--rahesh, and P. Schwarz. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Transactions on Database Systems, </journal> <month> March </month> <year> 1992. </year>
Reference-contexts: Transactions that only access data that is owned by the local server can commit locally. Thus, the peer-to-peer architecture incurs the additional overhead of distributed commit only when it is necessary. The transaction rollback and recovery facilities of SHORE are based on the ARIES recovery algorithm 9 <ref> [MHL + 92] </ref> extended for the client-server environment of SHORE. The client-server distinction reflects the roles played by the server with respect to an object. A server that owns an object is the one that stores the log for that object and that performs all recovery operations on the object.
Reference: [MNSS87] <author> S. P. Miller, B. C. Neuman, J. I. Schiller, and J. H. Saltzer. </author> <title> Section E.2.1: Kerberos authentication and authorization system. </title> <type> Technical Report Project Athena Technical Plan, </type> <institution> M.I.T. Project Athena, </institution> <address> Cambridge, MA, </address> <month> December </month> <year> 1987. </year>
Reference-contexts: The LIL also contains the Unix compatibility library, with procedures that emulate common file system calls such as open, read, and seek. Finally, the LIL is responsible for authenticating the application to the server using the Kerberos authentication system <ref> [MNSS87] </ref>. 3.2.2 The SHORE Server server in more detail. It is divided into two main components: a Server Interface, which communicates with applications, and the Storage Manager (SM), which manages the persistent object store. The Server Interface is responsible for providing 8 An OID contains a volume identifier.
Reference: [Obj92] <institution> Objectivity, Inc. </institution> <note> Objectivity reference manual. </note> <year> 1992. </year>
Reference-contexts: Ref&lt;AtomicPart p&gt; = ... ; p.update ()-&gt;swapXY (); The SHORE C++ binding implements collection types similarly to C++ OODBs <ref> [LLOW91, Obj92, Ont92, Ver92] </ref>: A template type such as Set&lt;Connection&gt; in Figure 6 contains a member function members that returns an iterator.
Reference: [Ont92] <author> Ontos, Inc. </author> <title> Ontos reference manual. </title> <year> 1992. </year>
Reference-contexts: Ref&lt;AtomicPart p&gt; = ... ; p.update ()-&gt;swapXY (); The SHORE C++ binding implements collection types similarly to C++ OODBs <ref> [LLOW91, Obj92, Ont92, Ver92] </ref>: A template type such as Set&lt;Connection&gt; in Figure 6 contains a member function members that returns an iterator.
Reference: [RCS93] <author> Joel E. Richardson, Michael J. Carey, and Daniel T. Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(3), </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Version 3.0 of EXODUS provides a client-server architecture with page-level locking, log-based recovery based on the ARIES algorithm [FZT + 92], and support for multiple servers and distributed transactions. The EXODUS package includes the E programming language <ref> [RCS93] </ref>, a variant of C++ that supports convenient creation and manipulation of persistent data structures. The functionality, performance, robustness, and low cost (free!) of EXODUS has made it a popular piece of software. EXODUS and its associated toolkit have been used in several projects at Wisconsin and elsewhere.
Reference: [RT74] <author> Dennis M. Ritchie and Ken Thompson. </author> <title> The unix time-sharing system. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: SHORE directory objects provide the same facilities as Unix directories. Familiar Unix concepts such as path name, subdirectory, parent directory, link (both hard and symbolic), and root directory are all defined as they are in Unix <ref> [RT74] </ref>. As in Unix, a directory is a set of hname; OIDi pairs. The OID can refer to any other SHORE object, but the system maintains the Unix invariant that the set of directories forms a single rooted tree. Directories and the objects they contain are called registered objects.
Reference: [SGK + 85] <author> R. Sandberg, D. Goldberg, S. Kleiman, D.Walsh, and B.Lyon. </author> <title> Design and implementation of the sun network filesystem. </title> <booktitle> In USENIX Summer Conference Proceedings, </booktitle> <year> 1985. </year>
Reference-contexts: Registered objects without text fields behave like /dev/null (they read as zero length and ignore attempts to change them). Anonymous objects can be accessed via cross references. For applications that cannot even be re-linked, we have constructed an NFS file server <ref> [SGK + 85] </ref>. An entire subtree of the SHORE name space can be "mounted" on an existing Unix file system.
Reference: [Sun90] <author> V. Sunderam. </author> <title> PVM: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 2(4), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: To support this goal, the ParSet implementation uses the "new threads" package [FM92], which in turn uses PVM <ref> [Sun90] </ref> for interprocess communication. (PVM is a public-domain message passing library for writing parallel programs that runs on platforms ranging from networks of workstations to multiprocessors.) By using this portable parallel programming environment in the PSHORE implementation we hope to ensure that, like 11 SHORE, PSHORE will also be usable by
Reference: [Ver92] <author> Versant, Inc. </author> <title> Versant reference manual. </title> <year> 1992. </year>
Reference-contexts: Ref&lt;AtomicPart p&gt; = ... ; p.update ()-&gt;swapXY (); The SHORE C++ binding implements collection types similarly to C++ OODBs <ref> [LLOW91, Obj92, Ont92, Ver92] </ref>: A template type such as Set&lt;Connection&gt; in Figure 6 contains a member function members that returns an iterator.
Reference: [WR91] <author> Y. Wang and L. Rowe. </author> <title> Cache consistency and concurrency control in a client/server dbms architecture. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <address> Denver, CO, </address> <month> June </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: These two types of caches are managed very differently. The SHORE servers' page caches are allowed to retain their contents across transaction boundaries (called inter-transaction caching). Cache consistency is maintained through the use of a callback locking protocol <ref> [HMN + 88, LLOW91, WR91, FC92] </ref>. The application/server interface, however does not support "upcalls." Requiring application processes to respond to remote procedure calls would interfere with other synchronization mechanisms used by many application programs such as threads packages, graphics (X11 or InterViews), and networking interfaces.
References-found: 27

