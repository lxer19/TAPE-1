URL: http://www.daimi.aau.dk/~tamtoft/Papers/PB503.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail: -fnielson,hrnielson,tamtoft-@daimi.aau.dk  
Title: Polymorphic Subtyping for Eoeect Analysis: the Algorithm  
Author: F.Nielson H.R.Nielson T.Amtoft 
Date: April 19, 1996  
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract: We study an annotated type and eoeect system that integrates let-poly-morphism, eoeects, and subtyping into an annotated type and eoeect system for a fragment of Concurrent ML. First a type inference algorithm and a procedure for constraint normalisation and simpliocation are deoned, and next they are proved syntactically sound with respect to the annotated type and eoeect system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.Amtoft, F.Nielson, H.R.Nielson, J.Ammann: </author> <title> Polymorphic Subtypes for Eoeect Analysis: the Semantics, </title> <year> 1996. </year>
Reference-contexts: 1 Introduction In a recent paper [8] we developed an annotated type and eoeect system for a fragment of Concurrent ML and in the companion paper <ref> [1] </ref> we proved it semantically sound. We now consider the algorithmic implications of the annotated type and eoeect system that integrates ML-style polymorphism (the let-construct), sub-typing (with the usual contravariant ordering for function spaces), and eoeects (for the set of idangerous variablesj). <p> Already in Deonition 2.1 we introduced the notion of well-formedness for constraint sets and type schemes; in [8] it was argued that this notion is essential for the semantic soundness of the inference system and this claim was substantiated in <ref> [1] </ref>. In addition we stipulate: Deonition 3.1 Types, behaviours, and substitutions are trivially well-formed. <p> The exclusion of the set FV (A; b) C# (rather than just FV (A; b)) is necessary in order to ensure f~ff ~ fig C" = f~ff ~ fig which is essential for semantic soundness <ref> [8, 1] </ref>.
Reference: [2] <author> Y.-C. Fuh and P. Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT '89. </booktitle> <volume> SLNCS 352, </volume> <year> 1989. </year> <month> 29 </month>
Reference-contexts: The techniques used are basically those of [9] and <ref> [2] </ref>, adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of form (C; t; b), and with respect to a oxed environment A.
Reference: [3] <author> Y.-C. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Com--puter Science, </journal> <volume> 73, </volume> <year> 1990. </year>
Reference-contexts: ; (b) If C; A ` e : oe & b then C 0 ; A ` e : oe & b (and has the same shape). 3 The Inference Algorithm In designing an inference algorithm W for the type inference system we are motivated by the overall approach of <ref> [9, 3] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour variables. <p> Atomicity of well-formed type constraints is responsible for disallowing constraint like (int ff) and (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the left hand side. This phenomenon can be found in <ref> [5, 3, 9] </ref> as well. <p> The algorithm follows the overall approach of [9, 4] except that as in <ref> [3] </ref> there are no explicit uniocation steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> The type part is isomorphic to the initial constraints, so this process may continue forever: we perform a second match and produce a second substitution R 2 , etc. To detect this situation we as in <ref> [3] </ref> make use of the equivalence relation and extend it with ff 1 ff 2 after the orst match that produced R 1 .
Reference: [4] <author> M. P. Jones. </author> <title> A theory of qualioed types. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 287306. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: Actually it could call itself recursively, rather than calling W, in all but one place 2 : the call to W immediately prior to the use of GEN to generalise the type of the let-bound identioer to a type scheme. The algorithm follows the overall approach of <ref> [9, 4] </ref> except that as in [3] there are no explicit uniocation steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly.
Reference: [5] <author> J. C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3), </volume> <year> 1991. </year>
Reference-contexts: Atomicity of well-formed type constraints is responsible for disallowing constraint like (int ff) and (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the left hand side. This phenomenon can be found in <ref> [5, 3, 9] </ref> as well.
Reference: [6] <author> H.R. Nielson and F. Nielson. </author> <title> Higher-order concurrent programs with onite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 8497. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: In many ways this would seem a sensible solution in that the actual structure of the type is of only minor importance. 28 Motivated by the goals of <ref> [6] </ref> of eventually incorporating more causal information also for behaviours, we shall favour another solution. This involves adding a new behaviour of form RECfi:b.
Reference: [7] <author> F. Nielson and H.R. Nielson. </author> <title> Constraints for polymorphic behaviours for Concurrent ML. </title> <booktitle> In Proc. </booktitle> <address> CCL'94. SLNCS 845, </address> <year> 1994. </year>
Reference-contexts: Fact 3.4 For all constants c, the type scheme TypeOf (c) is essentially simple. The notion of simplicity is taken from [11] and is used also in <ref> [7] </ref> and is a way to overcome the need for otherwise having to perform uniocation (or decomposition) in a non-free algebra (like the algebra of behaviours).
Reference: [8] <author> H.R.Nielson, F.Nielson, T.Amtoft: </author> <title> Polymorphic Subtypes for Eoeect Analysis: the Integration, </title> <year> 1996. </year>
Reference-contexts: 1 Introduction In a recent paper <ref> [8] </ref> we developed an annotated type and eoeect system for a fragment of Concurrent ML and in the companion paper [1] we proved it semantically sound. <p> through communication; this is quite analogous to the way the absence of recursive types in the simply typed -calculi forbids deoning the Y combinator and instead requires recursion to be an explicit primitive in the language. 2 Inference System In this section we brieAEy recapitulate the inference system presented in <ref> [8] </ref>. <p> C 0 and we say that the type scheme 8 (~ff ~ fi : C 0 ): t 0 is solvable from C by S 0 if Dom (S 0 ) f~ff ~ fig and if C ` S 0 C 0 . 2.1 Properties of the Inference System In <ref> [8] </ref> we proved the lemmas below which express how to get valid judgements from valid judgements: we shall see that these results are crucial for showing 5 soundness of our inference algorithm. <p> Already in Deonition 2.1 we introduced the notion of well-formedness for constraint sets and type schemes; in <ref> [8] </ref> it was argued that this notion is essential for the semantic soundness of the inference system and this claim was substantiated in [1]. In addition we stipulate: Deonition 3.1 Types, behaviours, and substitutions are trivially well-formed. <p> This phenomenon can be found in [5, 3, 9] as well. It is responsible for making the algorithm a iconservative extensionj (cf. <ref> [8] </ref>) of the way algorithm W for Standard ML would operate if eoeects were not taken into account: in particular our algorithm will fail, rather than produce an unsolvable constraint set, if the underlying type constraints of the eoeect-free system cannot be solved. <p> The exclusion of the set FV (A; b) C# (rather than just FV (A; b)) is necessary in order to ensure f~ff ~ fig C" = f~ff ~ fig which is essential for semantic soundness <ref> [8, 1] </ref>. <p> that it no longer holds in general that the substitution S used in Lemma 5.11 is simple; so if we were to extend R with the rules in Figure 9 we would lose the property that the inference tree iconstructed byj the inference algorithm is isimplej. 6 Experimental Results In <ref> [8] </ref> we considered the program fn f =&gt; let id = fn y =&gt; (if true then f else fn x =&gt; (sync (send (channel (), y)); x)); in id id which demonstrated the power of our inference system relative to other approaches. <p> We then have ; ` S 0 3 S 0 1 C as desired. 9 Conclusion We have developed an inference algorithm for a previously developed annotated type and eoeect system that integrates polymorphism, subtyping and eoeects <ref> [8] </ref>. Although the development was performed for a fragment of Concurrent ML we believe it equally possible for Standard ML with references.
Reference: [9] <author> G. S. Smith. </author> <title> Polymorphic inference with overloading and subtyping. </title> <booktitle> In SLNCS 668, Proc. TAPSOFT '93, </booktitle> <year> 1993. </year> <title> Also see: Principal Type Schemes for Functional Programs with Overloading and Subtyping: </title> <booktitle> Science of Computer Programming 23, </booktitle> <pages> pp. 197-226, </pages> <year> 1994. </year>
Reference-contexts: ; (b) If C; A ` e : oe & b then C 0 ; A ` e : oe & b (and has the same shape). 3 The Inference Algorithm In designing an inference algorithm W for the type inference system we are motivated by the overall approach of <ref> [9, 3] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour variables. <p> Atomicity of well-formed type constraints is responsible for disallowing constraint like (int ff) and (t 1 fi t 2 ff) by forcing ff to be replaced by a type expression that imatchesj the left hand side. This phenomenon can be found in <ref> [5, 3, 9] </ref> as well. <p> Actually it could call itself recursively, rather than calling W, in all but one place 2 : the call to W immediately prior to the use of GEN to generalise the type of the let-bound identioer to a type scheme. The algorithm follows the overall approach of <ref> [9, 4] </ref> except that as in [3] there are no explicit uniocation steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> The only novelty in the clause for let is the function GEN used for generalisation: GEN (A; b)(C; t) = let f~ff ~ fig = (FV (t) ) n (FV (A; b) ) f~ff ~ fig 2 Interestingly, this is exactly the place where the algorithm of <ref> [9] </ref> makes use of constraint simpliocation in the iclosej function; however, our prototype implementation suggests that the choice embodied in the deonition of W gives faster performance. 9 W 0 (A; c) = if c 2 Dom (TypeOf) then INST (TypeOf (c)) else fail const W 0 (A; x) = if <p> The techniques used are basically those of <ref> [9] </ref> and [2], adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of form (C; t; b), and with respect to a oxed environment A. <p> We now explain the rules: (redund) removes constraints which are redundant due to the ordering being reAEexive and transitive; applying this rule repeatedly is 18 called itransitive reductionj in <ref> [9] </ref> and is essential for a compact representation of the constraints. The remaining rules all replace some variable fl by another variable fl 0 . <p> The rule (cycle) collapses cycles in the graph; due to the remark above a cycle which involves two elements of FV (A) cannot be eliminated. (However, in <ref> [9] </ref> it holds that ; ` b 1 j b 2 implies b 1 = b 2 and hence cycle elimination can be part of the analogue of F.) The rule (shrink) expresses that a variable fl can be replaced by its iimmediate predecessorj fl 0 , and due to the
Reference: [10] <author> J. P. Talpin and P. Jouvelot. </author> <title> The type and eoeect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year>
Reference-contexts: Clearly this solves all behaviour constraints in C that were of the form (fi 1 fi 2 ) since in S 0 2 S 0 they appear as (fi fl fi fl ). (A less crude approach would be to adopt the ideas of canonical solution from <ref> [10] </ref> but this is best combined with the construction of S 0 3 below.) The remaining non-trivial constraints in S 0 2 S 0 1 C are ft 1 chang fi fl , , ft n chang fi fl for n 0. <p> If fi fl does not occur in any of t 1 ; ; t n we could follow <ref> [10] </ref> and deone S 0 3 by letting it map fi fl to fi fl [ ft 1 chang [ [ ft n chang and perhaps even dispense with the ifi fl [ j. This situation corresponds to the scenario in [10] where the type inference algorithm enforces that fi fl <p> t 1 ; ; t n we could follow <ref> [10] </ref> and deone S 0 3 by letting it map fi fl to fi fl [ ft 1 chang [ [ ft n chang and perhaps even dispense with the ifi fl [ j. This situation corresponds to the scenario in [10] where the type inference algorithm enforces that fi fl does not occur in t 1 ; ; t n by terminating with failure if the condition is not met. <p> However, we shall take the view that it is too demanding to always forbid such use of the communication capabilities and thus depart from <ref> [10] </ref>.
Reference: [11] <author> J. P. Talpin and P. Jouvelot. </author> <title> Polymorphic Type, Region and Eoeect Inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3), </volume> <pages> pages 245271, </pages> <year> 1992. </year> <month> 30 </month>
Reference-contexts: Fact 3.4 For all constants c, the type scheme TypeOf (c) is essentially simple. The notion of simplicity is taken from <ref> [11] </ref> and is used also in [7] and is a way to overcome the need for otherwise having to perform uniocation (or decomposition) in a non-free algebra (like the algebra of behaviours).
References-found: 11

