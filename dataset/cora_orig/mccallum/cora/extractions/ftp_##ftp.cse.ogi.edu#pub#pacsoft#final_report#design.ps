URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/final_report/design.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p_report.html
Root-URL: http://www.cse.ogi.edu
Title: Design of the SDRR Pipeline  
Author: James Hook Jeffrey M. Bell 
Note: Contents  
Date: February 27, 1995  
Affiliation: Pacific Software Research Center  
Abstract: Software Design for Reliability and Reuse (SDRR) is a program generation technology based on a core of reusable program transformation tools. This report outlines the top-level design of the tools constructed in the proof-of-concept demonstration project. The SDRR system was designed with goals of simplicity, redundant functionality, incremental development, interoperability, and structure preservation. To meet the requirements specification and accomplish these goals, a suite of tools was developed and integrated into a linear pipeline of program transformations forming a software component generator. We describe the design goals, the structure of the pipeline, and design issues raised in the development process. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> A Standard ML compiler, </title> <month> August </month> <year> 1987. </year> <title> Distributed as documentation with the compiler. </title>
Reference-contexts: The languages indicated in this diagram are not all distinct. Table 3 summarizes the languages and their relation to one another. Of these languages, only SML and CAML have independent compilers supported by external organizations. The SML/NJ compiler is supported by AT&T Bell Laboratories and by Princeton University <ref> [1] </ref>. The CAML compiler is supported by INRIA, the French national laboratory for computer science [24]. ADL is translated directly into SML and depends upon the SML/NJ compiler, including its type checking.
Reference: [2] <author> Andrew W. Appel, James S. Mattson, and David R. Tarditi. </author> <title> A lexical analyzer generator for Standard ML, </title> <month> May </month> <year> 1994. </year> <title> Distributed as documentation with ML-Lex. </title> <type> 19 </type>
Reference-contexts: It uses traditional compiler generation technology to do lexical analysis and parsing (ML-yacc [51] and ML-lex <ref> [2] </ref>, which are distributed with the SML/NJ distribution). The typechecker and code generation sections are written by hand, with some use of CRML's capability for automatic generation of control structures from datatype declarations. The generated code is expressed in ADL, a high-level functional language.
Reference: [3] <author> Jeffrey Bell et al. </author> <title> Software design for reliability and reuse: A proof-of-concept demonstration. </title> <booktitle> In TRI-Ada '94 Proceedings, </booktitle> <pages> pages 396-404. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The Software Design for Reliability and Reuse (SDRR) project has at its core an architecture for software generation. In the proof-of-concept demonstration an instance of this architecture was constructed that generates Ada programs for the Message Translation and Validation problem domain <ref> [3] </ref>. This document describes the design of the generator built during the proof-of-concept phase. It identifies those aspects of the design that are domain specific and those that are reusable. It also captures some of the design issues that were raised during the implementation phase.
Reference: [4] <author> Jeffrey M. Bell. </author> <title> An implementation of Reynold's defunctionalization method for a modern functional language. </title> <type> Master's thesis, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Program transformations to first-order form. (a) Specialization: the elimination of higher-order functions by making new instances for all function values used. Roughly speaking this is expansion of all instances of higher-order functions by "inlining". (b) Defunctionalization: the elimination of higher-order functions by encoding higher-order values in data structures <ref> [4] </ref>. When both methods are applicable specialization is preferred. However, defunctionalization is more general. 3. Enabling transformations Initially these were just the plumbing transformations and translations necessary to make certain previously developed tools fit into the pipeline. As the project developed, these became specific, potentially reusable transformations. <p> It is unnecessary for the MTV generator. It implements Reynolds' algorithm for defunctionalization <ref> [44, 4] </ref>. Astre RM L 1 ML2AST AST RE Astre AST RE CAM L CAM L The Astre tool was successfully developed and can be integrated into the pipeline. It was not required in the MTV generator. Astre is a first-order program transformation system based on term-rewriting [6, 5].
Reference: [5] <author> Fran~coise Bellegarde. ASTRE, </author> <title> a transformation system using completion. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1991. </year>
Reference-contexts: Astre RM L 1 ML2AST AST RE Astre AST RE CAM L CAM L The Astre tool was successfully developed and can be integrated into the pipeline. It was not required in the MTV generator. Astre is a first-order program transformation system based on term-rewriting <ref> [6, 5] </ref>. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling [8, 9, 7, 10].
Reference: [6] <author> Fran~coise Bellegarde. </author> <title> Program transformation and rewriting. </title> <booktitle> In Proceedings of the fourth conference on Rewriting Techniques and Applications, volume 488 of LNCS, </booktitle> <pages> pages 226-239, </pages> <address> Berlin, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Astre RM L 1 ML2AST AST RE Astre AST RE CAM L CAM L The Astre tool was successfully developed and can be integrated into the pipeline. It was not required in the MTV generator. Astre is a first-order program transformation system based on term-rewriting <ref> [6, 5] </ref>. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling [8, 9, 7, 10].
Reference: [7] <author> Fran~coise Bellegarde. Astre: </author> <title> Towards a fully automated program transformation system. </title> <type> Technical Report 94-027, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Astre is a first-order program transformation system based on term-rewriting [6, 5]. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling <ref> [8, 9, 7, 10] </ref>. It can also be used interactively to accomplish a wide range of program optimizations, including the introduction of accumulator variables and other fold/unfold transformations. The Astre system operates on sets of mutually recursive first-order functions on free algebras defined by systems of equations.
Reference: [8] <author> Fran~coise Bellegarde. </author> <title> Automatic transformations by rewriting techniques. </title> <type> Technical Report 94-009, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Astre is a first-order program transformation system based on term-rewriting [6, 5]. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling <ref> [8, 9, 7, 10] </ref>. It can also be used interactively to accomplish a wide range of program optimizations, including the introduction of accumulator variables and other fold/unfold transformations. The Astre system operates on sets of mutually recursive first-order functions on free algebras defined by systems of equations.
Reference: [9] <author> Fran~coise Bellegarde. </author> <title> Induction and synthesis for automatic program transformation. </title> <type> Technical Report 94-022, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Astre is a first-order program transformation system based on term-rewriting [6, 5]. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling <ref> [8, 9, 7, 10] </ref>. It can also be used interactively to accomplish a wide range of program optimizations, including the introduction of accumulator variables and other fold/unfold transformations. The Astre system operates on sets of mutually recursive first-order functions on free algebras defined by systems of equations.
Reference: [10] <author> Fran~coise Bellegarde. </author> <title> Termination issues in automated synthesis. </title> <type> Technical Report 94-028, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Astre is a first-order program transformation system based on term-rewriting [6, 5]. It existed as an interactive tool prior to the start of the project. Astre was extensively modified to make it function automatically. Astre is capable of automatically performing deforestation, fusion and tupling <ref> [8, 9, 7, 10] </ref>. It can also be used interactively to accomplish a wide range of program optimizations, including the introduction of accumulator variables and other fold/unfold transformations. The Astre system operates on sets of mutually recursive first-order functions on free algebras defined by systems of equations.
Reference: [11] <author> Richard S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design, volume 36 of NATO Series F. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol <ref> [11, 12, 39] </ref> and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19]. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [12] <author> Richard S. Bird. </author> <title> Lectures on constructive functional programming. </title> <editor> In M. Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, volume 52 of NATO Series F. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol <ref> [11, 12, 39] </ref> and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19]. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [13] <institution> Pacific Software Research Center. Management plan for the OGI SDRR technology development and validation program, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: At the end of each development phase, the plan calls for a review and replan of development for the following phase. The design decisions described in this section were made as part of these planning and replanning efforts. Other processes described in the Technical Plan, Management Plan <ref> [13] </ref>, and Measurement Plan [14] were key to the success of developing software with an evolving design. The change control board consisted of the entire team, which made technical issues visible to all concerned. Weekly project meetings allowed the team to act quickly to investigate technical issues.
Reference: [14] <institution> Pacific Software Research Center. Measurement plan for the OGI SDRR technology development and validation program, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: The design decisions described in this section were made as part of these planning and replanning efforts. Other processes described in the Technical Plan, Management Plan [13], and Measurement Plan <ref> [14] </ref> were key to the success of developing software with an evolving design. The change control board consisted of the entire team, which made technical issues visible to all concerned. Weekly project meetings allowed the team to act quickly to investigate technical issues.
Reference: [15] <institution> Pacific Software Research Center. Technical plan for the OGI SDRR technology development and validation program, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: The issue of preserving other structural information is an open research question. 15 5 Design Issues Raised in Development From the outset of the SDRR project, an evolving system design was expected and planned. The SDRR Technical Plan <ref> [15] </ref> describes the three phase incremental development process for the SDRR system, with an integrated prototype as a product of each phase. At the end of each development phase, the plan calls for a review and replan of development for the following phase.
Reference: [16] <institution> Pacific Software Research Center. </institution> <note> SDRR project phase i final scientific and technical report, Febru-ary 1995. </note>
Reference: [17] <author> Wei-Ngan Chin and John Darlington. </author> <title> Higher-order removal: A modular approach. Unpublished work, </title> <year> 1993. </year>
Reference-contexts: In the MTV generator Chin (Simplify) works in all cases; Firstify is unnecessary. RM L Chin RM L 1 CRM L The specialization algorithm in the Chin (Simplify) tool was originally based on an unpublished paper by Chin and Darlington <ref> [17] </ref>. Chin's original algorithm had to be extended and revised to work in our environment. In general, Chin's algorithm does not necessarily produce a first-order program. <p> For these reasons we elected to begin developing an alternative implementation of Schism's critical functionality, while still continuing to experiment with the use of Schism in the pipeline. The alternative was an implementation of an algorithm <ref> [17] </ref> to perform specialization in a typed language.
Reference: [18] <author> J. R. B. Cockett. </author> <title> About Charity. </title> <type> Technical Report 92/480/18, </type> <institution> University of Calgary, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino [27] and of Cockett's Charity group <ref> [18, 19] </ref>. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [19] <author> J. R. B. Cockett and D. Spencer. </author> <title> Strong categorical datatypes. </title> <editor> In R. A. G. Seely, editor, </editor> <booktitle> International Meeting on Category Theory, 1991. AMS, </booktitle> <year> 1992. </year> <month> 20 </month>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino [27] and of Cockett's Charity group <ref> [18, 19] </ref>. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [20] <author> Charles Consel. </author> <title> The Schism Manual, version 2.0. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1992. </year>
Reference-contexts: hand by not working to a tight integration, standards for the use of the SML module facility in tool implementations were not developed and enforced in inspections. 5.2 Design issues raised in post-prototype-one replanning 5.2.1 Schism Schism is a partial evaluator for a subset of Scheme, an untyped LISP dialect <ref> [20, 21, 22] </ref>. Schism was developed by Charles Consel, who was initially an active participant in the project but subsequently left OGI. Ultimately, Schism was not included in the pipeline.
Reference: [21] <author> Charles Consel. </author> <title> A tour of schism. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, PEPM'93, </booktitle> <pages> pages 145-154, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher> <year> 1993. </year>
Reference-contexts: hand by not working to a tight integration, standards for the use of the SML module facility in tool implementations were not developed and enforced in inspections. 5.2 Design issues raised in post-prototype-one replanning 5.2.1 Schism Schism is a partial evaluator for a subset of Scheme, an untyped LISP dialect <ref> [20, 21, 22] </ref>. Schism was developed by Charles Consel, who was initially an active participant in the project but subsequently left OGI. Ultimately, Schism was not included in the pipeline.
Reference: [22] <author> Charles Consel and Olivier Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: hand by not working to a tight integration, standards for the use of the SML module facility in tool implementations were not developed and enforced in inspections. 5.2 Design issues raised in post-prototype-one replanning 5.2.1 Schism Schism is a partial evaluator for a subset of Scheme, an untyped LISP dialect <ref> [20, 21, 22] </ref>. Schism was developed by Charles Consel, who was initially an active participant in the project but subsequently left OGI. Ultimately, Schism was not included in the pipeline.
Reference: [23] <author> Robert L. Constable, Todd B. Knoblock, and Joseph L. Bates. </author> <title> Writing programs that construct proofs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 285-326, </pages> <year> 1985. </year>
Reference-contexts: It included a module known as tactic and control which was to select and control the transformation process, modeled after LCF-style tactics found in theorem provers and program transformation systems <ref> [26, 23] </ref>. At the time we believed that partial evaluation might be profitable at multiple stages of the pipeline, and we were concerned with maintaining "out of band" information. The notion of tactic and control was not in the technical plan delivered in August 1993.
Reference: [24] <author> Guy Cousineau. </author> <title> The categorical abstract machine. </title> <editor> In Gerard Huet, editor, </editor> <booktitle> Logical foundations of functional programming, </booktitle> <pages> pages 25-45. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Of these languages, only SML and CAML have independent compilers supported by external organizations. The SML/NJ compiler is supported by AT&T Bell Laboratories and by Princeton University [1]. The CAML compiler is supported by INRIA, the French national laboratory for computer science <ref> [24] </ref>. ADL is translated directly into SML and depends upon the SML/NJ compiler, including its type checking.
Reference: [25] <author> Leonidas Fegaras, Tim Sheard, and Tong Zhou. </author> <title> Improving programs which recurse over multiple inductive structures. </title> <booktitle> In Proceedings from Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1994. </year>
Reference-contexts: HOT uses an eager strategy to apply the transformations. This can result in code blow-up. The transformations used in HOT to transform higher-order programs have not been previously implemented. These transformations extend the work of Malcom and others to more general datatypes and higher-order functions <ref> [38, 25, 48, 49] </ref>. The critical functionality of HOT was also present in Astre. In addition to fusion and deforestation, HOT does a significant amount of specialization. A subsequent specialization stage is still needed, however, because HOT is not guaranteed to produce first-order code.
Reference: [26] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: It included a module known as tactic and control which was to select and control the transformation process, modeled after LCF-style tactics found in theorem provers and program transformation systems <ref> [26, 23] </ref>. At the time we believed that partial evaluation might be profitable at multiple stages of the pipeline, and we were concerned with maintaining "out of band" information. The notion of tactic and control was not in the technical plan delivered in August 1993.
Reference: [27] <author> T. Hagino. </author> <title> A Categorical Programming Language. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino <ref> [27] </ref> and of Cockett's Charity group [18, 19]. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [28] <author> James Hook, Richard Kieburtz, and Tim Sheard. </author> <title> Generating programs by reflection. </title> <type> Technical Report 92-015, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Furthermore, it was also expected that CRML would be used as the primary implementation language for the project because it had the capability to support the Squigol-style of programming built into ADL through its use of reflection on datatype structures <ref> [46, 28] </ref>. However, at the same time it was recognized that the restriction to core ML would prohibit us from benefiting from the rich module system provided by Standard ML; something that we expected to be a significant resource in a large system.
Reference: [29] <author> James Hook and Tim Sheard. </author> <title> A semantics of compile-time reflection. </title> <type> Technical Report 93-019, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1993. </year>
Reference-contexts: earlier work, Sheard had investigated adding reflection to Standard ML; that is, adding the ability for programs to write and evaluate fragments of programs while compiling. (This feature is found in LISP dialects.) He developed a system called Compile-Time Reflective ML (CRML), which included tools for manipulating core ML 1 <ref> [47, 45, 29, 50] </ref>. Many concepts in the SDRR pipeline were initially explored in the context of the CRML system. At the beginning of the project it was expected that the CRML encoding of core ML would be the internal representation for all ML abstract syntax.
Reference: [30] <author> Thomas Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <editor> In J-P. Jouan-naud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <volume> volume 201, </volume> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: ADL is a critical tool; its functionality is not duplicated anyplace else in the system. Lambda-lifter SM L Lambda lifter RM L CRM L 12 Standard ML programs can have embedded declarations and anonymous functions. The lambda-lifter tool lifts all such declarations to the top-level <ref> [30] </ref>. Standard ML also has a general pattern-matching facility in its function definitions and case statements.
Reference: [31] <author> Richard Kieburtz and Jeffrey R. Lewis. </author> <title> Programming with algebras. </title> <year> 1993. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms <ref> [31, 32, 37] </ref>. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19].
Reference: [32] <author> Richard Kieburtz and Jeffrey R. Lewis. </author> <title> Algebraic design language. </title> <type> Technical Report 94-002, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: The MSL design and compiler. The language design was a significant design deliverable [55]. 3. Semantics preserving transformations on the ADL representation. The ADL language design is given in a technical report <ref> [32] </ref>. 4. A translator from ADL to a Standard ML [40] based representation. In conjunction with the MSL translator (2), this translator would provide a rapid prototyping capability for the generator. Users of the generator could thus quickly compile and execute a MSL specification to test its functionality. 5. <p> ADL is a new language based on work in the functional programming and categorical programming paradigms <ref> [31, 32, 37] </ref>. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19].
Reference: [33] <author> Richard B. Kieburtz. </author> <title> Results of the sdrr validation experiment, </title> <month> February </month> <year> 1995. </year> <note> In [16]. </note>
Reference-contexts: The redundant functionality of Astre with HOT gave us the freedom to make this decision. 6 System Deployment The system was deployed in a validation experiment <ref> [33] </ref>. The configuration selected for deployment was a mature version of prototype 2. Since the experiment was fundamentally testing usability and human productivity improvements with generator-based technology we did not require some of the advanced features of the third prototype.
Reference: [34] <author> Alexei Kotov. </author> <title> Application of a new software metric in a research environment. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Decisions concerning the elimination of non-critical functionality include the following. 1. Based on measurement data, in May of 1994 we were able to predict that we would not be able to deliver on time if we included all currently planned capabilities <ref> [34, 35] </ref>. As a result, we decided to not develop the templates capability of the program instantiator for delivery of the MTV generator. 2. As final integration and system testing of the MTV generator progressed, it became clear that the functionality of Firstify was not required.
Reference: [35] <author> Alexei Kotov. </author> <note> Measurement final report, February 1995. In [16]. </note>
Reference-contexts: Decisions concerning the elimination of non-critical functionality include the following. 1. Based on measurement data, in May of 1994 we were able to predict that we would not be able to deliver on time if we included all currently planned capabilities <ref> [34, 35] </ref>. As a result, we decided to not develop the templates capability of the program instantiator for delivery of the MTV generator. 2. As final integration and system testing of the MTV generator progressed, it became clear that the functionality of Firstify was not required.
Reference: [36] <author> Jeffrey R. Lewis. </author> <title> A specification for an MTV generator. </title> <type> Technical Report 94-003, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: This requirement was decomposed as follows: 1. Requirements analysis. The requirements for the message specification language (MSL) and the required functionality for solution components were identified in a document <ref> [36] </ref>. 2. The MSL design and compiler. The language design was a significant design deliverable [55]. 3. Semantics preserving transformations on the ADL representation. The ADL language design is given in a technical report [32]. 4. A translator from ADL to a Standard ML [40] based representation.
Reference: [37] <author> Jeffrey R. Lewis. </author> <title> ADL translator tool documentation, </title> <month> January </month> <year> 1995. </year> <title> In Collected Tool Documentation for MTV Generator (CDRL 002.7). </title> <type> 21 </type>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms <ref> [31, 32, 37] </ref>. Specifically, it builds on the calculational style of programming called Squigol [11, 12, 39] and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19].
Reference: [38] <author> G. Malcolm. </author> <title> Homomorphisms and promotability. In Mathematics of Program Construction. </title> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: HOT uses an eager strategy to apply the transformations. This can result in code blow-up. The transformations used in HOT to transform higher-order programs have not been previously implemented. These transformations extend the work of Malcom and others to more general datatypes and higher-order functions <ref> [38, 25, 48, 49] </ref>. The critical functionality of HOT was also present in Astre. In addition to fusion and deforestation, HOT does a significant amount of specialization. A subsequent specialization stage is still needed, however, because HOT is not guaranteed to produce first-order code.
Reference: [39] <author> Lambert Meertens. </author> <title> Algorithmics|towards programming as a mathematical activity. </title> <booktitle> In Proc. of the CWI Symbposium on Mathematics and Computer Science, </booktitle> <pages> pages 289-334. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: ADL is a new language based on work in the functional programming and categorical programming paradigms [31, 32, 37]. Specifically, it builds on the calculational style of programming called Squigol <ref> [11, 12, 39] </ref> and the categorical programming models of Hagino [27] and of Cockett's Charity group [18, 19]. ADL extends both of its predecessors, bringing the exponential types of functional programming to the categorical languages and the rich variety of algebras in the categorical framework to the functional community.
Reference: [40] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The MSL design and compiler. The language design was a significant design deliverable [55]. 3. Semantics preserving transformations on the ADL representation. The ADL language design is given in a technical report [32]. 4. A translator from ADL to a Standard ML <ref> [40] </ref> based representation. In conjunction with the MSL translator (2), this translator would provide a rapid prototyping capability for the generator. Users of the generator could thus quickly compile and execute a MSL specification to test its functionality. 5. Semantics preserving transformations on the SML based representations. <p> For this reason, some tools used the full Standard ML abstract syntax. 1 The core of ML refers to a subset that does not include the module facility. Core ML is defined in the definition of Standard ML <ref> [40] </ref>. 9 Restricted ML was developed in response to frustrations with the use of Standard ML as an intermediate form. Standard ML has too many features that make it convenient for programmers, but which only complicate program analysis tools. In particular, there were several recurring problems in the pipeline: 1.
Reference: [41] <author> Dino P. Oliva. </author> <title> Program instantiator templates documentation, </title> <month> January </month> <year> 1995. </year> <title> In Collected Tool Documentation for MTV Generator (CDRL 002.7). </title>
Reference-contexts: It is parameterized by a set of implementation templates that specify how to implement the primitive operations assumed by the RML program <ref> [42, 41] </ref>. Both RML and Ada are strongly typed. The program instantiator is distinguished because it preserves type information, naturally mapping the RML types into Ada. It does not use the traditional "boxed encoding" of values found in most functional language implementations.
Reference: [42] <author> Dino P. Oliva. </author> <title> Program instantiator tool documentation, </title> <month> January </month> <year> 1995. </year> <title> In Collected Tool Documentation for MTV Generator (CDRL 002.7). </title>
Reference-contexts: It is parameterized by a set of implementation templates that specify how to implement the primitive operations assumed by the RML program <ref> [42, 41] </ref>. Both RML and Ada are strongly typed. The program instantiator is distinguished because it preserves type information, naturally mapping the RML types into Ada. It does not use the traditional "boxed encoding" of values found in most functional language implementations.
Reference: [43] <author> Charles Plinta, Kenneth Lee, and Michael Rissman. </author> <title> A model solution for C 3 I message translation and validation. </title> <type> Technical Report CMU/SEI-89-TR-12 ESD-89-TR-20, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: In the case of the MTV domain, the previous work in the domain by Plinta, Lee and Rissman made this particularly successful since it defined the interface of an MTV component as an Ada package specified in Ada PDL <ref> [43] </ref>. Preserving structure Preservation of type information gave a sanity check to all transformation tools that was useful in testing.
Reference: [44] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: It is unnecessary for the MTV generator. It implements Reynolds' algorithm for defunctionalization <ref> [44, 4] </ref>. Astre RM L 1 ML2AST AST RE Astre AST RE CAM L CAM L The Astre tool was successfully developed and can be integrated into the pipeline. It was not required in the MTV generator. Astre is a first-order program transformation system based on term-rewriting [6, 5].
Reference: [45] <author> Tim Sheard. </author> <title> Guide to using CRML. </title> <year> 1993. </year>
Reference-contexts: earlier work, Sheard had investigated adding reflection to Standard ML; that is, adding the ability for programs to write and evaluate fragments of programs while compiling. (This feature is found in LISP dialects.) He developed a system called Compile-Time Reflective ML (CRML), which included tools for manipulating core ML 1 <ref> [47, 45, 29, 50] </ref>. Many concepts in the SDRR pipeline were initially explored in the context of the CRML system. At the beginning of the project it was expected that the CRML encoding of core ML would be the internal representation for all ML abstract syntax.
Reference: [46] <author> Tim Sheard. </author> <title> Type parametric programming. </title> <type> Technical Report 93-018, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1993. </year>
Reference-contexts: Furthermore, it was also expected that CRML would be used as the primary implementation language for the project because it had the capability to support the Squigol-style of programming built into ADL through its use of reflection on datatype structures <ref> [46, 28] </ref>. However, at the same time it was recognized that the restriction to core ML would prohibit us from benefiting from the rich module system provided by Standard ML; something that we expected to be a significant resource in a large system.
Reference: [47] <author> Tim Sheard. </author> <title> Type parametric programming with compile-time reflection. </title> <year> 1993. </year>
Reference-contexts: earlier work, Sheard had investigated adding reflection to Standard ML; that is, adding the ability for programs to write and evaluate fragments of programs while compiling. (This feature is found in LISP dialects.) He developed a system called Compile-Time Reflective ML (CRML), which included tools for manipulating core ML 1 <ref> [47, 45, 29, 50] </ref>. Many concepts in the SDRR pipeline were initially explored in the context of the CRML system. At the beginning of the project it was expected that the CRML encoding of core ML would be the internal representation for all ML abstract syntax.
Reference: [48] <author> Tim Sheard and Leonidas Fegaras. </author> <title> A fold for all seasons. </title> <booktitle> In Proceedings of the conference on Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: HOT uses an eager strategy to apply the transformations. This can result in code blow-up. The transformations used in HOT to transform higher-order programs have not been previously implemented. These transformations extend the work of Malcom and others to more general datatypes and higher-order functions <ref> [38, 25, 48, 49] </ref>. The critical functionality of HOT was also present in Astre. In addition to fusion and deforestation, HOT does a significant amount of specialization. A subsequent specialization stage is still needed, however, because HOT is not guaranteed to produce first-order code.
Reference: [49] <author> Tim Sheard and Leonidas Fegaras. </author> <title> Optimizing algebraic programs. </title> <type> Technical Report 94-004, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: HOT uses an eager strategy to apply the transformations. This can result in code blow-up. The transformations used in HOT to transform higher-order programs have not been previously implemented. These transformations extend the work of Malcom and others to more general datatypes and higher-order functions <ref> [38, 25, 48, 49] </ref>. The critical functionality of HOT was also present in Astre. In addition to fusion and deforestation, HOT does a significant amount of specialization. A subsequent specialization stage is still needed, however, because HOT is not guaranteed to produce first-order code.
Reference: [50] <author> Tim Sheard and James Hook. </author> <title> Meta-programming tools for ML. </title> <year> 1994. </year>
Reference-contexts: earlier work, Sheard had investigated adding reflection to Standard ML; that is, adding the ability for programs to write and evaluate fragments of programs while compiling. (This feature is found in LISP dialects.) He developed a system called Compile-Time Reflective ML (CRML), which included tools for manipulating core ML 1 <ref> [47, 45, 29, 50] </ref>. Many concepts in the SDRR pipeline were initially explored in the context of the CRML system. At the beginning of the project it was expected that the CRML encoding of core ML would be the internal representation for all ML abstract syntax.
Reference: [51] <author> David R. Tarditi and Andrew W. Appel. </author> <note> ML-Yacc user's manual, </note> <month> March </month> <year> 1991. </year> <title> Distributed as documentation with ML-Yacc. </title>
Reference-contexts: It uses traditional compiler generation technology to do lexical analysis and parsing (ML-yacc <ref> [51] </ref> and ML-lex [2], which are distributed with the SML/NJ distribution). The typechecker and code generation sections are written by hand, with some use of CRML's capability for automatic generation of control structures from datatype declarations. The generated code is expressed in ADL, a high-level functional language.
Reference: [52] <author> Dennis Volpano. </author> <title> Software Templates. </title> <type> PhD thesis, </type> <institution> Oregon Graduate Institute, </institution> <month> October </month> <year> 1986. </year>
Reference-contexts: Another unique feature of the program instantiator is that it translates from a parametrically polymorphic language (RML) to a language with ad hoc polymorphism (Ada). Although some preliminary work had been done on the notion of program instantiation by Volpano and Kieburtz <ref> [52, 53, 54] </ref>, there were no existing complete implementations. The program instantiator is a critical tool. It has unique functionality. The concept of program instantiation is key to achieving interoperability with existing software. The concept of implementation templates is key to achieving a reconfigurable system.
Reference: [53] <author> Dennis Volpano and Richard B. Kieburtz. </author> <title> Software templates. </title> <booktitle> In Proceedings Eighth International Conference on Software Engineering, </booktitle> <pages> pages 55-60. </pages> <publisher> IEEE Computer Society, </publisher> <month> August </month> <year> 1985. </year>
Reference-contexts: Another unique feature of the program instantiator is that it translates from a parametrically polymorphic language (RML) to a language with ad hoc polymorphism (Ada). Although some preliminary work had been done on the notion of program instantiation by Volpano and Kieburtz <ref> [52, 53, 54] </ref>, there were no existing complete implementations. The program instantiator is a critical tool. It has unique functionality. The concept of program instantiation is key to achieving interoperability with existing software. The concept of implementation templates is key to achieving a reconfigurable system.
Reference: [54] <author> Dennis Volpano and Richard B. Kieburtz. </author> <title> The templates approach to software reuse. </title> <editor> In Ted J. Biggersstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <pages> pages 247-255. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Another unique feature of the program instantiator is that it translates from a parametrically polymorphic language (RML) to a language with ad hoc polymorphism (Ada). Although some preliminary work had been done on the notion of program instantiation by Volpano and Kieburtz <ref> [52, 53, 54] </ref>, there were no existing complete implementations. The program instantiator is a critical tool. It has unique functionality. The concept of program instantiation is key to achieving interoperability with existing software. The concept of implementation templates is key to achieving a reconfigurable system.

References-found: 54

