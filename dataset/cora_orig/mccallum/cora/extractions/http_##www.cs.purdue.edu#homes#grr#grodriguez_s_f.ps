URL: http://www.cs.purdue.edu/homes/grr/grodriguez_s_f.ps
Refering-URL: http://www.cs.purdue.edu/homes/grr/
Root-URL: http://www.cs.purdue.edu
Email: -grr, mps, cef-@geodesic.com  
Title: A Non-Fragmenting Non-Copying, Garbage Collector  
Author: By Gustavo Rodriguez-Rivera, Michael Spertus, and Charles Fiterman 
Abstract: One of the biggest disadvantages of non-copying collectors compared to copying collectors has been their limited ability to deal with memory fragmentation. In this paper, we describe two techniques to reduce fragmentation without the need of copying live data. The first technique reduces internal fragmentation in BiBOP (Big Bag of Pages) like allocators. The second technique reduces external fragmentation using virtual memory calls available in most modern operating systems. It can also reduce the size of the heap after periods of great activity in long lived applications. These techniques have been successfully used in Geodesic Systems' Great Circle, a commercially-available conservative garbage collector. This paper describes these techniques, their implementation, and some experimental results. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Some copying collectors deal with this problem by pinning objects that are pointed by pointers that were found using conservative pointer finding <ref> [Bar88, Det91] </ref>, i.e., objects found by the conservative garbage collector are not moved, creating fragmentation problems. In this paper, we will describe two techniques to reduce fragmentation in non-copying garbage collectors.
Reference: [BC92] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [Boe93] <author> Hans-Juergen Boehm, </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation [PLD93], </booktitle> <pages> pages 197-206. </pages>
Reference-contexts: If a new search started where the previous one ended it would reuse all the objects in the list and would not give the opportunity for footprint reduction. A good side effect of footprint reduction is that pages that are blacklisted <ref> [Boe93] </ref> and therefore can not be used because they are being pointed by false pointers, are unmapped if they continue blacklisted for several consecutive allocations. Experiments In this section, we show the advantages of using footprint reduction in a long-lived program that is subject to changing loads.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience , 18(9) </journal> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Some work has been done to obtain pointer information of C programs from the debugging information [WJ93], however their use is limited since C and C++ can store pointer values in non-pointer types, and keeping track of pointer information at execution time is difficult. Conservative garbage collection <ref> [BW88] </ref> also has some problems when combined with copying collection. Conservative garbage collection considers every valid memory address that is word-aligned and that has a value that is in the heap-range as a real pointer. <p> In this paper, we will describe two techniques to reduce fragmentation in non-copying garbage collectors. The first technique is intended to reduce internal fragmentation in allocators that use a BiBOP scheme (Big Bag of Pages) <ref> [BW88, Wil95] </ref>. In a BIBOP allocator, the objects found in the same page have the same characteristics. The second technique is intended to reduce external fragmentation and uses virtual memory primitives that can be found in most modern operating systems. <p> In a BIBOP allocator, the objects found in the same page have the same characteristics. The second technique is intended to reduce external fragmentation and uses virtual memory primitives that can be found in most modern operating systems. Allocators such as the one used in Boehms collector <ref> [BW88] </ref> divide the objects in two classes: small and large objects. Small objects are obtained by dividing a single page in small pieces, and large objects are the ones that use one or more consecutive pages. <p> We will refer to this technique as footprint reduction. Both medium objects and footprint reduction have been implemented in a variation of Boehms conservative garbage collection library <ref> [BW88] </ref> called Great Circle. Great Circle is a commercially-available garbage collection library from Geodesic Systems. The ideas presented here are explained in the context of garbage collection. However, they can also be applied to any general-purpose memory allocator that does not use garbage collection. The paper is organized as follows.
Reference: [CN83] <author> Jacques Cohen and Alexandru Nicolau. </author> <title> Comparison of compacting algorithms for garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 532-553, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: Introduction Copying collectors <ref> [CN83] </ref> eliminate fragmentation by copying live data and leaving all free space in consecutive locations. Non-copying collectors are unable to move live data, and therefore free memory is interleaved with holes of live memory.
Reference: [ Det91] <author> David L. Detlefs. </author> <title> Concurrent, Atomic Garbage Collection. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> November </month> <year> 1991. </year> <note> Technical Report CMU-CS-90-177. </note>
Reference-contexts: Some copying collectors deal with this problem by pinning objects that are pointed by pointers that were found using conservative pointer finding <ref> [Bar88, Det91] </ref>, i.e., objects found by the conservative garbage collector are not moved, creating fragmentation problems. In this paper, we will describe two techniques to reduce fragmentation in non-copying garbage collectors.
Reference: [OOP93] <institution> OOPSLA 93 Workshop on Memory Management and Garbage Collection, </institution> <month> October </month> <year> 1993. </year> <note> Available for anonymous FTP from cs.utexas.edu in /pub/garbage/GC93. </note>
Reference: [PLD93] <institution> Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation, </institution> <address> Albuquerque, New Mexico, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [RR97] <author> Rodriguez-Rivera Gustavo, Vincent Russo. </author> <title> Nonintrusive cloning garbage collection with stock operating system support. </title> <journal> Software Practice and Experience, </journal> <volume> 27(8), </volume> <month> August </month> <year> 1997. </year>
Reference-contexts: The experiments shown here run in a Sparc Station 10 running the Solaris Operating System. The Great Circle library is linked into Netscape and the X-server at runtime using the injection technique described in <ref> [RR97] </ref>, and therefore no recompiling or linking is necessary. Great Circle provides a substitute for the malloc/free operations. In the experiments shown, explicit memory management is enabled, and therefore the free operations really return memory back to the free lists.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techni ques. </title> <booktitle> In Bekkers and Cohen [BC92], </booktitle> <pages> pages 1-42. </pages>
Reference: [Wil95] <author> Paul R. Wilson. </author> <title> Garbage Collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [Wil92]. Draft available via anonymous internet FTP from cs.utexas.edu as /pub/garbage/bigsurv.ps. </note>
Reference-contexts: This causes that some requests for free memory will not be satisfied with the available free memory because it is not in consecutive locations, even though, the total free memory could be greater than the amount requested. Copying-collectors can solve the fragmentation problem <ref> [Wil95] </ref>. Unfortunately, copying collectors can not be used in environments where no accurate pointer information is available, since pointers in live objects have to be updated during the copying phase. For example, off-the-shelf C and C++ compilers do not give accurate pointer information. <p> In this paper, we will describe two techniques to reduce fragmentation in non-copying garbage collectors. The first technique is intended to reduce internal fragmentation in allocators that use a BiBOP scheme (Big Bag of Pages) <ref> [BW88, Wil95] </ref>. In a BIBOP allocator, the objects found in the same page have the same characteristics. The second technique is intended to reduce external fragmentation and uses virtual memory primitives that can be found in most modern operating systems.
Reference: [WJ93] <author> Paul R. Wilson and Mark S. Johnstone. </author> <title> Truly real-time non-copying garbage collection. In OOPSLA 93 Workshop on Memory Management and Garbage Collection [OOP93]. </title> <note> Expanded version workshop position paper submitted for publication. </note>
Reference-contexts: For example, off-the-shelf C and C++ compilers do not give accurate pointer information. Some work has been done to obtain pointer information of C programs from the debugging information <ref> [WJ93] </ref>, however their use is limited since C and C++ can store pointer values in non-pointer types, and keeping track of pointer information at execution time is difficult. Conservative garbage collection [BW88] also has some problems when combined with copying collection.
Reference: [WJNB96] <author> Paul R. Wilson, Mark S. Johnstone. Michael Neely, and David Boles. </author> <title> Dynamic Storage Allocation: A survey and Critical Review. </title> <note> Available for anonymous FTP from cs.utexas.edu in /pub/garbage/. </note>
Reference-contexts: Medium objects are objects that are allocated by dividing multiple consecutive pages in pieces. Large objects are objects that are a multiple of a pagesize. The small and medium object allocator consists of buckets of objects for each size, called segregated free lists <ref> [WJNB96] </ref>. Great Circle pre-computes the sizes of small and medium objects and makes sure that the maximum fragmentation for each object size is less than some pre-specified constant. The large object allocator is a single list of objects ordered by address to allow coalescing.
References-found: 13

