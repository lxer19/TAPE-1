URL: http://www.cs.berkeley.edu/~daw/cs267/project/collsearch.ps
Refering-URL: http://www.cs.berkeley.edu/~daw/cs267/project/
Root-URL: http://www.cs.berkeley.edu
Title: Abstract  
Abstract: Current techniques for collision search with feasible memory requirements involve pseudorandom walks through some space where one must wait for the result of the current step before the next step can begin. These techniques are serial in nature, and direct parallelization is inefficient. W e present a simple new method of parallelizing collision searches that greatly extends the reach of practical attacks. The new method is illustrated with applications to hash functions and discrete logarithms in cyclic groups. In the case of hash functions, we begin with two messages; the first is a message that we want our target to digitally sign, and the second is a message that the target is willing to sign. Using collision search adapted for hashing collisions, one can find slightly altered versions of these messages such that the two new messages give the same hash result. As a particular example, a $10 million custom machine for applying parallel collision search to the MD5 hash function could complete an attack with an expected run time of 24 days. This machine would be specific to MD5, but could be used for any pair of messages. For discrete logarithms in cyclic groups, ideas from Pollards rho and lambda methods for index computation are combined to allow efficient parallel implementation using the new method. As a concrete example, we consider an elliptic curve cryptosystem over GF(2 155 ) with the order of the curve having largest prime factor of approximate size 10 36 . A $10 million machine custom built for this finite field could compute a discrete logarithm with an expected run time of 36 days. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> G.B. Agnew, R.C. Mullin, and S.A. Vanstone. </editor> <title> An implementation of elliptic curve cryptosystems over F 2 155 , IEEE J. </title> <journal> Selected Areas in Communications, </journal> <volume> vol. 11, no. </volume> <month> 5 (June </month> <year> 1993), </year> <pages> pp. 804-813. </pages>
Reference-contexts: Impact on elliptic curve cryptosystems over GF (2 155 ). We now discuss the practical utility of this new method by choosing, as an illustrative example, its application to a discrete-logarithm-based cryptosystem of Agnew et al. <ref> [1] </ref> which uses elliptic curve cryptosystems over GF (2 155 ). The security of such systems is apparently bounded by the difficulty of finding discrete logarithms over the group of points on the elliptic curve. <p> This allows collision information to be resolved into the recovery of logarithms. x i 1+ x i if x i S 2 ( ) pp/ 2 parallelized version with perfect linear speedup was implicit in this reasoning.) It was previously believed <ref> [1, p.809] </ref>: Provided that the square root attacks are the best attacks on the elliptic logarithm problem, we see that elliptic curves over F 2 m with m about 130 provide very secure systems. <p> The elliptic curve system over GF (2 155 ) can be implemented in less than 1 mm 2 of silicon in 1.5 mm technology and can perform an addition in 13155 clock cycles at 40 MHz <ref> [1, 2] </ref>. About 75 of these cells plus input/output and logic to detect distinguished points could be put on a $20 chip. We now summarize the results of an analysis similar to that for MD5 in Section 3. <p> The expected time to complete a discrete logarithm is This analysis makes use of the basic hardware described by Agnew et al. <ref> [1] </ref>, and does not take into account possible optimizations from pipelining the elliptic curve implementation or from using currently available silicon technology.
Reference: [2] <editor> G.B. Agnew, R.C. Mullin, and S.A. Vanstone. </editor> <title> On the Development of a Fast Elliptic Curve Cryptosystem, </title> <booktitle> Lecture Notes in Computer Science 658: Advances in Cryptology Eurocrypt 92 Proceedings, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 482-487. </pages>
Reference-contexts: The elliptic curve system over GF (2 155 ) can be implemented in less than 1 mm 2 of silicon in 1.5 mm technology and can perform an addition in 13155 clock cycles at 40 MHz <ref> [1, 2] </ref>. About 75 of these cells plus input/output and logic to detect distinguished points could be put on a $20 chip. We now summarize the results of an analysis similar to that for MD5 in Section 3.
Reference: [3] <author> E. Bach, </author> <title> Toward a Theory of Pollards Rho Method, </title> <booktitle> Information and Computation , vol. 90 (1991), </booktitle> <pages> pp. 139-155. </pages>
Reference-contexts: The actual expected run time will be slightly less than the calculated value. 64 2 p 2 1 1.5+( )+ 24days@ n n p 6 rigorously proven by Bach <ref> [3] </ref>), with only negligible space requirements; it is thus preferable. This method requires knowledge of the (exact) order of the group, whereas Shanks method requires only an upper bound.
Reference: [4] <author> Bell-Northern Research, </author> <title> Internal study of MD5 Silicon Implementation, </title> <year> 1994. </year>
Reference-contexts: Then use the following function f for collision search. An internal study <ref> [4] </ref> indicates that a collision search chip for one iteration of MD5 with 64 levels of pipelining (recall that MD5 involves 4 rounds of 16 computations per 512-bit block) could be built with a total area of (310 mils) 2 and would run at 50 MHz if designed in a 0.5
Reference: [5] <author> R . P. </author> <title> B r e n t . P a r a l l e l a l g o r i t h m s f o r i n t e g e r factorization. London Mathematical Society Lecture N o t e S e r i e s v o l . 1 5 4 , N u m b e r T h e o r y a n d Cambridge University Press, </title> <year> 1990. </year>
Reference-contexts: Regarding parallelization of discrete log algorithms for cyclic groups, little work has been done. We now brief ly review the known results, and obvious parallelizations of previous methods. In discussing the rho-method for factorization, Brent notes that Unfortunately, parallel implementation of the rho method does not give linear speedup <ref> [5, p. 29] </ref>. He continues A plausible use of parallelism is to try several different pseudorandom sequences (generated by different polynomials f). <p> One such application may be in one version of the elliptic curve factoring algorithm whose second phase involves such a random walk <ref> [5, p. 32] </ref>; another, of course, is to parallelized Pollard rho factoring [19], although better general factoring methods are available. Acknowledgments We would like to thank Bart Preneel for his helpful suggestions and Kevin McCurley for making us aware of reference [5]. <p> Acknowledgments We would like to thank Bart Preneel for his helpful suggestions and Kevin McCurley for making us aware of reference <ref> [5] </ref>.
Reference: [6] <author> K.W. Campbell and M.J. W iener, </author> <title> DES is not a Group, </title> <booktitle> Lecture Notes in Computer Science 740: Advances in Cryptology - Crypto92 Pr oceedings, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 512-520. </pages>
Reference-contexts: In a recent exhaustive key search attack proposed for DES [24], a large number of inexpensive specialized processors were proposed to achieve a high degree of parallelism. The importance of producing memoryless versions of attacks is well recognized (e.g. <ref> [6, 21] </ref>), but even a memoryless attack is of little practical use unless it can be ef ficiently parallelized. In this paper, we provide a method for efficient parallelization of collision search techniques. The remainder of this paper is or ganized as follows.
Reference: [7] <institution> Data Encryption Standard, National Bureau of Standards (U.S.), </institution> <note> Federal Information Processing Standards Publication (FIPS PUB) 46, </note> <institution> National Technical Information Service, Springfield VA, </institution> <year> 1977. </year>
Reference-contexts: 1. Introduction The power of parallelized attacks has been illustrated in recent work on integer factorization and cryptanalysis of the Data Encryption Standard (DES) <ref> [7] </ref>. In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. [14, 15]), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines [8, 9].
Reference: [8] <author> B. Dixon and A.K. Lenstra,. </author> <title> Factoring Integers Using SIMD Sieves, </title> <booktitle> Lecture Notes in Computer Science 765: Advances in Cryptology - Eur ocrypt 93, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 28-39. </pages>
Reference-contexts: In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. [14, 15]), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines <ref> [8, 9] </ref>. In a recent exhaustive key search attack proposed for DES [24], a large number of inexpensive specialized processors were proposed to achieve a high degree of parallelism.
Reference: [9] <author> R. Golliver, A.K. Lenstra, </author> <title> and K.S. McCurley , Lattice Sieving and Trial Division, presented at the Algorithmic Number Theory Symposium (ANTS94), </title> <institution> Cornell University, </institution> <month> May </month> <year> 1994. </year> <month> 9 </month>
Reference-contexts: In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. [14, 15]), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines <ref> [8, 9] </ref>. In a recent exhaustive key search attack proposed for DES [24], a large number of inexpensive specialized processors were proposed to achieve a high degree of parallelism. <p> in memory size in case the search takes longer than expected and a factor of 1.5 for overhead due to using a hash table for the list of distinguished points, we need about 30 Gbytes of memory. (Note that this is not impractical; the existing general purpose parallel machine of <ref> [9] </ref> has 37 Gbytes of memory.) Assuming that the cost of memory and the boards to house it is $75/Mbyte, the memory cost is $2.25 million. At $22 per chip (including overhead), the remaining $7.75 million can buy about 350 000 chips.
Reference: [10] <author> P. Flajolet and A.M. Odlyzko, </author> <title> Random Mapping Statistics, </title> <booktitle> Lecture Notes in Computer Science 434: Advances in Cryptology - Eurocrypt 89 Proceedings, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 329-354. </pages>
Reference-contexts: Let n be the cardinality of the range of f. The probability that no collision is found after selecting k inputs is (1-1/n)(1-2/n)(1-(k-1)/n) for large n and k = O ( ) [17]. The expected number of inputs that must be tried before a collision is found is <ref> [10] </ref>. Assuming that the f (x i ) values are stored in a hash table so that new entries can be added in constant time, this method finds a collision in O ( ) time and O ( ) memory.
Reference: [11] <author> R. Heiman. </author> <title> A note on discrete logarithms with special structure. </title> <booktitle> Lecture Notes in Computer Science 658: Advances in Cryptology - Eur oc rypt 92, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 454-457. </pages>
Reference-contexts: Pollard s rho-method does not seem adaptable to restricted intervals (thus motivating the lambda-method). Other refinements are possible if it is known that the logarithm being sought belongs to a group with special structure (e.g. <ref> [11] </ref>). Direct parallelization of known methods for logarithms in cyclic groups. Regarding parallelization of discrete log algorithms for cyclic groups, little work has been done. We now brief ly review the known results, and obvious parallelizations of previous methods.
Reference: [12] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. 2: </volume> <booktitle> Seminumerical Algorithms, 2nd edition, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1981. </year>
Reference-contexts: The advantage of this method is that the memory requirements are small if one uses a clever method of detecting a cycle. A simple approach to detecting a collision with Pollards rho method is to use Floyds cycle-finding algorithm <ref> [12, ex 3.1-6] </ref>. Start with two sequences, one applying f twice per step and the other applying f once per step, and compare the outputs of the sequences after each step.
Reference: [13] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. </volume> <month> 3: </month> <title> Sorting and Searching, </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Known methods for computing logarithms in cyclic groups. Recall that the powerful index-calculus techniques, which can be applied to groups with additional structure, do not apply to arbitrary cyclic groups. For the latter, the well-known baby-step giantstep algorithm, attributed to Shanks <ref> [13, pp. 9, 575] </ref>, allows one to compute discrete logarithms in a cyclic group G of order n in deterministic time O ( log n) and space for group elements.
Reference: [14] <author> A.K. Lenstra, H.W. Lenstra, M.S. Manasse, and J.M. Pollard, </author> <title> The Factorization of the ninth Fermat Number, </title> <journal> Math. Comp. </journal> <volume> vol. 61 (1993), </volume> <pages> pp. 319-349. </pages>
Reference-contexts: 1. Introduction The power of parallelized attacks has been illustrated in recent work on integer factorization and cryptanalysis of the Data Encryption Standard (DES) [7]. In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. <ref> [14, 15] </ref>), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines [8, 9].
Reference: [15] <author> A.K. Lenstra and M.S. Manasse, </author> <title> Factoring by electronic mail, Lecture Notes in Computer Science 4 34 : A d v an c e s in C ry p to lo gy - Eu r oc r y p t 8 9 Proceedings, </title> <publisher> Springer-Verlag, </publisher> <pages> pp. 355-371. </pages>
Reference-contexts: 1. Introduction The power of parallelized attacks has been illustrated in recent work on integer factorization and cryptanalysis of the Data Encryption Standard (DES) [7]. In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. <ref> [14, 15] </ref>), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines [8, 9].
Reference: [16] <author> K.S. McCurley. </author> <title> The discrete logarithm problem, </title> <journal> pp. 49-74 in Cryptology and Computational Number Theory, Proc. Symp. Applied Math., </journal> <volume> vol. 42 (1990), </volume> <publisher> American Math. Society. </publisher>
Reference-contexts: If n has a known factorization into prime powers, this problem can be reduced to one of finding c discrete logarithms in a subgroup of size p for each prime power p c dividing n (e.g., see [18] or <ref> [16] </ref>). For the reduced problem, we have y = g x , where g generates a subgroup of order p, y is known, and we wish to find x.
Reference: [17] <author> K. Nishimura and M. Sibuya. </author> <title> Probability to meet in the middle, </title> <journal> J. Cryptology, </journal> <volume> vol. 2 no. 1 (1990), </volume> <pages> pp. 13-22. </pages>
Reference-contexts: Let n be the cardinality of the range of f. The probability that no collision is found after selecting k inputs is (1-1/n)(1-2/n)(1-(k-1)/n) for large n and k = O ( ) <ref> [17] </ref>. The expected number of inputs that must be tried before a collision is found is [10].
Reference: [18] <author> S.C. Pohlig and M.E. Hellman. </author> <title> An improved algorithm for computing discrete logarithms over GF(p) and its cryptographic significance, </title> <journal> IEEE-IT, </journal> <volume> vol. 24 (1978), </volume> <pages> pp. 106-110. </pages>
Reference-contexts: If p is the largest prime divisor of n, Shanks algorithm can be generalized to run in deterministic time and space O ( ) [20]; moreover, space can be traded off against time <ref> [18] </ref>, which may be of interest if one anticipates computing a large number of logarithms. <p> If n has a known factorization into prime powers, this problem can be reduced to one of finding c discrete logarithms in a subgroup of size p for each prime power p c dividing n (e.g., see <ref> [18] </ref> or [16]). For the reduced problem, we have y = g x , where g generates a subgroup of order p, y is known, and we wish to find x.
Reference: [19] <author> J . M . P o l l a r d , A M o n t e C a r l o m e t h o d f o r factorization. </author> <title> BIT, </title> <booktitle> vol. 15 (1975), </booktitle> <pages> pp. 331-334. </pages>
Reference-contexts: The large memory requirements can be eliminated using Pollards rho method <ref> [19, 20] </ref>. This method involves taking a pseudorandom walk through some f inite set S. Conceptually, the shape of the path traced out resembles the letter rho, giving this method its name. <p> As discussed later, finding this point is necessary in some cases (e.g., finding collisions in hash functions), but in other cases (e.g., Pollards methods of factoring and computing discrete logarithms <ref> [19, 20] </ref>) it is sufficient that there are two distinct paths to the same point. pn/ 2 pn/ 2m ( ) 3 expected speedup is only a factor of , this is a very inefficient use of parallelization as it requires times more processing cycles than the single processor (serial) version. <p> Pollards lesser-known rho-method for discrete logarithms [20], based on the same theory as his rho-method for factoring <ref> [19] </ref>, also has time complexity O ( ) (originally given as heuristic time rather than deterministic, but 1 Summing the expected values of the three components of the run time ignores the possibility that a second collision which occurs later than the first will actually be detected and located earlier. <p> One such application may be in one version of the elliptic curve factoring algorithm whose second phase involves such a random walk [5, p. 32]; another, of course, is to parallelized Pollard rho factoring <ref> [19] </ref>, although better general factoring methods are available. Acknowledgments We would like to thank Bart Preneel for his helpful suggestions and Kevin McCurley for making us aware of reference [5].
Reference: [20] <author> J.M. Pollard, </author> <title> Monte Carlo Methods for Index Computation (mod p), </title> <journal> Math.Comp. </journal> <volume> vol. 32, no. 143, </volume> <month> July </month> <year> 1978, </year> <pages> pp. 918-924. </pages>
Reference-contexts: The large memory requirements can be eliminated using Pollards rho method <ref> [19, 20] </ref>. This method involves taking a pseudorandom walk through some f inite set S. Conceptually, the shape of the path traced out resembles the letter rho, giving this method its name. <p> As discussed later, finding this point is necessary in some cases (e.g., finding collisions in hash functions), but in other cases (e.g., Pollards methods of factoring and computing discrete logarithms <ref> [19, 20] </ref>) it is sufficient that there are two distinct paths to the same point. pn/ 2 pn/ 2m ( ) 3 expected speedup is only a factor of , this is a very inefficient use of parallelization as it requires times more processing cycles than the single processor (serial) version. <p> If p is the largest prime divisor of n, Shanks algorithm can be generalized to run in deterministic time and space O ( ) <ref> [20] </ref>; moreover, space can be traded off against time [18], which may be of interest if one anticipates computing a large number of logarithms. Pollards lesser-known rho-method for discrete logarithms [20], based on the same theory as his rho-method for factoring [19], also has time complexity O ( ) (originally given <p> largest prime divisor of n, Shanks algorithm can be generalized to run in deterministic time and space O ( ) <ref> [20] </ref>; moreover, space can be traded off against time [18], which may be of interest if one anticipates computing a large number of logarithms. Pollards lesser-known rho-method for discrete logarithms [20], based on the same theory as his rho-method for factoring [19], also has time complexity O ( ) (originally given as heuristic time rather than deterministic, but 1 Summing the expected values of the three components of the run time ignores the possibility that a second collision which occurs later <p> This method requires knowledge of the (exact) order of the group, whereas Shanks method requires only an upper bound. Pollards rarely discussed lambda-method for computing discrete logarithms can be used when the logarithm sought is known to lie in a specified interval <ref> [20] </ref>; this algorithm may terminate (with controllably small probability) without yielding the answer. <p> For large primes, one can use the parallelized rho method as now described. In a parallel version of the rho method for logarithms, we suggest the same iterating function used by Pollard <ref> [20] </ref>. Partition the set of subgroup elements into three roughly equal size disjoint sets S 1 , S 2 , and S 3 , based on some easily testable property. Define the iterating function: p 7 Each processor follows the following steps independently.
Reference: [21] <author> J.-J. Quisquater and J.-P. Delescaille, </author> <title> How easy is collision search? Application to DES, </title> <booktitle> Lecture Notes in Computer Science 434: Advances in Cryptology - Eurocrypt89 Proceedings, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 429-434. </pages>
Reference-contexts: In a recent exhaustive key search attack proposed for DES [24], a large number of inexpensive specialized processors were proposed to achieve a high degree of parallelism. The importance of producing memoryless versions of attacks is well recognized (e.g. <ref> [6, 21] </ref>), but even a memoryless attack is of little practical use unless it can be ef ficiently parallelized. In this paper, we provide a method for efficient parallelization of collision search techniques. The remainder of this paper is or ganized as follows. <p> Sedgewick, Szymanski, and Yao showed that by saving a small number of the values from the sequence, one could step through the sequence just once and detect the repetition shortly after it starts [23]. Quisquater and Delescaille took a different approach based on storing distinguished points <ref> [21] </ref>. A distinguished point is one that has some easily checked property such as having a number of leading zero bits. During the pseudo-random walk, points that satisfy the distinguishing property are stored. Repetition can be detected when a distinguished point is encountered a second time. <p> The expected number of steps taken by each processor is /m. Quisquater and Delescaille used an idea similar to this parallel collision search in finding DES collisions <ref> [21] </ref>.
Reference: [22] <author> R. Rivest, </author> <title> The MD5 MessageDigest Algorithm, Internet RFC 1321, </title> <month> April </month> <year> 1992. </year>
Reference-contexts: Section 3 illustrates the application of parallel collision search by adapting it to finding hash function collisions; we choose as an illustrative example the well-known hash function MD5 <ref> [22] </ref> and propose a high-level design for a machine to f ind MD5 collisions in hardware. For $10 million, 1 one could expect to find a collision in 24 days. <p> Let us now apply these techniques to the MD5 hash function <ref> [22] </ref>. With MD5, the hash result is 128 bits, and messages are divided into 512-bit blocks. To reduce the amount of computation required, we will assume that the effect of the mappings g m and g m can be confined to a single block within the messages.
Reference: [23] <author> R. Sedgewick, T.G. Szymanski, and A.C. Yao, </author> <title> The complexity of finding cycles in periodic functions, </title> <journal> Siam J. Computing, </journal> <volume> vol. 11, no. 2, </volume> <year> 1982, </year> <pages> pp. 376-390. </pages>
Reference-contexts: Sedgewick, Szymanski, and Yao showed that by saving a small number of the values from the sequence, one could step through the sequence just once and detect the repetition shortly after it starts <ref> [23] </ref>. Quisquater and Delescaille took a different approach based on storing distinguished points [21]. A distinguished point is one that has some easily checked property such as having a number of leading zero bits. During the pseudo-random walk, points that satisfy the distinguishing property are stored.
Reference: [24] <author> M.J. Wiener, </author> <title> Efficient DES Key Search, </title> <month> TR-244 (May </month> <year> 1994), </year> <institution> School of Computer Science, Carleton University, Ottawa, Canada. </institution> <note> (Presented at the Rump Session of Crypto 93.) </note>
Reference-contexts: In the factoring of the RSA-129 challenge number and other factoring efforts (e.g. [14, 15]), the sieving process was distributed among a large number of workstations. Similar ef forts have been undertaken on large parallel machines [8, 9]. In a recent exhaustive key search attack proposed for DES <ref> [24] </ref>, a large number of inexpensive specialized processors were proposed to achieve a high degree of parallelism. The importance of producing memoryless versions of attacks is well recognized (e.g. [6, 21]), but even a memoryless attack is of little practical use unless it can be ef ficiently parallelized. <p> Such a chip would cost about $15 in high volume. Based on a recent DES key search design <ref> [24] </ref>, the overhead of building a machine with many of these chips would be about $7 per chip. This includes the cost of a hierarchy of controllers and communications path to a central memory of distinguished points. <p> For comparison to the 24 days and 36 days, respectively, required to attack the above-mentioned systems using our new techniques, exhaustive DES key search with the same budget of $10 million would take about 21 minutes <ref> [24] </ref>. When comparing these times, it is worth noting that the MD5 collision search is based on 0.5 mm technology, the elliptic curve logarithm implementation is based on 1.5 mm, and DES key search is based on 0.8 mm.
Reference: [25] <author> G. Yuval, </author> <title> How to Swindle Rabin, </title> <journal> Cryptologia, </journal> <volume> vol. </volume> <month> 3 (3) (July </month> <year> 1979), </year> <pages> pp. 187-189. </pages>
Reference-contexts: Now suppose we have a message m that we would like our adversary to digitally sign, but he is not willing to do so. A simple attack on the hash function can help to acquire the desired signature as follows <ref> [25] </ref>. Choose some other message m that the adversary is willing to sign. Find several ways to modify each of m and m that do not alter their respective semantic meaning (e.g., adding extra spaces or making small changes in wording).
References-found: 25

