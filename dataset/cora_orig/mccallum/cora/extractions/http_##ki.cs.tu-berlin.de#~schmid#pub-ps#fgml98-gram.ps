URL: http://ki.cs.tu-berlin.de/~schmid/pub-ps/fgml98-gram.ps
Refering-URL: http://www.cs.tu-berlin.de/~schmid/publications.html
Root-URL: 
Email: Email: schmid@cs.tu-berlin.de  
Phone: 58,  
Title: Synthesis of Recursive Functions with Interdependent Parameters  
Author: Martin Muhlpfordt and Ute Schmid 
Keyword: inductive program synthesis, grammatical inference, context free tree grammers  
Address: Sekr. Fr  Franklinstr. 28/29, D-10587 Berlin, Germany,  
Affiliation: Methods of Artificial Intelligence, Computer Science Department,  Technical University Berlin,  
Abstract: We present a methodology for the inductive synthesis of recursive functions based on the theoretical framework of context-free tree grammars. The synthesis task is splitted into two parts: First, a small set of positive input/output examples is transformed into an initial program by means of heuristic search; second, the initial program is generalized to a recursive function. In this paper we concentrate on the second part of the synthesis task. We will describe our theoretical framework and propose an induction algorithm. The algorithm works without information about the number of parameters which might occur in the initial program. Subterms which change in a regular way are identified as parameters together with a substitution. It is possible to deal with substitutions which are interdependent between the parameters. Thereby we can infer a greater class of recursive functions than standard generalization-to-n techniques. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Le Blanc. </author> <title> BMWk revisited: Generalization and formalization of an algorithm for detecting recursive relations in term sequences. </title> <editor> In F. Bergadano and L. de Raedt, editors, </editor> <booktitle> Machine Learning, Proc. of ECML-94, </booktitle> <pages> pages 183197, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Inductive synthesis of recursive programs from examples was a major research topic in the seventies and eighties. Typically, the proposed algorithms had their background in the domain of functional (LISP) programming and relied on small sets of positive input/output examples <ref> [7, 3, 1] </ref>. In the nineties inductive program synthesis has become of interest again in the context of inductive logic programming (ILP) [4, 5]. As in the classical approaches, our aim is to infer functional expressions (i.e. terms and not logical clauses) from small sets of positive input/output examples. <p> In contrast to classical approaches to in ductive program synthesis <ref> [7, 3, 1] </ref> and to ILP approaches [4, 5] we do not start with input/output examples but with initial programs which were constructed by planning.
Reference: 2. <author> I. </author> <title> Guessarian. Program transformation and algebraic semantics. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 9:3965, </address> <year> 1979. </year>
Reference-contexts: hS;t 0 i = ( [ fsg; [ fg; P; s), s 62 , 62 ( as the bottom element); P is defined by: P = fs ! t 0 j g [ fG i (x i n i ) ! t i j g with G i 2 (cf. <ref> [2] </ref>). With the CFTG C hS;t 0 i we can now unfold a recursive scheme to terms in T [fg (X). An interpretation i of the unfolded trees of an RPS hS; t 0 i is a homomorphism i in a -algebra A, i : T ! A.
Reference: 3. <author> Y. Kodratoff and J.Fargues. </author> <title> A sane algorithm for the synthesis of lisp functions from example problems: The boyer and moore algorithm. </title> <booktitle> In Proc. of the AISE Meeting Hambourg, </booktitle> <pages> pages 169175, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Inductive synthesis of recursive programs from examples was a major research topic in the seventies and eighties. Typically, the proposed algorithms had their background in the domain of functional (LISP) programming and relied on small sets of positive input/output examples <ref> [7, 3, 1] </ref>. In the nineties inductive program synthesis has become of interest again in the context of inductive logic programming (ILP) [4, 5]. As in the classical approaches, our aim is to infer functional expressions (i.e. terms and not logical clauses) from small sets of positive input/output examples. <p> In contrast to classical approaches to in ductive program synthesis <ref> [7, 3, 1] </ref> and to ILP approaches [4, 5] we do not start with input/output examples but with initial programs which were constructed by planning.
Reference: 4. <author> S. Muggleton and L. De Raedt. </author> <title> Inductive logic programming: Theory and methods. </title> <journal> Journal of Logic Programming, Special Issue on 10 Years of Logic Programming, </journal> <volume> 19-20:629679, </volume> <year> 1994. </year>
Reference-contexts: Typically, the proposed algorithms had their background in the domain of functional (LISP) programming and relied on small sets of positive input/output examples [7, 3, 1]. In the nineties inductive program synthesis has become of interest again in the context of inductive logic programming (ILP) <ref> [4, 5] </ref>. As in the classical approaches, our aim is to infer functional expressions (i.e. terms and not logical clauses) from small sets of positive input/output examples. <p> In contrast to classical approaches to in ductive program synthesis [7, 3, 1] and to ILP approaches <ref> [4, 5] </ref> we do not start with input/output examples but with initial programs which were constructed by planning. This separation of constructing non-recursive initial programs and of generalization has some advantages: We believe that building initial programs and generalization are based on different (cognitive) processes.
Reference: 5. <author> M. R. K. Krishna Rao. </author> <title> A class of Prolog programs inferable from positive data. </title> <editor> In S. Arikawa and A. K. Sharma, editors, </editor> <booktitle> Algorithmic Learning Theory, Proc. of the 7th International Workshop, ALT '96, </booktitle> <address> Sydney, </address> <publisher> Aus-tralia, </publisher> <pages> pages 273284, </pages> <address> Berlin, 1996. </address> <publisher> Springer. </publisher>
Reference-contexts: Typically, the proposed algorithms had their background in the domain of functional (LISP) programming and relied on small sets of positive input/output examples [7, 3, 1]. In the nineties inductive program synthesis has become of interest again in the context of inductive logic programming (ILP) <ref> [4, 5] </ref>. As in the classical approaches, our aim is to infer functional expressions (i.e. terms and not logical clauses) from small sets of positive input/output examples. <p> In contrast to classical approaches to in ductive program synthesis [7, 3, 1] and to ILP approaches <ref> [4, 5] </ref> we do not start with input/output examples but with initial programs which were constructed by planning. This separation of constructing non-recursive initial programs and of generalization has some advantages: We believe that building initial programs and generalization are based on different (cognitive) processes.
Reference: 6. <author> U. Schmid and F. Wysotzki. </author> <title> Induction of recursive program schemes. </title> <booktitle> In Proceedings of the 10th European Conference on Machine Learning (ECML-98), number 1398 in LNAI, </booktitle> <pages> pages 228240. </pages> <publisher> Springer, </publisher> <year> 1998. </year>
Reference-contexts: But, in contrast to both the functional and ILP approach our algorithm works independed of the syntax of some given program language (as LISP or PROLOG). Thereby we are able to infer functions in arbitraty goal languages. In <ref> [6] </ref> we described the basic ideas of our methodology. We propose to split the program synthesis task in two distinct parts: In a first step, we construct initial programs, that is, non-recursive terms which transform the input part of an example into the desired output. <p> This idea was also employed by Summers [7]. His algorithm THESIS workes on cons-expressions as input data which are transformed into the output by rewriting with respect to a complete partial order over conses by means of a small set of primitive functions (namely car and cdr). In <ref> [6] </ref> we show that a wider class of input/output examples can be handled using a generic planning algorithm for constructing initial programs. In this paper, we concentrate on the second part of the synthesis process: generalizing over non-recursive terms. <p> Initial programs are regarded as elements of some term algebra with unknown elements but with known rules for forming syntactically correct expressions. Our generalization algorithm as reported in <ref> [6] </ref> can detect a variety of different recursive structures in initial programs as tail-recursion, linear-recursion, tree-recursion and combinations. But the algorithm is limited to cases where the parameters are replaced independently from one another. <p> It can easily be extended to structures starting with a nonrecursive term (i.e. a more complex calling main program) as shown in <ref> [6] </ref>. Currently we are working on an extension of the method to the detection of sets of recursive functions. A problem, which is probably beyond the scope of our method is the detection of indirect recursions (i.e. recursive functions which mutually call themselves).
Reference: 7. <author> P. D. Summers. </author> <title> A methodology for LISP program construction from examples. </title> <journal> Journal ACM, </journal> <volume> 24(1):162175, </volume> <year> 1977. </year>
Reference-contexts: 1 Introduction Inductive synthesis of recursive programs from examples was a major research topic in the seventies and eighties. Typically, the proposed algorithms had their background in the domain of functional (LISP) programming and relied on small sets of positive input/output examples <ref> [7, 3, 1] </ref>. In the nineties inductive program synthesis has become of interest again in the context of inductive logic programming (ILP) [4, 5]. As in the classical approaches, our aim is to infer functional expressions (i.e. terms and not logical clauses) from small sets of positive input/output examples. <p> In the second step, we generalize the initial program to a recursive function. This idea was also employed by Summers <ref> [7] </ref>. His algorithm THESIS workes on cons-expressions as input data which are transformed into the output by rewriting with respect to a complete partial order over conses by means of a small set of primitive functions (namely car and cdr). <p> In contrast to classical approaches to in ductive program synthesis <ref> [7, 3, 1] </ref> and to ILP approaches [4, 5] we do not start with input/output examples but with initial programs which were constructed by planning.
References-found: 7

