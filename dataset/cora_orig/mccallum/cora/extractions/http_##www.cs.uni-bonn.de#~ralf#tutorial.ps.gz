URL: http://www.cs.uni-bonn.de/~ralf/tutorial.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~ralf/index.body.html
Root-URL: http://cs.uni-bonn.de
Title: A Gentle Introduction to Haskell Version 1.4  
Author: Paul Hudak John Peterson Joseph H. Fasel 
Date: March, 1997  
Affiliation: Yale University Department of Computer Science  Yale University Department of Computer Science  University of California Los Alamos National Laboratory  
Abstract-found: 0
Intro-found: 1
Reference: <institution> References </institution>
Reference: [1] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Introduction to Functional Programming <ref> [1] </ref>, which uses a language sufficiently similar to Haskell to make translation between the two quite easy. For a useful survey of functional programming languages and techniques, including some of the language design principles used in Haskell, see [2]. The Haskell language has evolved significantly since it's birth in 1987.
Reference: [2] <author> P. Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <year> 1989. </year>
Reference-contexts: Introduction to Functional Programming [1], which uses a language sufficiently similar to Haskell to make translation between the two quite easy. For a useful survey of functional programming languages and techniques, including some of the language design principles used in Haskell, see <ref> [2] </ref>. The Haskell language has evolved significantly since it's birth in 1987. This tutorial deals with version 1.4 of the Haskell report. This version is nearly identical the prior 1.3 version; either the 1.3 or the 1.4 report can be used in conjunction with this tutorial.
Reference: [3] <author> J. Peterson and K. Hammond (editors). </author> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.4). </title> <institution> Yale University, Department of Computer Science Tech Report YALEU/DCS/RR-1106, </institution> <month> Feb </month> <year> 1997. </year>
Reference: [4] <author> K. Hammond and J. Peterson (editors). </author> <title> The Haskell Library Report. </title> <institution> Yale University, Department of Computer Science Tech Report YALEU/DCS/RR-1105, </institution> <month> Feb </month> <year> 1997. </year>
Reference-contexts: We suggest, however, that the reader completely ignore the details until the Gentle Introduction has been completely read. On the other hand, Haskell's Standard Prelude (in Appendix A of the Report and the standard libraries (found in the Library Report <ref> [4] </ref>) contain lots of useful examples of Haskell code; we encourage a thorough reading once this tutorial is completed.
Reference: [5] <author> R.S. Nikhil. </author> <title> Id (version 90.0) reference manual. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: of the squares of numbers from 1 to 100: squares = array (1,100) [(i, i*i) | i &lt;- [1..100]] This array expression is typical in using a list comprehension for the association list; in fact, this usage results in array expressions much like the array comprehensions of the language Id <ref> [5] </ref>.
Reference: [6] <editor> J. Rees and W. Clinger (eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIG-PLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: -&gt; m a -&gt; m a Instances of MonadPlus should obey the following laws: m ++ zero = m zero ++ m = m The ++ operator is ordinary list concatenation in the list monad. 9 Numbers Haskell provides a rich collection of numeric types, based on those of Scheme <ref> [6] </ref>, which in turn are based on Common Lisp [7]. (Those languages, however, are dynamically typed.) The standard types include fixed- and arbitrary-precision integers, ratios (rational numbers) formed from each integer type, and single- and double-precision real and complex floating-point.
Reference: [7] <author> G.L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, Mass., </address> <year> 1984. </year>
Reference-contexts: should obey the following laws: m ++ zero = m zero ++ m = m The ++ operator is ordinary list concatenation in the list monad. 9 Numbers Haskell provides a rich collection of numeric types, based on those of Scheme [6], which in turn are based on Common Lisp <ref> [7] </ref>. (Those languages, however, are dynamically typed.) The standard types include fixed- and arbitrary-precision integers, ratios (rational numbers) formed from each integer type, and single- and double-precision real and complex floating-point.
Reference: [8] <author> P. Wadler. </author> <title> How to replace failure by a list of successes. </title> <booktitle> In Proceedings of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <volume> LNCS Vol. 201, </volume> <pages> pages 113-128. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Now that we can turn trees into strings, let's turn to the inverse problem. The basic idea is a parser for a type a, which is a function that takes a string and returns a list of (a, String) pairs <ref> [8] </ref>. The Prelude provides a type synonym for such functions: type ReadS a = String -&gt; [(a,String)] Normally, a parser returns a singleton list, containing a value of type a that was read from the input string and the remaining string that follows what was parsed.
References-found: 9

