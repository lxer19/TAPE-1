URL: ftp://ftp.csd.uu.se/pub/papers/masters-theses/0108-carlsson.ps.gz
Refering-URL: http://www.csd.uu.se/~richardc/
Root-URL: 
Title: Towards a deadlock analysis for Erlang programs  
Author: Richard Carlsson Examiner: H-akan Millroth 
Degree: Supervisor: H-akan Millroth  
Address: Box 311 S-751 05 Uppsala Sweden  
Affiliation: Computing Science Department Uppsala University  Passed:  
Note: Uppsala Master's Theses in Computing Science 108 Examensarbete MN3 1997-04-15 ISSN 1100-1836  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Joe Armstrong and Robert Virding. </author> <title> Programming telephony. In Strand: New Concepts in Parallel Programming, </title> <booktitle> by Ian Foster and Stephen Taylor, </booktitle> <pages> pages 289-304. </pages> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Thus it cannot be assumed that no other message will be received after the specified time has elapsed; it only guarantees that the process executing the receive will not suspend indefinitely. This follows the Strand implementation <ref> [1] </ref> of Erlang, and should be true for the language in general. We want to keep the protocol between the receiver and the timer processes minimal, so we do not include any acknowledging of messages sent between them. <p> tests.) 5.2.2 Translating Erlang into CCP Leaving out the handling of process failure and error recovery, system calls, etc., there are three primary problems to be addressed in translating an Erlang program into CCP code. (A detailed description of the translation into Strand is given by Armstrong and Virding in <ref> [1] </ref>.) The first problem is to implement the functional semantics of Erlang; this is simply handled by adding an extra argument to the Erlang clauses, to hold the result. The second problem is to sequentialise the execution of the calls in the Erlang clause bodies.
Reference: [2] <author> Joe Armstrong, Robert Virding, Claes Wikstrom, and Mike Williams. </author> <title> Con current Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1996. </year>
Reference-contexts: There is no destructive updating in the language. It should be noted that as of this writing, Erlang is still under much development, and that what is stated here applies primarily to the language as described in the 1996 edition of "Concurrent Programming in Erlang" <ref> [2] </ref>. Still, for the purposes of this work, we are only concerned with the core of the language, which is not likely to change in any significant way. 4.1 The functional core The basic syntax is similar to Prolog.
Reference: [3] <author> Kenneth P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference: [4] <author> Richard Carlsson and H-akan Millroth. </author> <title> On cyclic process dependencies and the verification of absence of deadlocks in reactive systems. </title> <institution> Computing Science Department, Uppsala University, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: It is also far from obvious what the absence of deadlock cycles implies regarding the existence of local deadlocks (livelocks) particularly in the case when processes can be dynamically created by the program. In <ref> [4] </ref>, we give a thorough treatment of all the above questions, defining the class of weak process dependency relations, together with a basic set of rules for determining when such dependencies can safely be excluded between pairs of processes, and showing how Masticola's method can be extended using these dependency relations <p> The method is shown fast enough to be practical, and generally has better time behaviour than other analyses. (See section 1.6 for related work.) We believe that our extension of Masticola's method, described in detail in <ref> [4] </ref>, could give useful results if applied to Erlang programs, given that the precision problems described above can be solved satisfactorily, and we hope that in the future, an attempt will be made to do this. 40
Reference: [5] <author> Shing Chi Cheung and Jeff Kramer. </author> <title> Tractable dataflow analysis for dis tributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8) </volume> <pages> 579-593, </pages> <month> August </month> <year> 1994. </year>
Reference: [6] <author> Michael Codish, Moreno Falaschi, and Kim Marriott. </author> <title> Suspension analy ses for Concurrent Logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 649-686, </pages> <year> 1994. </year>
Reference: [7] <author> Michael Codish, Moreno Falaschi, Kim Marriott, and William Winsbor ough. </author> <title> Efficient analysis of Concurrent Constraint Logic programs. </title> <booktitle> In Proceedings of the 20th International Colloquium on Automata, Languages and Programming. Lecture Notes in Computer Science, </booktitle> <volume> Vol. 700, </volume> <pages> pages 633-644. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference: [8] <author> Christopher Colby. </author> <title> Analysis of synchronization and aliasing with abstract interpretation. </title> <note> Unpublished. </note>
Reference-contexts: These are, respectively, the synchronization and aliasing analysis of Colby <ref> [8] </ref>, and Masticola's method of locating and eliminating possible dependency cycles [19].
Reference: [9] <author> Christopher Colby. </author> <title> Analyzing the communication topology of concurrent programs. </title> <booktitle> In The ACM Symposium on Partial Evaluation and Semantics-based Program Manipulation, </booktitle> <pages> pages 202-214, </pages> <year> 1995. </year>
Reference-contexts: Colby's trace-based analysis of the communication topology <ref> [9] </ref> of concurrent programs seems to be a good candidate for improving this situation. Lastly, the need for a representation in any analysis of the contents of message buffers in the asynchronous inter-process communication system of Erlang (see chapter 5) is likely to blur many data dependencies.
Reference: [10] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fix-points. </title> <booktitle> In Conference Record of the 4th annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year> <month> 41 </month>
Reference: [11] <author> Saumya Debray, David Gudeman, and Peter Bigot. </author> <title> Detection and opti mization of suspension-free Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 29(1-3):171-194, </volume> <year> 1996. </year>
Reference: [12] <author> Saumya K. Debray. </author> <title> Efficient dataflow analysis of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 949-984, </pages> <year> 1994. </year>
Reference: [13] <author> Alain Deutsch. </author> <title> Operational Models of Programming Languages and Repre sentations of Relations on Regular Languages with Application to the Static Determination of Dynamic Aliasing Properties of Data. </title> <type> PhD thesis, </type> <institution> LIX, Ecole Polytechnique, Palaiseau, France, </institution> <year> 1992. </year>
Reference: [14] <author> Alain Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proceedings of the IEEE 1992 International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <address> San Francisco, California, </address> <month> April </month> <year> 1992. </year>
Reference: [15] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> New Concepts in Parallel Program ming. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Introduction to the Erlang language Erlang was originally invented as a programming notation to be automatically translated into a concurrent logic language. The first implementations used Parlog [16] as the target language; this was then changed to Strand <ref> [15] </ref> for efficiency reasons. (Section 5.2.2 discusses the translation from Erlang to languages such as these.) Both of the latter languages inherit most of their syntax and terminology from Prolog [22] and CSP [17], and a lot of that has carried over also to Erlang. <p> The clause cannot be selected unless the Tell bindings are consistent with the current state, and if it is selected, the bindings are performed as part of the (atomic) reduction. In languages like Strand <ref> [15] </ref>, there is no Tell part, and bindings are instead performed by externally defined atoms included in the body. This does in fact reduce their expressiveness somewhat; see [25].
Reference: [16] <author> S. Gregory. </author> <title> Parallel Logic Programming in PARLOG. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Introduction to the Erlang language Erlang was originally invented as a programming notation to be automatically translated into a concurrent logic language. The first implementations used Parlog <ref> [16] </ref> as the target language; this was then changed to Strand [15] for efficiency reasons. (Section 5.2.2 discusses the translation from Erlang to languages such as these.) Both of the latter languages inherit most of their syntax and terminology from Prolog [22] and CSP [17], and a lot of that has
Reference: [17] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: The first implementations used Parlog [16] as the target language; this was then changed to Strand [15] for efficiency reasons. (Section 5.2.2 discusses the translation from Erlang to languages such as these.) Both of the latter languages inherit most of their syntax and terminology from Prolog [22] and CSP <ref> [17] </ref>, and a lot of that has carried over also to Erlang. Later implementations of Erlang are however built on abstract machine models designed specifically for its own particular semantics. Unlike Parlog and Strand, Erlang is a functional language. <p> Thus, the last example shows that apart from a carrier process, at least one other process is necessary for each source-destination pair. Letting this other process be an (unbounded) buffer server, acting on requests from the sender and carrier processes (see <ref> [17] </ref> for an early example of a bounded buffer process using synchronous communication), our model of the asynchronous messaging system is complete, as illustrated in Figure 5.3.
Reference: [18] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference: [19] <author> Stephen P. Masticola. </author> <title> Static Detection of Deadlocks in Polynomial Time. </title> <type> PhD thesis, </type> <institution> New Brunswick Rutgers, State University of New Jersey, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: These are, respectively, the synchronization and aliasing analysis of Colby [8], and Masticola's method of locating and eliminating possible dependency cycles <ref> [19] </ref>. <p> The details of CHT analysis are complicated an important ingredient is a previous stage of analysis determining a "must have completed before"-relation on program points see <ref> [19] </ref> for mathematical models and examples of analyses of Ada, binary semaphores, and Concurrent C. 6.2 Our extension Masticola however fails to recognise that the concept of a "waits-on" dependency between processes is more complicated than our first intuition gives at hand. <p> probably be used to both simplify the analysis and increase its precision. 6.4 Conclusions Cycle detection and elimination, as opposed to most other suggested methods for verifying absence of deadlocks, has been shown (by Masticola) to be applicable in practice to large real-world programs, and with quite good results (see <ref> [19] </ref>). It also has the advantage over most other methods that it can locate possible local deadlocks as well as global, and give meaningful information about their causes.
Reference: [20] <author> S. G. Matthews. </author> <title> An extensional treatment of lazy data flow deadlocks. </title> <journal> Theoretical Computer Science, </journal> <volume> 151(1) </volume> <pages> 195-205, </pages> <year> 1995. </year>
Reference: [21] <author> E. Shapiro and S. Safra. </author> <title> Multiway merge with constant delay in Concurrent Prolog. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 211-216, </pages> <year> 1986. </year>
Reference-contexts: For instance, in <ref> [21] </ref> Shapiro and Safra use a built-in operator, which places a message in the first uninstantiated slot of a stream as an atomic operation, to implement a fair multiway merge.
Reference: [22] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The first implementations used Parlog [16] as the target language; this was then changed to Strand [15] for efficiency reasons. (Section 5.2.2 discusses the translation from Erlang to languages such as these.) Both of the latter languages inherit most of their syntax and terminology from Prolog <ref> [22] </ref> and CSP [17], and a lot of that has carried over also to Erlang. Later implementations of Erlang are however built on abstract machine models designed specifically for its own particular semantics. Unlike Parlog and Strand, Erlang is a functional language.
Reference: [23] <author> Scott D. Stoller and Fred B. Schneider. </author> <title> Verifying programs that use causally-ordered message-passing. </title> <institution> Department of Computer Science, Cor-nell University, </institution> <address> Ithaca, New York, </address> <month> April </month> <year> 1995. </year>
Reference: [24] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent pro grams. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <year> 1983. </year>
Reference: [25] <author> E. Yardeni, S. Kliger, and E. Shapiro. </author> <title> The languages FCP(:) </title> <journal> and FCP(:,?). New Generation Computing, </journal> <volume> 7(2) </volume> <pages> 89-107, </pages> <year> 1990. </year> <month> 42 </month>
Reference-contexts: In the most general, still monotonic form of CCP, a program clause (or rule) can be written on the following form (see e. g. Yardeni et al. 1990 <ref> [25] </ref>): Head &lt;- Ask : Tell | Body where Head is the clause head as in Erlang, Ask is a sequence of guards, Tell is a sequence of variable bindings and Body a sequence of atoms to be spawned. <p> In languages like Strand [15], there is no Tell part, and bindings are instead performed by externally defined atoms included in the body. This does in fact reduce their expressiveness somewhat; see <ref> [25] </ref>. Lastly, unlike Erlang, where the comma-separated expressions in a clause body are evaluated in textual order, those atoms spawned by a reduction in 31 CCP may be scheduled in any order, unless they explicitly synchronise via shared variables, as described. <p> This however calls for a nonstandard extension to CCP, such as the otherwise guard test found in FCP (:,?) <ref> [25] </ref> and Strand, and can not be implemented otherwise.
References-found: 25

