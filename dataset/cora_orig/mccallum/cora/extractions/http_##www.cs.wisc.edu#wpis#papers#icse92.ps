URL: http://www.cs.wisc.edu/wpis/papers/icse92.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: 1 The Use of Program Dependence Graphs in Software Engineering  
Author: Susan Horwitz and Thomas Reps 
Note: The paper primarily surveys work in this area that has been carried out at the University of Wisconsin during the past five years.  
Affiliation: University of Wisconsin  
Abstract: This paper describes a language-independent program representationthe program dependence graphand discusses how program dependence graphs, together with operations such as program slicing, can provide the basis for powerful programming tools that address important software-engineering problems, such as understanding what an existing program does and how it works, understanding the differences between several versions of a program, and creating new programs by combining pieces of old programs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Allen, J.R., </author> <title> Dependence analysis for subscripted variables and its application to program transformations, </title> <type> Ph.D. Thesis, </type> <institution> Department of Math. Sciences, Rice University, </institution> <address> Houston, TX (April 1983). </address>
Reference-contexts: Flow dependences are further classified as loop independent or loop carried <ref> [1] </ref>. <p> For example, we show below two programs and the set of untagged slices to which both programs correspond: program <ref> [1] </ref> x := 0 [3] w := x program [1] x := 0 [4] x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in <p> For example, we show below two programs and the set of untagged slices to which both programs correspond: program <ref> [1] </ref> x := 0 [3] w := x program [1] x := 0 [4] x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in the second program have different tags (indicated by [1] <p> <ref> [1] </ref> x := 0 [4] x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in the second program have different tags (indicated by [1] and [4]), the two pro grams correspond to different elements in the lattice of downwards-closed sets of tagged slices: , , ,I program J end J program [1] x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the <p> := 0 J end J Because the two occurrences of x := 0 in the second program have different tags (indicated by <ref> [1] </ref> and [4]), the two pro grams correspond to different elements in the lattice of downwards-closed sets of tagged slices: , , ,I program J end J program [1] x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] <p> Because the two occurrences of x := 0 in the second program have different tags (indicated by <ref> [1] </ref> and [4]), the two pro grams correspond to different elements in the lattice of downwards-closed sets of tagged slices: , , ,I program J end J program [1] x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program <p> 0 in the second program have different tags (indicated by <ref> [1] </ref> and [4]), the two pro grams correspond to different elements in the lattice of downwards-closed sets of tagged slices: , , ,I program J end J program [1] x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program [4] x := 0 program M [4] <p> program J end J program <ref> [1] </ref> x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program [4] x := 0 program M [4] x := 0 J end J Nevertheless, for both lattices, whenever the set that results from evaluating A [Base ]B is feasible, the corresponding program meets the semantic criterion for integration given in <p> <ref> [1] </ref> x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program [4] x := 0 program M [4] x := 0 J end J Nevertheless, for both lattices, whenever the set that results from evaluating A [Base ]B is feasible, the corresponding program meets the semantic criterion for integration given in Section 5.1.
Reference: 2. <author> Alpern, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Detecting equality of variables in programs, pp. </title> <booktitle> 1-11 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), (1988). </year>
Reference-contexts: described here for identifying the differences between two versions of a program, the Sequence-Congruence Algorithm can be used as a subroutine in an algorithm for integration problem I.1; this is discussed in Section 5.1.1.) The Sequence-Congruence Algorithm uses a technique (which we will call the Basic Partitioning Algorithm) adapted from <ref> [2] </ref>, which is based on an algorithm for minimizing a finite-state machine [15]. This technique finds the coarsest partition of a graph that is consistent with a given initial partition of the graph's vertices.
Reference: 3. <author> Ball, T., Horwitz, S., and Reps, T., </author> <title> Correctness of an algorithm for reconstituting a program from a dependence graph, </title> <type> Technical Report 947, </type> <institution> Department of Computer Sciences, University of Wisconsin Madison (July 1990). </institution>
Reference-contexts: The final step of the HPR algorithm involves reconstituting a program from the merged program dependence graph. However, it is possible that there is no such programthe merged graph can be an infeasible program dependence graph; this is Type II interference. (See [18] or <ref> [3] </ref> for a discussion of reconstructing a program from the merged program dependence graph and the inherent difficulties of this problem.) If neither kind of interference occurs, one of the programs that corresponds to the graph G M is returned as the result of the integration operation. Example. <p> For example, we show below two programs and the set of untagged slices to which both programs correspond: program [1] x := 0 <ref> [3] </ref> w := x program [1] x := 0 [4] x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in the second program have
Reference: 4. <author> Bannerjee, U., </author> <title> Speedup of ordinary programs, </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois, Urbana, </institution> <address> IL (October 1979). </address>
Reference-contexts: For example, we show below two programs and the set of untagged slices to which both programs correspond: program [1] x := 0 [3] w := x program [1] x := 0 <ref> [4] </ref> x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in the second program have different tags (indicated by [1] and [4]), the two <p> := 0 <ref> [4] </ref> x := 0 end , , ,I program J end J program x := 0 program x := 0 end program M x := 0 J end J Because the two occurrences of x := 0 in the second program have different tags (indicated by [1] and [4]), the two pro grams correspond to different elements in the lattice of downwards-closed sets of tagged slices: , , ,I program J end J program [1] x := 0 program [1] x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International <p> x := 0 end program M [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program <ref> [4] </ref> x := 0 program M [4] x := 0 J end J Nevertheless, for both lattices, whenever the set that results from evaluating A [Base ]B is feasible, the corresponding program meets the semantic criterion for integration given in Section 5.1. <p> [1] x := 0 J end J From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 17 - , , , ,I program J end J program [1] x := 0 program [1] x := 0 end program <ref> [4] </ref> x := 0 program M [4] x := 0 J end J Nevertheless, for both lattices, whenever the set that results from evaluating A [Base ]B is feasible, the corresponding program meets the semantic criterion for integration given in Section 5.1.
Reference: 5. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conference Record of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Antonio, TX, </address> <month> January 29-31, </month> <year> 1979), </year> <month> (January </month> <year> 1979). </year>
Reference-contexts: Actual-in and formal-in vertices are included for every parameter; formal-out and actual-out vertices are included only for parameters that may be modified as a result of the call. (Interprocedural data-flow analysis can be used to determine which parameters may be modified as a result of a procedure call <ref> [5] </ref>.) In addition to control, flow, and def-order dependence edges, an SDG includes one new kind of intraprocedural edge called a summary edge.
Reference: 6. <author> Berzins, V., </author> <title> On merging software extensions, </title> <note> Acta Informatica 23 pp. </note> <month> 607-619 </month> <year> (1986). </year>
Reference-contexts: If modifications do not preserve the module's semantics, the notion that module boundaries protect against interferenceeven in conjunction with There has been related work on integrating functions <ref> [6] </ref>, logic programs [25], and specifications [11]; however, different models of integration have been used in each case. For example, in Berzins's work on integrating functions [6], two variant programs, A and B, are merged without regard to Base. <p> not preserve the module's semantics, the notion that module boundaries protect against interferenceeven in conjunction with There has been related work on integrating functions <ref> [6] </ref>, logic programs [25], and specifications [11]; however, different models of integration have been used in each case. For example, in Berzins's work on integrating functions [6], two variant programs, A and B, are merged without regard to Base. <p> Thus, his work treats only the integration of program extensions, not program modifications, where the distinction between the two is as follows: A program extension extends the domain of a partial function without altering any of the initially defined values, while a modification redefines values that were defined initially <ref> [6] </ref>. The function that results from the merge preserves the (entire) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh the above policyis as flawed as the notion used in diff3. Both rely on the incorrect assumption that disjoint changes are interference free.
Reference: 7. <author> Binkley, D., </author> <title> Multi-procedure program integration, </title> <type> Ph.D. Thesis and Technical Report 1038, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], <ref> [7] </ref> Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], <ref> [7] </ref> Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> The latter example leads us to reformulate the integration model to capture better the goals of multi-procedure integration. After discussing the revised model for multi-procedure integration, we outline our multi-procedure integration algorithm. Details can be found in <ref> [7] </ref>. 5.2.1. <p> The criterion used for program integration, and a multi-procedure integration model are presented in <ref> [7] </ref>. Roughly, the multi-procedure integration model requires that the rolled-out version of the integrated program must capture all of the changed and preserved behaviors of the rolled-out versions of the variants with respect to the rolled-out version of Base. <p> v) -) The merged SDG is formed by taking the union of the three graphs that represent the variants' changed and preserved behaviors: S M = df D A, Base g D B, Base g Pre A, Base, B The details of the multi-procedure integration algorithm can be found in <ref> [7] </ref>. 6. IMPLEMENTATION The techniques for slicing, differencing, and integration that are described in this paperas well as a few others not described have been implemented in a prototype system, called the Wiscon-sin Program Integration System [34].
Reference: 8. <author> Binkley, D., Horwitz, S., and Reps, T., </author> <title> Identifying semantic differences in programs with procedures, </title> <type> Unpublished report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI (Sep-tember 1991). </institution>
Reference-contexts: Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. <ref> [8] </ref> Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> It is certainly possible to use other criteria for behavioral equivalence as the basis for a program-differencing tool. (One alternative, in which the criterion for equivalent behavior is not restricted to only top-level behavior, is explored in <ref> [8] </ref>.) However, for this paper we concentrate on the simpler criterion for equivalent behavior given above; this has the advantage that it simplifies the discussion considerably, yet still gives the flavor of the issues that must be addressed in algorithms for semantics-based program differencing.
Reference: 9. <author> Cytron, R., Ferrante, J., Rosen, B.K., Wegman, M.N., and Zadeck, K., </author> <title> An efficient method of computing static single assignment form, pp. </title> <booktitle> 25-35 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <year> 1989), (1989). </year>
Reference: 10. <author> Donzeau-Gouge, V., Huet, G., Kahn, G., and Lang, B., </author> <title> Programming environments based on structured editors: The MENTOR experience, pp. 128-140 in Interactive Programming Environments, </title> <editor> ed. D. Bar-stow, E. Sandewall, and H. Shrobe,McGraw-Hill, </editor> <address> New York (1984). </address>
Reference-contexts: A tagging facility with such properties can be supported by language-based editors, such as those that can be created by such systems as MENTOR <ref> [10] </ref>, GANDALF [29], and the Synthesizer Generator [33].
Reference: 11. <author> Feather, </author> <title> M.S., Detecting interference when merging specification evolutions, </title> <type> Unpublished report, </type> <institution> Information Sciences Institute, University of Southern California, Marina del Rey, </institution> <address> CA (1989). </address>
Reference-contexts: If modifications do not preserve the module's semantics, the notion that module boundaries protect against interferenceeven in conjunction with There has been related work on integrating functions [6], logic programs [25], and specifications <ref> [11] </ref>; however, different models of integration have been used in each case. For example, in Berzins's work on integrating functions [6], two variant programs, A and B, are merged without regard to Base. <p> However, in Lakhotia and Sterling's work there is no notion of interference, and the characterization of the semantic properties of the merged program was left as an open question in [25]. Feather's work on integrating specifications <ref> [11] </ref> does take Base into account, but although his integration algorithm preserves syntactic modifications, it does not guarantee any semantic properties of the integrated specification.
Reference: 12. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference: 13. <author> Gallagher, </author> <title> K.B., Using program slicing in software maintenance, </title> <type> Ph.D. </type> <institution> dissertation and Technical Report CS-90-05, Computer Science Department, University of Maryland, Baltimore Campus, Baltimore, </institution> <note> MD (January 1990). </note>
Reference-contexts: Gallagher has developed a prototype software-maintenance tool to prevent editing changes from having undesired effects on the portions of the code that the user does not want to change <ref> [13] </ref>. Although his work uses slicing to address a problem of interest in software engineering, it is outside the scope of this paper because it relies on Weiser's notion of slices, which cannot be computed using dependence graphs.
Reference: 14. <author> Hoffmann, </author> <title> C.M., Group-Theoretic Algorithms and Graph Isomor-phism, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 136, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1982). </address>
Reference-contexts: Slice-isomorphism testing Two PDG slices are isomorphic if there is a 1-to-1 and onto map between their vertex sets that preserves adjacency and labels. Although there is no known polynomial-time graph-isomorphism algorithm for arbitrary unlabeled graphs <ref> [14] </ref>, there are efficient algorithms for restricted classes of graphs, such as graphs of bounded valence [27].
Reference: 15. <author> Hopcroft, </author> <title> J.E., An n log n algorithm for minimizing the states of a finite automaton, </title> <booktitle> The Theory of Machines and Computations, </booktitle> <pages> pp. </pages> <month> 189-196 </month> <year> (1971). </year>
Reference-contexts: the Sequence-Congruence Algorithm can be used as a subroutine in an algorithm for integration problem I.1; this is discussed in Section 5.1.1.) The Sequence-Congruence Algorithm uses a technique (which we will call the Basic Partitioning Algorithm) adapted from [2], which is based on an algorithm for minimizing a finite-state machine <ref> [15] </ref>. This technique finds the coarsest partition of a graph that is consistent with a given initial partition of the graph's vertices.
Reference: 16. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), (1988). </year>
Reference-contexts: See <ref> [16] </ref> for a comparison of the two approaches. <p> Def-order dependence edges are included in program dependence graphs to ensure that inequivalent programs cannot have isomorphic program dependence graphs <ref> [16] </ref>.
Reference: 17. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference: 18. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Transactions on Programming Languages and Systems 11(3) pp. </journal> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: assignment statements, if-then-else statements, output statements, and while loops. (Input statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], <ref> [18] </ref>, Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. <p> (Input statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], <ref> [18] </ref>, Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. <p> Program Integration for Single-Procedure Programs While our long-term goal is to design a semantics-based program-integration tool for a full-fledged programming language, our early work used a simplified model of program integration so as to make the problem amenable to theoretical study <ref> [18] </ref>. This model possesses the essential features of the problem, and thus permitted us to conduct our studies without being overwhelmed by inessential details. <p> I.1: Program integration given a correspondence among components of Base, A, and B The first algorithm that meets the requirements of the model given above was formulated by Horwitz, Prins, and Reps <ref> [18] </ref>. That algorithmwhich we call the HPR algorithmis the first algorithm for semantics-based program integration. The HPR algorithm represents a fundamental advance over text-based program-integration algorithms (such as the UNIX utility diff3) by providing the first theoretical foundation for building a semantics-based program-integration tool. <p> The final step of the HPR algorithm involves reconstituting a program from the merged program dependence graph. However, it is possible that there is no such programthe merged graph can be an infeasible program dependence graph; this is Type II interference. (See <ref> [18] </ref> or [3] for a discussion of reconstructing a program from the merged program dependence graph and the inherent difficulties of this problem.) If neither kind of interference occurs, one of the programs that corresponds to the graph G M is returned as the result of the integration operation. Example.
Reference: 19. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Transactions on Programming Languages and Systems 12(1) pp. </journal> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: statements, output statements, and while loops. (Input statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. <ref> [19] </ref> Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c <p> problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. <ref> [19] </ref> Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. <ref> [19] </ref> Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> A polynomial-time algorithm that computes the set of summary edges is given in <ref> [19] </ref>. <p> site to the corresponding formal-in vertex in the called procedure; (3) a parameter-out edge is added from each formal-out vertex in the called procedure to the corresponding actual-out vertex at the call site. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Techniques for handling parameters passed by reference and for dealing with aliasing are discussed in <ref> [19] </ref>. <p> This technique ignores calling context, and so includes both calls to Mult3. defined in <ref> [19] </ref>. 7 This technique involves two passes: Pass 1 of a slice (either backward or forward) with respect to point p, starts from the vertex that represents p; it moves across edges within a procedure (including stepping across procedure calls by following summary edges) and up from a called procedure to <p> In this section, we discuss techniques for solving the three differencing problems introduced in Section 1: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 7 A different technique for interprocedural slicing has been given by Hwang et al. [22]. Their method also correctly handles the calling-context problem, but does not use SDGs. See <ref> [19] </ref> for a comparison of the two algo rithms.
Reference: 20. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June </month> <year> 1990), </year> <pages> pp. </pages> <month> 234-246 (June </month> <year> 1990). </year>
Reference-contexts: statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], <ref> [20] </ref> Sect. 4.1.2. [44], [20], Sect. 4.1.1. <p> however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], <ref> [20] </ref> Sect. 4.1.2. [44], [20], Sect. 4.1.1.
Reference: 21. <author> Horwitz, S. and Reps, T., </author> <title> Efficient comparison of program slices, </title> <note> Acta Informatica 28 pp. </note> <month> 713-732 </month> <year> (1991). </year>
Reference-contexts: Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], <ref> [21] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c <p> Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], <ref> [21] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> This property makes it possible to use depth-first search (traversing edges from targets to sources) to test whether two slices (possibly in different PDGs) are isomorphic. The running time of the algorithm is linear in the size of the smaller of the two slices being tested <ref> [21] </ref>. Because program points with isomorphic slices are guaranteed to have equivalent behavior, differencing problem D.2 can be solved by using the slice-isomorphism-testing algorithm of [21] to partition the components of New and Old into equivalence classes of isomorphic slices. <p> The running time of the algorithm is linear in the size of the smaller of the two slices being tested <ref> [21] </ref>. Because program points with isomorphic slices are guaranteed to have equivalent behavior, differencing problem D.2 can be solved by using the slice-isomorphism-testing algorithm of [21] to partition the components of New and Old into equivalence classes of isomorphic slices. The solution to D.2 is the set of components of New that are in a class that does not include any component of Old. <p> whether two b2 slices are isomorphic in time linear in the size of the smaller of the two slices being tested, and it is possible to partition the components of one or more procedures into equivalence classes in time proportional to the sum of the sizes of their b2 slices <ref> [21] </ref>. As discussed in Section 4.2.1, when two procedure components have isomorphic b2 slices they are guaranteed to produce the same sequence of values at top-level whenever their respective procedures are called with the same actual parameters.
Reference: 22. <author> Hwang, J.C., Du, M.W., and Chou, C.R., </author> <title> Finding program slices for recursive procedures, </title> <booktitle> in Proceedings of IEEE COMPSAC 88, </booktitle> <address> (Chi-cago, IL, </address> <month> Oct. </month> <pages> 3-7, </pages> <address> 1988), </address> <publisher> IEEE Computer Society, </publisher> <address> Washington, DC (1988). </address>
Reference-contexts: Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], <ref> [22] </ref>, [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> In this section, we discuss techniques for solving the three differencing problems introduced in Section 1: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 7 A different technique for interprocedural slicing has been given by Hwang et al. <ref> [22] </ref>. Their method also correctly handles the calling-context problem, but does not use SDGs. See [19] for a comparison of the two algo rithms.
Reference: 23. <author> Kuck, D. J., Muraoka, Y., and Chen, S. C., </author> <title> On the number of operations simultaneously executable in FORTRAN-like programs and their resulting speed-up, </title> <journal> IEEE Transactions on Computers C-21, </journal> <pages> pp. </pages> <month> 1293-1310 (December </month> <year> 1972). </year>
Reference-contexts: Section 6 provides information about a prototype system implemented at the University of Wisconsin that incorporates the ideas described in the paper. 2. DEPENDENCE GRAPHS Different definitions of program dependence representations have been given, depending on the intended application; however, they are all variations on a theme introduced in <ref> [23] </ref> and share the common feature of having explicit representations of both control dependences and data dependences. In Section 2.1 we define program dependence graphs, which can be used to represent single-procedure programs; that is, programs that consist of a single main procedure, with no procedure or function calls.
Reference: 24. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), (1981). </year>
Reference: 25. <author> Lakhotia, A. and Sterling, L., </author> <title> Composing recursive logic programs with clausal join, </title> <journal> New Generation Computing 6(2) pp. </journal> <month> 211-225 </month> <year> (1988). </year>
Reference-contexts: If modifications do not preserve the module's semantics, the notion that module boundaries protect against interferenceeven in conjunction with There has been related work on integrating functions [6], logic programs <ref> [25] </ref>, and specifications [11]; however, different models of integration have been used in each case. For example, in Berzins's work on integrating functions [6], two variant programs, A and B, are merged without regard to Base. <p> The 1-1 join operation defined by Lakhotia and Sterling is also a two-way merge <ref> [25] </ref>. However, in Lakhotia and Sterling's work there is no notion of interference, and the characterization of the semantic properties of the merged program was left as an open question in [25]. <p> The 1-1 join operation defined by Lakhotia and Sterling is also a two-way merge <ref> [25] </ref>. However, in Lakhotia and Sterling's work there is no notion of interference, and the characterization of the semantic properties of the merged program was left as an open question in [25]. Feather's work on integrating specifications [11] does take Base into account, but although his integration algorithm preserves syntactic modifications, it does not guarantee any semantic properties of the integrated specification.
Reference: 26. <author> Larus, J.R. and Hilfinger, </author> <title> P.N., Detecting conflicts between structure accesses, </title> <booktitle> Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <pages> pp. </pages> <month> 21-34 (June </month> <year> 1988). </year>
Reference: 27. <author> Luks, E., </author> <title> Isomorphism of bounded valence can be tested in polynomial time, pp. </title> <booktitle> 42-49 in Proceedings of the Twenty-First IEEE Symposium on Foundations of Computer Science (Syracuse, </booktitle> <address> NY, </address> <month> October </month> <year> 1980), </year> <booktitle> IEEE Computer Society, </booktitle> <address> Washington, DC (1980). </address>
Reference-contexts: Although there is no known polynomial-time graph-isomorphism algorithm for arbitrary unlabeled graphs [14], there are efficient algorithms for restricted classes of graphs, such as graphs of bounded valence <ref> [27] </ref>. Slice-isomorphism testing also concerns a restricted class of graphs: the vertices and edges in a program dependence graph are labeled, and the labeling, in conjunction with a graph's def-order edges, permits a vertex's incoming control and flow edges to be totally ordered.
Reference: 28. <author> Mogensen, T. and Holst, C.K., </author> <title> [Partial Evaluation] Terminology, </title> <journal> New Generation Computing 6 pp. </journal> <month> 303-307 </month> <year> (1988). </year>
Reference: 29. <author> Notkin, D., Ellison, R.J., Staudt, B.J., Kaiser, G.E., Kant, E., Haber-mann, A.N., Ambriola, V., and Montangero, C., </author> <title> Special issue on the GANDALF project, </title> <journal> Journal of Systems and Software 5(2)(May 1985). </journal>
Reference-contexts: A tagging facility with such properties can be supported by language-based editors, such as those that can be created by such systems as MENTOR [10], GANDALF <ref> [29] </ref>, and the Synthesizer Generator [33].
Reference: 30. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: variables, assignment statements, if-then-else statements, output statements, and while loops. (Input statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. <ref> [30] </ref>, [18], Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. <p> Single-Procedure Slicing Although Weiser's original slicing algorithm was expressed in terms of solving a sequence of dataflow-analysis problems [41], both backward and forward slices can be computed more efficiently using traversals of program dependence graphs <ref> [30] </ref>. 6 The backward (forward) slice of program P with respect to point p can be computed in time linear in the size of the slice by following control and flow dependence edges backward (forward) in P's PDG, starting from the vertex that represents point p.
Reference: 31. <author> Podgurski, A. and Clarke, L.A., </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance, </title> <journal> IEEE Transactions on Software Engineering SE-16(9) pp. </journal> <month> 965-979 (September </month> <year> 1990). </year>
Reference-contexts: vertex v to vertex w if vertex v represents a program component that assigns a value to some variable x, vertex w represents a com-hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 Podgurski and Clarke have explored an alternative concept that they call weak control dependence, which accounts for the control effects of potentially nonterminating constructs <ref> [31] </ref>. 3 Some definitions of program dependence graphs include output dependences and anti dependences in place of def-order dependences. See [16] for a comparison of the two approaches.
Reference: 32. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing, </title> <type> Technical Report 777, </type> <institution> Department of Computer Sciences, </institution> <note> University of WisconsinMadison (June 1988). </note>
Reference-contexts: The correctness of our solutions to problems S.1, S.2, and S.3 follow from the Slicing Theorem and Corollary proved in <ref> [32] </ref>: Theorem. (Slicing Theorem). Let s be a PDG slice of program P and let Q be a program whose program dependence graph is isomorphic to s.
Reference: 33. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator: A system for constructing language-based editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: A tagging facility with such properties can be supported by language-based editors, such as those that can be created by such systems as MENTOR [10], GANDALF [29], and the Synthesizer Generator <ref> [33] </ref>. <p> The Wisconsin Program Integration System is coupled to a program editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program editors <ref> [33] </ref>. Program analysis is carried out according to the editor's defining attribute grammar; the information gathered in this way is used to construct system dependence graphs. Commands are available in the editor to invoke the operations of slicing, differencing, and integration.
Reference: 34. <author> Reps, T., </author> <title> Demonstration of a prototype tool for program integration, </title> <type> Technical Report 819, </type> <institution> Department of Computer Sciences, </institution> <note> University From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 - 20 - of WisconsinMadison (January 1989). </note>
Reference-contexts: IMPLEMENTATION The techniques for slicing, differencing, and integration that are described in this paperas well as a few others not described have been implemented in a prototype system, called the Wiscon-sin Program Integration System <ref> [34] </ref>. The Wisconsin Program Integration System is coupled to a program editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program editors [33].
Reference: 35. <author> Reps, T. and Bricker, T., </author> <title> Illustrating interference in interfering versions of programs, </title> <booktitle> Proceedings of the 2nd International Workshop on Software Configuration Management, </booktitle> <address> (Princeton, NJ, </address> <month> October 24-27, </month> <year> 1989), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 17(7) pp. </booktitle> <month> 46-55 (November </month> <year> 1989). </year>
Reference-contexts: When interference is detected (i.e., integration fails), the system provides an interactive facility to help the user diagnose the cause of interference <ref> [35] </ref>. The Wisconsin Program Integration System can be obtained by contacting the authors. It is being distributed under license by the Computer Sciences Department at the University of Wisconsin-Madison.
Reference: 36. <author> Reps, T., </author> <title> The Wisconsin program-integration system reference manual, Unpublished document, </title> <institution> Department of Computer Sciences, University of Wisconsin, Madison, </institution> <address> WI (April 1990). </address>
Reference-contexts: It is being distributed under license by the Computer Sciences Department at the University of Wisconsin-Madison. The distribution consists of the source code for the system together with a reference manual that documents how to use the system <ref> [36] </ref>. The system is written in C and SSL (the specification language of the Synthesizer Generator) and runs under UNIX on a variety of workstations. Further information about configuration requirements is available on request from the authors.
Reference: 37. <author> Reps, T., </author> <title> Algebraic properties of program integration, </title> <booktitle> in Proceedings of the Third European Symposium on Programming, </booktitle> <address> (Copenhagen, Denmark, </address> <month> May 15-18, </month> <year> 1990), </year> <note> Lecture Notes in Computer Science, </note> <editor> ed. N. Jones,Springer-Verlag, </editor> <address> New York, NY (May 1990). </address>
Reference: 38. <author> Reps, T., </author> <title> Algebraic properties of program integration, </title> <booktitle> Science of Computer Programming 17 pp. </booktitle> <month> 139-215 </month> <year> (1991). </year>
Reference-contexts: Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. <ref> [38] </ref>, [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c
Reference: 39. <author> Rosen, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Global value numbers and redundant computations, pp. </title> <booktitle> 12-27 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), (1988). </year>
Reference: 40. <author> Shapiro, R. M. and Saint, H., </author> <title> The representation of algorithms, </title> <institution> Technical Reprot CA-7002-1432, Massachusetts Computer Associates (February 1970). </institution>
Reference: 41. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: and while loops. (Input statements are not included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. [19] Sect. 3.1. <ref> [41] </ref> Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c <p> I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. [19] Sect. 3.1. <ref> [41] </ref> Sect. 4.1.1. [18], [20] Sect. 4.1.2. [44], [20], Sect. 4.1.1. Sect. 5.1.1 and 5.1.2. [46] Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> Single-Procedure Slicing Although Weiser's original slicing algorithm was expressed in terms of solving a sequence of dataflow-analysis problems <ref> [41] </ref>, both backward and forward slices can be computed more efficiently using traversals of program dependence graphs [30]. 6 The backward (forward) slice of program P with respect to point p can be computed in time linear in the size of the slice by following control and flow dependence edges backward
Reference: 42. <author> Wolfe, M. J., </author> <title> Optimizing supercompilers for supercomputers, </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois, Urbana, </institution> <address> IL (October 1982). </address>
Reference: 43. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> Detecting program components with equivalent behaviors, </title> <type> Technical Report 840, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, </institution> <address> WI (April 1989). </address>
Reference: 44. <author> Yang, W., </author> <title> A new algorithm for semantics-based program integration, </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, WI (1990). </institution>
Reference-contexts: included; however, programs are assumed to be run on an initial hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Slicing problems Differencing problems Integration problems iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii S.1 S.2 S.3 D.1 D.2 D.3 I.1 I.2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Single procedure programs Sect. 3.1. [30], [18], Sect. 3.1. [19] Sect. 3.1. [41] Sect. 4.1.1. [18], [20] Sect. 4.1.2. <ref> [44] </ref>, [20], Sect. 4.1.1.
Reference: 45. <author> Yang, W., </author> <title> Identifying syntactic differences between two programs, </title> <journal> Software Practice& Experience 21(7) pp. </journal> <month> 739-755 (July </month> <year> 1991). </year>
Reference-contexts: be established by using a special editor to create New from (a copy of) Old, where the editor keeps track of the migration of components as New is edited. 8 The correspondence could also be established by applying a syntactic matching algorithm to the two programs, such as that of <ref> [45] </ref>. The component-correspondence relation in differencing problem D.1 furnishes the means for establishing how program-dependence-graph vertices from different versions correspond. It is the component-correspondence relation that is used to determine identical vertices when operations are performed using vertices from different program dependence graphs. <p> be established either by using a special editor to create the variants from (copies of) Base, where the editor keeps track of the migration of components as variants A and B are edited, or by first applying a syntactic matching algorithm to the three programs, such as that described in <ref> [45] </ref>. 5.1. Program Integration for Single-Procedure Programs While our long-term goal is to design a semantics-based program-integration tool for a full-fledged programming language, our early work used a simplified model of program integration so as to make the problem amenable to theoretical study [18].
Reference: 46. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> A program integration algorithm that accommodates semantics-preserving transformations, </title> <journal> ACM Transactions on Software Engineering and Methodology 1(3) pp. </journal> <month> 310-354 (July </month> <year> 1992). </year> <title> From: </title> <booktitle> Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 From: Proceedings of the 14th International Conference on Software Engineering (Melbourne Australia) May 1992 </booktitle>
Reference-contexts: Sect. 5.1.1 and 5.1.2. <ref> [46] </ref> Sect. 5.1.3. [38], [21] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multi procedure programs Sect. 3.2. [19], [22], [7] Sect. 3.2. [19] Sect. 3.2. [41] Sect. 4.2.1. [8] Sect. 4.2.2. [21] Sect. 5.2. [7] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c <p> In contrast, the YHR algorithm is parameterized in terms of a method for identifying congruent components of Base, A, and B. (A precise definition of congruence can be found in <ref> [46] </ref>; roughly, two components are congruent if they and all of their corresponding control dependence ancestors have equivalent behavior.) The partitioning algorithm discussed in Section 4.1.2 is one method that can be used to identify congruent components.
References-found: 46

