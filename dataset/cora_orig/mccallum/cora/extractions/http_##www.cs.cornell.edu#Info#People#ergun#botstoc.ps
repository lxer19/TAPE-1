URL: http://www.cs.cornell.edu/Info/People/ergun/botstoc.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/ergun/research.html
Root-URL: 
Title: Testing Multivariate Linear Functions: Overcoming the Generator Bottleneck  
Author: Funda Ergun 
Abstract: Self-testing programs are an approach to the problem of program correctness [BLR90]. One can construct self-testers by exploiting the set of properties that uniquely define the function and test that they hold at random inputs. The existing methods become more costly in the case of multivariate functions, since the number of such properties grows infeasibly large. In this paper we develop techniques for finding a much smaller set of such properties. These lead to more efficient testers for multi-variate linear functions. We present efficient self-testers for the following functions that did not have self-testers before: Fast Fourier Transform (both directions), evaluation of polynomials, dot product (and therefore vector 2-norm), and pointwise evaluation of linear functions on vectors (and some non-linear ones as well). We present a tester for polynomial multiplication that makes O(1) calls to the program, in contrast to O(log n) of the existing tester, and present a new tester for matrix multiplication. All of the testers presented make O(1) calls to the program that is being tested. 
Abstract-found: 1
Intro-found: 1
Reference: [ABCG] <author> S. Ar, M. Blum, B. Codenotti, P. Gemmel. </author> <title> Checking Approximate Computations over the Reals. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 786-795, </pages> <year> 1993. </year>
Reference: [BF90] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multioracle queries. </title> <booktitle> In Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer Verlag LNCS 415, </publisher> <pages> pp. </pages> <address> 37- 48, </address> <year> 1990. </year>
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Program cor-rectness checking : : : and the design of programs that check their work. </title>
Reference-contexts: T f should be different from p, as defined in <ref> [BK89] </ref>, and as efficient as possible [BLR90].
Reference: [BLR90] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> J. Comp. Sys. Sci. </journal> <volume> Vol. 47, No. </volume> <pages> 3, </pages> <note> December 1993 (special issue on STOC 1990). </note>
Reference-contexts: 1 Introduction The notion of self-testing/correcting programs, as introduced in <ref> [BLR90] </ref>, provides the user with a powerful tool for attacking the problem of program correctness. Various problems have been shown to have self-testers and self-correctors; some examples can fl Cornell University. email: ergun@cs.cornell.edu. This work is supported by ONR Young Investigator Award N00014-93-1-0590 be found in [BLR90][BF90][Lip91][CL90][GLRSW91] [RS92][ABCG][RS93][Rub94][BW94]. <p> Award N00014-93-1-0590 be found in <ref> [BLR90] </ref>[BF90][Lip91][CL90][GLRSW91] [RS92][ABCG][RS93][Rub94][BW94]. In this paper we investigate the problem of self-testing multivariate linear functions, i.e., given a multivariate linear function f and a program p that purportedly computes f , we try to determine efficiently whether p computes f (x) for most inputs x. In [BLR90] the unique characterization of functions by their properties is investigated; in particular, the authors characterize some univariate linear functions and use this characterization to construct self-testers in the following manner: Let f be the univariate linear function to be computed, and p be the program to be self-tested, where x <p> In general, we need ways to keep the number of calls to the program fixed, so that the overhead introduced by the self-tester will not increase the overall asymptotic complexity of the program. One way to get around this generator bottleneck is to exploit the property of "downward self-reducibility" <ref> [BLR90] </ref>. However, self-testers that use this property have to make log n or more calls to the program, depending on the way that the problem decomposes into similar problems of smaller size. <p> Our contribution in this paper is to introduce simple and efficient techniques to get around the generator bottleneck in testing linear multivariate functions. We test linearity in a fashion similar to <ref> [BLR90] </ref>. We find a small constant number of other properties which define these functions uniquely when combined with the linearity property. <p> This last example need not be linear, similar methods can be employed for functions satisfying certain addition theorems [Rub94] [CR92]. We also present a tester that is more efficient than the existing ones for polynomial multiplication. In <ref> [BLR90] </ref> a bootstrap tester for this problem is given that makes log n calls to the program being tested. <p> Finally, we give a new self-tester for matrix multiplication. It is already known that matrix multiplication can be tested with a constant number of calls to the program using a result checker due to Freivalds [Fre79], and a boostrap self-tester for this problem is given in <ref> [BLR90] </ref> that makes O (log n) calls to the program. <p> T f should be different from p, as defined in [BK89], and as efficient as possible <ref> [BLR90] </ref>. <p> with probability 1 ffi if P r x [P (x) 6= f (x)] * 2 A self-correcting program takes a program p that computes a function f correctly on most of its inputs and turns it into a program that computes f correctly on every input with arbitrarily high probability <ref> [BLR90] </ref>, [Lip91]. A self-corrector can be used in conjunction with a self-tester to first test whether a program is correct on most of the inputs and then self-correct it so that it becomes correct with the desired probability. <p> If g is always linear and it is consistent with respect to rotate-left operations on at least 1 * of its inputs, then it is always consistent with respect to rotate-left operations. Proof: The proof for the first property is given in <ref> [BLR90] </ref>, therefore we only give a proof for the second one. <p> The last one is just a rewriting of the terms. Since they all hold with non-zero probability, the first term is equal to the last with probability 1. 2 The linearity of g can be shown using a similar proof to that in <ref> [BLR90] </ref>. These three properties uniquely define the dot product operation: Lemma 7 If g has the properties mentioned in the pre-vious two lemmas, and is always linear, then g must be the dot product function. <p> A very similar tester can be built to test polynomial multiplication as well. This tester makes O (1) calls to the program, as opposed to the O (log n) calls of the bootsrap method in <ref> [BLR90] </ref>. Such a tester would differ only in Test 3 from the one for testing dot product, due to the different behavior polynomial multiplication from dot product when the input is rotated. <p> The last test tries to establish that g is associative. This property becomes necessary in determining the function that is computed by g. It can be proven with methods similar to those in <ref> [BLR90] </ref> that if p is linear at least 1 ffi=2 fraction of the time, then g is the same as p on at least 1ffi fraction of the inputs and is always linear. program test-matrix-multiply (p,ffi; *) /* Test 1 */ count = 0; for i = 1 : : :
Reference: [BW94] <author> M. Blum, H. Wasserman. </author> <title> Program Result-Checking: A Theory of Testing Meets a Test of Theory. </title> <booktitle> In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 382-392, </pages> <year> 1994. </year>
Reference-contexts: We apply the techniques that we develop to mul-tivariate linear functions for which we previously did not have self-testers: both directions of the conversion (coefficient-point-value and point-value-coefficient) between polynomial representations in Fast Fourier Transformation (a different tester for this problem has been given independently in <ref> [BW94] </ref>), evaluation of polynomials of degree n, dot product of vectors (and therefore vector 2-norm), and the pointwise evaluation of a function on the elements of a vector. This last example need not be linear, similar methods can be employed for functions satisfying certain addition theorems [Rub94] [CR92].
Reference: [Fre79] <author> R. Freivalds. </author> <title> Fast probabilistic Algorithms. </title> <booktitle> Springer Verlag Lecture Notes in CS No.74, Mathematical Foundations of CS, </booktitle> <pages> pp. 57-69, </pages> <year> 1979. </year>
Reference-contexts: Finally, we give a new self-tester for matrix multiplication. It is already known that matrix multiplication can be tested with a constant number of calls to the program using a result checker due to Freivalds <ref> [Fre79] </ref>, and a boostrap self-tester for this problem is given in [BLR90] that makes O (log n) calls to the program.
Reference: [CL90] <author> R. Cleve, M. Luby. </author> <title> A Note on Self-Testing/Correcting Methods for Trigonometric Functions. </title> <institution> International Computer Science Institute Technical Report TR-90-032, </institution> <month> July, </month> <year> 1990. </year>
Reference: [CR92] <author> E. Castillo, M. R. Ruiz-Cobo. </author> <title> Functional Equations and Modelling in Science and Engineering, </title> <publisher> Marcel Dekker, Inc., </publisher> <year> 1992. </year>
Reference-contexts: This last example need not be linear, similar methods can be employed for functions satisfying certain addition theorems [Rub94] <ref> [CR92] </ref>. We also present a tester that is more efficient than the existing ones for polynomial multiplication. In [BLR90] a bootstrap tester for this problem is given that makes log n calls to the program being tested.
Reference: [GLRSW91] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 32-42, </pages> <year> 1991. </year>
Reference: [Lip91] <author> R. Lipton. </author> <title> New directions in testing. </title> <journal> Distributed Computing and Cryptography, DI-MACS Series in Discrete Math and Theoretical Computer Science, American Mathematical Society, </journal> <volume> 2 </volume> <pages> 191-202, </pages> <year> 1991. </year>
Reference-contexts: probability 1 ffi if P r x [P (x) 6= f (x)] * 2 A self-correcting program takes a program p that computes a function f correctly on most of its inputs and turns it into a program that computes f correctly on every input with arbitrarily high probability [BLR90], <ref> [Lip91] </ref>. A self-corrector can be used in conjunction with a self-tester to first test whether a program is correct on most of the inputs and then self-correct it so that it becomes correct with the desired probability.
Reference: [Rub94] <author> R. Rubinfeld. </author> <title> Robust Functional Equaitons with Applications to Self-Testing/Correcting. </title> <booktitle> In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 288-299, </pages> <year> 1994. </year>
Reference-contexts: This last example need not be linear, similar methods can be employed for functions satisfying certain addition theorems <ref> [Rub94] </ref> [CR92]. We also present a tester that is more efficient than the existing ones for polynomial multiplication. In [BLR90] a bootstrap tester for this problem is given that makes log n calls to the program being tested. <p> It is possible to claim a stronger result by replacing the linearity property by addition properties. An addition property is a property of a function f in the form 8x; y f (x + y) = G [f (x); f (y)] In <ref> [Rub94] </ref> it is shown that addition properties are robust. Using this fact, it is possible to extend the above result to the testing of the pointwise evaluation of a function f that satisfies an addition property on a vector.
Reference: [RS92] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proceedings of the 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pp. 23-43, </pages> <year> 1992. </year>
Reference-contexts: pick random b 2 Z n+1 p if all of the g j 's are the same then y 2 = g 1 else FAIL if y 2 = concatenate (y;0) then count = count+1 if count q then PASS else FAIL sion of Polynomial Representation This is contrasted to <ref> [RS92] </ref> which tests for a fixed polynomial whether the program computes the polynomial correctly for most inputs.
Reference: [RS93] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust Characterizations of Polynomials and their Applications to Program Testing. </title> <note> Available as IBM Research Report RC 19156 (83446) 9/9/93 and Cornell CS Tech. Report 93-1387, </note> <month> September </month> <year> 1993. </year>
References-found: 13

