URL: ftp://mancos.cs.utah.edu/papers/shlibs.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/shlibs.html
Root-URL: 
Title: Fast and Flexible Shared Libraries  
Author: Douglas B. Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg 
Affiliation: University of Utah  
Abstract: Existing implementations of shared libraries sacrifice speed (in loading, linking, and executed code), for essential flexibility (in symbol binding, address space use, and interface evolution). Modern operating systems provide the primitives needed to make the dynamic linker and loader a persistent server which lives across program invocations. This can provide speed without sacrificing flexibility. The speed is gained primarily through caching of previous work, i.e., bound and relocated executable images and libraries. The flexibility comes from the server's being an active entity, capable of adapting to changing conditions, modifying its cached state, and responding to user directives. In this paper we present a shared library implementation based on OMOS, an Object/Meta-Object Server, which provides program linking and loading facilities as a special case of generic object instantiation. We discuss the architecture of OMOS and its support of module binding primitives, which make it more flexible and powerful than existing shared library schemes. Since our design does not require any support from the compiler, it is also language-independent and highly portable. Initial performance results, on two operating systems, show an average speedup of 20% (range 0 - 56%), on short running programs. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Larry W. Allen, Harminder G. Singh, Kevin G. Wallace, and Melanie B. Weaver. </author> <title> Program loading in OSF/1. </title> <booktitle> In Proceedings of the Winter 1991 USENIX Conference, </booktitle> <pages> pages 145-160. </pages> <publisher> USENIX Association, </publisher> <month> Winter </month> <year> 1991. </year>
Reference-contexts: However, our implementation is also paying a significant startup cost, the IPC from the bootstrap loader to OMOS. This would tend to counteract the above effect. On Mach 3.0-OSF/1, we compared our implementation and the OSF/1 1.0 scheme <ref> [1] </ref>. Since different compilers 5 supported the two implementations of shared libraries, we could not ensure a completely valid shared library comparison, but we do see that the both the bootstrap and integrated exec versions of OMOS perform remarkably well, with the latter giving a 56% speedup.
Reference: [2] <institution> Apollo Computer, Inc, Chelmsford, MA. DOMAIN Software Engineering Environment (DSEE) Call Reference, </institution> <year> 1987. </year>
Reference-contexts: Since OMOS retains access to the symbol table and relocation information for loaded modules, unlinking support could be added. The CLAM system from the University of Wisconsin provides dynamic loading of C++ code in order to extend graphical user interfaces. The Apollo DSEE <ref> [2] </ref> system was a server-based system which managed sources and objects, taking advantage of caching to avoid, typically, recompilation.
Reference: [3] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw : Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <pages> 143 pp. </pages>
Reference-contexts: A subset of the graph operations comprise module operations, as defined by Bracha and Lindstrom in the language Jigsaw <ref> [3, 4] </ref>. Jigsaw was designed in in order to decompose the bundled module definition and manipulation found in programming languages, including the manipulation performed in inheritance. Conceptually, a module is a self-referential naming scope. Module operations operate on and modify the symbol bindings in modules.
Reference: [4] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, April 20-23 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: A subset of the graph operations comprise module operations, as defined by Bracha and Lindstrom in the language Jigsaw <ref> [3, 4] </ref>. Jigsaw was designed in in order to decompose the bundled module definition and manipulation found in programming languages, including the manipulation performed in inheritance. Conceptually, a module is a self-referential naming scope. Module operations operate on and modify the symbol bindings in modules.
Reference: [5] <author> Steve Chamberlain. </author> <title> The Binary File Descriptor Library. Cygnus Support, </title> <address> Palo Alto, CA, </address> <year> 1992. </year> <title> in FSF binutils distribution; Copyright Free Software Foundation. </title>
Reference-contexts: Finally, OMOS requires an understanding of the native object file format. Although this understanding has also been encapsulated in an object, it remains the most complex and messy portion of the system to port. A promising route for future portability is the GNU project's BFD <ref> [5] </ref> library. This library provides a machine and object-format independent interface to object files. It contains an array of object-format specific backends, and backends exist for most popular formats and machines. We are in the process of fitting this object file switch as a back-end to OMOS.
Reference: [6] <author> Cary A. Coutant and Michelle A. Ruscetta. </author> <title> Shared libraries for HP-UX. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 46-53, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This was due to "user" time increases in the HP-UX shared library case. Since we used the default -B deferred binding mode, the HP-UX implementation <ref> [6, 15] </ref> does lazy relocation on procedure, and to some degree, data references, this time was presumably spent doing relocations and dispatch table patching. In timing tests using the much larger codegen, OMOS shared libraries were 18% faster than HP-UX shared libraries.
Reference: [7] <author> Robert A. Gingell. </author> <title> Evolution of the SunOS programming environment. </title> <type> Unpublished report, </type> <institution> Sun Microsystems, Inc., </institution> <year> 1988. </year>
Reference-contexts: When procedure binding is dynamic, one can, in principle, substitute a different procedure at run time, or interpose a wrapper procedure around the original. This provides powerful flexibility, separating interface from implementation. This capability has been noted before <ref> [7] </ref>, as well as the similarity between objects and shared libraries [18]. However, existing implementation of shared libraries have significant problems. They offer only limited control over the flexible binding discussed above.
Reference: [8] <author> Robert A. Gingell. </author> <title> Shared libraries. </title> <journal> Unix Review, </journal> <volume> 7(8) </volume> <pages> 56-66, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: For a complete discussion, refer to the articles by Sabatella [15] and Gingell <ref> [8] </ref>, who give good overviews. These include granularity of sharing, granularity of symbol binding, code purity and the methods to achieve it, address binding, time of binding, time of loading, and version control.
Reference: [9] <author> W. Wilson Ho and Ronald A. Olsson. </author> <title> An approach to genuine dynamic linking. </title> <journal> Software| Practice and Experience, </journal> <volume> 21(4) </volume> <pages> 375-390, </pages> <month> April </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: ;; stash a copy of _malloc () for later use (copy_as "^_malloc$" "_REAL_malloc" (merge /bin/ls.o /lib/libc.o) ) ;; Merge in a new definition /lib/test_malloc.o ) As a note, execution of arbitrary blueprints can be used to implement a dynamic loading facility similar to that found in the dynamic linker, dld <ref> [9] </ref>. A client can request that new classes be loaded, which are then merged with its own implementation, allowing the new classes to refer to procedures and data structures within the client. <p> In this way, some simple forms of runtime functional substitution can be provided. In addition, some linkers provide simple symbol renaming on the command line. Packages exist, such as dld <ref> [9] </ref>, to aid programmers in the dynamic loading of code and data. These packages tend to have a procedural point of view, provide lower-level functionality than OMOS, and do not offer the control over symbol manipulation that OMOS provides.
Reference: [10] <author> S.R. Kleiman. Vnodes: </author> <title> An architecture for multiple file system types in Sun UNIX. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 238-247, </pages> <address> Atlanta, GA, </address> <month> Summer </month> <year> 1986. </year>
Reference-contexts: They currently expect to see a simply structured sequence of bytes, from which they extract the few portions of interest. When such a program open ()'s a file, it would make little sense for OMOS (integrated with the operating system, e.g. as a Virtual File System <ref> [10] </ref>) to pass it an entire byte stream, only to have the program discard the majority of the data.
Reference: [11] <author> John Kohl and Carol Paxson. </author> <title> How well do SunOS shared libraries work? Unpublished report, </title> <institution> Computer Science Division, University of California at Berkeley, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The working set sizes of programs increase, because the library functions an application uses are scattered across a large set of pages with other, unused functions. Memory savings can be minimal, at least with with small libraries, due to the size of the dispatch tables <ref> [11] </ref>. In general, the memory savings from shared libraries are probably more significant in a multi-user time-shared system than in the dedicated workstation environment common today, though there are no good measurements of this. 2.2 Issues The traditional issues in shared library design and implementation are well recognized. <p> For small programs, shared library dispatch tables can account for a surprising portion of program size. (Initial measurements of the SunOS implementation have shown that for small programs (e.g. ls) and libraries (libc), more memory is used for dispatch tables than is saved in library code <ref> [11] </ref>.) In addition, the self-contained shared library scheme can use absolute addressing modes to reference data, which has particular performance benefits, important on CISC machines but also relevant to RISC architectures. Use of the OMOS constraint system does not preclude the use of position-independent code, of course.
Reference: [12] <author> Gary Lindstrom and Robert R. Kessler. </author> <title> Mach Shared Objects. </title> <booktitle> In Proceedings Software Technology Conference, </booktitle> <pages> pages 279-280, </pages> <address> Los Angeles, CA, </address> <month> April </month> <year> 1992. </year> <note> DARPA SISTO. </note>
Reference-contexts: The meta-object specification may either be the name of a meta-object found within the OMOS namespace, or an arbitrary blueprint to be executed by OMOS. This invocation mechanism is being used to load class methods in a project building a portable, persistent object management system on Unix <ref> [12] </ref>. 2 This is the invocation method we used to gather timings on HP-UX. 8 ;; ;; malloc () -&gt; malloc'() ;; (hide "_REAL_malloc" (merge ;; Get rid of the old definition (restrict "^_malloc$" ;; stash a copy of _malloc () for later use (copy_as "^_malloc$" "_REAL_malloc" (merge /bin/ls.o /lib/libc.o) )
Reference: [13] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | an object server for program execution. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: As indicated, m-graphs are composed of nodes which may contain graph meta-objects, or fragments. The complete set of graph operators defined in OMOS is described in <ref> [13] </ref>. The graph operators important to this discussion include: Merge: binds the symbol definitions found in one operand to the references found in another. Multiple definitions of a symbol constitutes an error. Override: merges two operands, resolving conflicting bindings (multiple definitions) in favor of the second operand.
Reference: [14] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proceedings of the 26th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: OMOS can automatically generate implementations that will produce monitoring data, which it will then use to derive a preferred routine order. This reordering benefits both cache performance and paging behavior. We have performed this experiment and achieved average speedups in excess of 10%, as described in <ref> [14] </ref>. 4.2 Partial-image Shared Libraries An alternative scheme for shared libraries is the partial-image shared library, which provides more convenient application debugging facilities. <p> Conversion of OMOS to use the BFD object file switch is underway. OMOS has been used to conduct experiments in automatically generating locality-of-reference optimization in running systems <ref> [14] </ref>. The basic OMOS system comprises 17,600 lines of C++ code, and uses C++ pointer overloading to implement an automatic reference counting scheme for memory management. We also have a non-server version of OMOS, called the Object File Editor (OFE).
Reference: [15] <editor> Marc Sabatella. </editor> <booktitle> Issues in shared libraries design. In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 11-24, </pages> <address> Anaheim, CA, </address> <month> Summer </month> <year> 1990. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: For a complete discussion, refer to the articles by Sabatella <ref> [15] </ref> and Gingell [8], who give good overviews. These include granularity of sharing, granularity of symbol binding, code purity and the methods to achieve it, address binding, time of binding, time of loading, and version control. <p> This was due to "user" time increases in the HP-UX shared library case. Since we used the default -B deferred binding mode, the HP-UX implementation <ref> [6, 15] </ref> does lazy relocation on procedure, and to some degree, data references, this time was presumably spent doing relocations and dispatch table patching. In timing tests using the much larger codegen, OMOS shared libraries were 18% faster than HP-UX shared libraries.
Reference: [16] <author> Marc Sabatella. </author> <title> Lazy evaluation of C++ static constructors. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(6) </volume> <pages> 29-36, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: These include granularity of sharing, granularity of symbol binding, code purity and the methods to achieve it, address binding, time of binding, time of loading, and version control. Additional issues have since surfaced, including handling languages such as C++ which present special problems such as static initializers <ref> [16] </ref>. 3 Overview of OMOS 3.1 Overview The OMOS object/meta-object server is a process which manages a database of objects and meta-objects. Objects are code fragments, data fragments, or complete programs.
Reference: [17] <author> M. Sannella, B. Freeman-Benson, J. Mahoney, and A. Borning. </author> <title> Multi-way versus one-way constraints in user interfaces: Experience with the DeltaBlue algorithm. </title> <institution> Department of Computer Science and Engineering TR-92-07-05, University of Washington, </institution> <year> 1992. </year>
Reference-contexts: Properly tuned policies would have beneficial effects on the working set sizes of programs using shared libraries. The current constraint system uses primitive criteria for making decisions about object placement. A more sophisticated constraint system, based on the University of Washington's "Delta-Blue" constraint solver <ref> [17] </ref>, has been developed in LISP and is being ported to OMOS and C++. We are planning to extend the module operations to allow discrimination between symbol references and definitions. This will allow more flexible control over binding. For example, it will then be possible to better handle recursive functions.

References-found: 17

