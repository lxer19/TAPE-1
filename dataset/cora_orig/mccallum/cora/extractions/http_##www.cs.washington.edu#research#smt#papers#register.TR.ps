URL: http://www.cs.washington.edu/research/smt/papers/register.TR.ps
Refering-URL: http://www.cs.washington.edu/research/smt/papers/registerabstract.html
Root-URL: 
Email: jlo@cs.washington.edu  
Title: Page 1 Software-Directed Register Deallocation for Simultaneous Multithreaded Processors  
Author: Jack L. Lo, Sujay S. Parekh, Susan J. Eggers, Henry M. Levy, and Dean M. Tullsen* 
Address: Box 352350  Seattle, WA 98195-2350  9500 Gilman Drive La Jolla, CA 92093-0114  
Affiliation: Dept. of Computer Science and Engineering  University of Washington  *Dept. of Computer Science and Engineering University of California, San Diego  University of Washington  
Pubnum: Technical Report #UW-CSE-97-12-01  
Abstract: This paper proposes and evaluates software techniques that increase register file utilization for simultaneous multithreading (SMT) processors. SMT processors require large register files to hold multiple thread contexts that can issue instructions, out of order, every cycle. By supporting better inter-thread sharing and management of physical registers, an SMT processor can reduce the number of registers required and can improve performance for a given register file size. Our techniques specifically target register deallocation. While out-of-order processors with register renaming are effective at knowing when a new physical register must be allocated, they are limited in knowing when physical registers can be deallocated. We propose architectural extensions that permit the compiler and operating system to (1) free registers immediately upon their last use, and (2) free registers allocated to idle thread contexts. Our results, based on detailed instruction-level simulations of an SMT processor, show that these techniques can increase performance significantly for register-intensive, multithreaded programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alverson, D. Callahan, D. Cummings, B. Koblenz, A. Porterfield, and B. Smith. </author> <title> The Tera computer system. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 16, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Consequently, hardware can only safely deallocate a physical register when it commits another instruction that redefines its associated architectural register, as shown in Figure 1. 2.2 Physical Register Organization and the Register Deallocation Problem In fine-grained multithreaded architectures like the Tera <ref> [1] </ref>, each hardware context includes Page 4 a register file for one thread, and a thread only accesses registers from its own context, as shown in Figure 2a. 1 In contrast, in an SMT processor, a single register file can be shared among all contexts (Figure 2b).
Reference: [2] <author> J. Boyle, R. Butler, T. Diaz, B. Glickfeld, E. Lusk, R. Overbeek, J. Patterson, and R. Stevens. </author> <title> Portable Programs for Parallel Processors. </title> <publisher> Holt, Rinehart, and Winston, Inc., </publisher> <year> 1987. </year>
Reference-contexts: All programs were compiled with the Multiflow trace-scheduling compiler [14] into DEC Alpha object files. (Multiflow generates high-quality code, using aggressive static scheduling for wide issue, loop unrolling, and other ILP-exposing optimizations.) The object files were then linked with our versions of the ANL <ref> [2] </ref> and SUIF runtime libraries to create executables.
Reference: [3] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Partitioned register files for VLIWs: A preliminary analysis of tradeoffs. </title> <booktitle> In 25th International Symposium on Microarchitecture, </booktitle> <pages> pages 292300, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries. Janssen and Corporaal [10], Capitanio, et al. <ref> [3] </ref>, Llosa, et al. [12], Multiflow [4], and Kiyohara, et al. [11] also investigated techniques for handling large register files, including partitioning, limited connectivity, replication, and the use of new opcodes to address an extended register file. 6 Conclusions Simultaneous multithreading has the potential to significantly increase processor utilization on wide-issue
Reference: [4] <author> R. P. Colwell, R. P. Nix, J. J. ODonnell, D. Papworth, and P. Rodman. </author> <title> A VLIW architecture for a trace scheduling compiler. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37(8):967979, </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries. Janssen and Corporaal [10], Capitanio, et al. [3], Llosa, et al. [12], Multiflow <ref> [4] </ref>, and Kiyohara, et al. [11] also investigated techniques for handling large register files, including partitioning, limited connectivity, replication, and the use of new opcodes to address an extended register file. 6 Conclusions Simultaneous multithreading has the potential to significantly increase processor utilization on wide-issue out-of-order processors, by permitting multiple threads
Reference: [5] <author> S. J. Eggers, J. S. Emer, H. M. Levy, J. L. Lo, R. L. Stamm, and D. M. Tullsen. </author> <title> Simultaneous multithreading: A platform for next-generation processors. </title> <booktitle> In IEEE Micro, </booktitle> <pages> pages 12-19, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Simultaneous multithreading (SMT) is a high-performance architectural technique that substantially improves processor performance by executing multiple instructions from multiple threads every cycle. By dynamically sharing processor resources among threads, SMT increases functional unit utilization, thereby boosting both instruction throughput for multiprogrammed workloads and application speedup for multithreaded programs <ref> [5] </ref>. Previous research has looked at the performance potential of SMT [24], as well as several Page 2 portions of its design, including instruction fetch mechanisms and cache organization [23][13]. This paper focuses on another specific design area that impacts SMTs cost-effectiveness: the organization and utilization of its register file.
Reference: [6] <author> K. I. Farkas, N. P. Jouppi, and P. Chow. </author> <title> Register file design considerations in dynamically scheduled processors. </title> <booktitle> In 2nd Annual International Symposium on High-Performance Computer Architecture, </booktitle> <pages> pages 4051, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Because only one register window can be active at any time, the density of the register file can be increased by overlaying multiple register cells so that they share wires. Several papers have investigated register lifetimes and other register issues. Farkas, et al. <ref> [6] </ref> 264 regs288 regs320 regs352 regs 0.0 100.0 swim 264 regs288 regs320 regs352 regs 0.0 200.0 hydro2d 264 regs288 regs320 regs352 regs 0.0 100.0 Execution cycles (millions) applu 264 regs288 regs320 regs352 regs 0.0 100.0 tomcatv the larger and smaller cache sizes.
Reference: [7] <author> M. Franklin and G. Sohi. </author> <title> Register traffic analysis for streamlining inter-operation communication in fine-grained parallel processors. </title> <booktitle> In 25th International Symposium on Microarchitecture, </booktitle> <pages> pages 236245, </pages> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: They also characterized the lifetime of register values, by identifying the number of live register values present in various stages of the renaming process. Franklin and Sohi <ref> [7] </ref> and Lozano and Gao [15] found that register values have short lifetimes, and often do not need to be committed to the register file.
Reference: [8] <author> L. Gwennap. </author> <title> Digital 21264 sets new standard. </title> <type> Microprocessor Report, </type> <pages> pages 1116, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Dependences are broken by dynamically aliasing each defined architectural register to a different physical register, enabling formerly dependent instructions to be executed in parallel. SMT assumes a register mapping scheme similar to that used in the DEC 21264 <ref> [8] </ref> and MIPS R10000 [27]. The register renaming hardware is responsible for three primary functions: (1) physical register allocation, (2) register operand renaming, and (3) register deallocation. Physical register allocation occurs on demand.
Reference: [9] <author> M. W. Hall, J. M. Anderson, S. P. Amarasinghe, B. R. Murphy, S.-W. Liao, E. Bugnion, and M. S. Lam. </author> <title> Maximizing multiprocessor performance with the SUIF compiler. </title> <journal> IEEE Computer, </journal> <volume> 29(12):8489, </volume> <month> December </month> <year> 1996. </year>
Reference-contexts: The SUIF compiler <ref> [9] </ref> automatically parallelized the SPEC benchmarks into multithreaded C code; the SPLASH-2 programs were already explicitly parallelized by the programmer.
Reference: [10] <author> J. Janssen and H. Corporaal. </author> <title> Partitioned register files for TTAs. </title> <booktitle> In 28th International Symposium on Mi-croarchitecture, </booktitle> <pages> pages 303312, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries. Janssen and Corporaal <ref> [10] </ref>, Capitanio, et al. [3], Llosa, et al. [12], Multiflow [4], and Kiyohara, et al. [11] also investigated techniques for handling large register files, including partitioning, limited connectivity, replication, and the use of new opcodes to address an extended register file. 6 Conclusions Simultaneous multithreading has the potential to significantly increase
Reference: [11] <author> T. Kiyohara, S. Mahlke, W. Chen, R. Bringmann, R. Hank, S. Anik, and W.W. Hwu. </author> <title> Register connection: A new approach to adding registers into instruction set architectures. </title> <booktitle> In 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 247256, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries. Janssen and Corporaal [10], Capitanio, et al. [3], Llosa, et al. [12], Multiflow [4], and Kiyohara, et al. <ref> [11] </ref> also investigated techniques for handling large register files, including partitioning, limited connectivity, replication, and the use of new opcodes to address an extended register file. 6 Conclusions Simultaneous multithreading has the potential to significantly increase processor utilization on wide-issue out-of-order processors, by permitting multiple threads to issue instructions to the
Reference: [12] <author> J. Llosa, M. Valero, and E. Ayguade. </author> <title> Non-consistent dual register files to reduce register pressure. </title> <booktitle> In 1st Annual International Symposium on High-Performance Computer Architecture, </booktitle> <pages> pages 2231, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries. Janssen and Corporaal [10], Capitanio, et al. [3], Llosa, et al. <ref> [12] </ref>, Multiflow [4], and Kiyohara, et al. [11] also investigated techniques for handling large register files, including partitioning, limited connectivity, replication, and the use of new opcodes to address an extended register file. 6 Conclusions Simultaneous multithreading has the potential to significantly increase processor utilization on wide-issue out-of-order processors, by permitting
Reference: [13] <author> J. L. Lo, S. J. Eggers, J. S. Emer, H. M. Levy, R. L. Stamm, and D. M. Tullsen. </author> <title> Converting thread-level parallelism to instruction-level parallelism via simultaneous multithreading. </title> <journal> In ACM Transactions on Computer and Systems, </journal> <volume> 15(3) </volume> <pages> 322-354, </pages> <month> August </month> <year> 1997. </year>
Reference: [14] <author> P. G. Lowney, S. M. Freudenberger, T. J. Karzes, W. Lichtenstein, R. P. Nix, J. S. ODonnell, and J. C. Rut-tenberg. </author> <title> The Multiflow trace scheduling compiler. </title> <journal> The Journal of Supercomputing, </journal> <volume> 7(1/2):51142, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: The SUIF compiler [9] automatically parallelized the SPEC benchmarks into multithreaded C code; the SPLASH-2 programs were already explicitly parallelized by the programmer. All programs were compiled with the Multiflow trace-scheduling compiler <ref> [14] </ref> into DEC Alpha object files. (Multiflow generates high-quality code, using aggressive static scheduling for wide issue, loop unrolling, and other ILP-exposing optimizations.) The object files were then linked with our versions of the ANL [2] and SUIF runtime libraries to create executables.
Reference: [15] <author> C. L. Lozano and G. Gao. </author> <title> Exploiting short-lived variables in superscalar processors. </title> <booktitle> In 28th International Symposium on Microarchitecture, </booktitle> <pages> pages 292302, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: They also characterized the lifetime of register values, by identifying the number of live register values present in various stages of the renaming process. Franklin and Sohi [7] and Lozano and Gao <ref> [15] </ref> found that register values have short lifetimes, and often do not need to be committed to the register file.
Reference: [16] <author> S. McFarling. </author> <title> Combining branch predictors. </title> <type> Technical Report TN-36, </type> <institution> DEC-WRL, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: branch prediction, we used a McFarling-style hybrid predictor with a 256-entry, 4-way set-associative branch target buffer, and a hybrid predictor (8k entries) that selects between a global history predictor (13 history bits) and a local predictor (a 2k-entry local history table that indexes into a 4k-entry, 2-bit local prediction table) <ref> [16] </ref>. Because of the length of the simulations, we limited our detailed simulation results to the parallel computation portion of the applications (the norm for simulating parallel applications).
Reference: [17] <author> P. R. Nuth and W. J. Dally. </author> <title> The named-state register file: Implementation and performance. </title> <booktitle> In 1st Annual International Symposium on High-Performance Computer Architecture, </booktitle> <pages> pages 413, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The compiler tries to identify an optimal number of registers for each thread, and generates code using that number. The runtime system then tries to dynamically pack the register sets from all active threads into the register file. Nuth and Dallys <ref> [17] </ref> named state register file caches register values by dynamically mapping active registers to a small, fast set of registers, while backing the full register name space in memory. To reduce the required chip area in processors with register windows, Sun designed 3-D register files [22].
Reference: [18] <author> A. R. Pleszkun and G. S. Sohi. </author> <title> The performance potential of multiple functional unit processors. </title> <booktitle> In 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 3744, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Both proposed compiler support to identify last uses and architectural mechanisms to allow the hardware to ignore writes to reduce register file traffic and the number of write ports, but neither applied these concepts to register deallocation. Pleszkun and Sohi <ref> [18] </ref> proposed a mechanism for exposing the reorder buffer to the compiler, so that it could generate better schedules and provide speculative execution. Sprangle and Patt [21] proposed a statically-defined tag ISA that exposes register renaming to the compiler and relies on basic blocks as the atomic units of work.
Reference: [19] <author> J. P. Singh, J. L. Hennessy, and A. Gupta. </author> <title> Scaling parallel programs for multiprocessors: Methodology and examples. </title> <journal> IEEE Computer, </journal> <volume> 27(7):4250, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: (1) it models todays memory hierarchies, as well as those of tomorrows low-cost processors, such as multimedia co-processors, and (2) it provides a more appropriate ratio between data set and cache size, modeling programs with larger data sets or data sets with less data locality than those in our benchmarks <ref> [19] </ref>. We also examined a variety of register file sizes, ranging between 264 and 352, to gauge the sensitivity of the register file management techniques to register size. With more than 352 registers, other processor resources, such as the instruction queues, become performance bottlenecks.
Reference: [20] <institution> Standard Performance Evaluation Council. </institution> <type> SPEC CPU 95 Technical Manual. </type> <month> August </month> <year> 1995. </year>
Reference-contexts: across all contexts. (b) (c) Thread 1 Thread 2 Thread 4Thread 3 Renaming registers Architectural registers Page 5 3 Methodology for the Experiments We have defined several register file management techniques devised to compensate for conservative register deallocation, and evaluated them using instruction-level simulation of applications from the SPEC 95 <ref> [20] </ref> and SPLASH-2 [26] benchmark suites (Table 1). The SUIF compiler [9] automatically parallelized the SPEC benchmarks into multithreaded C code; the SPLASH-2 programs were already explicitly parallelized by the programmer.
Reference: [21] <author> E. Sprangle and Y. Patt. </author> <title> Facilitating superscalar processing via a combined static/dynamic register renaming scheme. </title> <booktitle> In 27th International Symposium on Microarchitecture, </booktitle> <pages> pages 143147, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Pleszkun and Sohi [18] proposed a mechanism for exposing the reorder buffer to the compiler, so that it could generate better schedules and provide speculative execution. Sprangle and Patt <ref> [21] </ref> proposed a statically-defined tag ISA that exposes register renaming to the compiler and relies on basic blocks as the atomic units of work. Part of the register file is used for storing basic block effects, and the rest handles values that are live across basic block boundaries.
Reference: [22] <author> M. Tremblay, B. Joy, and K. Shin. </author> <title> A three dimensional register file for superscalar processors. </title> <booktitle> In Hawaii International Conference on System Sciences, </booktitle> <pages> pages 191201, </pages> <month> January </month> <year> 1995. </year> <pages> Page 17 </pages>
Reference-contexts: Nuth and Dallys [17] named state register file caches register values by dynamically mapping active registers to a small, fast set of registers, while backing the full register name space in memory. To reduce the required chip area in processors with register windows, Sun designed 3-D register files <ref> [22] </ref>. Because only one register window can be active at any time, the density of the register file can be increased by overlaying multiple register cells so that they share wires. Several papers have investigated register lifetimes and other register issues.
Reference: [23] <author> D. M. Tullsen, S. J. Eggers, J. S. Emer, H. M. Levy, J. L. Lo, and R. L. Stamm. </author> <title> Exploiting choice: Instruction fetch and issue on an implementable simultaneous multithreading processor. </title> <booktitle> In 23rd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 191202, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The register file contains register state for all processor-resident threads and consequently requires two additional pipeline stages for accessing it (one each for reading and writing). (See <ref> [23] </ref> for more details.) 2.1 Register Renaming and the Register Deallocation Problem Register renaming eliminates false (output and anti-) dependences that are introduced when the compilers register allocator assigns an arbitrary number of pseudo-registers to the limited number of architectural registers in the instruction set architecture.
Reference: [24] <author> D. M. Tullsen, S. J. Eggers, and H. M. Levy. </author> <title> Simultaneous multithreading: Maximizing on-chip parallelism. </title> <booktitle> In 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 392403, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: By dynamically sharing processor resources among threads, SMT increases functional unit utilization, thereby boosting both instruction throughput for multiprogrammed workloads and application speedup for multithreaded programs [5]. Previous research has looked at the performance potential of SMT <ref> [24] </ref>, as well as several Page 2 portions of its design, including instruction fetch mechanisms and cache organization [23][13]. This paper focuses on another specific design area that impacts SMTs cost-effectiveness: the organization and utilization of its register file.
Reference: [25] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> Register relocation: Flexible contexts for multithreading. </title> <booktitle> In 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 120129, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Large register files are a concern for both multithreaded architectures and processors with register windows. Waldspurger and Weihl <ref> [25] </ref> proposed compiler and runtime support for managing multiple register sets in a register file. The compiler tries to identify an optimal number of registers for each thread, and generates code using that number.
Reference: [26] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta. </author> <title> The SPLASH-2 programs: Characterization and methodological considerations. </title> <booktitle> In 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2436, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: (b) (c) Thread 1 Thread 2 Thread 4Thread 3 Renaming registers Architectural registers Page 5 3 Methodology for the Experiments We have defined several register file management techniques devised to compensate for conservative register deallocation, and evaluated them using instruction-level simulation of applications from the SPEC 95 [20] and SPLASH-2 <ref> [26] </ref> benchmark suites (Table 1). The SUIF compiler [9] automatically parallelized the SPEC benchmarks into multithreaded C code; the SPLASH-2 programs were already explicitly parallelized by the programmer.
Reference: [27] <author> K. C. Yeager. </author> <title> The MIPS R10000 superscalar microprocessor. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 2840, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Dependences are broken by dynamically aliasing each defined architectural register to a different physical register, enabling formerly dependent instructions to be executed in parallel. SMT assumes a register mapping scheme similar to that used in the DEC 21264 [8] and MIPS R10000 <ref> [27] </ref>. The register renaming hardware is responsible for three primary functions: (1) physical register allocation, (2) register operand renaming, and (3) register deallocation. Physical register allocation occurs on demand.
References-found: 27

