URL: http://www.cs.purdue.edu/homes/spaf/spyder/TR22P.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/wwwpub/node4.html
Root-URL: http://www.cs.purdue.edu
Title: An Execution Backtracking Approach to Program Debugging  
Author: Hiralal Agrawal Richard A. DeMillo Eugene H. Spafford 
Keyword: debugging, backtracking, reverse execution.  
Address: West Lafayette, IN 47907-1398  
Affiliation: Software Engineering Research Center Department of Computer Sciences Purdue University  
Pubnum: Technical Report SERC-TR-22-P  
Abstract: An execution backtracking facility in interactive source debuggers allows users to mirror their thought processes while debugging working backwards from the location where an error is manifested and determining the conditions under which the error occurred. Such a facility also allows a user to change program characteristics and reexecute from arbitrary points within the program under examination a what-if capability. This paper describes an experimental debugger that provides such a backtracking function. We describe why the facility is useful, and why other current techniques are inadequate. We show how execution backtracking can be efficiently implemented by saving only the latest values of variables modified by a statement, and allowing backtracking only over complete program statements. We also describe how this approach relates to our work on dynamic program slicing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hiralal Agrawal and Eugene H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <booktitle> In Proceedings of the Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pages 283-299, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1988. </year> <month> 16 </month>
Reference-contexts: Programmers spend considerable amounts of their program development time debugging. Several tools are available to help them in this task, varying from hexadecimal dumps of program state at the time of failure to window and mouse-based fl An early version of this paper appeared as <ref> [1] </ref>; a revised, later version appeared as [2].
Reference: [2] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <journal> IEEE Software, </journal> <pages> pages 21-26, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Several tools are available to help them in this task, varying from hexadecimal dumps of program state at the time of failure to window and mouse-based fl An early version of this paper appeared as [1]; a revised, later version appeared as <ref> [2] </ref>. This research was supported, in part, by a grant from the Software Engineering Research Center at Purdue University, a National Science Foundation Industry/University Cooperative Research Center (NSF Grant ECD-8913133), and by National Science Foundation Grant CCR-8910306. y Authors' e-mail addresses: fha,rad,spafg@cs.purdue.edu. 1 interactive debuggers using bit-mapped displays.
Reference: [3] <author> R. M. Balzer. </author> <title> Exdams: Extendible debugging and monitoring system. </title> <booktitle> In AFIPS Proceedings, Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 567-580, </pages> <address> Montvale, New Jersey, 1969. </address> <publisher> AFIPS Press. </publisher> <pages> 17 </pages>
Reference-contexts: We believe that such a facility will be a significant addition to the debugging help provided by conventional debuggers today. Systems that have provided similar facilities in the past (e.g., <ref> [3, 4, 5, 6] </ref>) have all used a technique that, in general, may require an unbounded amount of storage. To overcome this space problem, some systems restrict execution backtracking only over a fixed number of most recent operations (see Section 4). <p> EXDAMS <ref> [3] </ref>, an interactive debugging tool developed for FORTRAN in the late 60's, provided an execution replay facility where the program to be debugged is first executed in entirety and the complete execution history is saved. Then the program is reexecuted through a playback of this tape.
Reference: [4] <author> M. V. Zelkowitz. </author> <title> Reversible Execution As a Diagnostic Tool. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> January </month> <year> 1971. </year>
Reference-contexts: We believe that such a facility will be a significant addition to the debugging help provided by conventional debuggers today. Systems that have provided similar facilities in the past (e.g., <ref> [3, 4, 5, 6] </ref>) have all used a technique that, in general, may require an unbounded amount of storage. To overcome this space problem, some systems restrict execution backtracking only over a fixed number of most recent operations (see Section 4). <p> The user, however, cannot change values of variables before resuming forward execution because EXDAMS simply replays the program behavior recorded earlier. Zelkowitz incorporated a backtracking facility within the programming language PL/1 by adding a RETRACE statement to the language <ref> [4] </ref>. With this statement, execution can be backtracked over a desired number of statements, up to a statement with a given label, or until the program state matched a certain condition.
Reference: [5] <author> Warren Teitelman and Larry Masinter. </author> <title> The Interlisp programming environment. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 25-33, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: We believe that such a facility will be a significant addition to the debugging help provided by conventional debuggers today. Systems that have provided similar facilities in the past (e.g., <ref> [3, 4, 5, 6] </ref>) have all used a technique that, in general, may require an unbounded amount of storage. To overcome this space problem, some systems restrict execution backtracking only over a fixed number of most recent operations (see Section 4). <p> Incorporating backtracking facility within a programming language, however, does not provide interactive control over backtracking required during debugging, as the user must program the RETRACE statements along with the code in advance. INTERLISP <ref> [5] </ref> and the Cornell Program Synthesizer [6] also provide facilities to undo operations. All these systems maintain a history list of operations while recording their side effects. Thus they too suffer from the same space problem discussed in Section 2.1.
Reference: [6] <author> Tim Teitelbaum and Thomas Reps. </author> <title> The Cornell Program Synthesizer: a syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: We believe that such a facility will be a significant addition to the debugging help provided by conventional debuggers today. Systems that have provided similar facilities in the past (e.g., <ref> [3, 4, 5, 6] </ref>) have all used a technique that, in general, may require an unbounded amount of storage. To overcome this space problem, some systems restrict execution backtracking only over a fixed number of most recent operations (see Section 4). <p> Incorporating backtracking facility within a programming language, however, does not provide interactive control over backtracking required during debugging, as the user must program the RETRACE statements along with the code in advance. INTERLISP [5] and the Cornell Program Synthesizer <ref> [6] </ref> also provide facilities to undo operations. All these systems maintain a history list of operations while recording their side effects. Thus they too suffer from the same space problem discussed in Section 2.1.
Reference: [7] <author> J. D. Gould. </author> <title> Some psychological evidence on how people debug computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 7(1) </volume> <pages> 151-182, </pages> <month> January </month> <year> 1975. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwards deduce the conditions under which the program produces the (incorrect) output that it did <ref> [7] </ref>.
Reference: [8] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 246-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The first given a variable and a program location, determining which statements in the program really affected the value of that variable as observed at that location, when the program is executed for the given testcase (particular input values) is referred to as Dynamic Program Slicing <ref> [8] </ref>. Spyder can automatically find dynamic slices for us. It is also possible for Spyder to help us make judicious decisions about which statements within the slice we should examine first, based on, e.g., how the program has behaved on other testcases. <p> As it is not feasible to discuss all three of these functions in one paper, we discuss the last of the above tasks here: building execution backtracking support into debuggers. The reader is referred to <ref> [8] </ref> for a preliminary discussion of dynamic program slicing. 1.2 Why Backtrack While Debugging? As we mentioned above, one logical way to go about debugging a program is to think backwards from the statement where the error is first manifested.
Reference: [9] <author> Stuart I. Feldman and Channing B. Brown. Igor: </author> <title> a system for program debugging via reversible execution. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988. </year> <journal> ACM SIGPLAN/SIGOPS. SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 112-123, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: To overcome this problem, they all use bounded history lists: as new events occur, the existing events on the list are aged, with oldest events forgotten. Thus returning to points arbitrarily far back in the execution may not be possible in these systems. 15 IGOR <ref> [9] </ref> and COPE [10] also provide execution backtracking by performing periodic checkpointing of memory pages or file blocks modified during program execution.
Reference: [10] <author> James E. Archer, Jr., Richard Conway, and Fred B. Schneider. </author> <title> User recovery and reversal in interactive systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 1-19, </pages> <month> January </month> <year> 1984. </year> <month> 18 </month>
Reference-contexts: To overcome this problem, they all use bounded history lists: as new events occur, the existing events on the list are aged, with oldest events forgotten. Thus returning to points arbitrarily far back in the execution may not be possible in these systems. 15 IGOR [9] and COPE <ref> [10] </ref> also provide execution backtracking by performing periodic checkpointing of memory pages or file blocks modified during program execution.
References-found: 10

