URL: http://www.cs.cmu.edu/~fp/courses/linear/handouts/llf.ps
Refering-URL: http://www.cs.cmu.edu/~fp/courses/linear/handouts.html
Root-URL: 
Email: filianojfpg@cs.cmu.edu  
Title: A Linear Logical Framework  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213-3891  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We present the linear type theory LLF as the for This extended abstract will appear on the proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science | LICS'96, New Brunswick, NJ, July 27-30 1996. mal basis for a conservative extension of the LF logical framework. LLF combines the expressive power of dependent types with linear logic to permit the natural and concise representation of a whole new class of deductive systems, namely those dealing with state. As an example we encode a version of Mini-ML with references including its type system, its operational semantics, and a proof of type preservation. Another example is the encoding of a sequent calculus for classical linear logic and its cut elimination theorem. LLF can also be given an operational interpretation as a logic programming language under which the representations above can be used for type inference, evaluation and cut-elimination. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: However, differently from that treatment, our ability to work uniquely with -long forms permits obtaining precisely the canonical terms that are needed for meta-representation and proof-search. The reader is invited to consult <ref> [1] </ref> for details. Since type checking for LLF is decidable, we can effectively determine if a given term is the representation of a valid derivation from a (potentially linear) object logic, which is crucial in applications of a logical framework. <p> : A: B can be viewed either as the type of the term M 0 to which the variable x should be instantiated (rule oi iapp static), or as a formula to be proved by proof-search (rule oi iapp dynamic); a complete discussion on this aspect can be found in <ref> [1] </ref>. Notice that types in Figure 3 are checked for being canonical in rules ou llam, ou ilam and oi iapp static, therefore this deduction system does not replace, but extends the full canonical system. <p> This system is sound and complete with respect to the canonical calculus outlined at the end of Section 2. Theorem u Proof: After a proper generalization to handle atomic derivability and immediate entailment, we proceed by structural induction on the derivations in the hypotheses. See <ref> [1] </ref> for details. 2 We should stress that this is just the first step towards the specification of LLF as a logic programming language. In particular, a number of non-deterministic choices remain implicit in Figure 3.
Reference: [2] <author> I. Cervesato, J. S. Hodas, and F. Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, </address> <month> Mar. </month> <title> 1996. </title> <publisher> Springer-Verlag LNAI 1050. </publisher>
Reference-contexts: LLF also maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf [15, 17]. The experience gained with linearity in the language Lolli <ref> [10, 2] </ref> applies directly to our formalism.
Reference: [3] <author> I. Cervesato and F. Pfenning. </author> <title> The linear logical framework LLF. </title> <note> Accessible on the World-Wide Web as http://www.cs.cmu.edu/~iliano/LLF/. </note>
Reference-contexts: It furthermore demonstrates how the combination of linear and dependently typed terms can be employed to mechanize the meta-theory of languages with state at a very high level of abstraction which is not achievable in other frameworks. The complete LLF code for this example can be found in <ref> [3] </ref>. There and in this section, we adopt a concrete syntax analogous to that of Elf [17]. In particular, we use -x:A-B for x : A: B, simplifying it to A -&gt; B or B &lt;- A whenever possible. <p> The cut-elimination procedure is implemented as in [18], with the difference that it operates on the representation of linear derivations as linear LLF objects, and that its correctness does not depend on side-conditions. The complete code for this example can be found in <ref> [3] </ref>. 9 Axioms I : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : <p> The remaining connectives are all definable. A direct treatment would increase the length of proofs and encodings, but not their difficulty. A straightforward extension to encompass quantifiers adapts the techniques presented in [19] and is included in <ref> [3] </ref>. We encode formulas as canonical LLF objects of type o. As in the previous example, the linear aspects of our meta-language are not needed at this level. As in [18, 19], we rely on the four-zoned sequents ; ! ; fi to capture the notion of derivability. <p> It can also be formalized in LLF as shown in <ref> [3] </ref>; we omit the straightforward details here. 6 Conclusion and Future Work In this paper, we have developed an LF -style type theory based on linear logic and provided examples of its use as a logical framework in the theories of programming languages and substructural logics. <p> Additional substantial case studies we have completed include translations between minimal linear natural deduction and sequent calculus, as well as a number of puzzles and solitaires. The interested reader may access them on the World-Wide Web at <ref> [3] </ref>. LLF conservatively extends LF with constructs from linear logic. We can think of it as the type theory freely generated from the type constructors &gt;, &, ffi, and .
Reference: [4] <author> J. L. Chirimar. </author> <title> Proof Theoretic Approach to Specification Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1995. </year>
Reference-contexts: Consequently the adequacy of the representation is difficult to prove and the formal meta-theory quickly becomes intractable. Linear logic [7] provides a view of context formulas as resources, which can be exploited to model the notion of state, as described for example in <ref> [4, 10, 12, 22] </ref>. The current proposals put the emphasis on the issue of representing imperative constructs and resource-based logics, but appear inadequate for reasoning effectively about these representations. <p> We expect to be able to adapt standard techniques [16] to our linear setting in order to handle these issues effectively. 4 An Example: Reasoning about Im perative Computations In <ref> [4] </ref> Chirimar demonstrates how Forum [12], a meta-logic based on classical linear logic, can serve as a natural meta-language for specifying UML, a version of Mini-ML with references and continuations.
Reference: [5] <author> R. Dyckhoff. </author> <title> Contraction-free sequent calculi for intu-itionistic logic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 57(3) </volume> <pages> 795-807, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: In particular, constructs based on the notion of state as found in imperative languages often escape an elegant formalization by means of these tools. Similarly, logical systems that, by definition (e.g. substructural logics) or by presentation (e.g. Dyckhoff's contraction-free intu-itionistic sequent calculus <ref> [5] </ref>), rely on destructive context reductions require awkward encodings in an in fl This work was supported by NSF Grant CCR-9303383. The second author was supported by the Alexander-von-Humboldt-Stiftung when this paper was completed, during a visit to the Department of Mathematics of the Technical University Darmstadt. tuitionistic framework.
Reference: [6] <author> A. Felty. </author> <title> Encoding dependent types in an intuitionis-tic logic. </title> <editor> In G. Huet and G. D. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 214-251. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: To our knowledge, this is the first formulation of a type theory that focuses uniquely on long forms. It was inspired by Felty's canonical LF <ref> [6] </ref>.
Reference: [7] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: The second author was supported by the Alexander-von-Humboldt-Stiftung when this paper was completed, during a visit to the Department of Mathematics of the Technical University Darmstadt. tuitionistic framework. Consequently the adequacy of the representation is difficult to prove and the formal meta-theory quickly becomes intractable. Linear logic <ref> [7] </ref> provides a view of context formulas as resources, which can be exploited to model the notion of state, as described for example in [4, 10, 12, 22]. <p> Finally, Section 6 assesses the results and outlines future work. 2 The Linear Logical Framework LLF In order to facilitate the description of LLF in the available space, we must assume that the reader is familiar with both the logical framework LF [9] and various presentations of linear logic <ref> [7, 8] </ref>. We will also sparingly take advantage of the natural extension of the Curry-Howard isomorphism to linear logic by viewing types as formulas.
Reference: [8] <author> J.-Y. Girard. </author> <title> On the unity of logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 59 </volume> <pages> 201-217, </pages> <year> 1993. </year>
Reference-contexts: Finally, Section 6 assesses the results and outlines future work. 2 The Linear Logical Framework LLF In order to facilitate the description of LLF in the available space, we must assume that the reader is familiar with both the logical framework LF [9] and various presentations of linear logic <ref> [7, 8] </ref>. We will also sparingly take advantage of the natural extension of the Curry-Howard isomorphism to linear logic by viewing types as formulas. <p> More recent works <ref> [8, 10, 18] </ref> prefer to refine it as a pair ; of multi-sets so that the sequent ; ! A is equi-provable with (!; ) ! A in the traditional formulation. The two components of ; are called the intuitionistic and the linear context, respectively. <p> LLF generalizes other formalisms based on linear logic such as Forum [12] by making linear objects available for representations, by permitting proof terms and 11 by providing linear types. Our approach is orthogonal to general logics in the style of LU <ref> [8] </ref>. A slightly unpleasant feature of the type theory in its current form, from the practical point of view, is the insistence on dealing only with pre-canonical forms.
Reference: [9] <author> R. Harper, F. Honsell, and G. Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: 1 Introduction A logical framework is a formal system designed to provide effective representations of deductive systems and their properties. Proposals based on intuitionistic logic and intuitionistic type theory, such as the logical framework LF <ref> [9] </ref>, have been widely used to study logical formalisms [19] and programming languages [11]. Unfortunately, many constructs and concepts needed in common programming practice cannot be represented in a satisfactory way in these meta-languages. <p> Finally, Section 6 assesses the results and outlines future work. 2 The Linear Logical Framework LLF In order to facilitate the description of LLF in the available space, we must assume that the reader is familiar with both the logical framework LF <ref> [9] </ref> and various presentations of linear logic [7, 8]. We will also sparingly take advantage of the natural extension of the Curry-Howard isomorphism to linear logic by viewing types as formulas. <p> U and V do not mention linear constructs, then ` U * -# - V is derivable iff ` LF U * -# - V is derivable in the LF type theory, and similarly for contexts and sig natures. 2 The proofs of these results adapt the techniques outlined in <ref> [9] </ref> for LF . However, differently from that treatment, our ability to work uniquely with -long forms permits obtaining precisely the canonical terms that are needed for meta-representation and proof-search. The reader is invited to consult [1] for details.
Reference: [10] <author> J. S. Hodas and D. Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> Extended abstract in the Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <address> Amsterdam, </address> <month> July 15-18, </month> <year> 1991. </year>
Reference-contexts: Consequently the adequacy of the representation is difficult to prove and the formal meta-theory quickly becomes intractable. Linear logic [7] provides a view of context formulas as resources, which can be exploited to model the notion of state, as described for example in <ref> [4, 10, 12, 22] </ref>. The current proposals put the emphasis on the issue of representing imperative constructs and resource-based logics, but appear inadequate for reasoning effectively about these representations. <p> LLF also maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf [15, 17]. The experience gained with linearity in the language Lolli <ref> [10, 2] </ref> applies directly to our formalism. <p> More recent works <ref> [8, 10, 18] </ref> prefer to refine it as a pair ; of multi-sets so that the sequent ; ! A is equi-provable with (!; ) ! A in the traditional formulation. The two components of ; are called the intuitionistic and the linear context, respectively. <p> With the interpretation above, LLF makes available all the connectives and quantifiers of the freely gener 4 ated fragment of the language of linear hereditary Har--rop formulas, on which the programming language Lolli is based <ref> [10] </ref>. Additionally, LLF offers the characteristic features of a type theory: higher-order functions, proof terms, and type families indexed by arbitrary objects, possibly higher-order and linear. In the rules in Figures 1-2, types and kinds are always checked using a purely intuitionistic context.
Reference: [11] <author> S. Michaylov and F. Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stock-holm, Sweden, Jan. 1991. </address> <publisher> Springer-Verlag LNAI 596. </publisher>
Reference-contexts: 1 Introduction A logical framework is a formal system designed to provide effective representations of deductive systems and their properties. Proposals based on intuitionistic logic and intuitionistic type theory, such as the logical framework LF [9], have been widely used to study logical formalisms [19] and programming languages <ref> [11] </ref>. Unfortunately, many constructs and concepts needed in common programming practice cannot be represented in a satisfactory way in these meta-languages. In particular, constructs based on the notion of state as found in imperative languages often escape an elegant formalization by means of these tools.
Reference: [12] <editor> D. Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, July 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Consequently the adequacy of the representation is difficult to prove and the formal meta-theory quickly becomes intractable. Linear logic [7] provides a view of context formulas as resources, which can be exploited to model the notion of state, as described for example in <ref> [4, 10, 12, 22] </ref>. The current proposals put the emphasis on the issue of representing imperative constructs and resource-based logics, but appear inadequate for reasoning effectively about these representations. <p> On the other hand, encoding the same problem in Miller's linear meta-logic Forum <ref> [12] </ref> would map linear sequent derivations to linear derivations in the meta-language. But since Forum lacks proof terms, no internal notation for those entities is provided and cut-elimination cannot be implemented in this manner. <p> We expect to be able to adapt standard techniques [16] to our linear setting in order to handle these issues effectively. 4 An Example: Reasoning about Im perative Computations In [4] Chirimar demonstrates how Forum <ref> [12] </ref>, a meta-logic based on classical linear logic, can serve as a natural meta-language for specifying UML, a version of Mini-ML with references and continuations. <p> This property is crucial in the proofs of adequacy theorems for encodings and also for the completeness of uniform derivations and thus the view of LLF as a logic programming language. LLF generalizes other formalisms based on linear logic such as Forum <ref> [12] </ref> by making linear objects available for representations, by permitting proof terms and 11 by providing linear types. Our approach is orthogonal to general logics in the style of LU [8].
Reference: [13] <author> D. Miller, G. Nadathur, F. Pfenning, and A. Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: A proof having both these properties is uniform, and a formalism such that every provable goal has a uniform proof is called an abstract logic programming language <ref> [13] </ref>.
Reference: [14] <author> D. Miller, G. Plotkin, and D. Pym. </author> <title> A relevant analysis of natural deduction. Talk given at the Workshop on Logical Frameworks, </title> <address> B-astad, Sweden, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: To our knowledge, this is the first linear type theory that goes beyond simple types. Our work was inspired by ideas in <ref> [14] </ref>. The paper is organized as follows. Section 2 describes LLF and presents major results in its meta-theory, such as the decidability of type-checking. Section 3 indicates that efficient proof search in the style of logic programming can be achieved in LLF .
Reference: [15] <author> F. Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: LLF also maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf <ref> [15, 17] </ref>. The experience gained with linearity in the language Lolli [10, 2] applies directly to our formalism.
Reference: [16] <author> F. Pfenning. </author> <title> Computation and deduction. </title> <note> Unpublished lecture notes, revised May 1994, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: We expect to be able to adapt standard techniques <ref> [16] </ref> to our linear setting in order to handle these issues effectively. 4 An Example: Reasoning about Im perative Computations In [4] Chirimar demonstrates how Forum [12], a meta-logic based on classical linear logic, can serve as a natural meta-language for specifying UML, a version of Mini-ML with references and continuations.
Reference: [17] <author> F. Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: LLF also maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf <ref> [15, 17] </ref>. The experience gained with linearity in the language Lolli [10, 2] applies directly to our formalism. <p> Moreover, it lays the basis for an efficient implementation strategy in which -expansion takes place in a preprocessing phase but is not required during the execution. Normalization is then simply fi-reduction. Instead, a direct extension of the current implementation techniques for LF <ref> [17] </ref> would require carrying types around in order to handle properly objects of type &gt;. To our knowledge, this is the first formulation of a type theory that focuses uniquely on long forms. It was inspired by Felty's canonical LF [6]. <p> The complete LLF code for this example can be found in [3]. There and in this section, we adopt a concrete syntax analogous to that of Elf <ref> [17] </ref>. In particular, we use -x:A-B for x : A: B, simplifying it to A -&gt; B or B &lt;- A whenever possible. We adopt -o or o- for ffi, & for & and &lt;T&gt; for &gt;.
Reference: [18] <author> F. Pfenning. </author> <title> Structural cut elimination in linear logic. </title> <type> Technical Report CMU-CS-94-222, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Since it operates linearly on the formulas appearing in it, D would be adequately represented by a term pDq in a linear -calculus; the same holds for D 0 . This problem was encoded in LF by representing sequents as types and derivations as proof terms <ref> [18] </ref>. LF is intuitionistic and therefore the linearity of pDq needed to be checked explicitly as a property of pDq, complicating the meta-theory to the extent that it became infeasible and only the cut-elimination algorithm without the linearity check was implemented. <p> More recent works <ref> [8, 10, 18] </ref> prefer to refine it as a pair ; of multi-sets so that the sequent ; ! A is equi-provable with (!; ) ! A in the traditional formulation. The two components of ; are called the intuitionistic and the linear context, respectively. <p> these are the ones we are ultimately interested in) this is irrelevant and thus the intuitionistic quantifier suffices for this and many other examples we have examined. 5 Another Example: Cut Elimination in Classical Linear Logic A structural proof of the cut-elimination theorem for classical linear logic was given in <ref> [18] </ref>, together with an LF formulation of a sequent calculus for it. Since LF is intuitionistic, the first step of this encoding consisted in representing the inference rules of this logic without concern for the restrictions they impose on the use of context formulas. <p> The novel features of our framework permit a faithful representation of the linearity constraints each inference rule imposes on its context formulas. Therefore, only correct linear derivations can be built, so that we can dispense with encoding the tedious linearity check. The cut-elimination procedure is implemented as in <ref> [18] </ref>, with the difference that it operates on the representation of linear derivations as linear LLF objects, and that its correctness does not depend on side-conditions. <p> A straightforward extension to encompass quantifiers adapts the techniques presented in [19] and is included in [3]. We encode formulas as canonical LLF objects of type o. As in the previous example, the linear aspects of our meta-language are not needed at this level. As in <ref> [18, 19] </ref>, we rely on the four-zoned sequents ; ! ; fi to capture the notion of derivability. Here, , , and fi are multisets of implicitly labeled formulas. A deductive system for this formulation, that we call LV, is given in Figure 6. <p> Here, , , and fi are multisets of implicitly labeled formulas. A deductive system for this formulation, that we call LV, is given in Figure 6. The LV sequent above is equiprov-able to the more traditional !; ! ; ?fi, as shown in <ref> [18] </ref>. This presentation isolates the intuitionistic reasoning in the outer zones of the sequents rather than restricting the structural rules of contraction and weakening to exponential formulas only. The removal of these rules is central to our proof of cut elimination. <p> In order to make this induction truly structural we have to consider linear proof terms instead of full derivations D and E ; further technical details are given in <ref> [18] </ref>. 2 We transliterate the statement of the admissibility lemma as the type families ad : (pos A -o #) -&gt; (neg A -o #) -&gt; # -&gt; type. ad!: (pos A -o #) -&gt; (neg! A -&gt; #) -&gt; # -&gt; type. ad?: (pos? A -&gt; #) -&gt; (neg A
Reference: [19] <author> F. Pfenning. </author> <title> Structural cut elimination. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of the Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 156-166, </pages> <address> San Diego, California, June 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: 1 Introduction A logical framework is a formal system designed to provide effective representations of deductive systems and their properties. Proposals based on intuitionistic logic and intuitionistic type theory, such as the logical framework LF [9], have been widely used to study logical formalisms <ref> [19] </ref> and programming languages [11]. Unfortunately, many constructs and concepts needed in common programming practice cannot be represented in a satisfactory way in these meta-languages. In particular, constructs based on the notion of state as found in imperative languages often escape an elegant formalization by means of these tools. <p> The remaining connectives are all definable. A direct treatment would increase the length of proofs and encodings, but not their difficulty. A straightforward extension to encompass quantifiers adapts the techniques presented in <ref> [19] </ref> and is included in [3]. We encode formulas as canonical LLF objects of type o. As in the previous example, the linear aspects of our meta-language are not needed at this level. <p> A straightforward extension to encompass quantifiers adapts the techniques presented in [19] and is included in [3]. We encode formulas as canonical LLF objects of type o. As in the previous example, the linear aspects of our meta-language are not needed at this level. As in <ref> [18, 19] </ref>, we rely on the four-zoned sequents ; ! ; fi to capture the notion of derivability. Here, , , and fi are multisets of implicitly labeled formulas. A deductive system for this formulation, that we call LV, is given in Figure 6.
Reference: [20] <author> E. Rohwedder. </author> <title> Verifying the Meta-Theory of Deductive Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: We can indeed capture its computational contents but, as usual in LF, the fact that our code represents a proof needs to be checked as an external property <ref> [20] </ref>. The encoding takes the form of a relation between the derivations involved in the statement of type preservation. No lemmas or auxiliary judgments regarding state are required (except in the proof of the adequacy theorem for the representation) since the linear framework provides the necessary mechanisms internally. <p> It currently appears that this would greatly complicate the type theory while it is not clear how much would be gained. We would also like to explore the possibility of automatically verifying that a signature implements a meta-proof of a meta-theorem analogously to schema-checking for LF <ref> [20] </ref>. In the more immediate future, we plan to release a concrete implementation of LLF as a conservative extension of the logic programming language Elf (which mechanizes LF ) and to augment our already rich library of LLF examples.
Reference: [21] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information & Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We denote the objects hi, hM; N i, x : A: M , ^ x : A: M and M ^N as (), (M,N), [x:A]M, [x^A]M and M^N, respectively. Whenever possible, we keep the types implicit in the binding constructs. The polymorphism in ML ref is restricted to values <ref> [21] </ref> which seems to be generally accepted as superior to SML's imperative type variables. We achieve this by distinguishing two forms of let. We use x to stand for variables and c to stand for addresses of cells which may be updated imperatively. <p> K ` E ,! w), applying inversion to obtain the typing derivations necessary to appeal to the induction hypothesis. 2 While our development differs in some aspects from the formulations and proofs given in the literature (see, for example, <ref> [21] </ref> or [23]), our main contribution is not the proof itself, but its high-level implementation. We can indeed capture its computational contents but, as usual in LF, the fact that our code represents a proof needs to be checked as an external property [20].
Reference: [22] <author> P. Wadler. </author> <title> Linear types can change the world. </title> <editor> In M. Broy and C. B. Jones, editors, </editor> <booktitle> IFIP TC 2 Working Conference on Programming Concepts and Methods, </booktitle> <pages> pages 561-581, </pages> <address> Sea of Gallilee, Israel, </address> <month> Apr. </month> <title> 1990. </title> <publisher> North-Holland. </publisher>
Reference-contexts: Consequently the adequacy of the representation is difficult to prove and the formal meta-theory quickly becomes intractable. Linear logic [7] provides a view of context formulas as resources, which can be exploited to model the notion of state, as described for example in <ref> [4, 10, 12, 22] </ref>. The current proposals put the emphasis on the issue of representing imperative constructs and resource-based logics, but appear inadequate for reasoning effectively about these representations.
Reference: [23] <author> A. K. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information & Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> November </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: K ` E ,! w), applying inversion to obtain the typing derivations necessary to appeal to the induction hypothesis. 2 While our development differs in some aspects from the formulations and proofs given in the literature (see, for example, [21] or <ref> [23] </ref>), our main contribution is not the proof itself, but its high-level implementation. We can indeed capture its computational contents but, as usual in LF, the fact that our code represents a proof needs to be checked as an external property [20].
References-found: 23

