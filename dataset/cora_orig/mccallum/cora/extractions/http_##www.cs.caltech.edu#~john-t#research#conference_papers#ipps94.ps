URL: http://www.cs.caltech.edu/~john-t/research/conference_papers/ipps94.ps
Refering-URL: http://www.cs.caltech.edu/~john-t/research/conference_papers/
Root-URL: http://www.cs.caltech.edu
Email: john-t@cs.caltech.edu  
Title: Integrating Functional and Imperative Parallel Programming: CC++ Solutions to the Salishan Problems  
Author: John Thornley 
Address: Pasadena, California 91125, USA  
Affiliation: Computer Science Department California Institute of Technology  
Abstract: We investigate the practical integration of functional and imperative parallel programming in the context of a popular sequential object-based language. As the basis of our investigation, we develop solutions to the Salishan Problems, a set of problems intended as a standard by which to compare parallel programming notations. The language that we use is CC++, C++ extended with single-assignment variables, parallel composition, and atomic functions. We demonstrate how deterministic parallel programs can be written that are identical|except for the addition of a few keywords|to sequential programs that satisfy the same specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. R. Andrews. </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1991. </year>
Reference-contexts: We are motivated by the observation that the strengths of functional and imperative programming are complementary with respect to our goal. Imperative parallel programming <ref> [1] </ref> expresses a computation as a group of cooperating concurrent processes, each with its own state and thread of control.
Reference: [2] <editor> B. K. Szymanski, editor. </editor> <booktitle> Parallel Functional Languages and Compilers. </booktitle> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <year> 1991. </year>
Reference-contexts: The strength of imperative parallel programming is in representing explicitly concurrent entities and operations from the problem specification, e.g., real-time programming. Its weakness is the complexity of expressing parallelism that is not explicit in the problem specification, solely for execution performance on multiprocessor architectures. Functional parallel programming <ref> [2] </ref> expresses a computation as a deterministic mapping from input values onto output values. Programs can be executed in any manner such that operands are evaluated before they are needed. Exploitation of parallelism is mostly the responsibility of the compiler and runtime system.
Reference: [3] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Its weakness is the difficulty of representing state, sequence, and concurrency that are explicit in the specification of many problems. This paper investigates the practical integration of the complementary strengths of functional and imperative parallel programming. Our work differs from other work that integrates functional and imperative parallel programming <ref> [3, 4] </ref>, in that we build upon an established sequential object-based language. The language that we use is CC++ [5], a simple extension of C++ [6].
Reference: [4] <author> K. M. Chandy and S. Taylor. </author> <title> An Introduction to Parallel Programming. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, Mas-sachusetts, </address> <year> 1992. </year>
Reference-contexts: Its weakness is the difficulty of representing state, sequence, and concurrency that are explicit in the specification of many problems. This paper investigates the practical integration of the complementary strengths of functional and imperative parallel programming. Our work differs from other work that integrates functional and imperative parallel programming <ref> [3, 4] </ref>, in that we build upon an established sequential object-based language. The language that we use is CC++ [5], a simple extension of C++ [6].
Reference: [5] <author> P. Carlin, M. Chandy, and C. Kesselman. </author> <title> The Compositional C++ language definition. </title> <institution> CS-TR-92-02, Computer Science Dept., California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: This paper investigates the practical integration of the complementary strengths of functional and imperative parallel programming. Our work differs from other work that integrates functional and imperative parallel programming [3, 4], in that we build upon an established sequential object-based language. The language that we use is CC++ <ref> [5] </ref>, a simple extension of C++ [6]. To evaluate the benefits of the integrated use of functional and imperative parallel programming in this context, we develop solutions to the Salishan Problems [7], a set of problems intended as a standard by which to compare parallel programming notations. <p> A complete definition of the syntax and semantics of CC++ is given by <ref> [5] </ref>. 3 The Salishan Problems The Salishan Problems are a set of four problems proposed at the 1988 Salishan High-Speed Computing Conference as a standard by which to compare parallel programming notations. Invited speakers presented solutions to the problems in eight different parallel programming languages.
Reference: [6] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1990. </year>
Reference-contexts: Our work differs from other work that integrates functional and imperative parallel programming [3, 4], in that we build upon an established sequential object-based language. The language that we use is CC++ [5], a simple extension of C++ <ref> [6] </ref>. To evaluate the benefits of the integrated use of functional and imperative parallel programming in this context, we develop solutions to the Salishan Problems [7], a set of problems intended as a standard by which to compare parallel programming notations.
Reference: [7] <author> J. T. Feo, </author> <title> editor. A Comparative Study of Parallel Programming Languages: The Salishan Problems. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1992. </year>
Reference-contexts: The language that we use is CC++ [5], a simple extension of C++ [6]. To evaluate the benefits of the integrated use of functional and imperative parallel programming in this context, we develop solutions to the Salishan Problems <ref> [7] </ref>, a set of problems intended as a standard by which to compare parallel programming notations. <p> Loosely categorized, those languages were: Ada and Occam (imperative); Haskell, Id, and Sisal (functional); C fl (data-parallel); PCN and Scheme (combined imperative and functional). The Salishan Problems and the original eight sets of solutions are published in <ref> [7] </ref>. Three of the four problems|Hamming's Problem, the Paraffins Problem, and the Skyline Matrix Problem|are functional mappings, without any con-currency in their specifications. For these problems we write deterministic functional parallel programs using sync variables, par-blocks, and parfor statements.
Reference: [8] <author> J. Thornley. </author> <title> Integrating functional and imperative parallel programming: CC++ solutions to the Salishan problems. </title> <institution> CS-TR-93-40, Computer Science Dept., Cal-ifornia Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: The complete text of our solution programs can be found in <ref> [8] </ref>. 2 The CC++ Language CC++ (Compositional C++) is C++ with six extensions. Of those extensions, we use the following four in this paper: 1. Sync Types: A variable of a sync type initially has a special undefined value, and can be assigned a value at most once.
References-found: 8

