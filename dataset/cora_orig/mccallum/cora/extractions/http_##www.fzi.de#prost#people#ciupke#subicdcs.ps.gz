URL: http://www.fzi.de/prost/people/ciupke/subicdcs.ps.gz
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Email: ciupke@fzi.de  kottmannjwalter@ira.uka.de  
Title: Object Migration in Non-Monolithic Distributed Applications  
Author: Oliver Ciupke Dietmar A. Kottmann Hans-Dirk Walter 
Address: D-76021 Karlsruhe, Germany  D-76128 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik  Fakultat fur Informatik Universitat Karlsruhe  
Abstract: Object migration is usually applied to optimize distributed monolithic systems. In this paper, we investigate the effects of using object migration in cooperative systems which consist of autonomous, independently developed components. We show that the use of migration policies which are set up with only one component in mind can have detrimental effects on the overall performance. To avoid this without changing the internal structure of the components, we introduce two novel approaches: transient placement and reduction of attachment-transitiveness. The effects of these modifications are evaluated by simulation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Achauer. </author> <title> The DOWL distributed object-oriented language. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 48-55, </pages> <month> Sep. </month> <year> 1993. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> Consequently, linguistic support for migration often contains some means to attach () objects and to detach () them. The system guarantees that objects which are attached are moved together until they are explicitly detached again. Attachment is transitive but not symmetric <ref> [1, 10] </ref>. 2.3. Migration Policies The primitives presented above can be used as building blocks for arbitrary control policies. Many languages contain primitives that imply standard policies which are simple enough to be of general use. Two prominent examples are the move () and the visit () primitives. <p> These policies are called call-by-move or call-by-visit. The prospect of more sophisticated policies arises, when the primitives can be latched to other syntactical elements. This is illustrated in Figure 1, which adapts an example from <ref> [1] </ref>. A list of objects (written as [obj]) is processed inside a loop. <p> This effect is integrated into the simulation model by blocking calls for an object that is on the move until it is reinstalled at its target node. Local invocations are processed without consuming simulation time as they are normally about 4 orders of magnitude faster than a remote action <ref> [1] </ref>. As we are only interested in the effects of our system level approaches for reinterpreting migration primitives, we only modeled the inter-object communication that occurs inside a move-block. The rest of the inter-object communication is part of the background load, just as the other applications are.
Reference: [2] <author> J.-M. Andreoli, H. Gallaire, and R. Pareschi. </author> <title> Rule-Based Object Coordination. </title> <booktitle> In Object-Based Models and Languages for Concurrent Systems, volume 924 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Some other authors also recently proposed to separate aspects of object cooperation into a separate construct, such as <ref> [2, 8, 15] </ref>. All of them define relationships between cooperating objects. In addition to those approaches, an alliance can define a distribution policy [11].
Reference: [3] <author> H. E. Bal, F. Kaashoek, and A. S. Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. </title> <journal> IEEE Trans. on Softw. Eng., </journal> <volume> 18(3) </volume> <pages> 190-205, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication <ref> [3, 4, 9] </ref>, fragmentation [13] or object-migration [1, 4, 5, 6, 7, 10, 14] to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes.
Reference: [4] <author> U. M. Borghoff. </author> <title> Catalogue of Distributed File/Operating Systems. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication <ref> [3, 4, 9] </ref>, fragmentation [13] or object-migration [1, 4, 5, 6, 7, 10, 14] to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> Controlling Migration As objects encapsulate their internal state, they are not only ideal entities for distribution, but are also movable. This observation has lead to a wealth of systems which support mobile objects as discussed in the comparative studies of Borghoff <ref> [4] </ref> and Nuttall [14]. Basically, object migration is nothing else than an unintelligent tool. Benefits can only be drawn from this tool, if it is used in a way compliant with the goal one intends to achieve.
Reference: [5] <author> R. S. Chin and S. T. Chanson. </author> <title> Distributed object-based programming systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(1) </volume> <pages> 91-124, </pages> <month> Mar. </month> <year> 1991. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> This makes objects an ideal model on which to build distributed applications. To dis-tribute objects, one needs only a level of indirection to trap remote invocations and forward them to the location of the remote object. The technical principles of such systems are well understood <ref> [5] </ref> and need no further discussion. 2.2. Controlling Migration As objects encapsulate their internal state, they are not only ideal entities for distribution, but are also movable. <p> Hence, the network load imposed by the communication of objects only contributes a small portion of the overall load. Thus, saturation effects for networks like Ethernet could be neglected. Further, we neglected the effects of different policies for locating objects, like name-server lookup <ref> [5] </ref>, forward addressing [10], broadcast [6] or immediate update [7]. All in all, these assumptions result in a network model in which communication cost between sedentary objects is distributed around the same mean value for all nodes.
Reference: [6] <author> P. Dasgupta, R. J. L. B. Jr., W. F. Appelbe, and U. Ramachan-dran. </author> <title> The Clouds distributed operating system. </title> <booktitle> Computer, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> Hence, the network load imposed by the communication of objects only contributes a small portion of the overall load. Thus, saturation effects for networks like Ethernet could be neglected. Further, we neglected the effects of different policies for locating objects, like name-server lookup [5], forward addressing [10], broadcast <ref> [6] </ref> or immediate update [7]. All in all, these assumptions result in a network model in which communication cost between sedentary objects is distributed around the same mean value for all nodes.
Reference: [7] <author> D. Decouchant. </author> <title> Design of a distributed object manager for the smalltalk-80 system. </title> <booktitle> In OOPSLA. ACM, </booktitle> <year> 1986. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> Thus, saturation effects for networks like Ethernet could be neglected. Further, we neglected the effects of different policies for locating objects, like name-server lookup [5], forward addressing [10], broadcast [6] or immediate update <ref> [7] </ref>. All in all, these assumptions result in a network model in which communication cost between sedentary objects is distributed around the same mean value for all nodes.
Reference: [8] <author> R. Helm, I. M. Holland, and D. Gangopadhyay. </author> <title> Contracts: Specifying behavioral compositions in object-oriented systems. </title> <booktitle> In Proc. of ECOOP/OOPSLA, </booktitle> <pages> pages 169-180, </pages> <year> 1990. </year>
Reference-contexts: Some other authors also recently proposed to separate aspects of object cooperation into a separate construct, such as <ref> [2, 8, 15] </ref>. All of them define relationships between cooperating objects. In addition to those approaches, an alliance can define a distribution policy [11].
Reference: [9] <author> P. Jalote. </author> <title> Fault Tolerance in Distributed Systems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1994. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication <ref> [3, 4, 9] </ref>, fragmentation [13] or object-migration [1, 4, 5, 6, 7, 10, 14] to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes.
Reference: [10] <author> E. H. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Trans. Com-put. Syst., </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> The list is incomplete. For a complete list see the discussion in <ref> [10] </ref>. We selected the points which are commonly regarded as being of general importance. Even from this small list one can infer that the different goals are not generally compatible. Note, for example, that availability demands dislocated objects, while performance demands collocating them. <p> Consequently, linguistic support for migration often contains some means to attach () objects and to detach () them. The system guarantees that objects which are attached are moved together until they are explicitly detached again. Attachment is transitive but not symmetric <ref> [1, 10] </ref>. 2.3. Migration Policies The primitives presented above can be used as building blocks for arbitrary control policies. Many languages contain primitives that imply standard policies which are simple enough to be of general use. Two prominent examples are the move () and the visit () primitives. <p> Hence, the network load imposed by the communication of objects only contributes a small portion of the overall load. Thus, saturation effects for networks like Ethernet could be neglected. Further, we neglected the effects of different policies for locating objects, like name-server lookup [5], forward addressing <ref> [10] </ref>, broadcast [6] or immediate update [7]. All in all, these assumptions result in a network model in which communication cost between sedentary objects is distributed around the same mean value for all nodes. <p> Again simulation confirmed our claim. In this paper we were only concerned with object migration. It seems promising to use other mechanisms as targets for reinterpreting primitives in non-monolithic environments at the system level, as was already shown for a very basic case in Emerald <ref> [10] </ref>, where migration requests for immutable objects simply create a new copy of themselves.
Reference: [11] <author> D. Kottmann, P. C. Lockemann, and H.-D. Walter. </author> <title> Multi-object cooperation in distributed object bases. </title> <type> Technical Report 16-95, </type> <institution> Fakultat fur Informatik, Universitat Karlsruhe, </institution> <year> 1995. </year>
Reference-contexts: Some other authors also recently proposed to separate aspects of object cooperation into a separate construct, such as [2, 8, 15]. All of them define relationships between cooperating objects. In addition to those approaches, an alliance can define a distribution policy <ref> [11] </ref>. The only detail of importance for the following discussion is that objects can be members of different alliances and that a primitive that controls migration can be related to only one alliance. Relating primitives unambiguously to such relationships can be achieved in all cited approaches.
Reference: [12] <author> P. C. Lockemann and H.-D. Walter. </author> <title> Object-oriented protocol hierarchies for distributed workflow systems. Theory and Application of Persistent Object Systems (TAPOS), </title> <type> 1(4), </type> <year> 1995. </year>
Reference-contexts: In consequence all objects of all this working sets are moved. To keep the migration decisions of applications reasonable, the working set that is actually moved has to be the same as the one, the migration decision is based on. In order to achieve this, we introduced in <ref> [12] </ref> the notion of an alliance. An alliance defines a dynamic relationship between a set of cooperative objects. Further, an alliance defines a cooperation-policy between a set of objects by restricting the interaction between the objects to those that contribute to the aim of the cooperation defined in the alliance.
Reference: [13] <author> M. Makpangou, Y. Gourhant, J.-P. L. Narzul, and M. Shapiro. </author> <title> Fragmented objects for distributed applications. </title> <editor> In T. L. Casavant and M. Singhal, editors, </editor> <booktitle> Readings in Distributed Computing Systems, </booktitle> <pages> pages 170-186. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation <ref> [13] </ref> or object-migration [1, 4, 5, 6, 7, 10, 14] to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes.
Reference: [14] <author> M. Nuttall. </author> <title> A brief survey of systems providing process or object migration facilities. </title> <journal> Operating Systems Review, </journal> <volume> 28(4) </volume> <pages> 64-79, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The components dynamically need different items, so the simple approach of mapping all entities statically to nodes generally decreases quality-parameters like performance or fault-tolerance. One depends on mechanisms like replication [3, 4, 9], fragmentation [13] or object-migration <ref> [1, 4, 5, 6, 7, 10, 14] </ref> to counter this decrease in performance. Because of their nature, replication and fragmentation have always been discussed in the context of parallel access from different nodes. <p> Controlling Migration As objects encapsulate their internal state, they are not only ideal entities for distribution, but are also movable. This observation has lead to a wealth of systems which support mobile objects as discussed in the comparative studies of Borghoff [4] and Nuttall <ref> [14] </ref>. Basically, object migration is nothing else than an unintelligent tool. Benefits can only be drawn from this tool, if it is used in a way compliant with the goal one intends to achieve. Hence, not the tool, but the policy for controlling the tool is the central issue.
Reference: [15] <author> D. M. Yellin and R. E. Strom. </author> <title> Interfaces, protocols, and the semi-automatic construction of software adaptors. </title> <booktitle> In OOP-SLA, </booktitle> <pages> pages 176-190, </pages> <year> 1994. </year>
Reference-contexts: Some other authors also recently proposed to separate aspects of object cooperation into a separate construct, such as <ref> [2, 8, 15] </ref>. All of them define relationships between cooperating objects. In addition to those approaches, an alliance can define a distribution policy [11].
References-found: 15

