URL: ftp://theory.lcs.mit.edu/pub/cilk/cheng-thesis.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/abstracts/cheng-thesis.html
Root-URL: 
Title: Algorithms for Data-Race Detection in Multithreaded Programs  
Author: by Guang-Ien Cheng Arthur C. Smith 
Degree: 1997 Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Master of Engineering in Electrical Engineering and Computer Science at the  c Guang-Ien Cheng, MCMXCVIII. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part. Author  Certified by Charles E. Leiserson Professor of Computer Science and Engineering Accepted by  Chairman, Department Committee on Graduate Theses  
Date: June 1998  May 22, 1998  
Affiliation: S.B., Computer Science and Engineering Massachusetts Institute of Technology,  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Barnes and P. Hut. </author> <title> A hierarchical O(N log N ) force-calculation algorithm. </title> <journal> Nature, </journal> <volume> 324 </volume> <pages> 446-449, </pages> <year> 1986. </year>
Reference-contexts: Thus, for this application, the maximum number of locks held by a thread is k = 2, and L is at most the maximum degree of any vertex. n-body: An n-body gravity simulation using the Barnes-Hut algorithm <ref> [1] </ref>. In one phase of the program, parallel threads race to build various parts of an "octtree" data structure. Each part is protected by an associated lock, and the first thread to acquire that lock builds that part of the structure.
Reference: [2] <author> Philippe Bekaert, Frank Suykens de Laet, and Philip Dutre. Renderpark, </author> <year> 1997. </year> <note> Available on the Internet from http://www.cs.kuleuven.ac./cwis/research/ graphics/RENDERPARK/. </note>
Reference-contexts: This algorithm is analogous to the typical way a hash table is accessed in parallel. For this program, we have k = L = 1. rad: A 3-dimensional radiosity renderer running on a "maze" scene. The original 75-source-file C code was developed in Belgium by Bekaert et. al. <ref> [2] </ref>. We used Cilk to parallelize its scene geometry calculations. Each surface in the scene has its own lock, as does each "patch" of the surface.
Reference: [3] <author> Guang-Ien Cheng, Mingdong Feng, Charles E. Leiserson, Keith H. Randall, and Andrew F. Stark. </author> <title> Detecting data races in Cilk programs that use locks. </title> <booktitle> In Proceedings of the Tenth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: To properly deal with atomicity, a race detection tool should only report Parts of this chapter are based on "Detecting data races in Cilk programs that use locks," a paper by the present author, Mingdong Feng, Charles E. Leiserson, Keith H. Randall, and Andrew F. Stark <ref> [3] </ref>. 1 "data races," which are determinacy races between nonatomic accesses. To eliminate a data race, a user might either prevent the accesses from running in parallel, or make them mutually exclusive. This thesis presents algorithms for detecting data races in the computations of Cilk programs containing atomicity. <p> Programs whose critical sections produce the same results independent of their execution order|i.e., programs with commutative critical sections|always produce, when running on a given input, a single computation in which an apparent race exists if and only if a feasible race exists <ref> [3] </ref>. On such "abelian" programs, the algorithms in this thesis can be used to guarantee that a program always produces the same behavior on a given input, regardless of scheduling. <p> The discussion of locks in Cilk and the fake read lock is from <ref> [3] </ref>. 9 abbreviated to show only the accesses to shared location x. Each leaf is labeled with a code fragment that accesses x, with the set of locks held during that access shown above the code fragment. procedures, which execute in parallel. <p> In this section, we see how the algorithm, while conceptually keeping track of every accesses to every location during Section 3.1 is based on joint work published in <ref> [3] </ref>. 13 an execution, actually prunes redundant entries from the shadow space to ensure that at most one entry per lock set per location is recorded. <p> Such heuristics seem to be important in the practical use of Brelly and Brelly-Shared for data-race detection. Sections 4.1 and 4.2 are based largely on joint work published in <ref> [3] </ref>. 29 4.1 The umbrella locking discipline In this section, we introduce and discuss the "umbrella locking discipline," violations of which are detected by the Brelly and Brelly-Shared algorithms (Sections 4.2 and 4.3, respectively). <p> Each vertex in the graph contains a lock. Parallel threads perform simple This chapter is based on joint work published in <ref> [3] </ref>. 43 parameters time (sec.) slowdown program input k L original All-Sets Brelly All-Sets Brelly maxflow sparse 1K 2 32 0.05 30 3 590 66 sparse 4K 2 64 0.2 484 14 2421 68 dense 256 2 256 0.2 263 15 1315 78 dense 512 2 512 2.0 7578 136 3789
Reference: [4] <author> Cilk-5.1 Reference Manual. </author> <note> Available on the Internet from http://theory.lcs. mit.edu/~cilk. </note>
Reference-contexts: To eliminate a data race, a user might either prevent the accesses from running in parallel, or make them mutually exclusive. This thesis presents algorithms for detecting data races in the computations of Cilk programs containing atomicity. Cilk <ref> [4] </ref> is a multithreaded programming language based on C being developed at MIT's Lab for Computer Science. Linguistically, it adds to C [14] a "spawn" command, which creates subprocedures that execute in parallel, and a "sync" command, which forces a processor to wait for all spawned subprocedures to complete. <p> In reality, of course, each algorithm runs a computation just once, with per-location information being kept in the shadow spaces independently. 11 Locks in Cilk Release 5.1 of Cilk <ref> [4] </ref> provides the user with mutual-exclusion locks, including the command Cilk lock to acquire a specified lock and Cilk unlock to release a currently held lock. Any number of locks may be held simultaneously, and locks can be acquired and released however the user likes.
Reference: [5] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Each part is protected by an associated lock, and the first thread to acquire that lock builds that part of the structure. As the program never holds more than one lock at a time, we have k = L = 1. bucket: A bucket sort <ref> [5, Section 9.4] </ref>. Parallel threads acquire the lock associated with a bucket before adding elements to it. This algorithm is analogous to the typical way a hash table is accessed in parallel. <p> During the serial depth-first execution of a program on a specific input, the Review-Guards algorithm maintains the set of currently guarded memory blocks in the global variable current-blocks, which can be implemented as a red-black tree <ref> [5, Chapter 14] </ref> indexed by the start addresses of the memory blocks, allowing memory blocks to be inserted and deleted efficiently.
Reference: [6] <author> Anne Dinning and Edith Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the Second ACM SIG-PLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [7] <author> Anne Dinning and Edith Schonberg. </author> <title> Detecting access anomalies in programs with critical sections. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 85-96. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23]. <p> The algorithms presented in this thesis detect data races dynamically, and can 5 be used to create either post-mortem or on-the-fly debugging tools. (For convenience, we will describe them as on-the-fly algorithms.) In previous work, Dinning and Schonberg's "lock-covers" algorithm <ref> [7] </ref> also detects all data races in a computation. Our All-Sets algorithm improves the lock-covers algorithm by generalizing the data structures and techniques from the original Non-determinator to produce better time and space bounds.
Reference: [8] <author> Perry A. Emrath, Sanjoy Ghosh, and David A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 580-588, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Checking every possible control-flow of an arbitrary program is intractable, however, so most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [8, 12, 16, 19] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [9] <author> Mingdong Feng and Charles E. Leiserson. </author> <title> Efficient detection of determinacy races in Cilk programs. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 1-11, </pages> <address> Newport, Rhode Island, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23]. <p> A thread is a maximal sequence of instructions not containing any parallel command. Threads may contain normal C function calls, since all normal C code is executed serially, but not spawns of Cilk This chapter's discussion of Cilk computations and the SP-bags algorithm are based on <ref> [9] </ref>, which contains a fuller treatment of the material only summarized here. The discussion of locks in Cilk and the fake read lock is from [3]. 9 abbreviated to show only the accesses to shared location x. <p> The series relation is transitive. It is sometimes possible to infer the series/parallel relationship between two threads based on the relation of the two threads to a common third thread. The following lemmas, proved in <ref> [9] </ref>, show how to do so in two important cases. They will be used throughout the proofs of correctness for the algorithms in this thesis. <p> If e 1 k e 2 and e 2 k e 3 , then e 1 k e 3 . The Nondeterminator and the SP-bags algorithm The race-detection algorithms in this thesis are based on the the SP-bags algorithm used in the Nondeterminator tool <ref> [9] </ref>, which efficiently finds determinacy races (as opposed to data races) in Cilk programs. SP-bags is the fastest published determinacy-race detection algorithm that finds a determinacy race in a computation if and only if one exists. <p> Not shown are the updates to H, the set of currently held set of locks, which occur whenever locks are acquired or released. To determine whether the currently executing thread is in series or parallel with previously executed threads, Brelly uses the SP-bags data structure from <ref> [9] </ref>. is associated with the entry of a lock in locks [l] for some location l; no tag is associated with a lock globally, across all locations. <p> The logic for Review-Guards-Shared is shown in Figure 6-4. Lines 3-6 of Read and lines 3-7 of Write exactly mirror the read and write logic in SP-bags (see <ref> [9] </ref>). The logic for entering and exiting guard statements is exactly as in the original Review-Guards algorithm (Figure 6-2), except that in lines 4-5 of Enter-Guard, the inside-reader [l] and insider-writer [l] fields are reset to the ID of the initial thread. <p> That it correctly finds data races between guarded accesses that share the same instance of a guard address follows from the correctness SP-bags (see <ref> [9] </ref>), and the fact that Review-Guards-Shared performs SP-bags's logic for a location l within each guard statement that protects l. Theorem 6.6 Consider a Cilk program with guard statements that runs serially on a given input in T time using V shared memory locations.
Reference: [10] <author> Yaacov Fenster. </author> <title> Detecting parallel access anomalies. </title> <type> Master's thesis, </type> <institution> Hebrew University, </institution> <month> March </month> <year> 1998. </year> <month> 69 </month>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [11] <author> Andrew V. Goldberg and Robert E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 136-146, </pages> <address> Berkeley, California, </address> <month> 28-30 May </month> <year> 1986. </year>
Reference-contexts: In order to compare our experimental results with the theoretical bounds, we characterize our four test programs in terms of the parameters k and L, not counting the implicit fake r-lock used by the detection algorithms: maxflow: A maximum-flow code based on Goldberg's push-relabel method <ref> [11] </ref>. Each vertex in the graph contains a lock.
Reference: [12] <author> David P. Helmbold, Charles E. McDowell, and Jian-Zhong Wang. </author> <title> Analyzing traces with anonymous synchronization. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II70-II77, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Checking every possible control-flow of an arbitrary program is intractable, however, so most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [8, 12, 16, 19] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [13] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: a Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: The memory semantics of user locks is stronger, requiring all modified locations within a critical section to be updated between parallel threads, so lock swap is atomic and correct. 4 It is true that on a hardware shared 4 The use of locks typically requires at least release consistency <ref> [13, p. 716] </ref>, in which memory 52 memory machine, the implementation we have suggested for guard statements would likely result in an atomic guard swap as well, since a fast memory barrier can be used to update all memory after critical sections, but this would be an accident of the implementation,
Reference: [14] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: This thesis presents algorithms for detecting data races in the computations of Cilk programs containing atomicity. Cilk [4] is a multithreaded programming language based on C being developed at MIT's Lab for Computer Science. Linguistically, it adds to C <ref> [14] </ref> a "spawn" command, which creates subprocedures that execute in parallel, and a "sync" command, which forces a processor to wait for all spawned subprocedures to complete.
Reference: [15] <author> John Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proceedings of Supercomputing'91, </booktitle> <pages> pages 24-33. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [16] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the 1988 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 135-144, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Checking every possible control-flow of an arbitrary program is intractable, however, so most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [8, 12, 16, 19] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [17] <author> Sang Lyul Min and Jong-Deok Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 235-244, </pages> <address> Palo Alto, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol <ref> [17, 23] </ref>.
Reference: [18] <author> Greg Nelson, K. Rustan M. Leino, James B. Saxe, and Raymie Stata. </author> <title> Extended static checking home page, </title> <note> 1996. Available on the Internet from http://www.research.digital.com/SRC/esc/Esc.html. </note>
Reference-contexts: Related work Since race detection is a major concern in parallel debugging, and locking is a common form of providing atomicity, automatic data-race detection in programs with locks has been studied extensively. Static race detectors <ref> [18] </ref> can sometimes determine whether a program will ever produce a data race when run on all possible inputs.
Reference: [19] <author> Robert H. B. Netzer and Sanjoy Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with post/wait synchronization. </title> <booktitle> In Proceedings of the 1992 International Conference on Parallel Processing, </booktitle> <address> St. Charles, Illinois, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Checking every possible control-flow of an arbitrary program is intractable, however, so most race detectors are dynamic tools in which potential races are detected at runtime by executing the program on a given input. Some dynamic race detectors perform a post-mortem analysis based on program execution traces <ref> [8, 12, 16, 19] </ref>, while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [20] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, pages II: </booktitle> <pages> 93-97, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: An apparent data race between two threads in a given computation might be infeasible, because the computation itself may change if the threads are scheduled in a different order. Since the problem of finding feasible data races exactly is intractable <ref> [20] </ref>, attention has naturally focused on the easier (but still difficult) problem of finding apparent data races. <p> But the chief value of our guarantees|the if-and-only-if correctness proofs of our algorithms|is that they are suggestive. We know we cannot expect program verification: finding feasible data races exactly is NP-hard <ref> [20] </ref>. But there may be a via media between intractable problems and merely heuristic solutions.
Reference: [21] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <booktitle> 1(1) </booktitle> <pages> 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Instead they check for data races that exist in all possible schedulings of the computation generated by the serial execution of a multithreaded program on a given input. Furthermore, like most race detectors, the algorithms attempt to find, in the terminology of Netzer and Miller <ref> [21] </ref>, "apparent" data races|those that appear to occur in a computation according to the parallel control constructs|rather than "feasible" data races|those that can actually occur during program execution. The distinction arises because operations in critical sections may affect program control depending on the way threads are scheduled.
Reference: [22] <author> Itzhak Nudler and Larry Rudolph. </author> <title> Tools for the efficient development of efficient parallel programs. </title> <booktitle> In Proceedings of the First Israeli Conference on Computer Systems Engineering, </booktitle> <month> May </month> <year> 1986. </year> <month> 70 </month>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler <ref> [6, 7, 9, 10, 15, 22] </ref>, by binary rewriting [25], or by augmenting the machine's cache coherence protocol [17, 23].
Reference: [23] <author> Dejan Perkovic and Peter Keleher. </author> <title> Online data-race detection via coherency guarantees. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seattle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting [25], or by augmenting the machine's cache coherence protocol <ref> [17, 23] </ref>. <p> Our All-Sets algorithm improves the lock-covers algorithm by generalizing the data structures and techniques from the original Non-determinator to produce better time and space bounds. Perkovic and Keleher <ref> [23] </ref> offer an on-the-fly race-detection algorithm that "piggybacks" on a cache-coherence protocol for lazy release consistency.
Reference: [24] <author> Keith H. Randall. Cilk: </author> <title> Efficient Multithreaded Computing. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1998. </year>
Reference-contexts: Recall that the semantics state that only the accesses to the specifically guarded memory blocks are atomic, meaning that the guarded swap operation in guard swap is not atomic with itself since *q2 is not specifically guarded. In a distributed system with software-simulated shared memory (e.g. Distributed Cilk <ref> [24, Chapter 8] </ref>), these semantics might be implemented strictly, with the memory system ensuring consistency between parallel threads during their execution, by performing expensive memory update operations between the distributed memories, only for specifically guarded memory blocks.
Reference: [25] <author> Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas Anderson. Eraser: </author> <title> A dynamic race detector for multi-threaded programs. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Some dynamic race detectors perform a post-mortem analysis based on program execution traces [8, 12, 16, 19], while others perform an on-the-fly analysis during program execution. On-the-fly debuggers directly instrument memory accesses via the compiler [6, 7, 9, 10, 15, 22], by binary rewriting <ref> [25] </ref>, or by augmenting the machine's cache coherence protocol [17, 23]. <p> Their approach is fast (about twice the serial work, and the tool runs in parallel), but it only catches races that actually occur during a parallel execution, not those that are logically present in the computation. Savage et al. <ref> [25] </ref> originally suggested that efficient debugging tools can be developed by requiring programs to obey a locking discipline. Their Eraser tool enforces a simple discipline in which any shared variable is protected by a single lock throughout the course of the program execution.
Reference: [26] <author> Andrew F. Stark. </author> <title> Debugging multithreaded programs that incorporate user-level locks. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1998. </year>
Reference-contexts: Apparent data races due to memory publishing is common in programs operating on global linked-list and other dynamic data structures in parallel. Stark gives a thorough discussion of the problem in <ref> [26] </ref>. Stark also presents in [26] a theory of nondeterminism, in which one feature is the notion of an "abelian" program. Intuitively, a program is abelian if its critical section commute|i.e. they produce the same results regardless of the order in which they execute. <p> Apparent data races due to memory publishing is common in programs operating on global linked-list and other dynamic data structures in parallel. Stark gives a thorough discussion of the problem in <ref> [26] </ref>. Stark also presents in [26] a theory of nondeterminism, in which one feature is the notion of an "abelian" program. Intuitively, a program is abelian if its critical section commute|i.e. they produce the same results regardless of the order in which they execute.
Reference: [27] <author> Robert Endre Tarjan. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 26(4) </volume> <pages> 690-715, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: This execution order mirrors that of normal C programs: every subcom-putation that is spawned executes completely before the procedure that spawned it continues. While executing the program, SP-bags maintains an "SP-bags" data structure based on Tarjan's nearly linear-time least-common-ancestors algorithm <ref> [27] </ref>. The SP-bags data structure allows the algorithm to determine the series/parallel relationship between the currently executing thread and any previously executed thread in O (ff (V; V )) amortized time, where V is the size of shared memory.
Reference: [28] <author> Mihalis Yannakakis. </author> <title> Freedom from deadlock of safe locking policies. </title> <journal> SIAM Journal on Computing, </journal> <volume> 11(2) </volume> <pages> 391-408, </pages> <month> May </month> <year> 1982. </year> <month> 71 </month>
Reference-contexts: Are there general guidelines for programs 1 The question of the "right" locking discipline can also be asked with reference of deadlock detection. The problem of detecting deadlocks, even "apparent" deadlocks in a computation dag, is NP-hard <ref> [28] </ref>. We have investigated using locking disciplines based on the notion of umbrellas to make the problem of deadlock detection easier, with no progress.
References-found: 28

