URL: http://www.cis.ohio-state.edu/~harrold/788.12p/papers/ball.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/788.12p/readings.html
Root-URL: 
Email: tball@research.bell-labs.com  
Phone: (630)-979-4291  
Title: The Limit of Control Flow Analysis for Regression Testing  
Author: Thomas Ball 
Keyword: Regression testing, control flow analysis, coverage, profiling  
Address: 1000 E. Warrenville Rd., Room 1G-359 Naperville, IL 60566 USA  
Affiliation: Lucent Technologies, Bell Laboratories  
Abstract: Automated analyses for regression test selection (RTS) attempt to determine if a modified program, when run on a test t, will have the same behavior as an old version of the program run on test t, but without running the new program on t. RTS analyses must confront a price/performance tradeoff: a more precise analysis might be able to eliminate more tests, but could take much longer to run. We focus on the application of control flow analysis and control flow coverage, relatively inexpensive analyses, to the RTS problem. In particular, we establish strong relationships between control-flow-based RTS, deterministic finite state automata, and the intersection of regular languages. We define a strong optimality condition (edge-optimality) for RTS algorithms based on edge coverage. We reformulate Rothermel and Harrold's RTS algorithm and present three new algorithms that improve on it, culminating in an edge-optimal algorithm. Finally, we consider how the precision of RTS algorithms is affected by the type of coverage information collected. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: In P 's control flow graph G, each vertex represents a basic block of instructions and each edge represents a control transition between blocks. The translation of an abstract syntax tree representation of a procedure into its control flow graph representation is well known <ref> [1] </ref>. Since G is an executable representation of P , we will talk about executing both P and G on a test t. We now define some graph terminology that will be useful in the sequel.
Reference: [2] <author> G. Ammons, T. Ball, and J. Larus. </author> <title> Exploiting hardware performance counters with flow and context sensitive profiling. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 32(5) </volume> <pages> 85-96, </pages> <month> June </month> <year> 1997. </year> <booktitle> Proceedings of the SIG-PLAN '97 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: We consider how the path profiling technique of Am-mon/Ball/Larus (ABL) <ref> [2] </ref> applied to the graphs in Figure 6 can separate the paths p and q. The ABL algorithm decomposes a control flow graph into acyclic paths based on the backedges identified by a depth-first search from s. Suppose that v ! w is a backedge.
Reference: [3] <author> T. Ball and J. R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The above definition translates trivially into the most precise and computationally expensive CRTS algorithm: record the complete execution path of G (t ) (via code instrumentation that traces the path <ref> [3] </ref>) and compare it to the control flow graph of G 0 to determine if the path exists there.
Reference: [4] <author> S. Bates and S. Horwitz. </author> <title> Incremental program testing using program dependence graphs. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 384-396, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Static analyses for RTS come in many varieties: some examine the syntactic structure of a program [5]; others use control flow or control dependence information [10, 11, 12]; more ambitious analyses examine the def-use chains or flow dependences of a program <ref> [9, 4] </ref>. Typically, each of these analyses is more precise than the previous, but at a greater cost. A safe (conservative) RTS analysis never eliminates a test t if new (t ) has different behavior than old (t).
Reference: [5] <author> Y.-F. Chen, D. Rosenblum, and K. Vo. Testtube: </author> <title> A system for selective regression testing. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 211-222, </pages> <year> 1994. </year>
Reference-contexts: RTS analysis uses static analysis of programs old and new in combination with dynamic information (such as coverage information) collected about the execution old (t) in order to make this determination. Static analyses for RTS come in many varieties: some examine the syntactic structure of a program <ref> [5] </ref>; others use control flow or control dependence information [10, 11, 12]; more ambitious analyses examine the def-use chains or flow dependences of a program [9, 4]. Typically, each of these analyses is more precise than the previous, but at a greater cost.
Reference: [6] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: The vertex set V 00 of G 00 is defined by the fixed point of 2 In fact, G 00 is essentially an optimized version of a product automaton of G and G 0 <ref> [6] </ref>. the following recursion: S 0 = f (s; s 0 ) j Equiv (s; s 0 )g S i+1 = S i [ f (w; w 0 ) j (v; v 0 ) 2 S i ; Equiv (w; w 0 )g V 00 = S 1 [ faccept; reject
Reference: [7] <author> T. Lengauer and R. E. Tarjan. </author> <title> A fast algorithm for finding dominators in a flow graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: The algorithm requires, for each test in T , the construction of G 00 p and the set R, which takes time O (jEj jE 0 j), dominating all other steps in the algorithm. Using an extended version of the Lengauer/Tarjan immediate dominator algorithm <ref> [7] </ref>, the immediate v relation for G can be computed in near-linear time and space in the size of G.
Reference: [8] <author> R. Milner. </author> <title> Communication and concurrency. </title> <publisher> Pren-tice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: We have not yet considered how to generalize our algorithms to handle interprocedural control flow, as they done, so we are less general. The use of paths or traces of a program to decide questions of behavioral equivalence has connections to trace equivalence <ref> [8] </ref>. Two finite automata are trace equivalent if and only if they can perform exactly the same sequences of observable behavior. This is also the basis for our equivalence relation (where basic blocks and labels represent "observable behavior").
Reference: [9] <author> T. Ostrand and E. Weyuker. </author> <title> Using data flow analysis for regression testing. </title> <booktitle> In Proceedings of the 6th Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pages 233-247, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Static analyses for RTS come in many varieties: some examine the syntactic structure of a program [5]; others use control flow or control dependence information [10, 11, 12]; more ambitious analyses examine the def-use chains or flow dependences of a program <ref> [9, 4] </ref>. Typically, each of these analyses is more precise than the previous, but at a greater cost. A safe (conservative) RTS analysis never eliminates a test t if new (t ) has different behavior than old (t).
Reference: [10] <author> G. Rothermel and M. Harrold. </author> <title> A safe, efficient algorithm for regression test selection. </title> <booktitle> In Proceedings of the 1993 Conference on Software Maintenance, </booktitle> <pages> pages 358-367, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Static analyses for RTS come in many varieties: some examine the syntactic structure of a program [5]; others use control flow or control dependence information <ref> [10, 11, 12] </ref>; more ambitious analyses examine the def-use chains or flow dependences of a program [9, 4]. Typically, each of these analyses is more precise than the previous, but at a greater cost.
Reference: [11] <author> G. Rothermel and M. Harrold. </author> <title> Analyzing regression test selection techniques. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(8) </volume> <pages> 529-551, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Static analyses for RTS come in many varieties: some examine the syntactic structure of a program [5]; others use control flow or control dependence information <ref> [10, 11, 12] </ref>; more ambitious analyses examine the def-use chains or flow dependences of a program [9, 4]. Typically, each of these analyses is more precise than the previous, but at a greater cost. <p> That is, p and q are identical words (over an alphabet of basic blocks and labels). The following simple definition (a restatement of that found in <ref> [11] </ref>) precisely captures the power of CRTS: If graph G run on input t (denoted by G (t)) executes complete path p and graph G 0 con tains path p 0 identical to p, then G 0 (t ) will execute the path p 0 , thus producing the same output <p> It is clear that for any cutoff chosen, we can add another level of nesting and achieve the same effect. 6 RELATED WORK Rothermel and Harrold define a framework for comparing different regression test selection methods <ref> [11] </ref>, based on four characteristics: * Inclusiveness, the ability to choose modification re vealing tests (paths in diff (G; G 0 )); * Precision, the ability to eliminate or exclude tests that will not reveal behavioral differences (paths in inter (G; G 0 )); * Efficiency, the space and time requirements
Reference: [12] <author> G. Rothermel and M. Harrold. </author> <title> A safe, efficient regression test selection technique. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(2) </volume> <pages> 173-210, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: Static analyses for RTS come in many varieties: some examine the syntactic structure of a program [5]; others use control flow or control dependence information <ref> [10, 11, 12] </ref>; more ambitious analyses examine the def-use chains or flow dependences of a program [9, 4]. Typically, each of these analyses is more precise than the previous, but at a greater cost. <p> We will address both issues and the interactions between them. Our results are threefold: * (Section 3) Building on recent work in CRTS by Rothermel and Harrold <ref> [12] </ref>, we show a strong relationship between CRTS, deterministic finite state automata, and the intersection of regular languages. <p> Rother-mel and Harrold ran their algorithm on a set of seven small benchmarks (141-512 lines of code) and one larger benchmark (49,000 lines of code), and found that the multiply-visited vertex condition did not occur in these programs <ref> [12] </ref>. Further experimentation is clearly needed on larger and more diverse sets of programs to see how often this condition arises. 4.2 The Partial-reachability Algorithm Let us reconsider the example of Figure 1. The dotted outline in graph G 00 shows the set V 00 accept .
References-found: 12

