URL: http://www.cs.unc.edu/~zhangh/vis.ps
Refering-URL: http://www.cs.unc.edu/~zhangh/dsvb.html
Root-URL: http://www.cs.unc.edu
Email: zhs@osf.cnc.ac.cn  
Title: Order of Pixel Traversal and Parallel Volume Ray-tracing on the Distributed Shared Volume Buffer  
Author: Hansong Zhang, Shenquan Liu 
Keyword: Pixel Traversal, Parallel Volume Ray-tracing  
Address: P. O. Box 2704, Beijing 100080, P. R. China  
Affiliation: CAD Lab., Institute of Computing Technology Academia Sinica,  
Abstract: The distributed shared volume buffer (DSVB) is a software package we developed to facilitate general, parallel volume ray-tracing on networked workstations. It is internally implemented with message-passing and adopts the cache-coherent shared memory model. Thus the cache efficiency of volume data access is of utter importance to the performance of a DSVB-based ray-tracer. For a given data set, the data access behavior of a volume ray-tracer depends mostly on the way in which pixels of the image are traversed. This paper addresses the cache coherence problem and compares three kinds of pixel traversal order: one-way, two-way and along a space filling curve. Experiments show that traversing pixels along a space filling curve (e.g. a Hilbert curve) greatly enhances cache efficiency especially when size of the cache is small compared to that of the volume data, and in the meantime greatly simplifies task distribution and management. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.-L. Ma, J. S. Painter, C. D. Hansen and M. F. Krogh, </author> <title> Parallel Volume Rendering Using Binary-Swap Compositing, </title> <journal> IEEE Computer Graphics and Applications, </journal> <month> July </month> <year> 1994, </year> <pages> pp. 59-68 </pages>
Reference-contexts: So the major question for data distributed parallel ray-tracers is: what should I do if the data needed is not in the local memory? One solution is to distribute task in such a way that computation on a node need only local data <ref> [1, 3, 4, 5] </ref>. Or computation itself can be sent to the node where the requrired data reside [7]. All these approaches lead to highly specific algorithms that bear little resemblence to a serial algorithm. <p> The second type also travels row by row, but takes inverse directions on adjacent rows. This we call the two-way order. The third way of traversal is to follow a space filling curve. Let I = <ref> [0; 1] </ref>, a space filling curve is a continuous function c (t) with domain I and range I fi I. When the mapping between I and I fi I is 1-1, then the curve is simple. <p> When the mapping between I and I fi I is 1-1, then the curve is simple. A simple space filling curve establishes a one to one correspondence between a point on interval <ref> [0; 1] </ref> and a 2-D point in square [0; 1] fi [0; 1]. So, when t changes from 0 to 1, a simple space filling curve c (t) visits uniquely every point in I fi I. Here we consider only approximations of a simple space filling curve defined above. <p> When the mapping between I and I fi I is 1-1, then the curve is simple. A simple space filling curve establishes a one to one correspondence between a point on interval <ref> [0; 1] </ref> and a 2-D point in square [0; 1] fi [0; 1]. So, when t changes from 0 to 1, a simple space filling curve c (t) visits uniquely every point in I fi I. Here we consider only approximations of a simple space filling curve defined above. <p> When the mapping between I and I fi I is 1-1, then the curve is simple. A simple space filling curve establishes a one to one correspondence between a point on interval <ref> [0; 1] </ref> and a 2-D point in square [0; 1] fi [0; 1]. So, when t changes from 0 to 1, a simple space filling curve c (t) visits uniquely every point in I fi I. Here we consider only approximations of a simple space filling curve defined above. Often we call such an approximation itself a space filling curve.
Reference: [2] <author> J. P. Singh, A. Gupta and M. Levoy, </author> <title> Parallel Visualization Algorithms: Performance and Architectural Implications, </title> <booktitle> IEEE Computer, </booktitle> <month> July </month> <year> 1994, </year> <pages> pp. 59-55 </pages>
Reference-contexts: The volume data is physically distributed among machines (nodes) that participate in ray-tracing, but through the DSVB interface, the ray-tracer on each node can regard all data as local. DSVB incorporates the cache-coherent shared memory model <ref> [2] </ref>. Authors of [6] implemented a virtual memory based on software cache on Fujitu AF100, though in their case the nessesity of global data access arises from dynamic load balancing, but not from global illumination. Section 2 gives a breif description of DSVB.
Reference: [3] <author> U. Neumann, </author> <title> Parallel Volume-Rendering Algorithm Performance on Mesh-Connected Multicomputers, </title> <booktitle> Proc. Parallel Rendering Symp., ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 97-104 </pages>
Reference-contexts: So the major question for data distributed parallel ray-tracers is: what should I do if the data needed is not in the local memory? One solution is to distribute task in such a way that computation on a node need only local data <ref> [1, 3, 4, 5] </ref>. Or computation itself can be sent to the node where the requrired data reside [7]. All these approaches lead to highly specific algorithms that bear little resemblence to a serial algorithm.
Reference: [4] <author> W. M. Hsu, </author> <title> Segmented Ray Casting for Data Parallel Volume Rendering, </title> <booktitle> Proc. Parallel Rendering Symp., ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 7-14 </pages>
Reference-contexts: So the major question for data distributed parallel ray-tracers is: what should I do if the data needed is not in the local memory? One solution is to distribute task in such a way that computation on a node need only local data <ref> [1, 3, 4, 5] </ref>. Or computation itself can be sent to the node where the requrired data reside [7]. All these approaches lead to highly specific algorithms that bear little resemblence to a serial algorithm.
Reference: [5] <author> E. Camahort and Chakravarty, </author> <title> Integrating Volume Data Analysis and Rendering on Distributed Memory Architectures, </title> <booktitle> Proc. Parallel Rendering Symp., ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 23-26 </pages>
Reference-contexts: So the major question for data distributed parallel ray-tracers is: what should I do if the data needed is not in the local memory? One solution is to distribute task in such a way that computation on a node need only local data <ref> [1, 3, 4, 5] </ref>. Or computation itself can be sent to the node where the requrired data reside [7]. All these approaches lead to highly specific algorithms that bear little resemblence to a serial algorithm.
Reference: [6] <author> B. Corrie and P. Mackerras, </author> <title> Parallel Volume Rendering and Data Coherence, </title> <booktitle> Proc. Parallel Rendering Symp., ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <month> pp23-26 </month>
Reference-contexts: The volume data is physically distributed among machines (nodes) that participate in ray-tracing, but through the DSVB interface, the ray-tracer on each node can regard all data as local. DSVB incorporates the cache-coherent shared memory model [2]. Authors of <ref> [6] </ref> implemented a virtual memory based on software cache on Fujitu AF100, though in their case the nessesity of global data access arises from dynamic load balancing, but not from global illumination. Section 2 gives a breif description of DSVB.
Reference: [7] <author> D. Badouel, K. Bouatouch and T. Priol, </author> <title> Distributing Data and Control for Ray Tracing in Parallel, </title> <booktitle> IEEE Computer, </booktitle> <month> July </month> <year> 1994, </year> <pages> pp. 59-55 </pages>
Reference-contexts: Or computation itself can be sent to the node where the requrired data reside <ref> [7] </ref>. All these approaches lead to highly specific algorithms that bear little resemblence to a serial algorithm. Besides, in general volume ray-tracing (in contrast to simple ray-casting), light behaviors like reflection, refraction and shadowing are taken into account. The ray through any pixel may access any data.
Reference: [8] <author> G. Vezina, P. A. Fletcher and P. K. Robertson, </author> <title> Volume Rendering on the MasPar MP-1, </title> <booktitle> 1992 Workshop on Volume Visualization, </booktitle> <address> Boston, </address> <month> October </month> <year> 1992, </year> <pages> pp. 3-8 </pages>
Reference: [9] <author> J. Nieh and M. Levoy, </author> <title> Volume Rendering on Scalable Shared-Memory MIMD Architectures, </title> <booktitle> 1992 Workshop on Volume Visualization, </booktitle> <address> Boston, </address> <month> October </month> <year> 1992, </year> <pages> pp. 9-16 </pages>
Reference: [10] <author> M. Levoy, </author> <title> Efficient Ray Tracing of Volume Data, </title> <journal> ACM Transactions on Graphics, </journal> <month> July </month> <year> 1990, </year> <pages> pp. 245-261 </pages>
Reference-contexts: 1 Introduction Raytracing volume data can produce impressive images that help a lot in understanding the data <ref> [10, 11] </ref>. The cost of ray-tracing, however, is quite expensive both in time and in memory space. A high-quality image may take as much as hours to render. Volume data sets are typically large and get easily too large to hold in the main memory of an average workstation.
Reference: [11] <author> R. A. Drebin, L. Carpenter and P. Hanrahan, </author> <title> Volume Rendering, </title> <journal> Computer Graphics, </journal> <volume> vol. 22, </volume> <month> August </month> <year> 1988, </year> <pages> pp. 65-74 </pages>
Reference-contexts: 1 Introduction Raytracing volume data can produce impressive images that help a lot in understanding the data <ref> [10, 11] </ref>. The cost of ray-tracing, however, is quite expensive both in time and in memory space. A high-quality image may take as much as hours to render. Volume data sets are typically large and get easily too large to hold in the main memory of an average workstation.
Reference: [12] <author> R. J. Stevens, R.A.Lehar, F. H. Perston: </author> <title> Manipulation and Preservation of Multidimensional Image Data Using the Peano Scan, </title> <journal> IEEE Transaction on Pattern Analysis and Machine Intelligence, </journal> <month> May </month> <year> 1983, </year> <pages> pp. 520-526 </pages>
Reference-contexts: Intuitively, such a curve gives good coherence for any cluster of adjacent pixels on its path by the standard of (1) because of its self-entwined structure. Visiting pixels along a space filling curve has been used in image processing <ref> [12] </ref>, where typical operations occur on subregions of an image. By using a space filling curve, a 2-D subregion can be mapped to an 1-D interval.
Reference: [13] <author> L. Velho, J. Gomes, </author> <title> Digital Halftoning With Space Filling Curves, </title> <journal> Computer Graphics, </journal> <volume> Vol. 25(4), </volume> <month> July </month> <year> 1991, </year> <pages> pp. 81-90 </pages>
Reference-contexts: By using a space filling curve, a 2-D subregion can be mapped to an 1-D interval. This reduction of dimensionality lead to simplification of image processing methods. <ref> [13] </ref> used space filling curves in digital halftoning of images. 4 Task Allocation Our ray-tracer uses distributed task pools and task stealing paradigm for task allocation and dynamic load balancing. On start-up, every node obtains approximately the same number of pixels, which comprises the local task pool.
References-found: 13

