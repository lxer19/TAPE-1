URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-09-26.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Syntactic Analysis (Lecture 4 of 6) 1 A table-driven
Author: Siddhartha Chatterjee Predict(X ff) fFIRSTff f*gg S FOLLOW(X); ff 
Note: 1.1  In this case, the production X ff should be used if a 2 FOLLOW(X  FIRST(ff); otherwise:  
Date: 26 September 1995  
Abstract: Rather than have mutually recursive routines for each nonterminal, we can implement a predictive parser in a table-driven manner. This approach uses a general-purpose driver program and a parsing table that captures the necessary information about the grammar. It has the advantage that it is easier to change when the grammar is modified, since all that is required is to recompute the values in the parsing table, a task that can be automated. It has the disadvantage that an explicit parsing stack needs to be maintained. In a recursive implementation, this stack is implicitly maintained by the recursion stack. We introduced the special token $ to represent the end of the input stream. The table-driven predictive parser has four components: the input token stream w (terminated by the token $), the parsing stack, the parsing table M : N fi T ! P S ferrorg and the output stream. The stack is initialized to contain the symbols $ and S, with the S being on top of stack. The driver for the table-driven parser operates as follows. At each step, it examines the symbol X at the top of the parsing stack and the current token a. The action of the parser is completely determined by these two symbols, as follows. 3. If X is a nonterminal, the parser's action depends on the entry M (X; a) of the parsing table. If M (X; a) is the production X ::= X 1 : : : X k , then the parser pops X off the parsing stack and pushes the symbols X k through X 1 in that order, so that X 1 is now at the top of the stack. (It would also take some appropriate action such as printing the production used or extending the current parse tree.) If M (X; a) = error, the parser calls an error handling routine. The parsing table stores, for each combination of nonterminal X and terminal a, the production to be used to expand X when a is the current token in the input stream. The construction of the table is quite simple once we have computed the FIRST and FOLLOW sets. If there is a production X ::= ff, and a 2 FIRST(ff), then this production is the entry M (X; a). The only complication is if ff fl 
Abstract-found: 1
Intro-found: 1
References-found: 0

