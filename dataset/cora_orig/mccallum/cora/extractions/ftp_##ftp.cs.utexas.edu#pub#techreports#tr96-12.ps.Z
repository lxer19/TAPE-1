URL: ftp://ftp.cs.utexas.edu/pub/techreports/tr96-12.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/xguo/Research/
Root-URL: 
Email: E-mail: fpawang,xguo,ving@cs.utexas.edu,  
Phone: Phone: (512) 471-9732 Fax (512) 471-8885  
Title: A Hierarchical CPU Scheduler for Multimedia Operating Systems  
Author: Pawan Goyal, Xingang Guo, and Harrick M. Vin 
Address: Taylor Hall 2.124, Austin, TX 78712-1188  
Affiliation: Distributed Multimedia Computing Laboratory Department of Computer Sciences The University of Texas at Austin  
Abstract: The need for supporting variety of hard and soft real-time as well as best effort applications in a multimedia computing environment requires an operating system framework that: (1) enables different schedulers to be employed for different application classes, and (2) provides protection between the various classes of applications. We argue that these objectives can be achieved by hierarchical partitioning of CPU bandwidth, in which an operating system partitions the CPU bandwidth among various application classes, and each application class, in turn, partitions its allocation (potentially using a different scheduling algorithm) among its sub-classes or applications. We present Start-time Fair Queuing (SFQ) algorithm, which enables such hierarchical partitioning. We have implemented a hierarchical scheduler in Solaris 2.4. We describe our implementation, and demonstrate its suitability for multimedia operating systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Davin and A. Heybey. </author> <title> A Simulation Study of Fair Queueing and Policy Enforcement. </title> <journal> Computer Communication Review, </journal> <volume> 20(5) </volume> <pages> 23-29, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Furthermore, it is not known to have any better properties than SFQ. Self Clocked Fair Queuing (SCFQ), originally proposed in <ref> [1] </ref> and later analyzed in [4], was designed to reduce the computational complexity of fair scheduling algorithms like WFQ. It achieves efficiency over WFQ by approximating v (t) with the finish tag of the quantum in service at time t.
Reference: [2] <author> A. Demers, S. Keshav, and S. Shenker. </author> <title> Analysis and Simulation of a Fair Queueing Algorithm. </title> <booktitle> In Proceedings of ACM SIGCOMM, </booktitle> <pages> pages 1-12, </pages> <month> September </month> <year> 1989. </year> <month> 15 </month>
Reference-contexts: Most of these algorithms have been proposed for fair allocation of network bandwidth; we have modified their presentation appropriately for CPU scheduling. The earliest known fair scheduling algorithm is Weighted Fair Queuing (WFQ) <ref> [2] </ref>. WFQ was designed to emulate a hypothetical weighted round robin server in which the service received by each thread in a round is infinitesimal and proportional to the weight of the thread.
Reference: [3] <author> D. Le Gall. </author> <title> MPEG: A Video Compression Standard for Multimedia Apllications. </title> <journal> Communications of the ACM, </journal> <volume> 34(4) </volume> <pages> 46-58, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Due to inherent variations in scene complexity as well as the use of intra- and inter-frame compression techniques, processing bandwidth required for compression/decompression of frames of VBR video varies highly at multiple time-scales (see Figure 1 (b), which illustrates that successive frame decompression times for an MPEG <ref> [3] </ref> sequence can vary by a factor of 3). Furthermore, these variations are unpredictable.
Reference: [4] <author> S.J. Golestani. </author> <title> A Self-Clocked Fair Queueing Scheme for High Speed Applications. </title> <booktitle> In Proceedings of INFO-COM'94, </booktitle> <year> 1994. </year>
Reference-contexts: It has been shown in <ref> [4] </ref> that if a scheduling algorithm schedules threads in terms of quantum and guarantees that j W f (t 1 ;t 2 ) r m j H (f; m) for all intervals, then H (f; m) 1 2 ( f + m ). <p> Though WFQ is known to have bounded deviation in fairness, it is not known if the modified algorithm retains its fairness properties. * WFQ requires the computation of v (t), which, in turn, requires simulation of hypothetical server. This simulation is known to be computationally expensive <ref> [4] </ref>. In constrast, SFQ computes the start and finish tags efficiently. * As demonstrated in [12], WFQ has significantly higher unfairness than SFQ. * WFQ provides high delay to low throughput applications. <p> Furthermore, it is not known to have any better properties than SFQ. Self Clocked Fair Queuing (SCFQ), originally proposed in [1] and later analyzed in <ref> [4] </ref>, was designed to reduce the computational complexity of fair scheduling algorithms like WFQ. It achieves efficiency over WFQ by approximating v (t) with the finish tag of the quantum in service at time t.
Reference: [5] <author> P. Goyal, H. M. Vin, and H. Cheng. </author> <title> Start-time Fair Queuing: A Scheduling Algorithm for Integrated Services Packet Switching Networks. </title> <note> In Proceedings of ACM SIGCOMM'96 (to appear), </note> <month> August </month> <year> 1996. </year>
Reference-contexts: To be feasible in general purpose operating systems, the scheduling algorithm should be computationally efficient. Recently, we have developed a fair resource allocation algorithm, referred to as Start-time Fair Queuing (SFQ), that meets these requirements <ref> [5] </ref>. In the next section, we present the algorithm and describe its properties. 5 3 Start-time Fair Queuing Start-time Fair Queuing (SFQ) is a resource allocation algorithm that can be used for achieving fair CPU allocation. Before we present SFQ, let us define the notion of fair allocation. <p> SFQ achieves fair allocation of CPU regardless of variation in a server capacity and hence meets the key requirement of a scheduling algorithm for hierarchical partitioning. Specifically, in <ref> [5] </ref>, we have shown that regardless of a server behavior, SFQ guarantees that in any interval [t 1 ; t 2 ] in which two threads f and m are eligible for being scheduled, the following inequality holds: fi fi W f (t 1 ; t 2 ) r m fi <p> Let Q be the set of threads served by CPU and let P n2Q r n C where C is the capacity of the CPU. Then, SFQ provides the following throughput and delay guarantees <ref> [5] </ref>: * Throughput Guarantee: If the CPU is a FC server, then the throughput received by a thread f with weight r f is also FC with parameters: P n + r f C f (6) 4 The maximum quantum length may be known a-priori or may be enforced by a <p> WFQ then schedules quantums in the increasing order of their finish tags. WFQ has several drawbacks for scheduling CPU: * As demonstrated in <ref> [5] </ref>, WFQ does not provide fairness over variable rate servers. Since fairness over variable rate servers is crucial for supporting hierarchical partitioning, WFQ is unsuitable for a CPU scheduler in a general purpose operating system. * WFQ requires the length of the quantums to be known a priori. <p> Furthermore, it is not known to achieve fairness over variable rate servers. Finally, it has the same fairness and implementation complexity as SFQ but provides significantly larger delay guarantee than SFQ. Specifically, it increases the maximum delay of quantum q f by f <ref> [5] </ref>. Though the relationship between fair packet scheduling algorithms and fair CPU allocation was pointed out in [6], it remained largely unknown to the operating systems community. Consequently, a randomized fair algorithm, termed lottery scheduling, was proposed in [14].
Reference: [6] <author> A. Greenberg and N. </author> <title> Madras. How Fair is Fair Queuing. </title> <journal> The Journal of ACM, </journal> <volume> 39(3) </volume> <pages> 568-598, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Since interactive applications are low throughput in nature, this feature of SFQ is highly desirable for CPU scheduling. 14 Fair Queuing based on Start-time (FQS), was proposed in <ref> [6] </ref>, to make WFQ suitable for scheduling threads when quantum length may not be known a-priori. It computes start tag and finish tag of a quantum exactly as in WFQ. <p> Finally, it has the same fairness and implementation complexity as SFQ but provides significantly larger delay guarantee than SFQ. Specifically, it increases the maximum delay of quantum q f by f [5]. Though the relationship between fair packet scheduling algorithms and fair CPU allocation was pointed out in <ref> [6] </ref>, it remained largely unknown to the operating systems community. Consequently, a randomized fair algorithm, termed lottery scheduling, was proposed in [14]. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm [13].
Reference: [7] <author> K. Jeffay and D.L. Stone. </author> <title> Accounting for Interrupt Handling Costs in Dynamic Priority Task Systems. </title> <booktitle> In Proceedings of 14th IEEE Real-Time Systems Symposium Raleigh-Durham, NC, </booktitle> <pages> pages 212-221, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: To support hard and soft real-time application classes, the scheduling algorithm should provide bounds on minimum throughput and maximum delay observed by nodes. Furthermore, for the bounds to be useful, they should hold in realistic computing environments in which interrupts may be processed at the highest priority <ref> [7] </ref>. 4. To be feasible in general purpose operating systems, the scheduling algorithm should be computationally efficient. Recently, we have developed a fair resource allocation algorithm, referred to as Start-time Fair Queuing (SFQ), that meets these requirements [5].
Reference: [8] <author> M.B. Jones, P. Leach, R. Draves, and III J. Barrera. </author> <title> Support for User-Centric Modular Real-Time Resource Management in Rialto Operating System. </title> <booktitle> In Proceedings of NOSSDAV'95, </booktitle> <address> Durham, New Hampshire, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Observe that our hierarchical partitioning framework also facilitates the development of a QoS manager that allocates resources as per the QoS requirements of applications <ref> [8] </ref>. To illustrate, if an application requests hard/soft real-time service, then the QoS manager can use a deterministic/statistical admission control algorithm which utilizes the capacity allocated to hard/soft real-time classes to determine if the request can be satisfied, and if so, assign it to the appropriate partition. <p> Hence, in our implementation, a scheduler for a leaf node itself can use multiple scheduling policies. We envision our scheduling infrastructure would be used by a Quality of Service manager in a multimedia system (see Figure 3) <ref> [8] </ref>.
Reference: [9] <author> K. Lee. </author> <title> Performance Bounds in Communication Networks With Variable-Rate Links. </title> <booktitle> In Proceedings of ACM SIGCOMM'95, </booktitle> <pages> pages 126-136, </pages> <year> 1995. </year>
Reference-contexts: If the maximum rate of occurrence of interrupts and the CPU bandwidth used by the interrupts is known, the residual CPU bandwidth can be modeled as a Fluctuation Constrained (FC) server <ref> [9] </ref>. A FC server has two parameters; average rate C (instructions/s) and burstiness ffi (C) (instructions). Intuitively, an FC server, in any interval during a busy period, does at most ffi (C) less work than an equivalent constant rate server. <p> However, if distributions of the computation time requirements are known, then CPU is better modeled as Exponentially Bounded Fluctuation (EBF) server <ref> [9] </ref>. EBF server is a stochastic relaxation of FC server. Intuitively, the probability of work done by an EBF server deviating from the average rate by more than fl, decreases exponentially with fl.
Reference: [10] <author> C.L. Liu and J.W. Layland. </author> <title> Scheduling Algorithms for Multiprocessing in a Hard-Real Time Environment. </title> <journal> JACM, </journal> <volume> 20 </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Conventional schedulers like Earliest Deadline First (EDF) and Rate Monotonic Algorithm (RMA) used in hard-real time systems are suitable for such applications <ref> [10] </ref>. 2 * Soft real-time applications: These applications require an operating system to statistically guarantee QoS parameters such as maximum delay and throughput.
Reference: [11] <author> J. Nieh, J. Hanko, J. Northcutt, and G. Wall. </author> <title> SVR4UNIX Scheduler Unacceptable for Multimedia Applications. </title> <booktitle> In Proceedings of 4th International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <pages> pages 41-53, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Furthermore, no algorithm that achieves predictable allocation and protection simultaneously has a lower complexity. Although static priority algorithms have lower complexity, they have no protection and have been found to be unsatisfactory in multimedia operating systems <ref> [11] </ref>. Recall from Section 1 that a scheduling algorithm suitable for video applications should: (1) provide QoS guarantees even in presence of overload, and (2) not require computation requirements to be known precisely. <p> Figure 4 demonstrates that inspite of same user priority, the throughput received by the threads in time-sharing scheduler varies significantly thereby demonstrating it's inadequacy in achieving predictable allocation. In contrast, all threads in SFQ received the same throughput in conformance with the theoretical predictions. In <ref> [11] </ref>, it has been demonstrated that when a multimedia application is run as a real time thread in SVR4 scheduler, the whole system may become unusable.
Reference: [12] <author> A. Varma and D. Stiliadis. </author> <title> Design and Analysis of Frame-based Fair Queueing: A New Traffic Scheduling Algorithm for Packet Switched Networks. </title> <note> In Proceedings of SIGMETRICS'96 (to appear), </note> <year> 1996. </year>
Reference-contexts: This simulation is known to be computationally expensive [4]. In constrast, SFQ computes the start and finish tags efficiently. * As demonstrated in <ref> [12] </ref>, WFQ has significantly higher unfairness than SFQ. * WFQ provides high delay to low throughput applications.
Reference: [13] <author> C. Waldspurger and W. Weihl. </author> <title> Stride Scheduling: Deterministic Proportional-share Resource Management. </title> <type> Technical Report TM-528, </type> <institution> MIT, Laboratory for Computer Science, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Consequently, a randomized fair algorithm, termed lottery scheduling, was proposed in [14]. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm <ref> [13] </ref>. The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. Furthermore, no theoretical properties of the stride scheduling algorithm are known. Hierarchical partitioning of resource allocation was also proposed in [14] using the abstraction of tickets and currencies.
Reference: [14] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> Lottery Scheduling: Flexible Proportional-share Resource Management. </title> <booktitle> In Proceedings of symposim on Operating System Design and Implementation, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Though the relationship between fair packet scheduling algorithms and fair CPU allocation was pointed out in [6], it remained largely unknown to the operating systems community. Consequently, a randomized fair algorithm, termed lottery scheduling, was proposed in <ref> [14] </ref>. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm [13]. The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. <p> This limitation was later addressed by stride scheduling algorithm [13]. The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. Furthermore, no theoretical properties of the stride scheduling algorithm are known. Hierarchical partitioning of resource allocation was also proposed in <ref> [14] </ref> using the abstraction of tickets and currencies. In that framework, a thread is allocated tickets in some currency and the currency, in turn, is funded in terms of tickets of some other currency. <p> This achieves hierarchical partitioning since if a thread becomes inactive, the value of the tickets of the threads that are funded by the same currency increases. This specification of hierarchical partitioning is similar to our scheduling structure. However, the key differences between our framework and the approach of <ref> [14] </ref> are as follows. First, our framework permits different scheduling algorithms for different class of applications, whereas the framework of [14] does not. Second, hierarchical partitioning is achieved in [14] by recomputation of ticket values of every thread that are funded in the same currency or some ancestor of the currency <p> This specification of hierarchical partitioning is similar to our scheduling structure. However, the key differences between our framework and the approach of <ref> [14] </ref> are as follows. First, our framework permits different scheduling algorithms for different class of applications, whereas the framework of [14] does not. Second, hierarchical partitioning is achieved in [14] by recomputation of ticket values of every thread that are funded in the same currency or some ancestor of the currency every time a thread gets blocked or exits. <p> However, the key differences between our framework and the approach of <ref> [14] </ref> are as follows. First, our framework permits different scheduling algorithms for different class of applications, whereas the framework of [14] does not. Second, hierarchical partitioning is achieved in [14] by recomputation of ticket values of every thread that are funded in the same currency or some ancestor of the currency every time a thread gets blocked or exits. This approach not only incurs additional overhead of computing ticket values, but also does not provide any guarantees.
References-found: 14

