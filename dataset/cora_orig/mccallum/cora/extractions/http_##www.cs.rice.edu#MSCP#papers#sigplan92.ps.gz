URL: http://www.cs.rice.edu/MSCP/papers/sigplan92.ps.gz
Refering-URL: http://www.cs.rice.edu/MSCP/publications.html
Root-URL: 
Title: Rematerialization  
Author: Preston Briggs Keith D. Cooper Linda Torczon 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: This paper examines a problem that arises during global register allocation - rematerialization. If a value cannot be kept in a register, the allocator should recognize when it is cheaper to recompute the value (rematerialize it) than to store and reload it. Chaitin's original graph-coloring allocator handled simple instances of this problem correctly. This paper details a general solution to the problem and presents experimental evidence that shows its importance. Our approach is to tag individual values in the procedure's SSA graph with information specifying how it should be spilled. We use a variant of Wegman and Zadeck's sparse simple constant algorithm to propagate tags throughout the graph. The allocator then splits live ranges into values with different tags. This isolates those values that can be easily rematerialized from values that require general spilling. We modify the base allocator to use this information when estimating spill costs and introducing spill code. Our presentation focuses on rematerialization in the context of Chaitin's allocator; however, the problem arises in any global allocator. We believe that our approach will work in other allocators while the details of implementation will vary, the key insights should carry over directly. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David Bernstein, Dina Q. Goldin, Martin C. Golumbic, Hugo Krawczyk, Yishay Mansour, Itai Nahshon, and Ron Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <journal> SIG-PLAN Notices, </journal> <volume> 24(7) </volume> <pages> 258-263, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: When a value must be spilled, the allocator should recognize those cases when it is cheaper to recompute the value than to store and retrieve it from memory. While our discussion is set in the context of a Chaitin-style graph-coloring allocator <ref> [6, 5, 3, 1] </ref>, the same questions seem to arise in all global allocators. Consider the code fragments shown in Figure 1 (the notation [p] means "the contents of the memory location addressed by p").
Reference: [2] <author> Preston Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: We currently generate code for the IBM RT/PC and have experimental code generators for the Sparc, i860, and RS/6000. To experiment with register allocation, we have built a series of allocators that are independent of any particular architecture <ref> [2] </ref>. Our experimental allocators work with routines expressed in ILOC, a low-level intermediate language designed to allow extensive optimization. An ILOC routine that assumes an infinite register set is rewritten in terms of a particular target register set, with spill code added as necessary. <p> Our results appear to be slightly faster than the times reported by IBM's xlf compiler for register allocation and comparable to the times reported for optimization. In an extensive comparison with priority-based coloring, our allocators appeared much slower on very small routines, but much faster on very large routines <ref> [2] </ref>. <p> Conceptually, it seems easy to incorporate these ideas into our allocator; however, experience has shown that significant engineering is required. The complete results of our experiments with loop-based splitting are presented in Briggs' thesis <ref> [2] </ref>. Each scheme had several major successes; each had several equally dramatic failures. While the improvements are large enough to warrant further study, the failures are significant enough to discourage adoption in a production compiler.
Reference: [3] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 275-284, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: When a value must be spilled, the allocator should recognize those cases when it is cheaper to recompute the value than to store and retrieve it from memory. While our discussion is set in the context of a Chaitin-style graph-coloring allocator <ref> [6, 5, 3, 1] </ref>, the same questions seem to arise in all global allocators. Consider the code fragments shown in Figure 1 (the notation [p] means "the contents of the memory location addressed by p"). <p> The first actual implementation was done by Chaitin et al. in the PL.8 compiler [6]. Chow and Hennessy described a priority-based scheme built on a coloring paradigm [8]. Our own work has built on Chaitin's approach <ref> [3] </ref>. To distinguish our allocator from Chaitin's, we call it the optimistic allocator. Throughout this paper, we assume that the allocator works on either low-level intermediate code or assembly code. Before allocation, the code can reference an unlimited number of virtual registers. <p> Spilling one or more live ranges changes both the code and the interference graph. The compiler proceeds by iteratively spilling some live ranges and attempting to color the resulting new graph. This process is guaranteed to terminate. In practice, this process converges quickly <ref> [5, 3] </ref> (see also Table 2). Figure 2 illustrates the overall flow of the optimistic allocator. Renumber finds the live ranges and gives them unique names. It creates a new live range for each definition point and unions together the live ranges that reach each use point. <p> Spill Code is invoked if select left a node uncolored. It converts each such node into a collection of tiny live ranges by inserting a load or store at each use and definition. Detailed descriptions of these processes can be found in Chaitin's work and our earlier paper <ref> [5, 6, 3] </ref>. 3 Rematerialization Chaitin et al. discuss several ideas for improving the quality of spill code [6]. They point out that certain values can be recomputed in a single instruction and that the required operands will always be available for the computation.
Reference: [4] <author> David Callahan and Brian Koblenz. </author> <title> Register allo-cation via hierarchical graph coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(6) </volume> <pages> 192-203, </pages> <month> June </month> <year> 1991. </year> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The Chaitin column illustrates the code that would be produced by a Chaitin-style allocator. The entire live range of p has been spilled to memory, with loads inserted before uses and stores inserted after definitions. The final column shows code we would expect from a "splitting" allocator <ref> [8, 17, 16, 4] </ref>; the actual code might be worse. In fact, our work on rematerialization was motivated by problems observed during our own experiments with live range splitting. <p> In contrast, we are concerned primarily with quality of spill code. It is also interesting to compare our approach to other published alternatives, particularly the splitting allocator of Chow and Hennessy and the hierarchical coloring allocator of Callahan and Koblenz <ref> [8, 4] </ref>. The published work does not indicate how they handle rematerializa-tion. It is possible that they make no special provisions, trusting their splitting algorithm to do an adequate job.
Reference: [5] <author> Gregory J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(6) </volume> <pages> 98-105, </pages> <month> June </month> <year> 1982. </year> <booktitle> Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction. </booktitle>
Reference-contexts: When a value must be spilled, the allocator should recognize those cases when it is cheaper to recompute the value than to store and retrieve it from memory. While our discussion is set in the context of a Chaitin-style graph-coloring allocator <ref> [6, 5, 3, 1] </ref>, the same questions seem to arise in all global allocators. Consider the code fragments shown in Figure 1 (the notation [p] means "the contents of the memory location addressed by p"). <p> Spilling one or more live ranges changes both the code and the interference graph. The compiler proceeds by iteratively spilling some live ranges and attempting to color the resulting new graph. This process is guaranteed to terminate. In practice, this process converges quickly <ref> [5, 3] </ref> (see also Table 2). Figure 2 illustrates the overall flow of the optimistic allocator. Renumber finds the live ranges and gives them unique names. It creates a new live range for each definition point and unions together the live ranges that reach each use point. <p> It creates a new live range for each definition point and unions together the live ranges that reach each use point. Build constructs the interference graph using the dual representations, a triangular bit-matrix and a set of adjacency vectors, advocated by Chaitin <ref> [5] </ref>. Coalesce attempts to combine live ranges. Two live ranges l i and l j are combined, giving l ij , if the initial definition of l j is a copy from l i and there is no interference between l i and l j . <p> If all remaining nodes have k or more neighbors, it chooses a spill candidate, removes it from G, and pushes it on the stack. The metric for picking spill candidates is critical. Chaitin suggested choosing the node that mini mizes spill cost divided by degree <ref> [5] </ref>. Select assigns colors to the nodes of G in the order determined by simplify. Select repeatedly pops a node from the stack and attempts to give it a color distinct from its colored neighbors. If no color is available for a node, it is left uncolored. <p> Spill Code is invoked if select left a node uncolored. It converts each such node into a collection of tiny live ranges by inserting a load or store at each use and definition. Detailed descriptions of these processes can be found in Chaitin's work and our earlier paper <ref> [5, 6, 3] </ref>. 3 Rematerialization Chaitin et al. discuss several ideas for improving the quality of spill code [6]. They point out that certain values can be recomputed in a single instruction and that the required operands will always be available for the computation. <p> To understand why this restriction is safe (indeed, it is conservative), recall Chaitin's coloring heuristic <ref> [5] </ref>. Before any spilling, nodes of degree &lt; k are removed from the graph. When a node is removed, the degrees of its neighbors are reduced, perhaps allowing them to be removed. This process repeats until the graph is empty or all remaining nodes have degree k.
Reference: [6] <author> Gregory J. Chaitin, Marc A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: When a value must be spilled, the allocator should recognize those cases when it is cheaper to recompute the value than to store and retrieve it from memory. While our discussion is set in the context of a Chaitin-style graph-coloring allocator <ref> [6, 5, 3, 1] </ref>, the same questions seem to arise in all global allocators. Consider the code fragments shown in Figure 1 (the notation [p] means "the contents of the memory location addressed by p"). <p> The first actual implementation was done by Chaitin et al. in the PL.8 compiler <ref> [6] </ref>. Chow and Hennessy described a priority-based scheme built on a coloring paradigm [8]. Our own work has built on Chaitin's approach [3]. To distinguish our allocator from Chaitin's, we call it the optimistic allocator. <p> Spill Code is invoked if select left a node uncolored. It converts each such node into a collection of tiny live ranges by inserting a load or store at each use and definition. Detailed descriptions of these processes can be found in Chaitin's work and our earlier paper <ref> [5, 6, 3] </ref>. 3 Rematerialization Chaitin et al. discuss several ideas for improving the quality of spill code [6]. They point out that certain values can be recomputed in a single instruction and that the required operands will always be available for the computation. <p> Detailed descriptions of these processes can be found in Chaitin's work and our earlier paper [5, 6, 3]. 3 Rematerialization Chaitin et al. discuss several ideas for improving the quality of spill code <ref> [6] </ref>. They point out that certain values can be recomputed in a single instruction and that the required operands will always be available for the computation. They call these exceptional values never-killed and note that such values should be recalculated instead of being spilled and reloaded. <p> They call these exceptional values never-killed and note that such values should be recalculated instead of being spilled and reloaded. They further note that an uncoalesced copy of a never-killed value can be eliminated by recomputing it directly into the desired register <ref> [6] </ref>. Together, these techniques are termed rematerialization. <p> The high-level structure depicted in Figure 2 is unchanged, but a number of low-level modifications are required. The next sections discuss the enhancements required in renumber, coalesce, and select. 4.1 Renumber Chaitin's version of renumber (termed "getting the right number of names") was based on def-use chaining <ref> [6] </ref>. Long before our interest in rematerialization, we adopted an implementation strategy for renumber based on the pruned SSA graph. Conceptually, the old implementation has four steps: 1. Determine liveness at each basic block using a sparse data-flow evaluation graph [7]. 2. Insert -nodes based on dominance frontiers [11]. <p> Renumber the operands in every instruction to refer to values instead of the original virtual registers. At the same time, accumulate availability information for each block. The intersection of live and avail is needed at each block to allow construction of a precise interference graph <ref> [6] </ref>. 4. Form live ranges by unioning together all the values reaching each -node using a fast disjoint-set union. The disjoint-set structure is maintained while building the interference graph and coalescing (where coalesces are further union operations). <p> We intend to continue our search for a consistently profitable approach. 7 Related Work Our work extends the work described by Chaitin et al. and recalls an approach suggested by Cytron and Ferrante. Chaitin et al. introduce the term remateri-alization and discuss the problem briefly <ref> [6] </ref>. Because their allocator cannot split live ranges, they handle only the simple case where all definitions contributing to a live range are identical. Our work is a direct extension and is able to handle each component of a complete live range separately and correctly.
Reference: [7] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Fer-rante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: To achieve this goal, the construction technique inserts special definitions called -nodes at those points where control-flow paths join and different values merge. We actually use the pruned SSA, with dead -nodes eliminated <ref> [7] </ref>. A natural way to view the SSA graph for a procedure is as a collection of values, each composed of a single definition and one or more uses. Each value's definition is either a single instruction or a -node that merges two or more values. <p> Long before our interest in rematerialization, we adopted an implementation strategy for renumber based on the pruned SSA graph. Conceptually, the old implementation has four steps: 1. Determine liveness at each basic block using a sparse data-flow evaluation graph <ref> [7] </ref>. 2. Insert -nodes based on dominance frontiers [11]. Avoid inserting dead -nodes. 3. Renumber the operands in every instruction to refer to values instead of the original virtual registers. At the same time, accumulate availability information for each block.
Reference: [8] <author> Fred C. Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The Chaitin column illustrates the code that would be produced by a Chaitin-style allocator. The entire live range of p has been spilled to memory, with loads inserted before uses and stores inserted after definitions. The final column shows code we would expect from a "splitting" allocator <ref> [8, 17, 16, 4] </ref>; the actual code might be worse. In fact, our work on rematerialization was motivated by problems observed during our own experiments with live range splitting. <p> The first actual implementation was done by Chaitin et al. in the PL.8 compiler [6]. Chow and Hennessy described a priority-based scheme built on a coloring paradigm <ref> [8] </ref>. Our own work has built on Chaitin's approach [3]. To distinguish our allocator from Chaitin's, we call it the optimistic allocator. Throughout this paper, we assume that the allocator works on either low-level intermediate code or assembly code. <p> are not competitive with the fast, local techniques used in non-optimizing compilers [14, 15]; however, we believe that global optimizations require global register allocation. 6 Extensions Of course, rematerialization is not the only reason for splitting live ranges; others have observed that splitting a live range can improve the allocation <ref> [12, 8] </ref>. A natural extension to the scheme described in Section 3 is to split at all -nodes. This lets the allocator pick and choose among all the values in the SSA graph. The machinery used to support rematerialization can easily handle additional splitting. <p> In contrast, we are concerned primarily with quality of spill code. It is also interesting to compare our approach to other published alternatives, particularly the splitting allocator of Chow and Hennessy and the hierarchical coloring allocator of Callahan and Koblenz <ref> [8, 4] </ref>. The published work does not indicate how they handle rematerializa-tion. It is possible that they make no special provisions, trusting their splitting algorithm to do an adequate job.
Reference: [9] <author> Keith D. Cooper, Ken Kennedy, and Linda Torc-zon. </author> <title> The impact of interprocedural analysis and optimization on the IR n programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 491-523, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: The compiler is part of the ParaScope programming environment and includes support for interprocedural analysis and a variety of traditional optimizations <ref> [9] </ref>. We currently generate code for the IBM RT/PC and have experimental code generators for the Sparc, i860, and RS/6000. To experiment with register allocation, we have built a series of allocators that are independent of any particular architecture [2].
Reference: [10] <author> Ron Cytron and Jeanne Ferrante. </author> <title> What's in a name? The value of renaming for parallelism detection and storage allocation. </title> <booktitle> In Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pages 19-27, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Our work is a direct extension and is able to handle each component of a complete live range separately and correctly. Cytron and Fer-rante suggest splitting based on (the equivalent of) the SSA <ref> [10] </ref>. Their goal is minimal coloring in polynomial-time achieved at the cost introducing extra copies. There is no direct discussion of rematerialization; indeed, the discussion of spilling is very sketchy. In contrast, we are concerned primarily with quality of spill code.
Reference: [11] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: find values, how to propagate tags, how to split the live ranges, and how to remove unproductive splits. 3.1 Discovering Values To find values, we construct the procedure's static single assignment (SSA) graph, a representation that transforms the code so that each use of a value references exactly one definition <ref> [11] </ref>. To achieve this goal, the construction technique inserts special definitions called -nodes at those points where control-flow paths join and different values merge. We actually use the pruned SSA, with dead -nodes eliminated [7]. <p> Long before our interest in rematerialization, we adopted an implementation strategy for renumber based on the pruned SSA graph. Conceptually, the old implementation has four steps: 1. Determine liveness at each basic block using a sparse data-flow evaluation graph [7]. 2. Insert -nodes based on dominance frontiers <ref> [11] </ref>. Avoid inserting dead -nodes. 3. Renumber the operands in every instruction to refer to values instead of the original virtual registers. At the same time, accumulate availability information for each block. <p> of propagating rematerialization tags. * In all but one case, the cost of the build-coalesce loop is higher for the New allocator, due to the additional passes of conservative coalescing. * The very low costs of control-flow analysis illustrates the speed and practicality of the algorithm for calculating dominance frontiers <ref> [11] </ref>. * The higher cost of coloring in the first pass arises from the cost of choosing nodes to spill.
Reference: [12] <author> Janet Fabri. </author> <title> Automatic storage optimization. </title> <journal> SIG-PLAN Notices, </journal> <volume> 14(8) </volume> <pages> 83-91, </pages> <month> August </month> <year> 1979. </year> <booktitle> Proceedings of the ACM SIGPLAN '79 Symposium on Compiler Construction. </booktitle>
Reference-contexts: are not competitive with the fast, local techniques used in non-optimizing compilers [14, 15]; however, we believe that global optimizations require global register allocation. 6 Extensions Of course, rematerialization is not the only reason for splitting live ranges; others have observed that splitting a live range can improve the allocation <ref> [12, 8] </ref>. A natural extension to the scheme described in Section 3 is to split at all -nodes. This lets the allocator pick and choose among all the values in the SSA graph. The machinery used to support rematerialization can easily handle additional splitting.
Reference: [13] <author> George E. Forsythe, Michael A. Malcolm, and Cleve B. Moler. </author> <title> Computer Methods for Mathematical Computations. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1977. </year>
Reference-contexts: Eleven routines are from Forsythe, Malcolm, and Moler's book on numerical methods <ref> [13] </ref>. They are grouped into seven programs with simple drivers. The remaining fifty-nine routines are from the SPEC benchmark suite [20]. Four of the SPEC programs were used: doduc (41 routines), fpppp (12 routines), matrix300 (5 routines), and tomcatv (1 routine).
Reference: [14] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In an extensive comparison with priority-based coloring, our allocators appeared much slower on very small routines, but much faster on very large routines [2]. Of course, these speeds are not competitive with the fast, local techniques used in non-optimizing compilers <ref> [14, 15] </ref>; however, we believe that global optimizations require global register allocation. 6 Extensions Of course, rematerialization is not the only reason for splitting live ranges; others have observed that splitting a live range can improve the allocation [12, 8].
Reference: [15] <author> Christopher W. Fraser and David R. Hanson. </author> <title> Simple register spilling in a retargetable compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 22(1) </volume> <pages> 85-99, </pages> <month> Jan-uary </month> <year> 1992. </year>
Reference-contexts: In an extensive comparison with priority-based coloring, our allocators appeared much slower on very small routines, but much faster on very large routines [2]. Of course, these speeds are not competitive with the fast, local techniques used in non-optimizing compilers <ref> [14, 15] </ref>; however, we believe that global optimizations require global register allocation. 6 Extensions Of course, rematerialization is not the only reason for splitting live ranges; others have observed that splitting a live range can improve the allocation [12, 8].
Reference: [16] <author> Rajiv Gupta, Mary Lou Soffa, and Tim Steele. </author> <title> Register allocation via clique separators. </title> <journal> SIG-PLAN Notices, </journal> <volume> 24(7) </volume> <pages> 264-274, </pages> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The Chaitin column illustrates the code that would be produced by a Chaitin-style allocator. The entire live range of p has been spilled to memory, with loads inserted before uses and stores inserted after definitions. The final column shows code we would expect from a "splitting" allocator <ref> [8, 17, 16, 4] </ref>; the actual code might be worse. In fact, our work on rematerialization was motivated by problems observed during our own experiments with live range splitting.
Reference: [17] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Register allocation in the SPUR Lisp compiler. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7) </volume> <pages> 255-263, </pages> <month> July </month> <year> 1986. </year> <booktitle> Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction. </booktitle>
Reference-contexts: The Chaitin column illustrates the code that would be produced by a Chaitin-style allocator. The entire live range of p has been spilled to memory, with loads inserted before uses and stores inserted after definitions. The final column shows code we would expect from a "splitting" allocator <ref> [8, 17, 16, 4] </ref>; the actual code might be worse. In fact, our work on rematerialization was motivated by problems observed during our own experiments with live range splitting.
Reference: [18] <author> S. S. Lavrov. </author> <title> Store economy in closed operator schemes. </title> <journal> Zhurnal Vychislitel'noi Matematiki i Matematicheskoi Fiziki, </journal> <volume> 1(4) </volume> <pages> 687-701, </pages> <year> 1961. </year> <title> English translation in U.S.S.R. </title> <journal> Computational Mathematics and Mathematical Physics 3, </journal> <year> 1962. </year>
Reference-contexts: p p + 1 store p ? ? fl Splitting p Label store p reload p y y + [p] reload p p p + 1 ? ? fl 2 Background The notion of modeling register allocation as a graph coloring problem descends from very early work on storage allocation <ref> [18] </ref>. The first actual implementation was done by Chaitin et al. in the PL.8 compiler [6]. Chow and Hennessy described a priority-based scheme built on a coloring paradigm [8]. Our own work has built on Chaitin's approach [3]. To distinguish our allocator from Chaitin's, we call it the optimistic allocator.
Reference: [19] <author> Ravi Sethi. </author> <title> Complete register allocation problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 4(3) </volume> <pages> 226-248, </pages> <year> 1975. </year>
Reference-contexts: 1 Introduction In the past decade, the literature on register allocation has focused largely on global allocation methods that factor information about the entire procedure into the decision process. Because the problem of optimal register allocation is NP-complete <ref> [19] </ref>, compilers employ heuristic techniques to approximate its solution.
Reference: [20] <author> SPEC release 1.2, </author> <month> September </month> <year> 1990. </year> <title> Standards Performance Evaluation Corporation. </title>
Reference-contexts: Eleven routines are from Forsythe, Malcolm, and Moler's book on numerical methods [13]. They are grouped into seven programs with simple drivers. The remaining fifty-nine routines are from the SPEC benchmark suite <ref> [20] </ref>. Four of the SPEC programs were used: doduc (41 routines), fpppp (12 routines), matrix300 (5 routines), and tomcatv (1 routine). The two other FORTRAN programs in the suite (spice and nasa7) require language extensions not yet supplied by our front-end.
Reference: [21] <author> Mark N. Wegman and F. Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: By examining the defining instruction for each value, we can recognize never-killed values and propagate this information throughout the SSA graph. 3.2 Propagating Rematerialization Tags To propagate tags, we use an analog of Wegman and Zadeck's sparse simple constant algorithm <ref> [21] </ref>. We modify their lattice slightly to represent the necessary rematerialization information. The new lattice elements may have one of three types: &gt; Top means that no information is known.
References-found: 21

