URL: http://wwwipd.ira.uka.de/~odersky/papers/popl96.ps.gz
Refering-URL: http://scotch.systemsz.cs.yale.edu/aplar/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: odersky@ira.uka.de  laufer@math.luc.edu  
Title: Putting Type Annotations to Work  
Author: Martin Odersky Konstantin Laufer 
Address: 76128 Karlsruhe, Germany  Chicago, Illinois 60626, USA  
Affiliation: Department of Computer Science University of Karlsruhe  Department of Mathematical Sciences Loyola University Chicago  
Abstract: We study an extension of the Hindley/Milner system with explicit type scheme annotations and type declarations. The system can express polymorphic function arguments, user-defined data types with abstract components, and structure types with polymorphic fields. More generally, all programs of the polymorphic lambda calculus can be encoded by a translation between typing derivations. We show that type reconstruction in this system can be reduced to the decidable problem of first-order unification under a mixed prefix. 
Abstract-found: 1
Intro-found: 1
Reference: [Aug94] <author> L. Augustsson. Haskell B. </author> <note> user's manual version 0.999.7, </note> <month> October </month> <year> 1994. </year> <title> Distributed with the HBC compiler. </title>
Reference-contexts: Perry [Per90] and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell <ref> [Aug94] </ref> and CAML [MP93]. Remy [Rem94] has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed. Jones [Jon95] has investigated record types with polymorphic elements as a way to capture essential aspects of module systems.
Reference: [BMS80] <author> Rod Burstall, David MacQueen, and Donald T. Sanella. </author> <title> Hope: An experimental applicative language. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 136-143, </pages> <address> Redwood Estates, California, </address> <month> August </month> <year> 1980. </year> <title> The LISP Company. </title>
Reference-contexts: We have already discussed polymorphic sum and product type schemes. As another possible extension, it is straightforward to add polymorphic recursion [Myc84], which is known to be undecidable in the absence of type declarations [Hen93, KTU93]. Starting with Hope <ref> [BMS80] </ref>, many programming languages have supported polymorphic recursion when explicit declarations are given for polymorphically recursive functions. Nevertheless, we are not aware of a formal analysis of type reconstruction for these languages.
Reference: [Boe89] <author> Hans-J. Boehm. </author> <title> Type inference in the presence of type abstraction. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-206. </pages> <publisher> ACM, ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The proposed schemes all have rather complex inference rules with cumbersome conversions between declared and inferred types [McC84, OG89]. By contrast, Church-style reconstruction requires the position of type abstractions and applications to be indicated in the original source. This style of reconstruction (also called partial type reconstruction <ref> [Boe89] </ref>) was shown to be reducible to higher-order unification [Pfe88]. Even though Church-style reconstruction is thus undecidable in general this result opens up the possibility for semi-decision procedures that work well in practice.
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982. </year>
Reference-contexts: This paper tries to explore some of the design space between them. The Hindley/Milner system [Mil78] extends the simply-typed -calculus with polymorphic let-bound identifiers. It thus adds considerable expressive power yet retains the property that no type annotations in programs are needed, since most general types can be inferred <ref> [DM82] </ref>. This property has made the Hind-ley/Milner system very appealing as a basis of type systems for programming languages. By contrast, the second-order polymorphic - calculus F 2 [Gir71, Rey74] allows polymorphic types everywhere, but requires explicit annotations of both argument types and type instantiations. <p> This holds also if type annotations in the style of ML or Haskell are added to Hindley/Milner. We were able to show principal type properties and soundness and completeness of type inference fully analogous to the ones stated by Damas and Milner <ref> [DM82] </ref>. Since the engineering issues of ML-like programming languages and type checkers are by now well understood, we believe that this makes our system promising as a practical kernel language on which type-systematic extensions of ML or Haskell can be based. The rest of this paper is organized as follows. <p> We therefore have to give up Hindley/Milner's restriction that quantifiers may occur only at the outermost level of a type scheme and have to admit type schemes such as 1 ! 2 . An immediate consequence is that we have to refine the "generic instance" relation <ref> [DM82] </ref> if we want to get principal types for the system with annotations. Consider the function x:Int.[ ]. Two derivable type schemes for this function are 8a.Int ! [a] and Int ! 8a.[a]. None of these type schemes is a generic instance of the other. <p> The relation () is a subrelation of Mitchell's containment relation [Mit90] and hence is validated by all type inference models. For type schemes that have quantifiers only at the outermost level, () is the inverse of the "generic instance" relation given by Damas and Milner <ref> [DM82] </ref>. We changed the direction of () sign to stay in line with Mitchell's containment relation which corresponds to the semantic intuition of subtyp-ing as subsetting. () has the following useful properties. Proposition 2.1 Let and 0 be type schemes and let be a substitution.
Reference: [Fel90] <author> Matthias Felleisen. </author> <title> On the expressive power of programming languages. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> ESOP '90, European Symposium on Programming, </booktitle> <pages> pages 134-151. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> Lecture Notes in Computer Science 432. </note>
Reference-contexts: This shows that our typing discipline provides essentially the same capabilities as F 2 , even though the encoding in F 2 does not support a formal comparison of expressive power in the sense of Felleisen <ref> [Fel90] </ref> since it fails to be compositional. Our typing discipline is a conservative extension of the Hindley/Milner system. Every typable program in that system continues to be typable. This holds also if type annotations in the style of ML or Haskell are added to Hindley/Milner.
Reference: [Gir71] <author> J. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <booktitle> In 2nd Scandinavian Logic Symp., </booktitle> <pages> pages 63-92, </pages> <year> 1971. </year>
Reference-contexts: This property has made the Hind-ley/Milner system very appealing as a basis of type systems for programming languages. By contrast, the second-order polymorphic - calculus F 2 <ref> [Gir71, Rey74] </ref> allows polymorphic types everywhere, but requires explicit annotations of both argument types and type instantiations. The general Appeared in Proc. 23rd ACM Symposium on Principles of Programming Languages, January 1996. c fl 1997 ACM.
Reference: [Hen93] <author> Fritz Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 253-289, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: When applied in a programming language, several extensions would be possible and maybe even desirable. We have already discussed polymorphic sum and product type schemes. As another possible extension, it is straightforward to add polymorphic recursion [Myc84], which is known to be undecidable in the absence of type declarations <ref> [Hen93, KTU93] </ref>. Starting with Hope [BMS80], many programming languages have supported polymorphic recursion when explicit declarations are given for polymorphically recursive functions. Nevertheless, we are not aware of a formal analysis of type reconstruction for these languages.
Reference: [Jon92] <author> Mark P. Jones. </author> <title> Qualified Types: Theory and Practice. D.phil. </title> <type> thesis, </type> <institution> Oxford University, </institution> <month> September </month> <year> 1992. </year> <month> 13 </month>
Reference-contexts: A more flexible scheme, in which a label could be part of several structures, would be obtained by adding overloading to our type system <ref> [Jon92, OWW95] </ref>. In symmetry with our treatment of data types, we now adopt the convention that any type variables in one of the t i that do not appear in ff are universally quantified.
Reference: [Jon95] <author> Mark P. Jones. </author> <title> From Hindley-Milner types to first-class structures. </title> <booktitle> In Proc. Haskell Workshop, La Jolla, </booktitle> <pages> pages 115-136, </pages> <month> June </month> <year> 1995. </year> <institution> Yale University Research Report YALEU/DCS/RR-1075. </institution>
Reference-contexts: This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. Remy [Rem94] has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed. Jones <ref> [Jon95] </ref> has investigated record types with polymorphic elements as a way to capture essential aspects of module systems. A proposal along these lines has 1 been accepted for inclusion in Haskell 1.3. It seems that a combination of all of the above systems, while feasible, would be rather unwieldy. <p> In particular, we deal with Laufer and Odersky's version of abstract types [LO94] and with Jones' version of polymorphic structures <ref> [Jon95] </ref>. A system equivalent in expressiveness to Remy's [Rem94] can then be obtained by combining both extensions.
Reference: [KTU89] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The undecidability of the semi-unification problem. </title> <type> Technical Report BUCS-89-010, </type> <institution> Boston University, </institution> <month> Oct. </month> <year> 1989. </year> <note> also in Proc. of Symp. on Theory of Computing, </note> <institution> Baltimore, Maryland, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Decidability holds because we still admit only types and not type schemes in the range of substitutions | otherwise the problem would be equivalent to semi-unification, which is undecidable <ref> [KTU89] </ref>. * Unlike the situation in F 2 , we still maintain a stratification between types and type schemes. A universally quantified variable can be instantiated only to types, never to type schemes.
Reference: [KTU93] <author> A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 290-311, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: When applied in a programming language, several extensions would be possible and maybe even desirable. We have already discussed polymorphic sum and product type schemes. As another possible extension, it is straightforward to add polymorphic recursion [Myc84], which is known to be undecidable in the absence of type declarations <ref> [Hen93, KTU93] </ref>. Starting with Hope [BMS80], many programming languages have supported polymorphic recursion when explicit declarations are given for polymorphically recursive functions. Nevertheless, we are not aware of a formal analysis of type reconstruction for these languages.
Reference: [LMM87] <author> J. Lassez, M. Maher, and K. Marriott. </author> <title> Unification revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kauffman, </publisher> <year> 1987. </year>
Reference-contexts: We define 1 ( ffi 1 )j U = 2 j U . We write 1 U 2 if 9: 1 Note that this makes the "more general" substitution the smaller element in the pre-order U . This choice, which reverses the usual convention in treatments of unification (e.g. <ref> [LMM87] </ref>), was made to stay in line with the semantic notion of type instance. We make U a partial order by identifying substitutions that are equal up to variable renaming, or equivalently, by defining = U iff U and U . It follows from [LMM87][Theorem 7] that U is a complete
Reference: [LO94] <author> Konstantin Laufer and Martin Odersky. </author> <title> Polymorphic type inference and abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1411-1430, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: For instance, Launch-bury and Peyton Jones have presented an elegant type system for syntactic control of interference [LPar] that uses second-order universal quantification. Perry [Per90] and Laufer and Odersky <ref> [LO94] </ref> have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. <p> In particular, we deal with Laufer and Odersky's version of abstract types <ref> [LO94] </ref> and with Jones' version of polymorphic structures [Jon95]. A system equivalent in expressiveness to Remy's [Rem94] can then be obtained by combining both extensions. <p> Conceptually, a data type constructor is a special instance of a type constructor T , whereas value constructors k form a separate alphabet. As in <ref> [LO94] </ref> we adopt the convention that any type variables in one of the t i that do not appear in ff are existentially quantified. By contrast, in ML or Haskell such type variables would be disallowed. Example 3.1 The following declares a type of lists with heterogeneous elements. <p> Given a data type declaration (1), let fi i = ftv (t i )nff for i = 1; : : : ; n. Then the following typing rules are equivalent to the treatment in <ref> [LO94] </ref>. (AbsI) ` k i : 8ff:8fi i :t i ! D ff (i = 1; : : : ; n) (AbsE) ` e : D t 00 i ! D t 00 i ! t (i = 1; : : : ; n) ` case e of fk 1 x
Reference: [LPar] <author> John Launchbury and Simon Peyton Jones. </author> <title> State in Haskell. Lisp and Symbolic Computation, </title> <note> to appear. </note>
Reference-contexts: Recently there have been several approaches towards extending the Hindley/Milner system with some form of embedded quantifiers without going all the way to the polymorphic -calculus. For instance, Launch-bury and Peyton Jones have presented an elegant type system for syntactic control of interference <ref> [LPar] </ref> that uses second-order universal quantification. Perry [Per90] and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88].
Reference: [McC84] <author> N. </author> <title> McCracken. The typechecking of programs with implicit type structure. </title> <editor> In Gilles Kahn, David B. MacQueen, and Gordon D. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 301-315. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year> <note> Lecture Notes in Computer Science 173. </note>
Reference-contexts: Curry-style reconstruction fills in polymorphic abstractions and applications together with type annotations. This style of reconstruction is complicated by the lack of principal types in F 2 . The proposed schemes all have rather complex inference rules with cumbersome conversions between declared and inferred types <ref> [McC84, OG89] </ref>. By contrast, Church-style reconstruction requires the position of type abstractions and applications to be indicated in the original source. This style of reconstruction (also called partial type reconstruction [Boe89]) was shown to be reducible to higher-order unification [Pfe88].
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> Dec </month> <year> 1978. </year>
Reference-contexts: 1 Introduction Two of the most important cornerstones of type theory for programming languages are the Hindley/Milner system and the second-order polymorphic -calculus. This paper tries to explore some of the design space between them. The Hindley/Milner system <ref> [Mil78] </ref> extends the simply-typed -calculus with polymorphic let-bound identifiers. It thus adds considerable expressive power yet retains the property that no type annotations in programs are needed, since most general types can be inferred [DM82]. <p> The encodings give us principal type properties and type inference algorithms for these systems "for free". * Unlike the situation in the simply typed -calculus [Mor68] or ML <ref> [Mil78] </ref>, it is no longer possible to reduce type inference to a simple Herbrand unification problem. We need to consider instead the problem of finding a most general substitution that makes one type scheme an instance of another.
Reference: [Mil92] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 321-358, </pages> <year> 1992. </year>
Reference-contexts: We need to consider instead the problem of finding a most general substitution that makes one type scheme an instance of another. We show here that this problem is reducible to the problem of first-order unification under a mixed prefix <ref> [Mil92] </ref>, which is decidable. <p> Given type schemes and 0 , find the most general substitution = M GI ( 0 ) such that 0 , provided exists; return failure otherwise. This problem can be reduced to the unification under a mixed prefix problem <ref> [Mil92] </ref>.
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <editor> In Gerard Huet, editor, </editor> <booktitle> Logical Foundations of Functional Programming, The UT Year of Programming Series, chapter 8. </booktitle> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Rule ( 8) allows us to re-quantify a type scheme. Functions over type schemes are handled by the standard contravariance rule (!). As usual, we identify type schemes that are instances of each other. The relation () is a subrelation of Mitchell's containment relation <ref> [Mit90] </ref> and hence is validated by all type inference models. For type schemes that have quantifiers only at the outermost level, () is the inverse of the "generic instance" relation given by Damas and Milner [DM82].
Reference: [Mor68] <author> J. H. Morris. </author> <title> Lambda-Calculus Models of Programming Languages. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1968. </year> <note> Technical Report MAC-TR-57. </note>
Reference-contexts: The encodings give us principal type properties and type inference algorithms for these systems "for free". * Unlike the situation in the simply typed -calculus <ref> [Mor68] </ref> or ML [Mil78], it is no longer possible to reduce type inference to a simple Herbrand unification problem. We need to consider instead the problem of finding a most general substitution that makes one type scheme an instance of another.
Reference: [MP88] <author> J. Mitchell and G. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: For instance, Launch-bury and Peyton Jones have presented an elegant type system for syntactic control of interference [LPar] that uses second-order universal quantification. Perry [Per90] and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types <ref> [MP88] </ref>. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. Remy [Rem94] has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed.
Reference: [MP93] <author> M. Mauny and F. Pottier. </author> <title> An implementation of Caml-Light with existential types. </title> <type> Technical report, </type> <institution> INRIA, </institution> <month> October </month> <year> 1993. </year> <title> Distributed with the Caml-Light system. </title>
Reference-contexts: Perry [Per90] and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML <ref> [MP93] </ref>. Remy [Rem94] has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed. Jones [Jon95] has investigated record types with polymorphic elements as a way to capture essential aspects of module systems.
Reference: [Myc84] <author> A. Mycroft. </author> <title> Polymorphic type schemes and recursive definitions. </title> <booktitle> In Proc. 6th Int. Symposium. on Programming, LNCS 167, </booktitle> <year> 1984. </year>
Reference-contexts: When applied in a programming language, several extensions would be possible and maybe even desirable. We have already discussed polymorphic sum and product type schemes. As another possible extension, it is straightforward to add polymorphic recursion <ref> [Myc84] </ref>, which is known to be undecidable in the absence of type declarations [Hen93, KTU93]. Starting with Hope [BMS80], many programming languages have supported polymorphic recursion when explicit declarations are given for polymorphically recursive functions. Nevertheless, we are not aware of a formal analysis of type reconstruction for these languages.
Reference: [OG89] <author> James William O'Toole and David K. Gifford. </author> <title> Polymorphic type reconstruction. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 207-217. </pages> <publisher> ACM, ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Curry-style reconstruction fills in polymorphic abstractions and applications together with type annotations. This style of reconstruction is complicated by the lack of principal types in F 2 . The proposed schemes all have rather complex inference rules with cumbersome conversions between declared and inferred types <ref> [McC84, OG89] </ref>. By contrast, Church-style reconstruction requires the position of type abstractions and applications to be indicated in the original source. This style of reconstruction (also called partial type reconstruction [Boe89]) was shown to be reducible to higher-order unification [Pfe88].
Reference: [OL95] <author> Martin Odersky and Konstantin Laufer. </author> <title> Type reconstruction in the presence of type scheme annotations. </title> <type> Technical report, </type> <institution> University of Karl-sruhe, </institution> <year> 1995. </year> <month> forthcoming. </month>
Reference-contexts: We now state soundness and completeness of algorithm MGI. The proofs for this and the following theorems proceed by standard inductions on derivations. Proofs are omitted here; they will be given in a forthcoming technical report <ref> [OL95] </ref>. Lemma 5.2 (Substitution) If ` 0 then ` 0 .
Reference: [OWW95] <author> Martin Odersky, Philip Wadler, and Martin Wehr. </author> <title> A second look at overloading. </title> <booktitle> In Proc. ACM Conf. on Functional Programming and Computer Architecture, </booktitle> <pages> pages 135-1469, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: A more flexible scheme, in which a label could be part of several structures, would be obtained by adding overloading to our type system <ref> [Jon92, OWW95] </ref>. In symmetry with our treatment of data types, we now adopt the convention that any type variables in one of the t i that do not appear in ff are universally quantified.
Reference: [Per90] <author> N. Perry. </author> <title> The Implementation of Practical Functional Programming Languages. </title> <type> PhD thesis, </type> <institution> Imperial College of Science, Technology, and Medicine, University of London, </institution> <year> 1990. </year>
Reference-contexts: For instance, Launch-bury and Peyton Jones have presented an elegant type system for syntactic control of interference [LPar] that uses second-order universal quantification. Perry <ref> [Per90] </ref> and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. <p> Perry <ref> [Per90] </ref> and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. Remy [Rem94] has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed. Jones [Jon95] has investigated record types with polymorphic elements as a way to capture essential aspects of module systems.
Reference: [Pfe88] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: By contrast, Church-style reconstruction requires the position of type abstractions and applications to be indicated in the original source. This style of reconstruction (also called partial type reconstruction [Boe89]) was shown to be reducible to higher-order unification <ref> [Pfe88] </ref>. Even though Church-style reconstruction is thus undecidable in general this result opens up the possibility for semi-decision procedures that work well in practice.
Reference: [Rem89] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Proof: Direct from Theorem 5.3 and the definition of modified MGI. 2 6 Type Reconstruction Following <ref> [Rem89] </ref>, it is expressed as an inference system, with clauses of the form V; ` W e : and V; ` G e : : Each derivation step takes as input a type variable set V , a typothesis and an expression e.
Reference: [Rem94] <author> Didier Remy. </author> <title> Programming objects with ML-ART, and extension to ML with abstract and record types. </title> <booktitle> In Proc. Theoretical Aspects of Computer Software, </booktitle> <pages> pages 321-346, </pages> <address> April 1994. </address> <publisher> Springer LNCS 789. </publisher>
Reference-contexts: Perry [Per90] and Laufer and Odersky [LO94] have studied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version of Mitchell and Plotkin's abstract types [MP88]. This style of existential quantification has been implemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. Remy <ref> [Rem94] </ref> has extended Laufer and Odersky's system with universal quantification in datatypes, so that objects with polymorphic methods can be expressed. Jones [Jon95] has investigated record types with polymorphic elements as a way to capture essential aspects of module systems. <p> In particular, we deal with Laufer and Odersky's version of abstract types [LO94] and with Jones' version of polymorphic structures [Jon95]. A system equivalent in expressiveness to Remy's <ref> [Rem94] </ref> can then be obtained by combining both extensions.
Reference: [Rey74] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In International Programming Symposium, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year> <note> Lecture Notes in Computer Science 19. </note>
Reference-contexts: This property has made the Hind-ley/Milner system very appealing as a basis of type systems for programming languages. By contrast, the second-order polymorphic - calculus F 2 <ref> [Gir71, Rey74] </ref> allows polymorphic types everywhere, but requires explicit annotations of both argument types and type instantiations. The general Appeared in Proc. 23rd ACM Symposium on Principles of Programming Languages, January 1996. c fl 1997 ACM.
Reference: [Wel94] <author> J.B. Wells. </author> <title> Typability and type checking in the second order -calculus are equivalent and undecidable. </title> <booktitle> In Proc. 9th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 176-185, </pages> <month> July </month> <year> 1994. </year> <month> 14 </month>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. problem of typechecking without type annotations is undecidable <ref> [Wel94] </ref> but there have been several approaches towards type reconstruction where some type information is given. These generally fall into two categories. Curry-style reconstruction fills in polymorphic abstractions and applications together with type annotations. This style of reconstruction is complicated by the lack of principal types in F 2 .
References-found: 31

