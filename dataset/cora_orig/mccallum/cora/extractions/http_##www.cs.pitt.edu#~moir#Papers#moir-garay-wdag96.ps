URL: http://www.cs.pitt.edu/~moir/Papers/moir-garay-wdag96.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Fast, Long-Lived Renaming Improved and Simplified  
Author: Mark Moir and Juan A. Garay 
Abstract: In the long-lived M-renaming problem, N processes repeatedly acquire and release names ranging over f0; :::; M 1g, where M &lt; N. It is assumed that at most k processes concurrently request or hold names. Efficient solutions to the long-lived renaming problem can be used to improve the performance of applications in which processes repeatedly participate in a computation whose time complexity depends on the size of the name space containing the processes. In this paper, we consider wait-free solutions to the long-lived M-renaming problem that use only read and write instructions in an asynchronous, shared- memory multiprocessor. A solution to long-lived renaming is fast if the time complexity of acquiring and releasing a name once is independent of N . We present a new fast, long-lived (k(k + 1)=2)-renaming algorithm that significantly improves upon the time and space complexity of similar previous algorithms, while providing a much simpler solution. We also show for the first time that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This result is optimal with respect to the size of the name space.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Anderson and M. Moir, </author> <title> "Fast k-Exclusion Algorithms", </title> <note> submitted to Distributed Computing. Preliminary version appeared in Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </note> <month> August </month> <year> 1994, </year> <pages> pp. 141-150. </pages>
Reference-contexts: This is the essence of an approach suggested by Anderson and Moir for implementing scalable and resilient shared objects <ref> [1] </ref>. Because the time complexity of the computations discussed above is often dependent on the size of the name space containing the participating processes, renaming to a smaller name space can result in better overall time complexity.
Reference: 2. <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 10] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N . <p> The long-lived M renaming problem <ref> [2, 5, 6, 10] </ref> is a generalisation of one-time renaming, in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently.
Reference: 3. <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 10] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N .
Reference: 4. <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 10] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N .
Reference: 5. <author> H. Buhrman, J. Garay, J. Hoepman, and M. Moir, </author> <title> "Long-Lived Renaming Made Fast", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995, </year> <pages> pp. 194-203. </pages>
Reference-contexts: The long-lived M renaming problem <ref> [2, 5, 6, 10] </ref> is a generalisation of one-time renaming, in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> They presented fast solutions for both one-time and long-lived renaming. Their fast, long-lived renaming algorithms are extremely efficient but depend on strong synchronisation primitives such as test-and-set. Later, Buhrman et al. showed for the first time that fast, long-lived renaming using only read and write operations is possible <ref> [5] </ref>. Such algorithms are more portable and more widely applicable than algorithms that rely on special synchronisation primitives. The long-lived renaming solution presented in [5] is quite complicated. <p> Later, Buhrman et al. showed for the first time that fast, long-lived renaming using only read and write operations is possible <ref> [5] </ref>. Such algorithms are more portable and more widely applicable than algorithms that rely on special synchronisation primitives. The long-lived renaming solution presented in [5] is quite complicated. In particular, for different values of N and k, different algorithms must be combined, and various parameters chosen to satisfy certain constraints, in order to obtain a fast, long-lived (k (k + 1)=2)-renaming solution. <p> This resolves open questions left in <ref> [5] </ref> and [10]. Our 3 Actually, Burns and Peterson solved a more general problem, which they called `- assignment. An `-assignment protocol not only assigns names to processes, but also forces some processes to wait if too many request names concurrently. <p> We are grateful to Hagit Attiya for pointing this out to us. Reference M Time Complexity Space Complexity Fast? Long-Lived? [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes [10] 2k 1 fi (k 4 ) fi (k 4 ) Yes No <ref> [5] </ref> k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Thm. 2 2k 1 fi (k 4 ) fi (k 4 ) Yes Yes Table 1. <p> A comparison with previous read/write, wait-free M-renaming algorithms that are fast and/or long-lived. new long-lived (k (k + 1)=2)-renaming algorithm improves on the space and time complexity of the algorithm in <ref> [5] </ref>, and is also significantly simpler, as evidenced by the fact that we present full assertional proofs. This algorithm is similar to the one presented in [10] in that it consists of a grid of building blocks. However, we use a novel technique to make each building block fast. <p> We also show for the first time that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This algorithm is optimal with respect to the size of the name space. This resolves questions left open by <ref> [5] </ref> and [10]. While the latter algorithm is technically "fast" it still has quite high time complexity. It would be interesting to see if this can be improved upon by a more direct solution, as combining renaming algorithms tends to result in high time complexity.
Reference: 6. <author> J. Burns and G. Peterson, </author> <title> "The Ambiguity of Choosing", </title> <booktitle> Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1989, </year> <pages> pp. 145-157. </pages>
Reference-contexts: The long-lived M renaming problem <ref> [2, 5, 6, 10] </ref> is a generalisation of one-time renaming, in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> We are therefore motivated to seek renaming protocols whose destination name spaces are as small as possible. Burns and Peterson <ref> [6] </ref> and Herlihy and Shavit [8] have both shown that long-lived renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1. Wait-free, long-lived renaming was first solved for shared-memory systems by Burns and Peterson [6]. 3 Like most previous one-time renaming algorithms, the time <p> Burns and Peterson <ref> [6] </ref> and Herlihy and Shavit [8] have both shown that long-lived renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1. Wait-free, long-lived renaming was first solved for shared-memory systems by Burns and Peterson [6]. 3 Like most previous one-time renaming algorithms, the time complexity of Burns and Peterson's algorithm is dependent on N , the size of the original name space. Thus, it suffers from the same problem that long- lived renaming is intended to overcome. <p> Furthermore, the space requirements are (k 5 ) and, in some cases, are exponential in k. In this paper, we present a new read/write algorithm for fast, long-lived (k (k + 1)=2)-renaming and we also observe that this algorithm can be combined with that of Burns and Peterson <ref> [6] </ref> to achieve a fast, read/write solution to long- lived (2k 1)-renaming. This resolves open questions left in [5] and [10]. Our 3 Actually, Burns and Peterson solved a more general problem, which they called `- assignment. <p> We are grateful to Hagit Attiya for pointing this out to us. Reference M Time Complexity Space Complexity Fast? Long-Lived? <ref> [6] </ref> 2k 1 fi (N k 2 ) fi (N 2 ) No Yes [10] 2k 1 fi (k 4 ) fi (k 4 ) Yes No [5] k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Thm. 2 2k 1 <p> In particular, by combining our fast, long-lived renaming algorithm with the (non-fast) `-assignment algorithm (with ` = 2k 1) of Burns and Peterson <ref> [6] </ref>, fast, long-lived renaming can be achieved with a name space of size 2k 1. As explained in Section 1, if at most k processes concurrently access Burns and Peterson's algorithm, then their algorithm is wait-free.
Reference: 7. <author> C. A. R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming", </title> <journal> Communications of the ACM 12, </journal> <month> October </month> <year> 1969, </year> <pages> pp. </pages> <month> 576-580,583. </month>
Reference-contexts: Symbols in parentheses have the same binding power. We occasionally use parentheses to override these binding rules. We sometimes use Hoare triples <ref> [7] </ref> to denote the effects of a statement execution. To prove that an assertion I is an invariant, we show that I holds initially, and that no statement falsifies 5 I.
Reference: 8. <author> M. Herlihy and N. Shavit, </author> <title> "The Asynchronous Computability Theorem for tResilient Tasks", </title> <booktitle> Proceedings of the 25th ACM Symposium on Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 111-120. </pages>
Reference-contexts: We are therefore motivated to seek renaming protocols whose destination name spaces are as small as possible. Burns and Peterson [6] and Herlihy and Shavit <ref> [8] </ref> have both shown that long-lived renaming cannot be solved in a wait-free manner using atomic reads and writes unless M 2k 1.
Reference: 9. <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February </month> <year> 1987, </year> <pages> pp. 1-11. </pages>
Reference-contexts: Having described the overall structure of the algorithm, we now concentrate on how one building block is implemented. The long-lived building block used in [10] is based on a "resettable" version of Lamport's fast mutual exclusion technique <ref> [9] </ref>. The single Y bit in Lamport's technique is replaced by N Y -bits | one for each process. This ensures that, if a process p sets the Y variable (by setting Y [p]), then the Y variable stays set until p resets it.
Reference: 10. <author> M. Moir and J. Anderson, </author> <title> "Wait-Free Algorithms for Fast, Long-Lived Renaming", </title> <booktitle> Science of Computer Programming 25 (1995), </booktitle> <pages> pp. 1-39. </pages> <note> Preliminary version appeared in Proceedings of the 8th International Workshop on Distributed Algorithms, </note> <month> September, </month> <year> 1994, </year> <pages> pp. 141-155. </pages>
Reference-contexts: 1 Introduction In the one-time M renaming problem <ref> [2, 3, 4, 10] </ref>, each of a set of k processes with distinct identifiers ranging over f0; :::; N 1g is required to choose a distinct name ranging over f0; :::; M 1g, where M &lt; N . <p> The long-lived M renaming problem <ref> [2, 5, 6, 10] </ref> is a generalisation of one-time renaming, in which N processes repeatedly acquire and release names from f0; :::; M 1g. It is assumed that at most k processes concurrently request or hold names, and it is required that no two processes hold the same name concurrently. <p> This resolves open questions left in [5] and <ref> [10] </ref>. Our 3 Actually, Burns and Peterson solved a more general problem, which they called `- assignment. An `-assignment protocol not only assigns names to processes, but also forces some processes to wait if too many request names concurrently. <p> We are grateful to Hagit Attiya for pointing this out to us. Reference M Time Complexity Space Complexity Fast? Long-Lived? [6] 2k 1 fi (N k 2 ) fi (N 2 ) No Yes <ref> [10] </ref> 2k 1 fi (k 4 ) fi (k 4 ) Yes No [5] k (k + 1)=2 fi (k 3 ) fi (k 4 min (3 k ; N )) Yes Yes Thm. 2 2k 1 fi (k 4 ) fi (k 4 ) Yes Yes Table 1. <p> This algorithm is similar to the one presented in <ref> [10] </ref> in that it consists of a grid of building blocks. However, we use a novel technique to make each building block fast. <p> Similarly, a statement execution establishes an expression iff that expression does not hold before the statement execution, but holds after. 3 The Algorithm We now present our algorithm for fast (k (k +1)=2)-renaming. Like the algorithm presented in <ref> [10] </ref>, this algorithm is based on a grid of building blocks, as shown in Figure 1. To facilitate formal proofs, we have incorporated all the building blocks into a single algorithm, also shown in Figure 1. However, the building block structure should still be apparent. <p> We later show that, in either case, no other process acquires the same name concurrently. Having described the overall structure of the algorithm, we now concentrate on how one building block is implemented. The long-lived building block used in <ref> [10] </ref> is based on a "resettable" version of Lamport's fast mutual exclusion technique [9]. The single Y bit in Lamport's technique is replaced by N Y -bits | one for each process. <p> This is important to ensure that two processes to not concurrently hold the name at the same building block. Unfortunately, this approach necessitates reading all N Y -bits in order to determine whether the Y variable is set. This is why the algorithm in <ref> [10] </ref> is not fast. In the algorithm presented in this paper, we use at most k + 1 Y -components per building block. <p> By the definition of EN , the antecedent implies EN (p; p:i; p:j). Therefore :EN (q; p:i; p:j) holds, which implies that the consequent holds. 2 The following claims, which are proved in <ref> [10] </ref>, are used to prove the final two invariants. <p> We also show for the first time that fast, long-lived (2k 1)-renaming can be implemented with reads and writes. This algorithm is optimal with respect to the size of the name space. This resolves questions left open by [5] and <ref> [10] </ref>. While the latter algorithm is technically "fast" it still has quite high time complexity. It would be interesting to see if this can be improved upon by a more direct solution, as combining renaming algorithms tends to result in high time complexity.
Reference: 11. <author> G. Peterson, </author> <type> personal communication, </type> <month> November </month> <year> 1995. </year>
Reference-contexts: As explained in Section 1, if at most k processes concurrently access Burns and Peterson's algorithm, then their algorithm is wait-free. The worst-case time complexity of acquiring and releasing a name once is fi (N k 2 ) <ref> [11] </ref>. Thus, we have the following result, which is optimal with respect to the size of the name space.
References-found: 11

