URL: http://www.cs.unc.edu/~anderson/papers/dc93.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Composite Registers  
Author: James H. Anderson 
Keyword: atomicity, atomic register, composite register, concurrency, interleaving semantics, lineariz-ability, shared variable, snapshot CR Categories: D.4.1, D.4.2, F.3.1  
Note: To appear in Distributed Computing. Preliminary version was presented at the Ninth Annual ACM Symposium on Prin ciples of Distributed Computing [2]. Work supported, in part, at the University of Texas at Austin by Office of Naval Research Contract N00014-89-J-1913, and at the University of Maryland by an award from the University of Maryland General Research Board.  
Date: July 1989 Revised March 1991, February 1992  
Address: College Park College Park, Maryland 20742  
Affiliation: Department of Computer Science The University of Maryland at  
Abstract: We introduce a shared data object, called a composite register, that generalizes the notion of an atomic register. A composite register is an array-like shared data object that is partitioned into a number of components. An operation of a composite register either writes a value to a single component or reads the values of all components. A composite register reduces to an ordinary atomic register when there is only one component. In this paper, we show that multi-reader, single-writer atomic registers can be used to implement a composite register in which there is only one writer per component. In a related paper, we show how to use the composite register construction of this paper to implement a composite register with multiple writers per component. These two constructions show that it is possible to implement a shared memory that can be read in its entirety in a single snapshot operation, without using mutual exclusion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit, </author> <title> "Atomic Snapshots of Shared Memory," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing , 1990, </booktitle> <pages> pp. 1-14. </pages>
Reference-contexts: To read any set of memory locations, a process reads the entire composite register, and then selects the values of the components corresponding to this set. The problem of constructing a composite register from atomic registers has also been considered independently by Afek et al. <ref> [1] </ref>. They present two composite register constructions: the first implements a single-writer composite register from multi-reader, single-writer atomic registers, and the second implements a multi-writer composite register from multi-reader, multi-writer atomic registers. <p> The term item refers to a (val; id) pair. Fields seq [0] and seq <ref> [1] </ref> of Y [0] are arrays and are used to store the "sequence numbers" read from Z [0]; : : :; Z [R 1] by a 0-Write operation. <p> Note that each 0-Write operation makes two copies of Z [0]; : : : ; Z [R 1], one of which is stored in Y [0]:seq [0] and the other in Y [0]:seq <ref> [1] </ref>. <p> Z [0] Y [0] Writer 0 . . . . . Y <ref> [1] </ref> Writer C 1 Writer 1 Reader 0 Reader R 1 wc Before considering the Reader and Writer procedures in depth, several comments concerning notation are in order. The initialization requirement is defined by the initialization sections given with the shared variable declarations and within each procedure (if any). <p> First, note that Y [0]:val, Y [0]:wc, and Y [0]:seq [0] are modified only by statement 3 of Writer 0, and each execution of this statement increments the value of Y [0]:wc, modulo-3. Also, note that Y [0]:ss and Y [0]:seq <ref> [1] </ref> are modified only by statement 7 of Writer 0. With this in mind, consider an operation r of Reader j. Let v k denote the value r returns for component k, where 0 k &lt; C. <p> d : array [1::C 1] of itemtype; item : array [0::C 1] of itemtype; newseq : 0::2 begin =fl Select new sequence number differing from Writer 0's two copies fl= 0: read x := Y [0]; 1: select newseq such that newseq 6= x:seq [0; j] ^ newseq 6= x:seq <ref> [1; j] </ref>; =fl Can select such a value 2: write Z [j] := newseq; because newseq ranges over 0::2 fl= =fl Compute item [0::C 1] fl= 3: read a := Y [0]; =fl Read from Writer 0 fl= 4: read b := Y [1::C 1]; =fl Take snapshot of Writers other <p> Writers other than Writer 0 fl= 5: read c := Y [0]; =fl Read from Writer 0 fl= 6: read d := Y [1::C 1]; =fl Take snapshot of Writers other than Writer 0 fl= 7: read e := Y [0]; =fl Read from Writer 0 fl= 8: if e:seq <ref> [1; j] </ref> = newseq _ e:wc = a:wc 2 then item [0]; : : : ; item [C 1] := e:ss [0]; : : : ; e:ss [C 1] else if a:wc = c:wc then item [0]; item [1]; : : : ; item [C 1] := (a:val; a:id); b [1]; <p> := Y [0]; =fl Read from Writer 0 fl= 8: if e:seq [1; j] = newseq _ e:wc = a:wc 2 then item [0]; : : : ; item [C 1] := e:ss [0]; : : : ; e:ss [C 1] else if a:wc = c:wc then item [0]; item <ref> [1] </ref>; : : : ; item [C 1] := (a:val; a:id); b [1]; : : : ; b [C 1] else =fl c:wc = e:wc fl= item [0]; item [1]; : : : ; item [C 1] := (c:val; c:id); d [1]; : : : ; d [C 1] fi; 9: <p> [1; j] = newseq _ e:wc = a:wc 2 then item [0]; : : : ; item [C 1] := e:ss [0]; : : : ; e:ss [C 1] else if a:wc = c:wc then item [0]; item <ref> [1] </ref>; : : : ; item [C 1] := (a:val; a:id); b [1]; : : : ; b [C 1] else =fl c:wc = e:wc fl= item [0]; item [1]; : : : ; item [C 1] := (c:val; c:id); d [1]; : : : ; d [C 1] fi; 9: return (item [0]:val; : : : ; item [C 1]:val) end 8 <p> [C 1] := e:ss [0]; : : : ; e:ss [C 1] else if a:wc = c:wc then item [0]; item <ref> [1] </ref>; : : : ; item [C 1] := (a:val; a:id); b [1]; : : : ; b [C 1] else =fl c:wc = e:wc fl= item [0]; item [1]; : : : ; item [C 1] := (c:val; c:id); d [1]; : : : ; d [C 1] fi; 9: return (item [0]:val; : : : ; item [C 1]:val) end 8 procedure W riter0 (val : valtype) private var seq : array [0::1][0::R 1] of 0::2; wc : <p> else if a:wc = c:wc then item [0]; item <ref> [1] </ref>; : : : ; item [C 1] := (a:val; a:id); b [1]; : : : ; b [C 1] else =fl c:wc = e:wc fl= item [0]; item [1]; : : : ; item [C 1] := (c:val; c:id); d [1]; : : : ; d [C 1] fi; 9: return (item [0]:val; : : : ; item [C 1]:val) end 8 procedure W riter0 (val : valtype) private var seq : array [0::1][0::R 1] of 0::2; wc : 0::2; item : itemtype; ss : array [0::C 1] of itemtype; y <p> seq : array [0::1][0::R 1] of 0::2; wc : 0::2; item : itemtype; ss : array [0::C 1] of itemtype; y : array [1::C 1] of itemtype; n : 0::R 1 initialization wc = Y [0]:wc ^ item:id = Y [0]:id ^ (8i : 0 i &lt; R : seq <ref> [1; i] </ref> = Y [0]:seq [1; i]) ^ (8j : 0 j &lt; C : ss [j] = Y [0]:ss [j]) begin =fl Compute item, seq [0][0::R 1], and wc fl= 0: wc; item:val; item:id := wc 1; val; item:id + 1; 1: for n = 0 to R 1 do <p> of 0::2; wc : 0::2; item : itemtype; ss : array [0::C 1] of itemtype; y : array [1::C 1] of itemtype; n : 0::R 1 initialization wc = Y [0]:wc ^ item:id = Y [0]:id ^ (8i : 0 i &lt; R : seq <ref> [1; i] </ref> = Y [0]:seq [1; i]) ^ (8j : 0 j &lt; C : ss [j] = Y [0]:ss [j]) begin =fl Compute item, seq [0][0::R 1], and wc fl= 0: wc; item:val; item:id := wc 1; val; item:id + 1; 1: for n = 0 to R 1 do 2:n: read seq [0; n] <p> [n] =fl Read from Reader n fl= od; 3: write Y [0] := (item:val; item:id; seq [0::1][0::R 1]; ss [0::C 1]; wc); =fl Compute seq <ref> [1] </ref>[0::R 1] and ss [0::C 1] fl= 4: read y := Y [1::C 1]; =fl Take snapshot of other Writers fl= 5: ss [0]; ss [1]; : : : ; ss [C 1] := item; y [1]; : : : ; y [C 1]; 6: seq [1; 0]; : : : ; seq [1; R 1] := seq [0; 0]; : : : ; seq [0; R 1]; =fl Note: seq [1] is a copy of <p> [0] := (item:val; item:id; seq [0::1][0::R 1]; ss [0::C 1]; wc); =fl Compute seq <ref> [1] </ref>[0::R 1] and ss [0::C 1] fl= 4: read y := Y [1::C 1]; =fl Take snapshot of other Writers fl= 5: ss [0]; ss [1]; : : : ; ss [C 1] := item; y [1]; : : : ; y [C 1]; 6: seq [1; 0]; : : : ; seq [1; R 1] := seq [0; 0]; : : : ; seq [0; R 1]; =fl Note: seq [1] is a copy of seq [0] fl= 7: write Y [0] := (item:val; item:id; seq <p> wc); =fl Compute seq [1][0::R 1] and ss [0::C 1] fl= 4: read y := Y [1::C 1]; =fl Take snapshot of other Writers fl= 5: ss [0]; ss [1]; : : : ; ss [C 1] := item; y [1]; : : : ; y [C 1]; 6: seq <ref> [1; 0] </ref>; : : : ; seq [1; R 1] := seq [0; 0]; : : : ; seq [0; R 1]; =fl Note: seq [1] is a copy of seq [0] fl= 7: write Y [0] := (item:val; item:id; seq [0::1][0::R 1]; ss [0::C 1]; wc); 8: return end procedure <p> ss [0::C 1] fl= 4: read y := Y [1::C 1]; =fl Take snapshot of other Writers fl= 5: ss [0]; ss [1]; : : : ; ss [C 1] := item; y [1]; : : : ; y [C 1]; 6: seq [1; 0]; : : : ; seq <ref> [1; R 1] </ref> := seq [0; 0]; : : : ; seq [0; R 1]; =fl Note: seq [1] is a copy of seq [0] fl= 7: write Y [0] := (item:val; item:id; seq [0::1][0::R 1]; ss [0::C 1]; wc); 8: return end procedure W riter (i : 1::C 1; val <p> 5: ss [0]; ss <ref> [1] </ref>; : : : ; ss [C 1] := item; y [1]; : : : ; y [C 1]; 6: seq [1; 0]; : : : ; seq [1; R 1] := seq [0; 0]; : : : ; seq [0; R 1]; =fl Note: seq [1] is a copy of seq [0] fl= 7: write Y [0] := (item:val; item:id; seq [0::1][0::R 1]; ss [0::C 1]; wc); 8: return end procedure W riter (i : 1::C 1; val : valtype) private var item : itemtype initialization item:id = Y [i]:id begin 0: item:val; item:id := val; <p> For the specific situation depicted in Figure 4 (a), we can show that r returns the C values from the snapshot of w +1 . To see this, first observe that the value written to Z [j] by r : 2 is copied by w +1 to Y [0]:seq <ref> [1; j] </ref> prior to the occurrence of event r : 7. Because event w +2 : 3 doesn't modify Y [0]:seq [1], this implies that e:seq [1; j] = newseq when r executes statement 8 of the Reader procedure. <p> To see this, first observe that the value written to Z [j] by r : 2 is copied by w +1 to Y [0]:seq [1; j] prior to the occurrence of event r : 7. Because event w +2 : 3 doesn't modify Y [0]:seq <ref> [1] </ref>, this implies that e:seq [1; j] = newseq when r executes statement 8 of the Reader procedure. <p> To see this, first observe that the value written to Z [j] by r : 2 is copied by w +1 to Y [0]:seq <ref> [1; j] </ref> prior to the occurrence of event r : 7. Because event w +2 : 3 doesn't modify Y [0]:seq [1], this implies that e:seq [1; j] = newseq when r executes statement 8 of the Reader procedure. <p> This implies that events r : 3 and r : 5 both read the same value from Y [0]:wc, and hence a:wc = c:wc when r executes statement 8 of the Reader procedure. It can also be shown in this case that e:a <ref> [1; j] </ref> 6= newseq ^ e:wc 6= a:wc 2 when r executes statement 8 (i.e., the two cases above do not apply). <p> Lemma 1: Let r be an operation of Reader j, and let v and w be 0-Write operations such that last (Y [0]) = v at the state prior to r : 3 and last (Y [0]) = w at the state prior to r : 7. If r!e:seq <ref> [1; j] </ref> 6= r!newseq, then one of the following is true: w = v, w = v +1 , or w = v +2 . Proof: Let r, v, and w be as defined in the lemma. Assume that r!e:seq [1; j] 6= r!newseq. <p> If r!e:seq <ref> [1; j] </ref> 6= r!newseq, then one of the following is true: w = v, w = v +1 , or w = v +2 . Proof: Let r, v, and w be as defined in the lemma. Assume that r!e:seq [1; j] 6= r!newseq. By the text of the Reader procedure, r : 3 r : 7. <p> Hence, w 1 !seq [0; j] = r!newseq and w!seq [0; j] = r!newseq. By statement 6 of the procedure for Writer 0, w 1 !seq <ref> [1; j] </ref> = w 1 !seq [0; j] and w!seq [1; j] = w!seq [0; j]. Therefore, w 1 !seq [1; j] = r!newseq ^ w!seq [1; j] = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r <p> Hence, w 1 !seq [0; j] = r!newseq and w!seq [0; j] = r!newseq. By statement 6 of the procedure for Writer 0, w 1 !seq <ref> [1; j] </ref> = w 1 !seq [0; j] and w!seq [1; j] = w!seq [0; j]. Therefore, w 1 !seq [1; j] = r!newseq ^ w!seq [1; j] = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r : 7 or w : 3 r : 7 w <p> Hence, w 1 !seq [0; j] = r!newseq and w!seq [0; j] = r!newseq. By statement 6 of the procedure for Writer 0, w 1 !seq <ref> [1; j] </ref> = w 1 !seq [0; j] and w!seq [1; j] = w!seq [0; j]. Therefore, w 1 !seq [1; j] = r!newseq ^ w!seq [1; j] = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r : 7 or w : 3 r : 7 w : 7. In the former case, r!e:seq [1; j] = <p> By statement 6 of the procedure for Writer 0, w 1 !seq <ref> [1; j] </ref> = w 1 !seq [0; j] and w!seq [1; j] = w!seq [0; j]. Therefore, w 1 !seq [1; j] = r!newseq ^ w!seq [1; j] = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r : 7 or w : 3 r : 7 w : 7. In the former case, r!e:seq [1; j] = w!seq [1; j]. <p> 1 !seq <ref> [1; j] </ref> = r!newseq ^ w!seq [1; j] = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r : 7 or w : 3 r : 7 w : 7. In the former case, r!e:seq [1; j] = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is <p> = r!newseq ^ w!seq <ref> [1; j] </ref> = r!newseq : (1) Because last (Y [0]) = w at the state prior to r : 7, either w : 7 r : 7 or w : 3 r : 7 w : 7. In the former case, r!e:seq [1; j] = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is a contradiction. <p> In the former case, r!e:seq <ref> [1; j] </ref> = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is a contradiction. <p> In the former case, r!e:seq <ref> [1; j] </ref> = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is a contradiction. <p> In the former case, r!e:seq <ref> [1; j] </ref> = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is a contradiction. <p> In the former case, r!e:seq <ref> [1; j] </ref> = w!seq [1; j]. In the latter case, because statement 3 of Writer 0 does not alter the value of Y [0]:seq [1; j], we have r!e:seq [1; j] = w 1 !seq [1; j]. In either case, by (1), we have r!e:seq [1; j] = r!newseq, which is a contradiction. Thus, either w = v +1 or w = v +2 . 2 As explained informally in Section 4.1, there exists a state "during" the execution of each Read operation that corresponds to the "snapshot" taken by that operation. <p> Proof: Assume that r is an operation of Reader j. We consider four cases, based upon the conditional statement 8 of Reader j. Case 1: r!e:seq <ref> [1; j] </ref> = r!newseq. Let S be the set of 0-Write operations defined as follows: p is in S iff p is a 0-Write operation and p : 7 r : 7. <p> Then, last (Y [0]) equals either w or w +1 at the state prior to r : 7, and in the latter case, w +1 : 3 r : 7 w +1 : 7. Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref> or of Y [0]:ss [0::C 1], this implies that r!e:seq [1; j] = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; <p> Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref> or of Y [0]:ss [0::C 1], this implies that r!e:seq [1; j] = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; therefore, by (2), w!seq [0; j] = r!newseq ^ w!seq [1; j] <p> Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref> or of Y [0]:ss [0::C 1], this implies that r!e:seq [1; j] = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; therefore, by (2), w!seq [0; j] = r!newseq ^ w!seq [1; j] = r!newseq : (3) <p> does not alter the value of Y [0]:seq <ref> [1; j] </ref> or of Y [0]:ss [0::C 1], this implies that r!e:seq [1; j] = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; therefore, by (2), w!seq [0; j] = r!newseq ^ w!seq [1; j] = r!newseq : (3) We now show that r : 0 w : 3. Assume, to the contrary, that w : 3 r : 0. <p> of Y [0]:seq <ref> [1; j] </ref> or of Y [0]:ss [0::C 1], this implies that r!e:seq [1; j] = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; therefore, by (2), w!seq [0; j] = r!newseq ^ w!seq [1; j] = r!newseq : (3) We now show that r : 0 w : 3. Assume, to the contrary, that w : 3 r : 0. <p> r!e:seq <ref> [1; j] </ref> = w!seq [1; j] ^ (8k :: r!e:ss [k] = w!ss [k]) : (2) By statement 6 of the procedure for Writer 0, w!seq [0; j] = w!seq [1; j]. By assumption, r!e:seq [1; j] = r!newseq; therefore, by (2), w!seq [0; j] = r!newseq ^ w!seq [1; j] = r!newseq : (3) We now show that r : 0 w : 3. Assume, to the contrary, that w : 3 r : 0. By the text of the Reader procedure, r : 0 r : 7. Therefore, w : 3 r : 0 r : 7. <p> By the definition of w, we have r : 7 w +1 : 7. Therefore, w +1 : 3 r : 0 w +1 : 7. Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref>, this implies that r!x:seq [1; j] = w!seq [1; j]. Hence, by (3), r!newseq = r!x:seq [1; j], which, by statement 1 of the Reader procedure, is a contradiction. Thus, our assumption that w : 3 r : 0 is false, i.e., r : 0 w : 3. <p> By the definition of w, we have r : 7 w +1 : 7. Therefore, w +1 : 3 r : 0 w +1 : 7. Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref>, this implies that r!x:seq [1; j] = w!seq [1; j]. Hence, by (3), r!newseq = r!x:seq [1; j], which, by statement 1 of the Reader procedure, is a contradiction. Thus, our assumption that w : 3 r : 0 is false, i.e., r : 0 w : 3. Because r!e:seq [1; j] = r!newseq, by <p> Therefore, w +1 : 3 r : 0 w +1 : 7. Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref>, this implies that r!x:seq [1; j] = w!seq [1; j]. Hence, by (3), r!newseq = r!x:seq [1; j], which, by statement 1 of the Reader procedure, is a contradiction. Thus, our assumption that w : 3 r : 0 is false, i.e., r : 0 w : 3. Because r!e:seq [1; j] = r!newseq, by statement 8 of the <p> Therefore, w +1 : 3 r : 0 w +1 : 7. Because statement 3 of Writer 0 does not alter the value of Y [0]:seq <ref> [1; j] </ref>, this implies that r!x:seq [1; j] = w!seq [1; j]. Hence, by (3), r!newseq = r!x:seq [1; j], which, by statement 1 of the Reader procedure, is a contradiction. Thus, our assumption that w : 3 r : 0 is false, i.e., r : 0 w : 3. Because r!e:seq [1; j] = r!newseq, by statement 8 of the Reader procedure, (8k :: r!item [k] = r!e:ss <p> this implies that r!x:seq <ref> [1; j] </ref> = w!seq [1; j]. Hence, by (3), r!newseq = r!x:seq [1; j], which, by statement 1 of the Reader procedure, is a contradiction. Thus, our assumption that w : 3 r : 0 is false, i.e., r : 0 w : 3. Because r!e:seq [1; j] = r!newseq, by statement 8 of the Reader procedure, (8k :: r!item [k] = r!e:ss [k]). Therefore, by (2), (8k :: r!item [k] = w!ss [k]). By the definition of k , (8k :: k (r) = r!item [k]:id). <p> Therefore, t j= (8k : k &gt; 0 : Y [k] = w!ss [k]). By (4), this implies that t j= (8k : k &gt; 0 : Y [k]:val = r!item [k]:val ^ Y [k]:id = k (r)). Case 2: r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc = r!a:wc 2. <p> to r : 7. (v and w exist because, by our assumption concerning the initial Writes, there exists a 0-Write operation that precedes all Read operations.) Then, by the text of the procedures for Reader j and Writer 0, r!a:wc = v!wc ^ r!e:wc = w!wc : (5) Because r!e:seq <ref> [1; j] </ref> 6= r!newseq, by Lemma 1, one of the following holds: w = v, w = v +1 , or w = v +2 . Because r!e:wc = r!a:wc 2, by (5), w!wc = v!wc 2. Therefore, w = v +2 . <p> By (6), we have r : 2 w : 2:j r : 7. This implies that last (Z [j]) = r at the state prior to w : 2:j, and hence w!seq [0; j] = r!newseq. By statement 6 of the procedure for Writer 0, w!seq <ref> [1; j] </ref> = w!seq [0; j]; hence, by transitivity, w!seq [1; j] = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. <p> This implies that last (Z [j]) = r at the state prior to w : 2:j, and hence w!seq [0; j] = r!newseq. By statement 6 of the procedure for Writer 0, w!seq <ref> [1; j] </ref> = w!seq [0; j]; hence, by transitivity, w!seq [1; j] = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. <p> By statement 6 of the procedure for Writer 0, w!seq <ref> [1; j] </ref> = w!seq [0; j]; hence, by transitivity, w!seq [1; j] = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. However, we have assumed in Case 2 that r!e:seq [1; j] 6= r!newseq. Hence, we have r : 7 w : 7. By (6), this implies that w : 3 r : 7 w : 7. <p> statement 6 of the procedure for Writer 0, w!seq <ref> [1; j] </ref> = w!seq [0; j]; hence, by transitivity, w!seq [1; j] = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. However, we have assumed in Case 2 that r!e:seq [1; j] 6= r!newseq. Hence, we have r : 7 w : 7. By (6), this implies that w : 3 r : 7 w : 7. <p> Writer 0, w!seq <ref> [1; j] </ref> = w!seq [0; j]; hence, by transitivity, w!seq [1; j] = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. However, we have assumed in Case 2 that r!e:seq [1; j] 6= r!newseq. Hence, we have r : 7 w : 7. By (6), this implies that w : 3 r : 7 w : 7. <p> <ref> [1; j] </ref> = r!newseq. If w : 7 r : 7, then because last (Y [0]) = w at the state prior to r : 7, r!e:seq [1; j] = w!seq [1; j]. Therefore, by transitivity, r!e:seq [1; j] = r!newseq. However, we have assumed in Case 2 that r!e:seq [1; j] 6= r!newseq. Hence, we have r : 7 w : 7. By (6), this implies that w : 3 r : 7 w : 7. <p> Since statement 3 of Writer 0 does not alter the value of Y [0]:ss [0::C 1], and because v +1 and w are successive operations of the same Writer, this implies that (8k :: r!e:ss [k] = v +1 !ss [k]). Because r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc = r!a:wc 2, by statement 8 of the Reader procedure, (8k :: r!item [k] = r!e:ss [k]). Therefore, (8k :: r!item [k] = v +1 !ss [k]). By the definition of k , (8k :: k (r) = r!item [k]:id). <p> Therefore, t j= (8k : k &gt; 0 : Y [k] = v +1 !ss [k]). By (7), this implies that t j= (8k : k &gt; 0 : Y [k]:val = r!item [k]:val ^ Y [k]:id = k (r)). Case 3: r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc 6= r!a:wc 2 ^ r!a:wc = r!c:wc. <p> Because r!a:wc = r!c:wc, by (8), we have v!wc = v 0 !wc. Thus, because each 0-Write operation assigns wc := wc 1, and because is modulo-3 addition, v 0 6= v +1 and v 0 6= v +2 . Therefore, v 0 = v. Because r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc 6= r!a:wc 2 ^ r!a:wc = r!c:wc, by statement 8 of the Reader procedure, r!item [0]:val = r!a:val, r!item [0]:id = r!a:id, and (8k : k &gt; 0 : r!item [k] = r!b [k]). <p> By statement 4 of the Reader procedure, t j= (8k : k &gt; 0 : Y [k] = r!b [k]). By (9), this implies that t j= (8k : k &gt; 0 : Y [k]:val = r!item [k]:val ^ Y [k]:id = k (r)). Case 4: r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc 6= r!a:wc 2 ^ r!a:wc 6= r!c:wc. <p> This implies that v 6= v 0 . Therefore, v precedes v 0 , v 0 precedes or equals w, and either w = v or w = v +1 . This implies that v 0 = w. Because r!e:seq <ref> [1; j] </ref> 6= r!newseq ^ r!e:wc 6= r!a:wc 2 ^ r!a:wc 6= r!c:wc, by statement 8 of the Reader procedure, r!item [0]:val = r!c:val, r!item [0]:id = r!c:id, and (8k : k &gt; 0 : r!item [k] = r!d [k]). <p> By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner [4, 12, 14, 21]. The construction of this paper and the single-writer construction of Afek et al. <ref> [1] </ref> are both based upon the following insight: if a Read operation is overlapped by "too many" Write operations, then it returns the C values as read in a single snapshot by one of these overlapping Writes.
Reference: [2] <author> J. Anderson, </author> <title> "Composite Registers," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1990, </year> <pages> pp. 15-30. </pages>
Reference: [3] <author> J. Anderson, </author> <title> "Multi-Writer Composite Registers," </title> <type> Technical Report, </type> <institution> Department of Computer Science, The University of Maryland at College Park, </institution> <year> 1991. </year> <note> Preliminary version available as Technical Report TR.89.26, </note> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1989. </year>
Reference-contexts: We consider here the important question of whether atomic registers can be used to implement composite registers without waiting. We use a two-step approach in addressing this question. The results of this paper constitute the first step, and those of <ref> [3] </ref> the second. In this paper, we show that multi-reader, single-writer atomic registers can be used to construct a composite register in which there is only one writer per component (henceforth, called a single-writer composite register). In [3], we use the construction of this paper to implement a composite register in <p> The results of this paper constitute the first step, and those of <ref> [3] </ref> the second. In this paper, we show that multi-reader, single-writer atomic registers can be used to construct a composite register in which there is only one writer per component (henceforth, called a single-writer composite register). In [3], we use the construction of this paper to implement a composite register in which several writers per component are allowed (henceforth, called a multi-writer composite register). <p> They present two composite register constructions: the first implements a single-writer composite register from multi-reader, single-writer atomic registers, and the second implements a multi-writer composite register from multi-reader, multi-writer atomic registers. By contrast, our two constructions (the one in this paper and the one in <ref> [3] </ref>) together implement a multi-writer composite register using only single-writer atomic registers. Thus, our constructions also solve the problem of implementing a multi-writer atomic register (the case in which there is only one component) from single-writer ones.
Reference: [4] <author> J. Anderson and M. Gouda, </author> <title> "The Virtue of Patience: Concurrent Programming With and Without Waiting," </title> <type> Technical Report TR.90.23, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1990. </year>
Reference-contexts: It is shown in [6, 7] that composite registers can be used to implement any shared data object that can either be read, written, or modified by a commutative PRMW operation in a wait-free manner. These results stand in sharp contrast to those of <ref> [4, 14] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The rest of the paper is organized as follows. <p> Note that this restriction constrains those statements that access shared variables. * Wait-Freedom Restriction: As mentioned in the introduction, each procedure is required to be "wait-free," i.e., idle-waiting primitives and unbounded busy-waiting loops are not allowed. (A more formal 3 definition of wait-freedom is given in <ref> [4] </ref>.) We now define several concepts that are needed to state the correctness condition for a construction. These definitions apply to a given construction. A state is an assignment of values to all variables (private and shared) of the construction. One or more states are designated as initial states. <p> By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [4, 12, 14, 21] </ref>.
Reference: [5] <author> J. Anderson and M. Gouda, </author> <title> "A Criterion for Atomicity," </title> <journal> Formal Aspects of Computing: The International Journal of Formal Methods, </journal> <volume> Vol. 4, No. 3, </volume> <month> May </month> <year> 1992, </year> <pages> pp. 273-298. </pages>
Reference: [6] <author> J. Anderson and B. Groselj, </author> <title> "Pseudo Read-Modify-Write Operations: Bounded Wait-Free Implementations," </title> <booktitle> Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 579, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 52-70. </pages> <note> Expanded version to appear in Science of Computer Programming </note> . 
Reference-contexts: Composite registers are quite powerful and can be used to implement a number of interesting shared data objects without waiting. For example, as shown in <ref> [6, 7] </ref>, composite registers can be used to implement wait-free shared data objects with "pseudo" read-modify-write (PRMW) operations. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable 1 based upon the original value of that variable. <p> However, unlike an RMW operation, a PRMW operation does not return the value of the variable that it modifies. An operation that increments a shared variable without returning its value is an example of a PRMW operation. It is shown in <ref> [6, 7] </ref> that composite registers can be used to implement any shared data object that can either be read, written, or modified by a commutative PRMW operation in a wait-free manner. <p> This has the effect of reducing the general multi-writer case to the two-writer case. Afek et al. do not resort to recursion, and as a result, their solution is polynomial in both space and time. The results of <ref> [6, 7] </ref> show that composite registers are quite powerful and can be used to implement a variety of other nontrivial shared data objects without waiting. It remains to be seen whether other interesting applications exist.
Reference: [7] <author> J. Aspnes and M. Herlihy, </author> <title> "Wait-Free Data Structures in the Asynchronous PRAM Model," </title> <booktitle> Proceedings of the Second Annual ACM Symposium on Parallel Architectures and Algorithms, </booktitle> <month> July, </month> <year> 1990. </year>
Reference-contexts: Composite registers are quite powerful and can be used to implement a number of interesting shared data objects without waiting. For example, as shown in <ref> [6, 7] </ref>, composite registers can be used to implement wait-free shared data objects with "pseudo" read-modify-write (PRMW) operations. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable 1 based upon the original value of that variable. <p> However, unlike an RMW operation, a PRMW operation does not return the value of the variable that it modifies. An operation that increments a shared variable without returning its value is an example of a PRMW operation. It is shown in <ref> [6, 7] </ref> that composite registers can be used to implement any shared data object that can either be read, written, or modified by a commutative PRMW operation in a wait-free manner. <p> This has the effect of reducing the general multi-writer case to the two-writer case. Afek et al. do not resort to recursion, and as a result, their solution is polynomial in both space and time. The results of <ref> [6, 7] </ref> show that composite registers are quite powerful and can be used to implement a variety of other nontrivial shared data objects without waiting. It remains to be seen whether other interesting applications exist.
Reference: [8] <author> B. Awerbuch, L. Kirousis, E. Kranakis, P. Vitanyi, </author> <title> "On Proving Register Atomicity," </title> <type> Report CS-R8707, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1987. </year> <title> A shorter version entitled "A Proof Technique for Register Atomicity" appeared in Proceedings of the Eighth Conference on Foundations of Software Techniques and Theoretical Computer Science, </title> <booktitle> Lecture Notes in Computer Science 338, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> pp. 286-303. 23 </pages>
Reference-contexts: Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in [26], Proposition 3 in [19], and the definition of an atomic run and the Shrinking Function Theorem in <ref> [8] </ref>. The correctness proof for the Shrinking Lemma is given in an appendix. The proof is somewhat tedious, but is not hard. First, the precedence relation on operations in history h is augmented by adding pairs of operations.
Reference: [9] <author> B. Bloom, </author> <title> "Constructing Two-Writer Atomic Registers," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> December </month> <year> 1988, </year> <pages> pp. 1506-1514. </pages>
Reference: [10] <author> J. Burns and G. Peterson, </author> <title> "Constructing Multi-Reader Atomic Values from Non-Atomic Values," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 222-231. </pages>
Reference: [11] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Whenever we say that a given assertion holds without referring to a particular state, we mean that the assertion is an invariant ; i.e., it is true at each state of every history. Let E and F be two expressions over the variables of a construction. Following <ref> [11] </ref>, we say that the assertion E unless F holds iff for every pair of consecutive states in any history, if E ^ :F holds in the first state, then E _ F holds in the second state. We assume that each state in every history is distinct.
Reference: [12] <author> B. Chor, A. Israeli, and M. Li, </author> <title> "On Processor Coordination Using Asynchronous Hardware," </title> <booktitle> Principles of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 86-97. </pages>
Reference-contexts: By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [4, 12, 14, 21] </ref>.
Reference: [13] <author> P. Courtois, F. Heymans, and D. Parnas, </author> <title> "Concurrent Control with Readers and Writers," </title> <journal> Communications of the ACM , Vol. </journal> <volume> 14, No. 10, </volume> <month> October </month> <year> 1971, </year> <pages> pp. 667-668. </pages>
Reference-contexts: This work shows that, using only atomic registers of the simplest kind, the classical readers-writers problem <ref> [13] </ref> can be solved without requiring either readers or writers to wait. In this paper, we go a step further by defining a new shared data object, called a composite register , that generalizes the notion of an atomic register.
Reference: [14] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <month> January </month> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: It is shown in [6, 7] that composite registers can be used to implement any shared data object that can either be read, written, or modified by a commutative PRMW operation in a wait-free manner. These results stand in sharp contrast to those of <ref> [4, 14] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The rest of the paper is organized as follows. <p> By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [4, 12, 14, 21] </ref>.
Reference: [15] <author> M. Herlihy and J. Wing, </author> <title> "Linearizability: A Correctness Condition for Concurrent Objects," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <month> July </month> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: Intuitively, a history is linearizable if every operation in the history "appears" to take effect at some point between its first and last events. It can be shown that the following definition is equivalent to the more general definition of linearizability given by Herlihy and Wing in <ref> [15] </ref>, when restricted to the special case of constructing a composite register. Linearizable Histories: Let h be a well-formed history of a construction.
Reference: [16] <author> A. Israeli and M. Li, </author> <title> "Bounded Time-Stamps," </title> <booktitle> Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 371-382. </pages>
Reference: [17] <author> L. Kirousis, E. Kranakis, and P. Vitanyi, </author> <title> "Atomic Multireader Register," </title> <booktitle> Proceedings of the Second International Workshop on Distributed Computing , Lecture Notes in Computer Science 312, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987, </year> <pages> pp. 278-296. </pages>
Reference: [18] <author> L. Lamport, </author> <title> "Concurrent Reading and Writing," </title> <journal> Communications of the ACM , Vol. </journal> <volume> 20, No. 11, </volume> <month> Novem-ber </month> <year> 1977, </year> <pages> pp. 806-811. </pages>
Reference-contexts: The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [18, 19, 22, 24] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [19] <author> L. Lamport, </author> <title> "On Interprocess Communication, Parts I and II," </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, </volume> <year> 1986, </year> <pages> pp. 77-101. </pages>
Reference-contexts: The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [18, 19, 22, 24] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation. <p> Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in [26], Proposition 3 in <ref> [19] </ref>, and the definition of an atomic run and the Shrinking Function Theorem in [8]. The correctness proof for the Shrinking Lemma is given in an appendix. The proof is somewhat tedious, but is not hard.
Reference: [20] <author> M. Li, J. Tromp, and P. Vitanyi, </author> <title> "How to Construct Wait-Free Variables," </title> <booktitle> Proceedings of International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science 372, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 488-505. </pages>
Reference: [21] <author> M. Loui and H. Abu-Amara, </author> <title> "Memory Requirements for Agreement Among Unreliable Asynchronous Processes," </title> <booktitle> Advances in Computing Research, </booktitle> <publisher> JAI Press, </publisher> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [4, 12, 14, 21] </ref>.
Reference: [22] <author> J. Misra, </author> <title> "Axioms for Memory Access in Asynchronous Hardware Systems," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 8, No. 1, </volume> <month> January </month> <year> 1986, </year> <pages> pp. 142-153. </pages>
Reference-contexts: The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [18, 19, 22, 24] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [23] <author> R. Newman-Wolfe, </author> <title> "A Protocol for Wait-Free, Atomic, Multi-Reader Shared Variables," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 232-248. </pages>
Reference: [24] <author> G. Peterson, </author> <title> "Concurrent Reading While Writing," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, </volume> <year> 1983, </year> <pages> pp. 46-55. 24 </pages>
Reference-contexts: The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [18, 19, 22, 24] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [25] <author> G. Peterson and J. Burns, </author> <title> "Concurrent Reading While Writing II: The Multi-Writer Case," </title> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 383-392. </pages>
Reference: [26] <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> "The Elusive Atomic Register, Revisited," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 206-221. </pages>
Reference-contexts: Write Precedence orders Write operations of one component with respect to Write operations of another component. Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in <ref> [26] </ref>, Proposition 3 in [19], and the definition of an atomic run and the Shrinking Function Theorem in [8]. The correctness proof for the Shrinking Lemma is given in an appendix. The proof is somewhat tedious, but is not hard. <p> Using the construction of <ref> [26] </ref>, S (1; B; 1; R) = O (R 2 + BR), and using the construction of [27], S (1; B; 1; 1) = O (B); both of these constructions are asymptotically optimal.
Reference: [27] <author> J. Tromp, </author> <title> "How to Construct an Atomic Variable," </title> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 392, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 292-302. </pages>
Reference-contexts: Using the construction of [26], S (1; B; 1; R) = O (R 2 + BR), and using the construction of <ref> [27] </ref>, S (1; B; 1; 1) = O (B); both of these constructions are asymptotically optimal. This yields S (C; B; 1; R) = O (R 2 + CBR) + S (C 1; B; 1; R + 1).
Reference: [28] <author> P. Vitanyi and B. Awerbuch, </author> <title> "Atomic Shared Register Access by Asynchronous Hardware," </title> <booktitle> Proceedings of the 27th IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 233-243. 25 </pages>
References-found: 28

