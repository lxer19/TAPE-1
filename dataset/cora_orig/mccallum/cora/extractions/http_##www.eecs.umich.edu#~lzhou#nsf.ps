URL: http://www.eecs.umich.edu/~lzhou/nsf.ps
Refering-URL: http://www.eecs.umich.edu/~lzhou/
Root-URL: http://www.cs.umich.edu
Phone: (313) 763-0391  
Title: MDARTS: A Multiprocessor Database Architecture for Real-Time  
Author: Systems 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-Time Computing Laboratory Computer Science and Engineering Division Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: Some of the advanced real-time systems being proposed, such as the Next Generation Workstation/Machine Controller (NGC) for automated factories, require a built-in database to support concurrent data access and provide well-defined interfaces between software modules. However, conventional database systems do not provide the performance levels or response time guarantees needed by real-time applications. To address the need for high-performance real-time database systems, we propose to design, implement, and evaluate an object-oriented software system called Multiprocessor Database Architecture for Real-Time Systems (MDARTS). An important feature of MDARTS is that it supports explicit specification of real-time requirements and semantic constraints at an object-granularity level. The database examines these specifications at runtime during application initialization and dynamically adjusts its data management strategy accordingly to provide hard real-time guarantees. For maximum performance on shared-memory multiprocessors, MDARTS supports concurrent, direct, shared-memory data access. Prior real-time database systems do not support per-object dynamic configuration during initialization, and they either work only on uniprocessors or use relatively slow inter-process communication for all transactions. The unique design of MDARTS will support a transaction execution time two to three orders of magnitude faster than current real-time database systems for multiprocessors. For data access with less stringent timing constraints, MDARTS also supports remote transactions across networks and provides interfaces to external database systems. Once we have implemented the basic MDARTS architecture, we will demonstrate its capabilities by using it to develop distributed, open architecture controllers for actual manufacturing machine tools. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert Abbott and Hecktor Garcia-Molina. </author> <title> Scheduling real-time transactions. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 71-81, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: primary strategies 1) schedule transactions according to task priorities, 2) minimize delays and uncertainties associated with concurrency control and locking, and 3) use memory-based databases or fast database hardware. 2.2 Transaction and I/O Scheduling Several researchers have investigated transaction and I/O scheduling algorithms that support different real-time needs and priorities <ref> [1, 8, 35, 48, 44] </ref>. Some commercial DBMSs support priority-based transaction scheduling [17, 36]. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance.
Reference: [2] <author> Bruce Anderson. </author> <title> Next generation workstation/machine controller (NGC). </title> <booktitle> In Proc. </booktitle> <volume> IPC '92, </volume> <pages> pages xix-xxvi, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: To solve data sharing problems consistently and efficiently, we need a novel approach to data management that satisfies real-time requirements. The Next Generation Workstation/Machine Controller (NGC) for automated factories is representative of the current trend toward distributed real-time architectures <ref> [2, 30] </ref>. The NGC is a software architecture specification for advanced machine tool controllers. It is intended to achieve standardization in the controller field and accelerate technology transfer from laboratories to industry. The NGC architecture is designed for high-performance real-time computing platforms such as VME-based shared-memory multiprocessors.
Reference: [3] <author> Thomas E. Anderson. </author> <title> The performance of spin lock alternatives for shared-memory multiprocessors. </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Multiple MDARTS handle objects corresponding to the same database object may exist in a distributed application, and each will store and retrieve data from the same shared-memory location. For mutual exclusion on shared-memory data in multiprocessors, we will use spin-lock queues such as described by Anderson in <ref> [3] </ref>. For maximum performance, transactions must directly access data in shared memory without communicating with a separate database server process. However, without a database process to manage concurrency, the database objects must supply their own concurrency control. In other words, the database objects should be atomic data types [53, 42].
Reference: [4] <author> Peter M. G. Apers, Carel A. van den Berg, Jan Flokstra, Paul W. P. J. Grefen, Martin L. Kersten, and Annita N. Wilschut. Prisma/db: </author> <title> A parallel, main memory relational dbms. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 541-554, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems <ref> [4, 16, 26, 27] </ref>. Garcia-Molina and Salem presented an excellent overview of main memory database research [16].
Reference: [5] <author> B. R. Badrinath and Krithi Ramamritham. </author> <title> Synchronizing transactions on objects. </title> <journal> IEEE Trans. Computers, </journal> <volume> 37(5) </volume> <pages> 541-547, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Synchronization delays caused by locking can be reduced if the frequency of locking conflicts is reduced. One approach to reducing locking conflicts is to adjust the lock granularity to lock only data that are affected by each 3 transaction <ref> [5, 37, 46] </ref>. Reducing lock granularity increases space overhead for locking, and it can degrade per-formance if many locks must be acquired to perform a transaction. Therefore, the locking granularity should be tuned to transaction characteristics. <p> When possible, use data versioning [46] or multiple data copies [51] to permit concurrent read and write operations without locking. * Match locking granularity with data semantics. This ensures that locking does not unnecessarily restrict concurrency. Sha et al. [37], Badrinath and Ramamritham <ref> [5] </ref>, and Son [46] each propose locking only the data affected by a transaction. However, identifying affected data and locking only those data are non-trivial problems in conventional database systems, where the data affected by a transaction are determined during query processing at runtime.
Reference: [6] <author> B. R. Badrinath and Krithi Ramamritham. </author> <title> Semantics-based concurrency control: Beyond commutativity. </title> <journal> ACM Trans. Database Systems, </journal> <volume> 17(1) </volume> <pages> 163-199, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Therefore, the locking granularity should be tuned to transaction characteristics. Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization <ref> [6, 15, 25] </ref>. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether [46, 50, 51, 52]. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods.
Reference: [7] <author> Grady Booch. </author> <title> Object Oriented Design with Applications. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The sensor readings and other real-time control parameters may need to be saved for off-line analysis. The challenge here is that the logging process must be fast enough to keep up with the rate those data items are generated. Booch <ref> [7] </ref> shows how C++ can be used to access a relational database system. The OZ+ object-oriented DBMS [55] uses an underlying relational database to supply object persistence. Likewise, MDARTS can interface with external file-based DBMSs. MDARTS can construct handles to external databases that hide the database-specific queries from application programs.
Reference: [8] <author> A. P. Buchmann, D. R. McCarthy, M. Hsu, and U. Dayal. </author> <title> Time-critical database scheduling: A framework for integrating real-time scheduling and concurrency control. </title> <booktitle> In Proc. IEEE Int'l Conf. on Data Engineering, </booktitle> <pages> pages 470-480, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: primary strategies 1) schedule transactions according to task priorities, 2) minimize delays and uncertainties associated with concurrency control and locking, and 3) use memory-based databases or fast database hardware. 2.2 Transaction and I/O Scheduling Several researchers have investigated transaction and I/O scheduling algorithms that support different real-time needs and priorities <ref> [1, 8, 35, 48, 44] </ref>. Some commercial DBMSs support priority-based transaction scheduling [17, 36]. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance. <p> This problem and its contributing factors have been the focus of most real-time database research. One approach to RTDBS concurrency control is to abandon traditional concurrency control protocols such as two-phase locking that guarantee serializability but lead to transaction rollback delays <ref> [8, 32] </ref>. Lin [29, 28] suggests that, for real-time applications, data inconsistent with the external world can be worse than internally inconsistent data. <p> This temporary priority boost helps lower-priority tasks complete transactions and release their locks. Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications <ref> [8, 19, 20, 34, 45] </ref>. For example, Huang et al. [20] advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted. <p> By registering application needs during initialization, MDARTS will be able to track resource allocation at runtime and guarantee response times before the actual real-time transactions are performed. Prior RTDBS research either makes guarantees a priori with off-line static analysis of applications [43] or makes dynamic guarantees during transaction processing <ref> [8] </ref>. Both of these approaches have significant disadvantages. Off-line analysis of transactions is not always feasible, especially for complex, distributed applications. Dynamic transaction scheduling imposes substantial overhead and cannot prevent overload conditions.
Reference: [9] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The gemstone object database management system. </title> <booktitle> volume 34, </booktitle> <pages> pages 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: MDARTS is also extensible; one can define new semantic constraints and integrate them seamlessly with MDARTS without having to recompile the MDARTS library. Although there are a number of commercial object-oriented DBMS (such as GemStone <ref> [9] </ref>, ObjectStore [21] and Objectivity/DB [22]) and "real-time" DBMS (such as GDX [17] and RTA [36]) products on the market, none of them support the performance level and predictability that MDARTS is designed for.
Reference: [10] <author> James O. Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Once an object has been constructed from its constraint string, it will be possible to query that database object, e.g., to determine how fast its guaranteed response times will be. 3.2 Implementation Strategies 3.2.1 Implementation of the Contracting Mechanism MDARTS uses exemplar-based programming to construct database objects <ref> [10] </ref>. Exemplar-based programming uses a set of prototype "exemplar" objects to instantiate objects at runtime. The exemplar objects recognize their own particular set of constraints and clone themselves if they can meet all of the constraints specified in an object 8 construction request.
Reference: [11] <author> Ingemar J. Cox. </author> <title> C++ language support for guaranteed initialization, safe termination and error recovery in robotics. </title> <booktitle> In Proc. IEEE Int'l Conf. on Robotics and Automation, </booktitle> <volume> volume 1, </volume> <pages> pages 641-643, </pages> <year> 1988. </year>
Reference-contexts: We will use the C++ language [49] to implement MDARTS. We chose C++ because of its wide availability, runtime efficiency, compatibility with C, and object-oriented features. Some advantages of C++ for real-time software are discussed in the literature <ref> [11, 12] </ref>. To enhance the portability of our implementation, we will use only standard features of C++ rather than adding language extensions.
Reference: [12] <author> Ingemar J. Cox, David A. Kapilow, Walter J. Kropfl, and Jonathan E. Shopiro. </author> <title> Real-time software for robotics. </title> <journal> AT&T Technical Journal, </journal> <volume> 67(2) </volume> <pages> 61-71, </pages> <month> March/April </month> <year> 1988. </year>
Reference-contexts: We will use the C++ language [49] to implement MDARTS. We chose C++ because of its wide availability, runtime efficiency, compatibility with C, and object-oriented features. Some advantages of C++ for real-time software are discussed in the literature <ref> [11, 12] </ref>. To enhance the portability of our implementation, we will use only standard features of C++ rather than adding language extensions.
Reference: [13] <author> David Detlefs, Maurice Herlihy, and Jeannette Wing. </author> <title> Inheritance of synchronization and recovery properties in Avalon/C++. </title> <journal> IEEE Computer, </journal> <volume> 21(12) </volume> <pages> 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: It is also possible to implement atomicity in a base class and inherit this property in derived subclasses <ref> [13] </ref>. MDARTS shared-memory objects differ from atomic data types in that the handle parts of the objects are fragmented across multiple separate processes.
Reference: [14] <author> T. H. Dineen, P. J. Leach, Nathaniel W. Mishkin, Joseph N. Pato, and Geoffrey L. Wyant. </author> <title> The network computing architecture and system: An environment for developing distributed applications. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <pages> pages 385-398, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The SDM keeps track of the location and identity of shared-memory objects and also constructs its own database handle for each object to service remote requests. For RPCs, we will use the Network Computing System (NCS) RPC library from Hewlett Packard <ref> [14] </ref>. NCS was chosen as the core technology for the OSF Distributed Computing Environment (DCE). Some advantages of NCS over Sun RPC are described in [31]. Although we use NCS, our architecture is not dependent upon NCS in any fundamental way.
Reference: [15] <author> Lisa B. Cingiser DiPippo and Victor Fay Wolfe. </author> <title> Object-based semantic real-time concurrency control. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 87-96, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Therefore, the locking granularity should be tuned to transaction characteristics. Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization <ref> [6, 15, 25] </ref>. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether [46, 50, 51, 52]. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods.
Reference: [16] <author> Hector Garcia-Molina and Kenneth Salem. </author> <title> Main memory database systems: An overview. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 509-516, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems <ref> [4, 16, 26, 27] </ref>. Garcia-Molina and Salem presented an excellent overview of main memory database research [16]. <p> Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems [4, 16, 26, 27]. Garcia-Molina and Salem presented an excellent overview of main memory database research <ref> [16] </ref>. The primary limitation of conventional main memory database systems, from the perspective of hard real-time applications, is that these systems are designed to maximize average transaction throughput rather than to minimize worst-case individual transaction times.
Reference: [17] <author> GDX. </author> <title> sales literature of Firmware Associates, </title> <publisher> Inc., </publisher> <address> West Chester, PA, </address> <year> 1992. </year>
Reference-contexts: MDARTS is also extensible; one can define new semantic constraints and integrate them seamlessly with MDARTS without having to recompile the MDARTS library. Although there are a number of commercial object-oriented DBMS (such as GemStone [9], ObjectStore [21] and Objectivity/DB [22]) and "real-time" DBMS (such as GDX <ref> [17] </ref> and RTA [36]) products on the market, none of them support the performance level and predictability that MDARTS is designed for. <p> Some commercial DBMSs support priority-based transaction scheduling <ref> [17, 36] </ref>. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance. File-based databases in particular can benefit from transaction and I/O scheduling according to priorities.
Reference: [18] <author> Marc H. Graham. </author> <title> Issues in real-time data management. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(3) </volume> <pages> 185-202, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The inadequacy of conventional database systems for real-time applications has spawned the field of real-time database systems (RTDBSs). RTDBSs are usually considered to be functionally equivalent to conventional database systems except that they provide fast, guaranteed response times <ref> [18, 35] </ref>. Although some progress in the field of RTDBSs has been made, most of the work has focused on specific sub-problems such as transaction scheduling. <p> Fundamental database properties such as serializability may be called into question occasionally, but one must be careful not to lose the very properties for which the database is needed. We agree with Graham <ref> [18] </ref>, who claims that serializability is indispensable for correct interleaving of concurrent transactions. MDARTS is thus designed to meet hard deadlines while preserving serializability.
Reference: [19] <author> Jayant R. Haritsa, Michael J. Carey, and Miron Livny. </author> <title> Data access scheduling in firm real-time database systems. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(3) </volume> <pages> 203-241, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This temporary priority boost helps lower-priority tasks complete transactions and release their locks. Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications <ref> [8, 19, 20, 34, 45] </ref>. For example, Huang et al. [20] advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted.
Reference: [20] <author> Jiandong Huang, John A. Stankovic, Krithi Ramamritham, Don Towsley, and Bhaskar Purimetla. </author> <title> Priority inheritance in soft real-time databases. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(3) </volume> <pages> 243-268, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This temporary priority boost helps lower-priority tasks complete transactions and release their locks. Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications <ref> [8, 19, 20, 34, 45] </ref>. For example, Huang et al. [20] advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted. <p> Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications [8, 19, 20, 34, 45]. For example, Huang et al. <ref> [20] </ref> advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted. Synchronization delays caused by locking can be reduced if the frequency of locking conflicts is reduced.
Reference: [21] <author> Object Design Inc. </author> <title> ObjectStore Reference Manual. </title> <address> Burlington, MA. </address>
Reference-contexts: MDARTS is also extensible; one can define new semantic constraints and integrate them seamlessly with MDARTS without having to recompile the MDARTS library. Although there are a number of commercial object-oriented DBMS (such as GemStone [9], ObjectStore <ref> [21] </ref> and Objectivity/DB [22]) and "real-time" DBMS (such as GDX [17] and RTA [36]) products on the market, none of them support the performance level and predictability that MDARTS is designed for.
Reference: [22] <author> Objectivity Inc. </author> <title> Objectivity Database Reference Manual. </title> <address> Menlo Park, CA. </address>
Reference-contexts: MDARTS is also extensible; one can define new semantic constraints and integrate them seamlessly with MDARTS without having to recompile the MDARTS library. Although there are a number of commercial object-oriented DBMS (such as GemStone [9], ObjectStore [21] and Objectivity/DB <ref> [22] </ref>) and "real-time" DBMS (such as GDX [17] and RTA [36]) products on the market, none of them support the performance level and predictability that MDARTS is designed for.
Reference: [23] <author> David Jordan. </author> <title> Instantiation of C++ objects in shared memory. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 21-28, </pages> <month> March/April </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Specifically, pointers to data or to functions cannot be shared easily across different processes. In C++, objects often contain pointers to functions (most often in the form of a pointer to a virtual function table). Jordan <ref> [23] </ref> discusses this problem and presents an approach to instantiating C++ objects in shared memory. Unfortunately, Jordan's methods rely on virtual memory and will not work for real-time operating systems, such as VME-based VxWorks, that do not support virtual memory.
Reference: [24] <author> Gregor Kiczales and John Lamping. </author> <title> Operating systems: </title> <booktitle> Why object-oriented? In Proc. of IWOOOS, </booktitle> <pages> pages 25-30, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: 0.866, 3.4"); /* Corresponding declaration of MDARTS variable in control task: */ static ReadOnlyDbArray&lt;Point&gt; position_sensor_array"("position_sensors", "read &lt;= 80usec""); /* Control task reads the data: */ int i = position_sensor_array.size"(") - 1; Point end_effector_position = position_sensor_array"(i"); Kiczales and Lamping call the problem of choosing a service implementation strategy a mapping dilemma <ref> [24] </ref>. Since the service provider cannot control client usage patterns, successful resolution of mapping dilemmas requires prior knowledge of client needs. In some cases, it is possible to collect historical usage patterns on a per-client basis and use these patterns to predict future usage.
Reference: [25] <author> Tei-Wei Kuo and Aloysius K. Mok. </author> <title> Ssp: a semantics-based protocol for real-time data access. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 76-86, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Therefore, the locking granularity should be tuned to transaction characteristics. Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization <ref> [6, 15, 25] </ref>. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether [46, 50, 51, 52]. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods.
Reference: [26] <author> Tobin J. Lehman, Eugene J. Shekita, and Luis-Felipe Cabrera. </author> <title> An evaluation of starburst's memory resident storage component. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 4(6) </volume> <pages> 555-565, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems <ref> [4, 16, 26, 27] </ref>. Garcia-Molina and Salem presented an excellent overview of main memory database research [16].
Reference: [27] <author> Kai Li and Jeffrey F. Naughton. </author> <title> Multiprocessor main memory transaction processing. </title> <booktitle> In Proc. IEEE Int'l Symp. on Databases in Parallel and Distributed Systems, </booktitle> <pages> pages 177-187, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems <ref> [4, 16, 26, 27] </ref>. Garcia-Molina and Salem presented an excellent overview of main memory database research [16]. <p> The primary limitation of conventional main memory database systems, from the perspective of hard real-time applications, is that these systems are designed to maximize average transaction throughput rather than to minimize worst-case individual transaction times. For example, the TPK multiprocessor main memory database system reported in <ref> [27] </ref> achieves an average throughput of over 1,300 transactions per second on a multiprocessor with five one-MIPS processors. If TPK's 1,300 transactions per second corresponded to a guaranteed transaction time of one millisecond, it would be sufficient for many hard real-time systems (especially since much faster processors are now available).
Reference: [28] <author> Kwei-Jay Lin. </author> <title> Consistency issues in real-time database systems. </title> <booktitle> In 22nd Hawaii Int'l Conf. on System Sciences, </booktitle> <month> January </month> <year> 1989. </year>
Reference-contexts: This problem and its contributing factors have been the focus of most real-time database research. One approach to RTDBS concurrency control is to abandon traditional concurrency control protocols such as two-phase locking that guarantee serializability but lead to transaction rollback delays [8, 32]. Lin <ref> [29, 28] </ref> suggests that, for real-time applications, data inconsistent with the external world can be worse than internally inconsistent data.
Reference: [29] <author> Kwei-Jay Lin and Ming-Ju Lin. </author> <title> Enhancing availability in distributed real-time databases. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 34-43, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: This problem and its contributing factors have been the focus of most real-time database research. One approach to RTDBS concurrency control is to abandon traditional concurrency control protocols such as two-phase locking that guarantee serializability but lead to transaction rollback delays [8, 32]. Lin <ref> [29, 28] </ref> suggests that, for real-time applications, data inconsistent with the external world can be worse than internally inconsistent data.
Reference: [30] <author> Martin Marietta Astronautics Group. </author> <title> Next Generation Workstation / Machine Controller Specification for an Open System Architecture Standard, </title> <address> NGC-0001-13-000-SYS edition, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: To solve data sharing problems consistently and efficiently, we need a novel approach to data management that satisfies real-time requirements. The Next Generation Workstation/Machine Controller (NGC) for automated factories is representative of the current trend toward distributed real-time architectures <ref> [2, 30] </ref>. The NGC is a software architecture specification for advanced machine tool controllers. It is intended to achieve standardization in the controller field and accelerate technology transfer from laboratories to industry. The NGC architecture is designed for high-performance real-time computing platforms such as VME-based shared-memory multiprocessors.
Reference: [31] <author> Nathaniel W. Mishkin. Apollo NCA and Sun ONC: </author> <title> A comparison. Posted by the author to USENET, </title> <month> September </month> <year> 1989. </year>
Reference-contexts: For RPCs, we will use the Network Computing System (NCS) RPC library from Hewlett Packard [14]. NCS was chosen as the core technology for the OSF Distributed Computing Environment (DCE). Some advantages of NCS over Sun RPC are described in <ref> [31] </ref>. Although we use NCS, our architecture is not dependent upon NCS in any fundamental way. Since NCS does not support real-time deadlines, our prototype will not be able to support hard real-time deadlines for RPC transactions.
Reference: [32] <author> Shojiro Nishio, Shinichi Taniguchi, and Toshihide Ibaraki. </author> <title> On the efficiency of cautious schedulers for database concurrency control why insist on two-phase locking? Journal of Real-Time Systems, </title> <booktitle> 1 </booktitle> <pages> 177-195, </pages> <year> 1989. </year>
Reference-contexts: This problem and its contributing factors have been the focus of most real-time database research. One approach to RTDBS concurrency control is to abandon traditional concurrency control protocols such as two-phase locking that guarantee serializability but lead to transaction rollback delays <ref> [8, 32] </ref>. Lin [29, 28] suggests that, for real-time applications, data inconsistent with the external world can be worse than internally inconsistent data.
Reference: [33] <author> R. Rajkumar. </author> <title> Real-time synchronization protocols for shared memory multiprocessors. </title> <booktitle> In Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pages 116-123, </pages> <year> 1990. </year>
Reference-contexts: One approach to priority inversion is to abort lower priority transactions that conflict with higher priority ones. An alternative is to bound priority inversions using various priority inheritance protocols which temporarily boost the priority of tasks holding locks if they conflict with higher priority tasks <ref> [34, 33, 38, 44] </ref>. This temporary priority boost helps lower-priority tasks complete transactions and release their locks.
Reference: [34] <author> Ragunathan Rajkumar, Lui Sha, and John P. Lehoczky. </author> <title> Real-time synchronization protocols for multiprocessors. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 259-269, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: One approach to priority inversion is to abort lower priority transactions that conflict with higher priority ones. An alternative is to bound priority inversions using various priority inheritance protocols which temporarily boost the priority of tasks holding locks if they conflict with higher priority tasks <ref> [34, 33, 38, 44] </ref>. This temporary priority boost helps lower-priority tasks complete transactions and release their locks. <p> This temporary priority boost helps lower-priority tasks complete transactions and release their locks. Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications <ref> [8, 19, 20, 34, 45] </ref>. For example, Huang et al. [20] advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted.
Reference: [35] <author> Krithi Ramamritham. </author> <title> Real-time databases. </title> <booktitle> Distributed and Parallel Databases, </booktitle> (1):199-226, 1993. 
Reference-contexts: The inadequacy of conventional database systems for real-time applications has spawned the field of real-time database systems (RTDBSs). RTDBSs are usually considered to be functionally equivalent to conventional database systems except that they provide fast, guaranteed response times <ref> [18, 35] </ref>. Although some progress in the field of RTDBSs has been made, most of the work has focused on specific sub-problems such as transaction scheduling. <p> primary strategies 1) schedule transactions according to task priorities, 2) minimize delays and uncertainties associated with concurrency control and locking, and 3) use memory-based databases or fast database hardware. 2.2 Transaction and I/O Scheduling Several researchers have investigated transaction and I/O scheduling algorithms that support different real-time needs and priorities <ref> [1, 8, 35, 48, 44] </ref>. Some commercial DBMSs support priority-based transaction scheduling [17, 36]. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance.
Reference: [36] <institution> Real Time Computersoftware Ges.m.b.H., Vienna, Austria. RTA Introduction & Overview, </institution> <year> 1992. </year>
Reference-contexts: Although there are a number of commercial object-oriented DBMS (such as GemStone [9], ObjectStore [21] and Objectivity/DB [22]) and "real-time" DBMS (such as GDX [17] and RTA <ref> [36] </ref>) products on the market, none of them support the performance level and predictability that MDARTS is designed for. <p> Some commercial DBMSs support priority-based transaction scheduling <ref> [17, 36] </ref>. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance. File-based databases in particular can benefit from transaction and I/O scheduling according to priorities.
Reference: [37] <author> Lui Sha, John P. Lehoczky, and E. Douglas Jensen. </author> <title> Modular concurrency control and failure recovery. </title> <journal> IEEE Trans. Computers, </journal> <volume> 37(2) </volume> <pages> 146-159, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Synchronization delays caused by locking can be reduced if the frequency of locking conflicts is reduced. One approach to reducing locking conflicts is to adjust the lock granularity to lock only data that are affected by each 3 transaction <ref> [5, 37, 46] </ref>. Reducing lock granularity increases space overhead for locking, and it can degrade per-formance if many locks must be acquired to perform a transaction. Therefore, the locking granularity should be tuned to transaction characteristics. <p> When possible, use data versioning [46] or multiple data copies [51] to permit concurrent read and write operations without locking. * Match locking granularity with data semantics. This ensures that locking does not unnecessarily restrict concurrency. Sha et al. <ref> [37] </ref>, Badrinath and Ramamritham [5], and Son [46] each propose locking only the data affected by a transaction. However, identifying affected data and locking only those data are non-trivial problems in conventional database systems, where the data affected by a transaction are determined during query processing at runtime.
Reference: [38] <author> Lui Sha, Ragunathan Rajkumar, and John P. Lehoczky. </author> <title> Concurrency control for distributed real-time databases. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 82-98, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Such response times would cause real-time tasks to miss deadlines, possibly causing the machine to become unstable and damage property or injure human operators <ref> [40, 38] </ref>. The inadequacy of conventional database systems for real-time applications has spawned the field of real-time database systems (RTDBSs). RTDBSs are usually considered to be functionally equivalent to conventional database systems except that they provide fast, guaranteed response times [18, 35]. <p> One approach to priority inversion is to abort lower priority transactions that conflict with higher priority ones. An alternative is to bound priority inversions using various priority inheritance protocols which temporarily boost the priority of tasks holding locks if they conflict with higher priority tasks <ref> [34, 33, 38, 44] </ref>. This temporary priority boost helps lower-priority tasks complete transactions and release their locks.
Reference: [39] <author> K G Shin and P Ramanathan. </author> <title> Real-time computing: A new discipline of computer science and engineering. </title> <journal> IEEE Proceedings, </journal> <volume> 82(1) </volume> <pages> 6-24, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: discusses related work, Section 3 describes our approach and our implementation strategy, and Section 4 presents milestones of the proposed research. 2 Background and Related Work 2.1 Need for Hard Real-Time Database Systems The defining characteristic of hard real-time systems is that they must complete their computations within strict deadlines <ref> [39] </ref>. If real-time software is unable to complete a computation within its deadline, catastrophic failure may occur. These deadlines can be very tight; for example, a manufacturing machine controller may have to compute its control signals every 1 or 2 milliseconds.
Reference: [40] <author> Mukesh Singhal. </author> <title> Issues and approaches to design of real-time database systems. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 19-33, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Such response times would cause real-time tasks to miss deadlines, possibly causing the machine to become unstable and damage property or injure human operators <ref> [40, 38] </ref>. The inadequacy of conventional database systems for real-time applications has spawned the field of real-time database systems (RTDBSs). RTDBSs are usually considered to be functionally equivalent to conventional database systems except that they provide fast, guaranteed response times [18, 35]. <p> MDARTS will support a variety of concurrency control techniques such as data versioning and object-oriented locking. 2.4 Main Memory Databases Some RTDBS researchers propose use of main memory databases to eliminate blocking time uncertainties associated with disk I/O during database transactions <ref> [40, 47] </ref>. Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems [4, 16, 26, 27]. Garcia-Molina and Salem presented an excellent overview of main memory database research [16].
Reference: [41] <author> Andrea H. Skarra. </author> <title> Concurrency control for cooperating transactions in an object-oriented database. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(4) </volume> <pages> 145-147, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Since the concurrency control can be individually tailored according to the semantics of the class member functions, it is possible to achieve higher levels of concurrency than with traditional read-write locking <ref> [41, 54] </ref>. It is also possible to implement atomicity in a base class and inherit this property in derived subclasses [13]. MDARTS shared-memory objects differ from atomic data types in that the handle parts of the objects are fragmented across multiple separate processes.
Reference: [42] <author> Andrea H. Skarra and Stanley B. Zdonik. </author> <title> Concurrency control and object-oriented databases. </title> <editor> In Won Kim and Frederick H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 395-421. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: For maximum performance, transactions must directly access data in shared memory without communicating with a separate database server process. However, without a database process to manage concurrency, the database objects must supply their own concurrency control. In other words, the database objects should be atomic data types <ref> [53, 42] </ref>. An atomic data type is essentially a class whose member functions guarantee serial behavior in the presence of concurrent requests.
Reference: [43] <author> P. Sleat and P. Osmon. </author> <title> A methodology for real-time database system construction. </title> <booktitle> In Proc. Int. Conf. on Software Engineering for Real Time Systems, </booktitle> <pages> pages 233-238, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: By registering application needs during initialization, MDARTS will be able to track resource allocation at runtime and guarantee response times before the actual real-time transactions are performed. Prior RTDBS research either makes guarantees a priori with off-line static analysis of applications <ref> [43] </ref> or makes dynamic guarantees during transaction processing [8]. Both of these approaches have significant disadvantages. Off-line analysis of transactions is not always feasible, especially for complex, distributed applications. Dynamic transaction scheduling imposes substantial overhead and cannot prevent overload conditions. <p> Furthermore, processing deadline information adds additional overhead and complexity to the processing of each transaction. This overhead in turn reduces the performance of the database system. Some researchers advocate global static analysis of real-time applications to determine data access requirements and guarantee timing constraints prior to runtime <ref> [43] </ref>. This static approach is too inflexible: new real-time processes cannot be added to the system dynamically, source code must be available for all software modules to support the analysis stage, and the inherent timing uncertainties in concurrent tasks running on multiprocessors make static analysis difficult.
Reference: [44] <author> Sang H. Son. </author> <title> Scheduling real-time transactions. </title> <booktitle> In Proc. EuroMicro '90 Workshop on Real Time, </booktitle> <pages> pages 25-32. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: primary strategies 1) schedule transactions according to task priorities, 2) minimize delays and uncertainties associated with concurrency control and locking, and 3) use memory-based databases or fast database hardware. 2.2 Transaction and I/O Scheduling Several researchers have investigated transaction and I/O scheduling algorithms that support different real-time needs and priorities <ref> [1, 8, 35, 48, 44] </ref>. Some commercial DBMSs support priority-based transaction scheduling [17, 36]. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance. <p> One approach to priority inversion is to abort lower priority transactions that conflict with higher priority ones. An alternative is to bound priority inversions using various priority inheritance protocols which temporarily boost the priority of tasks holding locks if they conflict with higher priority tasks <ref> [34, 33, 38, 44] </ref>. This temporary priority boost helps lower-priority tasks complete transactions and release their locks.
Reference: [45] <author> Sang H. Son, Juhnyoung Lee, and Yi Lin. </author> <title> Hybrid protocols using dynamic adjustment of serialization order for real-time concurrency control. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(3) </volume> <pages> 269-276, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This temporary priority boost helps lower-priority tasks complete transactions and release their locks. Since the best approach to real-time concurrency control often depends upon the particular application, some researchers advocate hybrid protocols that borrow features of several earlier strategies to perform acceptably for a wider range of applications <ref> [8, 19, 20, 34, 45] </ref>. For example, Huang et al. [20] advocate a hybrid approach in which tasks inherit higher priorities only if they are close to committing. Otherwise, if higher-priority tasks require locks held by low-priority tasks, the lower priority transactions are aborted.
Reference: [46] <author> Sang Hyuk Son. </author> <title> Semantic information and consistency in distributed realtime systems. </title> <journal> Information and Software Technology, </journal> <volume> 30(7) </volume> <pages> 443-449, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Synchronization delays caused by locking can be reduced if the frequency of locking conflicts is reduced. One approach to reducing locking conflicts is to adjust the lock granularity to lock only data that are affected by each 3 transaction <ref> [5, 37, 46] </ref>. Reducing lock granularity increases space overhead for locking, and it can degrade per-formance if many locks must be acquired to perform a transaction. Therefore, the locking granularity should be tuned to transaction characteristics. <p> Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization [6, 15, 25]. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether <ref> [46, 50, 51, 52] </ref>. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods. MDARTS does not dictate concurrency control policies, but the MDARTS object-oriented approach facilitates the use of semantic and object-based concurrency control. <p> Shared memory provides the highest performance for systems that support it. * Support distributed, concurrent transaction processing. Centralized transaction execution or lock management can become a bottleneck in multiprocessor systems. * Avoid unnecessary locking. When possible, use data versioning <ref> [46] </ref> or multiple data copies [51] to permit concurrent read and write operations without locking. * Match locking granularity with data semantics. This ensures that locking does not unnecessarily restrict concurrency. Sha et al. [37], Badrinath and Ramamritham [5], and Son [46] each propose locking only the data affected by a <p> When possible, use data versioning <ref> [46] </ref> or multiple data copies [51] to permit concurrent read and write operations without locking. * Match locking granularity with data semantics. This ensures that locking does not unnecessarily restrict concurrency. Sha et al. [37], Badrinath and Ramamritham [5], and Son [46] each propose locking only the data affected by a transaction. However, identifying affected data and locking only those data are non-trivial problems in conventional database systems, where the data affected by a transaction are determined during query processing at runtime.
Reference: [47] <author> Sang Hyuk Son. </author> <title> Recovery in main memory database systems for engineering design applications. </title> <journal> Information and Software Technology, </journal> <volume> 31(2) </volume> <pages> 85-90, </pages> <month> March </month> <year> 1989. </year> <month> 16 </month>
Reference-contexts: MDARTS will support a variety of concurrency control techniques such as data versioning and object-oriented locking. 2.4 Main Memory Databases Some RTDBS researchers propose use of main memory databases to eliminate blocking time uncertainties associated with disk I/O during database transactions <ref> [40, 47] </ref>. Recently, there has also been considerable interest in using main memory databases to enhance the performance of conventional transaction processing systems [4, 16, 26, 27]. Garcia-Molina and Salem presented an excellent overview of main memory database research [16].
Reference: [48] <author> John A. Stankovic and Wei Zhao. </author> <title> On real-time transactions. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 4-18, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: primary strategies 1) schedule transactions according to task priorities, 2) minimize delays and uncertainties associated with concurrency control and locking, and 3) use memory-based databases or fast database hardware. 2.2 Transaction and I/O Scheduling Several researchers have investigated transaction and I/O scheduling algorithms that support different real-time needs and priorities <ref> [1, 8, 35, 48, 44] </ref>. Some commercial DBMSs support priority-based transaction scheduling [17, 36]. By servicing high-priority tasks first, the database can provide faster and more predictable performance for transactions submitted by high-priority tasks. In this case, low-priority tasks experience degraded performance.
Reference: [49] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language Second Edition. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: We will use the C++ language <ref> [49] </ref> to implement MDARTS. We chose C++ because of its wide availability, runtime efficiency, compatibility with C, and object-oriented features. Some advantages of C++ for real-time software are discussed in the literature [11, 12].
Reference: [50] <author> Peiyi Tang, Pen-Chung Yew, and Chuan-Qi Zhu. </author> <title> A parallel linked list for shared-memory multiprocessors. </title> <booktitle> In IEEE Int'l Computer Software & Applications Conf., </booktitle> <pages> pages 130-135, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization [6, 15, 25]. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether <ref> [46, 50, 51, 52] </ref>. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods. MDARTS does not dictate concurrency control policies, but the MDARTS object-oriented approach facilitates the use of semantic and object-based concurrency control.
Reference: [51] <author> K. Vidyasankar. </author> <title> An elegant 1-writer multireader multivalued atomic register. </title> <journal> Information Processing Letters, </journal> <pages> pages 221-223, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization [6, 15, 25]. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether <ref> [46, 50, 51, 52] </ref>. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods. MDARTS does not dictate concurrency control policies, but the MDARTS object-oriented approach facilitates the use of semantic and object-based concurrency control. <p> For example, a fundamental constraint type is the response time for concurrent read or write transactions. There are many algorithms that support concurrent data access. Faster algorithms generally require semantic restrictions such as allowing only a single writer at a given time <ref> [51, 52] </ref>. If multiple concurrent writers are allowed, additional overhead is required to lock and unlock the data and to wait if another task is updating it. The MDARTS library will contain data management classes optimized for restricted concurrency semantics as well as classes that support more general semantics. <p> This constraint allows the DbArray&lt;T&gt; class to use efficient concurrency control algorithms and provides protection from unauthorized data access. By alternating updates to two copies of the data as described by Vidyasankar <ref> [51] </ref>, MDARTS can perform concurrent read and write transactions without locking the data. This technique relies on the restriction that only one write transaction will be active at a given time. The "exclusive update" constraint guarantees that this will be the case. <p> Shared memory provides the highest performance for systems that support it. * Support distributed, concurrent transaction processing. Centralized transaction execution or lock management can become a bottleneck in multiprocessor systems. * Avoid unnecessary locking. When possible, use data versioning [46] or multiple data copies <ref> [51] </ref> to permit concurrent read and write operations without locking. * Match locking granularity with data semantics. This ensures that locking does not unnecessarily restrict concurrency. Sha et al. [37], Badrinath and Ramamritham [5], and Son [46] each propose locking only the data affected by a transaction.
Reference: [52] <author> K. Vidyasankar. </author> <title> Concurrent reading while writing revisited. </title> <booktitle> Distributed Computing, </booktitle> <pages> pages 81-85, </pages> <year> 1990. </year>
Reference-contexts: Semantic and object-based concurrency control protocols extend this idea by characterizing which transactions conflict one another and thus require serialization [6, 15, 25]. Another approach to reducing locking conflicts is to design transaction protocols that use data versioning to avoid locking altogether <ref> [46, 50, 51, 52] </ref>. MDARTS objects can use similar techniques in providing concurrency control for their transaction methods. MDARTS does not dictate concurrency control policies, but the MDARTS object-oriented approach facilitates the use of semantic and object-based concurrency control. <p> For example, a fundamental constraint type is the response time for concurrent read or write transactions. There are many algorithms that support concurrent data access. Faster algorithms generally require semantic restrictions such as allowing only a single writer at a given time <ref> [51, 52] </ref>. If multiple concurrent writers are allowed, additional overhead is required to lock and unlock the data and to wait if another task is updating it. The MDARTS library will contain data management classes optimized for restricted concurrency semantics as well as classes that support more general semantics.
Reference: [53] <author> William Weihl and Barbara Liskov. </author> <title> Implementation of resilient, atomic data types. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 245-269, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: For maximum performance, transactions must directly access data in shared memory without communicating with a separate database server process. However, without a database process to manage concurrency, the database objects must supply their own concurrency control. In other words, the database objects should be atomic data types <ref> [53, 42] </ref>. An atomic data type is essentially a class whose member functions guarantee serial behavior in the presence of concurrent requests.
Reference: [54] <author> William E. Weihl. </author> <title> Commutativity-based concurrency control for abstract data types. </title> <journal> IEEE Trans. Computers, </journal> <volume> 37(12) </volume> <pages> 1488-1505, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Since the concurrency control can be individually tailored according to the semantics of the class member functions, it is possible to achieve higher levels of concurrency than with traditional read-write locking <ref> [41, 54] </ref>. It is also possible to implement atomicity in a base class and inherit this property in derived subclasses [13]. MDARTS shared-memory objects differ from atomic data types in that the handle parts of the objects are fragmented across multiple separate processes.
Reference: [55] <author> Stephen P. Weiser and Frederick H. </author> <title> Lochovsky. OZ+: An object-oriented database system. </title> <editor> In Won Kim and Frederick H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 309-337. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year> <month> 17 </month>
Reference-contexts: The challenge here is that the logging process must be fast enough to keep up with the rate those data items are generated. Booch [7] shows how C++ can be used to access a relational database system. The OZ+ object-oriented DBMS <ref> [55] </ref> uses an underlying relational database to supply object persistence. Likewise, MDARTS can interface with external file-based DBMSs. MDARTS can construct handles to external databases that hide the database-specific queries from application programs.
References-found: 55

