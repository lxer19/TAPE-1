URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/elf-papers/esop96.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/elf-papers/
Root-URL: 
Email: er+@cs.cmu.edu, fp+@cs.cmu.edu  
Title: Mode and Termination Checking for Higher-Order Logic Programs  
Author: Ekkehard Rohwedder and Frank Pfenning 
Address: Pittsburgh, Pennsylvania 15213-3890, U.S.A.  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We consider how mode (such as input and output) and termination properties of typed higher-order constraint logic programming languages may be declared and checked effectively. The systems that we present have been validated through an implementation and numerous case studies.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure Prolog programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <year> 1993. </year>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., [10, 4, 7, 25, 27]) and termination (see, e.g., <ref> [24, 1] </ref>) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> These properties are decidable within our mode system and the implementation checks them efficiently and provides useful feedback in case a property is violated. While the basic notions of modes and termination have been known for some time <ref> [30, 1] </ref> they have not yet been applied to a higher-order setting that includes dependent types, higher-order terms and proof objects.
Reference: 2. <author> K. R. Apt and Alessandro Pellegrini. </author> <title> On the occur-check-free PROLOG programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 687-726, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In order to obtain termination we assume that the termination conditions are defined only on input arguments to a well-moded predicate <ref> [2] </ref>. This avoids a much more complicated analysis|consider, for example, a program containing the clauses p (s X) &lt;- p X and p z in this order. Elf (and Prolog) search for the goal ?- p Y will not terminate.
Reference: 3. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13 </volume> <pages> 103-179, </pages> <year> 1992. </year>
Reference-contexts: We then show via induction over the computation sequences that the groundedness properties established during mode checking will also hold at the Elf level. Related work. Many properties of logic programs can be derived by abstract interpretation <ref> [3] </ref>, including the inference of mode declarations [10]. Contrary to Debray and Mellish [4] we view mode declarations as part of a logic program's specification rather than as a property to be inferred.
Reference: 4. <author> S. K. Debray and D. S. Warren. </author> <title> Automatic mode inference for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 207-229, </pages> <year> 1988. </year>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., <ref> [10, 4, 7, 25, 27] </ref>) and termination (see, e.g., [24, 1]) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> Related work. Many properties of logic programs can be derived by abstract interpretation [3], including the inference of mode declarations [10]. Contrary to Debray and Mellish <ref> [4] </ref> we view mode declarations as part of a logic program's specification rather than as a property to be inferred. Our system distinguishes between ground and possibly non-ground terms, which makes mode information in a higher-order setting manageable while still being very useful.
Reference: 5. <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: We thus do not consider this a major limitation of the mode systems. Our lexicographically extended higher-order subterm ordering works well for structural inductions (on which most meta-proofs in Elf are based on), but they fail in other cases such as course-of-value induction or recursion over sub-lists <ref> [5] </ref>. In some of these situations one can make the termination proofs apparent 12 through the introduction of additional "measure" arguments (such as the length of a list). We also encountered an instance where unfolding of mutually recursive predicates was necessary to automatically show termination.
Reference: 6. <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: After an overview of Elf we present some sample programs and a formal execution model for the Elf interpreter. Logical Framework. The Logical Framework (LF) <ref> [6] </ref> is a calculus of dependent types consisting of three staged syntactic levels. Kinds : K ::= type j x:A:K Types : A ::= a M 1 . . . <p> They are introduced through a signature. Below we assume that we have fixed a signature . The types of free variables in a term M are provided by a context. The following principal judgments characterize the LF type theory <ref> [6] </ref>: ` M M 0 : A and ` A A 0 : type | type and object equivalences; ` , ` , and ` K | the validity of signatures, contexts and kinds; ` A : K and ` M : A | assigning kinds to types and types to
Reference: 7. <author> Dean Jacobs. </author> <title> A pragmatic view of types for logic programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in Logic Programming, chapter 7, </booktitle> <pages> pages 217-227. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., <ref> [10, 4, 7, 25, 27] </ref>) and termination (see, e.g., [24, 1]) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> Example. The execution of initial 0 ;; results in 0 ;, 9 (cplam (x:x) (y:y) (x:D:D)) =P , and &gt;. 3 Mode Analysis Modes. Modes have been proposed for expressing aspects of the operational semantics of logic programs (see, e.g., <ref> [7, 25, 27] </ref>). The simplest and most useful modes declare the input and output arguments of a predicate. The input arguments to a predicate should be ground when it is called. Upon successful return, the output arguments should be ground.
Reference: 8. <author> Stefan Kahrs. </author> <title> Towards a domain theory for termination proofs. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Sixth International Conference on Rewriting Techniques and Applications, RTA-95, </booktitle> <pages> pages 241-255, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the ALF framework [9] only total functions over disjoint patterns are definable and |since ALF does not employ higher-order abstract syntax| a first-order subterm ordering is sufficient for showing termination of recursive calls. Termination proofs in a higher-order setting have been investigated, among others, in [28] and <ref> [8] </ref>. Although our system employs similar ideas, we need to additionally make use of type subordination to obtain the desired termination ordering. We expect mode and termination properties of higher-order logic programs to play an important role in the compilation of such programs.
Reference: 9. <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: At present, the simplicity of our approach outweighs the benefits of a more flexible system such as Reddy's. We do not know of any framework logics that perform an analysis similar to ours. In the ALF framework <ref> [9] </ref> only total functions over disjoint patterns are definable and |since ALF does not employ higher-order abstract syntax| a first-order subterm ordering is sufficient for showing termination of recursive calls. Termination proofs in a higher-order setting have been investigated, among others, in [28] and [8].
Reference: 10. <author> C. S. Mellish. </author> <title> The automatic generation of mode declarations for Prolog programs. </title> <type> DAI Research Report 163, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., <ref> [10, 4, 7, 25, 27] </ref>) and termination (see, e.g., [24, 1]) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> We then show via induction over the computation sequences that the groundedness properties established during mode checking will also hold at the Elf level. Related work. Many properties of logic programs can be derived by abstract interpretation [3], including the inference of mode declarations <ref> [10] </ref>. Contrary to Debray and Mellish [4] we view mode declarations as part of a logic program's specification rather than as a property to be inferred. Our system distinguishes between ground and possibly non-ground terms, which makes mode information in a higher-order setting manageable while still being very useful.
Reference: 11. <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: of this approach are: a formalization of linear logic [21], where the linearity of derivations is a decidable property, an implementation of the sequent calculus [22] with a terminating cut-elimi nation procedure, a formulation of refinement types [19] for which the subtype property is decidable, and a representation of Mini-ML <ref> [11] </ref> for which type inference is guaranteed to terminate. Limitations. To date we have encountered a sole instance where the mode checker rejected an intuitively correct formalization, which, we believe, may be rewritten. We thus do not consider this a major limitation of the mode systems.
Reference: 12. <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: The only equations permitted in constraints are so-called flex-flex and flex-rigid pairs where at least one of the flexible terms is not a generalized variable (see section 3). 4 As long as the terms M 1 and M 2 are first-order or higher-order patterns after application of (see <ref> [12] </ref>), this guarantees most general unifiers. It should be noted that constraint simplification either fails or succeeds with a unique answer constraint. <p> On the other hand, the application of two ground terms (as in the first subgoal of the clause evapp) can be recognized as ground. This is an example where a program outside the L fragment <ref> [12] </ref> is verified as mode correct, which means that fi 0 unification and no constraints are generated for well-moded queries.
Reference: 13. <author> Dale Miller. </author> <title> Abstract syntax and logic programming. </title> <booktitle> In Proceedings of the First and Second Russian Conferences on Logic Programming, </booktitle> <pages> pages 322-337, </pages> <address> Irkutsk and St. Petersburg, Russia, 1992. </address> <publisher> Springer-Verlag LNAI 592. </publisher> <pages> 14 </pages>
Reference-contexts: Elf kinds are employed for type declarations, such as nat : type or ack : nat -&gt; nat -&gt; nat -&gt; type, whereas Elf object constants are used as syntax constructors and as clause labels. Lambda expressions exp are a prototypical example of higher-order abstract syntax <ref> [13] </ref>, where binding at the object level is represented as a higher-order term at the meta-level. nat : type. % Natural numbers 0: nat. ack : nat -&gt; nat -&gt; nat -&gt; type. % Ackermann function ack1: ack 0 Y Y. ack3: ack (s X) (s Y) R &lt;- ack (s
Reference: 14. <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 321-358, </pages> <year> 1992. </year>
Reference-contexts: Goal formulas F ::= &gt; j M : : = B : type j M 2 A j F 1 ^ F 2 j 8x:A:F j 9x:A:F Constraints ::= &gt; j M : Mixed-prefix contexts. Variables and 0 denote mixed-prefix contexts in the sense of Miller <ref> [14] </ref>. They allow us to model existentially and universally quantified variables (i.e., logic variables and parameters, respectively) as well as dependencies between them. The substitution relates these contexts: 0 ` : . It maps the goal formula F defined in the context to a formula over 0 . <p> Fortunately, we can obtain more information about F from this fact. The term F x is a gvar (generalized variable) under a mixed prefix (see <ref> [14] </ref>) since F is an existential variable that is applied to distinct universal variables declared to the right of F . Unification of a gvar with a ground term always returns a most general unifier (if it succeeds), instantiating the gvar to a ground term.
Reference: 15. <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Their correctness proofs are only sketched in this paper. In addition we outline a success continuation passing semantics for Elf and present a subterm ordering for higher-order terms which may be of independent interest. We expect a minor variation of these systems to be applicable to Prolog <ref> [15] </ref>. The remainder of the paper is organized as follows. We introduce the Logical Framework, Elf, and a sketch of its operational semantics based on success continuations in Section 2. Mode analysis, including a mode-checking system for Elf programs is presented in Section 3. <p> We expect mode and termination properties of higher-order logic programs to play an important role in the compilation of such programs. We need to investigate how our ideas can be applied to -Prolog <ref> [15] </ref> which presents two additional complications: extra-logical primitives (such as cut, or primitives for input and output) and higher-order subgoals permitting predicates as arguments to other predicates. This means that we may not be able to statically determine the call graph of a program.
Reference: 16. <author> L. Naish. </author> <title> Automatic generation of control for logic programs. </title> <type> Technical Report 83/6, </type> <institution> Department of Computer Science, The University of Melbourne, </institution> <year> 1983. </year>
Reference-contexts: Related work. Similarly to our mode analysis approach, we have extended a rather nave first-order termination analysis based on a subterm property <ref> [16] </ref> to a higher-order setting. Although it would have been straightforward to implement, we do not automatically infer an actual lexicographic order | we would rather consider the termination orderings part of the specification of a logic program.
Reference: 17. <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: In particular, it should be uniform, intuitive, concise and efficiently decidable. Furthermore, relatively few natural and correct programs should be rejected as ill-moded or non-terminating. We present a system for mode and termination properties of Elf programs. Elf <ref> [17] </ref> is a higher-order constraint logic programming language based on the LF logical framework. Although Elf encompasses pure Prolog, it has been designed as a meta-language for the specification, implementation, and meta-theory of programming languages and logics. <p> Since types of valid objects are unique up to fi-conversion we sometimes write A M for the canonical type of M . Elf. Using the propositions-as-types and derivations-as-objects correspondences, the LF type theory can also be viewed as a logic calculus, for which |in form of the language Elf <ref> [20, 17] </ref>| we have an implementation in the spirit of constraint logic programming. The Elf interpreter type-checks programs (i.e., LF signatures) presented to it and searches for derivations of goals in the manner of Prolog, replacing unification by simplification of constraints involving higher-order functions. <p> Similarly, we refer to the declaration of a constant with dynamic type as a clause. Elf execution model. In <ref> [17] </ref> a nondeterministic state transition system is given for Elf execution. This was sufficent to obtain the necessary soundness and non-deterministic completeness properties. For our modes and termination system the subgoal ordering is critical, so we make it explicit in the form of an operational semantics based on success continuations. <p> Constraints are characterized through a subclass of formulas. They arise during Elf "unification" which is implemented as constraint simplification <ref> [17] </ref>. Every solution to the constraints returned after simplification will unify the indicated equation.
Reference: 18. <author> Frank Pfenning, </author> <title> editor. Types in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Just like other paradigms logic programming benefits tremendously from types. Perhaps most importantly, types allow the early detection of errors when a program is checked against a type specification. With some notable exceptions most type systems proposed for logic programming languages to date (see <ref> [18] </ref>) are concerned with the declarative semantics of programs, for example, in terms of many-sorted, order-sorted, or higher-order logic. Operational properties of logic programs which are vital for their correctness can thus neither be expressed nor checked and errors will remain undetected.
Reference: 19. <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geuvers, editor, </editor> <booktitle> Informal Proceedings of the Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Some examples of this approach are: a formalization of linear logic [21], where the linearity of derivations is a decidable property, an implementation of the sequent calculus [22] with a terminating cut-elimi nation procedure, a formulation of refinement types <ref> [19] </ref> for which the subtype property is decidable, and a representation of Mini-ML [11] for which type inference is guaranteed to terminate. Limitations. To date we have encountered a sole instance where the mode checker rejected an intuitively correct formalization, which, we believe, may be rewritten.
Reference: 20. <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: Since types of valid objects are unique up to fi-conversion we sometimes write A M for the canonical type of M . Elf. Using the propositions-as-types and derivations-as-objects correspondences, the LF type theory can also be viewed as a logic calculus, for which |in form of the language Elf <ref> [20, 17] </ref>| we have an implementation in the spirit of constraint logic programming. The Elf interpreter type-checks programs (i.e., LF signatures) presented to it and searches for derivations of goals in the manner of Prolog, replacing unification by simplification of constraints involving higher-order functions. <p> For proofs of meta-theorems formalized in Elf that employ structural induction, these orderings correspond directly to the nesting of the inductive argument. 11 5 Pragmatics The mode and termination analyses described in this paper were implemented for the current Elf interpreter <ref> [20] </ref> and have proven to be valuable tools in the development of Elf programs. Multiple modes. Sometimes a predicate may be executed in multiple directions and we would like to assign it multiple modes, rather than copy its definition.
Reference: 21. <author> Frank Pfenning. </author> <title> Structural cut elimination in linear logic. </title> <type> Technical Report CMU-CS-94-222, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> Decem-ber </month> <year> 1994. </year>
Reference-contexts: This allows us to make a meta-mathematical statement about an object language formalized in Elf simply by exhibiting a checked program in the same framework. Some examples of this approach are: a formalization of linear logic <ref> [21] </ref>, where the linearity of derivations is a decidable property, an implementation of the sequent calculus [22] with a terminating cut-elimi nation procedure, a formulation of refinement types [19] for which the subtype property is decidable, and a representation of Mini-ML [11] for which type inference is guaranteed to terminate.
Reference: 22. <author> Frank Pfenning. </author> <title> Structural cut elimination. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of the Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 156-166, </pages> <address> San Diego, California, June 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Another important aspect of higher-order subterms can be demonstrated, e.g., from a formalization of predicate logic as it is used 9 in the cut-elimination proof for the sequent calculus <ref> [22] </ref>. We have type fam-ilies i for individuals and o for formulas, and|among others|a constructor forall : (i ! o) ! o. The proof requires A T (which represents [t=x]A) to be strictly smaller than forall A (which represents 8x:A). <p> Some examples of this approach are: a formalization of linear logic [21], where the linearity of derivations is a decidable property, an implementation of the sequent calculus <ref> [22] </ref> with a terminating cut-elimi nation procedure, a formulation of refinement types [19] for which the subtype property is decidable, and a representation of Mini-ML [11] for which type inference is guaranteed to terminate. Limitations.
Reference: 23. <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: Perhaps the most important extension is to show the totality of predicates: not only will every execution sequence terminate, but every execution sequence starting from a well-moded goal will succeed. This allows us to verify that certain 13 higher-level judgments implement proofs <ref> [23] </ref>, formally establishing many impor-tant meta-theoretic properties of the object languages under investigation. Finally, work on negation has often relied on mode information [27]. We plan to take advantage of mode and termination information when considering negation in the context of higher-order logic programming. Acknowledgments.
Reference: 24. <author> Lutz Plumer. </author> <title> Termination Proofs for Logic Programs. </title> <publisher> Springer-Verlag LNAI 446, </publisher> <year> 1991. </year>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., [10, 4, 7, 25, 27]) and termination (see, e.g., <ref> [24, 1] </ref>) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis.
Reference: 25. <author> Uday S. Reddy. </author> <title> A typed foundation for directional logic programming. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Proceedings of the Third International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 282-318, </pages> <address> Bologna, Italy, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag LNAI 660. </note>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., <ref> [10, 4, 7, 25, 27] </ref>) and termination (see, e.g., [24, 1]) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> Example. The execution of initial 0 ;; results in 0 ;, 9 (cplam (x:x) (y:y) (x:D:D)) =P , and &gt;. 3 Mode Analysis Modes. Modes have been proposed for expressing aspects of the operational semantics of logic programs (see, e.g., <ref> [7, 25, 27] </ref>). The simplest and most useful modes declare the input and output arguments of a predicate. The input arguments to a predicate should be ground when it is called. Upon successful return, the output arguments should be ground. <p> As a pragmatic decision, especially since the underlying LF type theory does not prescribe one particular operational interpretation, we implemented modes separately from types, whereas Reddy <ref> [25] </ref> proposes to combine mode and type specifications. At present, the simplicity of our approach outweighs the benefits of a more flexible system such as Reddy's. We do not know of any framework logics that perform an analysis similar to ours.
Reference: 26. <author> Z. Somogyi. </author> <title> A system of precise modes for logic programs. </title> <editor> In J. L. Lassez, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <volume> Volume 2, </volume> <pages> pages 769-787, </pages> <address> Cambridge, Massachusetts, 1987. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Mode systems for logic programs often rely on type information and also consider more precise modes, such as partially instantiated terms <ref> [26] </ref>. In our case we directly exploit Elf's type system. 4 Termination Analysis For termination we need to demonstrate that arguments to (possibly mutually) recursive subgoals decrease in some well-founded ordering with respect to the original program call.
Reference: 27. <author> Robert F. Stark. </author> <title> The declarative semantics of the Prolog selection rule. </title> <editor> In S. Abramsky, editor, </editor> <booktitle> Proceedings of the Ninth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 252-261, </pages> <address> Paris, France, July 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The presence of these features presents a chal-lenge, but also provides an opportunity. The challenge is to extend previous work on modes (see, e.g., <ref> [10, 4, 7, 25, 27] </ref>) and termination (see, e.g., [24, 1]) to deal with types and higher-order constraint simplification. On the other hand it turns out that we can take advantage of the already very expressive underlying type structure in our analysis. <p> Example. The execution of initial 0 ;; results in 0 ;, 9 (cplam (x:x) (y:y) (x:D:D)) =P , and &gt;. 3 Mode Analysis Modes. Modes have been proposed for expressing aspects of the operational semantics of logic programs (see, e.g., <ref> [7, 25, 27] </ref>). The simplest and most useful modes declare the input and output arguments of a predicate. The input arguments to a predicate should be ground when it is called. Upon successful return, the output arguments should be ground. <p> This allows us to verify that certain 13 higher-level judgments implement proofs [23], formally establishing many impor-tant meta-theoretic properties of the object languages under investigation. Finally, work on negation has often relied on mode information <ref> [27] </ref>. We plan to take advantage of mode and termination information when considering negation in the context of higher-order logic programming. Acknowledgments. We would like to thank the anonymous referees for their helpful comments and Brian Milnes for supplying us with a user's perspective on the checker implementation.
Reference: 28. <author> J. van de Pol and H. Schwichtenberg. </author> <title> Strict functionals for termination proofs. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the Second International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 350-364, </pages> <address> Edinburgh, United Kingdom, April 1995. </address> <publisher> Springer-Verlag LNCS. </publisher>
Reference-contexts: In the ALF framework [9] only total functions over disjoint patterns are definable and |since ALF does not employ higher-order abstract syntax| a first-order subterm ordering is sufficient for showing termination of recursive calls. Termination proofs in a higher-order setting have been investigated, among others, in <ref> [28] </ref> and [8]. Although our system employs similar ideas, we need to additionally make use of type subordination to obtain the desired termination ordering. We expect mode and termination properties of higher-order logic programs to play an important role in the compilation of such programs.
Reference: 29. <author> Roberto Virga. </author> <title> Higher-order superposition for dependent types. </title> <type> Technical Report CMU-CS-95-150, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: We define a type family a to be subordinate to a type family a 0 (a fl a 0 ) whenever a term M : A with hd (A) = a may be used in constructing a term N : B with hd (B) = a 0 (see <ref> [29] </ref>). If additionally a 0 fl a we say that a, a 0 are mutually recursive. We write a &lt; fl a 0 if a is subordinate to a 0 , but not mutually recursive with a.
Reference: 30. <author> D. H. D. Warren. </author> <title> Implementing Prolog|compiling predicate logic programs, Volume 1. </title> <type> DAI Research Report 39, </type> <institution> University of Edinburgh, </institution> <year> 1977. </year> <month> 15 </month>
Reference-contexts: These properties are decidable within our mode system and the implementation checks them efficiently and provides useful feedback in case a property is violated. While the basic notions of modes and termination have been known for some time <ref> [30, 1] </ref> they have not yet been applied to a higher-order setting that includes dependent types, higher-order terms and proof objects.
References-found: 30

