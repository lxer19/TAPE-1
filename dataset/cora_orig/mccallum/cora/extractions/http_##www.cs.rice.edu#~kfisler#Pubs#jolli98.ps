URL: http://www.cs.rice.edu/~kfisler/Pubs/jolli98.ps
Refering-URL: http://www.cs.rice.edu/~kfisler/publications.html
Root-URL: 
Email: kfisler@cs.rice.edu  
Title: Timing Diagrams and Algorithmic Verification  
Author: Kathi Fisler 
Keyword: computer-aided verification, counter machines, language containment, model checking, timing diagrams.  
Address: 6100 S. Main, MS 132 Houston, TX 77005-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Timing diagrams are popular in hardware design. They have been formalized for use in reasoning tasks, such as computer-aided verification. These efforts have largely treated timing diagrams as interfaces to established notations for which verification is decidable; this has restricted timing diagrams to expressing only regular language properties. This paper presents a timing diagram logic capable of expressing certain context-free and context-sensitive properties. It shows that verification is decidable for properties expressible in this logic. More specifically, it shows that containment of !-regular languages generated by Buchi automata in timing diagram languages is decidable. The result relies on a correlation between timing diagram and reversal-bounded counter machine languages. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Annotations of the form [l; u] on the arrows indicate discrete lower and upper bounds on the time between the related events; annotation "= n" (shorthand for [n; n]) indicates that the lower and upper bounds are the same, while "&gt; 3" (shorthand for <ref> [3; 1] </ref>) indicates a lower bound of 3 but no upper bound. Unannotated arrows have the time bound [1; 1]. Valid bound expressions consist of natural numbers, variables, and addition and subtraction expressions over them, as well as the symbol 1. <p> Unannotated arrows have the time bound <ref> [1; 1] </ref>. Valid bound expressions consist of natural numbers, variables, and addition and subtraction expressions over them, as well as the symbol 1. The labels in the box are for explanatory purposes and are not part of the timing diagram. <p> L); (p 5 ; R); (p 6 ; F )g) Relation O contains five elements, the first four corresponding to the arrows and the fifth to the synchronization line: O = f ((a; p 1 ); (a; p 2 ); [n; n]); ((a; p 2 ); (b; p 3 ); <ref> [1; 1] </ref>); ((a; p 5 ); (c; p 5 ); [0; 0])g Although we have provided only an example here, any timing diagram can be converted to this tuple representation by parsing the diagrammatic elements that comprise it. <p> Alpern and Schneider's result on splitting an !-regular language into an infinite component (liveness property) and a finite component (safety property) is similar in spirit <ref> [1] </ref>. We now describe the machines which implement these stages for timing diagram D = hT; S; X i. Let p 1 : : : p n be the time points of T , and let S = fp 1 ; : : : ; p k g.
Reference: 2. <author> Rajeev Alur, Thomas A. Henzinger, and Moshe Y. Vardi. </author> <title> Parametric real-time reasoning. </title> <booktitle> In Proceedings of the 25th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 592-601, </pages> <year> 1993. </year>
Reference-contexts: Jahanian, Mok, and Stuart have a textual logic of real-time timing constraints (RTL), that is undecidable [16]. Alur, Hen-zinger, and Vardi studied parametric timing constraints for real-time systems using a theory of parametric timed automata with multiple clocks for tracking parametric values <ref> [2] </ref>. They showed language emptiness is decidable for one parametric clock, undecidable for three parametric clocks, and an open problem for two parametric clocks. TDL timing diagrams yield certain properties requiring multiple parameterized clocks; the sets of problems addressed by their work and ours are therefore inequivalent. <p> In contrast, TDL is part of a larger project investigating logical features of diagrammatic design notations [10]. Our work on decidability for TDL begins to explore the efficacy of diagrammatic representations. Based on previous undecidability results regarding timing constraints <ref> [2, 16] </ref>, we expected containment of a regular language in a timing diagram language to be undecidable. In addition, our timing diagrams clearly describe context-free and context-sensitive languages, and containment for each is known to be undecidable [13].
Reference: 3. <author> Bachi Berkane, Simona Gandrabur, and Eduard Cerny. </author> <title> Timing diagrams: Semantics and timing analysis. </title> <institution> LASSO, University of Montreal, </institution> <year> 1996. </year> <note> jolli98.tex; 10/03/1998; 11:07; no v.; p.19 20 Kathi Fisler </note>
Reference-contexts: Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs [17, 19]. Damm, Josko, and Schlor [6], as well as Berkane, Gandrabur and Cerny <ref> [3] </ref>, have formalized timing diagram notations for use in verification. Although the syntax differs between formalizations, all timing diagrams express some common information: patterns of value changes on signals, precedence and synchronization relationships between changes, and timing constraints between changes. A sample timing diagram in our notation appears below. <p> Annotations of the form [l; u] on the arrows indicate discrete lower and upper bounds on the time between the related events; annotation "= n" (shorthand for [n; n]) indicates that the lower and upper bounds are the same, while "&gt; 3" (shorthand for <ref> [3; 1] </ref>) indicates a lower bound of 3 but no upper bound. Unannotated arrows have the time bound [1; 1]. Valid bound expressions consist of natural numbers, variables, and addition and subtraction expressions over them, as well as the symbol 1.
Reference: 4. <author> J.A. Brzozowski, T. Gahlinger, and F. Mavaddat. </author> <title> Consistency and satisfiability of waveform timing specifications. </title> <journal> Networks, </journal> <volume> 21 </volume> <pages> 91-107, </pages> <year> 1991. </year>
Reference-contexts: Dillon et al. designed a graphical, real-time, interval temporal logic [7]. Brzozowski, Gahlinger, and Mavaddat provide algorithms for testing consistency and satisfiability of timing specifications given as timing diagrams in the context of interfacing components <ref> [4] </ref>; Cerny and Khor-doc have done similar work [5]. Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs [17, 19]. Damm, Josko, and Schlor [6], as well as Berkane, Gandrabur and Cerny [3], have formalized timing diagram notations for use in verification.
Reference: 5. <author> E. Cerny and K. Khordoc. </author> <title> Interface specifications with conjunctive timing constraints: Realizability and compatibility. </title> <booktitle> In Second AMAST Workshop on Real-Time Systems, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Dillon et al. designed a graphical, real-time, interval temporal logic [7]. Brzozowski, Gahlinger, and Mavaddat provide algorithms for testing consistency and satisfiability of timing specifications given as timing diagrams in the context of interfacing components [4]; Cerny and Khor-doc have done similar work <ref> [5] </ref>. Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs [17, 19]. Damm, Josko, and Schlor [6], as well as Berkane, Gandrabur and Cerny [3], have formalized timing diagram notations for use in verification.
Reference: 6. <author> Werner Damm, Bernhard Josko, and Rainer Schlor. </author> <title> Specification and verification of VHDL-based system-level hardware designs. </title> <editor> In Egon Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 331-409. </pages> <publisher> Oxford Science Publications, </publisher> <year> 1995. </year>
Reference-contexts: Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs [17, 19]. Damm, Josko, and Schlor <ref> [6] </ref>, as well as Berkane, Gandrabur and Cerny [3], have formalized timing diagram notations for use in verification. Although the syntax differs between formalizations, all timing diagrams express some common information: patterns of value changes on signals, precedence and synchronization relationships between changes, and timing constraints between changes.
Reference: 7. <author> L.K. Dillon, G. Kutty, L.E. Moser, P.M. Melliar-Smith, and Y.S. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <type> Technical report, </type> <institution> UCSB, </institution> <year> 1993. </year>
Reference-contexts: Timing Diagrams Designers have traditionally used timing diagrams to document timing constraints on designs. Recognizing their appeal, researchers began formalized timing diagram notations for use in hardware reasoning tasks. Dillon et al. designed a graphical, real-time, interval temporal logic <ref> [7] </ref>. Brzozowski, Gahlinger, and Mavaddat provide algorithms for testing consistency and satisfiability of timing specifications given as timing diagrams in the context of interfacing components [4]; Cerny and Khor-doc have done similar work [5]. <p> Conclusions TDL is novel among timing diagram formalizations for two reasons: it supports variables in timing constraints (parametric timing constraints), and it has a customizable semantics. TDL also differs in its design goals. With one exception <ref> [7] </ref>, other formalizations are used as interfaces to existing sentential representations for which verification algorithms already exist. In contrast, TDL is part of a larger project investigating logical features of diagrammatic design notations [10]. Our work on decidability for TDL begins to explore the efficacy of diagrammatic representations.
Reference: 8. <author> Kathi Fisler. </author> <title> Containment of regular languages in non-regular timing diagram languages is decidable. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Verification (CAV), </booktitle> <year> 1997. </year>
Reference-contexts: The logic, which has been presented before <ref> [8] </ref>, is unique because it expresses certain context-free and context-sensitive languages. The decidability result shows that timing diagram specifications can be verified algorithmically against designs with infinite behaviors. This is significant because timing diagrams express different properties than the formalisms currently used in automated verification. <p> The decidability result shows that timing diagram specifications can be verified algorithmically against designs with infinite behaviors. This is significant because timing diagrams express different properties than the formalisms currently used in automated verification. A preliminary version of this result, covering only designs with finite behaviors, appeared previously <ref> [8, 10] </ref>; the extension to infinite behaviors is new. Sect. 2 provides a brief overview of computer-aided verification. The timing diagram formalization appears in Sect. 3; readers familiar with the logic can skip this section. Sect. 4 discusses timing diagram express-ibility and presents the decidability result. <p> The decision procedure for the invariant semantics is simple when the regular language to be tested contains only finite words: the language generated by NFA A is contained in the language of a timing diagram iff no reachable state of A generates a word accepted by M FAIL <ref> [8] </ref>. The problem is more difficult for !-regular languages. Consider a word in which no index satisfies some time point in the guarantee portion. If the word is finite, M FAIL can detect this upon reaching the end of the word.
Reference: 9. <author> Kathi Fisler. </author> <title> Counter machine constructions for timing diagrams. </title> <type> Technical report, </type> <institution> Department of Computer Science, Rice University, </institution> <year> 1998. </year> <note> In preparation. </note>
Reference-contexts: For each k j &lt; n, we also construct 1-2DCM M j accepting finite words that match D up to time point p j and end in the index immediately following 3 For lack of space, the proof of this and other machine claims are provided elsewhere <ref> [9] </ref> (Note to editor: if more space is allowed in the final paper, proofs will be added as possible). jolli98.tex; 10/03/1998; 11:07; no v.; p.12 DRAFT DRAFT- DRAFT 13 that which satisfied p j .
Reference: 10. <author> Kathryn Fisler. </author> <title> A Unified Approach to Hardware Verification Through a Heterogeneous Logic of Design Diagrams. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <year> 1996. </year>
Reference-contexts: The decidability result shows that timing diagram specifications can be verified algorithmically against designs with infinite behaviors. This is significant because timing diagrams express different properties than the formalisms currently used in automated verification. A preliminary version of this result, covering only designs with finite behaviors, appeared previously <ref> [8, 10] </ref>; the extension to infinite behaviors is new. Sect. 2 provides a brief overview of computer-aided verification. The timing diagram formalization appears in Sect. 3; readers familiar with the logic can skip this section. Sect. 4 discusses timing diagram express-ibility and presents the decidability result. <p> Given the restriction to reversal boundedness, however, our 1-2DCM can only process a bounded number of match attempts before accepting or rejecting the word. Each machine used in the decision procedures attempts at most one match. This is sufficient for reversal-boundedness, as argued in previous work <ref> [10] </ref>. Our decision procedures construct several 1-2DCM for a given timing diagram. <p> Containment between timing diagram languages is crucial for performing such reductions. Timing diagrams without parametric timing constraints correspond to regular languages <ref> [10] </ref>; reductions are therefore decidable for such diagrams. Unfortunately, our current decision procedures are insufficient for addressing containment between arbitrary timing diagram languages, finite or infinite. <p> TDL also differs in its design goals. With one exception [7], other formalizations are used as interfaces to existing sentential representations for which verification algorithms already exist. In contrast, TDL is part of a larger project investigating logical features of diagrammatic design notations <ref> [10] </ref>. Our work on decidability for TDL begins to explore the efficacy of diagrammatic representations. Based on previous undecidability results regarding timing constraints [2, 16], we expected containment of a regular language in a timing diagram language to be undecidable.
Reference: 11. <author> Seymour Ginsburg. </author> <title> The Mathematical Theory of Context-Free Languages. </title> <publisher> McGraw-Hill, </publisher> <year> 1966. </year>
Reference-contexts: As language containment is decidable for (!-)regular languages [22], these properties can be verified algorithmically. However, containment of a regular language (design) in a context-free language (property) is undecidable <ref> [11] </ref>. Accordingly, existing algorithmic verification tools support only regular language properties. As we show in Sect. 4, timing diagrams express a subset of context-free and context-sensitive languages in which containment of a regular language is decidable. This result therefore expands the set of algorithmically verifiable properties. 3.
Reference: 12. <author> David Harel and Danny Raz. </author> <title> Deciding properties of nonregular programs. </title> <journal> SIAM Journal of Computing, </journal> <volume> 22(4) </volume> <pages> 857-874, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: In addition, our timing diagrams clearly describe context-free and context-sensitive languages, and containment for each is known to be undecidable [13]. A paper by Harel and Raz <ref> [12] </ref>, in which non-regular extensions of propositional dynamic logic expressions were found to be decidable under certain structural restrictions, challenged this hypothesis. Timing diagrams depict non-regular languages meeting certain structural restrictions.
Reference: 13. <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Based on previous undecidability results regarding timing constraints [2, 16], we expected containment of a regular language in a timing diagram language to be undecidable. In addition, our timing diagrams clearly describe context-free and context-sensitive languages, and containment for each is known to be undecidable <ref> [13] </ref>. A paper by Harel and Raz [12], in which non-regular extensions of propositional dynamic logic expressions were found to be decidable under certain structural restrictions, challenged this hypothesis. Timing diagrams depict non-regular languages meeting certain structural restrictions.
Reference: 14. <author> Oscar H. Ibarra. </author> <title> Reversal-bounded multicounter machines and their decision problems. </title> <journal> Journal of the ACM, </journal> <volume> 25(1) </volume> <pages> 116-133, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: The following formal definition is adapted from a paper by Ibarra <ref> [14] </ref>. Definition 5. 1. <p> Whether containment between 1-2DCM representing timing diagram languages is decidable is an open problem. The single 1-2DCM accepting a finite timing diagram language is not reversal bounded, so Ibarra's decidability results do not apply. Containment between arbitrary 1-2DCM languages is known to be undecidable <ref> [14] </ref>. However, timing diagrams cannot express all 1-2DCM languages. The following "timing diagram" is not well-formed in TDL due to the disjunction in the time-bound expression. A 1-2DCM could be constructed to accept the language of this diagram under either semantics.
Reference: 15. <author> Oscar H. Ibarra, Tao Jiang, Nicholas Tran, and Hui Wang. </author> <title> New decidability results concerning two-way counter machines and applications. </title> <booktitle> In Proceedings of the 20th International Colloquium on Automata, Languages, and Programming (ICALP), 1993. Lecture Notes in Computer Science, </booktitle> <pages> 700. </pages>
Reference-contexts: Languages accepted by 1-2DCM can be characterized by the number of times the counter changes between incrementing and decrementing while reading the input tape. Denoting this parameter by r, the follow ing results about 1-2DCM (r) are due to Ibarra et al. <ref> [15] </ref>: Theorem 1 (Ibarra et al., 1993). For every r 1, emptiness is decidable for 1-2DCM (r). r 1-2DCM (r) is effectively closed under complementation, inter section, and union.
Reference: 16. <author> Farnam Jahanian, Aloysius K. Mok, and Douglas A. Stuart. </author> <title> Formal specification of real-time systems. </title> <type> Technical Report CS-TR-88-25, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <year> 1988. </year>
Reference-contexts: Ramakrishna et al. have proven decidability for a graphical, real-time, interval temporal logic without parametric timing constraints [21]. Jahanian, Mok, and Stuart have a textual logic of real-time timing constraints (RTL), that is undecidable <ref> [16] </ref>. Alur, Hen-zinger, and Vardi studied parametric timing constraints for real-time systems using a theory of parametric timed automata with multiple clocks for tracking parametric values [2]. They showed language emptiness is decidable for one parametric clock, undecidable for three parametric clocks, and an open problem for two parametric clocks. <p> In contrast, TDL is part of a larger project investigating logical features of diagrammatic design notations [10]. Our work on decidability for TDL begins to explore the efficacy of diagrammatic representations. Based on previous undecidability results regarding timing constraints <ref> [2, 16] </ref>, we expected containment of a regular language in a timing diagram language to be undecidable. In addition, our timing diagrams clearly describe context-free and context-sensitive languages, and containment for each is known to be undecidable [13].
Reference: 17. <author> K. Khordoc, M. Dufresne, E. Cerny, P.A. Babkine, and A. Silburt. </author> <title> Integrating behavior and timing in executable specifications. </title> <booktitle> In Proceedings of Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 385-402, </pages> <year> 1993. </year>
Reference-contexts: Brzozowski, Gahlinger, and Mavaddat provide algorithms for testing consistency and satisfiability of timing specifications given as timing diagrams in the context of interfacing components [4]; Cerny and Khor-doc have done similar work [5]. Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs <ref> [17, 19] </ref>. Damm, Josko, and Schlor [6], as well as Berkane, Gandrabur and Cerny [3], have formalized timing diagram notations for use in verification.
Reference: 18. <author> Robert P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Properties are often behavioral in nature (as opposed to structural). A traffic light controller, for example, should display green lights to only one street at a time; in addition, each street should periodically get a green light. One approach to computer-aided verification expresses both designs and properties as automata <ref> [18] </ref>. Automata may be viewed either as language generators or as language acceptors. Viewing a design as a generator and a property as an acceptor, this method asks whether the property automaton accepts the language generated by the design automaton. <p> Such machines may generate finite or infinite words; in the latter case, the languages are called !-regular [22]. A 1 Unfortunately, verification is intractable for many realistic designs due to the exponential growth of the state space; this problem is called state explosion <ref> [18] </ref>. jolli98.tex; 10/03/1998; 11:07; no v.; p.2 DRAFT DRAFT- DRAFT 3 large class of properties (including those expressible with propositional linear temporal logic [20]) is expressible with regular languages [23]. As language containment is decidable for (!-)regular languages [22], these properties can be verified algorithmically. <p> If ' 1 ; : : : ; ' k entails ', we can verify ' by verifying each ' i ; these may be simpler properties requiring fewer computational resources <ref> [18] </ref>. Containment between timing diagram languages is crucial for performing such reductions. Timing diagrams without parametric timing constraints correspond to regular languages [10]; reductions are therefore decidable for such diagrams. Unfortunately, our current decision procedures are insufficient for addressing containment between arbitrary timing diagram languages, finite or infinite.
Reference: 19. <author> Philippe Mooeschler, Hans Peter Amann, and Pausto Pellandini. </author> <title> High-level modeling using extended timing diagrams. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <pages> pages 494-499, </pages> <year> 1993. </year>
Reference-contexts: Brzozowski, Gahlinger, and Mavaddat provide algorithms for testing consistency and satisfiability of timing specifications given as timing diagrams in the context of interfacing components [4]; Cerny and Khor-doc have done similar work [5]. Several researchers propose writing behavioral specifications with algebras of timing diagrams annotated with programming constructs <ref> [17, 19] </ref>. Damm, Josko, and Schlor [6], as well as Berkane, Gandrabur and Cerny [3], have formalized timing diagram notations for use in verification. <p> Languages accepted by 1-2DCM can be characterized by the number of times the counter changes between incrementing and decrementing while reading the input tape. Denoting this parameter by r, the follow ing results about 1-2DCM (r) are due to Ibarra et al. [15]: Theorem 1 <ref> (Ibarra et al., 1993) </ref>. For every r 1, emptiness is decidable for 1-2DCM (r). r 1-2DCM (r) is effectively closed under complementation, inter section, and union.
Reference: 20. <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: A 1 Unfortunately, verification is intractable for many realistic designs due to the exponential growth of the state space; this problem is called state explosion [18]. jolli98.tex; 10/03/1998; 11:07; no v.; p.2 DRAFT DRAFT- DRAFT 3 large class of properties (including those expressible with propositional linear temporal logic <ref> [20] </ref>) is expressible with regular languages [23]. As language containment is decidable for (!-)regular languages [22], these properties can be verified algorithmically. However, containment of a regular language (design) in a context-free language (property) is undecidable [11]. Accordingly, existing algorithmic verification tools support only regular language properties. <p> A timing diagram language is any language that is iteratively or invariantly described by some TDL timing diagram. 4. Expressibility and Decidability Although TDL provides a linear-time temporal logic, it is incomparable with textual linear temporal logics such as LTL <ref> [20] </ref> with regard to expressiveness. TDL cannot express the LTL formula Fp ("eventually p", same as 3p) because there is no way to stop the repeated walks at a particular point.
Reference: 21. <author> Y.S. Ramakrishna, L.K. Dillon, L.E. Moser, P.M. Melliar-Smith, and G. Kutty. </author> <title> A real-time interval logic and its decision procedure. </title> <booktitle> In Proceedings of the Thirteenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 173-192, </pages> <month> December </month> <year> 1993. </year> <note> Springer-Verlag Lecture Notes in Computer Science volume 761. </note>
Reference-contexts: A natural question arises: is verification decidable for TDL? Others have investigated the decidability of verification problems involving timing constraints. Ramakrishna et al. have proven decidability for a graphical, real-time, interval temporal logic without parametric timing constraints <ref> [21] </ref>. Jahanian, Mok, and Stuart have a textual logic of real-time timing constraints (RTL), that is undecidable [16]. Alur, Hen-zinger, and Vardi studied parametric timing constraints for real-time systems using a theory of parametric timed automata with multiple clocks for tracking parametric values [2].
Reference: 22. <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 133-191. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: In an automata-based framework, designs are expressed by finite state machines; these correspond to regular languages. Such machines may generate finite or infinite words; in the latter case, the languages are called !-regular <ref> [22] </ref>. <p> As language containment is decidable for (!-)regular languages <ref> [22] </ref>, these properties can be verified algorithmically. However, containment of a regular language (design) in a context-free language (property) is undecidable [11]. Accordingly, existing algorithmic verification tools support only regular language properties.
Reference: 23. <author> Moshe Y. Vardi and Pierre Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First IEEE Symposium on Logic and Computer Science (LICS), </booktitle> <year> 1986. </year> <note> jolli98.tex; 10/03/1998; 11:07; no v.; p.20 </note>
Reference-contexts: is intractable for many realistic designs due to the exponential growth of the state space; this problem is called state explosion [18]. jolli98.tex; 10/03/1998; 11:07; no v.; p.2 DRAFT DRAFT- DRAFT 3 large class of properties (including those expressible with propositional linear temporal logic [20]) is expressible with regular languages <ref> [23] </ref>. As language containment is decidable for (!-)regular languages [22], these properties can be verified algorithmically. However, containment of a regular language (design) in a context-free language (property) is undecidable [11]. Accordingly, existing algorithmic verification tools support only regular language properties. <p> The string view of traces suggests a correlation between linear temporal logic and formal languages. This is borne out in practice; verification tools support linear temporal logics by translating expressions into Buchi automata and performing language containment as discussed in Sect. 2 <ref> [23] </ref>. Formal languages therefore appear to provide an appropriate semantic model for timing diagrams. TDL takes this approach, but requires a more general class of languages than the regular languages due to the use of variables in time bound annotations.
References-found: 23

