URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/able/ftp/style-fse3.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/able/www/paper_abstracts/style-fse3.html
Root-URL: 
Title: Formalizing style to understand descriptions of software architecture  
Author: Gregory Abowd, Robert Allen and David Garlan 
Keyword: Software architecture, models of architectural style, formal specification, the Z notation  
Date: July 13, 1994  
Address: Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: The software architecture of most systems is described informally and diagrammatically by means of boxes and lines. In order for these descriptions to be meaningful at all, the diagrams are understood by interpreting the boxes and lines in specific, conventionalized ways. The imprecision of these interpretations has a number of limitations. In this paper we consider these conventionalized interpretations as architectural styles and provide a formal framework for their uniform definition. In addition to providing a template for precisely defining new architectural styles, this framework allows for analysis within and between different architectural styles. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, R., and Garlan, D. </author> <title> A formal approach to software architectures. </title> <note> In Proceedings of IFIP'92 (September 1992), </note> <editor> J. van Leeuwen, Ed., </editor> <publisher> Elsevier Science Publishers B.V. </publisher>
Reference-contexts: Other formal modeling of classes of architectural descriptions have been presented by the authors and other colleagues, in the form of a formalization for a class of signal processing systems [8], the pipe-filter style <ref> [1] </ref> and the implicit invocation style [9]. This previous work was a strong motivation for providing a unified framework for defining an architectural styles. <p> In general, this is perhaps the hardest part of the process, since to do this properly we must come to grips with the intuition behind the use of the style. In the case of PF, an appropriate formal description of the semantic domain already exists <ref> [1, 2] </ref>. Here we will use only those aspects of the model that are necessary to illustrate the basic ideas. The PF style interprets components as filters, which are typed stream transducers.
Reference: [2] <author> Allen, R., and Garlan, D. </author> <title> Towards formalized software architectures. </title> <type> Tech. Rep. </type> <institution> CMU-CS-92-163, Carnegie Mellon University, School of Computer Science, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: In general, this is perhaps the hardest part of the process, since to do this properly we must come to grips with the intuition behind the use of the style. In the case of PF, an appropriate formal description of the semantic domain already exists <ref> [1, 2] </ref>. Here we will use only those aspects of the model that are necessary to illustrate the basic ideas. The PF style interprets components as filters, which are typed stream transducers. <p> A step in this behavior is either a computation step for one filter or a transmission step for one pipe, all else remaining unchanged. Details of this behavioral specification have been omitted here but can be found in <ref> [2] </ref>. 4.2 Concrete Syntax The second part of a style definition is the creation of a style-specific concrete syntax. While the details of such syntax are important, in this paper we are more concerned with understanding the relationship between these descriptions and their associated meanings. <p> Formally, we represent these languages as subsets of the respective description languages introduced in Section 3. FilterDescriptions : ff COMPDESC PipeDescriptions : ff CONNDESC For concreteness, Figure 6 illustrates the definition of a filter that capitalizes its character input stream using one notation developed for this style <ref> [2] </ref>. 11 4.3 Meaning Functions The third part of a style description is to define the meaning of the architectural syntax in terms of the semantic model. <p> For example, Allen and Garlan showed formally that in the pipe and filter style it is semantically meaningful to decompose a component (filter) into a configuration of pipes and filters <ref> [2] </ref>. In their treatment, the decomposition is meaningful when the behavior of the unbound ports of the associated configuration matches the behavior of ports of an equivalent filter.
Reference: [3] <author> Allen, R., and Garlan, D. </author> <title> Formalizing architectural connection. </title> <booktitle> In International Conference on Software Engineering: </booktitle> <address> ICSE-16 (Sorrento, Italy, </address> <month> May </month> <year> 1994), </year> ???, <note> p. </note> ??? 
Reference-contexts: We chose Z because it was simple to define the framework abstractly. It is quite possible that more appropriate formalisms could be chosen for parts of our examples. For instance, Allen and Garlan have recently explored the utility of process algebras for describing the protocols associated with conector types <ref> [3] </ref>. 2 What's in a Style? In order to provide a precise meaning for architectural descriptions it is important to distinguish the abstract syntactic domain of architectural descriptions from the semantic domain of architectural meanings.
Reference: [4] <institution> Proceedings of the Workshop on Domain-Specific Software Architectures (Hidden Valley, </institution> <address> PA, </address> <month> July </month> <year> 1990), </year> <journal> Software Engineering Institute. </journal> <volume> 25 </volume>
Reference-contexts: informal understanding of style toward a framework which suggests a uniform description of all styles and provides a rigorous means of comparing styles. 3 There are a growing number of industrial research and development efforts that are creating domain--specific architectural styles | or "reference architectures" | for specific product families <ref> [4, 6, 14] </ref>. To the extent that they formalize their architectural frameworks at all, the semantic descriptions produced by these efforts are typically developed from scratch, and each uses different, idiosyncratic conventions and semantic bases.
Reference: [5] <author> D.L.Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <booktitle> Communications of the ACM 15 (December 1972), </booktitle> <pages> 1053-1058. </pages>
Reference-contexts: Garlan and Shaw [11] demonstrated the use of idioms or common patterns of architectural descriptions and how they can be used to provide varied solutions to a common design problem (such as Parnas' Key Word in Context problem <ref> [5] </ref>). The first mention of architectural style was by Perry and Wolf [15]. They introduced style as a means of capturing the similarities between instances of architectures.
Reference: [6] <author> Earl, A. </author> <title> A reference model for computer assisted software engineering environment frameworks. </title> <type> Tech. Rep. </type> <institution> HPL-SEG-TN-90-11, Hewlett Packard Laboratories, Bristol, </institution> <address> England, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: informal understanding of style toward a framework which suggests a uniform description of all styles and provides a rigorous means of comparing styles. 3 There are a growing number of industrial research and development efforts that are creating domain--specific architectural styles | or "reference architectures" | for specific product families <ref> [4, 6, 14] </ref>. To the extent that they formalize their architectural frameworks at all, the semantic descriptions produced by these efforts are typically developed from scratch, and each uses different, idiosyncratic conventions and semantic bases.
Reference: [7] <author> Freeman, P., and A.I.Wasserman. </author> <booktitle> Tutorial on software design techniques, </booktitle> <year> 1976. </year>
Reference-contexts: Does the diagram make sense, that is, does it represent a legal configuration of boxes and lines? 1 Box and line diagrams in isolation do not provide all of the answers to these questions, so designers typically resort to conventional interpretations of the diagrams in order to provide those answers <ref> [7] </ref>. For example, for one system boxes might represent filters and lines might represent pipes connecting ports of those filters. In another, boxes might represent abstract data types or objects, and lines might represent procedure calls.
Reference: [8] <author> Garlan, D., and Delisle, N. </author> <title> Formal specifications as reusable frameworks. In VDM'90: VDM and Z | Formal Methods in Software Development (Kiel, </title> <address> West Germany, April 1990), </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 150-163. </pages>
Reference-contexts: Other formal modeling of classes of architectural descriptions have been presented by the authors and other colleagues, in the form of a formalization for a class of signal processing systems <ref> [8] </ref>, the pipe-filter style [1] and the implicit invocation style [9]. This previous work was a strong motivation for providing a unified framework for defining an architectural styles.
Reference: [9] <author> Garlan, D., and Notkin, D. </author> <title> Formalizing design spaces: Implicit invocation mechanisms. In VDM'91: Formal Software Development Methods (Noordwijkerhout, The Netherlands, October 1991), </title> <publisher> Springer-Verlag, LNCS 551, </publisher> <pages> pp. 31-44. </pages>
Reference-contexts: Other formal modeling of classes of architectural descriptions have been presented by the authors and other colleagues, in the form of a formalization for a class of signal processing systems [8], the pipe-filter style [1] and the implicit invocation style <ref> [9] </ref>. This previous work was a strong motivation for providing a unified framework for defining an architectural styles. <p> Event systems are increasingly important as a flexible tool integration technique, since they allow the implicit invocation of tools when some other tool announces an event <ref> [9, 16] </ref>. For the purposes of this paper we will treat each component in an event system as an object with a private, internal state and a collection of methods that can be invoked externally to alter the state. <p> FanOut PFGraph connect ~ 2 COMPNAME COMPNAME Garlan and Notkin have used the event system model to investigate the differences between various implementations of an implicit invocation mechanism <ref> [9] </ref>. Their examples concentrate on restrictions to the kinds of events that objects can announce and the form of the event to method binding that a distributor 22 allows.
Reference: [10] <author> Garlan, D., and Scott, C. </author> <title> Adding implicit invocation to traditional programming languages. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Software Engineering (Baltimore, </booktitle> <address> MD, </address> <month> May </month> <year> 1993). </year>
Reference-contexts: ObjectDescriptions : ff COMPDESC DistributorDescriptions : ff CONNDESC For example, Figure 8 illustrates a concrete syntax for the communication description extension that allows an Ada package interface to specify events announced by that package and the method to be invoked when an event is announced by some other package <ref> [10] </ref>. 18 for Package 1 declare Event 1 X : Integer; declare Event 2 when Event 3 =&gt; Method 1 B end for Package 1 for Package 2 declare Event 3 A,B : Integer; when Event 1 =&gt; Method 2 X when Event 2 =&gt; Method 4 end for Package 2
Reference: [11] <author> Garlan, D., and Shaw, M. </author> <title> An introduction to software architecture. </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <address> Volume I (New Jersey, </address> <year> 1993), </year> <editor> V. Ambriola and G. Tortora, Eds., </editor> <publisher> World Scientific Publishing Company. </publisher>
Reference-contexts: Components perform the primary computations of the system. Interactions, or connections, between components are high level communication abstractions. A variety of component and connector types are used to represent different forms of computation or interaction <ref> [11] </ref>. Examples of different component types are modules, filters, objects, and services. Examples of different connector types are pipes, procedure calls, message passing, and event broadcast. <p> It is only recently that this practice has been identified with architectural style. Garlan and Shaw <ref> [11] </ref> demonstrated the use of idioms or common patterns of architectural descriptions and how they can be used to provide varied solutions to a common design problem (such as Parnas' Key Word in Context problem [5]). The first mention of architectural style was by Perry and Wolf [15].
Reference: [12] <author> Horowitz, B. M. </author> <title> The importance of architecture in DOD software. </title> <type> Tech. Rep. </type> <institution> M91-35, The MITRE Corporation, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Software architecture is an important level of description for software systems <ref> [15, 12] </ref>. The software architecture is an abstract model of a system, and so it is relevant to ask what kind of information resides in such a model. In practice, when designers discuss or present a software architecture, they are considering the system as a collection of interacting components.
Reference: [13] <author> Luckham, D. C., and Vera, J. </author> <title> Event-based concepts and language for system architecture. </title> <note> Working draft, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, interfaces to components can be described solely in terms of their procedure signatures, and connectors can be restricted to procedure call. Other execution models include tasks with interprocess communication and event-based systems <ref> [13] </ref>. When so constrained, descriptions can be mapped directly to facilities of a programming language or other executable implementations, and can thereby be given precise meanings. This approach, however, has a number of problems.
Reference: [14] <author> Mettala, E., and Graham, M. H. </author> <title> The domain-specific software architecture program. </title> <type> Tech. Rep. </type> <institution> CMU/SEI-92-SR-9, Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: informal understanding of style toward a framework which suggests a uniform description of all styles and provides a rigorous means of comparing styles. 3 There are a growing number of industrial research and development efforts that are creating domain--specific architectural styles | or "reference architectures" | for specific product families <ref> [4, 6, 14] </ref>. To the extent that they formalize their architectural frameworks at all, the semantic descriptions produced by these efforts are typically developed from scratch, and each uses different, idiosyncratic conventions and semantic bases.
Reference: [15] <author> Perry, D. E., and Wolf, A. L. </author> <title> Foundations for the study of software architecture. </title> <booktitle> Software Engineering Notes 17, 4 (1992), </booktitle> <pages> 40-52. </pages>
Reference-contexts: 1 Introduction Software architecture is an important level of description for software systems <ref> [15, 12] </ref>. The software architecture is an abstract model of a system, and so it is relevant to ask what kind of information resides in such a model. In practice, when designers discuss or present a software architecture, they are considering the system as a collection of interacting components. <p> The first mention of architectural style was by Perry and Wolf <ref> [15] </ref>. They introduced style as a means of capturing the similarities between instances of architectures.
Reference: [16] <author> Reiss, S. </author> <title> Connecting tools using message passing in the Field Environment. </title> <booktitle> IEEE Software 7, </booktitle> <month> 4 (July </month> <year> 1990), </year> <pages> 57-66. </pages>
Reference-contexts: Event systems are increasingly important as a flexible tool integration technique, since they allow the implicit invocation of tools when some other tool announces an event <ref> [9, 16] </ref>. For the purposes of this paper we will treat each component in an event system as an object with a private, internal state and a collection of methods that can be invoked externally to alter the state.
Reference: [17] <author> Rice, M., and Seidman, S. </author> <title> A formal model for module interconnection languages. </title> <journal> IEEE Transactions on Software Engineering 20, </journal> <month> 1 (January </month> <year> 1994), </year> <pages> 88-101. </pages>
Reference-contexts: Rice and Seidman have recently presented a formal model of module interconnection languages (or MILs) that can be used to understand and compare their differences <ref> [17] </ref>. 1.2 Overview In Section 2, we begin by outlining the method we will use to define an architectural style as a mapping from syntactic descriptions to a (style-specific) semantic model.
Reference: [18] <author> Spivey, J. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Finally, in Section 6 we show how these semantic underpinnings support the analysis and comparison of styles. Throughout this paper, we we use the Z specification language to express the formal model <ref> [18] </ref>. Appendix A summaries the Z notation that we use in this paper. The main contribution of this paper is in defining the framework for style definition and then demonstrating its value for architectural analysis of various styles.
Reference: [19] <author> Sullivan, K. J., and Notkin, D. </author> <title> Reconciling environment integration and software evolution. </title> <journal> ACM Transactions on Software Engineering and Methodology 1, </journal> <month> 3 (July </month> <year> 1992), </year> <pages> 229-268. </pages>
Reference-contexts: IO Step b= IO ObjectStep _ IO DistributorStep 5.2 Concrete Syntax A concrete syntax for events systems can be developed as an extension of regular programming languages <ref> [19] </ref>. The details of these extensions are not particularly important for this discussion. These concrete descriptions define a subset of allowable computation and communication descriptions.
References-found: 19

