URL: ftp://www.cs.msstate.edu/staff/dreese/publications/oof_report.ps.gz
Refering-URL: http://www.cs.msstate.edu/PUBLICATIONS/technicalReports.html
Root-URL: 
Email: dreese@erc.msstate.edu  
Title: Object-Oriented Fortran  
Author: D. Reese, E. Luke, G. Henley, N. Doss, S. Korlakunta and G. Smith 
Note: Tech. Rept. MSSU-EIRS-ERC-94-1 G. Smith is now a PhD student in the  This work partially funded under NSF cooperative agreement number ECD-8907070.  
Date: August 23, 1994  
Address: P.O. Box 6176  MS 39762  
Affiliation: NSF Engineering Research Center for Computational Field Simulation Mississippi State University  Mississippi State,  Department of Industrial Engineering, Penn State University  
Abstract: Object-Oriented Fortran (OOF) was developed beginning in 1990 as a means of programming parallel applications in Fortran in a portable fashion. It was designed to hide the underlying machine architecture and message passing mechanism from the application writer. OOF has been implemented on several parallel architectures as well as networks of workstations. Several CFD applications have been written using this system. This paper discusses the design and implementation of OOF and provides insight into lessons learned during its development and use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Bailey, E. Barszcz, and J. Barton. </author> <title> The NAS Parallel Benchmarks. </title> <journal> The International Journal of Supercomputer Applications, </journal> <pages> pages 63-73, </pages> <year> 1991. </year>
Reference-contexts: expected that the execution time of the larger problem size will be reduced when the placement of blocks on processors is optimized. 4.2 NAS Parallel Benchmarks The Numerical Aerodynamic Simulation (NAS) organization has developed the NAS Parallel Benchmarks at NASA Ames Research Center to evaluate the performance of parallel computers <ref> [1] </ref>. The aerophysics community is a consumer of highly parallel systems and the NAS program is a large scale effort to advance the state of computational aerodynamics. The NAS Parallel Benchmark suite is designed to aid in the performance evaluation of the highly parallel systems.
Reference: [2] <author> B. Chapman, P. Mehrotra, and H. Zima. </author> <title> Programming in Vienna Fortran. </title> <journal> Scientific Programming, </journal> <volume> 1(1), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: OOF hides the low-level message passing from the programmer and therefore provides a more abstract model for programming. The other portable Fortran interface category is that taken by High Performance Fortran [10], Fortran D [7], and Vienna Fortran <ref> [2] </ref>. These systems provide either language extensions or compiler directives to specify how arrays of data are to be distributed across processors.
Reference: [3] <author> J. Coker, J. Harden, D. Linder, E. Luke, and W. Welch. </author> <title> A Technical Overview of the MADEM Accelerator. </title> <type> Technical report, </type> <institution> Mississippi State University, </institution> <month> July </month> <year> 1987. </year>
Reference: [4] <author> J. Dongarra, A. Geist, R. Manchek, and V. Sunderam. </author> <title> Integrated PVM Framework Supports Heterogeneous Network Computing. </title> <journal> Computers in Physics, </journal> <volume> 7(2) </volume> <pages> 166-75, </pages> <month> April </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: These interfaces generally fall into two categories. The first category consists of Fortran interfaces to portable message passing systems such as PVM <ref> [4] </ref> and MPI [6]. The model provided by OOF can take advantage of any of these underlying message passing systems to manage the actual communication between processors. OOF hides the low-level message passing from the programmer and therefore provides a more abstract model for programming.
Reference: [5] <author> N. Doss. </author> <title> Transparent Management of Shared Memory Resources Clustered Parallel Architec--tures Based on a Distributed Memory Programming Model. </title> <type> Master's thesis, </type> <institution> Mississippi State University, </institution> <month> December </month> <year> 1992. </year> <note> Computer Science (under D. Reese). </note>
Reference-contexts: The same runtime system supports both CPC and OOF programs. 2.4 Shared Memory Cluster Support In order to provide efficient communication on architectures which have shared memory, or clusters of shared memory processors connected via interconnection networks, a version of OOF was implemented which utilizes shared memory for communication <ref> [5] </ref>. This version utilizes a layered approach so that the general support for shared memory is portable across all shared memory architectures and only the underlying processor specific parts need be written to port to a new 15 architecture.
Reference: [6] <author> Message Passing Interface Forum. </author> <title> MPI: A Message-Passing Interface Standard. </title> <institution> Technical Report Computer Science Department Technical Report CS-94-230, University of Tennessee, Knoxville, TN, </institution> <month> May 5 </month> <year> 1994. </year> <booktitle> To appear in the International Journal of Supercomputing Applications, </booktitle> <volume> Volume 8, Number 3/4, </volume> <year> 1994. </year>
Reference-contexts: These interfaces generally fall into two categories. The first category consists of Fortran interfaces to portable message passing systems such as PVM [4] and MPI <ref> [6] </ref>. The model provided by OOF can take advantage of any of these underlying message passing systems to manage the actual communication between processors. OOF hides the low-level message passing from the programmer and therefore provides a more abstract model for programming.
Reference: [7] <author> G. Fox, S. Hiranandani, K. Kennedy, C. Koelbel, U. Kremer, C. Tseng, and M. Wu. </author> <title> Fortran D Language Specification. </title> <type> Technical Report COMP TR90-141, </type> <institution> Department of Computer Science, Rice University, Houston, TX, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: OOF hides the low-level message passing from the programmer and therefore provides a more abstract model for programming. The other portable Fortran interface category is that taken by High Performance Fortran [10], Fortran D <ref> [7] </ref>, and Vienna Fortran [2]. These systems provide either language extensions or compiler directives to specify how arrays of data are to be distributed across processors.
Reference: [8] <author> G. Henley. </author> <title> Message Passing in Fortran on a Multicomputer. </title> <booktitle> In Proceedings of the 26th Annual Southeast Regional ACM Conference, </booktitle> <pages> pages 562-566, </pages> <year> 1988. </year>
Reference-contexts: The reactive scheduler would place threads on a queue of active processes when receive requests were satisfied. The gravel parallel programming environment supported C with a smart pre-processor and supported a Fortran interface by providing a library of message passing calls <ref> [8] </ref>. 1.2 Design Rationale The CSP model as it was implemented in the gravel environment required a context switch to correctly emulate CSP on a single processor. Context switches were used to switch from threads blocked in a receive call waiting on messages to threads that had previously received messages.
Reference: [9] <author> S. Korlakunta. </author> <title> Object-oriented Implementation for NAS Parallel Benchmarks. </title> <type> Master's thesis, </type> <institution> Mississippi State University, </institution> <month> December </month> <year> 1994. </year> <note> Computer Science (under D. Reese). </note>
Reference-contexts: These benchmarks have been implemented on many parallel architectures. In order to measure the overhead of OOF applications, we implemented the NAS benchmarks in OOF and compared these implementations running on the Intel iPSC/860 with the versions obtained from NAS using native Intel calls for messaging <ref> [9] </ref>. Performance comparisons between the OOF implementations of the NAS benchmarks and the native Intel implementations showed that the OOF programs have exhibited approximately 40 percent overhead on moderate size problems compared to the structured programming implemen 22 tations.
Reference: [10] <author> D. Loveman. </author> <title> High Performance Fortran. </title> <journal> IEEE Parallel & Distributed Technology, </journal> <volume> 1(1), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: OOF hides the low-level message passing from the programmer and therefore provides a more abstract model for programming. The other portable Fortran interface category is that taken by High Performance Fortran <ref> [10] </ref>, Fortran D [7], and Vienna Fortran [2]. These systems provide either language extensions or compiler directives to specify how arrays of data are to be distributed across processors.
Reference: [11] <author> E. Luke. </author> <title> The Rock Parallel Programming Environment. </title> <booktitle> In Proceedings of the 26th Annual Southeast Regional ACM Conference, </booktitle> <pages> pages 35-38, </pages> <year> 1988. </year>
Reference-contexts: In gravel, parallelism was achieved by executing different threads on different processors. This environment supported the concept of virtual processors by providing the capability of managing 3 several threads on a single processor with a simple reactive scheduler <ref> [11] </ref>. The reactive scheduler would place threads on a queue of active processes when receive requests were satisfied.
Reference: [12] <author> E. Luke. </author> <title> The Development of a Scalable Parallel 3-D CFD Algorithm for Turbomachinery. </title> <type> Master's thesis, </type> <institution> Mississippi State University, </institution> <month> July </month> <year> 1993. </year> <note> Computational Engineering (under D. Reese). </note>
Reference-contexts: The results of that experiment are also described in this section. 4.1 Turbomachinery Code An OOF turbomachinery simulation application solves the Euler equations, a subset of the Navier-Stokes equations, for transonic fluid flow about rotating geometries such as prop fans <ref> [12] </ref>. The solver implemented is an implicit solver that has been modified slightly in order to improve parallel performance. Parallelism is extracted via domain decomposition where the grid about the geometry is broken into a number of sub-domains. <p> For example, in the turbomachinery application the communication between rotating zones was managed by a single array of floats in the sequential application. In the parallel version, it was managed by a much more complex distributed data structure <ref> [12] </ref>. This increased complexity was difficult to capture with the simple array models offered by standard Fortran and as a result impeded development of the turbomachinery application. In the final analysis, OOF has proven to be a highly portable threaded parallel programming language.
Reference: [13] <author> D. Reese and E. Luke. </author> <title> Object-Oriented Fortran for Development of Portable Parallel Programs. </title> <booktitle> In Proceedings of the 3rd IEEE Symposium on Parallel Distributed Processing, </booktitle> <pages> pages 608-615, </pages> <address> Dallas, TX, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: In addition to solving the above problems, OOF provides a familiar interface to many CFD application developers by using Fortran as the base language <ref> [13] </ref>. 2 Features of Object-Oriented Fortran OOF consists of a set of extensions to Fortran to support declaration, creation, and management of objects. In addition to the Fortran interface, a C++ interface is also provided.
Reference: [14] <author> G. Smith. </author> <title> Investigation of the Usability of a Visual Editor for Programming Parallel Data Decomposition Problems in an Object-oriented Language. </title> <type> Master's thesis, </type> <institution> Mississippi State University, </institution> <month> December </month> <year> 1992. </year> <note> Computer Science (under D. Reese). </note>
Reference-contexts: operators should be scheduled for execution. 10 The syntax for the ALLOW statement is: allow /object-class-name/ operator-namef,operator-nameg 2.2 The Visual Editor In order to enhance the interface for application programmers developing OOF applications, a visual editor (ViSE) was developed to support graphical design of the object structure and communication interface <ref> [14] </ref>. This editor produces skeletal OOF code to implement the communication structure. This skeletal code can then easily be expanded by the user to include the necessary computations. The programming steps followed when using the visual editor employ a hybrid graphical/textual approach.
Reference: [15] <author> G. Smith. </author> <title> Object-Oriented Fortran Tutorial. </title> <type> Technical Report MSSU-EIRS-93-17, </type> <institution> Mississippi State University, </institution> <month> July </month> <year> 1993. </year> <month> 26 </month>
Reference-contexts: For a more detailed description of the extensions including complete syntactic definitions, see <ref> [15] </ref>. 6 2.1.1 Object Declaration. Definition of object classes including associated data, operators and functions is handled through the object declaration block. This block associates a name with the object class much as a structure declaration associates a name with a list of variables in C.
References-found: 15

