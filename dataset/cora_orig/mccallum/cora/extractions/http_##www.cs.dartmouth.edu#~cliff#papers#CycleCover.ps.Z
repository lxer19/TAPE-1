URL: http://www.cs.dartmouth.edu/~cliff/papers/CycleCover.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Title: A Parallel Algorithm for Approximating the Minimum Cycle Cover  
Author: Philip Klein Clifford Stein 
Keyword: (m n)= log n processors.  
Address: Cambridge, MA  Cambridge, MA  
Affiliation: Aiken Computation Laboratory Harvard University  Laboratory for Computer Science MIT  
Abstract: We address the problem of approximating a minimum cycle cover in parallel. We give the first efficient parallel algorithm for finding an approximation to a minimum cycle cover. Our algorithm finds a cycle cover whose size is within a factor of O(1 + n logn m+n ) of the minimum sized cover using O(log 2 n) time on
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon and M. Tarsi. </author> <title> Covering multigraphs by simple circuits. </title> <journal> SIAM Journal of Algebraic and Discrete Methods, </journal> <volume> 6 </volume> <pages> 345-350, </pages> <year> 1985. </year>
Reference-contexts: Additionally, our techniques yield a useful sequential algorithm. The sequential algorithm that finds the smallest cycle cover is that of Alon and Tarsi <ref> [1] </ref>; their fl Research supported by ONR grant N00014-88-K-0243 and DARPA grant N00039-88-C0113 at Harvard University. This author's current address is Computer Science Department, Brown University, Providence, RI y Research supported by a graduate fellowship from GE. <p> Note that for non-sparse graphs (m &gt; n log n), our techniques yield a cover whose size is within a constant factor of optimal. Further, for all classes of graphs, our algorithm is faster than any of the previous algorithms for finding a cycle cover <ref> [1, 7, 8] </ref>. The basis for our approximation algorithm is a routine to find a maximal set of edge-disjoint cycles in an undirected graph, given in [12]. Thus we demonstrate the utility of this technique in parallel combinatorial optimization. <p> They also conjecture that finding the minimum cycle cover is N P -complete. Alon and Tarsi <ref> [1] </ref> have developed an algorithm that finds a smaller cover, one of size at most minf 5 3 m; m + 7 3 g, and runs in O (m + n 2 ) time.
Reference: [2] <author> B. Awerbach, A. Israeli, and Y. Shiloach. </author> <title> Finding euler circuits in logarithmic parallel time. </title> <booktitle> In Proceedings of the 16th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 249-257, </pages> <year> 1984. </year>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions [14, 15], and Euler tours <ref> [20, 2, 13, 6] </ref>. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors.
Reference: [3] <author> C. Berge. </author> <title> Graphs and hypergraphs. </title> <publisher> North Holland Mathematical library, </publisher> <year> 1979. </year>
Reference-contexts: It is well known that this collection of cycle vectors f (C (e))je 62 F g forms a cycle basis, i.e. a set of linearly independent vectors which span the cycle space <ref> [3] </ref>. We will refer to this particular basis as B. 2.2 Algorithm Maximal Cycles Consider the even-degree subgraph H obtained by adding together mod 2 all the cycles C (e) 2 B. That is, H is defined by (H) = e62F where the sum is elementwise mod 2.
Reference: [4] <author> R. Cole and U. Vishkin. </author> <title> Approximate and exact parallel scheduling with applications to list, tree, and graph problems. </title> <booktitle> In Proceedings of the 27th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 478-491, </pages> <year> 1986. </year>
Reference-contexts: We note that in practice, we would change Step 7 to include a cycle C only if it contained some edge that was not already in C. This could be checked in O (log n) time on (m + n)= log n processors using pointer jumping <ref> [4] </ref>.
Reference: [5] <author> H. </author> <title> Cross. Analysis of flow in networks of conduits of conductors. </title> <type> Bulletin 286, </type> <institution> University of Illinois Engineering Experimental Station, Urbana, Ill., </institution> <year> 1936. </year>
Reference-contexts: We restrict our attention to 2-edge connected (bridgeless) graphs, as any graph with a bridge does not have a cycle cover. In applications such as the analysis of irrigation systems by the Hardy Cross method <ref> [5] </ref> and the analysis of electrical circuits, it is important to find a small cycle cover. Finding a minimum cover|one minimizing the sum of the sizes of the cycles|is conjectured to be NP-complete [7].
Reference: [6] <author> H. Gabow. </author> <title> Using euler partitions to edge-color bipartite multigraphs. </title> <journal> International Journal of Computing and Information Science, </journal> <volume> 5 </volume> <pages> 345-355, </pages> <year> 1976. </year>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions [14, 15], and Euler tours <ref> [20, 2, 13, 6] </ref>. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors.
Reference: [7] <author> A. Itai, R. J. Lipton, C.H. Papadimitriou, and M. Rodeh. </author> <title> Covering graphs by simple circuits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 10(4) </volume> <pages> 746-750, </pages> <year> 1981. </year>
Reference-contexts: In applications such as the analysis of irrigation systems by the Hardy Cross method [5] and the analysis of electrical circuits, it is important to find a small cycle cover. Finding a minimum cover|one minimizing the sum of the sizes of the cycles|is conjectured to be NP-complete <ref> [7] </ref>. We give the first efficient parallel approximation algorithm for this problem, as we can find an O (1 + n log n m+n ) approximation to the minimum cycle cover in O (log 2 n) time on (m + n)= log n processors. <p> Note that for non-sparse graphs (m &gt; n log n), our techniques yield a cover whose size is within a constant factor of optimal. Further, for all classes of graphs, our algorithm is faster than any of the previous algorithms for finding a cycle cover <ref> [1, 7, 8] </ref>. The basis for our approximation algorithm is a routine to find a maximal set of edge-disjoint cycles in an undirected graph, given in [12]. Thus we demonstrate the utility of this technique in parallel combinatorial optimization. <p> The first algorithm for this problem, by Itai and Rodeh [8], finds a cover of size O (m + n log n) in O (n 3 ) time. Subsequently, Itai, Lipton, Papadimitriou and Rodeh <ref> [7] </ref> showed that every graph has a cover of size minf3m 6; m + 6n 7g and that this cover can be found in O (n 2 ) time. <p> This result relies on a proof by Seymour [17] that every bridgeless graph has a nowhere zero flow modulo 6. Alon and Tarsi also note that a certain graph called the Petersen graph <ref> [8, 7] </ref> has 15 edges and no cycle cover of size less than 21. This graph can be generalized to show that there exists an infinite family of graphs of m edges that have a minimum cycle cover of size at least 7 5 m. <p> It is known how to find such a graph B in linear time sequentially <ref> [7] </ref>, but this requires using depth-first search. We present a parallel algorithm that does not use depth-first search and finds a graph B in O (log n) time using (m + n)= log n processors.
Reference: [8] <author> A. Itai and M. Rodeh. </author> <title> Covering a graph by circuits. </title> <booktitle> In Proceeding of the ICALP Conference, Udine, </booktitle> <year> 1978. </year>
Reference-contexts: Note that for non-sparse graphs (m &gt; n log n), our techniques yield a cover whose size is within a constant factor of optimal. Further, for all classes of graphs, our algorithm is faster than any of the previous algorithms for finding a cycle cover <ref> [1, 7, 8] </ref>. The basis for our approximation algorithm is a routine to find a maximal set of edge-disjoint cycles in an undirected graph, given in [12]. Thus we demonstrate the utility of this technique in parallel combinatorial optimization. <p> Sequential algorithms for finding a cycle cover have been developed with two goals in mind. The first goal is to find a cover of small size, and the second is to get an algorithm that runs quickly. The first algorithm for this problem, by Itai and Rodeh <ref> [8] </ref>, finds a cover of size O (m + n log n) in O (n 3 ) time. <p> This result relies on a proof by Seymour [17] that every bridgeless graph has a nowhere zero flow modulo 6. Alon and Tarsi also note that a certain graph called the Petersen graph <ref> [8, 7] </ref> has 15 edges and no cycle cover of size less than 21. This graph can be generalized to show that there exists an infinite family of graphs of m edges that have a minimum cycle cover of size at least 7 5 m.
Reference: [9] <editor> F. Jaeger. </editor> <booktitle> On nowhere-zero flow in multigraphs. In Proceedings of the Fifth British Combinatorial Conference, </booktitle> <pages> pages 373-378, </pages> <year> 1975. </year>
Reference-contexts: Subsequently, Itai, Lipton, Papadimitriou and Rodeh [7] showed that every graph has a cover of size minf3m 6; m + 6n 7g and that this cover can be found in O (n 2 ) time. This result relies on a result of Jaeger <ref> [9] </ref> that shows that every bridgeless graph has a 4 nowhere zero flow modulo 8, and results of Tarjan [19] and Shiloach [18] that find edge-disjoint branchings. They also conjecture that finding the minimum cycle cover is N P -complete.
Reference: [10] <author> H. Jung. </author> <title> An optimal parallel algorithm for computing connected components in a graph. </title> <type> Preprint, </type> <institution> Humboldt University, Berlin, German Democratic Republic, </institution> <year> 1989. </year>
Reference-contexts: By Lemma 3.1, there are O (log n) iterations and each iteration is the algorithm Maximal Cycles with some restrictions placed on the choice of the spanning tree. By looking at the spanning tree algorithm of <ref> [10] </ref>, we see that this only makes the problem easier and hence adds no additional resources. We note that in practice, we would change Step 7 to include a cycle C only if it contained some edge that was not already in C.
Reference: [11] <author> R. Karp, E. Upfal, and A. Wigderson. </author> <title> Constructing a perfect matching is in random NC. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 22-32, </pages> <year> 1985. </year> <month> 10 </month>
Reference-contexts: Even if this sequence of computations could be efficiently parallelized, the best known NC algorithm for computing one maximum flow in a graph with polynomial bounded capacities uses many processors and randomness <ref> [11] </ref>. Thus, we focus on a different strategy that is based on using the algorithm Maximal Cycles as a subroutine. First observe that the output of this algorithm is a set of cycles C such that m n + 1 jE (C)j m.
Reference: [12] <author> P. Klein and C. Stein. </author> <title> A parallel algorithm for eliminating cycles in undirected graphs. </title> <journal> Information Processing Letters, </journal> <volume> 34(6) </volume> <pages> 307-312, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Further, for all classes of graphs, our algorithm is faster than any of the previous algorithms for finding a cycle cover [1, 7, 8]. The basis for our approximation algorithm is a routine to find a maximal set of edge-disjoint cycles in an undirected graph, given in <ref> [12] </ref>. Thus we demonstrate the utility of this technique in parallel combinatorial optimization. Historically, many sequential graph algorithms have relied on decomposing a graph with a breadth-first search or a depth-first search. <p> A slight variation on this algorithm will be an important part of our algorithm to find a minimum cycle cover. For details, the reader is referred to <ref> [12] </ref>. 2.1 Preliminaries Let G = (V; E) be an n-node undirected graph with node set V and edge set E = fe 1 ; : : : ; e m g. Let f0; 1g E denote the m-dimensional vector space over GF (2). <p> These observations suggest the following algorithm, Maximal Cycles, for finding a maximal set of edge-disjoint cycles in G: Step 1: Choose a rooted spanning forest ^ F of G. Step 2: Determine the subgraph H of G by (2). Step 3: Decompose H into edge-disjoint cycles. 3 In <ref> [12] </ref>, we show how to efficiently implement the above algorithm, yielding the following theorem: Theorem 2.1 Algorithm Maximal Cycles finds a maximal set of edge disjoint cycles in an undirected graph in O (log n) time on (n + m)= log n processors. 3 Approximating a Cycle Cover In this section,
Reference: [13] <author> G. F. Lev, N. Pippenger, and L. G. Valiant. </author> <title> A fast parallel algorithm for routing in permutation networks. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30:93-100, </volume> <year> 1981. </year>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions [14, 15], and Euler tours <ref> [20, 2, 13, 6] </ref>. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors.
Reference: [14] <author> L. Lovasz. </author> <booktitle> Computing ears and branchings in parallel. In Proceedings of the 26th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 464-467, </pages> <year> 1985. </year>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions <ref> [14, 15] </ref>, and Euler tours [20, 2, 13, 6]. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors. <p> 2 V , let N (v) be the non-tree neighbor w minimizing level (lca (v; w)) or ; if v has no non-tree neighbors. 4 Let E B = T [ f (v; N (v)) : v 2 V; N (v) 6= ;g. to the ear decomposition algorithm of Lovasz <ref> [14] </ref>. Observe that the first iteration of the algorithm finds a cover of size no less than m n + 1. Thus the number of edges not in C is at most n 1.
Reference: [15] <author> Y. Maon, B. Schieber, and U. Vishkin. </author> <title> Parallel ear decomposition search (EDS) and st-numbering in graphs. </title> <booktitle> In VLSI algorithms and architectures, Lecture notes in computer science 227, </booktitle> <pages> pages 34-45. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions <ref> [14, 15] </ref>, and Euler tours [20, 2, 13, 6]. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors.
Reference: [16] <author> B. Schieber and U. Vishkin. </author> <title> On finding lowest common ancestors: simplification and parallelization. </title> <booktitle> In Agaean Workshop on Computing, </booktitle> <pages> pages 111-123, </pages> <year> 1988. </year> <note> Published as Lecture Notes in Computer Science 319, Springer-Verlag. </note>
Reference-contexts: Proof: The bound follows from the previous results and the results of <ref> [16] </ref> that show how to compute lca and level in the stated time bounds. Our parallel algorithm translates into an efficient sequential algorithm.
Reference: [17] <author> P.D. Seymour. </author> <title> Nowhere-zero 6 flows. </title> <journal> Journal of Combinatorial Theory B, </journal> <volume> 30 </volume> <pages> 130-135, </pages> <year> 1981. </year>
Reference-contexts: Alon and Tarsi [1] have developed an algorithm that finds a smaller cover, one of size at most minf 5 3 m; m + 7 3 g, and runs in O (m + n 2 ) time. This result relies on a proof by Seymour <ref> [17] </ref> that every bridgeless graph has a nowhere zero flow modulo 6. Alon and Tarsi also note that a certain graph called the Petersen graph [8, 7] has 15 edges and no cycle cover of size less than 21.
Reference: [18] <author> Y. Shiloach. </author> <title> Edge-disjoint branching in directed multigraphs. </title> <journal> Information Processing Letters, </journal> <volume> 8 </volume> <pages> 24-27, </pages> <year> 1979. </year>
Reference-contexts: This result relies on a result of Jaeger [9] that shows that every bridgeless graph has a 4 nowhere zero flow modulo 8, and results of Tarjan [19] and Shiloach <ref> [18] </ref> that find edge-disjoint branchings. They also conjecture that finding the minimum cycle cover is N P -complete.
Reference: [19] <author> R. E. Tarjan. </author> <title> A good algorithm for edge-disjoint branchings. </title> <journal> Information Processing Letters, </journal> <volume> 3 </volume> <pages> 51-53, </pages> <year> 1975. </year>
Reference-contexts: This result relies on a result of Jaeger [9] that shows that every bridgeless graph has a 4 nowhere zero flow modulo 8, and results of Tarjan <ref> [19] </ref> and Shiloach [18] that find edge-disjoint branchings. They also conjecture that finding the minimum cycle cover is N P -complete.
Reference: [20] <author> R. E. Tarjan and U. Vishkin. </author> <title> Finding biconnected components and computing tree functions in logarithmic parallel time. </title> <booktitle> In Proceedings of the 16th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 12-20, </pages> <year> 1984. </year> <month> 11 </month>
Reference-contexts: Our work is part of an effort by researchers to design fast and efficient parallel decompositions more suitable for use in parallel computation. Other such decompositions that have proven fruitful include ear decompositions [14, 15], and Euler tours <ref> [20, 2, 13, 6] </ref>. 2 Finding a Maximal Set of Edge Disjoint Cycles We begin by reviewing an algorithm to find a maximal set of edge-disjoint cycles in O (log n) time on (m + n)= log n processors.
References-found: 20

