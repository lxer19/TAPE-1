URL: http://www.fzi.de/prost/people/genssler/SchulzGensslerMohrZimmer98.ps.gz
Refering-URL: http://www.fzi.de/prost/people/genssler.html
Root-URL: http://www.fzi.de
Title: On the Computer Aided Introduction of Design Patterns into Object-Oriented Systems  
Author: Benedikt Schulz Thomas Genler Berthold Mohr Walter Zimmer 
Keyword: design pattern operators, reorganization, refactorings, semantic equivalence, software maintenance, re-engineering, object-oriented systems  
Note: bschulz@fzi.de, phone:+49  
Address: Haid-und-Neu-Str. 10-14 76131 Karlsruhe  
Affiliation: Forschungszentrum Informatik  TLC GmbH Frankfurt  
Email: genssler@fzi.de,  mohr@fzi.de Walter.Zimmer@bku.db.de  
Phone: 721 9654 618  phone:+49 721 9654 620  
Abstract: We present a new approach to the reorganization of object-oriented systems using design patterns. Instead of looking at design patterns as building blocks, we consider them to be operators, whose application transforms an existing design into an improved target design. For this purpose, an algorithmic process of design pattern application is presented. Furthermore we show that design pattern operators can be implemented in terms of refactorings in a behavior preserving way. Afterwards we demonstrate the applicability of our approach by delineating our experiences with a tool prototype, which we implemented in order to reorganize a large C++ system by using design pattern operators. 
Abstract-found: 1
Intro-found: 1
Reference: [Ass98] <author> Uwe Assmann. </author> <title> Meta-programming composers in second-generation component systems. </title> <editor> In J. Bishop and N. Horspool, editors, </editor> <booktitle> Systems Implementation 2000 - Working Conference IFIP WG 2.4, </booktitle> <address> Berlin, February 1998. </address> <publisher> Chapman and Hall. </publisher>
Reference-contexts: We present only contributions, which are closely related to our work. A contribution to the flexible composition of components can be found in <ref> [Ass98] </ref>. The author uses meta-operators to transform data and code and to rearrange slots and methods of parameter components. Similar to our approach various atomic meta-operators are defined and used to built more complex operators. Schema evolution of object-oriented databases can be seen as the basis for Opdykes work.
Reference: [BKKK87] <author> Jay Banerjee, Won Kim, Hyounf-Joo Kim, and Henry F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: The author uses meta-operators to transform data and code and to rearrange slots and methods of parameter components. Similar to our approach various atomic meta-operators are defined and used to built more complex operators. Schema evolution of object-oriented databases can be seen as the basis for Opdykes work. In <ref> [BKKK87] </ref> a set of primitive schema evolution operators for the object-oriented database-system ORION is presented and categorized. However the focus of this contribution is about how to deal with different versions of persistent objects rather than about code transformations in general.
Reference: [BMR + 96] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal. </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons Ltd, </publisher> <year> 1996. </year>
Reference-contexts: This did not happen because the techniques like inheritance or encapsulation were the wrong techniques, but because they only provided a partial solution for the construction of large and complex object-oriented systems. These techniques must be combined with higher level techniques like design patterns [GHJV95] <ref> [BMR + 96] </ref> and frameworks [JF88], [Pre95], [R up97] in order to fully respond to the crisis surrounding software maintenance and extension. <p> The process of pattern application itself is often not taken into consideration. That means that 2 FUNDAMENTALS 4 up to now, design patterns have been seen as building blocks <ref> [BMR + 96] </ref>, rather than as operators. This allows for the easy construction of new systems, but makes it very hard to introduce design patterns into existing systems in order to reorganize them. In order to overcome these shortcomings, a new approach is presented in [Zim97].
Reference: [B ar98] <author> Holger B ar. </author> <title> Automatische Suche von Designproblemen in objekt-orientierten Systemen. </title> <type> Master's thesis, </type> <institution> Forschungszentrum Informatik (FZI) an der Univer-sit at Karlsruhe (TH), </institution> <month> March </month> <year> 1998. </year>
Reference: [Cas92] <author> Eduardo Casais. </author> <title> An incremental class reorganization approach. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Procedings of the 6th ECOOP Conference, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 114-132, </pages> <address> Utrecht, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However the focus of this contribution is about how to deal with different versions of persistent objects rather than about code transformations in general. One of the aspects necessary to improving the structure of object-oriented systems is discussed in <ref> [Cas92] </ref> and [Cas93]. The author describes both a global and an incremental approach to the reorganization of inheritance relationships. The approach focuses on the reduction of redundancies in the class definitions.
Reference: [Cas93] <author> Eduardo Casais. </author> <title> Object-Oriented Systems, volume 1, chapter Automatic Reorganization of Object-Oriented Hierachies: </title> <booktitle> A Case Study, </booktitle> <pages> pages 95-115. </pages> <year> 1993. </year>
Reference-contexts: However the focus of this contribution is about how to deal with different versions of persistent objects rather than about code transformations in general. One of the aspects necessary to improving the structure of object-oriented systems is discussed in [Cas92] and <ref> [Cas93] </ref>. The author describes both a global and an incremental approach to the reorganization of inheritance relationships. The approach focuses on the reduction of redundancies in the class definitions. The same author presented an excellent overview of existing techniques for the management of class evolution in object-oriented systems in [Cas95].
Reference: [Cas95] <author> Eduardo Casais. </author> <title> Object-Oriented Software Composition, </title> <booktitle> chapter Managing Class Evolution in Object-Oriented Systems, </booktitle> <pages> pages 201-244. </pages> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: The author describes both a global and an incremental approach to the reorganization of inheritance relationships. The approach focuses on the reduction of redundancies in the class definitions. The same author presented an excellent overview of existing techniques for the management of class evolution in object-oriented systems in <ref> [Cas95] </ref>. The FAMOOS project (Framework-based Approach for Mastering Object-Oriented Software Evolution) aims at support for the whole re-engineering process. It defines a re-engineering life-cycle [SW97] consisting of six phases.
Reference: [Ciu97] <author> Oliver Ciupke. </author> <title> Analysis of object-oriented programs using graphs. </title> <editor> In Jan Bosch and Stuart Mitchell, editors, </editor> <booktitle> Object-Oriented Technology - Ecoop'97 Workshop Reader, volume 1357 of Lecture Notes in Computer Science, </booktitle> <pages> pages 270-271, </pages> <address> Jyv askyl a, Finnland, March 1997. </address> <publisher> Springer. </publisher>
Reference: [DRT] <author> Serge Demeyer, Matthias Rieger, and Sander Tichelaar. </author> <title> Three reverse-engineering patterns. </title> <note> submitted to Europlop'98. REFERENCES 16 </note>
Reference-contexts: During the model capture phase, as much information as possible is derived from the system. This includes the reverse-engineering and re-documentation of the system. With the aid of software metrics [Mar97], graph-analysing-tools [Ciu97][B ar98] or hot-spot-detectors <ref> [DRT] </ref> the parts of the design which violate the flexibility requirements are detected. Appropriate target structures for these problem structures are determined in the problem analysis phase. The transformation of the problem structures into the target structures is performed in the reorganization phase.
Reference: [FMvW97] <author> Gert Florijn, Marco Meijlers, and Pieter van Winsen. </author> <title> Tool support for object-oriented patterns. </title> <address> http://www.cs.ruu.nl/ florijn/research/Patterns.html, </address> <month> Mai </month> <year> 1997. </year>
Reference: [Gam91] <author> E. </author> <title> Gamma. Objektorientierte Software-Entwicklung am Beispiel von ET++: Klassenbibliothek, Werkzeuge, Design. </title> <type> PhD thesis, </type> <year> 1991. </year>
Reference-contexts: Many people consider them to be a promising approach for overcoming some fundamental problems concerning the design and reuse of object-oriented software. Design patterns were first introduced to the software community by Gamma et. al [GHJV95], <ref> [Gam91] </ref> in the early 90s. They are descriptions of solutions to a set of common, recurring design problems within a particular context. They consist of a pattern name, a problem description, the presentation of a well-proven solution and the consequences and trade-offs of applying the pattern.
Reference: [GD97] <author> Thomas Grothehen and Klaus R. Dittrich. </author> <title> The methood approach: Measures, transformation rules and heuristics for object-oriented design. </title> <note> http://www.ifi.unizh.ch/dbtg/MeTHOOD/index.html, Oktober 1997. </note>
Reference-contexts: In [Mei96][vW96][FMvW97] the authors present an approach for visualizing fragments of object-oriented systems. These fragments can be classes, subsystems or even design patterns, among others. Fragment-transformations are implemented by using the refactoring browser for Smalltalk [RBJ97]. However the authors do not describe any high-level fragment-transformations. The MeTHOOD-project <ref> [GD97] </ref> covers almost the whole re-engineering life-cycle. The description of the transformations is given in a way similar to the description of the design pattern operators. However no proofs of correctness are given and it seems that it is not possible to perform the transformations automatically.
Reference: [GHJV95] <author> E. Gamma, R. Helm, R. Johnson, and J Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This did not happen because the techniques like inheritance or encapsulation were the wrong techniques, but because they only provided a partial solution for the construction of large and complex object-oriented systems. These techniques must be combined with higher level techniques like design patterns <ref> [GHJV95] </ref> [BMR + 96] and frameworks [JF88], [Pre95], [R up97] in order to fully respond to the crisis surrounding software maintenance and extension. <p> Many people consider them to be a promising approach for overcoming some fundamental problems concerning the design and reuse of object-oriented software. Design patterns were first introduced to the software community by Gamma et. al <ref> [GHJV95] </ref>, [Gam91] in the early 90s. They are descriptions of solutions to a set of common, recurring design problems within a particular context. They consist of a pattern name, a problem description, the presentation of a well-proven solution and the consequences and trade-offs of applying the pattern.
Reference: [HK95] <author> W.L. H ursch and L. M. Keszenheimer. </author> <title> Automating the evolution of object-oriented systems. </title> <year> 1995. </year>
Reference: [JF88] <author> R. Johnson and B. Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, Volume 1(No. </journal> <volume> 2), </volume> <year> 1988. </year>
Reference-contexts: These techniques must be combined with higher level techniques like design patterns [GHJV95] [BMR + 96] and frameworks <ref> [JF88] </ref>, [Pre95], [R up97] in order to fully respond to the crisis surrounding software maintenance and extension. Whereas design patterns are micro-architectures, which have been proven to be best-practice solutions for recurring design problems, frameworks can be used to produce families of systems with similar application domains or functionalities.
Reference: [Lie95] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software The Demeter Method. </title> <publisher> PWS Publishing Company, </publisher> <year> 1995. </year>
Reference: [Mar97] <author> Radu Marinescu. </author> <title> The use of software metrics in the design of object-oriented systems. </title> <type> Master's thesis, </type> <institution> Forschungszentrum Informatik (FZI) an der Univer-sit at Karlsruhe (TH), </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: During the model capture phase, as much information as possible is derived from the system. This includes the reverse-engineering and re-documentation of the system. With the aid of software metrics <ref> [Mar97] </ref>, graph-analysing-tools [Ciu97][B ar98] or hot-spot-detectors [DRT] the parts of the design which violate the flexibility requirements are detected. Appropriate target structures for these problem structures are determined in the problem analysis phase. The transformation of the problem structures into the target structures is performed in the reorganization phase.
Reference: [Mei96] <author> Marco Meijers. </author> <title> Tool support for object-oriented design patterns. </title> <type> Master's thesis, </type> <institution> CS Department of Utrecht University, </institution> <month> August </month> <year> 1996. </year>
Reference: [Moh98] <author> Berthold Mohr. </author> <title> Reorganisation objektorientierter Systeme. </title> <type> Master's thesis, </type> <institution> Forschungszentrum Informatik (FZI) an der Universit at Karlsruhe (TH), </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: for the development of Hotdraw. 1 Opdyke writes in [Opd92]: "The C++ language is a semantically complicated language, supporting machine level operations such as pointer arithmetic; these complexities make it difficult to more precisely define what behavior preservation means for C++ programs." 3 OUR APPROACH 8 Berthold Mohr showed in <ref> [Moh98] </ref> that it is possible to implement a tool supporting refac-torings for a subset of C++. He implemented the refactoring for the conversion of an inheritance relationship into an aggregation including all necessary low-level refactorings. In spite of the promising results in formalizing [Opd92] and implementing [RBJ97][Moh98] refactorings, there are some <p> On the other hand, refactorings provide at least a semi-formal proof of behavior preservation. Even more, it was shown that they can be implemented in tools [RBJ97], <ref> [Moh98] </ref>. However, refactorings, even the high-level refactorings are not at a level of abstraction which is needed for reorganization. Beyond this, the specification of refactoring-specific pre-conditions heavily depends on the semantics of the underlying programming language. Thus it is not possible to use the refactoring-approach in a language independent way. <p> For this purpose we implemented a tool prototype which provides several simple or complex refactorings for C++ (e.g., add class, change superclass, convert inheritance into aggregation, <ref> [Moh98] </ref>) using the FAST C++-parser [Sem97]. The sequence and order of refactorings in order to implement a particular design pattern is determined via shell scripts. We tested our tool with an existing software application for the visualization of flow data from the field of hydraulic engineering.
Reference: [Opd92] <author> William Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: In this section, we present two approaches for the reorganization of object-oriented systems. In 2.1 we describe the high-level approach first presented in [Zim97]. This approach describes design patterns as operators rather than as building blocks. The low-level approach of William Opdyke, who describes in <ref> [Opd92] </ref> a set of transformations he calls refactorings, is presented in 2.2. 2.1 Design Patterns as Operators In the last couple of years, design patterns have gained much attention in the field of software engineering. <p> Beyond this, the transformational approach enables the use of design patterns as reorganization operators in order to reorganize existing systems by identifying the problem structure and transforming it into an improved target structure. 2.2 Refactorings In his PhD thesis <ref> [Opd92] </ref>, William Opdyke presented an approach for the support of the evolution of object-oriented systems. He defined a set of so-called refactorings, which are implementable in a tool and showed that the application of these refactorings does not change the system-behavior. <p> The other subset consists of three high-level refactorings, which are defined by using the low-level refactorings. The proof of the behavior preserving nature of the high-level refactorings is also furnished in terms of low-level refactorings. The low-level refactorings William Opdyke describes in <ref> [Opd92] </ref> allow the creation and deletion (e.g., create empty class, delete member function) or modification of program entities (e.g., add function argument). Furthermore, refactorings to move member variables (e.g., move member variable to superclass) and simple composite refactorings (e.g., convert code segment to function) belong to the low-level refactorings. <p> The three high-level refactorings described in <ref> [Opd92] </ref> are: * Creation of an abstract super-class: The common abstraction (methods, member variables) of two or more classes is factored out into an abstract super-class. * Subclassing and simplifying conditionals: Conditional statements, dependent on the internal state of the object, which are used to select the different behavior of an <p> Due to the complexity of the C++ language 1 Ralph Johnson and his group focused on Smalltalk and constructed a Refactoring Browser for Smalltalk [RBJ97]. This tool supports a selection of the refactorings described in <ref> [Opd92] </ref> and was successfully used for the development of Hotdraw. 1 Opdyke writes in [Opd92]: "The C++ language is a semantically complicated language, supporting machine level operations such as pointer arithmetic; these complexities make it difficult to more precisely define what behavior preservation means for C++ programs." 3 OUR APPROACH 8 <p> Due to the complexity of the C++ language 1 Ralph Johnson and his group focused on Smalltalk and constructed a Refactoring Browser for Smalltalk [RBJ97]. This tool supports a selection of the refactorings described in <ref> [Opd92] </ref> and was successfully used for the development of Hotdraw. 1 Opdyke writes in [Opd92]: "The C++ language is a semantically complicated language, supporting machine level operations such as pointer arithmetic; these complexities make it difficult to more precisely define what behavior preservation means for C++ programs." 3 OUR APPROACH 8 Berthold Mohr showed in [Moh98] that it is possible to implement a tool supporting <p> He implemented the refactoring for the conversion of an inheritance relationship into an aggregation including all necessary low-level refactorings. In spite of the promising results in formalizing <ref> [Opd92] </ref> and implementing [RBJ97][Moh98] refactorings, there are some restrictions to the approach: * Behavior preservation: The described approach of assembling high-level refactor-ings from low-level refactorings requires behavior preservation for every application of a low-level refactoring. <p> Thus it is not possible to use the refactoring-approach in a language independent way. Our approach offers the best of both worlds. We combine the two approaches in order to overcome the shortcomings of both of them by implementing the design pattern operators [Zim97] with Opdyke's refactorings <ref> [Opd92] </ref>. Whereas in [Zim97] the description of the operators is very informal, we are now able to formalize the operators, as well as their pre-conditions and post-conditions with the aid of the refactorings. <p> This means, that we replace the meta-model and the operator-language defined in [Zim97] with the model and language defined in <ref> [Opd92] </ref>. The different phases for applying a design-pattern operator in [Zim97] are refined as follows: 1. Identification of the problem structure: As in [Zim97] the software engineer has to identify the part of the system to be reorganized first. <p> In order to achieve the necessary target structure, we used a variant of pattern operator Bridge consisting of the refactoring convert inheritance into aggregation. This high-level refactoring converts an inheritance relationship into a component relationship <ref> [Opd92] </ref> and consists of the following steps: 1. Create a new member variable impl of type Graphic. 2. For each member function inherited from Graphic create a member function in Shape. Calls to these functions are delegated to the corresponding methods in Graphic. <p> This sometimes leads to slightly complicated refactoring sequences and often requires user interaction. Another problem was that sometimes our tool could not check all preconditions automatically. However, this does not occur in only this specific case but is generally a problem <ref> [Opd92] </ref>, since pre-condition checking often requires global data flow analysis. Beyond this, our tool only supported a subset of C++ syntax, not supported is pointer arithmetic and multiple inheritance to name a few. Nevertheless, our tool helped to significantly ease the reorganization of the mentioned software.
Reference: [Pre95] <author> W. Pree. </author> <title> Design Patterns for Object-Oriented Software Development. </title> <address> Addison-Wesely, </address> <year> 1995. </year>
Reference-contexts: These techniques must be combined with higher level techniques like design patterns [GHJV95] [BMR + 96] and frameworks [JF88], <ref> [Pre95] </ref>, [R up97] in order to fully respond to the crisis surrounding software maintenance and extension. Whereas design patterns are micro-architectures, which have been proven to be best-practice solutions for recurring design problems, frameworks can be used to produce families of systems with similar application domains or functionalities. <p> We are currently exploring the possibilities of deriving refactoring sequences from design pattern descriptions in a more systematic way. A promising way is to take advantage of the fact that design patterns are composed of meta-patterns <ref> [Pre95] </ref>. These meta-patterns can easily be implemented with refactorings. This will lead us to the construction of a pattern operator library. Another field of interest is the introduction of design pattern operators in the process of forward engineering.
Reference: [RBJ97] <author> Don Roberts, John Brant, and Ralph Johnson. </author> <title> A refactoring tool for smalltalk. </title> <address> http://st-www.cs.uiuc.edu/users/brant/Refactory/RefactoringBrowser.html, April 1997. </address>
Reference-contexts: Due to the complexity of the C++ language 1 Ralph Johnson and his group focused on Smalltalk and constructed a Refactoring Browser for Smalltalk <ref> [RBJ97] </ref>. <p> On the other hand, refactorings provide at least a semi-formal proof of behavior preservation. Even more, it was shown that they can be implemented in tools <ref> [RBJ97] </ref>, [Moh98]. However, refactorings, even the high-level refactorings are not at a level of abstraction which is needed for reorganization. Beyond this, the specification of refactoring-specific pre-conditions heavily depends on the semantics of the underlying programming language. <p> Several approaches cover parts of this re-engineering life-cycle. In [Mei96][vW96][FMvW97] the authors present an approach for visualizing fragments of object-oriented systems. These fragments can be classes, subsystems or even design patterns, among others. Fragment-transformations are implemented by using the refactoring browser for Smalltalk <ref> [RBJ97] </ref>. However the authors do not describe any high-level fragment-transformations. The MeTHOOD-project [GD97] covers almost the whole re-engineering life-cycle. The description of the transformations is given in a way similar to the description of the design pattern operators.
Reference: [R up97] <author> Andreas R uping. </author> <title> Software-Entwicklung mit objektorientierten Frameworks. </title> <type> PhD thesis, </type> <institution> Fakult at f ur Informatik der Universit at Karlsruhe (TH), </institution> <month> Febru-ary </month> <year> 1997. </year>
Reference-contexts: These techniques must be combined with higher level techniques like design patterns [GHJV95] [BMR + 96] and frameworks [JF88], [Pre95], <ref> [R up97] </ref> in order to fully respond to the crisis surrounding software maintenance and extension. Whereas design patterns are micro-architectures, which have been proven to be best-practice solutions for recurring design problems, frameworks can be used to produce families of systems with similar application domains or functionalities.
Reference: [Sem97] <author> SemaGroup. </author> <title> FAST Programmer's Manual and FAST Programmer's Manual Complement, </title> <year> 1997. </year>
Reference-contexts: For this purpose we implemented a tool prototype which provides several simple or complex refactorings for C++ (e.g., add class, change superclass, convert inheritance into aggregation, [Moh98]) using the FAST C++-parser <ref> [Sem97] </ref>. The sequence and order of refactorings in order to implement a particular design pattern is determined via shell scripts. We tested our tool with an existing software application for the visualization of flow data from the field of hydraulic engineering.
Reference: [SW97] <author> Benedikt Schulz and Joachim Weisbrod. </author> <title> Life-cycle and primitive re-enginering operations. </title> <type> Technical report, </type> <institution> FAMOOS Internal, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The same author presented an excellent overview of existing techniques for the management of class evolution in object-oriented systems in [Cas95]. The FAMOOS project (Framework-based Approach for Mastering Object-Oriented Software Evolution) aims at support for the whole re-engineering process. It defines a re-engineering life-cycle <ref> [SW97] </ref> consisting of six phases. In the first phase called requirements analysis, the requirements of a concrete re-engineering process (e.g., gaining platform independence before moving to a new platform, modularizing a system before splitting it into 6 CONCLUSIONS AND FURTHER WORK 14 different reusable components) are determined.
Reference: [vW96] <author> Pieter van Winsen. </author> <title> (Re)engineering with object-oriented design patterns. </title> <type> Master's thesis, </type> <institution> Cs Department of Untrecht University, </institution> <month> November </month> <year> 1996. </year>
Reference: [Zim95] <author> Walter Zimmer. </author> <title> Relationships between design patterns. </title> <editor> In J. Coplien and D.C. Schmidt, editors, </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: They ease the documentation of design decisions and make them more under standable. * Design patterns are language independent. Over the years, some weaknesses in design patterns have been identified. One major problem is the absence of a more formal classification of design patterns and their mutual relationships <ref> [Zim95] </ref>. Due to the commonly very informal description of a design pattern it is often very hard to choose the right pattern variant from what could possibly be a large number of variants. Another major problem is the lack of a systematic way to integrate design patterns into existing systems.
Reference: [Zim97] <author> Walter Zimmer. </author> <title> Frameworks und Entwurfsmuster. </title> <type> PhD thesis, </type> <institution> FZI, </institution> <year> 1997. </year>
Reference-contexts: Thus the technique must define the notion of system-behavior making it possible to prove, that a performed reorganization-step does not change this behavior. In this section, we present two approaches for the reorganization of object-oriented systems. In 2.1 we describe the high-level approach first presented in <ref> [Zim97] </ref>. This approach describes design patterns as operators rather than as building blocks. <p> This allows for the easy construction of new systems, but makes it very hard to introduce design patterns into existing systems in order to reorganize them. In order to overcome these shortcomings, a new approach is presented in <ref> [Zim97] </ref>. The author introduces a novel concept to support the systematic application of design patterns to existing software systems. In his approach he considers design patterns to be operators, whose application transforms an existing design into a target design, fulfilling the necessary requirements. <p> Thus it is not possible to use the refactoring-approach in a language independent way. Our approach offers the best of both worlds. We combine the two approaches in order to overcome the shortcomings of both of them by implementing the design pattern operators <ref> [Zim97] </ref> with Opdyke's refactorings [Opd92]. Whereas in [Zim97] the description of the operators is very informal, we are now able to formalize the operators, as well as their pre-conditions and post-conditions with the aid of the refactorings. This means, that we replace the meta-model and the operator-language defined in [Zim97] with <p> Our approach offers the best of both worlds. We combine the two approaches in order to overcome the shortcomings of both of them by implementing the design pattern operators <ref> [Zim97] </ref> with Opdyke's refactorings [Opd92]. Whereas in [Zim97] the description of the operators is very informal, we are now able to formalize the operators, as well as their pre-conditions and post-conditions with the aid of the refactorings. This means, that we replace the meta-model and the operator-language defined in [Zim97] with the model and language defined in [Opd92]. <p> operators <ref> [Zim97] </ref> with Opdyke's refactorings [Opd92]. Whereas in [Zim97] the description of the operators is very informal, we are now able to formalize the operators, as well as their pre-conditions and post-conditions with the aid of the refactorings. This means, that we replace the meta-model and the operator-language defined in [Zim97] with the model and language defined in [Opd92]. The different phases for applying a design-pattern operator in [Zim97] are refined as follows: 1. Identification of the problem structure: As in [Zim97] the software engineer has to identify the part of the system to be reorganized first. <p> This means, that we replace the meta-model and the operator-language defined in <ref> [Zim97] </ref> with the model and language defined in [Opd92]. The different phases for applying a design-pattern operator in [Zim97] are refined as follows: 1. Identification of the problem structure: As in [Zim97] the software engineer has to identify the part of the system to be reorganized first. <p> This means, that we replace the meta-model and the operator-language defined in <ref> [Zim97] </ref> with the model and language defined in [Opd92]. The different phases for applying a design-pattern operator in [Zim97] are refined as follows: 1. Identification of the problem structure: As in [Zim97] the software engineer has to identify the part of the system to be reorganized first. Depending on the selected problem structure and the design pattern operator to be applied, the sequence of refactorings can be determined. 2. Checking the pre-conditions: The pre-conditions are derived from the sequence of refactorings. <p> However, it is possible to derive a set of pre-conditions which, when satisfied, ensures the success of the application of the whole sequence. 3. Parameterized transformation of the problem structure into the target structure: This step performs the transformation by executing the sequence of refac torings. Like in <ref> [Zim97] </ref> this may require a parameterization by the user. 4. Reorganization of context: Since the reorganization of the context is part of the application of a single refactoring, the context of the problem structure does not need to be reorganized after the execution of the sequence of refactorings. <p> An explicit checking of the post-conditions can thus be omitted. 3 OUR APPROACH 10 Figures 4 and 5 depict the third step of the application of the design pattern operator Bridge as performed by our new approach. The sequence of necessary transformation steps is different from the sequence in <ref> [Zim97] </ref>, since our approach requires behavior preservation at every step. In step 3a a new, unreferenced class AbstractSet is introduced. AbstractSet is assigned to the same super-class (not shown in the figure) as Set in step 3b.
References-found: 28

