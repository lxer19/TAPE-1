URL: http://www.cs.cornell.edu/home/jgm/cs719/DeutschPLDI94.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/cs719/cs719.html
Root-URL: 
Email: Alain.Deutsch@inria.fr  
Title: Interprocedural May-Alias Analysis for Pointers: Beyond k-limiting  
Author: Alain Deutsch 
Address: 78153 Le Chesnay Cedex, France  
Affiliation: INRIA Rocquencourt  
Abstract: Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, Orlando, June 1994, pp. 230-241. Existing methods for alias analysis of recursive pointer data structures are based on two approximation techniques: k-limiting, which blurs distinction between sub-objects below depth k; and store-based (or equivalently location or region-based) approximations, which blur distinction between elements of recursive data structures. Although notable progress in inter-procedural alias analysis has been recently accomplished, very little progress in the precision of analysis of recursive pointer data structures has been seen since the inception of these approximation techniques by Jones and Muchnick a decade ago. As a result, optimizing, verifying and parallelizing programs with pointers has remained difficult. We present a new parametric framework for analyzing recursive pointer data structures which can express a new natural class of alias information not accessible to existing methods. The key idea is to represent alias information by pairs of symbolic access paths which are qualified by symbolic descriptions of the positions for which the alias pair holds. Based on this result, we present an algorithm for interproce-dural may-alias analysis with pointers which on numerous examples that occur in practice is much more precise than recently published algorithms [CWZ90, He90, LR92, CBC93]. 
Abstract-found: 1
Intro-found: 1
Reference: [POP91] <editor> ACM Press. </editor> <booktitle> Eighteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> Jan. </month> <year> 1991. </year>
Reference: [PLD92] <editor> ACM Press. </editor> <booktitle> SIGPLAN'92 Conf. on Programming Language Design and Implementation, volume 27(7) of SIG-PLAN Notices, </booktitle> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference: [ASU86] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context.
Reference: [BK89] <author> V. Balasundaram and K. Kennedy. </author> <title> A technique for summarizing data access and its use in parallelism enhancing transformations. </title> <booktitle> In SIGPLAN'89 Conf. on Programming Language Design and Implementation, volume 24(7) of SIGPLAN Notices, </booktitle> <pages> pp. 41-53, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In essence, this lattice V ] controls qualitatively the ability to reason about dependencies (typ ical examples of V ] are constant propagation [Ki73], linear arithmetic constraints [Ka76], arithmetic intervals [CC77a], simple sections <ref> [BK89] </ref> etc., and combi nations of these). 2. an algorithm for interprocedural may-alias analysis with pointers. <p> char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities [CH78], simple sections <ref> [BK89, CC92] </ref>, linear congruence equalities [Gr91] and con-gruential trapezoids [Ma91]. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice. <p> In addition we define &gt; = S ] (;). Finally, if V ] (V ) has infinite height then it is equipped with a widening operator r [CC77a] to ensure termination of fixpoint computations. The relational lattices enumerated above satisfy this hypothesis (except the lattice of simple sections <ref> [BK89] </ref> which must be extended as explained in [CC92, x9.1]). Each independent numeric lattice L can also be accommodated by defining V ] as the n-fold (smash) product of L.
Reference: [Br64] <author> J. Brzozowski. </author> <title> Derivatives of regular expressions. </title> <journal> J. ACM, </journal> <volume> 11 </volume> <pages> 481-494, </pages> <year> 1964. </year>
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F.K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Conf. on Programming Language Design and Implementation, volume 25(6) of SIG-PLAN Notices, </booktitle> <pages> pp. 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information <ref> [Hu86, He88, CWZ90] </ref>, sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> The present paper provides a practical application to imperative languages of the general theory of [De92b]. [He90] cannot handle cyclic data: as noted in [HHN92], this is a serious obstacle to its use in languages with pointers. <ref> [CWZ90] </ref> and [He90] can distinguish to some extent struct List f char *hd; struct List *tl; g; struct List * Copy (struct List *L) f struct List *p, *t1; C 1 : if (L == null) C 2 : return (L); C 3 : p = malloc ( ); C 4 <p> -&gt;tl -&gt;hd; X-&gt;hd); [LR92] (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); [CBC93] (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered [LH88a] <ref> [CWZ90] </ref> [LR92] [CBC93] Deutsch P 1 : X and Y are acyclic yes yes yes P 2 : two successive heads of Y don't alias yes yes P 3 : X and Y tails don't alias yes yes yes yes P 4 : heads of X and Y are aliased only <p> This encom passes a large subset of the C language. Why is it significant? An example Our method provides a solution to an open problem <ref> [LH88a, CWZ90, He90, HHN92] </ref>: how to improve the accuracy of alias analysis in the presence of recursive pointer data structures. The information obtained by our analysis is generally much more precise than that obtained by previous methods. on an example due to Larus & Hilfinger [LH88b, p. 103]. <p> Section 4 discusses the time complexity of our method, and our prototype implementation is discussed in Section 5. Finally, we assess the precision of the alias information discovered by our framework in Section 6. 1 Node labels computed by the method [LH88a] are not shown. In the entry <ref> [CWZ90] </ref>, graph nodes are annotated with approximate reference counts. For the method [CBC93], the S1; S2; : : : are heap names (allocation sites). Alias pairs are shown for readability without the external level of dereferencing. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper <ref> [CWZ90, p.309,x8] </ref>. Regardless of the value of the parameter k of their analysis, [LR92] also report a cyclic list as it detects spurious aliases of the form hfl (l-&gt;tl -&gt;tl); fl (l-&gt;tl-&gt;tl-&gt;tl)i. Landi & Ryder's method is based on sets of pairs of k-limited access paths.
Reference: [CBC93] <author> J.D. Choi, M.G. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 232-245. </pages> <publisher> ACM Press, </publisher> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two <ref> [CBC93] </ref>. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context. All these methods partition an infinite number of run-time objects (or access paths) into a finite number of equivalence classes. <p> Spurious aliases [LH88a] -X ? 6 - - (Y -&gt;tl -&gt;tl ; Y -&gt;tl-&gt;tl-&gt;tl ); : : :g -Y 6 - 1 - 6 1 1 f (X-&gt;hd; X-&gt;tl-&gt;hd); (Y -&gt;tl -&gt;tl -&gt;hd; X-&gt;hd); [LR92] (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); <ref> [CBC93] </ref> (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered [LH88a] [CWZ90] [LR92] [CBC93] Deutsch P 1 : X and Y are acyclic yes yes yes P 2 : two successive <p> X-&gt;hd); [LR92] (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); <ref> [CBC93] </ref> (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered [LH88a] [CWZ90] [LR92] [CBC93] Deutsch P 1 : X and Y are acyclic yes yes yes P 2 : two successive heads of Y don't alias yes yes P 3 : X and Y tails don't alias yes yes yes yes P 4 : heads of X and Y are aliased only pairwise yes <p> Finally, we assess the precision of the alias information discovered by our framework in Section 6. 1 Node labels computed by the method [LH88a] are not shown. In the entry [CWZ90], graph nodes are annotated with approximate reference counts. For the method <ref> [CBC93] </ref>, the S1; S2; : : : are heap names (allocation sites). Alias pairs are shown for readability without the external level of dereferencing. <p> This is to avoid non-realizable interprocedural paths. The seminal papers [CC77c, SP81, JM82] present systematic and direct methods to perform this extension. [LR92] uses alias sets of size one as tokens, <ref> [CBC93] </ref> uses calling points and/or incoming alias sets (which can result in exponential behaviour, see [ML + 93]). We clearly separated the basic interprocedural framework from its extensions, unlike [LR92, ML + 93]. Our framework can therefore easily be extended to an arbitrary token set. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods <ref> [LH88a, HPR89, De90, St92, CBC93] </ref> fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8]. <p> However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods [LH88a, HPR89, De90, St92, CBC93] fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of <ref> [St92, CBC93] </ref>). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8].
Reference: [CCF91] <author> J.D. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse evaluation graphs. </title> <booktitle> In [POP91]. </booktitle>
Reference: [Co81] <author> P. Cousot. </author> <title> Semantic foundations of program analysis. In Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pp. 303-342. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference: [CC77a] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation : a unified lattice model for static analysis of programs by construction of approximation of fixpoints. </title> <booktitle> In Fourth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 238-252, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: In essence, this lattice V ] controls qualitatively the ability to reason about dependencies (typ ical examples of V ] are constant propagation [Ki73], linear arithmetic constraints [Ka76], arithmetic intervals <ref> [CC77a] </ref>, simple sections [BK89] etc., and combi nations of these). 2. an algorithm for interprocedural may-alias analysis with pointers. <p> V ] determines which class of relations between positions in aliased data structures can be captured. Independent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals <ref> [CC77a, Mo84] </ref> and arithmetic congruences [Gr89]. <p> In addition we define &gt; = S ] (;). Finally, if V ] (V ) has infinite height then it is equipped with a widening operator r <ref> [CC77a] </ref> to ensure termination of fixpoint computations. The relational lattices enumerated above satisfy this hypothesis (except the lattice of simple sections [BK89] which must be extended as explained in [CC92, x9.1]). <p> these two pairs by (hf 1 ; f 2 i; K _ K 0 ); return % Example: % 1 = f (hX-&gt;(tl-&gt;) k 1 hd ; Y -&gt;(tl-&gt;) k 2 hd i; S ] fk 1 =0; k 2 =0g)g if V ] is the lattice of arithmetic intervals <ref> [CC77a] </ref>: % 1 t % 2 = f (hX-&gt;(tl-&gt;) k 1 hd ; Y -&gt;(tl-&gt;) k 2 hd i; S ] f0k 1 ;k 2 1g)g if V ] is Karr's lattice [Ka76]: % 1 t % 2 = f (hX-&gt;(tl-&gt;) k 1 hd ; Y -&gt;(tl-&gt;) k 2 hd i; <p> is computed pointwise, see Figure 3. 2.1.4 Termination of fixpoint computations The parametric semilattice UR (V ] ) we have just defined has infinite chains: (1) because the number of possible SAPs is not bounded; and (2) because V ] may have infinite chains (for instance the lattice of intervals <ref> [CC77a] </ref>). We define the normalisation operation Factor which maps a SAP f to a SAP f 0 in which potentially unbounded subsequences of f (paths through recursive data structures) have been replaced by bases guarded by new coefficient variables. <p> Symbolic alias relations are implemented by two-level tries: a first trie maps each symbolic access path to a trie mapping symbolic access paths to elements of the numerical lattice V ] . The numerical lattices we have experimented with are: (1) the lattice of arithmetic intervals <ref> [CC77a] </ref>; (2) the combination of the lattice of intervals and of the lattice of linear equalities [Ka76] (see [CC79] and [Gr92] for an explanation of how to devise an optimal combination). Data flow equations augmented with widening operators are solved using standard iterative techniques.
Reference: [CC77b] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of generalized type unions. </title> <journal> SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 77-94, </pages> <month> Mar. </month> <year> 1977. </year>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context.
Reference: [CC77c] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of recursive procedures. </title> <booktitle> In Working Conf. on Formal Description of Programming Concepts. IFIP WG 2.2, </booktitle> <publisher> North-Holland, </publisher> <month> Aug. </month> <year> 1977. </year>
Reference-contexts: just before the assignment shown in Figure 7 is described by the symbolic alias relation % 1 , then aliasing after this assignment is % 2 = f (% 1 ). 3 The interprocedural framework Interprocedural methods for non-distributive problems over large semilattices limit information loss by analysing procedures separately <ref> [CC77c, SP81, JM82] </ref>, keyed by some token abstracting the call context. However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. <p> However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. Therefore, following <ref> [CC77c, Ha79, MR89, LR92] </ref>, we perform therefore generalisation of data flow values through function calls and instantiation through function returns. Consider two alias pairs hx; 1 i and hx; 2 i reaching the entry of a function F (x; y). <p> This is to avoid non-realizable interprocedural paths. The seminal papers <ref> [CC77c, SP81, JM82] </ref> present systematic and direct methods to perform this extension. [LR92] uses alias sets of size one as tokens, [CBC93] uses calling points and/or incoming alias sets (which can result in exponential behaviour, see [ML + 93]).
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Sixth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 269-282, </pages> <year> 1979. </year>
Reference-contexts: Each independent numeric lattice L can also be accommodated by defining V ] as the n-fold (smash) product of L. V ] can also be defined using one of the systematic methods for combin ing analysis frameworks proposed in <ref> [CC79, x10] </ref>. By abuse of notation, we will write V ] instead of V ] (V ) when V is clear from the context. <p> The numerical lattices we have experimented with are: (1) the lattice of arithmetic intervals [CC77a]; (2) the combination of the lattice of intervals and of the lattice of linear equalities [Ka76] (see <ref> [CC79] </ref> and [Gr92] for an explanation of how to devise an optimal combination). Data flow equations augmented with widening operators are solved using standard iterative techniques.
Reference: [CC92] <author> P. Cousot and R. Cousot. </author> <title> Comparing the Galois connection and widening-narrowing approaches to abstract interpretation. </title> <booktitle> In Programming Language Implementation and Logic Programming, 4th Intl. Symp, PLILP'92, volume 631 of Lecture Notes on Computer Science, </booktitle> <pages> pp. 269-295. </pages> <publisher> Springer Verlag, </publisher> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities [CH78], simple sections <ref> [BK89, CC92] </ref>, linear congruence equalities [Gr91] and con-gruential trapezoids [Ma91]. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice. <p> Finally, if V ] (V ) has infinite height then it is equipped with a widening operator r [CC77a] to ensure termination of fixpoint computations. The relational lattices enumerated above satisfy this hypothesis (except the lattice of simple sections [BK89] which must be extended as explained in <ref> [CC92, x9.1] </ref>). Each independent numeric lattice L can also be accommodated by defining V ] as the n-fold (smash) product of L. V ] can also be defined using one of the systematic methods for combin ing analysis frameworks proposed in [CC79, x10].
Reference: [CH78] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Fifth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 84-97, </pages> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities <ref> [CH78] </ref>, simple sections [BK89, CC92], linear congruence equalities [Gr91] and con-gruential trapezoids [Ma91]. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice.
Reference: [De90] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 157-168. </pages> <publisher> ACM Press, </publisher> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> We clearly separated the basic interprocedural framework from its extensions, unlike [LR92, ML + 93]. Our framework can therefore easily be extended to an arbitrary token set. This is an issue orthogonal to the present contribution. Pointers to functions can be accomodated using a technique similar to <ref> [De90] </ref>. struct List * Reverse (struct List *X,*Y) f struct List *p, *q; if (X == null) q = X; else f p = X-&gt;tl; q = Reverse (p, X); g return (q); g G 2 : l = Reverse (l, null); G 3 : 4 Complexity We define: n the <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods <ref> [LH88a, HPR89, De90, St92, CBC93] </ref> fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8].
Reference: [De92a] <author> A. Deutsch. </author> <title> Operational Models of Programming Languages and Representations of Relations on Regular Languages with Application to the Static Determination of Dynamic Aliasing Properties of Data. </title> <type> PhD thesis, </type> <institution> LIX, Ecole Polytechnique, F-91128, Palaiseau, France, </institution> <year> 1992. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> Independent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals [CC77a, Mo84] and arithmetic congruences [Gr89]. Relational (multidimensional) numeric lattices include: linear 2 The internal, postfix representation of the symbolic access path f is Xfl:(tlfl) i :hd. 3 The theoretically inclined reader is encouraged to consult [De92b] and <ref> [De92a, x3] </ref> for a theoretical account of the connection between SAPs, the unitary-prefix monomials of Eilenberg's treatise [Ei74] and Parikh's commutative decomposition [Pa66]. struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct <p> This case analysis describes precisely the aliases generated by an assignment <ref> [Jo81, De92a] </ref>, in terms of (possibly infinite) sets of alias pairs. We now define an abstract counterpart of this operation which does not oper ate on sets of alias pairs, but on (finite) symbolic alias relations. <p> As was pointed out by several researchers, these techniques are not sufficiently accurate to apply optimisation methods to programs with pointers. Based on our previous theoretical results in semantics, formal language theory and abstract interpretation <ref> [De92b, De92a] </ref>, we have proposed a method for may-alias analysis which radically departs from the currently prevalent store-based and k-limited approximation methods. The key concept is that of symbolic access paths qualified by integer coefficients denoting positions in data structures.
Reference: [De92b] <author> A. Deutsch. </author> <title> A storeless model of aliasing and its abstrac-tions using finite representations of right-regular equivalence relations. </title> <booktitle> In [ICC92], </booktitle> <pages> pp. 2-13. </pages>
Reference-contexts: They can distinguish a tree from a general directed graph. But as soon as a sub-object below depth k becomes aliased, aliasing erroneously propagates to all other sub-objects below depth k, contaminating even objects of different types. <ref> [De92b] </ref> presents a theoretical framework for alias analysis. The formalism used is based on Eilenberg's unitary-prefix monomial decomposition [Ei74], on Parikh's commutative decomposition [Pa66] and on a storeless semantic model of aliasing properties based on right-regular equivalence relations. <p> The main result of that paper is the lattice of unitary-prefix monomial relations on subsets of a regular language, which is shown to be an abstract interpretation of the lattice of right-regular equivalence relations. The present paper provides a practical application to imperative languages of the general theory of <ref> [De92b] </ref>. [He90] cannot handle cyclic data: as noted in [HHN92], this is a serious obstacle to its use in languages with pointers. [CWZ90] and [He90] can distinguish to some extent struct List f char *hd; struct List *tl; g; struct List * Copy (struct List *L) f struct List *p, *t1; <p> Independent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals [CC77a, Mo84] and arithmetic congruences [Gr89]. Relational (multidimensional) numeric lattices include: linear 2 The internal, postfix representation of the symbolic access path f is Xfl:(tlfl) i :hd. 3 The theoretically inclined reader is encouraged to consult <ref> [De92b] </ref> and [De92a, x3] for a theoretical account of the connection between SAPs, the unitary-prefix monomials of Eilenberg's treatise [Ei74] and Parikh's commutative decomposition [Pa66]. struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g <p> As was pointed out by several researchers, these techniques are not sufficiently accurate to apply optimisation methods to programs with pointers. Based on our previous theoretical results in semantics, formal language theory and abstract interpretation <ref> [De92b, De92a] </ref>, we have proposed a method for may-alias analysis which radically departs from the currently prevalent store-based and k-limited approximation methods. The key concept is that of symbolic access paths qualified by integer coefficients denoting positions in data structures.
Reference: [DGS94] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. Reducing the cost of data flow analysis by congruence partitionning. </title> <booktitle> In International Conference on Compiler Construction, to appear in the Springer Verlag Lecture Notes in Computer Science, </booktitle> <month> Apr. </month> <year> 1994. </year>
Reference: [Ei74] <author> S. Eilenberg. </author> <title> Automata, Languages and Machines, volume A. </title> <publisher> Academic Press, </publisher> <year> 1974. </year>
Reference-contexts: But as soon as a sub-object below depth k becomes aliased, aliasing erroneously propagates to all other sub-objects below depth k, contaminating even objects of different types. [De92b] presents a theoretical framework for alias analysis. The formalism used is based on Eilenberg's unitary-prefix monomial decomposition <ref> [Ei74] </ref>, on Parikh's commutative decomposition [Pa66] and on a storeless semantic model of aliasing properties based on right-regular equivalence relations. <p> Relational (multidimensional) numeric lattices include: linear 2 The internal, postfix representation of the symbolic access path f is Xfl:(tlfl) i :hd. 3 The theoretically inclined reader is encouraged to consult [De92b] and [De92a, x3] for a theoretical account of the connection between SAPs, the unitary-prefix monomials of Eilenberg's treatise <ref> [Ei74] </ref> and Parikh's commutative decomposition [Pa66]. struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g
Reference: [Gr89] <author> P. Granger. </author> <title> Static analysis of arithmetical congru-ences. </title> <journal> International Journal of Computer Mathematics, </journal> <volume> 30 </volume> <pages> 165-190, </pages> <year> 1989. </year>
Reference-contexts: V ] determines which class of relations between positions in aliased data structures can be captured. Independent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals [CC77a, Mo84] and arithmetic congruences <ref> [Gr89] </ref>.
Reference: [Gr91] <author> P. Granger. </author> <title> Static analysis on linear congruence equalities among variables of a program. </title> <booktitle> In TAPSOFT'91, volume 493 of Lecture Notes on Computer Science, </booktitle> <pages> pp. 169-192. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities [CH78], simple sections [BK89, CC92], linear congruence equalities <ref> [Gr91] </ref> and con-gruential trapezoids [Ma91]. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice.
Reference: [Gr92] <author> P. Granger. </author> <title> Improving the results of static analyses of programs by local decreasing iterations (extended abstract). </title> <booktitle> In Proc. 12th Conference of Foundations of Software Technology and Theoretical Computer Science, Lecture Notes on Computer Science, </booktitle> <pages> pp. 68-79. </pages> <publisher> Springer Verlag, </publisher> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: The numerical lattices we have experimented with are: (1) the lattice of arithmetic intervals [CC77a]; (2) the combination of the lattice of intervals and of the lattice of linear equalities [Ka76] (see [CC79] and <ref> [Gr92] </ref> for an explanation of how to devise an optimal combination). Data flow equations augmented with widening operators are solved using standard iterative techniques.
Reference: [Ha79] <author> N. Halbwachs. </author> <title> Determination automatique de relations lineaires verifiees par les variables d'un programme. </title> <type> PhD thesis, </type> <institution> Universite Scientifique et Medicale de Grenoble & Institut National Polytechnique de Grenoble, Grenoble, France, </institution> <month> Mar. </month> <year> 1979. </year>
Reference-contexts: However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. Therefore, following <ref> [CC77c, Ha79, MR89, LR92] </ref>, we perform therefore generalisation of data flow values through function calls and instantiation through function returns. Consider two alias pairs hx; 1 i and hx; 2 i reaching the entry of a function F (x; y).
Reference: [Ha89] <author> W.L. Harrison. </author> <title> The interprocedural analysis and automatic parallelisation of Scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(3) </volume> <pages> 176-396, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [He88] <author> L. Hederman. </author> <title> Compile time garbage collection. </title> <type> Master's thesis, </type> <institution> Rice University, Houston, </institution> <month> Aug. </month> <year> 1988. </year> <note> Tech. report COMP TR88-75. </note>
Reference-contexts: Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information <ref> [Hu86, He88, CWZ90] </ref>, sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [He90] <author> L. Hendren. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Trans. on Parallel and Distributed Processing, </journal> <volume> 1 </volume> <pages> 35-47, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context. <p> The present paper provides a practical application to imperative languages of the general theory of [De92b]. <ref> [He90] </ref> cannot handle cyclic data: as noted in [HHN92], this is a serious obstacle to its use in languages with pointers. [CWZ90] and [He90] can distinguish to some extent struct List f char *hd; struct List *tl; g; struct List * Copy (struct List *L) f struct List *p, *t1; C <p> The present paper provides a practical application to imperative languages of the general theory of [De92b]. <ref> [He90] </ref> cannot handle cyclic data: as noted in [HHN92], this is a serious obstacle to its use in languages with pointers. [CWZ90] and [He90] can distinguish to some extent struct List f char *hd; struct List *tl; g; struct List * Copy (struct List *L) f struct List *p, *t1; C 1 : if (L == null) C 2 : return (L); C 3 : p = malloc ( ); C 4 : t1 <p> This encom passes a large subset of the C language. Why is it significant? An example Our method provides a solution to an open problem <ref> [LH88a, CWZ90, He90, HHN92] </ref>: how to improve the accuracy of alias analysis in the presence of recursive pointer data structures. The information obtained by our analysis is generally much more precise than that obtained by previous methods. on an example due to Larus & Hilfinger [LH88b, p. 103]. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. <ref> [He90] </ref> would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. <ref> [He90] </ref> would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods [LH88a, HPR89, De90, St92, CBC93] fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]).
Reference: [HG92] <author> L.J. Hendren and G.R. Gao. </author> <title> Designing programming languages for analysability: a fresh look at pointer data structures. </title> <booktitle> In [ICC92], </booktitle> <pages> pp. 242-251. </pages>
Reference-contexts: Existential alias analysis is also called may-alias analysis. Compile-time alias information is important for scalar optimizations such as code motion; compile-time garbage-collection; program verification and debugging; dependence analysis; parallelisation and improving code generation for instruction-level parallelism <ref> [Wa91, HG92, RF93] </ref>. Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral [SF + 90] and interprocedural [LR91] algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem [La92b].
Reference: [HHN92] <author> L.J. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In [PLD92], </booktitle> <pages> pp. 249-260. </pages>
Reference-contexts: The present paper provides a practical application to imperative languages of the general theory of [De92b]. [He90] cannot handle cyclic data: as noted in <ref> [HHN92] </ref>, this is a serious obstacle to its use in languages with pointers. [CWZ90] and [He90] can distinguish to some extent struct List f char *hd; struct List *tl; g; struct List * Copy (struct List *L) f struct List *p, *t1; C 1 : if (L == null) C 2 <p> This encom passes a large subset of the C language. Why is it significant? An example Our method provides a solution to an open problem <ref> [LH88a, CWZ90, He90, HHN92] </ref>: how to improve the accuracy of alias analysis in the presence of recursive pointer data structures. The information obtained by our analysis is generally much more precise than that obtained by previous methods. on an example due to Larus & Hilfinger [LH88b, p. 103]. <p> Such information is important for optimisation, for instance to perform software pipelin-ing <ref> [HHN92, RF93] </ref>. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in <ref> [HHN92] </ref>, [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods [LH88a, HPR89, De90, St92, CBC93] fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]).
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Conf. on Programming Language Design and Implementation, volume 24(7) of SIGPLAN Notices, </booktitle> <pages> pp. 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods <ref> [LH88a, HPR89, De90, St92, CBC93] </ref> fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8].
Reference: [Hu86] <author> P. Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In Conf. Record of the 1986 ACM Symp. on LISP and Functional Programming, </booktitle> <pages> pp. 351-363, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information <ref> [Hu86, He88, CWZ90] </ref>, sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [ICC92] <editor> Proc. </editor> <booktitle> of the IEEE 1992 International Conf. on Computer Languages, </booktitle> <address> San Francisco, </address> <month> Apr. </month> <year> 1992. </year> <note> IEEE Press. </note>
Reference: [Jo81] <author> N.D. Jones. </author> <title> Flow analysis of lambda expressions. </title> <booktitle> In Symp. on Functional Languages and Computer Architecture, </booktitle> <pages> pp. 376-401. </pages> <institution> Chalmers University of Technology, </institution> <month> June </month> <year> 1981. </year>
Reference-contexts: Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) <ref> [Jo81, JM82] </ref> determined by the allocation context. All these methods partition an infinite number of run-time objects (or access paths) into a finite number of equivalence classes. As a consequence, store-based methods will typically fail to distinguish between elements of recursive pointer data structures. <p> Such sets will be used to represent finitely possibly infinite sets of access paths. For instance f (X-&gt;(tl-&gt;) i hd-&gt;(tl -&gt;) j hd; S ] fi = 5 This is necessary because alias relations are right-regular <ref> [Jo81] </ref>: if is aliased to 0 then for each path ffi (such that :ffi exists), :ffi is aliased to 0 :ffi. <p> This case analysis describes precisely the aliases generated by an assignment <ref> [Jo81, De92a] </ref>, in terms of (possibly infinite) sets of alias pairs. We now define an abstract counterpart of this operation which does not oper ate on sets of alias pairs, but on (finite) symbolic alias relations.
Reference: [JM81] <editor> N.D. Jones and S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pp. 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> Data flow values are kept finite by either k-limiting <ref> [JM81] </ref> or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context. All these methods partition an infinite number of run-time objects (or access paths) into a finite number of equivalence classes.
Reference: [JM82] <editor> N.D. Jones and S. Muchnick. </editor> <title> A flexible approach to inter-procedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 66-74. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) <ref> [Jo81, JM82] </ref> determined by the allocation context. All these methods partition an infinite number of run-time objects (or access paths) into a finite number of equivalence classes. As a consequence, store-based methods will typically fail to distinguish between elements of recursive pointer data structures. <p> just before the assignment shown in Figure 7 is described by the symbolic alias relation % 1 , then aliasing after this assignment is % 2 = f (% 1 ). 3 The interprocedural framework Interprocedural methods for non-distributive problems over large semilattices limit information loss by analysing procedures separately <ref> [CC77c, SP81, JM82] </ref>, keyed by some token abstracting the call context. However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. <p> This is to avoid non-realizable interprocedural paths. The seminal papers <ref> [CC77c, SP81, JM82] </ref> present systematic and direct methods to perform this extension. [LR92] uses alias sets of size one as tokens, [CBC93] uses calling points and/or incoming alias sets (which can result in exponential behaviour, see [ML + 93]).
Reference: [Jo81] <author> H.B.M. Jonkers. </author> <title> Abstract storage structures. </title> <editor> In de Bakker and van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> pp. 321-343. </pages> <publisher> IFIP, North Holland, </publisher> <year> 1981. </year>
Reference-contexts: Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) <ref> [Jo81, JM82] </ref> determined by the allocation context. All these methods partition an infinite number of run-time objects (or access paths) into a finite number of equivalence classes. As a consequence, store-based methods will typically fail to distinguish between elements of recursive pointer data structures. <p> Such sets will be used to represent finitely possibly infinite sets of access paths. For instance f (X-&gt;(tl-&gt;) i hd-&gt;(tl -&gt;) j hd; S ] fi = 5 This is necessary because alias relations are right-regular <ref> [Jo81] </ref>: if is aliased to 0 then for each path ffi (such that :ffi exists), :ffi is aliased to 0 :ffi. <p> This case analysis describes precisely the aliases generated by an assignment <ref> [Jo81, De92a] </ref>, in terms of (possibly infinite) sets of alias pairs. We now define an abstract counterpart of this operation which does not oper ate on sets of alias pairs, but on (finite) symbolic alias relations.
Reference: [Ka76] <author> M. Karr. </author> <title> Affine relationships among variables of a program. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 133-151, </pages> <year> 1976. </year>
Reference-contexts: Our alias analysis framework is parametrized by a lattice framework V ] whose purpose is to express information about tuples of integers. In essence, this lattice V ] controls qualitatively the ability to reason about dependencies (typ ical examples of V ] are constant propagation [Ki73], linear arithmetic constraints <ref> [Ka76] </ref>, arithmetic intervals [CC77a], simple sections [BK89] etc., and combi nations of these). 2. an algorithm for interprocedural may-alias analysis with pointers. <p> commutative decomposition [Pa66]. struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities <ref> [Ka76] </ref>, linear inequalities [CH78], simple sections [BK89, CC92], linear congruence equalities [Gr91] and con-gruential trapezoids [Ma91]. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice. <p> i; S ] fk 1 =0; k 2 =0g)g if V ] is the lattice of arithmetic intervals [CC77a]: % 1 t % 2 = f (hX-&gt;(tl-&gt;) k 1 hd ; Y -&gt;(tl-&gt;) k 2 hd i; S ] f0k 1 ;k 2 1g)g if V ] is Karr's lattice <ref> [Ka76] </ref>: % 1 t % 2 = f (hX-&gt;(tl-&gt;) k 1 hd ; Y -&gt;(tl-&gt;) k 2 hd i; S ] fk 1 =k 2 g)g predefined variables, say k 1 ; k 2 ; : : : The operator Rename maps a symbolic alias pair (hf 1 ; f 2 <p> The numerical lattices we have experimented with are: (1) the lattice of arithmetic intervals [CC77a]; (2) the combination of the lattice of intervals and of the lattice of linear equalities <ref> [Ka76] </ref> (see [CC79] and [Gr92] for an explanation of how to devise an optimal combination). Data flow equations augmented with widening operators are solved using standard iterative techniques.
Reference: [Ki73] <author> G. Kildall. </author> <title> A unified approach to global program opti-misation. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 194-206, </pages> <year> 1973. </year>
Reference-contexts: Our alias analysis framework is parametrized by a lattice framework V ] whose purpose is to express information about tuples of integers. In essence, this lattice V ] controls qualitatively the ability to reason about dependencies (typ ical examples of V ] are constant propagation <ref> [Ki73] </ref>, linear arithmetic constraints [Ka76], arithmetic intervals [CC77a], simple sections [BK89] etc., and combi nations of these). 2. an algorithm for interprocedural may-alias analysis with pointers. <p> V ] determines which class of relations between positions in aliased data structures can be captured. Independent (mono-dimensional) numeric lattices include: constant propagation <ref> [Ki73] </ref>, arithmetic intervals [CC77a, Mo84] and arithmetic congruences [Gr89].
Reference: [La92a] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context.
Reference: [La92b] <author> W. Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 323-337, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral [SF + 90] and interprocedural [LR91] algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem <ref> [La92b] </ref>. Intuitively, this is because alias sets become potentially infinite, and because transfer functions are not distributive as with single-level pointers. Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer-induced aliasing. </title> <booktitle> In [POP91], </booktitle> <pages> pp. 93-103. </pages>
Reference-contexts: Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral [SF + 90] and interprocedural <ref> [LR91] </ref> algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem [La92b]. Intuitively, this is because alias sets become potentially infinite, and because transfer functions are not distributive as with single-level pointers. Existing methods.
Reference: [LR92] <author> W. Landi and B.G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In [PLD92], </booktitle> <pages> pp. 235-248. </pages>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context. <p> Copy (t2); L 2 : X = null; L 3 : Algorithm Result at point L2 Spurious aliases [LH88a] -X ? 6 - - (Y -&gt;tl -&gt;tl ; Y -&gt;tl-&gt;tl-&gt;tl ); : : :g -Y 6 - 1 - 6 1 1 f (X-&gt;hd; X-&gt;tl-&gt;hd); (Y -&gt;tl -&gt;tl -&gt;hd; X-&gt;hd); <ref> [LR92] </ref> (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); [CBC93] (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered [LH88a] [CWZ90] [LR92] [CBC93] Deutsch <p> -&gt;hd; X-&gt;hd); <ref> [LR92] </ref> (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); [CBC93] (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered [LH88a] [CWZ90] [LR92] [CBC93] Deutsch P 1 : X and Y are acyclic yes yes yes P 2 : two successive heads of Y don't alias yes yes P 3 : X and Y tails don't alias yes yes yes yes P 4 : heads of X and Y are aliased only pairwise <p> However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. Therefore, following <ref> [CC77c, Ha79, MR89, LR92] </ref>, we perform therefore generalisation of data flow values through function calls and instantiation through function returns. Consider two alias pairs hx; 1 i and hx; 2 i reaching the entry of a function F (x; y). <p> If 1 and 2 are not visible in F and in the functions called by F , we can generalise these two alias pairs by a single alias pair hx; U i. U is a generic object name. The key observation, due to <ref> [MR89, LR92] </ref>, is that F operates uniformly on all the aliases of x that are not visible. Then F will be analysed with the incoming pair hx; U i, and the aliasing at the output of F can be propagated back by instantiation. <p> This is to avoid non-realizable interprocedural paths. The seminal papers [CC77c, SP81, JM82] present systematic and direct methods to perform this extension. <ref> [LR92] </ref> uses alias sets of size one as tokens, [CBC93] uses calling points and/or incoming alias sets (which can result in exponential behaviour, see [ML + 93]). We clearly separated the basic interprocedural framework from its extensions, unlike [LR92, ML + 93]. <p> We clearly separated the basic interprocedural framework from its extensions, unlike <ref> [LR92, ML + 93] </ref>. Our framework can therefore easily be extended to an arbitrary token set. This is an issue orthogonal to the present contribution. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8]. Regardless of the value of the parameter k of their analysis, <ref> [LR92] </ref> also report a cyclic list as it detects spurious aliases of the form hfl (l-&gt;tl -&gt;tl); fl (l-&gt;tl-&gt;tl-&gt;tl)i. Landi & Ryder's method is based on sets of pairs of k-limited access paths. It will not report aliasing when a data structure is completely unaliased, unlike store-based methods.
Reference: [LH88a] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In ACM SIGPLAN'88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pp. 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> : P-&gt;tl = Copy (t1); C 6 : p-&gt;hd = L-&gt;hd; C 7 : return (p); g /* X is an unaliased list */ L 1 : t2 = X; Y = Copy (t2); L 2 : X = null; L 3 : Algorithm Result at point L2 Spurious aliases <ref> [LH88a] </ref> -X ? 6 - - (Y -&gt;tl -&gt;tl ; Y -&gt;tl-&gt;tl-&gt;tl ); : : :g -Y 6 - 1 - 6 1 1 f (X-&gt;hd; X-&gt;tl-&gt;hd); (Y -&gt;tl -&gt;tl -&gt;hd; X-&gt;hd); [LR92] (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); [CBC93] (S1-&gt;hd; S3); <p> -&gt;tl -&gt;tl -&gt;hd; X-&gt;hd); [LR92] (X-&gt;tl-&gt;hd; Y -&gt;tl -&gt;hd); f (X-&gt;tl-&gt;tl ; Y -&gt;tl-&gt;tl); (X-&gt;tl -&gt;tl; Y -&gt;tl-&gt;tl -&gt;tl ); [CBC93] (S1-&gt;hd; S3); (S2-&gt;hd; S3); f (X-&gt;tl; X-&gt;tl-&gt;tl); (Y -&gt;tl -&gt;hd; Y -&gt;tl -&gt;tl -&gt;hd); Deutsch f (X-&gt;(tl -&gt;) i hd; Y -&gt;(tl-&gt;) j hd) j none Program property discovered <ref> [LH88a] </ref> [CWZ90] [LR92] [CBC93] Deutsch P 1 : X and Y are acyclic yes yes yes P 2 : two successive heads of Y don't alias yes yes P 3 : X and Y tails don't alias yes yes yes yes P 4 : heads of X and Y are aliased <p> This encom passes a large subset of the C language. Why is it significant? An example Our method provides a solution to an open problem <ref> [LH88a, CWZ90, He90, HHN92] </ref>: how to improve the accuracy of alias analysis in the presence of recursive pointer data structures. The information obtained by our analysis is generally much more precise than that obtained by previous methods. on an example due to Larus & Hilfinger [LH88b, p. 103]. <p> Section 4 discusses the time complexity of our method, and our prototype implementation is discussed in Section 5. Finally, we assess the precision of the alias information discovered by our framework in Section 6. 1 Node labels computed by the method <ref> [LH88a] </ref> are not shown. In the entry [CWZ90], graph nodes are annotated with approximate reference counts. For the method [CBC93], the S1; S2; : : : are heap names (allocation sites). Alias pairs are shown for readability without the external level of dereferencing. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods <ref> [LH88a, HPR89, De90, St92, CBC93] </ref> fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8].
Reference: [LH88b] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Restructuring Lisp programs for concurrent execution. </title> <booktitle> In ACM SIGPLAN'88 Conf. on Parallel Programming: Experiences with Applications, Languages and Systems, </booktitle> <pages> pp. 100-110, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: alias yes yes P 3 : X and Y tails don't alias yes yes yes yes P 4 : heads of X and Y are aliased only pairwise yes P 5 : at point L 3 , heads and tails of Y are completely unaliased yes yes aliased (adapted from <ref> [LH88b, p. 103] </ref>) between trees, dags and graphs. The first one extends store-based methods with reference counting, but is accurate only intraprocedurally in limited cases, as reference counts cannot, in general, be decremented safely. Contributions. 1. an expressive and parametric program analysis framework for may-alias analysis with pointers. <p> The information obtained by our analysis is generally much more precise than that obtained by previous methods. on an example due to Larus & Hilfinger <ref> [LH88b, p. 103] </ref>. The spurious aliases are due to k-limiting (Larus & Hilfin-ger, Landi & Ryder) or to collapsing together different heap nodes (Chase et al., Choi et al.). As can be seen, the analyses are in general not strictly comparable in precision.
Reference: [ML + 93] <author> T.J. Marlowe, W.G. Landi, B.G. Ryder, J.D. Choi, M.G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: This is to avoid non-realizable interprocedural paths. The seminal papers [CC77c, SP81, JM82] present systematic and direct methods to perform this extension. [LR92] uses alias sets of size one as tokens, [CBC93] uses calling points and/or incoming alias sets (which can result in exponential behaviour, see <ref> [ML + 93] </ref>). We clearly separated the basic interprocedural framework from its extensions, unlike [LR92, ML + 93]. Our framework can therefore easily be extended to an arbitrary token set. This is an issue orthogonal to the present contribution. <p> We clearly separated the basic interprocedural framework from its extensions, unlike <ref> [LR92, ML + 93] </ref>. Our framework can therefore easily be extended to an arbitrary token set. This is an issue orthogonal to the present contribution.
Reference: [MR89] <author> T.J. Marlowe and B.G. Ryder. </author> <title> Hybrid incremental alias algorithms. </title> <type> Tech. report LCSR-TR-129, </type> <institution> Rutgers University, </institution> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. Therefore, following <ref> [CC77c, Ha79, MR89, LR92] </ref>, we perform therefore generalisation of data flow values through function calls and instantiation through function returns. Consider two alias pairs hx; 1 i and hx; 2 i reaching the entry of a function F (x; y). <p> If 1 and 2 are not visible in F and in the functions called by F , we can generalise these two alias pairs by a single alias pair hx; U i. U is a generic object name. The key observation, due to <ref> [MR89, LR92] </ref>, is that F operates uniformly on all the aliases of x that are not visible. Then F will be analysed with the incoming pair hx; U i, and the aliasing at the output of F can be propagated back by instantiation.
Reference: [Ma91] <author> F. Masdupuy. </author> <title> Using abstract interpretation to detect array data dependencies. </title> <booktitle> In Proc. of the International Symp. on Supercomputing, </booktitle> <pages> pp. 19-27. </pages> <publisher> Kyushu University Press, </publisher> <month> Nov. </month> <year> 1991. </year> <note> ISBN 4-87378-284-8. </note>
Reference-contexts: struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities [CH78], simple sections [BK89, CC92], linear congruence equalities [Gr91] and con-gruential trapezoids <ref> [Ma91] </ref>. We will now list our assumptions about the numeric lattice and its associated operations, so as to keep our construction parametric by avoiding dependence on a particular numeric lattice.
Reference: [Mo84] <author> E. Morel. </author> <title> Data flow analysis and global optimisation. </title> <editor> In B. Lorho, editor, </editor> <title> Methods and Tools for Compiler Construction, </title> <booktitle> an Advanced Course, </booktitle> <pages> pp. 289-315. </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: V ] determines which class of relations between positions in aliased data structures can be captured. Independent (mono-dimensional) numeric lattices include: constant propagation [Ki73], arithmetic intervals <ref> [CC77a, Mo84] </ref> and arithmetic congruences [Gr89].
Reference: [NPD87] <author> A. Neirynck, P. Panangaden, and A.J. Demers. </author> <title> Computation of aliases and support sets. </title> <booktitle> In Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 274-283, </pages> <year> 1987. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [Pa66] <editor> R.J. Parikh. </editor> <title> On context-free languages. </title> <journal> J. ACM, </journal> <volume> 13 </volume> <pages> 570-581, </pages> <year> 1966. </year>
Reference-contexts: The formalism used is based on Eilenberg's unitary-prefix monomial decomposition [Ei74], on Parikh's commutative decomposition <ref> [Pa66] </ref> and on a storeless semantic model of aliasing properties based on right-regular equivalence relations. The main result of that paper is the lattice of unitary-prefix monomial relations on subsets of a regular language, which is shown to be an abstract interpretation of the lattice of right-regular equivalence relations. <p> include: linear 2 The internal, postfix representation of the symbolic access path f is Xfl:(tlfl) i :hd. 3 The theoretically inclined reader is encouraged to consult [De92b] and [De92a, x3] for a theoretical account of the connection between SAPs, the unitary-prefix monomials of Eilenberg's treatise [Ei74] and Parikh's commutative decomposition <ref> [Pa66] </ref>. struct List f char *hd; struct List *tl; g struct List2 f struct List *hd; struct List2 *tl;g struct Tree f char *key; struct Tree *left,*right;g Basis (struct List) = ftl -&gt;g Basis (struct List2) = ftl -&gt;g Basis (struct T ree) = fleft-&gt;; right-&gt;g bases equalities [Ka76], linear inequalities
Reference: [RF93] <author> B. Rau and J. Fisher. </author> <title> Instruction-level parallel processing. </title> <journal> The Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 9-50, </pages> <year> 1993. </year>
Reference-contexts: Existential alias analysis is also called may-alias analysis. Compile-time alias information is important for scalar optimizations such as code motion; compile-time garbage-collection; program verification and debugging; dependence analysis; parallelisation and improving code generation for instruction-level parallelism <ref> [Wa91, HG92, RF93] </ref>. Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral [SF + 90] and interprocedural [LR91] algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem [La92b]. <p> Such information is important for optimisation, for instance to perform software pipelin-ing <ref> [HHN92, RF93] </ref>. In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data.
Reference: [RM88] <author> C. Ruggieri and T. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Fifteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 285-293. </pages> <publisher> ACM Press, </publisher> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [SF + 90] <author> S. Sagiv, N. Francez, M. Rodeh, and R. Wilhem. </author> <title> A logic-based approach to data flow analysis. </title> <booktitle> In Programming Language Implementation and Logic Programming, volume 456 of Lecture Notes on Computer Science, </booktitle> <pages> pp. 277-292. </pages> <publisher> Springer Verlag, </publisher> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral <ref> [SF + 90] </ref> and interprocedural [LR91] algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem [La92b]. Intuitively, this is because alias sets become potentially infinite, and because transfer functions are not distributive as with single-level pointers. Existing methods. <p> These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedu-ral data flow analysis. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pp. 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: just before the assignment shown in Figure 7 is described by the symbolic alias relation % 1 , then aliasing after this assignment is % 2 = f (% 1 ). 3 The interprocedural framework Interprocedural methods for non-distributive problems over large semilattices limit information loss by analysing procedures separately <ref> [CC77c, SP81, JM82] </ref>, keyed by some token abstracting the call context. However this usually results in information loss for recursive procedures, as each recursive call can generate a new semilattice value. <p> This is to avoid non-realizable interprocedural paths. The seminal papers <ref> [CC77c, SP81, JM82] </ref> present systematic and direct methods to perform this extension. [LR92] uses alias sets of size one as tokens, [CBC93] uses calling points and/or incoming alias sets (which can result in exponential behaviour, see [ML + 93]).
Reference: [Sh91] <author> O. Shivers. </author> <title> Control-flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, Pitts-burgh, </institution> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93].
Reference: [St92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Existing methods. Approximate existential alias analysis methods for pointers can be classified into: store-based methods and access-paths based methods. These methods use either finite graphs (or abstract stores) to represent potential run-time stores <ref> [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] </ref> possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] or a combination of the two [CBC93]. <p> Such information is important for optimisation, for instance to perform software pipelin-ing [HHN92, RF93]. In contrast, <ref> [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] </ref> report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. <p> In contrast, [LH88a, HPR89, De90, CWZ90, LR92, St92, CBC93] report that the list l may be cyclic at G3. [He90] would probably detect that l is not cyclic. However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods <ref> [LH88a, HPR89, De90, St92, CBC93] </ref> fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of [St92, CBC93]). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8]. <p> However, as noted in [HHN92], [He90] is not of general applicability as it cannot handle graph-shaped data. The store-based methods [LH88a, HPR89, De90, St92, CBC93] fail because of their inability to distinguish an unbounded data structure from a cyclic data structure (this is independent of the parameter k of <ref> [St92, CBC93] </ref>). The addition of reference counting proposed by Chase et al. also fails, as discussed in their paper [CWZ90, p.309,x8].
Reference: [Wa91] <author> D.W. Wall. </author> <title> Limits of instruction-level parallelism. </title> <booktitle> In Proc. ASPLOS III, </booktitle> <pages> pp. 176-178, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: Existential alias analysis is also called may-alias analysis. Compile-time alias information is important for scalar optimizations such as code motion; compile-time garbage-collection; program verification and debugging; dependence analysis; parallelisation and improving code generation for instruction-level parallelism <ref> [Wa91, HG92, RF93] </ref>. Static determination of aliases for reference parameters and single-level pointers is now a well understood problem for which there exists accurate polynomial intraprocedu-ral [SF + 90] and interprocedural [LR91] algorithms. However, determining aliases for recursive pointer datatypes is a much harder problem [La92b].
Reference: [We80] <author> W.E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Seventh Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 83-94, </pages> <year> 1980. </year>
Reference-contexts: These methods use either finite graphs (or abstract stores) to represent potential run-time stores [JM81, JM82, NPD87, RM88, LH88a, Ha89, HPR89, De90, Sh91, De92a, St92] possibly augmented with reference count information [Hu86, He88, CWZ90], sets of pairs of access paths to represent aliasing <ref> [CC77b, We80, ASU86, He90, SF + 90, La92a, LR92] </ref> or a combination of the two [CBC93]. Data flow values are kept finite by either k-limiting [JM81] or by using a finite number of graph nodes (abstract locations) [Jo81, JM82] determined by the allocation context.
References-found: 58

