URL: http://www.cs.unc.edu/~walk/papers/cohenj/icollide.ps.gz
Refering-URL: http://www.cs.unc.edu/~cohenj/publications.html
Root-URL: http://www.cs.unc.edu
Email: fcohenj,lin,manocha,ponamgig@cs.unc.edu  
Title: I-COLLIDE: An Interactive and Exact Collision Detection System for Large-Scale Environments  
Author: Jonathan D. Cohen Ming C. Lin Dinesh Manocha Madhav K. Ponamgi 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We present an exact and interactive collision detection system, I-COLLIDE, for large-scale environments. Such environments are characterized by the number of objects undergoing rigid motion and the complexity of the models. The algorithm does not assume the objects' motions can be expressed as a closed form function of time. The collision detection system is general and can be easily interfaced with a variety of applications. The algorithm uses a two-level approach based on pruning multiple-object pairs using bounding boxes and performing exact collision detection between selected pairs of polyhedral models. We demonstrate the performance of the system in walkthrough and simulation environments consisting of a large number of moving objects. In particular, the system takes less than 1=20 of a second to determine all the collisions and contacts in an environment consisting of more than a 1000 moving polytopes, each consisting of more than 50 faces on an HP-9000/750. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.Garica-Alonso, N.Serrano, and J.Flaquer. </author> <title> Solving the collision detection problem. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 36-43, </pages> <year> 1994. </year>
Reference-contexts: The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement.
Reference: [2] <author> D. Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 19-28, </pages> <year> 1990. </year>
Reference: [3] <author> D. Baraff. </author> <title> Dynamic simulation of non-penetrating rigid body simulation. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement. <p> For convex 3-polytopes 1 linear time algorithms based on linear programming and tracking closest points [10] have been proposed. More recently, temporal and geometric coherence have been used to devise algorithms based on checking local features of pairs of convex 3-polytopes <ref> [3, 17] </ref>. Alonso et al.[1] use bounding boxes and spatial partitioning to test all O (n 2 ) pairs of arbitrary polyhedral objects. Different methods have been proposed to overcome the bottleneck of O (n 2 ) pairwise tests in an environment of n bodies. <p> In environments where the objects make relatively small movements between frames, the lists will be nearly sorted, so we can sort in expected O (n) time, as shown in <ref> [19, 3] </ref>. Insertion sort works well for previously sorted lists. In addition to sorting, we need to keep track of changes in overlap status of interval pairs (i.e. from overlapping in the last time step to non-overlapping in the current time step, and vice-versa).
Reference: [4] <author> S. Cameron. </author> <title> Collision detection by four-dimensional intersection testing. </title> <booktitle> Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages pp. 291-302, </pages> <year> 1990. </year>
Reference-contexts: Collisions are checked between all object pairs belonging to a particular cell. This approach works well for sparse environments in which the objects are uniformly distributed through the space. Another approach operates directly on four-dimensional volumes swept out by object motion over time <ref> [4, 14] </ref>. None of these algorithms adequately address the issue of collision detection in a virtual environment which requires performance at interactive rates for thousands of pairwise tests. Hubbard has proposed a solution to address this problem by trading accuracy for speed [14].
Reference: [5] <author> S. Cameron. </author> <title> Approximation hierarchies and s-bounds. </title> <booktitle> In Proceedings. Symposium on Solid Modeling Foundations and CAD/CAM Applications, </booktitle> <pages> pages 129-137, </pages> <address> Austin, TX, </address> <year> 1991. </year>
Reference: [6] <author> J. Cohen, M. Lin, D. Manocha, and K. Ponamgi. </author> <title> Interactive and exact collision detection for large-scaled environments. </title> <type> Technical Report TR94-005, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference: [7] <author> P. Dworkin and D. Zeltzer. </author> <title> A new model for efficient dynamics simulation. </title> <booktitle> Proceedings Eurographics workshop on animation and simulation, </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: Hubbard has proposed a solution to address this problem by trading accuracy for speed [14]. In an early extension of their work, Lin and Canny [16] proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model <ref> [7] </ref>. 3 BACKGROUND In this section, we highlight the importance of coherence in dynamic environments. <p> This previous closest feature pair may not be a good guess when the polytope pair has just become active. Dworkin and Zeltzer <ref> [7] </ref> suggest precom-puting a lookup table for each polytope to help find better starting guesses. 5.3 Multi-body Simulation The multi-body simulation is an application we developed to test the I-COLLIDE system. <p> This is explained further in our discussion of Graph 5. The seconds per frame numbers in Graph 1 compare very favorably with the work of Dworkin and Zeltzer <ref> [7] </ref> as well as those of Hub-bard [14]. For a 1000 polytopes in our simulation, our collision time results in 23 frames per second using the fixed bounding cubes. Graph 2 shows how the number faces affects the collision time. We took 20 uniformly sampled data points.
Reference: [8] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, Part I. </title> <journal> Internat. J. Comput. Math., </journal> <volume> 13 </volume> <pages> 209-219, </pages> <year> 1983. </year>
Reference-contexts: Each query of an interval intersection takes O (log n+k) time where k is the number of reported intersections and n is the number of intervals. Therefore, reporting intersections among n rectangles can be done in O (n log n+K) where K is the total number of intersecting rectangles <ref> [8] </ref>. 4.4 Alternatives to Dimension Reduction There are many different methods for reducing the number of pairwise tests, such as binary space partitioning (BSP) trees [23], octrees, etc. Several practical and efficient algorithms are based on uniform space division.
Reference: [9] <author> J. Snyder et. al. </author> <title> Interval methods for multi-point collisions between time dependent curved surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 321-334, </pages> <year> 1993. </year>
Reference: [10] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between objects in three-dimensional space. </title> <journal> IEEE J. Robotics and Automation, </journal> <volume> vol RA-4:pp. </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference-contexts: Most of them are restricted to a static instance of the problem and are non-trivial to implement. For convex 3-polytopes 1 linear time algorithms based on linear programming and tracking closest points <ref> [10] </ref> have been proposed. More recently, temporal and geometric coherence have been used to devise algorithms based on checking local features of pairs of convex 3-polytopes [3, 17]. Alonso et al.[1] use bounding boxes and spatial partitioning to test all O (n 2 ) pairs of arbitrary polyhedral objects.
Reference: [11] <author> J. K. Hahn. </author> <title> Realistic animation of rigid bodies. </title> <journal> Computer Graphics, </journal> <volume> 22(4):pp. </volume> <pages> 299-308, </pages> <year> 1988. </year>
Reference-contexts: The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement.
Reference: [12] <author> J.E. Hopcroft, J.T. Schwartz, and M. Sharir. </author> <title> Efficient detection of intersections among spheres. </title> <journal> The International Journal of Robotics Research, </journal> <volume> 2(4) </volume> <pages> 77-80, </pages> <year> 1983. </year>
Reference-contexts: Our method is suitable for dynamic environments where coherence is preserved. In computational geometry literature several algorithms exist that solve the static version of determining 3-D bounding box overlaps in O (n log 2 n + s) time, where s is the number of pairwise overlaps <ref> [12, 13] </ref>. We have reduced this to O (n + s) by using coherence. 4.3 Two-Dimensional Intersection Tests The two-dimensional intersection algorithm begins by projecting each three-dimensional axis-aligned bounding box onto any two of the x-y, x-z, and y-z planes. Each of these projections is a rectangle in 2-space.
Reference: [13] <author> H.Six and D.Wood. </author> <title> Counting and reporting intersections of D-ranges. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 46-55, </pages> <year> 1982. </year>
Reference-contexts: Our method is suitable for dynamic environments where coherence is preserved. In computational geometry literature several algorithms exist that solve the static version of determining 3-D bounding box overlaps in O (n log 2 n + s) time, where s is the number of pairwise overlaps <ref> [12, 13] </ref>. We have reduced this to O (n + s) by using coherence. 4.3 Two-Dimensional Intersection Tests The two-dimensional intersection algorithm begins by projecting each three-dimensional axis-aligned bounding box onto any two of the x-y, x-z, and y-z planes. Each of these projections is a rectangle in 2-space.
Reference: [14] <author> P. M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Collisions are checked between all object pairs belonging to a particular cell. This approach works well for sparse environments in which the objects are uniformly distributed through the space. Another approach operates directly on four-dimensional volumes swept out by object motion over time <ref> [4, 14] </ref>. None of these algorithms adequately address the issue of collision detection in a virtual environment which requires performance at interactive rates for thousands of pairwise tests. Hubbard has proposed a solution to address this problem by trading accuracy for speed [14]. <p> None of these algorithms adequately address the issue of collision detection in a virtual environment which requires performance at interactive rates for thousands of pairwise tests. Hubbard has proposed a solution to address this problem by trading accuracy for speed <ref> [14] </ref>. In an early extension of their work, Lin and Canny [16] proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model [7]. 3 BACKGROUND In this section, we highlight the importance of coherence in dynamic environments. <p> This is explained further in our discussion of Graph 5. The seconds per frame numbers in Graph 1 compare very favorably with the work of Dworkin and Zeltzer [7] as well as those of Hub-bard <ref> [14] </ref>. For a 1000 polytopes in our simulation, our collision time results in 23 frames per second using the fixed bounding cubes. Graph 2 shows how the number faces affects the collision time. We took 20 uniformly sampled data points.
Reference: [15] <author> J.C. Latombe. </author> <title> Robot Motion Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Section 7 presents our experimental results on walkthrough envi ronments and simulations. 1 2 PREVIOUS WORK The problem of collision detection has been extensively studied in robotics, computational geometry, and computer graphics. The goal in robotics has been the planning of collision-free paths between obstacles <ref> [15] </ref>. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time [1, 3, 11, 18, 20, 21].
Reference: [16] <author> M. Lin and J. Canny. </author> <title> Efficient collision detection for animation. </title> <booktitle> In Proceedings of the Third Eurograph-ics Workshop on Animation and Simulation, </booktitle> <address> Cam-bridge, England, </address> <year> 1991. </year>
Reference-contexts: Hubbard has proposed a solution to address this problem by trading accuracy for speed [14]. In an early extension of their work, Lin and Canny <ref> [16] </ref> proposed a scheduling scheme to handle multiple moving objects. Dworkin and Zeltzer extended this work for a sparse model [7]. 3 BACKGROUND In this section, we highlight the importance of coherence in dynamic environments. <p> of the boundary and of the interior in E 3 . steps are small enough that the objects to do not travel large distances between frames. 3.2 Pairwise Collision Detection for Convex Polytopes We briefly review the Lin-Canny collision detection algorithm which tracks closest points between pairs of convex polytopes <ref> [16, 17] </ref>. This algorithm is used at the lowest level of collision detection to determine the exact contact status between convex polytopes. The method maintains a pair of closest features for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions.
Reference: [17] <author> M.C. Lin. </author> <title> Efficient Collision Detection for Animation and Robotics. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: For convex 3-polytopes 1 linear time algorithms based on linear programming and tracking closest points [10] have been proposed. More recently, temporal and geometric coherence have been used to devise algorithms based on checking local features of pairs of convex 3-polytopes <ref> [3, 17] </ref>. Alonso et al.[1] use bounding boxes and spatial partitioning to test all O (n 2 ) pairs of arbitrary polyhedral objects. Different methods have been proposed to overcome the bottleneck of O (n 2 ) pairwise tests in an environment of n bodies. <p> of the boundary and of the interior in E 3 . steps are small enough that the objects to do not travel large distances between frames. 3.2 Pairwise Collision Detection for Convex Polytopes We briefly review the Lin-Canny collision detection algorithm which tracks closest points between pairs of convex polytopes <ref> [16, 17] </ref>. This algorithm is used at the lowest level of collision detection to determine the exact contact status between convex polytopes. The method maintains a pair of closest features for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions.
Reference: [18] <author> M. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 289-298, </pages> <year> 1988. </year>
Reference-contexts: The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement.
Reference: [19] <author> M.Shamos and D.Hoey. </author> <title> Geometric intersection problems. </title> <booktitle> Proc. 17th An. IEEE Symp. Found. on Com-put. Science, </booktitle> <pages> pages 208-215, </pages> <year> 1976. </year>
Reference-contexts: In environments where the objects make relatively small movements between frames, the lists will be nearly sorted, so we can sort in expected O (n) time, as shown in <ref> [19, 3] </ref>. Insertion sort works well for previously sorted lists. In addition to sorting, we need to keep track of changes in overlap status of interval pairs (i.e. from overlapping in the last time step to non-overlapping in the current time step, and vice-versa).
Reference: [20] <author> A. Pentland. </author> <title> Computational complexity versus simulated environment. </title> <journal> Computer Graphics, </journal> <volume> 22(2) </volume> <pages> 185-192, </pages> <year> 1990. </year>
Reference-contexts: Due to these unconstrained variables, collision detection is currently considered to be one of the major bottlenecks in building interactive simulated environments <ref> [20] </ref>. Main Contribution: We present a collision detection algorithm and system for interactive and exact collision detection in complex environments. <p> The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement.
Reference: [21] <author> M. Ponamgi, D. Manocha, and M. Lin. </author> <title> Incremental algorithms for collision detection between solid models. </title> <type> Technical Report TR94-061, </type> <institution> Department of Computer Science, University of North Carolina, Chapel Hill, </institution> <year> 1994. </year>
Reference-contexts: The goal in robotics has been the planning of collision-free paths between obstacles [15]. This differs from virtual environments and physically-based simulations, where the motion is subject to dynamic constraints or external forces and cannot typically be expressed as a closed form function of time <ref> [1, 3, 11, 18, 20, 21] </ref>. At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms [22]. Most of them are restricted to a static instance of the problem and are non-trivial to implement. <p> So instead we use pseudo-Voronoi regions, obtained by joining each vertex of the polytope with the centroid of the polytope <ref> [21] </ref>. Given a partition of the exterior and the interior of the polytope, we walk from the external Voronoi regions into the pseudo-internal Voronoi regions when necessary. If either of the closest features falls into a pseudo-Voronoi region at the end of the walk, we know the objects are interpenetrating. <p> In the hierarchical representation, the internal nodes can be convex or non-convex sub-parts, but all the leaf nodes are convex polytopes or features <ref> [21] </ref>. Beginning with the leaf nodes, we construct either a convex hull or other bounding volume and work up the tree, level by level, to the root. <p> If there is no collision between the two parents, the algorithm returns the closest feature pair of their bounding volumes. If there is a collision, the algorithm expands their children and recursively proceeds down the tree to determine if a collision actually occurs. More details are given in <ref> [21] </ref>. 4 MULTIPLE-OBJECT COLLISION DETECTION Large-scale environments consist of stationary as well as moving objects. Let there be N moving objects and M stationary objects. Each of the N moving objects can collide with the other moving objects, as well as with the stationary ones.
Reference: [22] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: At the same time, the emphasis in the computational geometry has been on theoretically efficient intersection detection algorithms <ref> [22] </ref>. Most of them are restricted to a static instance of the problem and are non-trivial to implement. For convex 3-polytopes 1 linear time algorithms based on linear programming and tracking closest points [10] have been proposed. <p> This results in fewer swaps as the objects move. In situations where the projections onto one-dimension result in densely clustered intervals, the two-dimensional technique is more efficient. The interval tree is a common data structure for performing such two-dimensional range queries <ref> [22] </ref>. Each query of an interval intersection takes O (log n+k) time where k is the number of reported intersections and n is the number of intervals.
Reference: [23] <author> W.Thibault and B.Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <journal> ACM Computer Graphics, </journal> <volume> 4, </volume> <year> 1987. </year>
Reference-contexts: Therefore, reporting intersections among n rectangles can be done in O (n log n+K) where K is the total number of intersecting rectangles [8]. 4.4 Alternatives to Dimension Reduction There are many different methods for reducing the number of pairwise tests, such as binary space partitioning (BSP) trees <ref> [23] </ref>, octrees, etc. Several practical and efficient algorithms are based on uniform space division. Divide space into unit cells (or volumes) and place each object in some cell (s).
Reference: [24] <author> D. Zeltzer. </author> <title> Autonomy, interaction and presence. Presence, </title> <journal> 1(1):127, 1992. </journal> <volume> 8 9 </volume>
Reference-contexts: Such actions require accurate collision detection. However, there may be hundreds, even thousands of objects in the virtual world, so a brute-force approach that tests all possible pairs for collisions is not acceptable. Efficiency is critical in a virtual environment, otherwise its interactive nature is lost <ref> [24] </ref>. A fast and interactive collision detection algorithm is a fundamental component of a complex virtual environment. The objective of collision detection is to report all geometric contacts between objects.
References-found: 24

