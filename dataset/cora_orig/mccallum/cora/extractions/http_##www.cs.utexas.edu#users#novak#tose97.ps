URL: http://www.cs.utexas.edu/users/novak/tose97.ps
Refering-URL: http://www.cs.utexas.edu/users/novak/tose97.html
Root-URL: 
Title: Software Reuse by Specialization of Generic Procedures through Views  
Author: Gordon S. Novak Jr. 
Keyword: Index Terms software reuse, view, generic algorithm, generic procedure, algorithm specialization, partial evaluation, direct-manipulation editor, abstract data type.  
Note: This article appears in IEEE Transactions on Software Engineering, vol. 23, no.  
Date: August 1, 1997  7, July 1997.  
Abstract: Copyright c fl1997 by IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. Abstract A generic procedure can be specialized, by compilation through views, to operate directly on concrete data. A view is a computational mapping that describes how a concrete type implements an abstract type. Clusters of related views are needed for specialization of generic procedures that involve several types or several views of a single type. A user interface that reasons about relationships between concrete types and abstract types allows view clusters to be created easily. These techniques allow rapid specialization of generic procedures for applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> IEEE Trans. </editor> <booktitle> on Software Engineering, </booktitle> <volume> vol. 11, no. 11, </volume> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in <ref> [1] </ref>, [39], and [60]. Mili [41] extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice [61] was based on reuse of cliches, somewhat analogous to our generics. This project produced some good ideas but had limited success.
Reference: [2] <author> M. Arbib and E. Manes, </author> <title> Arrows, Structures, and Functors: The Categorical Imperative, </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: If a ffi b is difficult to obtain directly, its value can be computed by encoding a and b using ', performing the computation '(a) fl '(b), and decoding or interpreting the result using the inverse ' 1 . A diagram is said to commute <ref> [2] </ref> if the same result is obtained regardless of which path between two points is followed, as shown in the diagram above. 2.2 Views as Isomorphisms Reuse of generic algorithms through views corresponds to computation as isomorphism.
Reference: [3] <author> R. Balzer, </author> <title> "A 15 Year Perspective on Automatic Programming," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 11, no. </volume> <pages> 11 pp. 1257-1267, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: They require only modest understanding of the details of library procedures for successful reuse. Our techniques allow restructuring of data to meet new requirements or to improve efficiency. Traditional languages reflect the data implementation in the code <ref> [3] </ref>, making changes costly. Our system derives code from the data definitions; design decisions are stated in a single place and distributed by compilation rather than by hand coding. The ability to produce code in different languages decouples the choice of programming tools from the choice of application language.
Reference: [4] <author> D. Batory and S. O'Malley, </author> <title> "The Design and Implementation of Hierarchical Software Systems with Reusable Components," </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <volume> vol. 1, no. 4, </volume> <pages> pp. 355-398, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Our approach adapts components to fit the application. Zaremski and Wing [77] describe retrieval of reusable ML components based on signature matching of functions and modules; related techniques could be used with our generics. 30 Batory <ref> [4] </ref> [5] [6] describes a data structure precompiler and construction of software systems from layers of plug-compatible components with standardized interfaces. The use of layers whose interfaces are carefully specified allows the developer to ensure that the layers will interface correctly.
Reference: [5] <author> D. Batory, V. Singhal, J. Thomas, and M. Sirkin, </author> <title> "Scalable Software Libraries," </title> <booktitle> Proc. ACM SIGSOFT '93: Foundations of Software Engineering, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This illustrates that switch values in view types can select optional features of generics. Weide [73] notes that options in reusable procedures are essential to avoid a combinatoric set of versions. For example, the Booch component set [9] contains over 500 components; Batory <ref> [5] </ref> has identified these as combinations of fewer design decisions. The linked-list library has 28 procedures; one view cluster allows specialization of any of them. VIEWAS requires minimal input; it presents sensible choices, so the user does not need to understand the abstract types in detail. <p> Our approach adapts components to fit the application. Zaremski and Wing [77] describe retrieval of reusable ML components based on signature matching of functions and modules; related techniques could be used with our generics. 30 Batory [4] <ref> [5] </ref> [6] describes a data structure precompiler and construction of software systems from layers of plug-compatible components with standardized interfaces. The use of layers whose interfaces are carefully specified allows the developer to ensure that the layers will interface correctly.
Reference: [6] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> "Reengineering a Complex Application Using a Scalable Data Structure Compiler," </title> <booktitle> in Proc. ACM SIGSOFT '94, </booktitle> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Our approach adapts components to fit the application. Zaremski and Wing [77] describe retrieval of reusable ML components based on signature matching of functions and modules; related techniques could be used with our generics. 30 Batory [4] [5] <ref> [6] </ref> describes a data structure precompiler and construction of software systems from layers of plug-compatible components with standardized interfaces. The use of layers whose interfaces are carefully specified allows the developer to ensure that the layers will interface correctly.
Reference: [7] <author> A. Berlin and D. Weise, </author> <title> "Compiling Scientific Code Using Partial Evaluation," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 12, </volume> <pages> pp. 25-37, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Symbolic optimization folds operations on constants [62], performs partial evaluation <ref> [7] </ref> [12] and mathematical optimization, removes dead code, and combines operations to improve efficiency. It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time. <p> Intentions can be transformed by enzymes at the abstract syntax tree level and can be parsed and unparsed into various surface syntaxes by methods stored with or inherited by the intentions. This work is in progress; its results to date are impressive. Berlin and Weise <ref> [7] </ref> used partial evaluation to improve efficiency of scientific programs. Given that certain features of a problem are constant, their compiler performs as many constant calculations as possible at compile time, yielding a specialized program that runs faster. Our system includes partial evaluation by in-lining and symbolic optimization.
Reference: [8] <author> T. Biggerstaff and A. Perlis (eds), </author> <title> Software Reusability (2 vols.), </title> <publisher> ACM Press / Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The system described here is not a silver bullet, but it suggests that significant improvement in software development is possible. 8.1 Software Reuse Krueger [34] is an excellent survey of software reuse, with criteria for practical effectiveness. Biggerstaff and Perlis <ref> [8] </ref> contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], [39], and [60]. Mili [41] extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice [61] was based on reuse of cliches, somewhat analogous to our generics.
Reference: [9] <author> G. Booch, </author> <title> Software Components with Ada, </title> <address> Benjamin-Cummings, </address> <year> 1987. </year>
Reference-contexts: This illustrates that switch values in view types can select optional features of generics. Weide [73] notes that options in reusable procedures are essential to avoid a combinatoric set of versions. For example, the Booch component set <ref> [9] </ref> contains over 500 components; Batory [5] has identified these as combinations of fewer design decisions. The linked-list library has 28 procedures; one view cluster allows specialization of any of them.
Reference: [10] <author> F. P. Brooks, </author> <title> "No Silver Bullet: </title> <journal> Essence and Accidents of Software Engineering," IEEE Computer, </journal> <volume> vol. 20, no. </volume> <pages> 4 pp. 10-19. </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: It is easy to use. The amount of user input and the learning required are small. 3. It produces efficient code in several languages. 4. It minimally constrains the representation of data. Generics can be specialized for use with existing data and programs. Brooks <ref> [10] </ref> contends that there are "no silver bullets" in software development. The system described here is not a silver bullet, but it suggests that significant improvement in software development is possible. 8.1 Software Reuse Krueger [34] is an excellent survey of software reuse, with criteria for practical effectiveness.
Reference: [11] <author> J. C. Cleaveland, </author> <title> An Introduction to Data Types, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: to v will yield z. 3 Although it is not required, our abstract types usually specify a concrete record containing the basis variables; this is useful as an example and for testing the generic procedures. 4 This definition of abstract type is different from the algebraic description of abstract types <ref> [11] </ref> as a collection of abstract sorts, procedure signatures, and axioms. In the algebraic approach, an abstract type is described without regard to its implementation.
Reference: [12] <author> C. Consel and O. Danvy, </author> <title> "Tutorial Notes on Partial Evaluation," </title> <booktitle> ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993, </year> <pages> pp. </pages> <month> 493-501. </month> <title> [13] "The Common Object Request Broker: Architecture and Specification," TC Document 91.12.1, Revision 1.1, </title> <booktitle> Object Management Group, </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Symbolic optimization folds operations on constants [62], performs partial evaluation [7] <ref> [12] </ref> and mathematical optimization, removes dead code, and combines operations to improve efficiency. It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time. <p> Given that certain features of a problem are constant, their compiler performs as many constant calculations as possible at compile time, yielding a specialized program that runs faster. Our system includes partial evaluation by in-lining and symbolic optimization. Consel and Danvy <ref> [12] </ref> survey work on partial evaluation. 8.6 Views Goguen [18] proposes a library interconnection language, LIL. This proposal has much in common with our approach, and Goguen uses the term view similarly; LIL has a stronger focus on mathematical descriptions and axioms.
Reference: [14] <author> R. B. K. Dewar, </author> <title> The SETL Programming Language, </title> <type> manuscript, </type> <year> 1980. </year>
Reference-contexts: Alphard [66] and CLU [38] allow iterators for concrete types; Interlisp [30] provided a flexible looping construct for Lisp lists. SETL <ref> [14] </ref> provides sets and maps and compiles loops over them, with implementations chosen by the compiler [63]. Generic procedures need loops that are independent of data structure (e.g., array, linked list, or tree); this is done by loop macros. <p> Our system allows storing into a data structure through a view and composition of views [52]. Miranda [71] is a strongly-typed functional language with higher-order functions. While this allows generics, it is often hard to write functional programs with good performance. SETL <ref> [14] </ref> provides sets and set operations. [63] describes an attempt to automatically choose data structures in SETL to improve efficiency.
Reference: [15] <author> E. W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Smith [68] uses the term theory morphism for a similar notion. Dijkstra <ref> [15] </ref> uses the term coordinate transformation for a similar notion, in which some variables are replaced by others; Gries [23] uses the term coupling invariant for the predicate that describes the relation (between the abstract types or variables and their concrete counterparts) that is to be maintained by functions.
Reference: [16] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <month> 35 </month>
Reference-contexts: In the algebraic approach, an abstract type is described without regard to its implementation. In our approach, an abstract implementation is assumed because the abstract type has generic procedures that implement operations. 5 Views can be implemented in an object-oriented system by adapter or wrapper objects <ref> [16] </ref>, where a wrapper contains the concrete data, presents the interface of the abstract type, and translates messages between the abstract and concrete types. Our views give the effect of wrappers without creating them. 6 2.
Reference: [17] <author> D. Garlan, </author> <title> "Views for Tools in Integrated Environments," </title> <editor> in R. Conradi, T. Didriksen, and D. Wanvik (eds.), </editor> <booktitle> LNCS 244: Adv. Prog. Environments, </booktitle> <publisher> Springer, </publisher> <year> 1986. </year>
Reference-contexts: Tracz [70] describes LILEANNA, which implements LIL for construction of Ada packages; views in LILEANNA map types, operations, and exceptions between theories. In our system, views are computational transformations between types; general procedures as well as operators can be reused. Garlan <ref> [17] </ref> and Kaiser [31] use views to allow tools in a program development environment to access a common set of data.
Reference: [18] <author> J. A. Goguen, </author> <title> "Reusing and Interconnecting Software Components," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 16-28, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Data Procedure Data View Generic Procedure 1 We consider an abstract type to be a set of basis variables and a set of generic procedures that are written in terms of the basis variables. 2 Goguen <ref> [18] </ref> and others have used a similar analogy and diagram. 2 Concrete Type View Compiler Generic Procedure Specialized Procedure ? ? This approach to reuse has several advantages: 1. It provides freedom to select the implementation of data; data need not be designed ab initio to match the algorithms. 2. <p> Section 8 surveys related work, and Section 9 presents conclusions. 3 2 Views 2.1 Computation as Isomorphism It is useful to think of all computation as simulation or, more formally, as isomorphism. This idea has a long history; for example, isomorphism is the basis of denotational semantics [20]. Goguen <ref> [18] </ref> [19] describes views as isomorphisms, with mappings of unary and binary operators. Our views allow broader mappings between concrete and abstract types and include algorithms as well as operators. We use isomorphism to introduce the use of views. <p> Our system includes partial evaluation by in-lining and symbolic optimization. Consel and Danvy [12] survey work on partial evaluation. 8.6 Views Goguen <ref> [18] </ref> proposes a library interconnection language, LIL. This proposal has much in common with our approach, and Goguen uses the term view similarly; LIL has a stronger focus on mathematical descriptions and axioms.
Reference: [19] <author> J. A. Goguen, </author> <booktitle> "Principles of Parameterized Programming," </booktitle> <volume> [8], </volume> <pages> pp. 159-225. </pages>
Reference-contexts: This idea has a long history; for example, isomorphism is the basis of denotational semantics [20]. Goguen [18] <ref> [19] </ref> describes views as isomorphisms, with mappings of unary and binary operators. Our views allow broader mappings between concrete and abstract types and include algorithms as well as operators. We use isomorphism to introduce the use of views. <p> This proposal has much in common with our approach, and Goguen uses the term view similarly; LIL has a stronger focus on mathematical descriptions and axioms. The OBJ language family of Goguen et al. <ref> [19] </ref> has views that are formal type mappings; operators are mapped by strict isomorphisms. Tracz [70] describes LILEANNA, which implements LIL for construction of Ada packages; views in LILEANNA map types, operations, and exceptions between theories.
Reference: [20] <author> M. J. C. Gordon, </author> <title> The Denotational Description of Programming Languages, </title> <publisher> Springer, </publisher> <year> 1979. </year>
Reference-contexts: Section 8 surveys related work, and Section 9 presents conclusions. 3 2 Views 2.1 Computation as Isomorphism It is useful to think of all computation as simulation or, more formally, as isomorphism. This idea has a long history; for example, isomorphism is the basis of denotational semantics <ref> [20] </ref>. Goguen [18] [19] describes views as isomorphisms, with mappings of unary and binary operators. Our views allow broader mappings between concrete and abstract types and include algorithms as well as operators. We use isomorphism to introduce the use of views.
Reference: [21] <author> D. Gries and J. Prins, </author> <title> "A New Notion of Encapsulation," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 20, no. 7, </volume> <pages> pp. 131-139, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Our system allows significant representation changes to be accomplished easily by recompilation. Formal verification might be applied to specialized generics. Gries and Prins <ref> [21] </ref> suggest a stratified proof of a program obtained by transformation: if a generic is correct and an implementation of its abstract type is correct, the transformed algorithm will be correct. Morgan [42] extends these techniques for proofs of data refinements. <p> The user must select transformations to be used and must supply a formal domain theory for the application. This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins <ref> [21] </ref> proposed use of syntactic transformations to specify implementation of abstract algorithms. Volpano [72] and Gries [23] describe systems in which a user specifies transformations for variables, expression patterns, and statement patterns; by performing substitutions on an algorithm, a different version of the algorithm is obtained.
Reference: [22] <author> D. Gries and I. Stojmenovic, </author> <title> "A Note on Graham's Convex Hull Algorithm," </title> <journal> Information Processing Letters, </journal> <volume> vol. 25, no. </volume> <month> 5 (July </month> <year> 1987), </year> <pages> pp. 323-327. </pages>
Reference-contexts: Although convex hull algorithms are described in textbooks [64] and in the literature, getting an algorithm from such sources is difficult: it is necessary to understand the algorithm, and a published description may omit details of the algorithm or even contain errors <ref> [22] </ref>. A hand-coded version of a published algorithm requires testing or verification. Fig. 13 illustrates execution of a generic convex hull algorithm. We describe the algorithm 23 and illustrate its use on cities viewed as points.
Reference: [23] <author> D. Gries and D. Volpano, </author> <title> "The Transform aNew Language Construct," </title> <journal> Structured Programming, </journal> <volume> vol. 11, no. 1, </volume> <pages> pp. 1-10, </pages> <year> 1990. </year>
Reference-contexts: Smith [68] uses the term theory morphism for a similar notion. Dijkstra [15] uses the term coordinate transformation for a similar notion, in which some variables are replaced by others; Gries <ref> [23] </ref> uses the term coupling invariant for the predicate that describes the relation (between the abstract types or variables and their concrete counterparts) that is to be maintained by functions. <p> This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins [21] proposed use of syntactic transformations to specify implementation of abstract algorithms. Volpano [72] and Gries <ref> [23] </ref> describe systems in which a user specifies transformations for variables, expression patterns, and statement patterns; by performing substitutions on an algorithm, a different version of the algorithm is obtained.
Reference: [24] <author> J. V. Guttag and J. J. Horning, </author> <title> "Introduction to LCL, a LARCH/C Interface Language," </title> <type> TR SRC-74, </type> <institution> D.E.C. Software Res. Ctr., </institution> <address> Palo Alto, CA, </address> <year> 1991. </year>
Reference-contexts: Re-representation of data allows reuse of an existing procedure; it requires space and execution time, although [36] found this was a small cost in a compiler. [49] and this paper describe methods for data translation, but these do not handle shared structure. Guttag and Horning <ref> [24] </ref> describe a formal language for specifying procedure interface signatures and properties. Yellin and Strom [76] describe semi-automatic synthesis of protocol converters to allow interfacing of clients and servers. 8.8 Object-oriented Programming We have described how views can be used to generate methods for OOP.
Reference: [25] <author> B. Hailpern and H. Ossher, </author> <title> "Extending Objects to Support Multiple Interfaces and Access Control," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 11, </volume> <pages> pp. 1247-1257, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Their MELD system can combine features (collections of classes and methods) to allow "additive" construction of a system from selected features. 32 Meyers [40] discusses problems of consistency among program development tools and surveys approaches including use of files, databases, and views as developed by Garlan. Hailpern and Ossher <ref> [25] </ref> describe views as subsets of methods of a class, to restrict certain methods to particular clients.
Reference: [26] <author> W. Harrison and H. Ossher, </author> <title> "Subject-Oriented Programming (A Critique of Pure Objects)," </title> <journal> Proc. OOPSLA-93, ACM SIGPLAN Notices, </journal> <volume> vol. 28, no. 10, </volume> <pages> pp. 411-428, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Hailpern and Ossher [25] describe views as subsets of methods of a class, to restrict certain methods to particular clients. Harrison and Ossher <ref> [26] </ref> argue that OOP is too restrictive for applications that need their own views of objects; they propose subjects that are analogous to class hierarchies. 8.7 Data Translation IDL (Interface Description Language) [36] translates representations, possibly with structure sharing, for exchange of data between parts of a compiler, based on precise
Reference: [27] <author> M. Herlihy and B. Liskov, </author> <title> "A Value Transmission Method for Abstract Data Types," </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> vol. 4, no. 4, </volume> <pages> pp. 527-551, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: Herlihy and Liskov <ref> [27] </ref> describe transmission of data over a network, with representation translation and shared structure; the user writes procedures to encode and decode data for transmission.
Reference: [28] <author> R. F. Hille, </author> <title> Data Abstraction and Program Development using Modula-2, </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The use of layers whose interfaces are carefully specified allows the developer to ensure that the layers will interface correctly. We have focused on adapting interfaces so that generics can be reused for independently designed data. 8.3 Languages with Generic Procedures Ada, Modula-2 <ref> [28] </ref>, and C++ [69] allow modules for parameterized abstract types such as ST ACK [type]. Books of generic procedures [37] [44] contain some of the same procedures that are provided with our system.
Reference: [29] <author> I. M. Holland, </author> <title> "Specifying Reusable Components Using Contracts," </title> <editor> in O. Lehrmann Madsen (ed.), </editor> <booktitle> Proc. 6th European Conf. Object-Oriented Prog. (ECOOP-92), </booktitle> <volume> LNCS 615, </volume> <pages> pp. 287-308, </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: In many OOP systems, a class must include all data of its superclasses, so reuse with OOP restricts implementation of data; names of data and messages must be consistent and must not conflict. Holland <ref> [29] </ref> uses contracts to specify data and behavioral obligations of composed objects. Contracts are somewhat like our clusters, but require that specializations include certain instance data and implement data in the same way as the generics that are to be specialized.
Reference: [30] <institution> Interlisp Reference Manual, Xerox Palo Alto Research Center, </institution> <year> 1983. </year>
Reference-contexts: A single definition of a generic covers the combinatoric set of component types. 6.2 Generic Loop Macros A language with abstract types must provide loops over collections of data. Alphard [66] and CLU [38] allow iterators for concrete types; Interlisp <ref> [30] </ref> provided a flexible looping construct for Lisp lists. SETL [14] provides sets and maps and compiles loops over them, with implementations chosen by the compiler [63]. Generic procedures need loops that are independent of data structure (e.g., array, linked list, or tree); this is done by loop macros.
Reference: [31] <author> G. Kaiser and D. Garlan, </author> <title> "Synthesizing Programming Environments from Reusable Features," </title> <booktitle> in [8], </booktitle> <pages> pp. 35-55. </pages>
Reference-contexts: Tracz [70] describes LILEANNA, which implements LIL for construction of Ada packages; views in LILEANNA map types, operations, and exceptions between theories. In our system, views are computational transformations between types; general procedures as well as operators can be reused. Garlan [17] and Kaiser <ref> [31] </ref> use views to allow tools in a program development environment to access a common set of data.
Reference: [32] <author> E. Kant, </author> <title> "Understanding and Automating Algorithm Design," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 11, no. 11, </volume> <pages> pp. 1361-1374, </pages> <month> Nov. </month> <year> 1985. </year> <month> 36 </month>
Reference-contexts: The C version of the convex hull program, described below, runs 20 times faster than the Lisp version. 6.6 A Larger Example: Convex Hull The convex hull of a set of points is the smallest convex polygon that encloses them. Kant <ref> [32] </ref> studied highly qualified human subjects who wrote algorithms for this task. All subjects took considerable time; some failed or produced an inefficient solution.
Reference: [33] <author> E. Kant, F. Daube, W. MacGregor, and J. Wald, </author> <title> "Scientific Programming by Automated Synthesis," </title> <booktitle> in [39], </booktitle> <pages> pp. 169-205. </pages>
Reference-contexts: Our views specify transformations from features of abstract types to their implementations. Kant et al. <ref> [33] </ref> describe Sinapse, which generates programs to simulate spatial differential equations, e.g. for seismic analysis. Sinapse transforms a small specification into a much larger program in Fortran or C; it is written using Mathematica [75] and appears to work 31 well within its domain.
Reference: [34] <author> C. W. Krueger, </author> <title> "Software Reuse," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 24, no. 2, </volume> <pages> pp. 131-184, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It is always possible to say "an equivalent program could be written in language x"; however, a system for software reuse must satisfy several criteria simultaneously to be effective <ref> [34] </ref>. We claim that the system described here satisfies all of these criteria: 1. It has wide applicability: many kinds of software can be expressed as reusable generics. 2. It is easy to use. The amount of user input and the learning required are small. 3. <p> Generics can be specialized for use with existing data and programs. Brooks [10] contends that there are "no silver bullets" in software development. The system described here is not a silver bullet, but it suggests that significant improvement in software development is possible. 8.1 Software Reuse Krueger <ref> [34] </ref> is an excellent survey of software reuse, with criteria for practical effectiveness. Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], [39], and [60].
Reference: [35] <author> P. Kruchten, E. Schonberg, and J. Schwartz, </author> <title> "Software Prototyping using the SETL Language," </title> <journal> IEEE Software, </journal> <volume> vol. 1, no. </volume> <pages> 4 pp. 66-75, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: Miranda [71] is a strongly-typed functional language with higher-order functions. While this allows generics, it is often hard to write functional programs with good performance. SETL [14] provides sets and set operations. [63] describes an attempt to automatically choose data structures in SETL to improve efficiency. Kruchten et al. <ref> [35] </ref> say "slow is beautiful" to emphasize ease of constructing programs, but inefficient implementations can make even small problems intractable. 8.5 Transformation Systems Transformation systems repeatedly replace parts of an abstract algorithm specification with code that is closer to an implementation, until executable code is reached.
Reference: [36] <author> D. Lamb, </author> <title> "IDL: Sharing Intermediate Representations," </title> <journal> ACM Trans. Programming Languages Syst. </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 267-318, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Harrison and Ossher [26] argue that OOP is too restrictive for applications that need their own views of objects; they propose subjects that are analogous to class hierarchies. 8.7 Data Translation IDL (Interface Description Language) <ref> [36] </ref> translates representations, possibly with structure sharing, for exchange of data between parts of a compiler, based on precise data specifications. Herlihy and Liskov [27] describe transmission of data over a network, with representation translation and shared structure; the user writes procedures to encode and decode data for transmission. <p> Purtilo and Atlee [58] describe a system that translates calling sequences by producing small interface modules that reorder and translate parameters as necessary for the called procedure. Re-representation of data allows reuse of an existing procedure; it requires space and execution time, although <ref> [36] </ref> found this was a small cost in a compiler. [49] and this paper describe methods for data translation, but these do not handle shared structure. Guttag and Horning [24] describe a formal language for specifying procedure interface signatures and properties.
Reference: [37] <author> C. Lins, </author> <title> The Modula-2 Software Component Library, </title> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: We have focused on adapting interfaces so that generics can be reused for independently designed data. 8.3 Languages with Generic Procedures Ada, Modula-2 [28], and C++ [69] allow modules for parameterized abstract types such as ST ACK [type]. Books of generic procedures <ref> [37] </ref> [44] contain some of the same procedures that are provided with our system. In Ada and Modula-2, such collections have limited value because such code is easy to write and is only a small part of most applications.
Reference: [38] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J. C. Schaffert, R. Scheifler, and A. Snyder, </author> <title> CLU Reference Manual, </title> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: A single definition of a generic covers the combinatoric set of component types. 6.2 Generic Loop Macros A language with abstract types must provide loops over collections of data. Alphard [66] and CLU <ref> [38] </ref> allow iterators for concrete types; Interlisp [30] provided a flexible looping construct for Lisp lists. SETL [14] provides sets and maps and compiles loops over them, with implementations chosen by the compiler [63].
Reference: [39] <author> M. Lowry and R. McCartney, eds., </author> <title> Automating Software Design, </title> <publisher> AAAI Press / MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], <ref> [39] </ref>, and [60]. Mili [41] extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice [61] was based on reuse of cliches, somewhat analogous to our generics. This project produced some good ideas but had limited success.
Reference: [40] <author> S. Meyers, </author> <title> "Difficulties in Integrating Multiview Development Systems," </title> <journal> IEEE Software, </journal> <volume> vol. 8, no. 1, </volume> <pages> pp. 49-57, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Garlan [17] and Kaiser [31] use views to allow tools in a program development environment to access a common set of data. Their MELD system can combine features (collections of classes and methods) to allow "additive" construction of a system from selected features. 32 Meyers <ref> [40] </ref> discusses problems of consistency among program development tools and surveys approaches including use of files, databases, and views as developed by Garlan. Hailpern and Ossher [25] describe views as subsets of methods of a class, to restrict certain methods to particular clients.
Reference: [41] <author> H. Mili, F. Mili, and A. Mili, </author> <title> "Reusing Software: Issues and Research Directions," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 21, no. 6, </volume> <pages> pp. 528-562, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], [39], and [60]. Mili <ref> [41] </ref> extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice [61] was based on reuse of cliches, somewhat analogous to our generics. This project produced some good ideas but had limited success.
Reference: [42] <author> C. Morgan, </author> <title> "Data Refinement by Miracles," </title> <journal> Information Processing Letters, </journal> <volume> vol. 26, </volume> <pages> pp. 243-246, </pages> <year> 1988. </year>
Reference-contexts: Formal verification might be applied to specialized generics. Gries and Prins [21] suggest a stratified proof of a program obtained by transformation: if a generic is correct and an implementation of its abstract type is correct, the transformed algorithm will be correct. Morgan <ref> [42] </ref> extends these techniques for proofs of data refinements. Morris [43] provides calculational laws for refinement of programs written in terms of abstract types such as bags and sets.
Reference: [43] <author> J. M. Morris, </author> <title> "Laws of Data Refinement," </title> <journal> Acta Informatica, </journal> <volume> vol. 26, </volume> <pages> pp. 287-308, </pages> <year> 1989. </year>
Reference-contexts: Gries and Prins [21] suggest a stratified proof of a program obtained by transformation: if a generic is correct and an implementation of its abstract type is correct, the transformed algorithm will be correct. Morgan [42] extends these techniques for proofs of data refinements. Morris <ref> [43] </ref> provides calculational laws for refinement of programs written in terms of abstract types such as bags and sets.
Reference: [44] <author> D. Musser and A. Stepanov, </author> <title> The Ada Generic Library, </title> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: We have focused on adapting interfaces so that generics can be reused for independently designed data. 8.3 Languages with Generic Procedures Ada, Modula-2 [28], and C++ [69] allow modules for parameterized abstract types such as ST ACK [type]. Books of generic procedures [37] <ref> [44] </ref> contain some of the same procedures that are provided with our system. In Ada and Modula-2, such collections have limited value because such code is easy to write and is only a small part of most applications.
Reference: [45] <author> R. Neches, R. Fikes, T. Finin, T. Gruber, R. Patil, P. Senator, and W. Swartout, </author> <title> "Enabling Technology for Knowledge Sharing," </title> <journal> AI Magazine, </journal> <volume> vol. 12, no. 3, </volume> <pages> pp. 36-56, </pages> <month> Fall </month> <year> 1991. </year>
Reference-contexts: The Common Object Request Broker Architecture (CORBA) [13] includes an Interface Definition Language and can automatically generate stubs to allow interoperability of objects across distributed systems and across languages and machine architectures. The ARPA Knowledge-Sharing Project <ref> [45] </ref> addresses the problem of sharing knowledge bases that were developed using different ontologies. Purtilo and Atlee [58] describe a system that translates calling sequences by producing small interface modules that reorder and translate parameters as necessary for the called procedure.
Reference: [46] <author> G. Novak, </author> <title> "GLISP: A LISP-Based Programming System With Data Abstraction," </title> <journal> AI Magazine, </journal> <volume> vol. 4, no. 3, </volume> <pages> pp. 37-47, </pages> <month> Fall </month> <year> 1983. </year>
Reference-contexts: The next section describes how views are implemented and compiled in GLISP. 6 This could include arrays, or sub-records reached by a fixed sequence of pointer traversals. 7 3 GLISP Language and Compiler GLISP <ref> [46, 47, 48, 49] </ref> ("Generic Lisp"), a high-level language with abstract data types, is compiled into Lisp; it has a language for describing data in Lisp and in other languages. <p> GLISP is described only briefly here; for more detail, see [49] and <ref> [46] </ref>. 3.1 Data-independent Code A GLISP type is analogous to a class in object-oriented programming (OOP); it specifies a data structure and a set of methods. For each method, there is a name (selector) and a definition as an expression or function. <p> It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time. Optimization often eliminates operations associated with a view, so that use of the view has little or no cost after compilation. 3.2 Views in GLISP A view <ref> [46, 49, 50] </ref> is expressed as a GLISP type whose record is the concrete type. The abstract type is a superclass of the view type, allowing generics to be inherited 7 . The view type encapsulates the concrete type and defines methods to compute basis variables of the abstract type. <p> Finally, the vertices are collected as a (non-circular) linked list. Fig. 13 shows the successive splittings. The algorithm rapidly eliminates most points from consideration. Fig. 16 shows the type cluster used for convex hull. The line formed by a point and its successor is declared as a virtual line-segment <ref> [46] </ref>; this is another way of specifying a view. This allows the polygon to be treated simultaneously as a sequence of vertices and as a sequence of edges. Only vertices are represented, but the algorithm deals with edges as well.
Reference: [47] <author> G. Novak, </author> <title> "GLISP User's Manual," </title> <type> Tech. Report STAN-CS-82-895, </type> <institution> Stanford Univ., 1982; TR-83-25, Univ. of Texas at Austin. </institution>
Reference-contexts: The next section describes how views are implemented and compiled in GLISP. 6 This could include arrays, or sub-records reached by a fixed sequence of pointer traversals. 7 3 GLISP Language and Compiler GLISP <ref> [46, 47, 48, 49] </ref> ("Generic Lisp"), a high-level language with abstract data types, is compiled into Lisp; it has a language for describing data in Lisp and in other languages.
Reference: [48] <author> G. Novak, </author> <title> "Data Abstraction in GLISP," </title> <booktitle> Proc. SIGPLAN '83 Symposium, ACM SIGPLAN Notices, </booktitle> <volume> vol. 18, no. 3, </volume> <pages> pp. 170-177, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: The next section describes how views are implemented and compiled in GLISP. 6 This could include arrays, or sub-records reached by a fixed sequence of pointer traversals. 7 3 GLISP Language and Compiler GLISP <ref> [46, 47, 48, 49] </ref> ("Generic Lisp"), a high-level language with abstract data types, is compiled into Lisp; it has a language for describing data in Lisp and in other languages.
Reference: [49] <author> G. Novak, F. Hill, M. Wan, and B. Sayrs, </author> <title> "Negotiated Interfaces for Software Reuse," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 18, no. 7, </volume> <month> July </month> <year> 1992. </year> <month> 37 </month>
Reference-contexts: The next section describes how views are implemented and compiled in GLISP. 6 This could include arrays, or sub-records reached by a fixed sequence of pointer traversals. 7 3 GLISP Language and Compiler GLISP <ref> [46, 47, 48, 49] </ref> ("Generic Lisp"), a high-level language with abstract data types, is compiled into Lisp; it has a language for describing data in Lisp and in other languages. <p> GLISP is described only briefly here; for more detail, see <ref> [49] </ref> and [46]. 3.1 Data-independent Code A GLISP type is analogous to a class in object-oriented programming (OOP); it specifies a data structure and a set of methods. For each method, there is a name (selector) and a definition as an expression or function. <p> GLISP uses a single Lisp-like syntax. In Lisp, a function call is written inside parentheses: (sqrt x). A similar syntax (feature object) is used in GLISP to access any feature of a data structure <ref> [49] </ref>: 1. If feature is the name of a field of the type of object, data access is compiled. 2. If feature is a method name (selector) of the type of object, the method call is compiled. 3. <p> It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time. Optimization often eliminates operations associated with a view, so that use of the view has little or no cost after compilation. 3.2 Views in GLISP A view <ref> [46, 49, 50] </ref> is expressed as a GLISP type whose record is the concrete type. The abstract type is a superclass of the view type, allowing generics to be inherited 7 . The view type encapsulates the concrete type and defines methods to compute basis variables of the abstract type. <p> Re-representation of data allows reuse of an existing procedure; it requires space and execution time, although [36] found this was a small cost in a compiler. <ref> [49] </ref> and this paper describe methods for data translation, but these do not handle shared structure. Guttag and Horning [24] describe a formal language for specifying procedure interface signatures and properties.
Reference: [50] <author> G. Novak, </author> <title> "Software Reuse through View Type Clusters," </title> <booktitle> 7th Knowledge--Based Software Engineering Conf., </booktitle> <publisher> IEEE CS Press, </publisher> <year> 1992, </year> <pages> pp. 70-79. </pages>
Reference-contexts: It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time. Optimization often eliminates operations associated with a view, so that use of the view has little or no cost after compilation. 3.2 Views in GLISP A view <ref> [46, 49, 50] </ref> is expressed as a GLISP type whose record is the concrete type. The abstract type is a superclass of the view type, allowing generics to be inherited 7 . The view type encapsulates the concrete type and defines methods to compute basis variables of the abstract type.
Reference: [51] <author> G. Novak, </author> <title> "Generating Programs from Connections of Physical Models," </title> <booktitle> 10th Conf. Artificial Intelligence for Applications, </booktitle> <publisher> IEEE CS Press, </publisher> <year> 1994, </year> <pages> pp. 224-230. </pages>
Reference-contexts: VIEWAS is intended for views of data structures; a companion program MKV [54] uses a graphical interface and algebraic manipulation of equations to make mathematical views. We have also investigated creation of programs from connections of diagrams that represent physical and mathematical models <ref> [51] </ref>. 19 6 Higher-order Code 6.1 Compound Structures Abstract types may be used in larger structures.
Reference: [52] <author> G. Novak, </author> <title> "Composing Reusable Software Components through Views," </title> <booktitle> 9th Knowledge-Based Software Engineering Conf., </booktitle> <publisher> IEEE CS Press, </publisher> <year> 1994, </year> <pages> pp. 39-47. </pages>
Reference-contexts: ML also includes references (pointers) that allow imperative programming. ML functors can instantiate generic modules such as container types. Our system allows storing into a data structure through a view and composition of views <ref> [52] </ref>. Miranda [71] is a strongly-typed functional language with higher-order functions. While this allows generics, it is often hard to write functional programs with good performance. SETL [14] provides sets and set operations. [63] describes an attempt to automatically choose data structures in SETL to improve efficiency.
Reference: [53] <author> G. Novak, </author> <title> "Conversion of Units of Measurement," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 21, no. 8, </volume> <pages> pp. 651-661, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: this higher-order code can transfer data to a different record type and can change the representation during the transfer, e.g., by converting the radius of a circle in one representation to the area in another representation, or by converting the data 21 to reflect different representations or units of measurement <ref> [53] </ref>.
Reference: [54] <author> G. Novak, </author> <title> "Creation of Views for Reuse of Software with Different Data Representations," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 21, no. 12, </volume> <pages> pp. 993-1005, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: A program MKV ("make view") <ref> [54] </ref> allows a user to specify mathematical views graphically by connecting corresponding parts of the concrete type and a diagram associated with the abstract type; MKV uses symbolic algebra to derive view procedures from the correspondences. For wider reuse, the storage and independence properties must be relaxed slightly. <p> A procedure can be defined in the view type to accomplish assignment to a basis variable while maintaining the storage and independence properties. MKV <ref> [54] </ref> produces such procedures automatically. A view can define a procedure to create an instance of the concrete type from a set of basis variables of the abstract type [54]. This is needed for generics that create new data, e.g. when two vectors are added to produce a new vector. <p> MKV <ref> [54] </ref> produces such procedures automatically. A view can define a procedure to create an instance of the concrete type from a set of basis variables of the abstract type [54]. This is needed for generics that create new data, e.g. when two vectors are added to produce a new vector. Several points about views are worth noting: 1. <p> We assume that the user understands the concrete type and understands the abstract types well enough to make the choices presented. VIEWAS is intended for views of data structures; a companion program MKV <ref> [54] </ref> uses a graphical interface and algebraic manipulation of equations to make mathematical views. We have also investigated creation of programs from connections of diagrams that represent physical and mathematical models [51]. 19 6 Higher-order Code 6.1 Compound Structures Abstract types may be used in larger structures.
Reference: [55] <author> L. C. Paulson,, </author> <title> ML for the Working Programmer, </title> <publisher> Cambridge U. Press, </publisher> <year> 1991. </year>
Reference-contexts: Our declarations are also complex, but VIEWAS hides this complexity and guides the user in creating correct views. The ideas in VIEWAS might be adapted for other languages. 8.4 Functional and Set Languages ML [74] <ref> [55] </ref> is like a strongly typed Lisp; it includes polymorphic functions (e.g., functions that operate on lists of an arbitrary type) and functors (functions that map structures of types and functions to structures). ML also includes references (pointers) that allow imperative programming.
Reference: [56] <author> F. Preparata and R. Yeh, </author> <title> Introduction to Discrete Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Goguen [18] [19] describes views as isomorphisms, with mappings of unary and binary operators. Our views allow broader mappings between concrete and abstract types and include algorithms as well as operators. We use isomorphism to introduce the use of views. Preparata and Yeh <ref> [56] </ref> give a definition and diagram for isomorphism of semigroups: Given two semigroups G 1 = [S; ffi] and G 2 = [T; fl], an invertible function ' : S ! T is said to be an isomorphism between G 1 and G 2 if, for every a and b in
Reference: [57] <author> F. Preparata and M. Shamos, </author> <title> Computational Geometry, </title> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: Fig. 13 illustrates execution of a generic convex hull algorithm. We describe the algorithm 23 and illustrate its use on cities viewed as points. The algorithm uses several views of the same data and reuses other generics; it is similar to the QUICKHULL algorithms <ref> [57] </ref>. A convex hull is represented as a circularly linked list of vertex points in clockwise order (Fig. 14). An edge is formed by a vertex and its successor.
Reference: [58] <author> J. M. Purtilo and J. M. Atlee, </author> <title> "Module Reuse by Interface Adaptation," </title> <journal> Software Practice and Experience, </journal> <volume> vol. 21, no. 6, </volume> <pages> pp. 539-556, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The ARPA Knowledge-Sharing Project [45] addresses the problem of sharing knowledge bases that were developed using different ontologies. Purtilo and Atlee <ref> [58] </ref> describe a system that translates calling sequences by producing small interface modules that reorder and translate parameters as necessary for the called procedure.
Reference: [59] <author> C. Rich, </author> <title> "A Formal Representation for Plans in the Programmer's Apprentice," </title> <booktitle> 7th Intl. Joint Conf. Artificial Intelligence (IJCAI-81), </booktitle> <pages> pp. 1044-1052, </pages> <year> 1981. </year>
Reference-contexts: We assume that the user will treat the outputs of our system as "black boxes" and will not need to read or modify the code. Rich <ref> [59] </ref> describes a plan calculus for representing program and data abstractions; overlays relate program and data plans, analogous to our views. Weide [73] proposed a software components industry based on formally specified and unchangeable components.
Reference: [60] <editor> C. Rich and R. Waters (eds), </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering, </booktitle> <address> San Francisco: </address> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], [39], and <ref> [60] </ref>. Mili [41] extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice [61] was based on reuse of cliches, somewhat analogous to our generics. This project produced some good ideas but had limited success.
Reference: [61] <author> C. Rich and R. Waters, </author> <title> The Programmer's Apprentice, </title> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Reuse of the generic procedure for an application has a high payoff: the generated code is much larger and more complex than the few lines that are entered to create the views. 6.7 Testing and Verification Users must have confidence that reused programs will behave as intended. Programmer's Apprentice <ref> [61] </ref> produced Ada code; the user would read this code and modify it as necessary. We do not believe a programmer should read the output of any reuse system. <p> Biggerstaff and Perlis [8] contains papers on theory and applications of reuse; artificial intelligence approaches are described in [1], [39], and [60]. Mili [41] extensively surveys software reuse, emphasizing technical challenges. 8.2 Software Components The Programmer's Apprentice <ref> [61] </ref> was based on reuse of cliches, somewhat analogous to our generics. This project produced some good ideas but had limited success.
Reference: [62] <author> M. Schaefer, </author> <title> A Mathematical Theory of Global Program Optimization, </title> <publisher> Prentice-Hall, </publisher> <year> 1973. </year>
Reference-contexts: Recursive expansion allows a small amount of source code to expand into large output code; it allows generic procedures to use other generics as subroutines and allows higher-order procedures to be expanded through several levels of abstraction until operations on data are reached. Symbolic optimization folds operations on constants <ref> [62] </ref>, performs partial evaluation [7] [12] and mathematical optimization, removes dead code, and combines operations to improve efficiency. It provides conditional compilation, since a conditional is eliminated when the 8 test can be evaluated at compile time.
Reference: [63] <author> E. Schonberg, J. T. Schwartz, and M. Sharir, </author> <title> "An Automatic Technique for Selection of Data Representations in SETL Programs," </title> <journal> ACM Trans. on Prog. Lang. and Systems, </journal> <volume> vol. 3, no. </volume> <pages> 2 pp. 126-143, </pages> <month> Apr. </month> <year> 1981. </year>
Reference-contexts: Alphard [66] and CLU [38] allow iterators for concrete types; Interlisp [30] provided a flexible looping construct for Lisp lists. SETL [14] provides sets and maps and compiles loops over them, with implementations chosen by the compiler <ref> [63] </ref>. Generic procedures need loops that are independent of data structure (e.g., array, linked list, or tree); this is done by loop macros. Expansion of generic procedures obeys strict hierarchy and involves independent name spaces. <p> Our system allows storing into a data structure through a view and composition of views [52]. Miranda [71] is a strongly-typed functional language with higher-order functions. While this allows generics, it is often hard to write functional programs with good performance. SETL [14] provides sets and set operations. <ref> [63] </ref> describes an attempt to automatically choose data structures in SETL to improve efficiency.
Reference: [64] <author> R. Sedgewick, </author> <title> Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Kant [32] studied highly qualified human subjects who wrote algorithms for this task. All subjects took considerable time; some failed or produced an inefficient solution. Although convex hull algorithms are described in textbooks <ref> [64] </ref> and in the literature, getting an algorithm from such sources is difficult: it is necessary to understand the algorithm, and a published description may omit details of the algorithm or even contain errors [22]. A hand-coded version of a published algorithm requires testing or verification. <p> The component itself might be in error. 2. The component might be used improperly. 3. The specialization of a component might not be correct. Algorithms that are reused justify careful development and are tested in many applications, so unnoticed errors are unlikely. Humans introduce errors in coding algorithms; Sedgewick <ref> [64] </ref> notes "Quicksort ... is fragile: a simple mistake in the implementation can go unnoticed and can cause it to perform badly for some files." Reuse of carefully developed generics is likely to produce better programs than hand coding. VIEWAS and MKV guide the user by presenting only correct choices.
Reference: [65] <author> D. Setliff, </author> <title> "On the Automatic Selection of Data Structures and Algorithms," </title> <booktitle> in [39], </booktitle> <pages> pp. 207-226. </pages>
Reference-contexts: Sinapse transforms a small specification into a much larger program in Fortran or C; it is written using Mathematica [75] and appears to work 31 well within its domain. Setliff's Elf system <ref> [65] </ref> automatically generates data structures and algorithms for wire routing on integrated circuits and printed circuit boards. Rules are used to select refinement transformations based on characteristics of the routing task. KIDS [68] transforms problem statements in first-order logic into programs that are highly efficient for certain combinatorial problems.
Reference: [66] <author> M. Shaw, W. Wulf, and R. </author> <title> London, "Abstraction and Verification in Alphard: Defining and Specifying Iterators and Generators," </title> <journal> Comm. ACM, </journal> <volume> vol. 20, no. 9, </volume> <pages> pp. 553-564, </pages> <month> Aug. </month> <year> 1977. </year>
Reference-contexts: A single definition of a generic covers the combinatoric set of component types. 6.2 Generic Loop Macros A language with abstract types must provide loops over collections of data. Alphard <ref> [66] </ref> and CLU [38] allow iterators for concrete types; Interlisp [30] provided a flexible looping construct for Lisp lists. SETL [14] provides sets and maps and compiles loops over them, with implementations chosen by the compiler [63].
Reference: [67] <author> C. Simonyi, </author> <title> "Intentional Programming Innovation in the Legacy Age," </title> <booktitle> Presented at IFIP WG 2.1 meeting, </booktitle> <month> June 4, </month> <year> 1996. </year> <note> See http://www.research.microsoft.com/research/ip/main.htm </note>
Reference-contexts: The ability to specify individual transformations in Gries' system gives more flexibility, possibly at the cost of writing more patterns. The Intentional Programming project at Microsoft <ref> [67] </ref> is based on intentions, which are similar to algorithm fragments expressed as abstract syntax trees. Intentions can be transformed by enzymes at the abstract syntax tree level and can be parsed and unparsed into various surface syntaxes by methods stored with or inherited by the intentions.
Reference: [68] <author> D. R. Smith, "KIDS: </author> <title> A Semiautomatic Program Development System," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 9, </volume> <pages> pp. 1024-1043, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Smith <ref> [68] </ref> uses the term theory morphism for a similar notion. <p> Setliff's Elf system [65] automatically generates data structures and algorithms for wire routing on integrated circuits and printed circuit boards. Rules are used to select refinement transformations based on characteristics of the routing task. KIDS <ref> [68] </ref> transforms problem statements in first-order logic into programs that are highly efficient for certain combinatorial problems. The user must select transformations to be used and must supply a formal domain theory for the application. This system is interesting and powerful, but its user must be mathematically sophisticated.
Reference: [69] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: The use of layers whose interfaces are carefully specified allows the developer to ensure that the layers will interface correctly. We have focused on adapting interfaces so that generics can be reused for independently designed data. 8.3 Languages with Generic Procedures Ada, Modula-2 [28], and C++ <ref> [69] </ref> allow modules for parameterized abstract types such as ST ACK [type]. Books of generic procedures [37] [44] contain some of the same procedures that are provided with our system. <p> In Ada and Modula-2, such collections have limited value because such code is easy to write and is only a small part of most applications. The class, template, and virtual function features of C++ allow reuse of generics; however, Stroustrup's examples <ref> [69] </ref> show that the declarations required are complex and subtle. Our declarations are also complex, but VIEWAS hides this complexity and guides the user in creating correct views. <p> Our views provide encapsulation that prevents name conflicts; views allow the reuse benefits of OOP with flexibility in implementing data. 33 Some OOP systems are inefficient: since most methods are small, message interpreta-tion overhead can be large, especially in layered systems. C++ <ref> [69] </ref> has restricted OOP with efficient method dispatching. Opacity of objects prevents optimization across message boundaries unless messages are compiled in-line; C++ allows in-line compilation.
Reference: [70] <author> W. Tracz, "LILEANNA: </author> <title> A parameterized programming language," </title> <booktitle> 2nd Int'l Workshop on Software Reuse (IWSR-2), </booktitle> <publisher> IEEE CS Press, </publisher> <year> 1993, </year> <pages> pp. 66-78. </pages>
Reference-contexts: This proposal has much in common with our approach, and Goguen uses the term view similarly; LIL has a stronger focus on mathematical descriptions and axioms. The OBJ language family of Goguen et al. [19] has views that are formal type mappings; operators are mapped by strict isomorphisms. Tracz <ref> [70] </ref> describes LILEANNA, which implements LIL for construction of Ada packages; views in LILEANNA map types, operations, and exceptions between theories. In our system, views are computational transformations between types; general procedures as well as operators can be reused.
Reference: [71] <author> D. Turner, </author> <title> "An Overview of Miranda," </title> <journal> SIGPLAN Notices, </journal> <month> Dec. </month> <year> 1986. </year>
Reference-contexts: ML also includes references (pointers) that allow imperative programming. ML functors can instantiate generic modules such as container types. Our system allows storing into a data structure through a view and composition of views [52]. Miranda <ref> [71] </ref> is a strongly-typed functional language with higher-order functions. While this allows generics, it is often hard to write functional programs with good performance. SETL [14] provides sets and set operations. [63] describes an attempt to automatically choose data structures in SETL to improve efficiency.
Reference: [72] <author> D. Volpano. and R. Kieburtz, </author> <title> "The Templates Approach to Software Reuse," </title> <booktitle> in [8], </booktitle> <pages> pp. 247-255. </pages>
Reference-contexts: The user must select transformations to be used and must supply a formal domain theory for the application. This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins [21] proposed use of syntactic transformations to specify implementation of abstract algorithms. Volpano <ref> [72] </ref> and Gries [23] describe systems in which a user specifies transformations for variables, expression patterns, and statement patterns; by performing substitutions on an algorithm, a different version of the algorithm is obtained.
Reference: [73] <author> B. Weide, W. Ogden, and S. </author> <title> Zweben, "Reusable Software Components," </title> <editor> in M. Yovits, ed., </editor> <booktitle> Adv. in Computers, </booktitle> <volume> vol. 33, </volume> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 1-65. </pages>
Reference-contexts: Generics defined for sorted-linked-list explicitly test sort-direction; since this value is constant, only the code for the selected direction is kept. This illustrates that switch values in view types can select optional features of generics. Weide <ref> [73] </ref> notes that options in reusable procedures are essential to avoid a combinatoric set of versions. For example, the Booch component set [9] contains over 500 components; Batory [5] has identified these as combinations of fewer design decisions. <p> We assume that the user will treat the outputs of our system as "black boxes" and will not need to read or modify the code. Rich [59] describes a plan calculus for representing program and data abstractions; overlays relate program and data plans, analogous to our views. Weide <ref> [73] </ref> proposed a software components industry based on formally specified and unchangeable components. Because the components would be verified and unchangeable, errors would be prevented; however, the rigidity of the components might make them harder to reuse. Our approach adapts components to fit the application.
Reference: [74] <author> A. Wikstrom, </author> <title> Functional Programming Using Standard ML, </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Our declarations are also complex, but VIEWAS hides this complexity and guides the user in creating correct views. The ideas in VIEWAS might be adapted for other languages. 8.4 Functional and Set Languages ML <ref> [74] </ref> [55] is like a strongly typed Lisp; it includes polymorphic functions (e.g., functions that operate on lists of an arbitrary type) and functors (functions that map structures of types and functions to structures). ML also includes references (pointers) that allow imperative programming.
Reference: [75] <author> S. Wolfram, </author> <title> Mathematica: a System for Doing Mathematics by Computer, </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Our views specify transformations from features of abstract types to their implementations. Kant et al. [33] describe Sinapse, which generates programs to simulate spatial differential equations, e.g. for seismic analysis. Sinapse transforms a small specification into a much larger program in Fortran or C; it is written using Mathematica <ref> [75] </ref> and appears to work 31 well within its domain. Setliff's Elf system [65] automatically generates data structures and algorithms for wire routing on integrated circuits and printed circuit boards. Rules are used to select refinement transformations based on characteristics of the routing task.
Reference: [76] <author> D. M. Yellin and R. E. Strom, </author> <title> "Interfaces, Protocols, and the SemiAutomatic Construction of Software Adaptors," </title> <journal> Proc. OOPSLA-94, ACM SIGPLAN Notices, </journal> <volume> vol. 29, no. 10, </volume> <pages> pp. 176-190, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Guttag and Horning [24] describe a formal language for specifying procedure interface signatures and properties. Yellin and Strom <ref> [76] </ref> describe semi-automatic synthesis of protocol converters to allow interfacing of clients and servers. 8.8 Object-oriented Programming We have described how views can be used to generate methods for OOP.
Reference: [77] <author> A. M. Zaremski and J. M. Wing, </author> <title> "Signature Matching: A Key to Reuse," </title> <journal> ACM Software Engineering Notes, </journal> <volume> vol. 18, no. 5, </volume> <pages> pp. 182-190, </pages> <month> Dec. </month> <year> 1993. </year> <month> 39 </month>
Reference-contexts: Weide [73] proposed a software components industry based on formally specified and unchangeable components. Because the components would be verified and unchangeable, errors would be prevented; however, the rigidity of the components might make them harder to reuse. Our approach adapts components to fit the application. Zaremski and Wing <ref> [77] </ref> describe retrieval of reusable ML components based on signature matching of functions and modules; related techniques could be used with our generics. 30 Batory [4] [5] [6] describes a data structure precompiler and construction of software systems from layers of plug-compatible components with standardized interfaces.
References-found: 76

