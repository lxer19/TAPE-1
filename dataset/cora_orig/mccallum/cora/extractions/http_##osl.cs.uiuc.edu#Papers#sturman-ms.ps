URL: http://osl.cs.uiuc.edu/Papers/sturman-ms.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/sturman/
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by Daniel Charles Sturman 
Date: 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Acceta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Developement. </title> <booktitle> In USENIX 1986 Summer Conference Proceedings, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: For example, check-pointing may be composed with replication without having either protocol know about the other. Non-reflective systems which support customization do so only in a system-wide manner. For example, customization in a micro-kernel based system <ref> [1] </ref> affects all the objects collectively. In an object-oriented system such as Choices [6], frameworks may be customized for a particular application. However, once customized, the characteristics may not change dynamically. Reflection in an object-based system allows customization of the underlying system independently for each object. <p> to 1) if (m.get src () = members [i]) /* Since the message was from a replica, * we know that the first argument is a tag and * the second is the original message. */ /* Discard message */ return; else if (m [0] = tag) f self.enqueue (m <ref> [1] </ref>); tag := tag + 1; g message of the server is tagged to allow the elimination of duplicate replies by the client. A mail queue at the client performs this duplicate elimination. The code for this mail queue is shown in Figure 2.3. <p> To implement exception 28 foo (int x) f int y; w := x + y + z; g cont meth 1 (int ret) f var int x; x = state [0]; y = state <ref> [1] </ref>; w := x + y + z; foo (int x) f int y; A.boo (self, cont meth 1,x,y); state [0] = x; state [1] = y; g handling for Screed, it was necessary to construct the appropriate system library actors as well as generate the correct code for handle and <p> int y; w := x + y + z; g cont meth 1 (int ret) f var int x; x = state [0]; y = state <ref> [1] </ref>; w := x + y + z; foo (int x) f int y; A.boo (self, cont meth 1,x,y); state [0] = x; state [1] = y; g handling for Screed, it was necessary to construct the appropriate system library actors as well as generate the correct code for handle and signal statements. 4.3.1 Explicit Continuations An explicit continuation is specified as a message send with an additional parameter list for return values. <p> Each element of v used as a parameter should be typechecked and converted to the correct type. Using the appropriate ValtoTYPE 38 void Database::lookup (Method& m, Array &v, int params) f if (m == query n && params == 3) query (ValToInteger (v [0]), ValToAddress (v <ref> [1] </ref>), ValToMethod (v [2])); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g <p> Using the appropriate ValtoTYPE 38 void Database::lookup (Method& m, Array &v, int params) f if (m == query n && params == 3) query (ValToInteger (v [0]), ValToAddress (v <ref> [1] </ref>), ValToMethod (v [2])); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A sample lookup function. function guarantees a correct conversion, as mentioned in Section A.1. <p> 3) query (ValToInteger (v [0]), ValToAddress (v <ref> [1] </ref>), ValToMethod (v [2])); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A sample lookup function. function guarantees a correct conversion, as mentioned in Section A.1. A lookup function for a database actor is shown in figure A.1. Interface to the Dmon is provided through routines inherited from AClass .
Reference: [2] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: We then briefly discuss some of the advantages of object-oriented programming and how they are important to our methods. Finally, we give a more in-depth discussion of reflection and how it relates to a programming language. 1.3.1 The Actor Model We illustrate our approach using the Actor model <ref> [2, 3] </ref>. It is important to note that the idea of using reflection to describe dependability is not tied to any specific language framework. <p> Forwarding messages to the backup server is implemented using a meta-level mail queue. The Screed code for this mail queue is presented in Figure 2.2. Using a dispatcher, each reply 10 class Eliminator : Mailq f var actor members <ref> [2] </ref>; actor client; /* No get method is required since we use * the default behavior inherited from Mailq */ put (msg m) f for (i := 0 to 1) if (m.get src () = members [i]) /* Since the message was from a replica, * we know that the first <p> Each element of v used as a parameter should be typechecked and converted to the correct type. Using the appropriate ValtoTYPE 38 void Database::lookup (Method& m, Array &v, int params) f if (m == query n && params == 3) query (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v <ref> [2] </ref>)); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A <p> appropriate ValtoTYPE 38 void Database::lookup (Method& m, Array &v, int params) f if (m == query n && params == 3) query (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v <ref> [2] </ref>)); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A sample lookup function. function guarantees a correct conversion, as mentioned in Section A.1. <p> (v [0]), ValToAddress (v [1]), ValToMethod (v <ref> [2] </ref>)); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v [3])); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A sample lookup function. function guarantees a correct conversion, as mentioned in Section A.1. A lookup function for a database actor is shown in figure A.1. Interface to the Dmon is provided through routines inherited from AClass . There are five such routines.
Reference: [3] <author> G. Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We then briefly discuss some of the advantages of object-oriented programming and how they are important to our methods. Finally, we give a more in-depth discussion of reflection and how it relates to a programming language. 1.3.1 The Actor Model We illustrate our approach using the Actor model <ref> [2, 3] </ref>. It is important to note that the idea of using reflection to describe dependability is not tied to any specific language framework. <p> void Database::lookup (Method& m, Array &v, int params) f if (m == query n && params == 3) query (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else if (m == update n && params == 4) update (ValToInteger (v [0]), ValToInteger (v [1]), ValToAddress (v [2]), ValToMethod (v <ref> [3] </ref>)); else if (m == read n && params == 3) read (ValToInteger (v [0]), ValToAddress (v [1]), ValToMethod (v [2])); else AClass::lookup (m,v,params); g Figure A.1: A sample lookup function. function guarantees a correct conversion, as mentioned in Section A.1.
Reference: [4] <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A Linguistic Framework for the Dynamic Composition of DependabilityProtocols. </title> <editor> In C.E. Landwehr, B. Randell, and L. Simoncini, editors, </editor> <title> Dependable Computing for Critical Applications 3, </title> <booktitle> volume 8 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 345-363. </pages> <publisher> IFIP Transactions, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Greater or fewer restrictions may be imposed on the meta-level depending on the dependability and security requirements that a given application must meet. 7 Chapter 2 Meta-level Architecture for Ultra-dependability In this chapter we introduce maud (Meta-level Architecture for Ultra Dependability) <ref> [4] </ref>. maud supports the development of reusable dependability protocols. These protocols may then be installed during the execution of an application. maud has been implemented on Broadway, our run-time environment for actors. We begin with a discussion of maud's structure.
Reference: [5] <author> K. P. Birman and T. A. Joseph. </author> <title> Communication Support for Reliable Distributed Computing. In Fault-tolerant Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In Argus [20], Avalon [13] and Arjuna [28], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time. The focus in [24], [7] and <ref> [5] </ref> is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from the application specific code. In [33] and [25], replication can be described separate from the service being replicated.
Reference: [6] <author> Roy Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing amd Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: For example, check-pointing may be composed with replication without having either protocol know about the other. Non-reflective systems which support customization do so only in a system-wide manner. For example, customization in a micro-kernel based system [1] affects all the objects collectively. In an object-oriented system such as Choices <ref> [6] </ref>, frameworks may be customized for a particular application. However, once customized, the characteristics may not change dynamically. Reflection in an object-based system allows customization of the underlying system independently for each object.
Reference: [7] <author> E. Cooper. </author> <title> Programming Language Support for Multicast Communication in Distributed Systems. </title> <booktitle> In Tenth International Conference on Distributed Computer Systems, </booktitle> <year> 1990. </year>
Reference-contexts: In Argus [20], Avalon [13] and Arjuna [28], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time. The focus in [24], <ref> [7] </ref> and [5] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from the application specific code. In [33] and [25], replication can be described separate from the service being replicated.
Reference: [8] <author> Antonio Corradi, Paola Mello, and Antonio Natali. </author> <title> Error Recovery Mechanisms for Remote Procedure Call-Based Systems. </title> <booktitle> In 8th Annual International Phoenix Conference on Computers and Communicaton Conference Proceedings, </booktitle> <pages> pages 502-507, </pages> <address> Phoenix, Arizona, March 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Therefore, on generating the signal, this parameter list must provide all possible information used by the handler. For concurrent systems, an approach has been proposed for languages which use RPC communication <ref> [8] </ref>. However, the technique is based on synchronized components which allows their constructions to be closer to that of a sequential system than an asynchronous system. Exception handling mechanisms have been proposed for other Actor languages.
Reference: [9] <author> F. Cristain. </author> <title> Understanding Fault-tolerant Distributed Systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <year> 1991. </year>
Reference-contexts: Introduction 1.1 Introduction The failure semantics of a service refers to the set whose elements are the different ways in which a service can fail <ref> [9] </ref>. This set serves as a contract with clients who use the service: failure semantics for a client are often dependent on the failure semantics of the services used. Therefore, an incorrect specification of the failure semantics of one service can lead to a chain of incorrect failure semantics.
Reference: [10] <author> Quian Cui and John Gannon. </author> <title> Data-Oriented Exception Handling in Ada. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18 </volume> <pages> 98-106, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Goodenough introduced the idea of exceptions and exception handling in [17]. Since then, many different exception handling mechanisms have been proposed. Exception handling constructs have been developed for object-based languages such as Clu [21] and Ada <ref> [10] </ref>. Dony [11] describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in [12]. <p> Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in [12]. A critical difference between object-oriented approaches to exception handling and non-object-oriented approaches such as CLU [21] or Ada <ref> [10] </ref> is that, in the non-object-oriented approaches, the exception object is represented by a set of parameters to a function. Therefore, on generating the signal, this parameter list must provide all possible information used by the handler. <p> In languages such as CLU [21], SR [18], and Ada <ref> [10] </ref>, exception handling routines are defined within the scope of the invoking objects. We refer to this approach as two-party exception handling (the invoker and the signaler) and our approach as three-party exception handling (the invoker, the signaler and an independent handler).
Reference: [11] <author> Christophe Dony. </author> <title> Improving Exception Handling with Object-Oriented Programming. </title> <booktitle> In Proceedings of the 14th Annual International Computer Software and Applications Conference, </booktitle> <pages> pages 36-42, </pages> <address> Chicago, </address> <year> 1990. </year> <journal> IEEE Computer Society, IEEE. </journal> <volume> 51 </volume>
Reference-contexts: Goodenough introduced the idea of exceptions and exception handling in [17]. Since then, many different exception handling mechanisms have been proposed. Exception handling constructs have been developed for object-based languages such as Clu [21] and Ada [10]. Dony <ref> [11] </ref> describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in [12]. <p> An exception may be signaled either by the run-time system or by the application. The former are referred to as system exceptions and the latter as user-defined exceptions. Exceptions in Screed are represented as objects, as proposed in <ref> [11] </ref> for sequential object-oriented languages. None of the other concurrent languages discussed in Section 1.2 have taken this approach. However, we feel this approach allows for more flexible and efficient exception handling: all the information needed by a handler is contained in one object.
Reference: [12] <author> Christophe Dony, Jan Purchase, and Russel Winder. </author> <title> Exception Handling in Object--Oriented Systems. </title> <journal> OOPS Messanger, </journal> <volume> 3(2) </volume> <pages> 17-29, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Dony [11] describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in <ref> [12] </ref>. A critical difference between object-oriented approaches to exception handling and non-object-oriented approaches such as CLU [21] or Ada [10] is that, in the non-object-oriented approaches, the exception object is represented by a set of parameters to a function.
Reference: [13] <author> Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors. CAMELOT AND AVALON: A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The appendices provide a more detailed description Broadway and Screed. Appendix A provides the Broadway User's Manual and Appendix B is the Screed Programmer's Guide. 1.2 Related Work A number of languages and systems offer support for constructing fault-tolerant systems. In Argus [20], Avalon <ref> [13] </ref> and Arjuna [28], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time.
Reference: [14] <author> Jacques Ferber and Jean-Pierre Briot. </author> <booktitle> Design of a Concurrent Language for Distributed Artificial Intelligence. In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 755-762. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: Reflection has been used in the Muse Operating System [34] for dynamically modifying the system behavior. However, the literature is unclear as to the effect on efficiency of this generally reflective system. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in <ref> [14] </ref> and [31], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [15] <author> S. Frtlund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> ECOOP'92 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 185-196. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year> <note> Lecture Notes in Computer Science 615. </note>
Reference-contexts: If the mail queue has no appropriate message to pass onto its base object, it must record that a get message was received: no further get messages will be sent by the Dmon until the base actor processes another message. Once synchronization constraints are implemented in Broadway <ref> [15] </ref>, a constraint would prevent the delivery of a get message until the meta-level mail queue is prepared for the message (i.e. has messages to deliver). <p> In the case of state-variables, these values may have changed even more due to other pending messages which the actor processes before the continuation. With the eventual introduction of synchronization constraints <ref> [15] </ref> to the language, the programmer will be better able to specify which methods may execute before completion of the continuation. The implementation of explicit continuations was fairly straight forward. The continuation body itself is converted into a new method.
Reference: [16] <author> S. Frtlund and G. Agha. </author> <title> A Language Framework for Multi-Object Coordination. </title> <booktitle> In Proceedings of ECOOP 1993. </booktitle> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1993. </year> <note> LNCS 627. </note>
Reference-contexts: Different protocols may have different rules for defining consistent installation. The best tool for coordinating such operations is a multi-object constraint. Specifically, synchronizers <ref> [16] </ref> may be used to specify customized constraints for each protocol or even a subset of objects in each protocol. Synchronizers are expressed in terms of events at the coordinated objects. These events may be restricted in several different ways including mutual exclusion, atomicity, or triggering.
Reference: [17] <author> John B. Goodenough. </author> <title> Exception Handling: Issues and a Proposed Notation. </title> <journal> Communications of the ACM, </journal> <volume> 18(12) </volume> <pages> 683-696, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: In these papers, detected failures are considered asynchronous events much as exceptional conditions are treated in distributed programming languages. Therefore, exception handling constructs provide a natural way to incorporate failure-response code into an application. Goodenough introduced the idea of exceptions and exception handling in <ref> [17] </ref>. Since then, many different exception handling mechanisms have been proposed. Exception handling constructs have been developed for object-based languages such as Clu [21] and Ada [10]. Dony [11] describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects.
Reference: [18] <author> Daniel T. Huang and Ronald A. Olsson. </author> <title> An Exception Handling Mechanism for SR. </title> <journal> Computer Languages, </journal> <volume> 15(3) </volume> <pages> 163-176, </pages> <year> 1990. </year>
Reference-contexts: In Screed, such a construct in not necessary: the actor can explicitly send a message to the appropriate exception handler. 3.3 Supporting Adaptive Dependability A significant difference between exception handling in Screed and other languages is the use of third-party exception handlers. In languages such as CLU [21], SR <ref> [18] </ref>, and Ada [10], exception handling routines are defined within the scope of the invoking objects. We refer to this approach as two-party exception handling (the invoker and the signaler) and our approach as three-party exception handling (the invoker, the signaler and an independent handler).
Reference: [19] <author> Yuuji Ichisugi and Akinori Yonezawa. </author> <title> Exception Handling and Real Time Features in an Object-Oriented Concurrent Language. </title> <editor> In A. Yonezawa and T. Ito, editors, Concur-rency: </editor> <booktitle> Theory, Language, and Architecture, </booktitle> <pages> pages 92-109. </pages> <publisher> Springer-Verlag, Oxford, </publisher> <address> UK, </address> <month> September </month> <year> 1989. </year> <note> LNCS 491. </note>
Reference-contexts: However, the technique is based on synchronized components which allows their constructions to be closer to that of a sequential system than an asynchronous system. Exception handling mechanisms have been proposed for other Actor languages. In <ref> [19] </ref>, an exception handling mechanism was proposed for ABCL/1 and for Acore in [23]. These languages use complaint addresses to support exception handling. A complaint address is an address, specified with each message, to which all signals are dispatched.
Reference: [20] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: The appendices provide a more detailed description Broadway and Screed. Appendix A provides the Broadway User's Manual and Appendix B is the Screed Programmer's Guide. 1.2 Related Work A number of languages and systems offer support for constructing fault-tolerant systems. In Argus <ref> [20] </ref>, Avalon [13] and Arjuna [28], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time.
Reference: [21] <author> Barbara Liskov and Alan Snyder. </author> <title> Exception Handling in Clu. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(6) </volume> <pages> 546-558, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: Therefore, exception handling constructs provide a natural way to incorporate failure-response code into an application. Goodenough introduced the idea of exceptions and exception handling in [17]. Since then, many different exception handling mechanisms have been proposed. Exception handling constructs have been developed for object-based languages such as Clu <ref> [21] </ref> and Ada [10]. Dony [11] describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in [12]. <p> This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in [30]. A good overview of techniques proposed for other object-oriented languages can be found in [12]. A critical difference between object-oriented approaches to exception handling and non-object-oriented approaches such as CLU <ref> [21] </ref> or Ada [10] is that, in the non-object-oriented approaches, the exception object is represented by a set of parameters to a function. Therefore, on generating the signal, this parameter list must provide all possible information used by the handler. <p> In other systems, a special construct exists for generating signals within the current context, i.e. generate a signal which is caught by the handle statement in whose scope the statement occurs. An example of such a construct would be the exit statement in Clu <ref> [21] </ref>. In Screed, such a construct in not necessary: the actor can explicitly send a message to the appropriate exception handler. 3.3 Supporting Adaptive Dependability A significant difference between exception handling in Screed and other languages is the use of third-party exception handlers. In languages such as CLU [21], SR [18], <p> in Clu <ref> [21] </ref>. In Screed, such a construct in not necessary: the actor can explicitly send a message to the appropriate exception handler. 3.3 Supporting Adaptive Dependability A significant difference between exception handling in Screed and other languages is the use of third-party exception handlers. In languages such as CLU [21], SR [18], and Ada [10], exception handling routines are defined within the scope of the invoking objects. We refer to this approach as two-party exception handling (the invoker and the signaler) and our approach as three-party exception handling (the invoker, the signaler and an independent handler).
Reference: [22] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> Technical Report 87-2, </type> <institution> Artificial Intelligence Laboratory, Vrije University, </institution> <year> 1987. </year>
Reference-contexts: In this way, a component's implementation may change without affecting other components. Code may also be reused efficiently since components share code by inheriting from a common ancestor class. 1.3.3 Reflection Reflection means that a system can manipulate a causally connected description of itself <ref> [29, 22] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. In a reflective system, a change in these descriptions or meta-objects results in a change in how objects are implemented.
Reference: [23] <author> Carl Manning. ACORE: </author> <title> The Design of a Core Actor Language and its Compiler. </title> <type> Master's thesis, </type> <institution> MIT, Artificial Intelligence Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: However, the technique is based on synchronized components which allows their constructions to be closer to that of a sequential system than an asynchronous system. Exception handling mechanisms have been proposed for other Actor languages. In [19], an exception handling mechanism was proposed for ABCL/1 and for Acore in <ref> [23] </ref>. These languages use complaint addresses to support exception handling. A complaint address is an address, specified with each message, to which all signals are dispatched. Complaint address-based schemes 4 do not allow for different handlers to be bound to different exceptions: all complaints are sent to the same destination.
Reference: [24] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> Technical report, </type> <institution> University of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: In Argus [20], Avalon [13] and Arjuna [28], the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time. The focus in <ref> [24] </ref>, [7] and [5] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from the application specific code. In [33] and [25], replication can be described separate from the service being replicated.
Reference: [25] <author> M. H. Olsen, E. Oskiewicz, and J. P. Warne. </author> <title> A Model for Interface Groups. </title> <booktitle> In Tenth Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <year> 1991. </year> <month> 52 </month>
Reference-contexts: The focus in [24], [7] and [5] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from the application specific code. In [33] and <ref> [25] </ref>, replication can be described separate from the service being replicated. Our approach is more flexible since fault-tolerance schemes are not only described separately but they can also be attached and detached dynamically.
Reference: [26] <author> Richard D. Schlichting, Falviu Christian, and Titus D. M. Purdin. </author> <title> A Linguistic Approach to Failure Handling in Distributed Systems. </title> <editor> In A. Avizienis and J.C. Laprie, editors, </editor> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 387-409. </pages> <publisher> IFIP, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: is described in terms of three components: a container, which represents the acquaintances and script; a processor, which acts as the scheduler for the actor; and a mailbox, which handles message reception The concept of unifying exception handling and fault detection was originally proposed in [27] and then refined in <ref> [26] </ref>. In these papers, detected failures are considered asynchronous events much as exceptional conditions are treated in distributed programming languages. Therefore, exception handling constructs provide a natural way to incorporate failure-response code into an application. Goodenough introduced the idea of exceptions and exception handling in [17].
Reference: [27] <author> Richard D. Schlichting and Titus D. M. Purdin. </author> <title> Failure Handling in Distributed Programming Languages. </title> <booktitle> In Proceedings: Fifth Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 59-66, </pages> <address> Los Angeles, CA, January 1986. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In Rosette, the meta-level is described in terms of three components: a container, which represents the acquaintances and script; a processor, which acts as the scheduler for the actor; and a mailbox, which handles message reception The concept of unifying exception handling and fault detection was originally proposed in <ref> [27] </ref> and then refined in [26]. In these papers, detected failures are considered asynchronous events much as exceptional conditions are treated in distributed programming languages. Therefore, exception handling constructs provide a natural way to incorporate failure-response code into an application.
Reference: [28] <author> Santosh Shrivastava, Graeme Dixon, and Graham Parrington. </author> <title> An Overview of the Arjuna Distributed Programming System. </title> <journal> IEEE Software, </journal> <pages> pages 66-73, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The appendices provide a more detailed description Broadway and Screed. Appendix A provides the Broadway User's Manual and Appendix B is the Screed Programmer's Guide. 1.2 Related Work A number of languages and systems offer support for constructing fault-tolerant systems. In Argus [20], Avalon [13] and Arjuna <ref> [28] </ref>, the concept of nested transactions is used to structure distributed systems. Consistency and resilience is ensured by atomic actions whose effect are check-pointed at commit time. The focus in [24], [7] and [5] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems.
Reference: [29] <author> B. C. Smith. </author> <title> Reflection and semantics in a procedural language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year>
Reference-contexts: In this way, a component's implementation may change without affecting other components. Code may also be reused efficiently since components share code by inheriting from a common ancestor class. 1.3.3 Reflection Reflection means that a system can manipulate a causally connected description of itself <ref> [29, 22] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. In a reflective system, a change in these descriptions or meta-objects results in a change in how objects are implemented.
Reference: [30] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: Exception handling constructs have been developed for object-based languages such as Clu [21] and Ada [10]. Dony [11] describes an approach for object-oriented languages which was implemented in Smalltalk. This was the first approach that implemented exceptions as objects. Exception handling for C++ is discussed in <ref> [30] </ref>. A good overview of techniques proposed for other object-oriented languages can be found in [12].
Reference: [31] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOP-SLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: Reflection has been used in the Muse Operating System [34] for dynamically modifying the system behavior. However, the literature is unclear as to the effect on efficiency of this generally reflective system. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [14] and <ref> [31] </ref>, respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [32] <author> T. Watanabe and A. Yonezawa. </author> <title> A Actor-Based Metalevel Arhitecture for Group-Wide Reflection. </title> <editor> In J. W. deBakker, W. P. deRoever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 405-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS 489. </note>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [35]. A reflective implementation of object migration is reported in <ref> [32] </ref>. Reflection has been used in the Muse Operating System [34] for dynamically modifying the system behavior. However, the literature is unclear as to the effect on efficiency of this generally reflective system.
Reference: [33] <author> C. T. Wilkes and R. J. LeBlanc. </author> <title> Distributed Locking: A Mechanism for Constructing Highly Available Objects. </title> <booktitle> In Seventh Symposium on Reliable Distributed Systems, </booktitle> <institution> Ohio State University, Columbus, Ohio, </institution> <year> 1988. </year>
Reference-contexts: The focus in [24], [7] and [5] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. None of the above systems support the factorization of fault-tolerance characteristics from the application specific code. In <ref> [33] </ref> and [25], replication can be described separate from the service being replicated. Our approach is more flexible since fault-tolerance schemes are not only described separately but they can also be attached and detached dynamically.
Reference: [34] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The Muse Object Architecture: </title>
Reference-contexts: For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [35]. A reflective implementation of object migration is reported in [32]. Reflection has been used in the Muse Operating System <ref> [34] </ref> for dynamically modifying the system behavior. However, the literature is unclear as to the effect on efficiency of this generally reflective system. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [14] and [31], respectively.
References-found: 34

