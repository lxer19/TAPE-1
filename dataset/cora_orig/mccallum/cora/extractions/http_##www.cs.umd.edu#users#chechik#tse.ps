URL: http://www.cs.umd.edu/users/chechik/tse.ps
Refering-URL: http://www.cs.umd.edu/users/chechik/research.html
Root-URL: 
Email: fchechik, gannong@cs.umd.edu  
Title: AUTOMATIC ANALYSIS OF CONSISTENCY BETWEEN REQUIREMENTS AND DESIGNS 1  
Author: Marsha Chechik John Gannon 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: Formal methods can be used to demonstrate that safety properties of embedded systems are enforced by the system's requirements. Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. We have developed a technique for discovering instances of inconsistency and incompleteness in detailed designs of programs with respect to their requirements. We present a language for specifying detailed designs and an analysis tool, called Analyzer, which creates a model of a design through abstract interpretation of the language constructs. The tool also uses requirements information to automatically generate properties which ensure that required state transitions appear in the design, and then determines if these properties are preserved. In addition, Analyzer checks that the design satisfies other user-specified safety properties. This paper presents a description of our implementation of Analyzer and our experience in applying it to a small but realistic problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Section 8 presents the WLMS case study. Finally, in Section 9, we discuss limitations of our approach and compare it with related work. 2 Requirements Notation This section describes the requirements specification format: Software Cost Reduction (SCR) requirements <ref> [2, 15, 17, 18] </ref>. These requirements model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events. <p> Requirements specifications of realistic size and complexity (like <ref> [2] </ref>), however, contain global properties which cannot be expressed using only these assertions. Allowing the user to specify a richer set of properties is relatively easy, although not every CTL-expressible formula can be verified during our analysis.
Reference: [3] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Mary-land, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: This information records relationships between monitored or controlled variables. Relationships help requirements designers eliminate redundant information and increase the clarity of specifications <ref> [3] </ref>. The following is a list of relationships recognized by Analyzer: * An implication (B -&gt; C) is a relationship which indicates that when B is True, C should be True; and when C is False, B should be False.
Reference: [4] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Automated techniques can be used to derive a finite-state representation of a set of tabular requirements, and determine if it is a model for system safety properties expressed as temporal logic assertions <ref> [4] </ref>. We present a complementary technique which automatically compares properties derived from a set of requirements with a finite state representation of its detailed design. 1 This work was supported by the Air Force Office of Scientific Research under contract F49620-93-1-0034. <p> A mode transition table for modeclass Normal is shown in Table 5. Relationships between monitored and controlled variables are shown in Table 6. The requirements included four user-defined safety properties, identical to those used in <ref> [4] </ref>. They are shown in Table 7. If the SelfTest button has been pressed for 500ms or more, the system is either in mode Test or will be in mode Test after its next transition.
Reference: [5] <author> S.H. Caine and E.K. Gordon. </author> <title> "PDL: A Tool for Software Design". </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <volume> volume 44, </volume> <pages> pages 271-276, </pages> <year> 1975. </year>
Reference: [6] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 ISSTA, </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called Analyzer <ref> [6, 7] </ref>, which automatically determines if a design written in PDL is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design written in PDL.
Reference: [7] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called Analyzer <ref> [6, 7] </ref>, which automatically determines if a design written in PDL is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design written in PDL.
Reference: [8] <author> Edmind M. Clarke, Orna Grumberg, and David E. </author> <title> Long. "Model Checking and Abstraction". </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Aspect's [22, 23, 24] specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported. Clarke et al. <ref> [8] </ref> also create abstract, finite state models of programs, and use model checking techniques to verify formulas. Programs written in a special finite-state programming language are translated into relational expressions characterizing the program's initial state and transition relation.
Reference: [9] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year> <month> 30 </month>
Reference: [10] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> "Procedure Cloning". </title> <booktitle> In Proceedings of IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, since designs usually consist of several procedures, we needed to extend our analysis technique to process these designs. We perform interprocedural analysis using an adaptation of a technique called cloning <ref> [10] </ref>. A similar algorithm was described in [34]. This technique enables Analyzer to process designs with cycles in their call graphs (recursion), to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [11] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programmation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable <ref> [11, 12] </ref>. We compute two sets of information for our analysis: reaching values (RVs) and conditions (Conds). The RV of a variable at a node is a set of values that a variable may attain if the control reaches the node. RVs are computed by interpreting Update and Initial annotations.
Reference: [12] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Abstract Interpretation: A Unified Lattice Model For Static Analysis of Programs by Construction or Approximation of Fixpoints". </title> <booktitle> In Proceedings of the 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable <ref> [11, 12] </ref>. We compute two sets of information for our analysis: reaching values (RVs) and conditions (Conds). The RV of a variable at a node is a set of values that a variable may attain if the control reaches the node. RVs are computed by interpreting Update and Initial annotations.
Reference: [13] <author> O. Grumberg and D.E. </author> <title> Long. "Model Checking and Modular Verification". </title> <booktitle> In Proceedings of CONCUR'91: 2nd International Conference on Concurrency Theory, </booktitle> <year> 1991. </year>
Reference: [14] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. "STATEMATE: </author> <title> A Working Environment for the Development of Complex Reactive Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference: [15] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Section 8 presents the WLMS case study. Finally, in Section 9, we discuss limitations of our approach and compare it with related work. 2 Requirements Notation This section describes the requirements specification format: Software Cost Reduction (SCR) requirements <ref> [2, 15, 17, 18] </ref>. These requirements model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [16] <author> C. Heitmeyer, B. Labaw, and D. Kiskis. </author> <title> "Consistency Checking of SCR-Style Requirements Specifications". </title> <booktitle> In Proceedings of RE'95 International Symposium of Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: A condition is a predicate on monitored or mode class variables. An event occurs when the value of a condition changes. For example, @T (a) WHEN [b] occurs if a condition a changes its value from False to True while a condition b is True, or, formally (from <ref> [16] </ref>), @T (a) WHEN [b] =~ a ^ a0 ^ b; where the unprimed version of condition a denotes a in the old state and the primed version denotes a in the new state.
Reference: [17] <author> K. Heninger. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical Report NRL Report 3876, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, DC, </address> <year> 1978. </year>
Reference-contexts: Section 8 presents the WLMS case study. Finally, in Section 9, we discuss limitations of our approach and compare it with related work. 2 Requirements Notation This section describes the requirements specification format: Software Cost Reduction (SCR) requirements <ref> [2, 15, 17, 18] </ref>. These requirements model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [18] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Section 8 presents the WLMS case study. Finally, in Section 9, we discuss limitations of our approach and compare it with related work. 2 Requirements Notation This section describes the requirements specification format: Software Cost Reduction (SCR) requirements <ref> [2, 15, 17, 18] </ref>. These requirements model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [19] <author> W.E. Howden. </author> <title> "Comments Analysis and Programming Errors". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(1) </volume> <pages> 72-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [20] <author> W.E. Howden and G.M. Shi. </author> <title> "Linear and Structural Event Sequence Analysis". </title> <note> Submitted to ISSTA'96, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Other comments contain assertions about properties of objects. An interpreter builds an abstract model of the implementation from the assertions and the implementation's control flow graph. Hypotheses are verified with respect to this model. 28 More recent work <ref> [20] </ref> enriches QDA's specification language so assertions also describe event occurrences and hypotheses assert that the implementation's events occur in certain sequences.
Reference: [21] <author> W.E. Howden and B. Wieand. </author> <title> "QDA A Method for Systematic Informal Program Analysis". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 445-462, </pages> <month> June </month> <year> 1994. </year>
Reference: [22] <author> D. Jackson. </author> <title> Aspect: A Formal Specification Language for Detecting Bugs. </title> <type> PhD thesis, </type> <institution> MIT, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [22, 23, 24] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [23] <author> Daniel Jackson. </author> <title> "Abstract Analysis with Aspect". </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 19-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [22, 23, 24] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [24] <author> Daniel Jackson. </author> <title> "Aspect: Detecting Bugs with Abstract Dependences". </title> <note> (submitted to Transactions on Software Engineering and Methodology), </note> <month> November </month> <year> 1993. </year> <month> 31 </month>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [22, 23, 24] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [25] <author> D.A. Lamb. </author> <title> Software Engineering: Planning for Change. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Designs are often expressed in a program design language (PDL)[5] consisting of a concrete outer syntax of basic statement types, and an inner syntax of comments. Design reviews seek to establish that the design is consistent with the requirements <ref> [25] </ref>. We define a design to be consistent with its requirements if the design's state transitions are enabled by the same events as those of the requirements, all the requirement's state transitions appear in the design, and the requirement's safety properties hold in the design.
Reference: [26] <author> N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference: [27] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> "Cesar: A Static Sequencing Constraint Analyzer". </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 66-74, </pages> <month> December </month> <year> 1989. </year>
Reference: [28] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference: [29] <author> Kurt M. Olender and Leon K. Osterweil. </author> <title> "Interprocedural Static Analysis of Sequencing Constraints". </title> <journal> ACM Transactions of Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference: [30] <author> Dewayne E. Perry. </author> <title> "Software Interconnection Models". </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 61-69. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [30, 31, 32] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [31] <author> Dewayne E. Perry. </author> <booktitle> "The Inscape Environment.". In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 60-68, </pages> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [30, 31, 32] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [32] <author> Dewayne E. Perry. </author> <title> "The Logic of Propagation in The Inscape Environment". </title> <booktitle> In Proceedings of the 3rd Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 114-121, </pages> <address> Key West, Florida, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [30, 31, 32] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [33] <author> A. J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: A special-purpose model checking algorithm determines if the FSM is a model of the formulas. In this paper we describe the tool and show results of a case study in which we analyzed a detailed design of a water-level monitoring system (WLMS) <ref> [33] </ref>, discovering several latent errors. The rest of the paper is organized as follows: Section 2 presents our requirements specification format. In Section 3, we describe the types of global system properties which are automatically generated from the specifications. Section 4 presents a language for specifying designs. <p> Two push buttons, SelfTest and Reset, permit the operator to test the system and return it to normal operation. A complete description of this system can be found in <ref> [33] </ref>. WLMS has two mode classes, Normal and Failure, whose modes are described in Table 4. The system starts in mode Standby of mode class Normal and mode AllOK of mode class Failure.
Reference: [34] <author> Ben Wegbreit. </author> <title> "Property Extraction in Well-Founded Property Sets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3) </volume> <pages> 270-285, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: However, since designs usually consist of several procedures, we needed to extend our analysis technique to process these designs. We perform interprocedural analysis using an adaptation of a technique called cloning [10]. A similar algorithm was described in <ref> [34] </ref>. This technique enables Analyzer to process designs with cycles in their call graphs (recursion), to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [35] <author> Michal Young and Richard N. Taylor. </author> <title> "Rethinking the Taxonomy of Fault Detection Techniques". </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 53-62, </pages> <month> May </month> <year> 1989. </year> <month> 32 </month>
Reference-contexts: Assuming that a formula does not include negated quantifiers (i.e. ~ AG (P ) = EF (~ P )), we can verify it only if it does not contain mixed quantifiers. Young and Taylor <ref> [35] </ref> reach the same conclusion. All properties discussed in earlier sections contained just one quantifier, and thus could be processed. We plan to extend Analyzer to be able to verify arbitrary consistent CTL formulae.
References-found: 35

