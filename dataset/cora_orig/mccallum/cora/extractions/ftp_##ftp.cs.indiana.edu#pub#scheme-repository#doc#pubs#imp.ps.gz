URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/imp.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Email: email: stung@cs.indiana.edu  
Title: Interactive Modular Programming in Scheme  
Author: Sho-Huan Simon Tung 
Address: Bloomington, Indiana 47405  
Affiliation: Computer Science Department Indiana University  
Abstract: This paper presents a module system and a programming environment designed to support interactive program development in Scheme. The module system extends lexical scoping while maintaining its flavor and benefits and supports mutually recursive modules. The programming environment supports dynamic linking, separate compilation, production code compilation, and a window-based user interface with multiple read-eval-print contexts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson, Gerald J. Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1984. </year>
Reference-contexts: However, their system does not allow dynamically extended bindings to access lexical variables in a module. This restriction is too strong to be acceptable. Some Scheme implementations support first-class environments <ref> [1] </ref>. A first-class environment captures the current lexical environment at the point where the first-class environment is created. When used with eval or access, first-class environments can be used to support a form of modular programming. This approach, however, disrupts the flavor and benefits of lexical scoping.
Reference: [2] <author> Luca Cardelli, James Donahue, Lucille Glass-man, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report. Technical Report 31, </type> <institution> DEC Systems Research Center, </institution> <year> 1988. </year>
Reference-contexts: Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications require that the entire program be reloaded. We have also looked at conventional module-supporting languages such as CLU [8], Modula-2 [16], Modula-3 <ref> [2] </ref>, and Ada [15]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: [3] <author> Pavel Curtis and James Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Conference Record of the 1990 ACM Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: When used with eval or access, first-class environments can be used to support a form of modular programming. This approach, however, disrupts the flavor and benefits of lexical scoping. Curtis and Rauen recently proposed a module system designed for large scale programming in Scheme <ref> [3] </ref>. Their system supports more general interface specifications than IMP, but does not address interactive programming. Common Lisp's [11] package system uses symbol tables to represent modules. Symbols defined as external in a package can be exported. Various mechanisms are available to access or to import exported symbols.
Reference: [4] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Modular programming, on the other hand, typically requires a more static model for program development. However, for some languages, these two programming paradigms can be merged gracefully while maintaining the benefits of both. This paper presents a module system and a programming environment designed for Scheme <ref> [4, 10] </ref> that supports interactive modular programming. The module system has the following features: 1. It maintains the flavor and benefits of lexical scop ing. 2. It allows flexible and responsive interactive programming. Interactive modifications of definitions and module interfaces are allowed without requir ing recompilation. 3.
Reference: [5] <author> Daniel P. Friedman and Matthias Felleisen. </author> <title> A closer look at export and import statements. </title> <booktitle> Computer Language, </booktitle> <volume> 11(1) </volume> <pages> 29-37, </pages> <year> 1986. </year>
Reference-contexts: Finally, we discuss issues of extending IMP to support object-oriented programming. 2. Related Work Among many concrete proposals we have looked at, Felleisen and Friedman's module proposal is the only module system designed with consideration for interactive programming <ref> [5] </ref>. However, their system does not allow dynamically extended bindings to access lexical variables in a module. This restriction is too strong to be acceptable. Some Scheme implementations support first-class environments [1]. A first-class environment captures the current lexical environment at the point where the first-class environment is created.
Reference: [6] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> The definition of Standard ML. </title> <type> Technical Report ECS-LFCS-89-81, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: This requires the module dependency graph to be acyclic and defeats possibilities for flexible interaction. Standard ML is a statically scoped programming language with a secure polymorphic type system and a module system <ref> [6] </ref>. However, its type system limits its flexibility as an interactive language. Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications require that the entire program be reloaded.
Reference: [7] <author> Simon Kaplan, Alan M. Carroll, Christopher Love, and Daniel M. LaLiberte. </author> <title> Epoch GNU Emacs for the X Window System. </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: The user interface relates modules with files, editing windows, and a multiple-context read-eval-print loop. It is based on GNU Emacs and can also be used with Epoch, which is a variant of GNU Emacs supporting true multi-window editing under the X window system <ref> [7] </ref>. Figure 5 presents IMP's user interface. The syntax of the module system requires a module name to be specified for every definition and expression within the module.
Reference: [8] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <year> 1977. </year>
Reference-contexts: Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications require that the entire program be reloaded. We have also looked at conventional module-supporting languages such as CLU <ref> [8] </ref>, Modula-2 [16], Modula-3 [2], and Ada [15]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: [9] <author> Christian Queinnec and Julian Padget. </author> <title> A detailed summary of a deterministic model of modules and macros for Lisp. </title> <type> Technical Report LIX/RR/90/01, </type> <institution> Ecole Polytechnique, Laboratoire d'Informatique, </institution> <address> 91128 Palaiseau Cedex (France), </address> <month> July-December </month> <year> 1989. </year>
Reference-contexts: Queinnec and Padget designed a module system for Lisp <ref> [9] </ref>, but their system binds imported identifiers early in the module definition phase. This requires the module dependency graph to be acyclic and defeats possibilities for flexible interaction. Standard ML is a statically scoped programming language with a secure polymorphic type system and a module system [6].
Reference: [10] <editor> Jonathan Rees and William Clinger. (Editors), </editor> <title> Revised 4 report on the algorithmic language Scheme. Lisp Pointers, </title> <note> to appear. </note>
Reference-contexts: Modular programming, on the other hand, typically requires a more static model for program development. However, for some languages, these two programming paradigms can be merged gracefully while maintaining the benefits of both. This paper presents a module system and a programming environment designed for Scheme <ref> [4, 10] </ref> that supports interactive modular programming. The module system has the following features: 1. It maintains the flavor and benefits of lexical scop ing. 2. It allows flexible and responsive interactive programming. Interactive modifications of definitions and module interfaces are allowed without requir ing recompilation. 3. <p> Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications. Ada supports generic packages that must be instantiated statically through declarations. These languages, however, do not support interactive programming. 3. The Module System The Revised 4 Report on Scheme <ref> [10] </ref> describes the structure of a Scheme program as consisting of a sequence of expressions and definitions. <p> We have extended IMP to support object-oriented programming [13, 14]. Several macro systems supporting hygienic macros have been proposed for Scheme. These proposals provide different facilities for writing low-level macros. We are considering integrating and extending the system proposed by Hieb and Dybvig to support exported macros <ref> [10] </ref>. Acknowledgements I would like to thank Kent Dybvig, Bob Hieb, Michael Ashley, Carl Bruggeman, Dan Friedman, and Shinn-Der Lee for many useful insights and suggestions on the design of the system and on earlier drafts of this paper.
Reference: [11] <author> Guy L. Steele Jr. </author> <title> Common Lisp. </title> <publisher> Digital Press, </publisher> <year> 1990. </year> <note> Second Edition. </note>
Reference-contexts: This approach, however, disrupts the flavor and benefits of lexical scoping. Curtis and Rauen recently proposed a module system designed for large scale programming in Scheme [3]. Their system supports more general interface specifications than IMP, but does not address interactive programming. Common Lisp's <ref> [11] </ref> package system uses symbol tables to represent modules. Symbols defined as external in a package can be exported. Various mechanisms are available to access or to import exported symbols. The package system could be used as the low-level implementation for fully developed (static) modules.
Reference: [12] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: 3) i else (m # 2) i else (m # 1) i else i lookupM [[]] i = undefined lookupM [[f irst rest fl ]] i = if (f irst # 2) i = undefined then lookupM rest fl i else (f irst # 2) i extended subset of Scheme <ref> [12] </ref>. To simplify the presentation, support for renaming imported identifiers has been omitted.
Reference: [13] <author> Sho-Huan Simon Tung. </author> <title> Merging Interactive, Modular, and Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, </institution> <year> 1992. </year>
Reference-contexts: Modular programming and object-oriented programming are two programming paradigms that share many common objectives. These common objectives include encapsulation and modularity and should be supported by common rather than different language facilities. We have extended IMP to support object-oriented programming <ref> [13, 14] </ref>. Several macro systems supporting hygienic macros have been proposed for Scheme. These proposals provide different facilities for writing low-level macros. We are considering integrating and extending the system proposed by Hieb and Dybvig to support exported macros [10].
Reference: [14] <author> Sho-Huan Simon Tung and R. Kent Dybvig. </author> <title> Object-oriented programming with interactive modules. </title> <note> in preparation. </note>
Reference-contexts: Modular programming and object-oriented programming are two programming paradigms that share many common objectives. These common objectives include encapsulation and modularity and should be supported by common rather than different language facilities. We have extended IMP to support object-oriented programming <ref> [13, 14] </ref>. Several macro systems supporting hygienic macros have been proposed for Scheme. These proposals provide different facilities for writing low-level macros. We are considering integrating and extending the system proposed by Hieb and Dybvig to support exported macros [10].
Reference: [15] <author> US Government Department of Defense. </author> <title> The programming language ADA reference manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 106, </volume> <year> 1981. </year>
Reference-contexts: Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications require that the entire program be reloaded. We have also looked at conventional module-supporting languages such as CLU [8], Modula-2 [16], Modula-3 [2], and Ada <ref> [15] </ref>. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: [16] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications require that the entire program be reloaded. We have also looked at conventional module-supporting languages such as CLU [8], Modula-2 <ref> [16] </ref>, Modula-3 [2], and Ada [15]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
References-found: 16

