URL: ftp://ftp.csd.uu.se/pub/papers/reports/0088.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: email voronkov@csd.uu.se  
Title: Implementing Bottom-up Procedures with Code Trees: a Case Study of Forward Subsumption  
Author: Andrei Voronkov 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department Uppsala University  
Abstract: UPMAIL Technical Report No. 88 October 3, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [AS92] <author> O.L. Astrakhan and M.E. Stickel. </author> <title> Caching and lemmaizing in model elimination theorem prover. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 224-239, </pages> <address> Saratoga Springs, NY, USA, June 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: SLD-AL resolution [Vie89] and OLDT-resolution [TS86, War92] are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas <ref> [AS92, GLMS94] </ref>, which allow one to use previously proved subgoals. This article deals with an implementation technique for bottom-up systems, which can be used to speed up many important algorithms. Bottom-up algorithms have been used through the years in automated deduction. <p> Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination <ref> [AS92] </ref> also use a similar scheme. There are certain specific features of such systems which pose a challenge to people who implement them: 1. There is usually a small number of operations which must repeatedly be applied to clauses in the database (for example, resolution). 2.
Reference: [BMSU86] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J.D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the 5th ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: For instance, various modifications of magic sets transformations require the semi-naive bottom-up evaluation of the transformed logic 1 The bottom-up methods of search are also sometimes called indirect methods, in opposite to direct top-down methods. (Lincoln Wallen, private communication.) 3 program <ref> [BMSU86, BR87] </ref>. SLD-AL resolution [Vie89] and OLDT-resolution [TS86, War92] are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas [AS92, GLMS94], which allow one to use previously proved subgoals. <p> If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets <ref> [BMSU86, BNRST87] </ref>, tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [BNRST87] <author> C. Beeri, Sh. Naqvi, R. Ramakrishnan, O. Shmueli, and Sh. Tsur. </author> <title> Sets and negation in a logic database language (LDL1). </title> <booktitle> In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 21-36. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets <ref> [BMSU86, BNRST87] </ref>, tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [BR87] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: For instance, various modifications of magic sets transformations require the semi-naive bottom-up evaluation of the transformed logic 1 The bottom-up methods of search are also sometimes called indirect methods, in opposite to direct top-down methods. (Lincoln Wallen, private communication.) 3 program <ref> [BMSU86, BR87] </ref>. SLD-AL resolution [Vie89] and OLDT-resolution [TS86, War92] are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas [AS92, GLMS94], which allow one to use previously proved subgoals.
Reference: [CD93] <author> M. Codish and B. Demoen. </author> <title> Analyzing logic programs using "Prop"-ositional logic programs and a magic wand. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming | Proceedings of the 1993 International Symposium, </booktitle> <pages> pages 114-129. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs <ref> [CD93] </ref>, constraint logic programming, parsing [TR94], production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme. There are certain specific features of such systems which pose a challenge to people who implement them: 1.
Reference: [Das92] <author> S.K. Das. </author> <title> Deductive Databases and Logic Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking <ref> [LT85, LST86, Dec86, Das92] </ref>, bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme.
Reference: [Dec86] <author> H. Decker. </author> <title> Integrity enforcements on deductive databases. </title> <booktitle> In Proc. of the 1st International Conference on Expert Database Systems, </booktitle> <pages> pages 271-285, </pages> <address> Charleston, South Carolina, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking <ref> [LT85, LST86, Dec86, Das92] </ref>, bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme.
Reference: [GJ79] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability. </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: The subsumption-check for multi-literal clauses is much harder than that of unit clauses. It is known that the subsumption-check for multi-literal clauses is NP-complete (see e.g. <ref> [GJ79] </ref>). The usual indexing methods used in theorem proving programs do not work well with multi-literal clauses.
Reference: [GLMS94] <author> C. Goller, R. Letz, K. Mayr, and J. Schumann. </author> <title> SETHEO V3.2: Recent developments. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Automated Deduction | CADE-12. 12th International Conference on Automated Deduction., volume 814 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 778-782, </pages> <address> Nancy, France, </address> <month> June/July </month> <year> 1994. </year>
Reference-contexts: SLD-AL resolution [Vie89] and OLDT-resolution [TS86, War92] are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas <ref> [AS92, GLMS94] </ref>, which allow one to use previously proved subgoals. This article deals with an implementation technique for bottom-up systems, which can be used to speed up many important algorithms. Bottom-up algorithms have been used through the years in automated deduction.
Reference: [GL87] <author> G. Gottlob and A. Leitsch. </author> <title> On the efficiency of subsumption algorithms. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32(2) </volume> <pages> 280-295, </pages> <month> April </month> <year> 1987. </year>
Reference: [Gra94] <author> P. Graf. </author> <title> Extended path-indexing. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Automated Deduction | CADE-12. 12th International Conference on Automated Deduction., volume 814 of 31 Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 514-528, </pages> <address> Nancy, France, </address> <month> June/July </month> <year> 1994. </year>
Reference-contexts: Our technique discriminate variables in the order of their occurrences in clauses. Thus, it treats variables occurring in different clauses in a uniform way. We do not know any implementation of a logic programming or theorem proving system which makes use of this idea. In <ref> [Gra94] </ref> a technique is proposed which tries to find some dependencies in path indexes in a uniform way. Ideas of that paper have something in common with our paper. There are some quite obvious optimizations of code trees. For example, one can use hashing instead of forking in the tree. <p> But all these procedures may use the same indexing scheme. At the same time if one would try to provide indexing schemes with more information helpful for an algorithm, it may result in a huge memory consumption, as was shown in <ref> [Gra94] </ref> for path indexing. 25 Section 6 Experiments Here we give a statistics of two examples proved in our theorem proving system V ampire on a Hewlett Packard 735. We did not try to set the best methods/switches to solve the two problems.
Reference: [Lus92] <author> E.L. Lusk. </author> <title> Controlling redundancy in large search spaces: Argonne-style theorem proving through the years. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming and Automated Reasoning. International Conference LPAR'92., volume 624 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 96-106, </pages> <address> St.Petersburg, Russia, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: As noted in [Wos92], the implementation of discrimination trees in the well known theorem prover OTTER resulted in a much faster performance. Most bottom-up systems are based on the following loop that resembles the "closure algorithm" from <ref> [Lus92] </ref>: Let D be the initial database of clauses. loop: 1. Apply given inference rules to D (or a part of D). Let D be the new clauses. 2. If D; D satisfy a termination criterion, then terminate. 3. Apply a retention test to D. 4.
Reference: [LST86] <author> J.W. Lloyd, E.A. Sonenberg, and R.W. Topor. </author> <title> Integrity constraint checking in stratified databases. </title> <type> Technical Report 86/5, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <year> 1986. </year>
Reference-contexts: This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking <ref> [LT85, LST86, Dec86, Das92] </ref>, bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme.
Reference: [LT85] <author> J.W. Lloyd and R.W. Topor. </author> <title> A basis for deductive database systems. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(2) </volume> <pages> 93-109, </pages> <year> 1985. </year>
Reference-contexts: This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking <ref> [LT85, LST86, Dec86, Das92] </ref>, bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme.
Reference: [MAT94] <author> A.M. Maeda, J.-I. Aoe, and H. Tomabechi. </author> <title> Signature-check based unification filter. </title> <journal> Software | Practice and Experience, </journal> <volume> 24(7) </volume> <pages> 603-622, </pages> <year> 1994. </year>
Reference-contexts: the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems <ref> [MAT94] </ref>. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme. There are certain specific features of such systems which pose a challenge to people who implement them: 1.
Reference: [MB88] <author> R. Manthey and F. Bry. </author> <title> SATCHMO: a theorem prover implemented in Prolog. </title> <booktitle> In CADE'88 (9th Int. Conf. on Automated Deduction), Lecture Notes in Computer Science, </booktitle> <pages> pages 179-216, </pages> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988. </year>
Reference: [Mas67] <author> S.Yu. Maslov. </author> <title> An inverse method for establishing deducibility of nonprenex formulas of the predicate calculus. </title> <editor> In J.Siekmann and G.Wrightson, editors, </editor> <booktitle> Automation of Reasoning (Classical papers on Computational Logic), </booktitle> <volume> volume 2, </volume> <pages> pages 48-54. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution [Rob65a] and the inverse method <ref> [Mas67, Vor92] </ref>. In order to efficiently implement such procedures, indexing techniques have been develop [Sti89, McC88, McC92]. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. <p> If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method <ref> [Mas67, Vor92] </ref>, implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [McC88] <author> William W. McCune. </author> <title> An indexing method for finding more general formulas. </title> <journal> Association for Automated Reasoning Newsletter, </journal> <volume> 1(9) </volume> <pages> 7-8, </pages> <year> 1988. </year>
Reference-contexts: Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution [Rob65a] and the inverse method [Mas67, Vor92]. In order to efficiently implement such procedures, indexing techniques have been develop <ref> [Sti89, McC88, McC92] </ref>. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. As noted in [Wos92], the implementation of discrimination trees in the well known theorem prover OTTER resulted in a much faster performance.
Reference: [McC90] <author> William W. McCune. </author> <title> OTTER 2.0 users guide. </title> <type> Technical report, </type> <institution> Argonne National Laboratory, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The retention test for D usually includes forward subsumption: remove from D every clause subsumed by a clause in D. In principle, there might be other criteria for discarding new goals <ref> [McC90] </ref>. When the number of generated clauses is big compared to the number of kept clauses, forward subsumption becomes the most costly operation. 4. The changes in D are induced by new clauses from D. Two algorithms may be applied at this stage.
Reference: [McC92] <author> William W. McCune. </author> <title> Experiments with discrimination-tree in indexing and path indexing for term retrieval. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 147-167, </pages> <year> 1992. </year>
Reference-contexts: Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution [Rob65a] and the inverse method [Mas67, Vor92]. In order to efficiently implement such procedures, indexing techniques have been develop <ref> [Sti89, McC88, McC92] </ref>. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. As noted in [Wos92], the implementation of discrimination trees in the well known theorem prover OTTER resulted in a much faster performance. <p> The first idea is to exploit the common structure of clauses in D in order to select a (hopefully small) subset of potential candidates for subsumption. This idea has given rise to the use of various indexing schemes, like discrimination trees <ref> [McC92] </ref> or path indexing [Sti89]. Indexing plays the role of a filter for the selection of potentially useful clauses. The second idea is to combine algorithms which perform subsumption by D in one algorithm (the code tree). In Section 5 we briefly compare the two approaches. <p> Some of them are reviewed in <ref> [McC92] </ref>. Most of these techniques use indexing to filter out the relevant clauses and to perform the algorithms "set at a time". There are two main types of indexing schemes which are used in modern theorem provers | path indexing [Sti89] and discrimination trees [McC92]. <p> Some of them are reviewed in <ref> [McC92] </ref>. Most of these techniques use indexing to filter out the relevant clauses and to perform the algorithms "set at a time". There are two main types of indexing schemes which are used in modern theorem provers | path indexing [Sti89] and discrimination trees [McC92]. In this section we briefly compare code trees with indexing schemes. Discrimination trees are trees which encode structure of terms occurring in clauses. Paths is the discrimination trees correspond to the terms. An example from [McC92] of a set of terms and its discrimination tree is shown on Figure 5.1 <p> which are used in modern theorem provers | path indexing [Sti89] and discrimination trees <ref> [McC92] </ref>. In this section we briefly compare code trees with indexing schemes. Discrimination trees are trees which encode structure of terms occurring in clauses. Paths is the discrimination trees correspond to the terms. An example from [McC92] of a set of terms and its discrimination tree is shown on Figure 5.1 (the example is taken over from [McC92]). The main difference in the design of code trees and indexing schemes is the following. Indexing is used to filter out relevant clauses for a procedure. <p> Discrimination trees are trees which encode structure of terms occurring in clauses. Paths is the discrimination trees correspond to the terms. An example from <ref> [McC92] </ref> of a set of terms and its discrimination tree is shown on Figure 5.1 (the example is taken over from [McC92]). The main difference in the design of code trees and indexing schemes is the following. Indexing is used to filter out relevant clauses for a procedure. It may often be not enough for efficient algorithms. Thus, indexing schemes are usually provided with additional information.
Reference: [Nei90] <author> V. Neiman. </author> <title> Refutation search for horn sets by a subgoal-extraction method. </title> <journal> Journal of Logic Programming, </journal> <volume> 9(2) </volume> <pages> 267-284, </pages> <year> 1990. </year>
Reference: [Pel86] <author> F.J. Pelletier. </author> <title> Seventy-five problems for testing automatic theorem provers. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 2(2) </volume> <pages> 191-216, </pages> <year> 1986. </year>
Reference-contexts: There is only one predicate symbol and only one function symbol. Thus, subsumption never fails on the comparison of function symbols. On multi-literal clauses, we tried the "steamroller" problem from the Pelletier list <ref> [Pel86] </ref>: 1. :Q1 (x0); :P 0 (x1); :P 0 (x2); :R (x1; x0); :R (x2; x1) 3. P 1 (a) 5. P 2 (b) 7. P 3 (c) 1 Here the weight of a clause is the number of occurrences of symbols in the clause.
Reference: [Rob65a] <author> J.A. Robinson. </author> <title> Automatic deduction with hyper-resolution. </title> <journal> International Journal of Computer Mathematics, </journal> <volume> 1 </volume> <pages> 227-234, </pages> <year> 1965. </year>
Reference-contexts: This article deals with an implementation technique for bottom-up systems, which can be used to speed up many important algorithms. Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution <ref> [Rob65a] </ref> and the inverse method [Mas67, Vor92]. In order to efficiently implement such procedures, indexing techniques have been develop [Sti89, McC88, McC92]. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. <p> Back subsumption consists of removal from D every clause subsumed by a clause from D. If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution <ref> [Rob65, Rob65a] </ref>, the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production
Reference: [Rob65] <author> J.A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: This article deals with an implementation technique for bottom-up systems, which can be used to speed up many important algorithms. Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution <ref> [Rob65] </ref>, hyperresolution [Rob65a] and the inverse method [Mas67, Vor92]. In order to efficiently implement such procedures, indexing techniques have been develop [Sti89, McC88, McC92]. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. <p> Back subsumption consists of removal from D every clause subsumed by a clause from D. If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution <ref> [Rob65, Rob65a] </ref>, the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production
Reference: [RW69] <author> G. Robinson and L.T. Wos. </author> <title> Paramodulation and theorem-proving in first order theories with equality. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> volume 4. </volume> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year> <month> 32 </month>
Reference-contexts: We shall show its use it on the forward subsumption problem. The idea of code trees is very general and may as well be applied to various concepts of resolution. It can also be used for the implementation of equality reasoning procedures, like paramodulation <ref> [RW69] </ref> and rewriting. Our technique is based on the following two main ideas. The first idea is to compile specialized subsumption procedures for kept clauses. It can be considered as a run time specialization of a general subsumption algorithm.
Reference: [Sti88] <author> M. Stickel. </author> <title> A PROLOG technology theorem prover: Implementation by an extended Prolog compiler. </title> <journal> Journal of Automated Reasoning, </journal> (4):353-380, 1988. 
Reference: [Sti89] <author> M. Stickel. </author> <title> The path indexing method for indexing terms. </title> <type> Technical Report 473, </type> <institution> Artificial Intelligence Center, SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution [Rob65a] and the inverse method [Mas67, Vor92]. In order to efficiently implement such procedures, indexing techniques have been develop <ref> [Sti89, McC88, McC92] </ref>. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. As noted in [Wos92], the implementation of discrimination trees in the well known theorem prover OTTER resulted in a much faster performance. <p> The first idea is to exploit the common structure of clauses in D in order to select a (hopefully small) subset of potential candidates for subsumption. This idea has given rise to the use of various indexing schemes, like discrimination trees [McC92] or path indexing <ref> [Sti89] </ref>. Indexing plays the role of a filter for the selection of potentially useful clauses. The second idea is to combine algorithms which perform subsumption by D in one algorithm (the code tree). In Section 5 we briefly compare the two approaches. Let us start with an example. <p> Some of them are reviewed in [McC92]. Most of these techniques use indexing to filter out the relevant clauses and to perform the algorithms "set at a time". There are two main types of indexing schemes which are used in modern theorem provers | path indexing <ref> [Sti89] </ref> and discrimination trees [McC92]. In this section we briefly compare code trees with indexing schemes. Discrimination trees are trees which encode structure of terms occurring in clauses. Paths is the discrimination trees correspond to the terms.
Reference: [SR93] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms (extended abstract). </title> <editor> In Dale Miller, editor, </editor> <booktitle> Logic Programming. Proceedings of the 1993 International Symposium, </booktitle> <pages> pages 557-574. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs <ref> [TS86, War92, SR93] </ref>, various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94]. <p> Remove (I; T ) corresponds to C without all variants of c; Proof is straightforward, but tedious. Note that by using code trees we obtained an interesting technique of indexing in presence of variables. It has been noted in <ref> [SR93] </ref> that the non-ground subsumption-checking is difficult: "In the general case, subsumption-checking is a costly operation, and we are not aware of efficient subsumption-checking techniques for the case of arbitrary non-ground facts: : : ".
Reference: [TR94] <author> M. Tambe and P.S. Rosenbloom. </author> <title> Investigating production system representations for non-combinatorial match. </title> <journal> Artificial Intelligence, </journal> <volume> 68 </volume> <pages> 155-190, </pages> <year> 1994. </year>
Reference-contexts: hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing <ref> [TR94] </ref>, production systems [MAT94]. Top-down procedures which use lemmaizing, like SLD-AL-resolution [Vie89] or some implementations of model elimination [AS92] also use a similar scheme. There are certain specific features of such systems which pose a challenge to people who implement them: 1.
Reference: [TS86] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: For instance, various modifications of magic sets transformations require the semi-naive bottom-up evaluation of the transformed logic 1 The bottom-up methods of search are also sometimes called indirect methods, in opposite to direct top-down methods. (Lincoln Wallen, private communication.) 3 program [BMSU86, BR87]. SLD-AL resolution [Vie89] and OLDT-resolution <ref> [TS86, War92] </ref> are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas [AS92, GLMS94], which allow one to use previously proved subgoals. <p> This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs <ref> [TS86, War92, SR93] </ref>, various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [Vie89] <author> Laurent Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: For instance, various modifications of magic sets transformations require the semi-naive bottom-up evaluation of the transformed logic 1 The bottom-up methods of search are also sometimes called indirect methods, in opposite to direct top-down methods. (Lincoln Wallen, private communication.) 3 program [BMSU86, BR87]. SLD-AL resolution <ref> [Vie89] </ref> and OLDT-resolution [TS86, War92] are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas [AS92, GLMS94], which allow one to use previously proved subgoals. <p> Top-down procedures which use lemmaizing, like SLD-AL-resolution <ref> [Vie89] </ref> or some implementations of model elimination [AS92] also use a similar scheme. There are certain specific features of such systems which pose a challenge to people who implement them: 1.
Reference: [Vor90] <author> A. Voronkov. </author> <title> LISS the Logic Inference Search System. </title> <editor> In Mark Stickel, editor, </editor> <booktitle> Proc. Int. Conf. on Automated Deduction, volume 449 of Lecture Notes in Computer Science, </booktitle> <pages> pages 677-678, </pages> <address> Kaiserslautern, Germany, 1990. </address> <publisher> Springer Verlag. </publisher>
Reference: [Vor92] <author> A. Voronkov. </author> <title> Theorem proving in non-standard logics based on the inverse method. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 648-662, </pages> <address> Saratoga Springs, NY, USA, June 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Bottom-up algorithms have been used through the years in automated deduction. They are used by many automatic theorem proving procedures, e.g., binary resolution [Rob65], hyperresolution [Rob65a] and the inverse method <ref> [Mas67, Vor92] </ref>. In order to efficiently implement such procedures, indexing techniques have been develop [Sti89, McC88, McC92]. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. <p> If a new clause includes equalities, it can be used for back demodulation, i.e. rewriting applied to clauses from D. This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method <ref> [Mas67, Vor92] </ref>, implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs [TS86, War92, SR93], various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [War83] <author> David H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> SRI Tech. Note 309, </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year>
Reference: [War92] <author> D.S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Communications of the ACM (invited paper), </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <year> 1992. </year>
Reference-contexts: For instance, various modifications of magic sets transformations require the semi-naive bottom-up evaluation of the transformed logic 1 The bottom-up methods of search are also sometimes called indirect methods, in opposite to direct top-down methods. (Lincoln Wallen, private communication.) 3 program [BMSU86, BR87]. SLD-AL resolution [Vie89] and OLDT-resolution <ref> [TS86, War92] </ref> are further examples of systems which combine the bottom-up and top-down evaluations. In automatic theorem proving, model elimination which is a top-down procedure, has recently been augmented with lemmas [AS92, GLMS94], which allow one to use previously proved subgoals. <p> This loop is used in most implementations of binary resolution and hyperresolution [Rob65, Rob65a], the inverse method [Mas67, Vor92], implementations based on magic sets [BMSU86, BNRST87], tabled computations of logic programs <ref> [TS86, War92, SR93] </ref>, various deductive databases procedures, for example query answering and integrity checking [LT85, LST86, Dec86, Das92], bottom-up 4 static analysis of logic programs [CD93], constraint logic programming, parsing [TR94], production systems [MAT94].
Reference: [WOL91] <author> Larry Wos, Ross Overbeek, and Ewing Lusk. </author> <title> Subsumption, a sometimes undervalued procedure. </title> <editor> In Jean-Louis Lassez and Gordon Plotkin, editors, </editor> <booktitle> Computational Logic. Essays in Honor of Alan Robinson., </booktitle> <pages> pages 3-40. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Bottom-up systems usually deal with a database of clauses and generate new clauses by applying inference rules to clauses in the database. There are also systems which can combine top-down with bottom-up. Systems which keep track of previously generated clauses are said to retain information in <ref> [WOL91] </ref>. All bottom-up systems retain information. If a top-down system retains information, it is usually characterized as a combination of top-down and bottom-up. The systems retaining information show a superior performance when dealing with problems involving large search spaces. It has been widely recognized in the deductive database community. <p> On the contrary, we tried to set options in such a way so that to increase the number of forward subsumptions required. One of the hardest problems dealing with unit clauses was the condensed detachment 4 problem from <ref> [WOL91] </ref>. The initial clauses are the following: 1. P (x 1 ); :P (x 2 ); :P (i (x 2 ; x 1 )): 3. P (i (x 1 ; i (i (x 2 ; i (x 3 ; x 1 )); i (x 3 ; x 2 )))).
Reference: [Wos92] <author> Larry Wos. </author> <title> Note on McCune's article on discrimination trees. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 145-146, </pages> <year> 1992. </year> <month> 33 </month>
Reference-contexts: In order to efficiently implement such procedures, indexing techniques have been develop [Sti89, McC88, McC92]. Indexing allows main operations (like resolution and subsumption) to be implemented on the "set at a time" basis. As noted in <ref> [Wos92] </ref>, the implementation of discrimination trees in the well known theorem prover OTTER resulted in a much faster performance. Most bottom-up systems are based on the following loop that resembles the "closure algorithm" from [Lus92]: Let D be the initial database of clauses. loop: 1.
References-found: 37

