URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-011.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Folding A Stack Of Equal Width Components  
Author: Venkat Thanvantri and Sartaj Sahni 
Keyword: and Phrases stacked bit slice architectures, folding, layout area  
Note: This research was supported in part by the National Science Foundation under the grant MIP 91-03379  
Date: 94-011  
Address: Gainesville, FL-32611  
Affiliation: Department of CIS, University of Florida,  
Pubnum: Technical Report  
Abstract: We consider two versions of the problem of folding a stack of equal width components. In both versions, when a stack is folded, a routing penalty is incurred at the fold. In one version, the height of the folded layout is given and we are to minimize width. In the other, the width of the folded layout is given and its height is to be minimized. For the first version, we develop a fast linear time algorithm. For the second, four algorithms of complexity O(n log n), O(n log log n), O(n log fl n), and O(n) respectively are presented. Experimental results indicate that in practice, the O(n log n) algorithm performs best. 
Abstract-found: 1
Intro-found: 1
Reference: [FRED83] <author> G. N. Frederickson, and D. B. Johnson, </author> <title> "Finding kth paths and p-centers by generating and searching good data structures", </title> <journal> Journal of Algorithms, </journal> <volume> 4 </volume> <pages> 61-80, </pages> <year> 1983. </year>
Reference-contexts: As is evident, our algorithm is considerably superior to that of [PAIK93] even on small instances. 4 Parametric Search In this section, we provide an overview of parametric search. The overview relies heavily on the developments provided by Frederickson and Johnson <ref> [FRED83, FRED84] </ref> and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in [FRED83, FRED84, FRED91, FRED92]. <p> The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. By sorted, we mean that M ij M i;j+1 ; 1 i n; 1 j &lt; n The matrix is provided implicitly. <p> The entries in the new rows and columns are 0. This does not affect the asymptotic complexity of PSEARCH. Alternatively, we can modify the matrix splitting process to partition into four roughly equal submatrices at each step. The details of these generalizations are given in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. 13 Procedure PSEARCH is modeled after procedure MSEARCH of [FRED92]. <p> An alterna-tive search algorithm in which the for loop is iterated twice, once with T being the multiset of the largest values in S and once with T being the multiset of the smallest values in S is given in <ref> [FRED83, FRED84] </ref>. <p> Hence, the overall complexity of the parametric search algorithm to find the minimum height folding remains O (n log n). We note that our O (n log n) algorithm is very similar to the O (n log n) algorithm of <ref> [FRED83] </ref> to partition a path into k subpaths such that the length of the shortest subpath is maximized. <p> 1.47 2.28 1.49 1.52 256 23255 45.96 76.55 169.58 169.42 Times are in milliseconds Table 3: Run times of equal-width width-constrained algorithms (2) The definition of M ij needs to be adjusted to account for the routing heights r i and r j+1 needed at either end of the stack. <ref> [FRED83, FRED84, FRED91, FRED92] </ref> present several refinements of the basic parametric search technique. These refinements apply to the equal-width width-constrained problem just as well as to the path partitioning problem provided we start with a normalized instance and use the candidate matrix M defined above. <p> To apply these refinements we do not need much development specific to the component stack problem. As a result we do not describe the refined algorithms here. The interested reader is referred to <ref> [FRED83, FRED84, FRED91, FRED92] </ref>.
Reference: [FRED84] <author> G. N. Frederickson, and D. B. Johnson, </author> <title> "Generalized selection and ranking: sorted matrices", </title> <journal> SIAM Journal on computing, </journal> <volume> 13 </volume> <pages> 14-30, </pages> <year> 1984. </year>
Reference-contexts: As is evident, our algorithm is considerably superior to that of [PAIK93] even on small instances. 4 Parametric Search In this section, we provide an overview of parametric search. The overview relies heavily on the developments provided by Frederickson and Johnson <ref> [FRED83, FRED84] </ref> and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in [FRED83, FRED84, FRED91, FRED92]. <p> The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. By sorted, we mean that M ij M i;j+1 ; 1 i n; 1 j &lt; n The matrix is provided implicitly. <p> The entries in the new rows and columns are 0. This does not affect the asymptotic complexity of PSEARCH. Alternatively, we can modify the matrix splitting process to partition into four roughly equal submatrices at each step. The details of these generalizations are given in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. 13 Procedure PSEARCH is modeled after procedure MSEARCH of [FRED92]. <p> An alterna-tive search algorithm in which the for loop is iterated twice, once with T being the multiset of the largest values in S and once with T being the multiset of the smallest values in S is given in <ref> [FRED83, FRED84] </ref>. <p> 1.47 2.28 1.49 1.52 256 23255 45.96 76.55 169.58 169.42 Times are in milliseconds Table 3: Run times of equal-width width-constrained algorithms (2) The definition of M ij needs to be adjusted to account for the routing heights r i and r j+1 needed at either end of the stack. <ref> [FRED83, FRED84, FRED91, FRED92] </ref> present several refinements of the basic parametric search technique. These refinements apply to the equal-width width-constrained problem just as well as to the path partitioning problem provided we start with a normalized instance and use the candidate matrix M defined above. <p> To apply these refinements we do not need much development specific to the component stack problem. As a result we do not describe the refined algorithms here. The interested reader is referred to <ref> [FRED83, FRED84, FRED91, FRED92] </ref>.
Reference: [FRED91] <author> G. N. Frederickson, </author> <title> "Optimal algorithms for tree partitioning", </title> <booktitle> Proc. 2nd ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> San Francisco, California (Jan. </address> <year> 1991), </year> <pages> pp. 168-177 </pages>
Reference-contexts: As is evident, our algorithm is considerably superior to that of [PAIK93] even on small instances. 4 Parametric Search In this section, we provide an overview of parametric search. The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son <ref> [FRED91, FRED92] </ref>. This overview has, however, been tailored to suit our application here and is not as general as that provided in [FRED83, FRED84, FRED91, FRED92]. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. <p> The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. By sorted, we mean that M ij M i;j+1 ; 1 i n; 1 j &lt; n The matrix is provided implicitly. <p> The entries in the new rows and columns are 0. This does not affect the asymptotic complexity of PSEARCH. Alternatively, we can modify the matrix splitting process to partition into four roughly equal submatrices at each step. The details of these generalizations are given in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. 13 Procedure PSEARCH is modeled after procedure MSEARCH of [FRED92]. <p> 1.47 2.28 1.49 1.52 256 23255 45.96 76.55 169.58 169.42 Times are in milliseconds Table 3: Run times of equal-width width-constrained algorithms (2) The definition of M ij needs to be adjusted to account for the routing heights r i and r j+1 needed at either end of the stack. <ref> [FRED83, FRED84, FRED91, FRED92] </ref> present several refinements of the basic parametric search technique. These refinements apply to the equal-width width-constrained problem just as well as to the path partitioning problem provided we start with a normalized instance and use the candidate matrix M defined above. <p> To apply these refinements we do not need much development specific to the component stack problem. As a result we do not describe the refined algorithms here. The interested reader is referred to <ref> [FRED83, FRED84, FRED91, FRED92] </ref>.
Reference: [FRED92] <author> G. N. Frederickson, </author> <title> "Optimal parametric search algorithms in trees I: tree partitioning", </title> <type> manuscript, </type> <institution> Purdue University, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: As is evident, our algorithm is considerably superior to that of [PAIK93] even on small instances. 4 Parametric Search In this section, we provide an overview of parametric search. The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son <ref> [FRED91, FRED92] </ref>. This overview has, however, been tailored to suit our application here and is not as general as that provided in [FRED83, FRED84, FRED91, FRED92]. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. <p> The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son [FRED91, FRED92]. This overview has, however, been tailored to suit our application here and is not as general as that provided in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. Assume that we are given a sorted matrix of O (n 2 ) candidate values M ij , 1 i; j n. By sorted, we mean that M ij M i;j+1 ; 1 i n; 1 j &lt; n The matrix is provided implicitly. <p> Consequently, the largest element of each submatix is in bottom right corner and the smallest is in the top left corner. These elements can therefore be determined in constant time per matrix of S. Theorem 3 : <ref> [FRED92] </ref> The number of feasibility tests F performed by procedure PSEARCH when started with S = fM g, M an nfin sorted matrix that is provided implicitly is O (log n) and the total time spent obtaining the candidates for feasibility test is O (n). 2 Corollary 1 : Let t <p> To analyze the complexity of these algorithms, we shall use the following theorem and corollary. Theorem 4 : <ref> [FRED92] </ref> If PSEARCH is initiated with S containing m sorted matrices, each of dimension n, then the number of feasibility tests is O (log n) and the total time spent obtaining the candidate values for these tests is O (mn). 2 Corollary 2 : Let t (n) be as in Corollary <p> The entries in the new rows and columns are 0. This does not affect the asymptotic complexity of PSEARCH. Alternatively, we can modify the matrix splitting process to partition into four roughly equal submatrices at each step. The details of these generalizations are given in <ref> [FRED83, FRED84, FRED91, FRED92] </ref>. 13 Procedure PSEARCH is modeled after procedure MSEARCH of [FRED92]. <p> This does not affect the asymptotic complexity of PSEARCH. Alternatively, we can modify the matrix splitting process to partition into four roughly equal submatrices at each step. The details of these generalizations are given in [FRED83, FRED84, FRED91, FRED92]. 13 Procedure PSEARCH is modeled after procedure MSEARCH of <ref> [FRED92] </ref>. An alterna-tive search algorithm in which the for loop is iterated twice, once with T being the multiset of the largest values in S and once with T being the multiset of the smallest values in S is given in [FRED83, FRED84]. <p> 1.47 2.28 1.49 1.52 256 23255 45.96 76.55 169.58 169.42 Times are in milliseconds Table 3: Run times of equal-width width-constrained algorithms (2) The definition of M ij needs to be adjusted to account for the routing heights r i and r j+1 needed at either end of the stack. <ref> [FRED83, FRED84, FRED91, FRED92] </ref> present several refinements of the basic parametric search technique. These refinements apply to the equal-width width-constrained problem just as well as to the path partitioning problem provided we start with a normalized instance and use the candidate matrix M defined above. <p> To apply these refinements we do not need much development specific to the component stack problem. As a result we do not describe the refined algorithms here. The interested reader is referred to <ref> [FRED83, FRED84, FRED91, FRED92] </ref>.
Reference: [HORO78] <author> E. Horowitz, and S. Sahni, </author> <title> "Fundamentals of Computer Algorithms", </title> <publisher> Computer Science Press, </publisher> <address> Maryland, </address> <year> 1978. </year>
Reference: [LARM90] <author> L. Larmore, D. Gajski and A. Wu, </author> <title> "Layout Placement for Sliced Architecture", </title> <institution> University of California, Irvine, </institution> <type> Technical Report, </type> <year> 1990. </year>
Reference-contexts: 1 Introduction Component stack folding, in the context of bit sliced architectures, was introduced by Larmore, Gajski, and Wu <ref> [LARM90] </ref>. In this paper, they used this model to compile layout for cmos technology. Further applications of the model were considered by Wu and Gajski [WU90]. In the model of [LARM90] and [WU90] the component stack can be folded at only one point. <p> 1 Introduction Component stack folding, in the context of bit sliced architectures, was introduced by Larmore, Gajski, and Wu <ref> [LARM90] </ref>. In this paper, they used this model to compile layout for cmos technology. Further applications of the model were considered by Wu and Gajski [WU90]. In the model of [LARM90] and [WU90] the component stack can be folded at only one point. In addition, it is possible to reorder the components on the stack. A related, yet different, folding model was considered by Paik and Sahni [PAIK93]. <p> In this, no limit is placed on the number of points at which the stack may be folded. Also, component reordering is forbidden. They point out that this model may also be used in the application cited by <ref> [LARM90] </ref> and [WU90]. Furthermore, it accurately models the placement step of the standard cell and sea-of-gates layout algorithms of Shragowitz et al. 1 6 C 1 C n r i 1 +1 Interstack routing (reproduced from [PAIK93]) [SHRA88, SHRA90].
Reference: [PAIK93] <author> D. Paik, S. Sahni, </author> <title> "Optimal folding of bit sliced stacks", </title> <journal> IEEE Trans. on CAD of Integrated Circuits and Systems, </journal> <volume> 12, 11, </volume> <month> Nov. </month> <year> 1993, </year> <pages> 1679-1685. </pages>
Reference-contexts: In the model of [LARM90] and [WU90] the component stack can be folded at only one point. In addition, it is possible to reorder the components on the stack. A related, yet different, folding model was considered by Paik and Sahni <ref> [PAIK93] </ref>. In this, no limit is placed on the number of points at which the stack may be folded. Also, component reordering is forbidden. They point out that this model may also be used in the application cited by [LARM90] and [WU90]. <p> Furthermore, it accurately models the placement step of the standard cell and sea-of-gates layout algorithms of Shragowitz et al. 1 6 C 1 C n r i 1 +1 Interstack routing (reproduced from <ref> [PAIK93] </ref>) [SHRA88, SHRA90]. Formally, a component stack is comprised of variable height and variable width components C 1 ; C 2 ; : : : ; C n stacked one on top of the other. <p> 4 log 2 n) O (n 4 log 2 n) Variable heights and widths, height constrained O (n 5 log n) O (n 5 log n) Variable heights and widths, width constrained O (n 5 log 2 n) O (n 5 log 2 n) Table 1: Summary of results of <ref> [PAIK93] </ref> (reproduced from [PAIK93]) folded may be limited (and known in advance) and we are to minimize the width (height). Several versions of folding into height (width) constrained rectangles were considered by Paik and Sahni [PAIK93]. Their results are summarized in Table 1. <p> n) O (n 4 log 2 n) Variable heights and widths, height constrained O (n 5 log n) O (n 5 log n) Variable heights and widths, width constrained O (n 5 log 2 n) O (n 5 log 2 n) Table 1: Summary of results of <ref> [PAIK93] </ref> (reproduced from [PAIK93]) folded may be limited (and known in advance) and we are to minimize the width (height). Several versions of folding into height (width) constrained rectangles were considered by Paik and Sahni [PAIK93]. Their results are summarized in Table 1. <p> log 2 n) O (n 5 log 2 n) Table 1: Summary of results of <ref> [PAIK93] </ref> (reproduced from [PAIK93]) folded may be limited (and known in advance) and we are to minimize the width (height). Several versions of folding into height (width) constrained rectangles were considered by Paik and Sahni [PAIK93]. Their results are summarized in Table 1. In this paper we consider two of the problems considered in [PAIK93]: (1) Equal-width, height-constrained with routing area at stack ends. For this problem, the algorithm of [PAIK93] runs in O (n 2 ) time. <p> Several versions of folding into height (width) constrained rectangles were considered by Paik and Sahni <ref> [PAIK93] </ref>. Their results are summarized in Table 1. In this paper we consider two of the problems considered in [PAIK93]: (1) Equal-width, height-constrained with routing area at stack ends. For this problem, the algorithm of [PAIK93] runs in O (n 2 ) time. We develop an O (n) algorithm. (2) Equal-width, width-constrained with routing area at stack ends. We develop a series of four algorithms for this problem. <p> Several versions of folding into height (width) constrained rectangles were considered by Paik and Sahni <ref> [PAIK93] </ref>. Their results are summarized in Table 1. In this paper we consider two of the problems considered in [PAIK93]: (1) Equal-width, height-constrained with routing area at stack ends. For this problem, the algorithm of [PAIK93] runs in O (n 2 ) time. We develop an O (n) algorithm. (2) Equal-width, width-constrained with routing area at stack ends. We develop a series of four algorithms for this problem. <p> The algorithm is given in Figure 6. From the correctness of procedure Normalize, it follows that a minimum width folding 9 n <ref> [PAIK93] </ref> Figure 6 16 0.11 0.05 256 24.85 0.52 Times are in milliseconds Table 2: Comparison of equal-width height-constrained algorithms of the normalized instance is also a minimum width folding of the initial instance. <p> Note that while we are able to solve the equal-width height-constrained problem in linear time using a combination of normalizing and the greedy method, the algorithm of <ref> [PAIK93] </ref> uses dynamic programming on the unnormalized instance and takes O (n 2 ) time. In Table 2, we give the observed run times of the two algorithms. These were obtained by running C programs on a SUN 4 workstation. <p> In Table 2, we give the observed run times of the two algorithms. These were obtained by running C programs on a SUN 4 workstation. As is evident, our algorithm is considerably superior to that of <ref> [PAIK93] </ref> even on small instances. 4 Parametric Search In this section, we provide an overview of parametric search. The overview relies heavily on the developments provided by Frederickson and Johnson [FRED83, FRED84] and Frederick-son [FRED91, FRED92]. <p> The differences are that (1) We need to normalize the component stack before parametric search can be used. and, 15 n <ref> [PAIK93] </ref> O (n log n) O (n log log n) O (n log fl n) O (n) 16 4.9 1.47 2.28 1.49 1.52 256 23255 45.96 76.55 169.58 169.42 Times are in milliseconds Table 3: Run times of equal-width width-constrained algorithms (2) The definition of M ij needs to be adjusted <p> For comparison purposes, the O (n 3 ) dynamic programming algorithm of <ref> [PAIK93] </ref> was also programmed. The run time performance of these five algorithms is given in Table 3. These times represent the average time for ten instances of each size. The algorithm of [PAIK93] takes much more time than each of the parametric search algorithms. <p> For comparison purposes, the O (n 3 ) dynamic programming algorithm of <ref> [PAIK93] </ref> was also programmed. The run time performance of these five algorithms is given in Table 3. These times represent the average time for ten instances of each size. The algorithm of [PAIK93] takes much more time than each of the parametric search algorithms. However, within the class of parametric search algorithms, the O (n log n) one is fastest in the tested problem size range. This may be attributed to the increased overhead associated with the remaining algorithms. <p> We have developed a linear time algorithm for the equal-width height-constrained problem. This compares very favorably (both analytically and experimentally) with the O (n 2 ) dynamic programming algorithm of <ref> [PAIK93] </ref>. For the equal-width width-constrained problem we have developed four algorithms of complexity O (n log n), O (n log log n), O (n log fl n), and O (n), respectively. All compare very favorably with the O (n 3 ) dynamic programming algorithm of [PAIK93]. <p> ) dynamic programming algorithm of <ref> [PAIK93] </ref>. For the equal-width width-constrained problem we have developed four algorithms of complexity O (n log n), O (n log log n), O (n log fl n), and O (n), respectively. All compare very favorably with the O (n 3 ) dynamic programming algorithm of [PAIK93]. Experimental results indicate that the O (n log n) algorithm performs best on practical size instances. 17
Reference: [SHRA88] <author> E. Shragowitz, L. Lin, S. Sahni, </author> <title> "Models and algorithms for structured layout", Computer Aided Design, </title> <journal> Butterworth & Co, </journal> <volume> 20, 5, </volume> <year> 1988, </year> <pages> 263-271. </pages>
Reference-contexts: Furthermore, it accurately models the placement step of the standard cell and sea-of-gates layout algorithms of Shragowitz et al. 1 6 C 1 C n r i 1 +1 Interstack routing (reproduced from [PAIK93]) <ref> [SHRA88, SHRA90] </ref>. Formally, a component stack is comprised of variable height and variable width components C 1 ; C 2 ; : : : ; C n stacked one on top of the other.
Reference: [SHRA90] <author> E. Shragowitz, J. Lee, and S. Sahni, </author> <title> "Placer-router for sea-of-gates design style", </title> <booktitle> in Progress in computer aided VLSI design, </booktitle> <editor> Ed. G.Zobrist, Ablex Publishing, </editor> <volume> Vol 2, </volume> <year> 1990, </year> <pages> 43-92. </pages>
Reference-contexts: Furthermore, it accurately models the placement step of the standard cell and sea-of-gates layout algorithms of Shragowitz et al. 1 6 C 1 C n r i 1 +1 Interstack routing (reproduced from [PAIK93]) <ref> [SHRA88, SHRA90] </ref>. Formally, a component stack is comprised of variable height and variable width components C 1 ; C 2 ; : : : ; C n stacked one on top of the other.
Reference: [WU90] <author> A. Wu, and D. Gajski, </author> <title> "Partitioning Algorithms for Layout Synthesis from Register-Transfer Netlists", </title> <booktitle> Proc. of International Conference on Computer Aided Design, </booktitle> <month> November </month> <year> 1990, </year> <pages> pp. 144-147. 18 </pages>
Reference-contexts: 1 Introduction Component stack folding, in the context of bit sliced architectures, was introduced by Larmore, Gajski, and Wu [LARM90]. In this paper, they used this model to compile layout for cmos technology. Further applications of the model were considered by Wu and Gajski <ref> [WU90] </ref>. In the model of [LARM90] and [WU90] the component stack can be folded at only one point. In addition, it is possible to reorder the components on the stack. A related, yet different, folding model was considered by Paik and Sahni [PAIK93]. <p> In this paper, they used this model to compile layout for cmos technology. Further applications of the model were considered by Wu and Gajski <ref> [WU90] </ref>. In the model of [LARM90] and [WU90] the component stack can be folded at only one point. In addition, it is possible to reorder the components on the stack. A related, yet different, folding model was considered by Paik and Sahni [PAIK93]. <p> In this, no limit is placed on the number of points at which the stack may be folded. Also, component reordering is forbidden. They point out that this model may also be used in the application cited by [LARM90] and <ref> [WU90] </ref>. Furthermore, it accurately models the placement step of the standard cell and sea-of-gates layout algorithms of Shragowitz et al. 1 6 C 1 C n r i 1 +1 Interstack routing (reproduced from [PAIK93]) [SHRA88, SHRA90].
References-found: 10

