URL: http://atb-www.larc.nasa.gov/ftp/larc/fp_div/fmcad96pre.ps
Refering-URL: http://www.csl.sri.com/pvs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: p.s.miner@larc.nasa.gov  E-mail: leathrum@ee.odu.edu  
Phone: 2  
Title: Verification of IEEE Compliant Subtractive Division Algorithms To appear in FMCAD '96  
Author: Paul S. Miner and James F. Leathrum, Jr. 
Address: Hampton VA 23681-0001 USA,  Norfolk VA 23529 USA,  
Affiliation: 1 NASA Langley Research Center,  Old Dominion University, Department of Electrical and Computer Engineering,  
Abstract: A parameterized definition of subtractive floating point division algorithms is presented and verified using PVS. The general algorithm is proven to satisfy a formal definition of an IEEE standard for floating point arithmetic. The utility of the general specification is illustrated using a number of different instances of the general algorithm.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Mark D. Aagaard and Carl-Johan H. Seger. </author> <title> The formal verification of a pipelined double-precision IEEE floating-point multiplier. </title> <booktitle> In Proceedings 1995 IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <pages> pages 7-10, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: In addition, the verifications guarantee that all intermediate results of the algorithms fit the datapath of the existing floating point hardware. Aagaard and Seger employ a combination of theorem proving and model-checking techniques to verify a floating point multiplier against a formal definition of IEEE multiplication <ref> [1] </ref>. Our work is a generalization of the Rue, Srivas, and Shankar verification. In addition, to the SRT algorithms, our verification encompasses most of the algorithms presented in [6].
Reference: 2. <author> Geoff Barrett. </author> <title> A formal approach to rounding. </title> <booktitle> In Proceedings 8th Symposium on Computer Arithmetic, </booktitle> <pages> pages 247-254, </pages> <year> 1987. </year>
Reference-contexts: be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . [7, 8] Barrett manually verified a general rounding algorithm with respect to a Z formalization of IEEE 754 <ref> [2, 3] </ref>. When Barrett performed his verification, there was no machine assisted reasoning for the Z specification language. Some tools for machine assisted application of Z have recently been developed [14].
Reference: 3. <author> Geoff Barrett. </author> <title> Formal methods applied to a floating-point number system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(5) </volume> <pages> 611-621, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . [7, 8] Barrett manually verified a general rounding algorithm with respect to a Z formalization of IEEE 754 <ref> [2, 3] </ref>. When Barrett performed his verification, there was no machine assisted reasoning for the Z specification language. Some tools for machine assisted application of Z have recently been developed [14].
Reference: 4. <author> Bhaskar Bose. </author> <title> DRS derivational reasoning system: A digital design derivation system for hardware synthesis. </title> <editor> In T. Hilburn, G.Suski, and J. Zalewski, editors, </editor> <title> Safety and Reliability in Emerging Control Technologies. </title> <publisher> Elsevier Science Publishers, Oxford, </publisher> <address> UK, </address> <year> 1996. </year> <note> ISBN 0 08 042610 7, to be published. </note>
Reference-contexts: With that in mind, the general algorithm was presented in a standard form that can be easily transformed to an equivalent tail-recursive description [11]. 13 This provides a top-level specification for deriving a hardware realization using a transformational system such as DRS <ref> [4] </ref>. This process has been tested with the general subtractive division algorithms presented in this paper. The work presented here is a major step toward establishing an environment conducive to development of formally verified floating point hardware.
Reference: 5. <author> E. M. Clarke, S. M. German, and X. Zhao. </author> <title> Verifying the SRT division algorithm using theorem proving techniques. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Machine assisted reasoning is crucial to prevent such errors. Two recent verifications of Taylor's SRT divider [20] illustrate how theorem proving techniques can be used to prevent omissions in lookup tables similar to that employed by the Pentium <ref> [5, 18] </ref>. These verifications describe a relationship from a verified algorithm to a hardware design. In order to complete the verification, it is necessary to relate the algorithm to a specification of the floating point operation. <p> In response to the flaw in the Pentium [21], several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [20] radix-4 SRT division circuit <ref> [5] </ref>. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar [18] generalize this work using the Prototype Verification System (PVS [17]).
Reference: 6. <author> Milos D. Ercegovac and Tomas Lang. </author> <title> Division and Square Root: Digit-Recurrence Algorithms and Implementations. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Our work is a generalization of the Rue, Srivas, and Shankar verification. In addition, to the SRT algorithms, our verification encompasses most of the algorithms presented in <ref> [6] </ref>. In addition, our verification includes a formal path relating the algorithm to the IEEE standard. 2.1 Brief introduction to PVS PVS [17] is a verification system that provides support for general purpose theorem proving. The specification language is a higher order logic augmented with dependent types. <p> Multiplicative algorithms, such as Goldschmidt's Algorithm or Newton-Raphson iterations provide fewer iterations, but the operations in each iteration grow increasingly complex. Ercegovac and Lang present a detailed study of subtractive algorithms for both division and square root <ref> [6] </ref>. The general division algorithm is presented in PVS providing a parameterized class of verified subtractive division algorithms. 3.1 General algorithm definition Subtractive algorithms generate one quotient digit per iteration. <p> Ercego--vac and Lang present a series of interrelated factors which differentiate subtractive division algorithms: the radix (r), the quotient-digit set (fa; a + 1; :::; 1; 0; 1; :::; a 1; ag), the range of the divisor (b), and the quotient-digit select function (qs) <ref> [6] </ref>. These factors are all parameters to the general division theory. <p> A quotient selection function that uses an approximation of p that is either exact, or underestimated. Examples include designs that compute an estimate of the next remainder as in Taylor's circuit [20] (verified in [18]), or use a carry-save adder for the computation of the partial remainder <ref> [6] </ref> 2. A quotient selection function that uses an over approximation of p. This is the case if the partial remainder is computed using a signed-digit adder [6] 3. A selection function where the approximation error is towards zero. In this case, the lookup table is folded in half. <p> the next remainder as in Taylor's circuit [20] (verified in [18]), or use a carry-save adder for the computation of the partial remainder <ref> [6] </ref> 2. A quotient selection function that uses an over approximation of p. This is the case if the partial remainder is computed using a signed-digit adder [6] 3. A selection function where the approximation error is towards zero. In this case, the lookup table is folded in half. The verification amounts to proving that each quotient digit select function satisfies the type constraints of qs type.
Reference: 7. <author> IEEE-754. </author> <title> Standard for Binary Floating-Point Arithmetic, </title> <booktitle> 1985. </booktitle> <address> ANSI/IEEE Std 754-1985. </address>
Reference-contexts: These verifications describe a relationship from a verified algorithm to a hardware design. In order to complete the verification, it is necessary to relate the algorithm to a specification of the floating point operation. Our work provides a link between the IEEE floating point standards <ref> [7, 8] </ref> and a class of verified division algorithms. A strength of theorem prover based verification is that it allows verification of classes of algorithms. Once a class is verified with respect to the standard, it can be used routinely in the development of verified hardware. <p> The IEEE standards for floating point arithmetic unambiguously state that each operation shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . <ref> [7, 8] </ref> Barrett manually verified a general rounding algorithm with respect to a Z formalization of IEEE 754 [2, 3]. When Barrett performed his verification, there was no machine assisted reasoning for the Z specification language. Some tools for machine assisted application of Z have recently been developed [14]. <p> The verified rounding scheme is applicable for all floating-point algorithms. In addition, the theory mapping the standard to the general subtractive algorithm includes a number of intermediate results that apply to all floating point division algorithms. 6 4.1 Rounding scheme The IEEE Standards for floating-point arithmetic <ref> [7, 8] </ref> require support for four rounding modes. The default mode is round to nearest even, and requires that the returned value be the floating point number nearest to the exact result.
Reference: 8. <author> IEEE-854. </author> <title> Standard for Radix-Independent Floating-Point Arithmetic, </title> <booktitle> 1987. </booktitle> <address> ANSI/IEEE Std 854-1987. </address>
Reference-contexts: These verifications describe a relationship from a verified algorithm to a hardware design. In order to complete the verification, it is necessary to relate the algorithm to a specification of the floating point operation. Our work provides a link between the IEEE floating point standards <ref> [7, 8] </ref> and a class of verified division algorithms. A strength of theorem prover based verification is that it allows verification of classes of algorithms. Once a class is verified with respect to the standard, it can be used routinely in the development of verified hardware. <p> The IEEE standards for floating point arithmetic unambiguously state that each operation shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . <ref> [7, 8] </ref> Barrett manually verified a general rounding algorithm with respect to a Z formalization of IEEE 754 [2, 3]. When Barrett performed his verification, there was no machine assisted reasoning for the Z specification language. Some tools for machine assisted application of Z have recently been developed [14]. <p> The verified rounding scheme is applicable for all floating-point algorithms. In addition, the theory mapping the standard to the general subtractive algorithm includes a number of intermediate results that apply to all floating point division algorithms. 6 4.1 Rounding scheme The IEEE Standards for floating-point arithmetic <ref> [7, 8] </ref> require support for four rounding modes. The default mode is round to nearest even, and requires that the returned value be the floating point number nearest to the exact result.
Reference: 9. <author> J. Harrison. </author> <title> Floating point verification in HOL. </title> <editor> In E.T. Schubert, P.J. Wind-ley, and J. Alves-Foss, editors, </editor> <booktitle> Proceedings 8th International Workshop on Higher Order Logic Theorem Proving and its Applications, volume 971 of Lecture Notes in Computer Science, </booktitle> <pages> pages 186-199, </pages> <address> Aspen Grove, UT, USA, September 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: They do not address the issue of relating the algorithms to a formal definition of floating point operations. Harrison has presented a verification of two floating point algorithms; square root, and a CORDIC [23] natural logarithm algorithm <ref> [9] </ref>. For both algorithms, Harrison relates the proofs to a floating point interpretation. Although he does not present hardware descriptions, he does address some of the preliminary error analysis necessary to provide correct rounding.
Reference: 10. <author> J. O'Leary, M. Leeser, J. Hickey, and M. Aagaard. </author> <title> Non-restoring integer square root: A case study in design by principled optimization. </title> <editor> In T. Kropf and R. Kumar, editors, </editor> <booktitle> Proc. 2nd International Conference on Theorem Provers in Circuit Design (TPCD94), volume 901 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71, </pages> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer Verlag. published 1995. </note>
Reference-contexts: The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification (using Nuprl) of a binary non-restoring square root algorithm and its implementation <ref> [10, 13] </ref>. Verkest, et al. present a similar verification (using nqthm) of a binary non-restoring division algorithm [22]. In response to the flaw in the Pentium [21], several researchers investigated theorem prover based verifications of SRT division hardware.
Reference: 11. <author> Steven D. Johnson. </author> <title> Synthesis of Digital Design from Recursion Equations. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1984. </year> <note> ACM Distinguished Dissertation 1984. </note>
Reference-contexts: The ultimate goal of the work is to assist in the development of verified hardware. With that in mind, the general algorithm was presented in a standard form that can be easily transformed to an equivalent tail-recursive description <ref> [11] </ref>. 13 This provides a top-level specification for deriving a hardware realization using a transformational system such as DRS [4]. This process has been tested with the general subtractive division algorithms presented in this paper.
Reference: 12. <author> Israel Koren. </author> <title> Computer Arithmetic Algorithms. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: number with at most p base-b digits of precision using the following function: Definition 10. round scaled (z; mode) ^= round (z b p1e (z) ; mode) b e (z)(p1) A common algorithm for implementing IEEE compliant rounding to p digits of precision uses two extra digits and a sticky-flag <ref> [12] </ref>. The first extra digit is called the guard digit and ensures that the computed result can be normalized while preserving p digits of precision. This is necessary for multiplication and division algorithms.
Reference: 13. <author> M. Leeser and J. O'Leary. </author> <title> Verification of a subtractive radix-2 square root algorithm and implementation. </title> <booktitle> In Proceedings International Conference on Computer Design 1995 (ICCD '95), </booktitle> <pages> pages 526-531, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification (using Nuprl) of a binary non-restoring square root algorithm and its implementation <ref> [10, 13] </ref>. Verkest, et al. present a similar verification (using nqthm) of a binary non-restoring division algorithm [22]. In response to the flaw in the Pentium [21], several researchers investigated theorem prover based verifications of SRT division hardware.
Reference: 14. <author> Irwin Meisels and Mark Saaltink. </author> <title> The Z/EVES reference manual (draft). </title> <type> Technical Report TR-95-5493-03, </type> <institution> ORA Canada, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: When Barrett performed his verification, there was no machine assisted reasoning for the Z specification language. Some tools for machine assisted application of Z have recently been developed <ref> [14] </ref>. Thus far, these have not been applied to floating point verification. 2 Recently, the microcode for the floating point division and square root al-gorithms of the AMD5 K 86 TM microprocessor has been mechanically verified using the ACL2 theorem prover [16, 19].
Reference: 15. <author> Paul S. Miner. </author> <title> Defining the IEEE-854 floating-point standard in PVS. </title> <type> Technical Memorandum 110167, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: This does not constitute a full proof of compliance, it just illustrates how non-exceptional cases of division can be realized. This verification step is performed with respect to a formal specification of IEEE 854 defined using PVS <ref> [15] </ref>. The verification is performed in two stages. First, a generalization of the basic guard, round, and sticky bit rounding algorithm is shown to satisfy the requirements of the standard. Then, the general subtractive algorithm is shown to provide sufficient information to utilize this rounding scheme. <p> The fractional part of a real number z is defined by fzg ^= z bzc The next two definitions are from Miner's PVS formalization of IEEE 854 <ref> [15] </ref>. <p> For normal floating point numbers x and y such that E min E x E y Adj (x; y) E max fp div (x; y; mode) = div algorithm (x; y; mode) Function fp div defines the floating point division operator required by the IEEE standard <ref> [15] </ref>. The first part of the proof consists of showing that the restrictions on the exponents of x and y ensure that the result of fp div returns a normal floating point number.
Reference: 16. <author> J Strother Moore, Tom Lynch, and Matt Kaufmann. </author> <title> A mechanically checked proof of the correctness of the kernel of the AMD5 k 86 floating point division algorithm. </title> <note> (Submitted), URL:http://devil.ece.utexas.edu:80/~lynch/divide/- divide.html, </note> <month> March </month> <year> 1996. </year>
Reference-contexts: Thus far, these have not been applied to floating point verification. 2 Recently, the microcode for the floating point division and square root al-gorithms of the AMD5 K 86 TM microprocessor has been mechanically verified using the ACL2 theorem prover <ref> [16, 19] </ref>. Both algorithms assume correct hardware for floating point multiplication, addition, and subtraction. Both verifications include detailed analysis of rounding and proof that the delivered result is rounded in accordance with the IEEE standard.
Reference: 17. <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar [18] generalize this work using the Prototype Verification System (PVS <ref> [17] </ref>). They present a general verification of arbitrary radix SRT division algorithms, instantiate their theory with Taylor's radix-4 SRT division circuit, and verify a description of the hardware. Included in their work is a technique to verify a concrete representation of the lookup table. <p> Our work is a generalization of the Rue, Srivas, and Shankar verification. In addition, to the SRT algorithms, our verification encompasses most of the algorithms presented in [6]. In addition, our verification includes a formal path relating the algorithm to the IEEE standard. 2.1 Brief introduction to PVS PVS <ref> [17] </ref> is a verification system that provides support for general purpose theorem proving. The specification language is a higher order logic augmented with dependent types. Theories can be parameterized, and the dependent type mechanism allows for stating arbitrary constraints on theory parameters.
Reference: 18. <author> H. Rue, N. Shankar, and M. K. Srivas. </author> <title> Modular verification of SRT division. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science, </booktitle> <pages> pages 123-134, </pages> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Machine assisted reasoning is crucial to prevent such errors. Two recent verifications of Taylor's SRT divider [20] illustrate how theorem proving techniques can be used to prevent omissions in lookup tables similar to that employed by the Pentium <ref> [5, 18] </ref>. These verifications describe a relationship from a verified algorithm to a hardware design. In order to complete the verification, it is necessary to relate the algorithm to a specification of the floating point operation. <p> Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [20] radix-4 SRT division circuit [5]. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar <ref> [18] </ref> generalize this work using the Prototype Verification System (PVS [17]). They present a general verification of arbitrary radix SRT division algorithms, instantiate their theory with Taylor's radix-4 SRT division circuit, and verify a description of the hardware. <p> The tables developed are for 1. A quotient selection function that uses an approximation of p that is either exact, or underestimated. Examples include designs that compute an estimate of the next remainder as in Taylor's circuit [20] (verified in <ref> [18] </ref>), or use a carry-save adder for the computation of the partial remainder [6] 2. A quotient selection function that uses an over approximation of p. This is the case if the partial remainder is computed using a signed-digit adder [6] 3. <p> The verification of the lookup tables requires a little more effort. The process of verifying lookup tables in PVS was first illustrated by Rue, Srivas, and Shankar <ref> [18] </ref> and repeated here with respect to the general division algorithm. However, the development of two new lookup tables proved insightful in demonstrating the usefulness of PVS in the design process. Not only were omissions from the table detected, but PVS allowed the faster development of new tables. <p> However, the development of two new lookup tables proved insightful in demonstrating the usefulness of PVS in the design process. Not only were omissions from the table detected, but PVS allowed the faster development of new tables. Each table was developed starting from the base table in <ref> [18] </ref> and then modified to meet the new requirements. PVS was used to indicate which table entries were incorrect under the new specifications, allowing the designer to easily modify the table.
Reference: 19. <author> David M. Russinoff. </author> <title> A mechanically checked proof of correctness of the AMD K5 floating-point square root algorithm. </title> <type> unpublished manuscript, </type> <month> July </month> <year> 1996. </year>
Reference-contexts: Thus far, these have not been applied to floating point verification. 2 Recently, the microcode for the floating point division and square root al-gorithms of the AMD5 K 86 TM microprocessor has been mechanically verified using the ACL2 theorem prover <ref> [16, 19] </ref>. Both algorithms assume correct hardware for floating point multiplication, addition, and subtraction. Both verifications include detailed analysis of rounding and proof that the delivered result is rounded in accordance with the IEEE standard.
Reference: 20. <author> George S. Taylor. </author> <title> Compatible hardware for division and square root. </title> <booktitle> In Proceedings 5th Symposium on Computer Arithmetic, </booktitle> <pages> pages 127-134, </pages> <year> 1981. </year>
Reference-contexts: This is particularly true if the flaw is in a region of the design that is thought to be unreachable. Machine assisted reasoning is crucial to prevent such errors. Two recent verifications of Taylor's SRT divider <ref> [20] </ref> illustrate how theorem proving techniques can be used to prevent omissions in lookup tables similar to that employed by the Pentium [5, 18]. These verifications describe a relationship from a verified algorithm to a hardware design. <p> Verkest, et al. present a similar verification (using nqthm) of a binary non-restoring division algorithm [22]. In response to the flaw in the Pentium [21], several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's <ref> [20] </ref> radix-4 SRT division circuit [5]. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar [18] generalize this work using the Prototype Verification System (PVS [17]). <p> The tables developed are for 1. A quotient selection function that uses an approximation of p that is either exact, or underestimated. Examples include designs that compute an estimate of the next remainder as in Taylor's circuit <ref> [20] </ref> (verified in [18]), or use a carry-save adder for the computation of the partial remainder [6] 2. A quotient selection function that uses an over approximation of p. This is the case if the partial remainder is computed using a signed-digit adder [6] 3.
Reference: 21. <author> V. Pratt. </author> <title> Anatomy of the Pentium bug. </title> <editor> In P.D. Mosses, M. Nielsen, and M.I. Schwartzbach, editors, </editor> <booktitle> TAPSOFT '95: Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-107, </pages> <address> Aarhus, Denmark, May 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: This was made abundantly clear by the infamous bug in the floating point unit of the Intel Pentium (tm) microprocessor. The bug consists of five missing entries in a lookup table. Pratt <ref> [21] </ref> provides a thorough analysis of this error. He provides compelling arguments that a thorough manual analysis of a design may still allow errors to evade detection. This is particularly true if the flaw is in a region of the design that is thought to be unreachable. <p> Leeser, O'Leary, et al. present a verification (using Nuprl) of a binary non-restoring square root algorithm and its implementation [10, 13]. Verkest, et al. present a similar verification (using nqthm) of a binary non-restoring division algorithm [22]. In response to the flaw in the Pentium <ref> [21] </ref>, several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [20] radix-4 SRT division circuit [5].
Reference: 22. <author> D. Verkest, L. Claesen, and H. De Man. </author> <title> A proof of the nonrestoring division algorithm and its implementation on an ALU. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4 </volume> <pages> 5-31, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification (using Nuprl) of a binary non-restoring square root algorithm and its implementation [10, 13]. Verkest, et al. present a similar verification (using nqthm) of a binary non-restoring division algorithm <ref> [22] </ref>. In response to the flaw in the Pentium [21], several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [20] radix-4 SRT division circuit [5].
Reference: 23. <author> J. S. Walther. </author> <title> A unified algorithm for elementary functions. </title> <booktitle> In Proceedings of Spring Joint Computer Conference, </booktitle> <pages> pages 379-385, </pages> <year> 1971. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 15 </title>
Reference-contexts: They do not address the issue of relating the algorithms to a formal definition of floating point operations. Harrison has presented a verification of two floating point algorithms; square root, and a CORDIC <ref> [23] </ref> natural logarithm algorithm [9]. For both algorithms, Harrison relates the proofs to a floating point interpretation. Although he does not present hardware descriptions, he does address some of the preliminary error analysis necessary to provide correct rounding. <p> The most obvious class of algorithms to consider is subtractive square root algorithms. Another good candidate for exploration is whether a similar general schema can be developed for division through multiplication algorithms. Another example to be considered is the generalized CORDIC algorithm <ref> [23] </ref>. The algorithm has already been defined in PVS, and the solutions to the defining 12 CORDIC equations have been verified. These proofs required the addition of some axioms describing properties of trigonometric and hyperbolic functions.
References-found: 23

