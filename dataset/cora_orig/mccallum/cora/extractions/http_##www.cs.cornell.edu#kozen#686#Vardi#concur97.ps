URL: http://www.cs.cornell.edu/kozen/686/Vardi/concur97.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: Email: harel@wisdom.weizmann.ac.il  Email: orna@eecs.berkeley.edu  Email: vardi@cs.rice.edu,  
Phone: 2  3  
Title: On the Complexity of Verifying Concurrent Transition Systems  
Author: David Harel and Orna Kupferman ?? and Moshe Y. Vardi ??? 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: Rehovot 76100, Israel.  Berkeley, Berkeley CA 94720-1770, U.S.A.  Houston, TX 77251-1892, U.S.A.  
Affiliation: 1 Department of Applied Math. Computer Science, The Weizmann Institute,  EECS Department, UC  Rice University, Department of Computer Science,  
Abstract: In implementation verification, we check that an implementation is correct with respect to a specification by checking whether the behaviors of a transition system that models the program's implementation correlate with the behaviors of a transition system that models its specification. In this paper, we investigate the effect of concurrency on the complexity of implementation verification. We consider trace-based and tree-based approaches to the verification of concurrent transition systems, with and without fairness. Our results show that in almost all cases the complexity of the problem is exponentially harder than that of the sequential case. Thus, as in the model-checking verification methodology, the state explosion problem cannot be avoided.
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: We first describe implementation verification in more detail. Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. <ref> [AL91] </ref>). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. [LS84, Kur94]): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. <p> The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair kripke structures. </title> <booktitle> In Proc. 21st ICALP, </booktitle> <address> Jerusalem, </address> <year> 1994. </year>
Reference-contexts: When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the advantage of the trace-based approach reappears [KV96].
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> In Proc. 4th CAV, LNCS 663, </booktitle> <address> Montreal, </address> <year> 1992. </year>
Reference-contexts: When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the advantage of the trace-based approach reappears [KV96].
Reference: [BGS92] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference-contexts: We examine the complexity of the containment and the simulation problems in four different ways: 1. The joint complexity of containment and simulation. This measure considers the complexity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete <ref> [Mil80, BGS92] </ref>, whereas that of containment is PSPACE-complete [SVW87]. 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. <p> Theorem 2. [SVW87, VW94, KV96] The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. <ref> [Mil80, BGS92, KV96] </ref> The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th CAV, </booktitle> <volume> LNCS 818, </volume> <pages> pages 142-155, </pages> <address> Stanford, </address> <year> 1994. </year>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem. <p> Can we do better than this? Can we model-check a concurrent program and avoid the state-explosion problem? Unfortunately, the answer is no. Indeed, model checking of concurrent programs for LTL and CTL is PSPACE-complete even for a fixed formula <ref> [VW94, BVW94] </ref>. Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition.
Reference: [CGL93] <author> E.M. Clarke and O. Grumberg and D. </author> <title> Long. Verification tools for finite-state concurrent systems. In Decade of Concurrency Reflections and Perspectives, </title> <publisher> LNCS 803, </publisher> <pages> pages 124-175, </pages> <year> 1993. </year>
Reference-contexts: Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. Coping with the state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. <ref> [CGL93] </ref>) What about implementation verification? Is the state-explosion problem unavoidable there too? This is the subject of our work. We first describe implementation verification in more detail. Consider an implementation and a specification.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Theorem 8. The simulation problem for concurrent transition systems is EXPTIME-complete. Proof (sketch): Membership in EXPTIME follows from Theorems 1 and 3. To prove hardness in EXPTIME, we carry out a reduction from alternating linear-space-bounded Turing machines, proved to be EXPTIME-hard in <ref> [CKS81] </ref>.
Reference: [DH94] <author> D. Drusinsky and D. Harel. </author> <title> On the power of bounded concurrency I: Finite automata. </title> <journal> Journal of the ACM, </journal> <volume> 41(3) </volume> <pages> 517-539, </pages> <year> 1994. </year>
Reference-contexts: To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in <ref> [Har89, DH94] </ref>, is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no concur-rency, and we call it a sequential transition system. <p> This approach to modeling concurrency, called bounded cooperative concurrency in [Har89, DH94], is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no concur-rency, and we call it a sequential transition system. By <ref> [DH94] </ref>, a concurrent transition system can be translated into a sequential transition system with an exponential blow up in size. Indeed, it is the size of this sequential system that is referred to in current analyses of the complexity of verification. <p> Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level. <p> In the present paper, the power criteria is the complexity of the verification problem. Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying sequential transition systems, and thus the state-explosion problem cannot be avoided. <p> Proof (sketch): Drusinsky and Harel prove the theorem with respect to automata, where the observable events are input to the machine and where equivalence is defined as agreement on the trace set <ref> [DH94] </ref>. Yet, their proof holds also for transition systems with our definition of equivalence (mutual simulation), as follows. Consider a concurrent transition system S with n components. <p> The implementation complexity of the fair-simulation problem for concurrent transition systems is EXPTIME-complete. Proof: Membership in EXPTIME follows from Theorems 5 and 1. Hardness in EXPTIME follows from Theorem 9. ut 6 Discussion Our results are illustrated by the cube figures below, in the style of <ref> [Har89, DH94] </ref>. All the complexities denote tight bounds. We use J to denote joint complexity (and its omission to denote implementation complexity), F to denote fair transition systems (and its omission to denote non-fair ones), and C to denote concurrent transition systems (and its omission to denote sequential ones).
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref> are both PSPACE-complete [KV96]. 4. The implementation complexity of fair containment and fair simulation. Here, the advantage of the trace-based approach reappears [KV96]. <p> Let c and c 0 be configurations in S and S 0 , respectively. A relation H C fi C 0 is a fair-simulation relation from hS; ci to hS 0 ; c 0 i iff the following conditions hold <ref> [GL94] </ref>. 1. H (c; c 0 ). 2. For all configurations a 2 C and a 0 2 C 0 with H (a; a 0 ), we have L (a) = L (a 0 ). 3.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <journal> Sci. Comp. Prog., </journal> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. The basic motivation for this comes from the statecharts of <ref> [Har87] </ref>, which can be viewed as finite automata with both concurrency and hierarchy, though for simplicity we eliminate the hierarchy here. A concurrent transition system consists of components, which model the program's underlying processes. (The analogous parts of a statechart are called orthogonal components in [Har87].) Each component is a state-transition <p> comes from the statecharts of <ref> [Har87] </ref>, which can be viewed as finite automata with both concurrency and hierarchy, though for simplicity we eliminate the hierarchy here. A concurrent transition system consists of components, which model the program's underlying processes. (The analogous parts of a statechart are called orthogonal components in [Har87].) Each component is a state-transition graph. Its states correspond to the possible positions of the process it models, and each state is labeled with the events that occur, or hold, in the corresponding position.
Reference: [Har89] <author> D. Harel. </author> <title> A thesis for bounded concurrency. </title> <booktitle> In Proc. 14th MFOCS, </booktitle> <volume> LNCS 379, </volume> <pages> pages 35-48, </pages> <address> New York, </address> <year> 1989. </year>
Reference-contexts: To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in <ref> [Har89, DH94] </ref>, is the dominating one in research on distributed systems (cf. [Kur94]). A concurrent transition system with a single component models a program with no concur-rency, and we call it a sequential transition system. <p> Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level. <p> In the present paper, the power criteria is the complexity of the verification problem. Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying sequential transition systems, and thus the state-explosion problem cannot be avoided. <p> The implementation complexity of the fair-simulation problem for concurrent transition systems is EXPTIME-complete. Proof: Membership in EXPTIME follows from Theorems 5 and 1. Hardness in EXPTIME follows from Theorem 9. ut 6 Discussion Our results are illustrated by the cube figures below, in the style of <ref> [Har89, DH94] </ref>. All the complexities denote tight bounds. We use J to denote joint complexity (and its omission to denote implementation complexity), F to denote fair transition systems (and its omission to denote non-fair ones), and C to denote concurrent transition systems (and its omission to denote sequential ones).
Reference: [Hen85] <author> M. Hennessy. </author> <title> Algebraic theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [HH94] <author> T. Hirst and D. Harel. </author> <title> On the power of bounded concurrency II: Pushdown automata. </title> <journal> Journal of the ACM, </journal> <volume> 41(3) </volume> <pages> 540-554, </pages> <year> 1994. </year>
Reference-contexts: Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level.
Reference: [HRV90] <author> D. Harel, R. Rosner, and M.Y. Vardi. </author> <title> On the power of bounded concurrency iii: Reasoning about programs. </title> <booktitle> In Proc. 5th LICS, </booktitle> <address> Philadelphia, </address> <year> 1990. </year>
Reference-contexts: Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. In addition, our work continues the study of the power of bounded cooperative concurrency undertaken in <ref> [Har89, DH94, HH94, HRV90] </ref>. the results in these papers show that cooperative concurrency exhibits inherent exponential power. The power criteria considered there are succinctness of finite automata and pushdown automata, and the effect of the succinctness gap on the difficulty of reasoning about transition systems on a propositional level.
Reference: [Koz77] <author> D. Kozen. </author> <title> Lower bounds for natural proof systems. </title> <booktitle> In Proc. 18th FOCS, </booktitle> <pages> pages 254-266, </pages> <year> 1977. </year>
Reference-contexts: Hence, T rejects the empty tape iff S T is empty. ut In view of the known PSPACE lower bound for emptiness in communicating finite state machines <ref> [Koz77] </ref>, our PSPACE lower bound here is not surprising. Note, however, that the bound in [Koz77] does not directly imply our bound here, since concurrent transition systems generate infinite traces. 4 The Simulation Problem Establishing simulation involves only local checks. One could hope that locality circumvents the state-explosion problem. <p> Hence, T rejects the empty tape iff S T is empty. ut In view of the known PSPACE lower bound for emptiness in communicating finite state machines <ref> [Koz77] </ref>, our PSPACE lower bound here is not surprising. Note, however, that the bound in [Koz77] does not directly imply our bound here, since concurrent transition systems generate infinite traces. 4 The Simulation Problem Establishing simulation involves only local checks. One could hope that locality circumvents the state-explosion problem.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. [AL91]). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. <ref> [LS84, Kur94] </ref>): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. At each stage the current implementation is verified to satisfy its specification. <p> One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment <ref> [Kur94] </ref> and tree-based verification corresponds to establishing simulation [Mil71]. As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> To model the cooperation of processes during execution, the transitions are made conditional and can depend on the states of the other components. This approach to modeling concurrency, called bounded cooperative concurrency in [Har89, DH94], is the dominating one in research on distributed systems (cf. <ref> [Kur94] </ref>). A concurrent transition system with a single component models a program with no concur-rency, and we call it a sequential transition system. By [DH94], a concurrent transition system can be translated into a sequential transition system with an exponential blow up in size.
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Verification of fair transition systems. </title> <booktitle> In Proc. 8th CAV, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 372-382. </pages> <institution> Rutgers, </institution> <year> 1996. </year>
Reference-contexts: The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. According to this measure, containment is easier than simulation <ref> [KV96] </ref>. 3. The joint complexity of fair containment and fair simulation. When we consider fair transition systems [MP92], which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. <p> The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete <ref> [KV96] </ref>. 4. The implementation complexity of fair containment and fair simulation. Here, the advantage of the trace-based approach reappears [KV96]. We address the question about the power of concurrency in program verification by examining the four measures when applied to concurrent transition systems. <p> The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete <ref> [KV96] </ref>. 4. The implementation complexity of fair containment and fair simulation. Here, the advantage of the trace-based approach reappears [KV96]. We address the question about the power of concurrency in program verification by examining the four measures when applied to concurrent transition systems. We first define containment and simulation with respect to such systems, and then consider the complexity and the implementation complexity of detecting their presence. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. <p> In the present paper, the power criteria is the complexity of the verification problem. Our results strengthen the observations in <ref> [Har89, DH94, KV96] </ref>. Specifically, the question of whether the exponential nature of concurrency carries over to the verification problem is answered in the affirmative. We show that verifying concurrent transition systems is exponentially harder than verifying sequential transition systems, and thus the state-explosion problem cannot be avoided. <p> This result is robust: It is independent of the verification approach and the fairness constraint under consideration, and remains valid when we consider implementation complexity too. In particular, we show that the fair-containment and fair-simulation problems for concurrent transition systems are EXPSPACE-complete. These results join those of <ref> [KV96] </ref> in questioning the computational superiority of tree-based verification. One exception to the inherent exponential power of cooperative concurrency is the fair-simulation problem for strongly-fair transition systems. While the implementation complexity of the problem is PTIME-complete for sequential transition systems [KV96], we show that it is PSPACE-complete (rather than EXPTIME-complete) for <p> These results join those of <ref> [KV96] </ref> in questioning the computational superiority of tree-based verification. One exception to the inherent exponential power of cooperative concurrency is the fair-simulation problem for strongly-fair transition systems. While the implementation complexity of the problem is PTIME-complete for sequential transition systems [KV96], we show that it is PSPACE-complete (rather than EXPTIME-complete) for concurrent transition systems. <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for <p> Theorem 2. [SVW87, VW94, KV96] The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. <ref> [Mil80, BGS92, KV96] </ref> The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. <p> Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems. Theorem 5. <ref> [KV96] </ref> The fair-simulation problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is PTIME-complete. It follows that, when comparing the trace-based and the tree-based approaches to verification from a complexity-theoretic point to view, there is no clear advantageous approach. <p> Assume that S has n components. Then, following the construction described in the proof of Theorem 1, the system D has k = k 1 k 2 k n states and m = m 1 + m 2 + + m k pairs in its fairness condition. By <ref> [KV96] </ref>, we can translate D to an unconditionally-fair sequential transition system U with k 2 O (m) states. Thus, the size of U is exponential in the size of S. <p> The fair-simulation problem for concurrent transition systems is EXPSPACE-complete. Proof (sketch): Membership in EXPSPACE follows from Theorems 5 and 1. To prove hardness in EXPSPACE we do a reduction from exponential-space-bounded Turing machines. Our reduction is similar to the reduction described in <ref> [KV96] </ref> for proving a lower bound to the fair-simulation problem for sequential transition systems. The only change is that while there the Turing machines are polynomial-space bounded, yielding a PSPACE lower bound, here the machines are exponential-space bounded, yielding an EXPSPACE lower bound.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proc. 12th POPL, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <year> 1985. </year>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem.
Reference: [LPS81] <author> D. Lehman, A. Pnueli, and J. Stavi. Impartiality, </author> <title> justice, and fairness the ethics of concurrent termination. </title> <booktitle> In Proc. 8th ICALP, </booktitle> <volume> LNCS 115, </volume> <pages> pages 264-277. </pages> <year> 1981. </year>
Reference-contexts: We then turn to defining fair-containment and fair-simulation with respect to concurrent transition systems, and study their complexities too, employing unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, MP92] </ref>. Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation verification in [Mil80, BGS92, KV96].
Reference: [LS84] <author> S.S. Lam and A.U. Shankar. </author> <title> Protocol verification via projection. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 325-342, </pages> <year> 1984. </year>
Reference-contexts: Consider an implementation and a specification. Both describe possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. [AL91]). This basic notion suggests a top-down method for design development, called hierarchical refinement (cf. <ref> [LS84, Kur94] </ref>): Starting with a highly abstract specification, we construct a sequence of behavior descriptions, each of which refers to its predecessor as a specification, and is thus less abstract than the predecessor. At each stage the current implementation is verified to satisfy its specification.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. 2nd IJCAI, </booktitle> <pages> pages 481-489, </pages> <year> 1971. </year>
Reference-contexts: One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment [Kur94] and tree-based verification corresponds to establishing simulation <ref> [Mil71] </ref>. As shown by Milner [Mil80], while simulation implies containment, the opposite direction is not true. We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> Let c and c 0 be configurations of S and S 0 , respectively. A relation H C fi C 0 is a simulation relation from hS; ci to hS 0 ; c 0 i iff the following conditions hold <ref> [Mil71] </ref>. 1. H (c; c 0 ). 2. For all configurations a 2 C and a 0 2 C 0 with H (a; a 0 ), we have L (a) = L (a 0 ). 3.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <publisher> LNCS 92, Springer Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: One justification for this is the fact that the more concrete implementation is typically defined over a wider set of variables than the more abstract specification. With this interpretation, trace-based verification corresponds to establishing containment [Kur94] and tree-based verification corresponds to establishing simulation [Mil71]. As shown by Milner <ref> [Mil80] </ref>, while simulation implies containment, the opposite direction is not true. We model concurrent programs (and hence implementations and specifications) by what we shall call concurrent transition systems. <p> We examine the complexity of the containment and the simulation problems in four different ways: 1. The joint complexity of containment and simulation. This measure considers the complexity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete <ref> [Mil80, BGS92] </ref>, whereas that of containment is PSPACE-complete [SVW87]. 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation verification in <ref> [Mil80, BGS92, KV96] </ref>. Unlike these papers, our complexity analysis addresses the state-explosion issue explicitly, by taking the size to be that of the concurrent systems themselves and not their sequential equivalents. <p> Theorem 2. [SVW87, VW94, KV96] The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. <ref> [Mil80, BGS92, KV96] </ref> The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrecny. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clifs, </address> <year> 1989. </year>
Reference-contexts: The exact notion of correct implementation then depends on how we interpret correlation. Numerous proposals for this have been made and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>. In this paper we adopt a simple interpretation, taking correlation to mean equivalence with respect to the variables joint to the implementation and the specification.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Since the implementation is typically much larger than the specification, this measure is of particular interest. According to this measure, containment is easier than simulation [KV96]. 3. The joint complexity of fair containment and fair simulation. When we consider fair transition systems <ref> [MP92] </ref>, which enable the description of behaviors that satisfy both liveness and safety properties, containment and simulation are revised to consider only the fair computations of the implementation and the specification. The resulting problems, of fair containment and fair simulation [BBLS92, ASB + 94, GL94] are both PSPACE-complete [KV96]. 4. <p> We then turn to defining fair-containment and fair-simulation with respect to concurrent transition systems, and study their complexities too, employing unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, MP92] </ref>. Before saying a little more about the results themselves, we clarify what we feel are the paper's two main contributions. First, it continues the study of implementation verification in [Mil80, BGS92, KV96].
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: The joint complexity of containment and simulation. This measure considers the complexity in terms of both the implementation and the specification. The joint complexity of simulation is PTIME-complete [Mil80, BGS92], whereas that of containment is PSPACE-complete <ref> [SVW87] </ref>. 2. The implementation complexity of containment and simulation. This measure considers the complexity in terms of the implementation, assuming the specification is fixed. Since the implementation is typically much larger than the specification, this measure is of particular interest. <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: For example, in the case of the temporal logics LTL and CTL, model checking can be carried out in space that is polynomial in n log m, where n is the length of the formula and m is the size of the graph modeling the program <ref> [LP85, VW94, BVW94] </ref>. Keeping in mind that the formulas are usually small, it seems that model checking is easy and tractable. It suffers, however, acutely from the so-called state-explosion problem. <p> Can we do better than this? Can we model-check a concurrent program and avoid the state-explosion problem? Unfortunately, the answer is no. Indeed, model checking of concurrent programs for LTL and CTL is PSPACE-complete even for a fixed formula <ref> [VW94, BVW94] </ref>. Hence, in the worst case we might need to traverse the exceedingly large state space introduced by the parallel composition. <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for <p> Theorem 2. <ref> [SVW87, VW94, KV96] </ref> The containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete. Theorem 3. [Mil80, BGS92, KV96] The simulation problem for sequential transition systems is PTIME-complete; The implementation complexity of the problem is PTIME-complete. Theorem 4. [SVW87, VW94, KV96] The fair-containment problem for sequential transition systems is PSPACE-complete; The implementation complexity of the problem is NLOGSPACE-complete for unconditionally-fair and weakly-fair systems, and is PTIME-complete for strongly-fair systems.
References-found: 26

