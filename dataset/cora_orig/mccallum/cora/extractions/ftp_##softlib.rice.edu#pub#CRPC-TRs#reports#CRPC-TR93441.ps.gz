URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR93441.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Email: vigourou@lip.ens-lyon.fr  
Title: Monitoring of Distributed Memory Multicomputer Programs  
Author: Maurice van Riek Bernard Tourancheau Xavier-Fran~cois Vigouroux 
Keyword: Categories and Subject Descriptor C.1.2 [Multiple Data Stream Architectures] MIMD D.1.3 [Concurrent Programming] D.2.5 [Testing and Debugging] Monitors, Tracing D.2.6 [Programming Environments] D.4.8 [Performance] Measurements, Monitors General Terms Measurement, Performance, Supercomputing. Additional Key words and Phrases Distributed memory systems, collecting runtime information, program execution visualization, performance monitoring, debugging, monitoring environments  
Note: On leave from CNRS-URA 1398,  Supported in part by the National Science Foundation under grant ASC-8715728, the National Science Foundation Science and Technology Center Cooperative Agreement CCR-8809615, the DARPA and ARO under contract DAAL03-91-C-0047, ARCHIPEL SA and MRE under grant 974, research program C 3 the CNRS-NSF grant number 950.223/07 and DRET. btouranc@cs.utk.edu Part of this work was realized when visiting the  
Address: 69364 Lyon Cedex 07, France.  107 Ayres Hall, Knoxville, TN 37996-1301, USA.  69364 Lyon Cedex 07, France.  69364 Lyon Cedex 07, France.  Tennessee.  
Affiliation: Laboratoire de l'Informatique du Parallelisme, CNRS-URA 1398 Ecole Normale Superieure de Lyon,  Department of Computer Science, University of Tennessee  Laboratoire de l'Informatique du Parallelisme, CNRS-URA 1398 Ecole Normale Superieure de Lyon,  Laboratoire de l'Informatique du Parallelisme, Ecole Normale Superieure de Lyon,  CS department of the University of  
Abstract: Programs for distributed memory parallel machines are generally considered to be much more complex than sequential programs. Monitoring systems that collect runtime information about a program execution often prove a valuable help in gaining insight into the behavior of a parallel program and thus can improve its performance. This report describes in a systematic and comprehensive way the issues involved in the monitoring of parallel programs running on distributed memory systems. It aims to provide a structured general approach to the field of monitoring and a guide for further documentation. First the different approaches to parallel monitoring are presented and the problems encountered are discussed and classified. In the second part, the main existing systems are described to provide the user with a feeling for the possibilities and limitations of real tools. 
Abstract-found: 1
Intro-found: 1
Reference: [Abs90] <author> F. Abstreiter. </author> <title> Visualizing and analyzing the runtime behavior of parallel programs. </title> <booktitle> In Burkhart [Bur90], </booktitle> <pages> pages 828-839. </pages>
Reference-contexts: When encoding traces in a verbose manner, text based trace-formats are also space-inefficient. However, this is not necessarily true, when trace-records are encoded as sequences of integers represented in ASCII. Examples of monitoring systems that use text based trace-formats are the ParMod runtime system <ref> [Abs90] </ref> and the PICL instrumented library [GHPW90]. To limit the overhead of the encoding of the trace-records, PICL uses an internal binary trace-format because it is more time efficient. * Binary trace formats, on the other hand, are compact and induce little overhead, because they are fast to encode. <p> A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we
Reference: [Ayd93] <author> R. Aydt. </author> <title> The pablo self-defining data format. </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> March </month> <year> 1993. </year> <note> available by ftp anonymous bugle.cs.uiuc.edu:pub/Release-1.1/Documentation/SDDF.ps.Z. </note>
Reference-contexts: This header contains both the syntactic and the semantic description of the event-records contained in a trace file. A tool reads this header to find out what information is contained in the trace file and where to find it <ref> [PGUB92, RP91, Ayd93] </ref>. * object oriented : Instead of defining a trace-format standard or just a header, the measured trace-formats are considered as a generic abstract data structure. Evaluation tools can only access the measured data via a uniform and standardized set of generic procedures. <p> The data analysis The second part of Pablo is a graphical interface (using Motif) to analyze the data contained in trace files. The link between the instrumentation and the analysis is a trace file following the "self-describing data format" (SDDF) <ref> [Ayd93] </ref>. This meta-format allows for changes in the instrumentation without modifying the analysis tool. Obviously no semantic can be added in the trace file, so every field is recognized by a syntactic analysis.
Reference: [Bat88] <author> P. Bates. </author> <title> Distributed debugging tools for heterogeneous distributed systems. </title> <booktitle> In IEEE, editor, 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 308-315, </pages> <year> 1988. </year>
Reference-contexts: The Event Based Behavioral Abstraction (EBBA) approach is more than simply a way of analyzing event-records, and constitutes a complete high-level approach to debugging [Bat89]. Globally speaking the approach consists of constructing high-level models that describe the expected behavior of the monitored program. When executing a program, EBBA-based tools <ref> [Bat88] </ref> automatically compare the generated runtime information with the expected behavior as described in a model. The differences are analyzed and an interactive tool allows the user to explore these differences. In [CBM90] the use of artificial intelligence techniques for the analysis of runtime information is suggested.
Reference: [Bat89] <author> P. Bates. </author> <title> Debugging heterogeneous distributed systems using event-based models of behaviour. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 11-22, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The SIMPLE environment adopted this approach by integrating the data analysis and graphics package S from AT&T [Moh90]. The Event Based Behavioral Abstraction (EBBA) approach is more than simply a way of analyzing event-records, and constitutes a complete high-level approach to debugging <ref> [Bat89] </ref>. Globally speaking the approach consists of constructing high-level models that describe the expected behavior of the monitored program. When executing a program, EBBA-based tools [Bat88] automatically compare the generated runtime information with the expected behavior as described in a model.
Reference: [BB88] <author> H.-J. Beier and T. Bemmerl. </author> <title> Software monitoring of parallel programs. </title> <editor> In C. R. Jesshope and K. D. Reinartz, editors, </editor> <address> CONPAR 88, Manchester, 1988. </address> <publisher> British Computer Society's Paralle Specialist Group, Cambrige Univerity Press. </publisher>
Reference-contexts: In our set, we will only include atomic events. This is not a restriction since the occurrence of compound events can always be deduced by analyzing the atomic events (see SWM <ref> [BB88] </ref>). Atomic events have the advantage that their detection is relatively easy and often machine independent. * Monitoring the control flow : First of all, we should be able to monitor the flow of control in each of the processors. <p> However, instead of monitoring the electrical signals of the system, the relevant data is written directly into the registers of the hardware monitor. This increases the flexibility and only slows the execution down by about 2% <ref> [BB88] </ref>. 6.4.4 The tools In TOPSYS different tools that allow the observation of the runtime information are provided. These tools provide graphical representations of views of the runtime information. Multiple views from one or multiple tools can be displayed at the same time.
Reference: [BB91] <author> T. Bemmerl and A. Bode. </author> <title> An integrated environment for programming distributed memory multiprocessors. </title> <booktitle> In 2nd European conference on Distributed Memory Computing, </booktitle> <pages> pages 131-142, </pages> <month> April </month> <year> 1991. </year> <month> 46 </month>
Reference-contexts: For a more detailed presentation of TOPSYS refer to <ref> [BBB + 90, BB91, Bem90] </ref>. Currently, an implementation of the MKK kernel exists for the iPSC/2 with both software, hardware and hybrid versions of the monitoring system.
Reference: [BBB + 90] <author> T. Bemmerl, A. Bode, P. Braun, O. Hansen, P. Liksch, and R. Wismuller. </author> <title> TOPSYS tools for parallel systems (user's overview and user's manuals). </title> <type> Technical Report TUM-I9047, </type> <note> SFB-Bericht Nr. 342/25/90 A, </note> <institution> Institut fur Informatik der Technischen Unversitat Munchen, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: In this report, we will concentrate on the monitoring aspects of debugging. For more information about parallel debuggers, the reader should refer to the more specialized publications [PU89, Pan92, LS92a, Cha91]. An example of a debugging oriented monitoring tool is DETOP <ref> [BBB + 90] </ref> of the TOPSYS environment. * Performance monitoring oriented tools tend to gather statistical information (busy and idle times of processors, communication times, amount of messages exchanged, average lengths of messages, etc.) about an execution. <p> For a more detailed presentation of TOPSYS refer to <ref> [BBB + 90, BB91, Bem90] </ref>. Currently, an implementation of the MKK kernel exists for the iPSC/2 with both software, hardware and hybrid versions of the monitoring system. <p> The tools allow the specification of compound events that can be detected by the different monitors (see section 2.7). For a more detailed list of the events that can be monitored with TOPSYS, see <ref> [BBB + 90] </ref>. The monitors TOPSYS offers hardware, software and hybrid monitoring [BLT90]. The interface to the different monitors is the same and their use is therefore interchangeable. <p> Icons have been used extensively to structure access to these different levels of abstraction.Multiple views on the runtime information can be displayed at the same time in either curve diagrams or barcharts. The following measurements are available in PATOP <ref> [BBB + 90] </ref> : At the system level * Idle time of the whole system, * Average percentage of time that tasks spend in ready queues. <p> Percentage of time tasks are waiting in send or receive operations, * CPU usage of each task, * Waiting time at semaphores, * Number of kbytes sent to or received from each mailbox on any node, * Delays of tasks waiting at mailboxes. 39 VISTOP-VISualization TOol for Parallel systems VISTOP <ref> [BBB + 90] </ref> displays the dynamic behavior of concurrent programs running under the distributed operating system kernel MMK. The main idea behind VISTOP is that to understand the behavior of a parallel program, it is crucial to know what communication and synchronization events take place.
Reference: [BD91] <author> G. Burns and R. Daoud. </author> <title> Trollius reference manual for c programmers. Occam User's Group Newsletter, </title> <month> March </month> <year> 1991. </year> <title> Document Series 2/2. </title>
Reference-contexts: possible), efficiency (the impact on the performance of the system should be as little as possible), accuracy (the results should reflect the behavior of applications when run without the monitor). 6.2.3 The global system structure TMON is a hybrid monitor (see 3.5) built on top of the Trollius operating system <ref> [BD91] </ref>. One transputer is assigned as the master (reactive) node and is capable of interrupting all other nodes in the system to start the monitoring simultaneously. By sending commands to this node, the user can control the monitoring. In TMON the "specialized processes" model has been adopted.
Reference: [Bem90] <author> T. </author> <title> Bemmerl. </title> <booktitle> The TOPSYS architecture. In Bukhart [Bur90], </booktitle> <pages> pages 732-743. </pages>
Reference-contexts: For a more detailed presentation of TOPSYS refer to <ref> [BBB + 90, BB91, Bem90] </ref>. Currently, an implementation of the MKK kernel exists for the iPSC/2 with both software, hardware and hybrid versions of the monitoring system.
Reference: [BHL90] <author> T. Bemmerl, O. Hansen, and T. Ludwig. </author> <title> PATOP for performance tuning of parallel programs. </title> <booktitle> In Burkhart [Bur90], </booktitle> <pages> pages 840-851. </pages>
Reference-contexts: These tools provide graphical representations of views of the runtime information. Multiple views from one or multiple tools can be displayed at the same time. Among the tools available in TOPSYS, PATOP and VISTOP will be discussed in more detail here. PATOP-Performance Analysis TOol for Parallel systems PATOP <ref> [BHL90] </ref> is a performance oriented tool that incorporates system, node, and object levels of abstraction. Icons have been used extensively to structure access to these different levels of abstraction.Multiple views on the runtime information can be displayed at the same time in either curve diagrams or barcharts.
Reference: [BL92] <author> T. Bemmerl and T. Ludwig. </author> <title> MMK a distributed operating system kernel with integrated dynamc loadbalancing. </title> <booktitle> In Burkhart [Bur90], </booktitle> <pages> pages 744-755. </pages>
Reference-contexts: Few tools offer the possibility of extensive system event detection. Those tools that do offer this possibility usually use a modified version of the operating system or use available system calls. The MMK kernel of TOPSYS is an example of a tool where the operating system has been modified <ref> [BL92] </ref>. There is also a modification of Intel OS NX/2 tool in [MRR90] and Trollius OS [vRT92c]. In [LCSM92] two classes of events are introduced that group atomic events according to their availability in monitoring tools. <p> The TOPSYS environment is an example of such a system, where one common monitoring system generates runtime information that is used for many different purposes <ref> [BL92] </ref>. In our set, we will only include atomic events. This is not a restriction since the occurrence of compound events can always be deduced by analyzing the atomic events (see SWM [BB88]). <p> To this end, an object-oriented programming model <ref> [BL92] </ref> has been chosen that offers active objects (tasks), communication objects (mailboxes), synchronization objects (semaphores) and storage objects (memory). When using this programming model, the programmer thinks about his parallel program in terms of objects and standard operations upon these objects.
Reference: [BLT90] <author> T. Bemmerl, R. Linfhof, and T. Treml. </author> <title> The distributed monitor system of TOPSYS. </title> <booktitle> In Burkhart [Bur90], </booktitle> <pages> pages 756-765. </pages>
Reference-contexts: Just like an atomic event, a compound event has no duration and is defined by its moment of occurrence which corresponds to the moment when the expression is fulfilled. An activity can be associated with its corresponding duration (see section 5.2). According to <ref> [BLT90] </ref> the necessary operators for combining events are : event e 1 or event e 2 happens : (e 1 _ e 2 ) event e 1 happens before event e 2 : (e 1 ! e 2 ) both events happen in any order : (e 1 ^ e 2 <p> This activity is called clustering (see section 5.2). Most tools do not allow the user to specify compound events because of the complicated detection mechanisms that it requires. TOPSYS (see section 6.4 <ref> [BLT90] </ref> is one of the few monitors that does allow the user-specification of compound events. From a conceptual point of view, atomic events can be divided into three fundamental types of events (see Figure 2). * Execution events trace the flow of control in a process. <p> Although this is traditionally the domain of parallel debuggers, data event detection is easy to implement for simple variables, thus providing a powerful feature at little cost. TOPSYS currently offers the possibility of monitoring the reading and writing of a user-defined variable <ref> [BLT90] </ref>. * Parallelity events deal with the parallelism in distributed programs. They occur when a process interacts with another process. Under normal conditions parallelity events always come in pairs, because a parallelity event in one process induces a parallelity event in another process. <p> The on-chip integration of floating point, memory management and other functional units and the use of pipelining and on-chip caches have led to a hardware observation of the node-processors. Therefore, hardware monitors will probably be integrated on the chip in the future <ref> [BLT90] </ref>. Since much of the information is buried in the chip, often a special version of the node processor is required that provides access to signals in the chip. Figure 13 shows the integration of the TOPSYS hardware monitor into an observed system. <p> Figure 13 shows the integration of the TOPSYS hardware monitor into an observed system. The TOPSYS monitor makes use of a special processor version,which has extra signals added to its pins (the bondout lines in the Figure 9) <ref> [BLT90] </ref>. Processor A D C bondout Monitor D A bondout A D C Node board Probe A C : address-bus : data-bus : control-bus 20 In hardware monitoring, events are detected by matching patterns on the observed lines with predefined patterns. Banks of high-speed comparators are used for this matching. <p> Event-record clustering can, like event-record filtering be done at different levels. * The lowest level is found in hardware monitors that cluster the hits to detect application-level event occurrences <ref> [BLT90] </ref>. * In non-hardware monitors, event-records can be clustered in a distributed manner, during or after the point at which the application process is terminated. <p> The tools allow the specification of compound events that can be detected by the different monitors (see section 2.7). For a more detailed list of the events that can be monitored with TOPSYS, see [BBB + 90]. The monitors TOPSYS offers hardware, software and hybrid monitoring <ref> [BLT90] </ref>. The interface to the different monitors is the same and their use is therefore interchangeable. Due to the clear definition of the monitoring interface, simulations of a program execution can also be used as long as they comply with this interface (see Figure 15).
Reference: [Bur90] <editor> H. Burkhart, editor. </editor> <booktitle> CONPAR 90 - VAPP IV, volume 457 of Lecture Notes in Computer Science, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1990. </year> <note> Springer-Verlag. </note>
Reference: [CBM90] <author> W. Cheung, J. Black, and E. Manning. </author> <title> A framework for distributed debugging. </title> <journal> IEEE Software, </journal> <volume> 7 </volume> <pages> 106-115, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: According to <ref> [CBM90, GMGK84, JLSU87, Mil92] </ref> the following reasons can be distinguished: * Size of the system : Distributed programs tend to be large due to the replication of code (SPMD 3 paradigm). <p> These probes are then used to try to understand the behavior of a program <ref> [CBM90] </ref>. 24 * Unload when low load : Each time the load of the communication is less than a defined value, the reactive process will unload the event-records contained in its buffer. Obviously, the "unload when buffer full" strategy often complements this strategy. <p> When executing a program, EBBA-based tools [Bat88] automatically compare the generated runtime information with the expected behavior as described in a model. The differences are analyzed and an interactive tool allows the user to explore these differences. In <ref> [CBM90] </ref> the use of artificial intelligence techniques for the analysis of runtime information is suggested. A system based on this approach would capture the expertise of an experienced programmer in a knowledge base and make it available to all users by assisting the user in developing fault hypotheses. <p> To our knowledge, no systems, for distributed-system runtime-information analysis that are based on AI techniques yet exist. However, in <ref> [CBM90] </ref> a system for the debugging of single processor, concurrent systems, called the Message Trace Analyzer [GS84] is mentioned. 27 5.4 Interacting with the runtime information There are essentially two problems that the user faces when dealing with the runtime information: 1.
Reference: [CDW92] <author> J. Choi, J. Dongarra, and D. Walker. </author> <title> The design of scalable software libraries for distributed memory cocurrent computers. </title> <booktitle> In Dongarra and Tourancheau [DT92], </booktitle> <pages> pages 17-30. </pages>
Reference-contexts: As far as the performance evaluation is concerned, the definition of the best algorithm performance criteria is not clear and actually, most of the authors refer to metric related to the problem size [Gus88, CRT89] or scalability and iso-efficiency function <ref> [CDW92, GK92] </ref>. 2.4 The use of runtime information for increased program understanding Understanding a system in science often means being able to predict the behavior of that system. With complex systems such as parallel computers, this may not always be possible.
Reference: [Cha91] <author> S. Chaumette. </author> <title> A replay mechanism within an environment for distributed programming. </title> <booktitle> In Proceedings of Supercomputing Debugging workshop '91, </booktitle> <address> Albuquerque, NM,, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: In this report, we will concentrate on the monitoring aspects of debugging. For more information about parallel debuggers, the reader should refer to the more specialized publications <ref> [PU89, Pan92, LS92a, Cha91] </ref>.
Reference: [CK90] <author> A. Couch and D. Krumme. </author> <title> Monitoring parallel executions in real time. </title> <booktitle> In Proceedings of the 5th distributed memory computing conference, </booktitle> <volume> volume 2, </volume> <pages> pages 1187-1196. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> The user is free to interrupt, to resume or to proceed in a step-by-step manner the process of displaying the runtime information [HE91b] However ParaGraph does not provide a step-by-step backward option. The Seeplex performance mon itor on the other hand provides a complete implementation of the replay feature <ref> [CK90] </ref>. Multiple views A user-interface should include mechanisms for multiple views of the runtime information, presented through one or more media in several representations. Different views are useful for different purposes and often complement each other.
Reference: [CL85] <author> K. Chandy and L. Lamport. </author> <title> Distributed snapshots : determining global states in distributed sytems. </title> <journal> ACM transaction s on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The state of an active process is determined by the value of all its variables including its program instruction counter and its channels states. Following <ref> [CL85] </ref>, an event e in an active process p is defined as an entity without duration that reflects a change in the state of p or in a channel adjacent to p at a specific time.
Reference: [CRT89] <author> M. Cosnard, Y. Robert, and B. Tourancheau. </author> <title> Evaluating speedups on distributed memory archie ctures. </title> <journal> Parallel Computing, </journal> <volume> 10 </volume> <pages> 247-253, </pages> <year> 1989. </year>
Reference-contexts: As far as the performance evaluation is concerned, the definition of the best algorithm performance criteria is not clear and actually, most of the authors refer to metric related to the problem size <ref> [Gus88, CRT89] </ref> or scalability and iso-efficiency function [CDW92, GK92]. 2.4 The use of runtime information for increased program understanding Understanding a system in science often means being able to predict the behavior of that system. With complex systems such as parallel computers, this may not always be possible.
Reference: [DHHB86] <author> A. Duda, G. Harrus, Y. Haddad, and G. Bernard. </author> <title> Monitoring of distributed systems. </title> <type> Technical Report 52, </type> <institution> ISEM, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: Another is that the drift has not been eliminated. Software synchronization In [Lam78] Lamport proposes an algorithm that allows for software synchronization of the local clocks in a system. Each message that is sent from a node contains a timestamp of the local time when it was sent. In <ref> [DHHB86] </ref> a better algorithm is described that was originally proposed by Gusella and Zatti [GZ84]. The main idea of the algorithm is to exchange messages containing timestamps and current estimates of the time offset. <p> Analyzing the send-receive pairs of our trace-file will thus result in a set of equations that bounds the values of the offset. The more pairs analyzed in this method, the better the obtained precision is. In <ref> [DHHB86] </ref> two methods based on this principle are proposed. Simulation results show that the global time can be estimated with high precision using these methods.
Reference: [DJ91] <author> C. Diehl and C. Jard. </author> <title> Interval approximations of message causality in distributed executin. </title> <type> IR 617, </type> <institution> IRISA, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: In [Fid88] the use of partially ordered logical clocks is proposed as a solution to this problem and a debugging strategy based on these partially ordered clocks is proposed <ref> [Mat89, SM92, DJ91] </ref>. e1 e2 before e2 Proc 1 Proc 2 Observer e1 wrongly e1 e1 correctly before e2 Proc 1 Proc 2 Observer point of view. 2.10.2 Practical implementations [IM93] shows that the global time precision can influence the understanding of the trace based representation.
Reference: [DL93] <author> C. Derr and V. Lo. </author> <title> Selection and reduction : Techniques for visualizing massively parallel programs, </title> <year> 1993. </year>
Reference-contexts: The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92]. Paragraph is used in many laboratories <ref> [DL93, FJA91] </ref> and has been ported on top of different parallel systems [vRT92b, GHSG92]; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views.
Reference: [DT92] <editor> J. Dongarra and B. Tourancheau, editors. </editor> <booktitle> Environments and Tools for Parallel Scientific Computing, volume 6 of Advances In Parallel Computing, </booktitle> <address> Saint Hilaire du Touvet, France, </address> <month> September </month> <year> 1992. </year> <title> CNRS-NSF, </title> <publisher> Elsevier Science Publishers North Holland. </publisher>
Reference: [Dun91] <author> T. H. Dunigan. </author> <title> Hypercube clock synchronization. </title> <type> Technical Report TM-11744, </type> <institution> Oak Ridge National Laboratory, TN, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Practical implementations, as the PICL library on the Intel iPSC, used very simple solutions to synchronize the clocks. Pairs of nodes synchronized with each other through exchanges of messages that contained the local time of the sending node. Currently, a much better algorithm has been adopted in PICL <ref> [Dun91] </ref>, it eliminates 99% of the drift between the different clocks, but it takes approximatively 60 seconds to synchronize. Estimating global time from event-records In this method the global time is calculated in a post-mortem way.
Reference: [Fid88] <author> J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <booktitle> In ACM, editor, Proceedings DIGPLAN/SIGOPS workshop on parallel and distributed debugging, </booktitle> <pages> pages 183-194, </pages> <month> May </month> <year> 1988. </year> <month> 47 </month>
Reference-contexts: This results in a number of problems <ref> [Fid88] </ref>. First of all, it is impossible to distinguish between when the temporal ordering between two events is, and when is not enforced by a causal relationship (see Figure 8). Secondly, the monitor itself may be non-deterministically affected by this interleaving of events. <p> Secondly, the monitor itself may be non-deterministically affected by this interleaving of events. For exactly the same computation with the same inputs which generate the same results, the monitor may produce different results due to the differences in interleaving. In <ref> [Fid88] </ref> the use of partially ordered logical clocks is proposed as a solution to this problem and a debugging strategy based on these partially ordered clocks is proposed [Mat89, SM92, DJ91]. e1 e2 before e2 Proc 1 Proc 2 Observer e1 wrongly e1 e1 correctly before e2 Proc 1 Proc 2
Reference: [FJA91] <author> J. Francioni, J. Jackson, and L. Albright. </author> <title> The sounds of parallel programs. </title> <editor> In Q. Stout and M. Wolfe, editors, </editor> <booktitle> The sixth distributed memory computing conference proceedings, Frontier Series, </booktitle> <pages> pages 570-577, </pages> <address> Portland, Oregon, April 1991. </address> <publisher> IEEE, IEEE computer society press. </publisher>
Reference-contexts: In spite of the fact that psychological studies have shown that users respond more quickly to audio cues than to visual signals in certain instances [RP91], the possibilities of sound remain largely unexplored in monitoring tools. The performance monitor that are currently under development implement sonic data representation are <ref> [RP91, FJA91, ZT92b] </ref>. The use of sound is based on sonic widgets that allow the mapping of sequences of scalar or higher order dimensional data values to frequencies, durations, timbres, attacks/decays and stereo balance. <p> The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92]. Paragraph is used in many laboratories <ref> [DL93, FJA91] </ref> and has been ported on top of different parallel systems [vRT92b, GHSG92]; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views.
Reference: [GGJ + 89] <author> V. Guarna, D. Gannon, D. Jablonowski, A. Malony, and Y. Gaur. </author> <title> FAUST : An integrated environment of parallel programming. </title> <journal> IEEE Software, </journal> <volume> 6 </volume> <pages> 20-29, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> Some tools, such as TOPSYS (see section 6.4), TIPS (see section 6.2) and Faust <ref> [GGJ + 89] </ref> include in their graphical data representations icons which are associated with objects. By clicking on such an icon, a window pops up with additional information about that object. The use of icons results in structured tools with a clear separation of the different levels of abstraction.
Reference: [GHPW90] <author> G. Geist, M. Heath, B. Peyton, and P. Worley. </author> <title> A user's guide to PICL (a portable instru-mentes communication libary). </title> <type> Technical Report TM-11616, </type> <institution> Oak Ridge National Laboratory, TN, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: It should not be very difficult for the reader to adapt this set to his own specific needs. Other authors have defined similar sets of important events to monitor <ref> [GHPW90, GMGK84, MN90] </ref> and in defining a "general purpose set" we drew it on their work, our on work and on discussions with users of parallel systems. 8 A general monitoring tool should both possess a predefined set of monitorable events and the possibility of user-specified events. <p> Table 1: some common attributes A further attribute that records the duration of the activity can be associated with compound event (see section 5.2). Many tools use it implicitly, by associating duration-attribute with an event which, in fact, is a compound event (PICL is an example <ref> [GHPW90] </ref>.). 4 Assignments without side-effects are implied here. By "simple variable", we mean a variable that is of a simple type (int, real, boolean, char, float) and that is easy to access. Pointers to simple variables are not allowed. <p> However, this is not necessarily true, when trace-records are encoded as sequences of integers represented in ASCII. Examples of monitoring systems that use text based trace-formats are the ParMod runtime system [Abs90] and the PICL instrumented library <ref> [GHPW90] </ref>. To limit the overhead of the encoding of the trace-records, PICL uses an internal binary trace-format because it is more time efficient. * Binary trace formats, on the other hand, are compact and induce little overhead, because they are fast to encode. <p> When this happens, the active process is suspended and the event-records are downloaded. A disadvantage of this method is that an active process is suspended at unpredictable moments. "Unload when buffer full" is one of two transport strategies that have been implemented in the PICL library <ref> [GHPW90] </ref>, the second being described in "store and unload afterwards". The user has the choice of either of the strategies. * Unload when requested : This strategy allows the user to define the moments of unloading by calling a trace-flush function. <p> This way, the suspension of the active process in critical sections, as might happen with the "unload when buffer full" strategy, can be avoided. In case a buffer fills up, the previous strategy is applied. In the PICL library <ref> [GHPW90] </ref>, a trace-flush function has been provided that allows the user to unload the contents of the trace-buffer. 8 Output debugging consists of inserting debugging probes, usually output statements at carefully selected places in a program. <p> There is no impact on the communication network and less overhead for the processor (assuming that storing data in memory takes less time than initiating the sending of this data). "Store and unload afterwards" is the second transport strategy that has been implemented in the PICL library <ref> [GHPW90] </ref>. Furthermore, this strategy has been used in [Imr92] for the ECS 9 . 5 Representation of the events Until now we have mainly discussed the generation of the runtime information. In its raw form, this information consists of sequences of event-records. <p> PICL offers the possibility of "conditional event-record generation" by allowing the user to set the level of tracing required <ref> [GHPW90] </ref>. Depending on the level set, more and different event-records will be generated. An on-the-fly method is, also, explained in [HM93]. <p> The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph <ref> [GHPW90, Wor92] </ref>. Paragraph is used in many laboratories [DL93, FJA91] and has been ported on top of different parallel systems [vRT92b, GHSG92]; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views. <p> end, user defined control flow event) a the cumulative busy/idle times of a node a the cumulative communication statistics (number of messages, bytes) of a node Table 3: events monitored by ParaGraph (e for events and a for activities Several functions have been provided in PICL to control the trace-generation <ref> [GHPW90] </ref>. Three different types can be distinguished: functions that allow the user to control the mechanism of "conditional event-record generation" and thus the events that are traced. functions that control the actual tracing.
Reference: [GHSG92] <author> I. Glendinning, S. A. Hellberg, P. A. Shallow, and M. Gorrod. </author> <title> Generic visualization and performance monitoring tools for message passing parallel systems. </title> <editor> In Topham et al. </editor> <booktitle> [TIB92], </booktitle> <pages> pages 139-150. </pages>
Reference-contexts: The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92]. Paragraph is used in many laboratories [DL93, FJA91] and has been ported on top of different parallel systems <ref> [vRT92b, GHSG92] </ref>; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views.
Reference: [GK92] <author> A. Gupta and V. Kumar. </author> <title> Analysing Performance of Large Scale Parallel Systems. </title> <type> Technical Report TR 92-32, </type> <institution> Department of Computer Science University of Minnesota - Minneapolis, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: As far as the performance evaluation is concerned, the definition of the best algorithm performance criteria is not clear and actually, most of the authors refer to metric related to the problem size [Gus88, CRT89] or scalability and iso-efficiency function <ref> [CDW92, GK92] </ref>. 2.4 The use of runtime information for increased program understanding Understanding a system in science often means being able to predict the behavior of that system. With complex systems such as parallel computers, this may not always be possible.
Reference: [GMGK84] <author> H. Garcia-Molina, F. Germano, and W. H. Kohler. </author> <title> Debugging a distributed computing system. In IEEE, editor, </title> <journal> Transactions on Software Engineering, </journal> <pages> pages 210-219, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: According to <ref> [CBM90, GMGK84, JLSU87, Mil92] </ref> the following reasons can be distinguished: * Size of the system : Distributed programs tend to be large due to the replication of code (SPMD 3 paradigm). <p> It should not be very difficult for the reader to adapt this set to his own specific needs. Other authors have defined similar sets of important events to monitor <ref> [GHPW90, GMGK84, MN90] </ref> and in defining a "general purpose set" we drew it on their work, our on work and on discussions with users of parallel systems. 8 A general monitoring tool should both possess a predefined set of monitorable events and the possibility of user-specified events.
Reference: [GS84] <author> N. K. Gupta and R. E. Seviora. </author> <title> An expert system approach to real-time debugging. </title> <booktitle> In Proceedings of the 1st conference on Artificial Intelligence Application, </booktitle> <pages> pages 336-343. </pages> <publisher> CS Press, </publisher> <year> 1984. </year>
Reference-contexts: To our knowledge, no systems, for distributed-system runtime-information analysis that are based on AI techniques yet exist. However, in [CBM90] a system for the debugging of single processor, concurrent systems, called the Message Trace Analyzer <ref> [GS84] </ref> is mentioned. 27 5.4 Interacting with the runtime information There are essentially two problems that the user faces when dealing with the runtime information: 1. Monitoring systems can generate enormous amounts of runtime information that are usually of a relatively low-level of abstraction.
Reference: [Gus88] <author> J.L. Gustafson. </author> <title> The Scaled Sized Model: A Revision of Amdahl's Law. </title> <editor> In L.P Kartashev and S.I. Kartashev, editors, Supercomputing'88, </editor> <volume> volume II, </volume> <pages> pages 130-133. </pages> <booktitle> International Computing Institute, </booktitle> <year> 1988. </year>
Reference-contexts: As far as the performance evaluation is concerned, the definition of the best algorithm performance criteria is not clear and actually, most of the authors refer to metric related to the problem size <ref> [Gus88, CRT89] </ref> or scalability and iso-efficiency function [CDW92, GK92]. 2.4 The use of runtime information for increased program understanding Understanding a system in science often means being able to predict the behavior of that system. With complex systems such as parallel computers, this may not always be possible.
Reference: [GZ84] <author> R. Gusella and S. Zatti. </author> <title> Tempo : A network time controller for a distributed berkeley unix system. </title> <journal> Distributed processing technical communication newsletter IEEE, </journal> <volume> 6(SI-6):7-15, </volume> <month> June </month> <year> 1984. </year>
Reference-contexts: Each message that is sent from a node contains a timestamp of the local time when it was sent. In [DHHB86] a better algorithm is described that was originally proposed by Gusella and Zatti <ref> [GZ84] </ref>. The main idea of the algorithm is to exchange messages containing timestamps and current estimates of the time offset. Practical implementations, as the PICL library on the Intel iPSC, used very simple solutions to synchronize the clocks.
Reference: [HE91a] <author> M. Heath and J. Etheridge. </author> <title> Visualizing performance of parallel programs. </title> <type> Technical Report TM-11813, </type> <institution> Oak Ridge National Laboratory, TN, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> visual dynamic representations of the execution of such programs might considerably help the user in a better understanding of her/his program and thus lead to significant improvements. 6.1 PICL/ParaGraph 6.1.1 Introduction ParaGraph is a trace-based, highly graphical, interactive visualization tool that has been developed at the Oak Ridge National Laboratory <ref> [HE91a, HE91b] </ref>. The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92]. <p> Other views include Critical Path, Clock, Phase Portrait, Message queues, Communication meter, Communication traffic, Processor status, Statistical Summary, etc. For more information about these views refer to <ref> [HE91a] </ref>. 33 6.2 TMON 6.2.1 Introduction The Transputer MONitor forms an integral part of the TIPS parallel programming environment as described in [WCG + 92] that was developed at the University of British Columbia.
Reference: [HE91b] <author> M. Heath and J. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8 </volume> <pages> 29-39, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: These methods range from the simple compilation of statistics from event-records to complex systems such as tools based on Event Based Behavioral Abstraction (EBBA). Some of these methods will be briefly introduced here. The simplest way of analyzing runtime information consists of collecting statistics from the individual event-records. ParaGraph <ref> [HE91b] </ref> and the Crystal [RR89b] are typical examples of tools that use this approach. Among the gathered statistics are cumulative busy/idle times, cumulative communication times, number of bytes sent, etc. <p> A disadvantage of the "replay" feature is that its implementation requires the storage of the run-time information. ParaGraph features a partial implementation of the replay feature. The user is free to interrupt, to resume or to proceed in a step-by-step manner the process of displaying the runtime information <ref> [HE91b] </ref> However ParaGraph does not provide a step-by-step backward option. The Seeplex performance mon itor on the other hand provides a complete implementation of the replay feature [CK90]. <p> visual dynamic representations of the execution of such programs might considerably help the user in a better understanding of her/his program and thus lead to significant improvements. 6.1 PICL/ParaGraph 6.1.1 Introduction ParaGraph is a trace-based, highly graphical, interactive visualization tool that has been developed at the Oak Ridge National Laboratory <ref> [HE91a, HE91b] </ref>. The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92].
Reference: [HG92] <editor> G. Haring and Kotsis G., editors. </editor> <booktitle> Workshop on Performance Measurement and Visualization of Parallel Systems, volume 7 of Advances in parallel Computing. </booktitle> <publisher> North Holland, </publisher> <month> October </month> <year> 1992. </year>
Reference: [HIM91] <author> J. Hollingsworth, B. Irvin, and P. B. Miller. </author> <title> The integration of application and system based metrics in a parallel program performance tool. </title> <booktitle> To appear in Proceedings of the 1991 ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <year> 1991. </year> <note> accessible by anonymous FTP in grilled.cs.wisc.edu:technical reports/edcu.ps.Z. </note>
Reference-contexts: Miller. IPS-2 <ref> [HIM91] </ref>, is "an interactive, trace driven performance measurement system for parallel and distributed programs". The IPS-2 can measure shared-memory and message-passing parallel programs running on a heterogeneous collection of machines. The events are only generated by software probes inserted in the source (C or Fortran).
Reference: [HM93] <author> J. Hollingsworth and P. B. Miller. </author> <title> Dynamic control of performance monitoring on large scale parallel systems. </title> <booktitle> To appear International Conference on Supercomputing, </booktitle> <address> Tokyo, </address> <month> July </month> <year> 1993, </year> <note> accessible by ftp grilled.cs.wisc.edu:technical papers/w3search.ps.Z, </note> <year> 1993. </year>
Reference-contexts: PICL offers the possibility of "conditional event-record generation" by allowing the user to set the level of tracing required [GHPW90]. Depending on the level set, more and different event-records will be generated. An on-the-fly method is, also, explained in <ref> [HM93] </ref>. The PIE tools [LSV + 89] proposed also some filtering to reduce the amount of data. * Filtering can also take place in a distributed manner, just after the event-record has been generated or before the transport of the event-record takes place.
Reference: [Hon89] <author> R. Hon. </author> <title> A simple trace interchange format. </title> <institution> Technical Report Apple Computer Inc., </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Unfortunately, byte orderings and number representations differ across different machines, and porting trace files across machines will almost certainly imply converting the trace files. According to <ref> [Hon89] </ref>, the raw number of bits required to represent a event-record in text format can easily exceed five to ten times the number of bits required for an equivalent binary representation.
Reference: [IM93] <author> R. Irvin and P. B. Miller. </author> <title> Multi-application support in a parallel program performance tool. </title> <type> Technical Report 1135, </type> <institution> University of Wisconsin-Madison, </institution> <address> 1210 W Dayton Street, Madison, Wisconsin 53706, </address> <year> 1993. </year> <note> accessible by anonymous FTP grilled.cs.wisc.edu:technical papers/multiapp.ps.Z. 48 </note>
Reference-contexts: is proposed as a solution to this problem and a debugging strategy based on these partially ordered clocks is proposed [Mat89, SM92, DJ91]. e1 e2 before e2 Proc 1 Proc 2 Observer e1 wrongly e1 e1 correctly before e2 Proc 1 Proc 2 Observer point of view. 2.10.2 Practical implementations <ref> [IM93] </ref> shows that the global time precision can influence the understanding of the trace based representation.
Reference: [Imr92] <author> K. Imre. </author> <title> Experiences with monitoring and visualising the performance of parallel programs. </title> <editor> In Haring and G. </editor> <publisher> [HG92]. </publisher>
Reference-contexts: Furthermore, this strategy has been used in <ref> [Imr92] </ref> for the ECS 9 . 5 Representation of the events Until now we have mainly discussed the generation of the runtime information. In its raw form, this information consists of sequences of event-records. <p> This type of clustering has the same advantages as distributed filtering (see 5.2.1). 26 * Clustering the event-records just before the usage is the highest level where clustering can be done. The existing tools that provide clustering features have usually adopted this approach. In the SIMPLE environment <ref> [Moh90, Imr92] </ref> a tool called ADAR (Activity Definition And Recognition system) has been provided.
Reference: [JLSU87] <author> J. Joyce, G. Lomow, K. Slind, and B. Unger. </author> <title> Monitoring distributed systems. </title> <journal> Transactions computing systems ACM, </journal> <volume> 5(2) </volume> <pages> 121-150, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: According to <ref> [CBM90, GMGK84, JLSU87, Mil92] </ref> the following reasons can be distinguished: * Size of the system : Distributed programs tend to be large due to the replication of code (SPMD 3 paradigm). <p> Although the use of graphics has become the dominant way to represent runtime information, textual representations are still used, often in combination with graphical representations. An example of the use of text is the Jade programming environment <ref> [JLSU87] </ref>, which provides amongst others a text-based console that prints messages as events are detected. In SIMPLE, a completely text-based representation tool SMART that can be used on ASCII terminals is provided (see section 6.3.3).
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clock and the ordering of events in a distributed system communication. </title> <journal> Communications of th ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Thus, the causal order is sometime sufficient and less costly in terms of monitoring power. For this purpose, in this section, the notions "happened before" and "clock" will be introduced and the related issues will be discussed. * In <ref> [Lam78] </ref> the happened before ("!") relationship is introduced. This relationship is at the base of partial orders over sets of events. The "happened before" relationship only defines which events might have influenced each other, but does not tell us if they actually did. <p> The entire system of clocks is represented by the function C, which assigns to any event e the number C (e). For a clock to be correct, the following condition should hold <ref> [Lam78] </ref> : For any two events a; b : if a ! b then C (a) &lt; C (b), but the opposite is not necessarily true (C (a) &lt; C (b) 6) a ! b). Two different types of clocks can be distinguished. <p> One disadvantage is that this reset mechanism usually needs to be added to the machine. Another is that the drift has not been eliminated. Software synchronization In <ref> [Lam78] </ref> Lamport proposes an algorithm that allows for software synchronization of the local clocks in a system. Each message that is sent from a node contains a timestamp of the local time when it was sent.
Reference: [LCSM92] <author> J. E. Lumpp, T. L. Casavant, H. J. Siegel, and D. C. Marinescu. </author> <title> Specification and identification of events for debugging and performance monitoring of distributed multiprocessor systems. </title> <booktitle> In IEEE, editor, Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 476-483, </pages> <year> 1992. </year>
Reference-contexts: The MMK kernel of TOPSYS is an example of a tool where the operating system has been modified [BL92]. There is also a modification of Intel OS NX/2 tool in [MRR90] and Trollius OS [vRT92c]. In <ref> [LCSM92] </ref> two classes of events are introduced that group atomic events according to their availability in monitoring tools. <p> Example : * modification of the value of the variable ``counter'' * enter the procedure ``Hello world'' Currently, tools that allow for the specification and the automatic detection of user specified events are being developed <ref> [LCSM92] </ref>. of abstraction. <p> The SIMPLE environment provides such an automatic instrumentation tool, called AICOS (Automatic Instrumentation of C Object Software) [Moh90] that automatically instruments procedures, procedure calls or arbitrary statements in source-code written in C. Another project <ref> [LCSM92] </ref> goes even further and aims to develop a complete event-specification language. The user defines the events that are to be monitored in this language and a "compiler" will automatically insert the probes in the source-code. The events that are currently monitorable are data-flow events such as assignments and incrementations.
Reference: [LMCF92] <author> T. J. Leblanc, J. M. Mellor-Crummey, and R. J. Fowler. </author> <title> Analysing parallel program executions using multiple views. </title> <journal> Journal of parallel and distributed computing academic press, </journal> <volume> 9(2) </volume> <pages> 203-217, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Visual representations are also called visualizations. 11 Graphical data representations are also called graphical visualizations <ref> [LMCF92] </ref>. 28 Representing information related to one object The information related to an object usually consists of some statistical information about that object. For example, the utilization of a processor, the number of messages that have been sent through a channel, the number of memory accesses, etc. <p> A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> The collective behavior of the processes defines the results of the program, but the behavior of individual processes may be the cause of anomalies <ref> [LMCF92] </ref>. Therefore a monitoring tool should have the capabilility of presenting information at different levels of abstraction, thus allowing the user to analyze the behavior of a program at the desired level of detail.
Reference: [LS92a] <author> E. Leu and A. Schiper. </author> <title> Execution replay : A mechanism for integrating a visualizing tool wth symbolic debugger. </title> <editor> In L. Bouge, M. Cosnard, Y. Robert, and D. Trystram, editors, </editor> <booktitle> Proceedings of CONPAR 92 - VAPP V, </booktitle> <address> Lyon, </address> <month> September </month> <year> 1992. </year> <institution> Ecole Normale Superieure, Springer-Verlag. </institution>
Reference-contexts: In this report, we will concentrate on the monitoring aspects of debugging. For more information about parallel debuggers, the reader should refer to the more specialized publications <ref> [PU89, Pan92, LS92a, Cha91] </ref>.
Reference: [LS92b] <author> E. Leu and A. Schiper. </author> <title> ParaRex : a programming environment integrating execution replay -ns visualization. </title> <booktitle> In Dongarra and Tourancheau [DT92], </booktitle> <pages> pages 155-170. </pages>
Reference-contexts: They are implemented in those monitors that need to deliver the runtime information in real-time (See <ref> [LS92b] </ref> on iPSC/2). <p> From a practical point of view, this strategy means that as soon as a event-record has been generated, it is sent to its destination. Typical examples that use "delayed availability" are visualization tools that allow the "real-time" observation of the executing program and output debugging 8 <ref> [LS92b] </ref>. "Delayed availability" definitely has an impact on the behavior of the communication network of the system, if no separate network is used. With blocking sends and a loaded communication network, the impact may even become dramatic, due to the continuous blocking of the active processes by sends.
Reference: [LSV + 89] <author> T. Lehr, Z. Segall, D. F. Vrsalovic, E. Caplan, A. L. Chung, and C.E. Fineman. </author> <title> Visualizing performance debugging computer. </title> <journal> IEEE, </journal> <pages> pages 38-51, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: However, no precise model has been developed that allows us to quantify these effects. A common approach is to try to minimize the influence of the software monitoring and neglect whatever influence remains. In the PIE environment <ref> [LSV + 89] </ref> a simple compensation mechanism has been developed that attempts to compensate the delays induced by the software probes. This algorithm that is used on uni-processor, multi-threaded executions, adjusts the timestamps of each event-record in accordance with the number of monitored events that occurred before it. <p> PICL offers the possibility of "conditional event-record generation" by allowing the user to set the level of tracing required [GHPW90]. Depending on the level set, more and different event-records will be generated. An on-the-fly method is, also, explained in [HM93]. The PIE tools <ref> [LSV + 89] </ref> proposed also some filtering to reduce the amount of data. * Filtering can also take place in a distributed manner, just after the event-record has been generated or before the transport of the event-record takes place. <p> A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> Therefore, the use of color has been chosen because human being has a better graphical perception than a textual one. Furthermore, Maritxu has been enhanced by the addition of sound [ZT92b]. The user of Maritxu has thus not only visual stimuli but also audio ones. 42 6.8 PIE PIE <ref> [LSV + 89] </ref> (Parallel Programming and Instrumentation Environment) was developed at Carnegie Mellon university. Its philosophy is to be "efficiently mapping parallel applications onto specific architectures and observing them when they execute". PIE supports language such as C, MPC, C-threads, Ada and Fortran.
Reference: [MAA + 89] <author> A. Malony, J. Arendt, R. Aydt, D. Reed, D. Grabas, and B. Totty. </author> <title> An integrated performance data collection analysis, and visualization system. </title> <booktitle> In Proceedings of the 4th conference on hypercube concurrent computers and applications, </booktitle> <pages> pages 229-236, </pages> <year> 1989. </year>
Reference-contexts: Object-code instrumentation has the disadvantage of requiring an instrumenting compiler. At this time, we know of no such compilers that are commercially available for parallel machines. Thus, an existing compiler will have to be modified. In <ref> [MAA + 89, MRR90] </ref> a performance monitor based on object-code instrumentation is described. To insert the software probes a GNU C compiler was modified. This modified compiler inserts calls to the monitoring functions in the intermediate RTL representation instead of in the assembly code. <p> In the TOPSYS environment on the other hand, the probes have been added to MMK, the operating system kernel which is part of the project and which runs on top of NX. In <ref> [MAA + 89] </ref> the instrumented kernel approach has been adopted as a complement to the object-code instrumentation. The instrumented kernel detects the system events, whereas the instrumented object-code handles the application events. <p> The memory mapped I/O approach clearly induces less overhead, but requires considerably more additional hardware because the address and the data bus need to be monitored. The Hypermon hybrid monitor for the iPSC/2 implements a slightly different approach <ref> [MAA + 89] </ref>. The hardware part of Hypermon is connected to the I/O-signals of each of the monitored node processors. <p> A monitor such a TMON (see section 6.2), which mainly consists of a software monitor with one independent node, will be slightly less intrusive than its software equivalent. On the other hand, hybrid monitors such as the Hypermon <ref> [MAA + 89] </ref>, which are close to hardware monitors, hardly induce any overhead when used with memory mapped I/O (see section 3.5.2). 4 Transportation of the events To our knowledge, no entirely distributed monitoring tool has yet been developed (i.e. a complete parallel program that will gather and use the monitored
Reference: [Mal89] <author> A. Malony. </author> <title> Multiprocessor instrumentation : Approches for cedar. </title> <type> Technical report, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <address> Santa Fe, New Mexico, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Therefore often only the interesting events are traced and the evolution of the program state is approximated 4 by leaving out the uninteresting information. This method has been generally adopted in monitoring tools <ref> [Mal89, PTV92] </ref>. By defining a higher level of abstraction (i.e. by changing the granularity) at which we look at the program (for instance looking at procedures instead of instructions), its state representation can be considerably simplified, thus reducing the number of changes to monitor.
Reference: [Mat89] <author> F. Mattern. </author> <title> Virtual time and global state of ditributed systems. </title> <editor> In Cosnard, Quinton, Ray-nald, and Robert, editors, </editor> <booktitle> international workshop on parallel and distributed algorithms. </booktitle> <publisher> North Holland, </publisher> <month> November </month> <year> 1989. </year>
Reference-contexts: In [Fid88] the use of partially ordered logical clocks is proposed as a solution to this problem and a debugging strategy based on these partially ordered clocks is proposed <ref> [Mat89, SM92, DJ91] </ref>. e1 e2 before e2 Proc 1 Proc 2 Observer e1 wrongly e1 e1 correctly before e2 Proc 1 Proc 2 Observer point of view. 2.10.2 Practical implementations [IM93] shows that the global time precision can influence the understanding of the trace based representation.
Reference: [Mil92] <author> B. Miller. </author> <title> What to draw ? when to draw ? an essay on parallel program visualization. </title> <note> to appear Journal of Parallel & Distributed Computing, </note> <year> 1992. </year>
Reference-contexts: According to <ref> [CBM90, GMGK84, JLSU87, Mil92] </ref> the following reasons can be distinguished: * Size of the system : Distributed programs tend to be large due to the replication of code (SPMD 3 paradigm). <p> Such descriptions can be found in <ref> [Mil92] </ref>. Different levels of abstraction When analyzing a program's execution, the focus of interest often begins with the entire program and then moves to smaller groups of processes or even to a single process.
Reference: [mL92] <author> R. mac Laren. </author> <title> Instrumentation and performance monitoring of distributed systems. </title> <booktitle> In Proceedings of the 5th Distributed Memory Computing Conference, </booktitle> <pages> pages 1180-1186. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: So it would be enough to know all the states, the system went through from the start to the end of a program execution, to know precisely what went on in the machine. This observation can be done in two different ways <ref> [mL92] </ref>: * The first one consists of time-sampling the program state. With the help of these time-samples, one can reconstruct the evolution of the program state. The advantage is that the user can choose the induced overhead by choosing the sample intervals. <p> Detecting application-events on the other hand, will be impossible as long as the application does not use any kernel functions. To overcome this problem, a solution similar to instrumented libraries can be used, that is, a special trace-function that can be called upon and added to the kernel (see <ref> [mL92] </ref>). Today, few machines offer kernels that are equipped for monitoring (see [MN90] and section 2.8 for a discussion about the minimum set of measurement capabilities a parallel operating systems should provide). <p> The only effect a hardware monitor may have on the observed system is the need for a decreased clock-speed <ref> [mL92] </ref>, due to the additional loading of the system busses. This does not affect the ordering of the events, but only slows down the execution time. 3.5 Generation through hybrid monitoring Hybrid monitoring tries to combine the best of both software and hardware monitoring. <p> Suppose that every 1000 instructions one event is generated (this implies an overhead of less than 0.5% <ref> [mL92] </ref>). This will result in the generation of 10,000 events per second per processor. With 16 processors this results in an event generation rate of 160,000 events per second. With 128 processors the event generation rate will be 1,280,000 events per second.
Reference: [MLCS92] <author> D. Marinescu, J. Lumpp, T. Casavant, and H. Siegel. </author> <title> Models for monitoring and debugging tools for parallel and distributed software. </title> <journal> Journal od parallel and distributed computing Academic press, </journal> <pages> pages 171-184, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Two disjoint subsystems can be identified in a parallel machine <ref> [MLCS92] </ref>. They are the subsystem A that consists of the application processes called active processes and the monitoring subsystem processes reactive processes R that provides the needed monitoring functions. <p> Although the code is clearly separated in distinct processes (except for the probes themselves), the active and the reactive code are still running on the same processor (in a time-sliced way). The altering of the timing of events due to the insertion of reactive code may <ref> [MLCS92] </ref>: * lead to incorrect results * create (or mask) deadlock situations when the order of events in different threads of control is affected * cause a real-time program to fail to meet its deadlines * increase the execution time of the monitored program 19 The existence of these effects on
Reference: [MN90] <author> A. Malony and K. Nichols. </author> <title> Standards working group summary. </title> <booktitle> In Simmons and Koskela [SK90], </booktitle> <pages> pages 261-278. </pages>
Reference-contexts: It should not be very difficult for the reader to adapt this set to his own specific needs. Other authors have defined similar sets of important events to monitor <ref> [GHPW90, GMGK84, MN90] </ref> and in defining a "general purpose set" we drew it on their work, our on work and on discussions with users of parallel systems. 8 A general monitoring tool should both possess a predefined set of monitorable events and the possibility of user-specified events. <p> Because of the growing interest in monitoring parallel program executions, some efforts are being made to standardize trace formats <ref> [PGUB92, MN90] </ref>. With a standardized trace-format, monitors and tools can freely exchange runtime information. <p> To overcome this problem, a solution similar to instrumented libraries can be used, that is, a special trace-function that can be called upon and added to the kernel (see [mL92]). Today, few machines offer kernels that are equipped for monitoring (see <ref> [MN90] </ref> and section 2.8 for a discussion about the minimum set of measurement capabilities a parallel operating systems should provide). On most machines instrumenting a kernel will be a far from easy task and might even necessitate completely rewriting the kernel or writing a new kernel.
Reference: [Moh90] <author> B. Mohr. </author> <title> Performance evaluation of parallel programs in parallel and distribted systems. </title> <booktitle> In Burkhart [Bur90], </booktitle> <pages> pages 176-187. </pages>
Reference-contexts: After identifying an event, the reactive process determines the action to perform, performs it and then returns to the suspended state. Often interesting aspects in the behavior of a monitored system are determined by a sequence of events, called an activity <ref> [Moh90] </ref>. An activity could be defined by a regular expression of events or previously defined activities. Informally, one could say that the activity describes the actions that lead to the occurrence of an event. <p> Tools that help the user in generating this access-key are available. In the SIMPLE environment <ref> [Moh90] </ref>, this approach has been adopted. * standard exchange of Trace-Format (STIF)[Hon89, MN90] : This format is designed to be easy to convert to and from and to transport between sites. It is text-based and most existing event-traces can be expressed in it. <p> On the other hand manually inserting probes is very labour intensive and for this reason automatic instrumentation tools have been developed. The SIMPLE environment provides such an automatic instrumentation tool, called AICOS (Automatic Instrumentation of C Object Software) <ref> [Moh90] </ref> that automatically instruments procedures, procedure calls or arbitrary statements in source-code written in C. Another project [LCSM92] goes even further and aims to develop a complete event-specification language. <p> This type of clustering has the same advantages as distributed filtering (see 5.2.1). 26 * Clustering the event-records just before the usage is the highest level where clustering can be done. The existing tools that provide clustering features have usually adopted this approach. In the SIMPLE environment <ref> [Moh90, Imr92] </ref> a tool called ADAR (Activity Definition And Recognition system) has been provided. <p> More complex analysis is provided by the integration into the monitoring environment of statistical analysis packages, that allow the interactive analysis of the trace-data. The SIMPLE environment adopted this approach by integrating the data analysis and graphics package S from AT&T <ref> [Moh90] </ref>. The Event Based Behavioral Abstraction (EBBA) approach is more than simply a way of analyzing event-records, and constitutes a complete high-level approach to debugging [Bat89]. Globally speaking the approach consists of constructing high-level models that describe the expected behavior of the monitored program. <p> bar represents the number of messages sent within some interval of time and the density of bars reflects the message activity between a pair of nodes. 6.3 SIMPLE 6.3.1 Introduction SIMPLE is a performance evaluation tool environment that has been developed at the University of Erlangen and is described in <ref> [Moh90] </ref>. Much attention was paid in the SIMPLE project to produce a portable tool environment that was not bound to any particular machine. This resulted in an object-oriented data access interface that makes the SIMPLE code easily portable and easy to interface to other existing tools.
Reference: [MR90] <author> A. Mallony and D. Reed. </author> <title> A hardware-based performance monitor for the intel iPSC/2 hypercube. </title> <editor> In Miller B. and McDowell C., editors, </editor> <booktitle> Proceedings of the ACM International Conference on Supercomputing, </booktitle> <address> Amsterdam, June 1990. </address> <publisher> ACM press. </publisher> <pages> 49 </pages>
Reference-contexts: Unfortunately few machines are equipped with such a clock and adding one to an existing machine can be a complicated task (see Hypermon in <ref> [MRR90, MR90] </ref>). Global clocks require additional hardware and are usually not portable. Either one central timer counter transmits its value to all the nodes in the system or the local clocks of the system works in a lockstep fashion.
Reference: [MRR90] <author> A. Malony, D. Reed, and D. Rudolph. </author> <title> Integrating performance data collection, analysis and visualization. </title> <booktitle> In Simmons and Koskela [SK90], </booktitle> <pages> pages 73-97. </pages>
Reference-contexts: The MMK kernel of TOPSYS is an example of a tool where the operating system has been modified [BL92]. There is also a modification of Intel OS NX/2 tool in <ref> [MRR90] </ref> and Trollius OS [vRT92c]. In [LCSM92] two classes of events are introduced that group atomic events according to their availability in monitoring tools. <p> Unfortunately few machines are equipped with such a clock and adding one to an existing machine can be a complicated task (see Hypermon in <ref> [MRR90, MR90] </ref>). Global clocks require additional hardware and are usually not portable. Either one central timer counter transmits its value to all the nodes in the system or the local clocks of the system works in a lockstep fashion. <p> Object-code instrumentation has the disadvantage of requiring an instrumenting compiler. At this time, we know of no such compilers that are commercially available for parallel machines. Thus, an existing compiler will have to be modified. In <ref> [MAA + 89, MRR90] </ref> a performance monitor based on object-code instrumentation is described. To insert the software probes a GNU C compiler was modified. This modified compiler inserts calls to the monitoring functions in the intermediate RTL representation instead of in the assembly code.
Reference: [Noe92] <author> R. Noe. </author> <title> Pablo instrumentation environment User's Guide. </title> <institution> Noe, R., Department of computer Science, Univeristy of Illinois, Urbana, Illinois 61801, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: are TVIEW (see section 6.2) from the TIPS environment, VISTOP (see section 6.4) from the TOPSYS environment, MARITXU 6.7. * Debugging oriented tools collect information about the state of processes (values of variables) and about the flow of control in a detailed way (entering specific procedures, loops, conditional statements, ...) <ref> [Noe92] </ref>. Whereas a debugging oriented monitoring tool only gathers information about a program execution a real parallel debugger also allows the user to interact with this execution. In this report, we will concentrate on the monitoring aspects of debugging. <p> If the timestamps of the event-records are not related to a global time, this global time can be deduced from the local time stamps of the event-records. In Pablo, each node 9 Edinburgh Concurrent Supercomputer 25 generates its own trace file, thus such an algorithm is used <ref> [Noe92] </ref> to merge data into one file. <p> This can be done in a more or less distributed manner, and using on-line or off-line processing. Usually runtime information is centralized at some point during the processing (for example, in Pablo <ref> [Noe92] </ref>, the merging operation is done by hand, just before the visualization), because most applications use runtime information to obtain an accurate global view of the execution of a distributed program.
Reference: [OQM91] <author> C. W. Oehlrich, A. Quick, and P. Metzger. </author> <title> Monitor-supported analysis of a communication system for transputer-networks. </title> <booktitle> In Proceedings of the 2nd European Distributed Memory Computing Conference, </booktitle> <pages> pages 120-129, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: If the hardware part of the monitor has access to the application's state, all the attributes can be collected by the monitor and the software probes have only to issue one single write to signal an event occurrence. This results in a minimal overhead. In <ref> [OQM91] </ref> the adaptation of the ZM4 monitor to a transputer network is described. The ZM4 monitor has been used with both a sort of memory mapped I/O 6 and direct channel I/O 7 . <p> At the end of a program execution the monitors transfer the recorded data to the CEC over the data channel of the ZM4. Node 1 Monitor 1 Node 2 Monitor 2 Monitor n Node n monitored object system ZM4 Data channel CEC In <ref> [OQM91] </ref> two different approaches to event detection with the ZM4 are described. In a sort of memory mapped I/O, a part of the memory addresses are reserved for monitoring uses.
Reference: [Pan92] <author> Cherri M. Pancake. </author> <title> Graphical support for parallel debugging. </title> <booktitle> In NATO sponsored Advanced Research Workshop on Software for Parallel Computation, </booktitle> <pages> pages 216-228, </pages> <address> Cosenza, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In this report, we will concentrate on the monitoring aspects of debugging. For more information about parallel debuggers, the reader should refer to the more specialized publications <ref> [PU89, Pan92, LS92a, Cha91] </ref>.
Reference: [PGUB92] <author> C. Pancake, D. Gannon, S. Utter, and D. Bergmark. </author> <title> Supercomputing `90 bof session on standardizing parallel trace-formts. </title> <note> unpublished document available in Postscript from anonymous ftp fromeagle.cnsf.cornell.edu in pub/BOF as bof.ps, </note> <month> November </month> <year> 1992. </year>
Reference-contexts: Because of the growing interest in monitoring parallel program executions, some efforts are being made to standardize trace formats <ref> [PGUB92, MN90] </ref>. With a standardized trace-format, monitors and tools can freely exchange runtime information. <p> This header contains both the syntactic and the semantic description of the event-records contained in a trace file. A tool reads this header to find out what information is contained in the trace file and where to find it <ref> [PGUB92, RP91, Ayd93] </ref>. * object oriented : Instead of defining a trace-format standard or just a header, the measured trace-formats are considered as a generic abstract data structure. Evaluation tools can only access the measured data via a uniform and standardized set of generic procedures.
Reference: [PTV92] <author> S. Poinson, B. Tourancheau, and X. Vigouroux. </author> <title> Distributed monitoring for scalable massively parallel machines. </title> <booktitle> In Dongarra and Tourancheau [DT92], </booktitle> <pages> pages 85-101. </pages>
Reference-contexts: Therefore often only the interesting events are traced and the evolution of the program state is approximated 4 by leaving out the uninteresting information. This method has been generally adopted in monitoring tools <ref> [Mal89, PTV92] </ref>. By defining a higher level of abstraction (i.e. by changing the granularity) at which we look at the program (for instance looking at procedures instead of instructions), its state representation can be considerably simplified, thus reducing the number of changes to monitor. <p> The user starts observing the program at the system level. Each time additional information about an object is desired, the user clicks on this object, decreasing the level of abstraction at each step. Icons allow PIMSY <ref> [PTV92] </ref> to be scalable by implementing the strategy of "clumping" the information. Controlling the time Some tools allow the user at any time to interrupt, to proceed in a step-by step manner, to resume or to start again from the beginning the process of representing the runtime information. <p> A distributed collection system on the other hand consists of a set of reactive processes (one per node), where each reactive process monitors those processes that are local to its node. Partially distributed collection systems with one reactive process supervising several nodes could be devised. The PIMSY tool <ref> [PTV92, vRTV92] </ref> is based on this approach and tries to prove the advantage of such a system.
Reference: [PU89] <author> Cherri M. Pancake and Sue Utter. </author> <title> Models for visualization in parallel debuggers. </title> <booktitle> In Proceedings of Supercomputing '89, </booktitle> <pages> pages 627-636, </pages> <address> Reno NV, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: In this report, we will concentrate on the monitoring aspects of debugging. For more information about parallel debuggers, the reader should refer to the more specialized publications <ref> [PU89, Pan92, LS92a, Cha91] </ref>.
Reference: [RAM + 92] <author> D. Reed, R. Aydt, T. Madhyastha, R. Noe, K. Shields, and B. Schwartz. </author> <title> An overview of the pablo performance analysis environment, </title> <year> 1992. </year>
Reference-contexts: The interactions between different objects are represented by arrows linking the objects that interact. TOPSYS provides a complete replay feature (see section 5.4) that allows continuous or step-by-step (forward and backward) running of the representation clock. 6.5 Pablo The following introduction is extracted from <ref> [RAM + 92] </ref>. Pablo is a performance analysis environment designed to provide performance data capture, analysis, and presentation across a wide variety of scalable parallel systems. <p> This meta-format allows for changes in the instrumentation without modifying the analysis tool. Obviously no semantic can be added in the trace file, so every field is recognized by a syntactic analysis. For example <ref> [RAM + 92] </ref> : /* "Trace generation date" "November 1, 1991" * #1: // "event" "message sent to one or more processors" "message send" - double "timestamp"; // "From" "Processor sending message" int "SourcePE"; // "To" "Processor (s) receiving message" int "DestinationPE"[]; // "Size" "Message length in bytes" int "Message Length";
Reference: [RP91] <author> D. </author> <title> Reed and the Picasso group. Scalable performance environments for parallel systems. </title> <note> Available in PostScript from reed.ps, </note> <month> April </month> <year> 1991. </year>
Reference-contexts: According to [Hon89], the raw number of bits required to represent a event-record in text format can easily exceed five to ten times the number of bits required for an equivalent binary representation. In <ref> [RP91] </ref>, a monitoring system that uses a binary trace-format is described. 14 3.1.2 Defining a trace-format A trace-format defines both the syntax and the semantics of event-records (That is, what the event-records look like and what information is contained in them). <p> This header contains both the syntactic and the semantic description of the event-records contained in a trace file. A tool reads this header to find out what information is contained in the trace file and where to find it <ref> [PGUB92, RP91, Ayd93] </ref>. * object oriented : Instead of defining a trace-format standard or just a header, the measured trace-formats are considered as a generic abstract data structure. Evaluation tools can only access the measured data via a uniform and standardized set of generic procedures. <p> The dimensions of the audio parameter space include duration (time), pitch (frequency), volume (amplitude), timbre (waveform) and stereo balance. In spite of the fact that psychological studies have shown that users respond more quickly to audio cues than to visual signals in certain instances <ref> [RP91] </ref>, the possibilities of sound remain largely unexplored in monitoring tools. The performance monitor that are currently under development implement sonic data representation are [RP91, FJA91, ZT92b]. <p> In spite of the fact that psychological studies have shown that users respond more quickly to audio cues than to visual signals in certain instances [RP91], the possibilities of sound remain largely unexplored in monitoring tools. The performance monitor that are currently under development implement sonic data representation are <ref> [RP91, FJA91, ZT92b] </ref>. The use of sound is based on sonic widgets that allow the mapping of sequences of scalar or higher order dimensional data values to frequencies, durations, timbres, attacks/decays and stereo balance.
Reference: [RR89a] <author> D. Reed and L. Rudolph. </author> <title> Experience with hypercube operating system instrumentation. </title> <journal> International journal of high-speed computing, </journal> <pages> pages 517-542, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In [MAA + 89] the instrumented kernel approach has been adopted as a complement to the object-code instrumentation. The instrumented kernel detects the system events, whereas the instrumented object-code handles the application events. Some other monitoring systems have modified the Operating system : <ref> [RR89a] </ref> for the Ncube OS, [vRT92c], for TROLLIUS. 3.3.3 A complete software monitor A complete monitoring system not only detects events, but also generates, stores, processes (if there is a form of distributed processing), and transports the event-records.
Reference: [RR89b] <author> D. C. Rudolph and D. A. Reed. </author> <title> Crystal : Intel iPSC/2 operating system instrumentation. </title> <booktitle> In Proceedings of the 4th Conference on Hypercube Concurrent Computers and Applications, </booktitle> <pages> pages 249-252, </pages> <year> 1989. </year>
Reference-contexts: On most machines instrumenting a kernel will be a far from easy task and might even necessitate completely rewriting the kernel or writing a new kernel. This makes an instrumented kernel the least portable and the least flexible type of software monitoring. The Crystal project <ref> [RR89b] </ref> and TOPSYS (see section 6.4) have adopted the instrumented-kernel approach. In Crystal, that runs on an iPSC/2, the original NX operating system has been modified by adding software probes to the NX source code. <p> Some of these methods will be briefly introduced here. The simplest way of analyzing runtime information consists of collecting statistics from the individual event-records. ParaGraph [HE91b] and the Crystal <ref> [RR89b] </ref> are typical examples of tools that use this approach. Among the gathered statistics are cumulative busy/idle times, cumulative communication times, number of bytes sent, etc. More complex analysis is provided by the integration into the monitoring environment of statistical analysis packages, that allow the interactive analysis of the trace-data.
Reference: [SBN88] <author> D. Socha, M. Bailey, and D. Notkin. </author> <title> Voyeur : Graphical views of parallel programs. </title> <booktitle> In ACM, editor, Proceedings SIGPLAN/SIGOPS workshops on parallel and distributed debugging, </booktitle> <pages> pages 206-215, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A user-interface should possess some additional features that help the user to interact with the different views on the data. In this section, 12 For examples of these graphical representations see <ref> [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, CK90, SBN88] </ref>. 13 For other representations that represent interactions between different object see section 6 and [Abs90, GGJ + 89, HE91a, LMCF92, LSV + 89, MAA + 89, CK90, SBN88]. 14 As opposed to icons. 29 features of existing tools that we <p> In Voyeur <ref> [SBN88] </ref>, an original solution has been found to this problem that will be briefly discussed here. The main idea of Voyeur is that the user should be allowed to add high-level application-specific views of parallel programs to the user-interface.
Reference: [SK90] <author> M. Simmons and R. Koskela, </author> <title> editors. Performance Instrumentation and visualization, Frontier Series, </title> <address> Santa Fe, New Mexico, </address> <month> May </month> <year> 1990. </year> <title> ACM, </title> <publisher> Addison-Wesley Publishing Compagny. </publisher>
Reference: [SM92] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed communications :in search of the holy grail. </title> <type> Technical Report 15/92, </type> <institution> Universitat Keiserslautern, </institution> <address> Postflach 3049, D-6750 Keiserslautern, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: In [Fid88] the use of partially ordered logical clocks is proposed as a solution to this problem and a debugging strategy based on these partially ordered clocks is proposed <ref> [Mat89, SM92, DJ91] </ref>. e1 e2 before e2 Proc 1 Proc 2 Observer e1 wrongly e1 e1 correctly before e2 Proc 1 Proc 2 Observer point of view. 2.10.2 Practical implementations [IM93] shows that the global time precision can influence the understanding of the trace based representation.
Reference: [Sto88] <author> J. M. Stone. </author> <title> A graphical representation of concurrent processes. </title> <booktitle> In ACM, editor, Proceedings SIGPLAN/ SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 226-235, </pages> <month> May </month> <year> 1988. </year>
Reference: [TIB92] <author> N. Topham, R. Ibbett, and T. </author> <title> Bemmerl, </title> <editor> editors. </editor> <booktitle> Programming Environments for parallel computing, volume A-11 of IFIP Transactions, </booktitle> <address> Edinburgh, Scotland, April 1992. </address> <publisher> IFIP, North Holland. </publisher>
Reference: [vRT92a] <author> M. van Riek and B. Tourancheau. </author> <title> The design of the general parallel monitoring system. </title> <editor> In Topham et al. </editor> <booktitle> [TIB92], </booktitle> <pages> pages 127-137. </pages>
Reference-contexts: The only drawback is that complex OS cost a lot in context switches and thus diminish the overall performance of the system and precision of the probes. Meter Buffer Mgr Backend Slave Application Probes Arbitrary Network The TIPS programming environment [WCG + 92] and GPMS <ref> [vRT92a] </ref> implement this "specialized processes" model.
Reference: [vRT92b] <author> M. van Riek and B. Tourancheau. </author> <title> A framework to parallel monitoring on distributed memory multicomputers. </title> <booktitle> In Transputer'92, </booktitle> <address> Besan~con, France, March 1992. </address> <publisher> IAO Press. </publisher> <pages> 50 </pages>
Reference-contexts: The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph [GHPW90, Wor92]. Paragraph is used in many laboratories [DL93, FJA91] and has been ported on top of different parallel systems <ref> [vRT92b, GHSG92] </ref>; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views.
Reference: [vRT92c] <author> M. van Riek and B. Tourancheau. </author> <title> A parallel monitoring system and its implementation under the trollius operating system. </title> <editor> In Topham et al. </editor> <publisher> [TIB92]. </publisher>
Reference-contexts: The MMK kernel of TOPSYS is an example of a tool where the operating system has been modified [BL92]. There is also a modification of Intel OS NX/2 tool in [MRR90] and Trollius OS <ref> [vRT92c] </ref>. In [LCSM92] two classes of events are introduced that group atomic events according to their availability in monitoring tools. <p> In [MAA + 89] the instrumented kernel approach has been adopted as a complement to the object-code instrumentation. The instrumented kernel detects the system events, whereas the instrumented object-code handles the application events. Some other monitoring systems have modified the Operating system : [RR89a] for the Ncube OS, <ref> [vRT92c] </ref>, for TROLLIUS. 3.3.3 A complete software monitor A complete monitoring system not only detects events, but also generates, stores, processes (if there is a form of distributed processing), and transports the event-records.
Reference: [vRTV92] <author> M. van Riek, B. Tourancheau, and X. Vigouroux. </author> <title> The massively parallel monitoring system (a truly approach to parallel monitoring). </title> <note> In Haring [HG92]. </note>
Reference-contexts: A distributed collection system on the other hand consists of a set of reactive processes (one per node), where each reactive process monitors those processes that are local to its node. Partially distributed collection systems with one reactive process supervising several nodes could be devised. The PIMSY tool <ref> [PTV92, vRTV92] </ref> is based on this approach and tries to prove the advantage of such a system. <p> Building this view in a completely distributed manner is feasible, but would require a great deal of communications between the different processes (for example, in PIMSY <ref> [vRTV92] </ref>, the data is filtered and gathered by servers just before being given to processes that requested it).
Reference: [WCG + 92] <author> A. Wagner, S. Chanson, N. Goldstein, J. Jiang, H. Larsen, and H. Sreekantaswamy. </author> <title> Tips : Transputer-based interactive parallelizing system, </title> <year> 1992. </year>
Reference-contexts: The only drawback is that complex OS cost a lot in context switches and thus diminish the overall performance of the system and precision of the probes. Meter Buffer Mgr Backend Slave Application Probes Arbitrary Network The TIPS programming environment <ref> [WCG + 92] </ref> and GPMS [vRT92a] implement this "specialized processes" model. <p> Obviously, the "unload when buffer full" strategy often complements this strategy. The "unload when low load" complemented by the "unload when buffer full" strategy has been adopted by the TMON monitor of the TIPS environment <ref> [WCG + 92] </ref>. 4.3 Store and unload afterwards The "store and unload afterwards" strategy does not affect the behavior of the communication network. The event-records are stored in a local memory buffer and unloaded when all the active processes have finished their activities. <p> Other views include Critical Path, Clock, Phase Portrait, Message queues, Communication meter, Communication traffic, Processor status, Statistical Summary, etc. For more information about these views refer to [HE91a]. 33 6.2 TMON 6.2.1 Introduction The Transputer MONitor forms an integral part of the TIPS parallel programming environment as described in <ref> [WCG + 92] </ref> that was developed at the University of British Columbia. The TIPS parallel programming environment consists of 4 major components: TMON (a performance monitor), TMAP (a process to processor mapping tool), TVIEW (a graphical interface), TRES (a tool to identify and analyze the resource requirements) of an application.
Reference: [Wor92] <author> P. Worley. </author> <title> A new PICL trace file format. </title> <type> Technical Report TM-12125, </type> <institution> Oak Ridge National Laboratory, Oak Ridge, </institution> <address> TN 37831, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: The Portable Instrumented Communication Library (PICL) is the instrumented library that generates runtime information for ParaGraph <ref> [GHPW90, Wor92] </ref>. Paragraph is used in many laboratories [DL93, FJA91] and has been ported on top of different parallel systems [vRT92b, GHSG92]; thus it has became a de facto standard and will be presented as a basic tool. ParaGraph displays the run-time information through different animated graphical views. <p> PICL is a subroutine library that can be used to develop parallel programs that are portable across several distributed-memory multiprocessors <ref> [Wor92] </ref>. The routines that are provided by PICL implement many of the system dependent functions, such as the communication primitives, synchronization, and other system calls. Part of the library are some high-level functions, such as broadcasting.
Reference: [ZT92a] <author> E. Zabala and R. Taylor. </author> <title> Maritxu : Generic visualisation of highly parallel processing. </title> <editor> In Topham et al. </editor> <booktitle> [TIB92], </booktitle> <pages> pages 171-180. </pages>
Reference-contexts: The program and the representation of the new metrics are linked by External Data collectors units (EDCU). The EDCUs are divided into two parts : the metric specific part (how to generate the information), the histogram generation part (how to use it). 6.7 Maritxu Maritxu <ref> [ZT92a] </ref>, developed at the University of York (UK) by Eugenio Zabala and Richard Taylor is a tool close to the hardware (processors, network,...).
Reference: [ZT92b] <author> E. Zabala and R. Taylor. </author> <title> Process and processor interaction: Architecture independent visual-sation schema. </title> <booktitle> In Dongarra and Tourancheau [DT92], </booktitle> <pages> pages 55-72. 51 </pages>
Reference-contexts: In spite of the fact that psychological studies have shown that users respond more quickly to audio cues than to visual signals in certain instances [RP91], the possibilities of sound remain largely unexplored in monitoring tools. The performance monitor that are currently under development implement sonic data representation are <ref> [RP91, FJA91, ZT92b] </ref>. The use of sound is based on sonic widgets that allow the mapping of sequences of scalar or higher order dimensional data values to frequencies, durations, timbres, attacks/decays and stereo balance. <p> The Maritxu tool has been designed by taking into account the psychological aspect of perception. Therefore, the use of color has been chosen because human being has a better graphical perception than a textual one. Furthermore, Maritxu has been enhanced by the addition of sound <ref> [ZT92b] </ref>. The user of Maritxu has thus not only visual stimuli but also audio ones. 42 6.8 PIE PIE [LSV + 89] (Parallel Programming and Instrumentation Environment) was developed at Carnegie Mellon university.
References-found: 82

