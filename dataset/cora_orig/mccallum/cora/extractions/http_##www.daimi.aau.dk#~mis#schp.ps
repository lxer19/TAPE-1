URL: http://www.daimi.aau.dk/~mis/schp.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Email: mis@daimi.aau.dk  
Title: Static Correctness of Hierarchical Procedures  
Author: Michael I. Schwartzbach 
Address: Ny Munkegade DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department Aarhus University  
Note: To appear in Theoretical Computer Science. Also in Proc. ICALP'90, pages 32-45.  
Abstract: A system of hierarchical, fully recursive types in a truly imperative language allows program fragments written for small types to be reused for all larger types. To exploit this property to enable type-safe hierarchical procedures, it is necessary to impose a static requirement on procedure calls. We introduce an example language and prove the existence of a sound requirement which preserves static correctness while allowing hierarchical procedures. This requirement is further shown to be optimal, in the sense that it imposes as few restrictions as possible. This establishes the theoretical basis for a general type hierarchy with static type checking, which enables 1st order polymorphism combined with multiple inheritance and specialization in a language with assignments. We extend the results to include opaque types. An opaque version of a type is different from the original but has the same values and the same order relations to other types. The opaque types allow a more flexible polymorphism and provide the usual pragmatic advantages 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Cardelli, L. </author> <note> "Typeful Programming" DEC Research Report 45, </note> <year> 1989. </year>
Reference: [2] <author> Cardelli, L. & Mitchell, J. </author> <booktitle> "Operations on Records" in Proceedings of MFPS'90, </booktitle> <volume> LNCS Vol 442, </volume> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: There have been many suggestions for languages with a similar subtype poly-morphism. Ours is unique in allowing truly imperative features such as assignments, subvariables, and variable parameters. Many systems rely on coercions [1,2,4,6] which have distinct disadvantages such as type loss and the update problem <ref> [2] </ref>. We avoid these; for example, the procedure Proc Id (var x: ) skip end Id will be the identity on both the type and the value of any argument.
Reference: [3] <author> Cardelli, L. & Wegner, P. </author> <title> "On Understanding Types, Data Abstraction, </title> <journal> and Polymorphism" in Computing Surveys, </journal> <volume> Vol 17 No 4, </volume> <booktitle> ACM 1985. </booktitle>
Reference-contexts: Naturally, we hope that this can develop into a complete programming language. It is worth noting that all in fact defines a partial order on types. This seems to suggest that the hierarchical mechanism may be viewed as a version of (implicit) bounded parametric polymorphism <ref> [3] </ref>. The ordering is, however, radically different from the usual subtyping relation, as it satisfies 8S 1 T 1 9S 2 T 2 : (S 1 ; S 2 ) 6 (T 1 ; T 2 ) which we might call anti-compositionality, to coin a phrase.
Reference: [4] <author> Courcelle, B. </author> <title> "Infinite Trees in Normal Form and Recursive Equations Having a Unique Solution" in Mathematical Systems Theory 13, </title> <address> 131-180. </address> <publisher> Springer-Verlag 1979. </publisher>
Reference: [5] <author> Courcelle, B. </author> <title> "Fundamental Properties of Infinite Trees" in Theoretical Computer Science Vol 25 No 1, </title> <publisher> North-Holland 1983. </publisher>
Reference-contexts: Being regular, the type o has finitely many different subtypes o 1 ; o 2 ; : : : ; o k , where o = o 1 . The o i 's can be uniquely defined <ref> [5] </ref> through a set of type equations of the form o i = f i (o 1 ; o 2 ; : : : ; o k ) Now, the type ff = ff 1 is defined by the equations ff i = A # oe if F # oe =
Reference: [6] <author> Reynolds, </author> <title> J.C. "Three approaches to type structure.", </title> <booktitle> In Mathematical Foundations of Software Development, </booktitle> <volume> LNCS Vol 185, </volume> <publisher> Springer-Verlag 1985. </publisher>
Reference: [7] <author> Schmidt, </author> <title> E.M. & Schwartzbach, M.I. "An Imperative Type Hierarchy with Partial Products" in Proceedings of MFCS'89, </title> <note> LNCS Vol 379, Springer-Verlag 1989. </note>
Reference-contexts: The partiality of the product will prove essential to the correctness of the hierarchy. Furthermore, partial products yield a pragmatically advantageous notation for specifying recursive types, in particular when combined with the notion of structural invariants. Details are presented in <ref> [7] </ref>. The values of types may be taken to be the -least solutions to the corresponding equations on sets induced by the above interpretation of the type constructors. Other interpretations of types are possible; for example, one may include infinite (lazy) values. <p> If 0 is this inductive (finite) refinement of v, then the full ordering is defined as S T , 8S 0 v S; jS 0 j &lt; 1 : S 0 0 T Thus, products with fewer components are smaller than products with more components. As noted in <ref> [7] </ref>, trees under this ordering no longer form a cpo. However, all the chains definable by type equations still have limits.
Reference: [8] <author> Schwartzbach, M.I. </author> <title> "Infinite Values in Hierarchical Imperative Types" in Proceedings of CAAP'90, </title> <publisher> LNCS, Springer-Verlag 1990. </publisher>
Reference-contexts: The values of types may be taken to be the -least solutions to the corresponding equations on sets induced by the above interpretation of the type constructors. Other interpretations of types are possible; for example, one may include infinite (lazy) values. The variety of different interpretations is investigated in <ref> [8] </ref>. 4 2.1 Type Equivalence Several type expressions may be taken to denote the same type. These can be identified by an equivalence relation , which is defined as the identity of normal forms, using the techniques of [4,5].
Reference: [9] <author> Schwartzbach, M.I. & Schmidt, </author> <title> E.M. "Types and Automata". </title> <institution> PB-316, Department of Computer Science, Aarhus University, </institution> <year> 1990. </year>
Reference-contexts: There is a natural isomorphism between such automata and type equations. The above decision problem translates to a variation of language inclusion for which an efficient algorithm is presented in <ref> [9] </ref>. 2 Example 6.10: The type T defined by the equations Type A = (x : B; y : C) Type B = Type C = flD Type D = (x : E; z : F ) Type E = flA Type F = Int corresponds to the automaton 21 OEAE
Reference: [10] <author> Wirth, N. </author> <title> "Type Extensions.", </title> <booktitle> In Transactions on Programming Languages and Systems Vol 10 No 2, ACM 1988. </booktitle> <pages> 38 </pages>
Reference-contexts: The presence of variables or mutable types [1,2] have so far lead to unsafe type systems, unless the subtype ordering is trivialized in this case. A system which operationally is more similar to ours is that of type extensions <ref> [10] </ref>. However, several important issues are not addressed, leading to various anomalies. For example, just allowing actual parameters to have larger types than formal parameters is too liberal an attitude. We must have a homogeneous choice of larger types, as the following example shows.
References-found: 10

