URL: http://www-cad.eecs.berkeley.edu/~orna/publications/ictl97.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: orna@eecs.berkeley.edu,  vardi@cs.rice.edu,  
Phone: 2  
Title: Synthesis with Incomplete Informatio  
Author: Orna Kupferman ?? and Moshe Y. Vardi ??? 
Web: http://www-cad.eecs.berkeley.edu/ orna  http://www.cs.rice.edu/ vardi  
Address: Berkeley, Berkeley CA 94720-1770, U.S.A.  Houston, TX 77251-1892, U.S.A.  
Affiliation: 1 EECS Department, UC  Rice University, Department of Computer Science,  
Abstract: In program synthesis, we transform a specification into a system that is guaranteed to satisfy the specification. When the system is open, then at each moment it reads input signals and writes output signals, which depend on the input signals and the history of the computation so far. The specification considers all possible input sequences. Thus, if the specification is linear, it should hold in every computation generated by the interaction, and if the specification is branching, it should hold in the tree that embodies all possible input sequences. Often, the system cannot read all the input signals generated by its environment. For example, in a distributed setting, it might be that each process can read input signals of only part of the underlying processes. Then, we should transform a specification into a system whose output depends only on the readable parts of the input signals and the history of the computation. This is called synthesis with incomplete information. In this work we solve the problem of synthesis with incomplete information in its full generality. We consider linear and branching settings with complete and incomplete information. We claim that alternation is a suitable and helpful mechanism for coping with incomplete information. Using alternating tree automata, we show that incomplete information does not make the synthesis problem more complex, in both the linear and the branching paradigm. In particular, we prove that independently of the presence of incomplete information, the synthesis problems for CTL and CTL ? are complete for EXPTIME and 2EXPTIME, respectively.
Abstract-found: 1
Intro-found: 1
Reference: [ALW89] <author> M. Abadi, L. Lamport, and P. Wolper. </author> <title> Realizable and unrealizable concurrent program specifications. </title> <booktitle> In Proc. 16th ICALP, </booktitle> <volume> LNCS 372, </volume> <pages> pp. 1-17. </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In program synthesis, we transform a specification into a program that is guaranteed to satisfy the specification. Earlier works on synthesis consider closed systems. There, a program that meets the specification can be extracted from a constructive proof that the formula is satisfiable [MW80, EC82]. As argued in <ref> [Dil89, PR89, ALW89] </ref>, such synthesis paradigms are not of much interest when applied to open systems, which interact with an environment. Consider for example a scheduler for a printer that serves two users. The scheduler is an open system.
Reference: [Ant95] <author> M. Antoniotti. </author> <title> Synthesis and verification of discrete controllers for robotics and manufacturing devices with temporal logic and the Control-D system. </title> <type> PhD thesis, </type> <address> New York University, New York, </address> <year> 1995. </year>
Reference-contexts: Correct synthesis of then amounts to constructing such P . We note that this problem is different from the supervisor-synthesis problem considered in <ref> [Ant95] </ref>. There, a given structure needs to be restricted (by disabling some of its transitions) in order to satisfy a given branching specification. So far, we considered the case where the specifications (either linear or branching) refer solely to signals in I and O, both are known to P .
Reference: [BL69] <author> J.R. Buchi and L.HG. </author> <title> Landweber. Solving sequential conditions by finite-state strategies. </title> <journal> Trans. AMS, </journal> <volume> 138 </volume> <pages> 295-311, </pages> <year> 1969. </year>
Reference-contexts: The solutions to Church's problem and the LTL synthesis problem are similar [Rab70, PR89], and consist of a reduction to the nonemptiness problem of tree automata (an earlier and more complicated solution can be found in <ref> [BL69] </ref>). Though the program P is deterministic, it induces a computation tree. The branches of the tree correspond to external nondeterminism, caused by different possible inputs.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th CAV, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 142-155, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Here, alternation enables us to define automata that are exponentially smaller than automata with no alternations. Theorem 1. <ref> [BVW94] </ref> Given a CTL ? formula over a set AP of atomic propositions and a set of directions, there exists an alternating Rabin tree automaton A ; over 2 AP -labeled -trees, with 2 O (j j) states and two pairs, such that L (A ; ) is exactly the set <p> The function ffi 0 is essentially the same function used in the original alternating tree automata framework for CTL model checking in <ref> [BVW94] </ref>. The only change is that ffi 0 attributes the states with modes.
Reference: [Chu63] <author> A. Church. </author> <title> Logic, arithmetics, and automata. </title> <booktitle> In Proc. International Congress of Mathematicians, </booktitle> <year> 1962, </year> <pages> pp. 23-35. </pages> <address> institut Mittag-Leffler, </address> <year> 1963. </year>
Reference-contexts: Correct synthesis of then amounts to constructing such P [PR89]. The linear paradigm for realizability and synthesis is closely related to Church's solvability problem <ref> [Chu63] </ref>.
Reference: [Dil89] <author> D.L. Dill. </author> <title> Trace theory for automatic hierarchical verification of speed independent circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction In program synthesis, we transform a specification into a program that is guaranteed to satisfy the specification. Earlier works on synthesis consider closed systems. There, a program that meets the specification can be extracted from a constructive proof that the formula is satisfiable [MW80, EC82]. As argued in <ref> [Dil89, PR89, ALW89] </ref>, such synthesis paradigms are not of much interest when applied to open systems, which interact with an environment. Consider for example a scheduler for a printer that serves two users. The scheduler is an open system.
Reference: [EC82] <author> E.A. Emerson and E.M. Clarke. </author> <title> Using branching time logic to synthesize synchronization skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction In program synthesis, we transform a specification into a program that is guaranteed to satisfy the specification. Earlier works on synthesis consider closed systems. There, a program that meets the specification can be extracted from a constructive proof that the formula is satisfiable <ref> [MW80, EC82] </ref>. As argued in [Dil89, PR89, ALW89], such synthesis paradigms are not of much interest when applied to open systems, which interact with an environment. Consider for example a scheduler for a printer that serves two users. The scheduler is an open system.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: When we synthesize P from an LTL specification , we require to hold in all the paths of P 's computation tree. Consequently, we cannot impose possibility requirements on P <ref> [Lam80, EH86] </ref>.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th FOCS, </booktitle> <pages> pp. 368-377, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The upper bounds then follow from the known translation of alternating Rabin tree automata to nondeterministic Rabin tree automata [MS95] and the complexity of the nonemptiness problem for the latters <ref> [EJ88, PR89] </ref>.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pp. 997-1072, </pages> <year> 1990. </year>
Reference-contexts: In order to express possibility properties, we should specify P using branching temporal logics, which enable both universal and existential path quantification <ref> [Eme90] </ref>. Given a branching specification over I [ O (we consider here specifications given in terms of CTL or CTL ? formulas), realizability of is the problem of determining whether there exists a program P whose computation tree satisfies . Correct synthesis of then amounts to constructing such P . <p> These results join the 2EXPTIME-complete bound for LTL synthesis in both settings [PR89, Ros92, Var95]. Keeping in mind that the satisfiability problems for LTL, CTL, and CTL ? are complete for PSPACE, EXPTIME, and 2EXPTIME <ref> [Eme90] </ref>, it follows that while the transition from closed to open systems dramatically increases the complexity of synthesis in the linear paradigm, it does not influence the complexity in the branching paradigm. 2 Preliminaries Given a finite set , an -tree is a set T fl such that if x 2
Reference: [ES84] <author> A.E. Emerson and A.P. Sistla. </author> <title> Deciding full branching time logics. </title> <journal> Information and Control, </journal> <volume> 61(3) </volume> <pages> 175-201, </pages> <year> 1984. </year>
Reference-contexts: This problem can be easily solved using tree automata. Essentially, we first construct a tree automaton A that accepts exactly all 2 I [O -labeled trees that satisfy <ref> [ES84, VW86] </ref>. Then, we construct a tree automaton A P that accepts all the potential computation trees (i.e., all 2 I [O -labeled trees obtained by annotating the I-exhaustive tree with outputs). Finally, we check that the intersection of the two automata is nonempty.
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: By [VW86], we can therefore check the nonemptiness of the product of A and A exh in time exponential in j j. The lower bound follows from the known lower bound to the satisfiability problem for CTL <ref> [FL79] </ref>. ut 5 Discussion We suggest a framework for the synthesis problem in its full generality. The difficulties caused by incomplete information require the use of alternating tree automata.
Reference: [KG95] <author> R. Kumar and V.K. Garg. </author> <title> Modeling and control of logical discrete event systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: Essentially, nondeterminism of the automata can be used to guess the missing information, making sure that no guess violates the specification [Var95]. Similarly, methods for control and synthesis in other linear paradigms (e.g., when specifying terminating programs by regular languages) have been extended to handle incomplete information <ref> [KG95, KS95] </ref>. Coping with incomplete information is more difficult in the branching paradigm. The methods used in the linear paradigm are not applicable here. To see why, let us consider first realizability with complete information.
Reference: [KS95] <author> R. Kumar and M.A. Shayman. </author> <title> Supervisory control of nondeterministic systems under partial observation and decentralization. </title> <journal> SIAM Journal of Control and Optimization, </journal> <year> 1995. </year>
Reference-contexts: Essentially, nondeterminism of the automata can be used to guess the missing information, making sure that no guess violates the specification [Var95]. Similarly, methods for control and synthesis in other linear paradigms (e.g., when specifying terminating programs by regular languages) have been extended to handle incomplete information <ref> [KG95, KS95] </ref>. Coping with incomplete information is more difficult in the branching paradigm. The methods used in the linear paradigm are not applicable here. To see why, let us consider first realizability with complete information.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes not never on the temporal logic of programs. </title> <booktitle> In Proc. 7th POPL, </booktitle> <pages> pp. 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: When we synthesize P from an LTL specification , we require to hold in all the paths of P 's computation tree. Consequently, we cannot impose possibility requirements on P <ref> [Lam80, EH86] </ref>.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: This condition is non-regular and cannot be checked by an automaton. In order to solve this difficulty, we need the framework of alternating tree automata. 4.1 Alternating Tree Automata Alternating tree automata run on labeled trees. They generalize nondeterministic tree automata and were first introduced in <ref> [MS87] </ref>. For simplicity, we refer first to automata over infinite binary trees. Consider a nondeterministic tree automaton A with a set Q of states and transition function ffi.
Reference: [MS95] <author> D.E. Muller and P.E. Schupp. </author> <title> Simulating aternating tree automata by nondeterministic automata: New results and new proofs of theorems of Rabin, McNaughton and Safra. </title> <journal> Theoretical Computer Science, </journal> <volume> 141 </volume> <pages> 69-107, </pages> <year> 1995. </year>
Reference-contexts: Furthermore, the nonemptiness algorithm for A can be extended. within the same complexity bounds to produce a finite-state strategy. Proof: Rabin proved the theorem for nondeterministic Rabin tree automata [Rab70]. Muller and Schupp translated alternating tree automata to nondeterministic tree automata of the same acceptance condition <ref> [MS95] </ref>. ut Theorem 6. The synthesis problem for LTL and CTL ? , with either complete or incomplete information, is 2EXPTIME-complete. Proof: We reduced the synthesis problem for a CTL ? formula to the nonemptiness problem of an alternating Rabin tree automaton with exponentially many states and linearly many pairs. <p> Proof: We reduced the synthesis problem for a CTL ? formula to the nonemptiness problem of an alternating Rabin tree automaton with exponentially many states and linearly many pairs. The upper bounds then follow from the known translation of alternating Rabin tree automata to nondeterministic Rabin tree automata <ref> [MS95] </ref> and the complexity of the nonemptiness problem for the latters [EJ88, PR89]. <p> The first automaton, A , is an alternating Buchi tree automaton with O (j j) states. The second, A exh , is a nondeterministic Buchi automaton with 2 O (j j) states. By <ref> [MS95] </ref>, we can translate A to an alternating Buchi tree automaton with 2 O (j j) states. By [VW86], we can therefore check the nonemptiness of the product of A and A exh in time exponential in j j.
Reference: [MW80] <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <year> 1980. </year>
Reference-contexts: 1 Introduction In program synthesis, we transform a specification into a program that is guaranteed to satisfy the specification. Earlier works on synthesis consider closed systems. There, a program that meets the specification can be extracted from a constructive proof that the formula is satisfiable <ref> [MW80, EC82] </ref>. As argued in [Dil89, PR89, ALW89], such synthesis paradigms are not of much interest when applied to open systems, which interact with an environment. Consider for example a scheduler for a printer that serves two users. The scheduler is an open system.
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: Of course, this should hold no matter how the users send jobs. We can specify the requirement for the scheduler in terms of a linear temporal logic (LTL) formula <ref> [Pnu81] </ref>. Satisfiability of does not imply that a required scheduler exists. To see this, observe that is satisfied in every structure in which the four signals never hold. In addition, an evidence to 's satisfiability is not of much help in extracting a correct scheduler.
Reference: [PR89] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. 16th POPL, </booktitle> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In program synthesis, we transform a specification into a program that is guaranteed to satisfy the specification. Earlier works on synthesis consider closed systems. There, a program that meets the specification can be extracted from a constructive proof that the formula is satisfiable [MW80, EC82]. As argued in <ref> [Dil89, PR89, ALW89] </ref>, such synthesis paradigms are not of much interest when applied to open systems, which interact with an environment. Consider for example a scheduler for a printer that serves two users. The scheduler is an open system. <p> Given an LTL formula over I [ O, realizability of is the problem of determining whether there exists a program P all of whose computations satisfy . Correct synthesis of then amounts to constructing such P <ref> [PR89] </ref>. The linear paradigm for realizability and synthesis is closely related to Church's solvability problem [Chu63]. <p> A function f as above then maps every possible input sequence into a permitted output sequence, and can be therefore viewed as a correct program. The solutions to Church's problem and the LTL synthesis problem are similar <ref> [Rab70, PR89] </ref>, and consist of a reduction to the nonemptiness problem of tree automata (an earlier and more complicated solution can be found in [BL69]). Though the program P is deterministic, it induces a computation tree. The branches of the tree correspond to external nondeterminism, caused by different possible inputs. <p> It is known how to cope with incomplete information in the linear paradigm. In particular, the approach used in <ref> [PR89] </ref> can be extended to handle LTL synthesis with incomplete information. Essentially, nondeterminism of the automata can be used to guess the missing information, making sure that no guess violates the specification [Var95]. <p> In particular, we prove that independently of the presence of incomplete information, the synthesis problems for CTL and CTL ? are complete for EXPTIME and 2EXPTIME, respectively. These results join the 2EXPTIME-complete bound for LTL synthesis in both settings <ref> [PR89, Ros92, Var95] </ref>. <p> It is easy to see that problem of branching synthesis with incomplete information is a proper extension of the problem of branching synthesis with complete information. We claim that it is also a proper extension of the linear synthesis problem with incomplete (and hence also complete) information <ref> [PR89, PR90, Var95] </ref>. For that, we show that synthesis for an LTL formula ' can be reduced to synthesis for the CTL ? formula A'. Moreover, ' and A' are realized by the same programs. Consider a program P . Assume first that P realizes A'. <p> In more detail, we show that CTL ? synthesis with incomplete information can be done in 2EXPTIME, matching the 2EXPTIME lower bound for LTL synthesis with complete information. 4 The Solution Church's solvability problem and the LTL synthesis problem are solved, in <ref> [Rab70, PR89] </ref>, using nondeterministic tree automata. <p> Thus, finite-state programs are generated by finite-state automata. We sometimes refer also to finite state strategies, for arbitrary -labeled -trees. It is shown in <ref> [PR89] </ref> that for every realizable LTL specification we can synthesize a finite-state program. In the theorem below, we show that this holds also for the general synthesis problem. Theorem 5. Given an alternating tree automaton A over -labeled -trees, the following are equivalent: 1. A is nonempty. 2. <p> The upper bounds then follow from the known translation of alternating Rabin tree automata to nondeterministic Rabin tree automata [MS95] and the complexity of the nonemptiness problem for the latters <ref> [EJ88, PR89] </ref>. <p> The lower bounds follow from the known lower bounds to the realizability problem for LTL and the satisfiability problems for CTL ? <ref> [VS85, PR89, Ros92] </ref>. ut 4.4 Handling CTL Specifications More Efficiently As CTL is a subset of CTL ? , the algorithm described in Theorem 4 suggests a solution for the synthesis problem of CTL. <p> In the presence of incomplete information, it needs to pass an additional simple transformation (narrow). Our framework handles, as a special case, the classical LTL synthesis problem and suggest a simpler solution for this case. In particular, it avoids the determinization procedure required in <ref> [PR89] </ref>. Typically, alternating tree automata shift all the combinatorial difficulties of the synthesis problem, in both the linear and the branching framework, to the nonemptiness test.
Reference: [PR90] <author> A. Pnueli and R. Rosner. </author> <title> Distributed reactive systems are hard to synthesize. </title> <booktitle> In Proc. 31st FOCS, </booktitle> <pages> pp. 746-757, </pages> <year> 1990. </year>
Reference-contexts: It is easy to see that problem of branching synthesis with incomplete information is a proper extension of the problem of branching synthesis with complete information. We claim that it is also a proper extension of the linear synthesis problem with incomplete (and hence also complete) information <ref> [PR89, PR90, Var95] </ref>. For that, we show that synthesis for an LTL formula ' can be reduced to synthesis for the CTL ? formula A'. Moreover, ' and A' are realized by the same programs. Consider a program P . Assume first that P realizes A'.
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <booktitle> In Proc. Symp. Math. Logic and Foundations of Set Theory, </booktitle> <pages> pp. 1-23. </pages> <publisher> North Holland, </publisher> <year> 1970. </year>
Reference-contexts: A function f as above then maps every possible input sequence into a permitted output sequence, and can be therefore viewed as a correct program. The solutions to Church's problem and the LTL synthesis problem are similar <ref> [Rab70, PR89] </ref>, and consist of a reduction to the nonemptiness problem of tree automata (an earlier and more complicated solution can be found in [BL69]). Though the program P is deterministic, it induces a computation tree. The branches of the tree correspond to external nondeterminism, caused by different possible inputs. <p> In more detail, we show that CTL ? synthesis with incomplete information can be done in 2EXPTIME, matching the 2EXPTIME lower bound for LTL synthesis with complete information. 4 The Solution Church's solvability problem and the LTL synthesis problem are solved, in <ref> [Rab70, PR89] </ref>, using nondeterministic tree automata. <p> There exists a finite-state strategy f : fl ! such that h fl ; f i 2 L (A). Furthermore, the nonemptiness algorithm for A can be extended. within the same complexity bounds to produce a finite-state strategy. Proof: Rabin proved the theorem for nondeterministic Rabin tree automata <ref> [Rab70] </ref>. Muller and Schupp translated alternating tree automata to nondeterministic tree automata of the same acceptance condition [MS95]. ut Theorem 6. The synthesis problem for LTL and CTL ? , with either complete or incomplete information, is 2EXPTIME-complete.
Reference: [Ros92] <author> R. Rosner. </author> <title> Modular Synthesis of Reactive Systems. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1992. </year>
Reference-contexts: In particular, we prove that independently of the presence of incomplete information, the synthesis problems for CTL and CTL ? are complete for EXPTIME and 2EXPTIME, respectively. These results join the 2EXPTIME-complete bound for LTL synthesis in both settings <ref> [PR89, Ros92, Var95] </ref>. <p> The lower bounds follow from the known lower bounds to the realizability problem for LTL and the satisfiability problems for CTL ? <ref> [VS85, PR89, Ros92] </ref>. ut 4.4 Handling CTL Specifications More Efficiently As CTL is a subset of CTL ? , the algorithm described in Theorem 4 suggests a solution for the synthesis problem of CTL.
Reference: [Var95] <author> M.Y. Vardi. </author> <title> An automata-theoretic approach to fair realizability and synthesis. </title> <booktitle> In Proc. 7th CAV, </booktitle> <volume> LNCS 939, </volume> <pages> pp. 267-292. </pages> <year> 1995. </year>
Reference-contexts: In particular, the approach used in [PR89] can be extended to handle LTL synthesis with incomplete information. Essentially, nondeterminism of the automata can be used to guess the missing information, making sure that no guess violates the specification <ref> [Var95] </ref>. Similarly, methods for control and synthesis in other linear paradigms (e.g., when specifying terminating programs by regular languages) have been extended to handle incomplete information [KG95, KS95]. Coping with incomplete information is more difficult in the branching paradigm. The methods used in the linear paradigm are not applicable here. <p> In particular, we prove that independently of the presence of incomplete information, the synthesis problems for CTL and CTL ? are complete for EXPTIME and 2EXPTIME, respectively. These results join the 2EXPTIME-complete bound for LTL synthesis in both settings <ref> [PR89, Ros92, Var95] </ref>. <p> It is easy to see that problem of branching synthesis with incomplete information is a proper extension of the problem of branching synthesis with complete information. We claim that it is also a proper extension of the linear synthesis problem with incomplete (and hence also complete) information <ref> [PR89, PR90, Var95] </ref>. For that, we show that synthesis for an LTL formula ' can be reduced to synthesis for the CTL ? formula A'. Moreover, ' and A' are realized by the same programs. Consider a program P . Assume first that P realizes A'.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th STOC, </booktitle> <pages> pp. 240-251, </pages> <year> 1985. </year>
Reference-contexts: The lower bounds follow from the known lower bounds to the realizability problem for LTL and the satisfiability problems for CTL ? <ref> [VS85, PR89, Ros92] </ref>. ut 4.4 Handling CTL Specifications More Efficiently As CTL is a subset of CTL ? , the algorithm described in Theorem 4 suggests a solution for the synthesis problem of CTL.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: This problem can be easily solved using tree automata. Essentially, we first construct a tree automaton A that accepts exactly all 2 I <ref> [O -labeled trees that satisfy [ES84, VW86] </ref>. Then, we construct a tree automaton A P that accepts all the potential computation trees (i.e., all 2 I [O -labeled trees obtained by annotating the I-exhaustive tree with outputs). Finally, we check that the intersection of the two automata is nonempty. <p> This problem can be easily solved using tree automata. Essentially, we first construct a tree automaton A that accepts exactly all 2 I [O -labeled trees that satisfy <ref> [ES84, VW86] </ref>. Then, we construct a tree automaton A P that accepts all the potential computation trees (i.e., all 2 I [O -labeled trees obtained by annotating the I-exhaustive tree with outputs). Finally, we check that the intersection of the two automata is nonempty. <p> The second, A exh , is a nondeterministic Buchi automaton with 2 O (j j) states. By [MS95], we can translate A to an alternating Buchi tree automaton with 2 O (j j) states. By <ref> [VW86] </ref>, we can therefore check the nonemptiness of the product of A and A exh in time exponential in j j.
References-found: 26

