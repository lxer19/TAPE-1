URL: http://www.cs.rice.edu/~adve/CS615/emerald_sosp95.ps
Refering-URL: http://www.cs.rice.edu/~adve/comp615.html
Root-URL: 
Title: Object and Native Code Thread Mobility Among Heterogeneous Computers  
Author: Bjarne Steensgaard Eric Jul 
Address: One Microsoft Way  Redmond, WA 98052 Universitetsparken 1 USA DK-2100 Kbenhavn Denmark  
Affiliation: Microsoft Research DIKU (Dept. of Computer Science)  University of Copenhagen  
Abstract: We present a technique for moving objects and threads among heterogeneous computers at the native code level. To enable mobility of threads running native code, we convert thread states among machine-dependent and machine-independent formats. We introduce the concept of bus stops, which are machine-independent representations of program points as represented by program counter values. The concept of bus stops can be used also for other purposes, e.g., to aid inspecting and debugging optimized code, garbage collection etc. We also discuss techniques for thread mobility among processors executing differently optimized codes. We demonstrate the viability of our ideas by providing a prototype implementation of object and thread mobility among heterogeneous computers. The prototype uses the Emerald distributed programming language without modification; we have merely extended the Emerald runtime system and the code generator of the Emerald compiler. Our extensions allow object and thread mobility among VAX, Sun-3, HP9000/300, and Sun SPARC workstations. The excellent intra-node performance of the original homogeneous Emerald is retained: migrated threads run at native code speed before and after migration; the same speed as on homogeneous Emerald and close to C code performance. Our implementation of mobility has not been optimized: thread mobility and trans-architecture invocations take about 60% longer than in the homogeneous implementation. We believe this is the first implementation of full object and thread mobility among heterogeneous computers with threads executing native code. 
Abstract-found: 1
Intro-found: 1
Reference: [ABLN85] <author> Guy T. Almes, Andrew P. Black, Edward D. Lazowska, and Jerre D. Noe. </author> <title> The Eden System: A Technical Review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node <ref> [ABLN85, Bla85] </ref>. Mobility of threads/processes among heterogeneous processors relies on mapping information from a machine-dependent program format to a machine-independent program format and vice versa.
Reference: [Ame89] <institution> American National Standards Institute, Inc. Programming language C, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Given a set of bus stops, the code generator is free to optimize code between bus stops in any way, as the optimization transformations are not visible to the runtime system. In this respect, bus stops are related to the synchronization points of ANSI C <ref> [Ame89] </ref>. Compiler support is necessary to generate both the information needed to describe machine-dependent use of registers and temporaries in activation records and the bus stop information. No change to the generated code is necessary.
Reference: [BCL + 87] <author> Brian N. Bershad, Dennis T. Ching, Edward D. La-zowska, Jan Sanislo, and Michael Schwartz. </author> <title> A remote procedure call facility for interconnecting heterogeneous computer systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(8):880-894, </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: 1 Introduction A trend in distributed operating systems has been to either support communication and remote procedure call [BN84] among heterogeneous computers <ref> [BCL + 87, Gib87] </ref> or to support object and thread/process mobility among homogeneous computers [Jul89, Dou87].
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference: [BHJL86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <month> October </month> <year> 1986. </year> <journal> ACM SIG-PLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year>
Reference: [Bla85] <author> Andrew P. Black. </author> <title> Supporting distributed applications: Experience with Eden. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 181-193. </pages> <institution> Association for Computing Machinery, </institution> <month> December </month> <year> 1985. </year>
Reference-contexts: In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node <ref> [ABLN85, Bla85] </ref>. Mobility of threads/processes among heterogeneous processors relies on mapping information from a machine-dependent program format to a machine-independent program format and vice versa.
Reference: [BN84] <author> Andrew D. Birrell and Bruce J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: 1 Introduction A trend in distributed operating systems has been to either support communication and remote procedure call <ref> [BN84] </ref> among heterogeneous computers [BCL + 87, Gib87] or to support object and thread/process mobility among homogeneous computers [Jul89, Dou87].
Reference: [Bra94] <author> Sren Brandt. </author> <title> Migration and checkpointing in BETA. </title> <type> Private communication, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: The codes for a single program compiled for heterogeneous processors have all been subject to exactly the same transformations. His preemption points are similar to our bus stops. Sren Brandt at the University of Aarhus, Denmark, is planning a migration and checkpointing package <ref> [Bra94] </ref> for the BETA programming language [MMPN93]. The package should enable checkpointing and migration of objects, including process objects, among heterogeneous workstations running BETA.
Reference: [Car95] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> In Proceedings 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 286-297, </pages> <address> San Francisco, California, </address> <month> January 22-25, </month> <year> 1995. </year>
Reference-contexts: The reason for this is that Emerald was designed for robust distributed computing: node crashes are considered normal, expected events. We want to minimize residual dependencies [PM83], e.g., by co-locating threads with the objects within which they are executing. Our model differs from the model used in Oblique <ref> [Car95] </ref> where the objects are moved to where the threads are executing. Object and thread mobility among heterogeneous computers is straightforward, if a system executes machine-independent byte codes and operates on machine-independent data. However, the price of this painless migration is execution inefficiency due to interpretation.
Reference: [DMH92] <author> Amer Diwan, Eliot Moss, and Richard Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, California, </address> <month> January 17-19 </month> <year> 1992. </year>
Reference-contexts: The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and [H ol95] and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector [JLHB88, JJ92, Juu93], and GC-points in <ref> [DMH92] </ref>). In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node [ABLN85, Bla85].
Reference: [Dou87] <author> Fred Douglis. </author> <title> Process migration in the Sprite operating system. </title> <type> Technical Report UCB/CSD 87/343, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <month> February </month> <year> 1987. </year> <note> A revised version of this paper appeared in the 7th International Conference on Distributed Computing Systems. </note>
Reference-contexts: 1 Introduction A trend in distributed operating systems has been to either support communication and remote procedure call [BN84] among heterogeneous computers [BCL + 87, Gib87] or to support object and thread/process mobility among homogeneous computers <ref> [Jul89, Dou87] </ref>. We have combined the two by extending the Emerald system [BHJL86, BHJ + 87, Hut87, HRB + 87, JLHB88, Jul89, RTL + 91] to support object and native code thread mobility among fl Work done while at DIKU, University of Copenhagen, Denmark. <p> Mobility is fine-grained in the sense that individual objects, regardless of size, can move independent of other objects residing on the same processor node. Mobility is not restricted to mobility of entire address spaces as in, e.g., the Sprite operating system <ref> [Dou87] </ref> and the DEMOS/MP operating system [PM83]. By a thread we mean a light-weight thread of control running (pseudo-) concurrently with other threads within a single address space. By thread mobility in an object system we mean that a thread is able to move among processor nodes. <p> They limit the number of optimizations they perform in order to be able to do the deoptimization. A number of other systems offer native code process or thread mobility, e.g., Sprite <ref> [Dou87] </ref> and DEMOS/MP [PM83], but they only support such mobility among homogeneous processors. 6 Conclusion We have shown how object and thread mobility among heterogeneous computers can be implemented by converting both normal data and program state to and from a machine-independent format during move operations.
Reference: [DS84] <author> Peter Deutsch and Alan Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Proceedings 11th Symposium on the Principles of Programming Languages, </booktitle> <address> Salt Lake City, Utah, </address> <year> 1984. </year>
Reference-contexts: Programs are statically specialized to specific processors by installers. It should be possible to implement process mobility among heterogeneous processors using ANDF as the machine-independent format. The use of bus stops is already in use in several programming tools (e.g., interrupt points in <ref> [DS84] </ref> and [H ol95] and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector [JLHB88, JJ92, Juu93], and GC-points in [DMH92]).
Reference: [Ern94] <author> Michael Ernst. </author> <title> Practical fine-grained static slicing of optimized code. </title> <type> Technical Report MSR-TR-94-14, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Program slicing using optimized program representations also relies 9 on maintaining relationships between an optimized representation of the program and the original program representation (the source code or a parse tree) <ref> [Tip95, Ern94] </ref>. We expect future work in this area to develop techniques to maintain relationships between abstract values describing the unoptimized and optimized program representations respectively, even in the presence of data changing transformations such as strength reduction in loops.
Reference: [Fis81] <author> Joseph A. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: One way to overcome code motion differences between different compiled instances of the code is to build bridging code between the origin and destination instances of the code. The different instances of code can be viewed as the super-blocks of Trace Scheduling <ref> [Fis81] </ref>; the bridging code is then equivalent to the entry paths to and the exit paths from the super-block, and the bridging code can be constructed using similar techniques. Example 2 Consider the code sequences shown in Figure 3.
Reference: [Gib87] <author> Phillip B. Gibbons. </author> <title> A stub generator for multilanguage RPC in heterogeneous environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):77-87, </volume> <month> Jan-uary </month> <year> 1987. </year>
Reference-contexts: 1 Introduction A trend in distributed operating systems has been to either support communication and remote procedure call [BN84] among heterogeneous computers <ref> [BCL + 87, Gib87] </ref> or to support object and thread/process mobility among homogeneous computers [Jul89, Dou87].
Reference: [Hen82] <author> John L. Hennessy. </author> <title> Symbolic debugging of optimized code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: It should be possible to implement process mobility among heterogeneous processors using ANDF as the machine-independent format. The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and [H ol95] and stopping points in <ref> [Hen82] </ref>), and garbage collection (e.g., the Emerald Garbage Collector [JLHB88, JJ92, Juu93], and GC-points in [DMH92]).
Reference: [Hoa74] <author> C.A.R. Hoare. </author> <title> Monitors: An operating system structuring construct. </title> <journal> Communications of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: The Motorola 68000 processors (used in Sun-3 and HP9000/300 workstations) and SPARC processors cannot perform the unlinking as an atomic operation. As unlinking is used to implement monitors <ref> [Hoa74] </ref> in Emerald, a system call is required to ensure the atomicity of the unlinking operation. The bus stops on all types of processors must be isomorphic to each other.
Reference: [H ol95] <author> Urs H olzle. </author> <title> Adaptive Optimization for Self: Recon-siling High Performance with Exploratory Programming. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1995. </year> <note> 10 [HRB + 87] Norman C. </note> <author> Hutchinson, Rajendra K. Raj, Andrew P. Black, Henry M. Levy, and Eric Jul. </author> <title> The Emerald programming language report. </title> <type> Technical Report 87-10-07, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, WA, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: It should be possible to implement mobility of Java and TeleScript processes among heterogeneous processors under the same conditions as for Taos processes. It is our understanding that the Taos, Java, and TeleScript compilers differ from the SELF compiler <ref> [HU94, H ol95] </ref> by not being very aggressive with respect to optimizations. The OSF's Architecture-Neutral Distribution Format (ANDF [TN94]) is a low-level machine-independent program representation. Programs are statically specialized to specific processors by installers. <p> Programs are statically specialized to specific processors by installers. It should be possible to implement process mobility among heterogeneous processors using ANDF as the machine-independent format. The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and <ref> [H ol95] </ref> and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector [JLHB88, JJ92, Juu93], and GC-points in [DMH92]). <p> Such techniques are likely to be directly useful for generating bridging code in the presence of data changing transformations. Dynamic translation of optimized code to unoptimized code is performed in the latest version of the SELF system <ref> [H ol95] </ref>. They limit the number of optimizations they perform in order to be able to do the deoptimization.
Reference: [HU94] <author> Urs H olzle and David Ungar. </author> <title> A third-generation SELF implementation reconciling responsiveness with performance. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 229-243, </pages> <address> Portland, OR, </address> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: It should be possible to implement mobility of Java and TeleScript processes among heterogeneous processors under the same conditions as for Taos processes. It is our understanding that the Taos, Java, and TeleScript compilers differ from the SELF compiler <ref> [HU94, H ol95] </ref> by not being very aggressive with respect to optimizations. The OSF's Architecture-Neutral Distribution Format (ANDF [TN94]) is a low-level machine-independent program representation. Programs are statically specialized to specific processors by installers.
Reference: [Hut87] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Wash-ington, </institution> <address> Seattle, WA, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: However, this tracking is fundamentally no different than that which is required for supporting homogeneous object and thread mobility. Even in the homogeneous case, the compiler must produce extensive information concerning the location and type of variables that must be converted during the move <ref> [Hut87, Jul89] </ref>. The advantage of such extensive compiler support is that node-local operations are very efficientas efficient as comparable C programsbecause the runtime overhead is restricted to actual migration operations while non-migration operations are not affected at all. <p> Intra-node computations will therefore execute exactly the same instructions (and in the same order) on the original Emerald system and our enhanced Emerald system. The intra-node runtime performance (comparable to that provided by C compilers <ref> [Hut87] </ref> and on the SPARC architectures at times even better [Mar92]) should therefore in theory be exactly the same on both systems. Measurements on both systems verify this trivially.
Reference: [Int94] <author> Intel Corporation. </author> <title> Pentium Processor User's Manual, </title> <year> 1994. </year>
Reference-contexts: Assume that code1 is part of the code for an object to be moved, and the program counter value corresponding to the switch () operation is visible. The program counter may be visible, if switch () 3 RISCification is common in, e.g., compilers for the Pentium processor <ref> [Int94] </ref> where only a subset of simple instructions may be executed simultaneously with other instructions in the processor's other execution pipeline. 4 code1 op1; switch (); - op3; op5; bridge op2; op5; code2 op2; switch (); op4; op3; the code sequence code1 to using the code sequence code2 at the switch
Reference: [IOS94] <author> International Organization for Standardization. </author> <title> Information Technology Abstract Syntax Notation One (ASN.1), </title> <month> February </month> <year> 1994. </year>
Reference: [JJ92] <author> Niels Christian Juul and Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, IWMM 92, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 103-115, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <title> INRIA, IRISA, </title> <booktitle> and ACM Sigplan, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and [H ol95] and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector <ref> [JLHB88, JJ92, Juu93] </ref>, and GC-points in [DMH92]). In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node [ABLN85, Bla85].
Reference: [JLHB88] <author> Eric Jul, Henry Levy, Norman Hutchinson, and An-drew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year> <note> Appeared originally at SOSP'87. </note>
Reference-contexts: We introduce the concept of bus stops to represent program counter values in a machine-independent manner. To demonstrate our ideas we have taken an existing object based system with migration, the Emerald system (see <ref> [JLHB88] </ref> 1 ), and enhanced it with support for heterogeneous migration. The Emerald language includes constructs for specifying object mobility (and thereby also thread mobility). The language can be used without modification. <p> The issues related to mobility among heterogeneous processors is then no different than mobility among homogeneous processors and can be performed as described in <ref> [JLHB88] </ref>. However, if the code is machine-dependent, e.g., native code, we cannot execute the same code on heterogeneous processors unless we implement interpreters of the various other machine-dependent formats on each type of processor, which typically is very inefficient. <p> The prototype is an extension of the Emerald programming system, which originally supported object and thread mobility among homogeneous processors <ref> [JLHB88, Jul89] </ref>. <p> The extra effort to do this was considered unimportant for demonstrating our points. 3.2 Features of the Original Emerald System The original Emerald system supports both object and thread mobility among homogeneous processors not using distributed shared memory <ref> [JLHB88] </ref>. The processors are workstations connected in a local network. Fine-grained objects can be extracted from the address space of one processor and moved to another processor. All activation records describing invocations of methods in the moved objects are moved along with the objects, thereby implementing thread mobility. <p> The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and [H ol95] and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector <ref> [JLHB88, JJ92, Juu93] </ref>, and GC-points in [DMH92]). In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node [ABLN85, Bla85].
Reference: [Jul89] <author> Eric Jul. </author> <title> Object Mobility in a Distributed Object-Oriented System. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, WA, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction A trend in distributed operating systems has been to either support communication and remote procedure call [BN84] among heterogeneous computers [BCL + 87, Gib87] or to support object and thread/process mobility among homogeneous computers <ref> [Jul89, Dou87] </ref>. We have combined the two by extending the Emerald system [BHJL86, BHJ + 87, Hut87, HRB + 87, JLHB88, Jul89, RTL + 91] to support object and native code thread mobility among fl Work done while at DIKU, University of Copenhagen, Denmark. <p> However, this tracking is fundamentally no different than that which is required for supporting homogeneous object and thread mobility. Even in the homogeneous case, the compiler must produce extensive information concerning the location and type of variables that must be converted during the move <ref> [Hut87, Jul89] </ref>. The advantage of such extensive compiler support is that node-local operations are very efficientas efficient as comparable C programsbecause the runtime overhead is restricted to actual migration operations while non-migration operations are not affected at all. <p> The Emerald system relies on its compiler to generate code that transfers control to the runtime system instead of having the runtime system preempt the threads <ref> [Jul89] </ref>. Control can only be transferred to the runtime system at suitable chosen points: at system calls, operation invocation entry (procedure/function calls), and at the bottom of loops. <p> The prototype is an extension of the Emerald programming system, which originally supported object and thread mobility among homogeneous processors <ref> [JLHB88, Jul89] </ref>. <p> The initial design of the Emerald system allowed for multiple templates for each activation record, each template being valid for a certain range of program counter values. Initial experiments found that multiple templates could be avoided by a combination of careful compiler design and the bus stops technique <ref> [Jul89] </ref>. Apart from the template information necessary for the runtime system to support mobility among homogeneous processors, the Emerald compiler also generates debugging information for use by a symbolic debugger. The debugging information identifies the exact locations and types of both global object variables and local variables.
Reference: [Juu93] <author> Niels Christian Juul. </author> <title> Comprehensive, Concurrent, and Robust Garbage Collection in the Distributed, Object-Based System, Emerald. </title> <type> PhD thesis, </type> <institution> DIKU, Department of Computer Science, University of Copenhagen, </institution> <month> February </month> <year> 1993. </year> <note> Available as Technical Report DIKU 93/1. </note>
Reference-contexts: The use of bus stops is already in use in several programming tools (e.g., interrupt points in [DS84] and [H ol95] and stopping points in [Hen82]), and garbage collection (e.g., the Emerald Garbage Collector <ref> [JLHB88, JJ92, Juu93] </ref>, and GC-points in [DMH92]). In some systems, coarse-graind bus stops have been used for migration, e.g., mobility in Eden was achieved by check-pointing an object, which dumped the object to stable storage, and subsequently moving the stored image and restarting it on another node [ABLN85, Bla85].
Reference: [Kl94] <author> Jan Klander. </author> <title> Implementation af OSI-protokoller i det distribuerede system Emerald vha. ISODE. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Copenhagen, 1994. DIKU M.S. </institution> <note> thesis no. 450. In Danish. </note>
Reference-contexts: He also worked on an extension of the ISODE tools to describe thread states in a machine-independent manner for the purposes of transferring a thread state over the network <ref> [Kl94] </ref>. Peter Smith at the University of British Columbia, Canada, is investigating techniques to implement a heterogeneous migration package to be used primarily with C but which should be usable for other languages [Smi95]. His system enables mobility of entire (native code) processes among Sun-3 and Sun-4 workstations.
Reference: [Mar92] <author> Jacob Marquard. </author> <title> Porting Emerald to a SPARC. </title> <type> Master's thesis, </type> <institution> DIKU, Department of Computer Science, University of Copenhagen, </institution> <year> 1992. </year>
Reference-contexts: Intra-node computations will therefore execute exactly the same instructions (and in the same order) on the original Emerald system and our enhanced Emerald system. The intra-node runtime performance (comparable to that provided by C compilers [Hut87] and on the SPARC architectures at times even better <ref> [Mar92] </ref>) should therefore in theory be exactly the same on both systems. Measurements on both systems verify this trivially. Thus we have achieved one of our major goals: to provide heterogeneous thread mobility at the same time as preserving node-local performance.
Reference: [MMPN93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The codes for a single program compiled for heterogeneous processors have all been subject to exactly the same transformations. His preemption points are similar to our bus stops. Sren Brandt at the University of Aarhus, Denmark, is planning a migration and checkpointing package [Bra94] for the BETA programming language <ref> [MMPN93] </ref>. The package should enable checkpointing and migration of objects, including process objects, among heterogeneous workstations running BETA. This work is still in the design stage. 5.2 Relevant Techniques IN the Taos operating system [Pou91], all programs are compiled to a machine-independent byte code representation.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <note> ISBN 0-201-63337-X. </note>
Reference-contexts: For example, most systems use the processor's native representation for integers (little or big endian) and floating point numbers (IEEE or non-IEEE). A notable exception is Tcl <ref> [Ous94] </ref>, which represents all types of data as strings.
Reference: [PM83] <author> Michael L. Powell and Barton P. Miller. </author> <title> Process migration in DEMOS/MP. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 110-119, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: Mobility is fine-grained in the sense that individual objects, regardless of size, can move independent of other objects residing on the same processor node. Mobility is not restricted to mobility of entire address spaces as in, e.g., the Sprite operating system [Dou87] and the DEMOS/MP operating system <ref> [PM83] </ref>. By a thread we mean a light-weight thread of control running (pseudo-) concurrently with other threads within a single address space. By thread mobility in an object system we mean that a thread is able to move among processor nodes. <p> The reason for this is that Emerald was designed for robust distributed computing: node crashes are considered normal, expected events. We want to minimize residual dependencies <ref> [PM83] </ref>, e.g., by co-locating threads with the objects within which they are executing. Our model differs from the model used in Oblique [Car95] where the objects are moved to where the threads are executing. <p> They limit the number of optimizations they perform in order to be able to do the deoptimization. A number of other systems offer native code process or thread mobility, e.g., Sprite [Dou87] and DEMOS/MP <ref> [PM83] </ref>, but they only support such mobility among homogeneous processors. 6 Conclusion We have shown how object and thread mobility among heterogeneous computers can be implemented by converting both normal data and program state to and from a machine-independent format during move operations.
Reference: [Pou91] <author> D. Pountain. Taos: </author> <title> An innovation in operating systems. </title> <journal> BYTE, </journal> <volume> 16(1), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: The package should enable checkpointing and migration of objects, including process objects, among heterogeneous workstations running BETA. This work is still in the design stage. 5.2 Relevant Techniques IN the Taos operating system <ref> [Pou91] </ref>, all programs are compiled to a machine-independent byte code representation. At load-time, the byte code representation is compiled on the fly to native code. While we have no detailed information on the compilation process, we speculate it will be rather simple in order to be fast.
Reference: [Rep90] <author> John H. Reppy. </author> <title> Asynchronous signals in Standard ML. </title> <type> Technical Report TR 90-1144, </type> <institution> Computer Science Department, Cornell University, </institution> <note> August 1990. </note> <author> [RTL + 91] Rajendra K. Raj, Ewan D. Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchinson, and Eric Jul. </author> <title> Emerald: A general-purpose programming language. </title> <journal> Software Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 91-118, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: However, for the implementation to function correctly, it is necessary that the unique object identifiers, OIDs, are the same for all versions of the program. most of the user code polls are free. Roughly the same method is used to implement signals in Standard ML of New Jersey <ref> [Rep90] </ref>. In a homogeneous processor environment, the same object code can be used on all workstations, and it makes sense to assign object code OIDs. In a heterogeneous processor environment, only object code compiled for a specific type of workstation can be used.
Reference: [SC88] <author> Michael W. Strevell and Harvey G. Cragon. </author> <title> High-speed transformation of primitive data types in a heterogeneous distributed computer system. </title> <booktitle> In The 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 41-45. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Heterogeneous RPC implementations usually also support conversion of more complicated data types [BCL + It is also possible for each processor type to use its own machine-dependent format and then convert data between machine-dependent formats as required by each data transfer <ref> [SC88] </ref>. Unfortunately, the number of conversion routines required is quadratic in the number of data formats. Furthermore, supporting a new data format requires modifying existing systems by adding the necessary data conversion routines. 2.2 Migrating Threads Moving a thread really amounts to moving a thread state. <p> Previous work has shown that multiple protocols can be used for RPC in a heterogeneous environment to avoid the extra overhead of converting data to a machine-independent format (network format) when performing RPC between homogeneous processors <ref> [SC88] </ref>. The extra effort to do this was considered unimportant for demonstrating our points. 3.2 Features of the Original Emerald System The original Emerald system supports both object and thread mobility among homogeneous processors not using distributed shared memory [JLHB88]. The processors are workstations connected in a local network.
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 17-29, </pages> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices 21(11) </journal> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: We say that the critical program counter values are made invisible and that the remaining values are visible. Such restriction of visibility be achieved in that multiple ways. The Trellis/Owl system <ref> [SCB + 86] </ref> permitted transfer of control to the runtime system at any time (e.g., by interrupts), but if the transfer of control happened in a critical region, the top layer of the runtime system would execute by interpretation the necessary number of instructions to exit the critical region before calling
Reference: [SGK + 85] <author> R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and implementation of the SUN Network File System. </title> <booktitle> In Proceedings of the Summer Usenix Conference, </booktitle> <year> 1985. </year>
Reference: [Smi95] <author> Peter Smith. </author> <title> Phd thesis proposal: The possibilities and limitations of heterogeneous process migration. </title> <institution> University of British Columbia, Canada., </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Peter Smith at the University of British Columbia, Canada, is investigating techniques to implement a heterogeneous migration package to be used primarily with C but which should be usable for other languages <ref> [Smi95] </ref>. His system enables mobility of entire (native code) processes among Sun-3 and Sun-4 workstations. The programs must all be written in a type-safe subset of C and must be compiled by a special C compiler.
Reference: [Sun84] <author> Sun Microsystems, Inc. </author> <title> eXternal Data Representation Reference Manual, </title> <month> September </month> <year> 1984. </year>
Reference: [Sun88] <author> Sun Microsystems, Inc. Byteorder(3N), </author> <year> 1988. </year> <title> Unix manual page. </title>
Reference-contexts: to convert 16 and 32 bit integers to network byte order before sending them over the network (e.g., when performing a remote procedure call) and converting them back to host byte order at the receiving end, e.g., using the htons (3), ntohs (3), htonl (3), and ntohl (3) library functions <ref> [Sun88] </ref>. Heterogeneous RPC implementations usually also support conversion of more complicated data types [BCL + It is also possible for each processor type to use its own machine-dependent format and then convert data between machine-dependent formats as required by each data transfer [SC88].
Reference: [Sun95] <author> Sun Microsystems, Inc. </author> <title> The Java language: </title> <note> A white paper, 1995. Available from http://java.sun.com/. </note>
Reference-contexts: Java and TeleScript programs are also dynamically compiled from a machine-independent format to a machine-dependent format <ref> [Sun95, Tel95] </ref>. It should be possible to implement mobility of Java and TeleScript processes among heterogeneous processors under the same conditions as for Taos processes.
Reference: [Tel95] <author> TeleScript. </author> <title> Compilation of telescript programs. </title> <address> Second-hand rumors, </address> <year> 1995. </year>
Reference-contexts: Java and TeleScript programs are also dynamically compiled from a machine-independent format to a machine-dependent format <ref> [Sun95, Tel95] </ref>. It should be possible to implement mobility of Java and TeleScript processes among heterogeneous processors under the same conditions as for Taos processes.
Reference: [Tip95] <author> Frank Tip. </author> <title> Generation of Program Analysis Tools. </title> <type> PhD thesis, </type> <institution> Universiteit van Amsterdam, Institute for Logic, </institution> <note> Language and Computation, 1995. Available as a book in the ILLC dissertation series (contact illc@fwi.uva.nl). </note>
Reference-contexts: Program slicing using optimized program representations also relies 9 on maintaining relationships between an optimized representation of the program and the original program representation (the source code or a parse tree) <ref> [Tip95, Ern94] </ref>. We expect future work in this area to develop techniques to maintain relationships between abstract values describing the unoptimized and optimized program representations respectively, even in the presence of data changing transformations such as strength reduction in loops.
Reference: [TN94] <author> Jens Ulrik Toft and Jens P. Nielsen. </author> <title> Formal Specification of ANDF. </title> <editor> DDC-International A/A, G. Lundtoftevej 1B, </editor> <address> 2800 Lyngby, Denmark, </address> <month> January </month> <year> 1994. </year> <note> Document code 202104/RPT/19 issue 2. 11 </note>
Reference-contexts: It is our understanding that the Taos, Java, and TeleScript compilers differ from the SELF compiler [HU94, H ol95] by not being very aggressive with respect to optimizations. The OSF's Architecture-Neutral Distribution Format (ANDF <ref> [TN94] </ref>) is a low-level machine-independent program representation. Programs are statically specialized to specific processors by installers. It should be possible to implement process mobility among heterogeneous processors using ANDF as the machine-independent format.
References-found: 43

