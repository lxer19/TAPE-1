URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/express.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Title: On the Expressive Power of Programming Languages  
Author: Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: The literature on programming languages contains an abundance of informal claims on the relative expressive power of programming languages, but there is no framework for formalizing such statements nor for deriving interesting consequences. As a first step in this direction, we develop a formal notion of expressiveness and investigate its properties. To validate the theory, we analyze some widely held beliefs about the expressive power of several extensions of functional languages. Based on these results, we believe that our system correctly captures many of the informal ideas on expressiveness, and that it constitutes a foundation for further research in this direction.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abramsky, S. </author> <title> The lazy -calculus. In Declarative Programming, </title> <editor> D. Turner (ed). </editor> <publisher> Addison Wesley, </publisher> <year> 1988, </year> <pages> 65-116. </pages>
Reference-contexts: No matter which argument the procedure x evaluates first, the expression (YK) eventually appears in the hole of the evaluation context, which leads to an immediate termination of the program evaluation. 10 Gordon Plotkin pointed out Abramsky's <ref> [1] </ref> and Ong's [31] work on the lazy -calculus, which corrected a mistake in an early draft. 20 In the full language fl, the above analysis no longer holds: Call-by-value proce-dures can evaluate and discard the expression (YK) in a way that does not affect the rest of the program. <p> Thus, in the extended setting fl n + fbeging is more expressive than fl v + fbeging. The claim is still valid if the new facility is already in the language universe. Take the same example and add v xy:y, i.e., Abramsky's <ref> [1] </ref> convergence tester C for fl n , to both sub-languages, which is equivalent to adding begin. 23 The example in the preceding theorem formalizes Algol 60's definition of call-by--value as an abbreviation of a call-by-name procedure preceded by an additional block or statement [30:12]; i.e., it is not the pure <p> As a consequence, such models naturally lead to the discovery of non-expressible programming constructs. In the framework of -calculus languages, such facilities are multiple argument functions that do not require the values of all arguments to determine their result <ref> [33, 1] </ref>. Still, the study of full abstraction does not provide true insight into the expressive power of languages. On one hand, the discovery of new facilities directly depends on the choice of a model.
Reference: 2. <author> Baker, H.G. and C. Hewitt. </author> <title> The incremental garbage collection of processes. </title> <booktitle> In Proceedings of the Symposium on Artificial Intelligence and Programming Languages. SIGPLAN Notices 12(8), </booktitle> <year> 1977, </year> <pages> 55-59. </pages>
Reference-contexts: Hans Boehm, Robert 16 This is not to be confused with compiler annotations, which also preserve the operational equivalences but do not increase the expressive power of a language, e.g., futures for indicating opportunities for parallel evaluations <ref> [2, 19] </ref> and single-threaded destructive updates in functional languages [18]. 41 Cartwright, Dan Friedman, Robert Hieb, John Lamping, Scott Smith, Rebecca Selke, Carolyn Talcott, Mitchell Wand and numerous of my patient seminar students suggested many improvements in the presentation of the material.
Reference: 3. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Unlike logic, the programming language world does not know such ubiquitous constructs as the logical connectors. Our prototypical example of a programming language is a derivative of the language fl of the pure -calculus <ref> [3] </ref>. Figure 1 summarizes its (concrete) syntax and semantics. In order to compare the expressiveness of call-by-value and call-by-name procedures later in this section, we extend fl with a new constructor, v , and rename to n . <p> Below, v and n denote the sets of all -constructors. For readability, we use concrete syntax for fl-terms and adopt the traditional -calculus conventions about its use <ref> [3] </ref>. The constructors v x and n x bind the variable x in their term arguments. The set of free variables in an expression e, fv (e), is the set of variables that are in e and are not bound. <p> Some of his results may be relevant for future extensions of our work. A secondary piece of related work is the study of the full abstraction property of mathematical models [25, 31, 33] and the representability of functions in -calculi <ref> [3, 4] </ref>. In many cases, the natural denotational model of a programming language contains too many elements so that operationally equivalent phrases have different mathematical meanings.
Reference: 4. <author> Berry, G. Sequentialite de l'evaluation formelle des -expressions. </author> <booktitle> In Proc. 3rd International Colloquium on Programming, </booktitle> <year> 1978. </year>
Reference-contexts: Some of his results may be relevant for future extensions of our work. A secondary piece of related work is the study of the full abstraction property of mathematical models [25, 31, 33] and the representability of functions in -calculi <ref> [3, 4] </ref>. In many cases, the natural denotational model of a programming language contains too many elements so that operationally equivalent phrases have different mathematical meanings.
Reference: 5. <author> Burris, S. and H. P. Sankappanaras. </author> <title> A Course in Universal Algebra. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: In the terminology of universal algebra, the set of expressions is the universe of a free term algebra <ref> [5] </ref>; instead of relying on the more typical algebraic 1 We assume that there is enough structure on an infinite set of constructors for specifying the decidability of predicates and the recursiveness of translations on the set of phrases. <p> More technically, the translation of a phrase is the evaluation of a term (in the sense of universal algebra <ref> [5] </ref>) over the restricted language at the translations of the subphrases. As mentioned above, terms correspond to contexts in our framework; for clarity, we refer to contexts as syntactic abstractions 8 in relation to the following definition and its uses. <p> For a comparison of arbitrary programming languages, these relations are too weak. One solution is to conceive of our abstract programming languages as signatures (or types in the sense of universal algebra <ref> [5] </ref>) for classes of real programming languages. It is then possible to compare languages by comparing their signatures if one signature happens to be a conservative extension of the other.
Reference: 6. <author> Chandra, A.K. and Z. Manna. </author> <title> The power of programming features. </title> <note> Journal of Computer Languages (Pergamon Press) 1, </note> <year> 1975, </year> <pages> 219-232. </pages>
Reference-contexts: simple statements and to state the purpose of a program in the concisest possible manner. 6 Related Work The earliest attempt at defining and comparing the expressive power of programming languages is the work on comparative schematology by Chandra, Hewitt, Manna, Paterson, and others in the early and mid seventies <ref> [6, 32] </ref>. Schematology studies programming languages with a simple set of control constructs, e.g., while-loop programs or recursion equations, and with uninterpreted constant and function symbols. As in predicate logic without arithmetic, it is possible to decide certain questions about such uninterpreted program schemas.
Reference: 7. <author> Church, A. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic 5(1), </journal> <year> 1940, </year> <pages> 56-68. </pages>
Reference-contexts: An explicit inclusion of the lexical scoping structure through a Church encoding <ref> [7] </ref> of the language in a typed lambda calculus is a feasible and interesting alternative but would probably lead to a slightly different definition of expressibility and expressiveness. 5 Phrases e ::= x j v j (ee) (expressions) v ::= ( v x:e) j ( n x:e) (values) Programs e is
Reference: 8. <author> Felleisen, M. </author> <title> The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> Ph.D. dissertation, </type> <institution> Indiana University, </institution> <year> 1987. </year>
Reference: 9. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 180-190. </pages>
Reference-contexts: A more realistic model of Scheme systems (as opposed to the Scheme semantics [35]) would have to include the interactive loop, which provides a delimiter for control actions <ref> [9] </ref>. By including an appropriate version of this delimiter in PS (control), abort becomes macro-expressible as a combination of call/cc and the control delimiter [39]. Put differently, interactive programming systems actually add expressive power to the programming language.
Reference: 10. <author> Felleisen, M. and D.P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. In Formal Description of Programming Concepts III , edited by M. Wirsing. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> Amsterdam, </address> <year> 1986, </year> <pages> 193-217. </pages>
Reference: 11. <author> Felleisen, M. and D.P. Friedman. </author> <title> A syntactic theory of sequential state. </title> <journal> Theor. Comput. Sci. </journal> <volume> 69(3), </volume> <year> 1989, </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987, </year> <pages> 314-325. 42 </pages>
Reference-contexts: In the following subsections, ~ = ps denotes the operational equivalence relation on Pure Scheme; other indexes correspond to extensions of Pure Scheme and should be self-explanatory. The main characteristic of Idealized Scheme <ref> [11, 12, 13] </ref> is the extension of the functional core language Pure Scheme with type predicates, local branching constructs, and imperative facilities: * branching expressions for the local manipulation of control, * predicate constants for determining the type of a value, * control operators for the non-local manipulation of control, and <p> Clearly, PS (state) is a conservative extension of Pure Scheme; the new semantics is the basis for an equational calculus for reasoning about operational equivalences in PS (state) <ref> [11, 12] </ref>. Proposition 4.7 Pure Scheme cannot express set! and letrec. Proof Sketch. Consider the expression ((lambda (d) (f 0)) (f 0)), which contains the same subexpression, (f 0), twice. <p> For every subsequent proper transaction, the 15 This comparison is part of the folklore of the expressiveness discussion [24:165]; the particular example is adapted from our previous paper on the equational semantics of assignments <ref> [11] </ref>. 36 procedure then uses an assignment to increase TransCounter by 1. There is a special transaction of appropriate type that can check the number of past transactions. A program in Pure Scheme|or any other functional language without assignments| must realize the counting of transactions in a different way.
Reference: 12. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <note> Accepted at TCS </note> . 
Reference-contexts: In the following subsections, ~ = ps denotes the operational equivalence relation on Pure Scheme; other indexes correspond to extensions of Pure Scheme and should be self-explanatory. The main characteristic of Idealized Scheme <ref> [11, 12, 13] </ref> is the extension of the functional core language Pure Scheme with type predicates, local branching constructs, and imperative facilities: * branching expressions for the local manipulation of control, * predicate constants for determining the type of a value, * control operators for the non-local manipulation of control, and <p> With the semantics of Figure 5, it is trivial to verify that the extensions are conservative over Pure Scheme. The semantics forms the basis of a simple equational calculus for abort and call/cc, and permits simple, algebra-like reasoning about programs with control operations <ref> [12, 13] </ref>. All three languages are more expressive than Pure Scheme. Proposition 4.5 Pure Scheme cannot macro-express non-local control constructs: Pure Scheme cannot macro-express abort or call/cc relative to PS (abort), PS (call/cc), and PS (control). Proof Sketch. <p> Clearly, PS (state) is a conservative extension of Pure Scheme; the new semantics is the basis for an equational calculus for reasoning about operational equivalences in PS (state) <ref> [11, 12] </ref>. Proposition 4.7 Pure Scheme cannot express set! and letrec. Proof Sketch. Consider the expression ((lambda (d) (f 0)) (f 0)), which contains the same subexpression, (f 0), twice.
Reference: 13. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: In the following subsections, ~ = ps denotes the operational equivalence relation on Pure Scheme; other indexes correspond to extensions of Pure Scheme and should be self-explanatory. The main characteristic of Idealized Scheme <ref> [11, 12, 13] </ref> is the extension of the functional core language Pure Scheme with type predicates, local branching constructs, and imperative facilities: * branching expressions for the local manipulation of control, * predicate constants for determining the type of a value, * control operators for the non-local manipulation of control, and <p> With the semantics of Figure 5, it is trivial to verify that the extensions are conservative over Pure Scheme. The semantics forms the basis of a simple equational calculus for abort and call/cc, and permits simple, algebra-like reasoning about programs with control operations <ref> [12, 13] </ref>. All three languages are more expressive than Pure Scheme. Proposition 4.5 Pure Scheme cannot macro-express non-local control constructs: Pure Scheme cannot macro-express abort or call/cc relative to PS (abort), PS (call/cc), and PS (control). Proof Sketch.
Reference: 14. <author> Fortune, S., D. Leivant, and M. O'Donnell. </author> <title> The expressiveness of simple and second-order type structures. </title> <journal> J. ACM 30(1), </journal> <year> 1980, </year> <pages> 151-185. </pages>
Reference-contexts: In the presence of full arithmetic, i.e., representations of integers with an addition and multiplication function, the approach can no longer compare the expressive power of programming languages since everything can be encoded and all functions become computable. A second approach is due to Fortune et al <ref> [14] </ref>. Their basic observation is that statically typed languages without facilities for constructing diverging programs can only encode a subset of the total computable functions.
Reference: 15. <author> Friedman, </author> <title> D.P. and D.S. Wise. Cons should not evaluate its arguments. In Automata, Languages and Programming, </title> <editor> S. Michaelson and R. Milner (eds). </editor> <publisher> Edinburgh Univ. Press, </publisher> <pages> 257-284, </pages> <year> 1976. </year>
Reference-contexts: Alternatively, such languages offer data constructors, say cons, that do not evaluate their arguments <ref> [15] </ref>. It is a widely held 34 belief that such provisions are superfluous in the presence of higher-order procedural abstractions. Evaluation Contexts E ::= ff j (u . . .
Reference: 16. <author> Goguen, J., J. Thatcher, and E. Wagner. </author> <title> An initial algebra approach to the specification, correctness, and implementation of abstract data types. </title> <booktitle> In Current Trends in Programming Methodology IV, edited by R. Yeh. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1979, </year> <pages> 80-149. </pages>
Reference-contexts: The terminology of equational algebraic specifications <ref> [16] </ref> refers to syntactic abstractions as derived operators. 17 Proof. It is easy to see that the additional condition in the antecedent is precisely what is needed to adapt the proof of Theorem 3.6 to the stronger conclusion.
Reference: 17. <author> Griffin, T. </author> <title> Notational definition|A formal account. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1988, </year> <pages> 372-383. </pages>
Reference-contexts: L-expressions e 1 ; . . . ; e a i , then L 0 can macro-express the facilities F 1 ; . . . ; F n ; . . .. 8 In Lisp-like languages, syntactic abstractions are realized as macros [22]; logical frameworks know them as notational abbreviations <ref> [17] </ref>. The terminology of equational algebraic specifications [16] refers to syntactic abstractions as derived operators. 17 Proof. It is easy to see that the additional condition in the antecedent is precisely what is needed to adapt the proof of Theorem 3.6 to the stronger conclusion.
Reference: 18. <author> Guzm an, J.C. and P. Hudak. </author> <title> Single-threaded polymorphic lambda-calculus. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1990, </year> <pages> 333-345. </pages>
Reference-contexts: Hans Boehm, Robert 16 This is not to be confused with compiler annotations, which also preserve the operational equivalences but do not increase the expressive power of a language, e.g., futures for indicating opportunities for parallel evaluations [2, 19] and single-threaded destructive updates in functional languages <ref> [18] </ref>. 41 Cartwright, Dan Friedman, Robert Hieb, John Lamping, Scott Smith, Rebecca Selke, Carolyn Talcott, Mitchell Wand and numerous of my patient seminar students suggested many improvements in the presentation of the material.
Reference: 19. <author> Halstead, R. </author> <title> Multilisp: A language for concurrent symbolic computataion. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7(4), </volume> <year> 1985, </year> <pages> 501-538. </pages>
Reference-contexts: Hans Boehm, Robert 16 This is not to be confused with compiler annotations, which also preserve the operational equivalences but do not increase the expressive power of a language, e.g., futures for indicating opportunities for parallel evaluations <ref> [2, 19] </ref> and single-threaded destructive updates in functional languages [18]. 41 Cartwright, Dan Friedman, Robert Hieb, John Lamping, Scott Smith, Rebecca Selke, Carolyn Talcott, Mitchell Wand and numerous of my patient seminar students suggested many improvements in the presentation of the material.
Reference: 20. <author> Hoare, </author> <title> C.A.R. The varieties of programming languages. </title> <booktitle> In Proc. International Joint Conference on Theory and Practic of Software Development. Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1989, </year> <pages> 1-18. </pages>
Reference-contexts: While these two approaches illuminate some of the issues about the expressiveness of data and type structures, their applicability to full-fledged programming languages is impossible because an equating of expressiveness with computational power is uninteresting from the programmer's perspective. Recently, Hoare <ref> [20] </ref> proposed classifying programming languages according to the equational and inequational laws that their programming constructs satisfy. He illustrates this idea with a collection of examples. The laws are based on denotational semantics, which are generally sound with respect to operational equivalences.
Reference: 21. <author> Kleene, S. C. </author> <title> Introduction to Metamathematics, </title> <publisher> Van Nostrand, </publisher> <address> New York, </address> <year> 1952. </year>
Reference-contexts: The following short overview summarizes and adapts Troelstra's [42:I.2] descriptions of Kleene's work <ref> [21] </ref>. A formal system is a triple of sets: expressions, formulae, and theorems. The second is a subset of the first, the third a subset of the second.
Reference: 22. <author> Kohlbecker, E. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> Ph.D. dissertation, </type> <institution> Indiana University, </institution> <year> 1986. </year>
Reference-contexts: . ; '(e a i )) for all L-expressions e 1 ; . . . ; e a i , then L 0 can macro-express the facilities F 1 ; . . . ; F n ; . . .. 8 In Lisp-like languages, syntactic abstractions are realized as macros <ref> [22] </ref>; logical frameworks know them as notational abbreviations [17]. The terminology of equational algebraic specifications [16] refers to syntactic abstractions as derived operators. 17 Proof.
Reference: 23. <author> Landin, P.J. </author> <title> A -calculus approach. In Advances in Programming and Nonnumerical Computation, edited by L. Fox. </title> <publisher> Pergamon Press, </publisher> <address> New York, </address> <year> 1966, </year> <pages> 97-141. </pages>
Reference: 24. <author> Landin, P.J. </author> <title> The next 700 programming languages. </title> <journal> Commun. ACM 9(3), </journal> <year> 1966, </year> <pages> 157-166. </pages>
Reference-contexts: The lack of a comparison relation makes it impossible to draw any firm conclusions from expressiveness claims or to use them for an objective decision about the use of a programming language. fl Supported in part by NSF grant CCR 89-17022 and Darpa/NSF grant CCR 87-20277. 1 Landin <ref> [24] </ref> was the first to propose the development of a formal framework for comparing programming languages. <p> . ; F n ; . . . 3.2 Macro Expressibility Although the definition of eliminable programming construct is a satisfactory first step towards a better understanding of the formal structure of programming languages, it does not completely account for the idealized notion of "syntactic sugar" of Landin and others <ref> [24, 36, 37, 40] </ref> as discussed in the introduction. In many cases, the elimination of "syntactic sugar" constructs not only preserves the global program structure but also the structure of the subexpressions of phrases built from eliminable constructs. Recall the two examples from the introduction: 16 1.
Reference: 25. <author> Meyer, </author> <title> A.R. Semantical Paradigms. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1988, </year> <pages> 236-255. </pages>
Reference-contexts: In other words, replacing the original phrase with its translation does not affect the termination behavior of the surrounding programs. This relation between two phrases of programming languages is widely studied in semantics and is known as operational (or observational ) equivalence <ref> [25, 29, 33, 34] </ref>. After developing the formal definition of operational equivalence, we can characterize sufficient conditions for the eliminability of programming constructs. <p> Some of his results may be relevant for future extensions of our work. A secondary piece of related work is the study of the full abstraction property of mathematical models <ref> [25, 31, 33] </ref> and the representability of functions in -calculi [3, 4]. In many cases, the natural denotational model of a programming language contains too many elements so that operationally equivalent phrases have different mathematical meanings.
Reference: 26. <author> Meyer, A.R. and J.R. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <year> 1988, </year> <pages> 63-71. </pages>
Reference-contexts: following proposition shows that in Idealized Scheme, the two are actually independent enhancements of the expressive power of the core language. 13 12 This example is a folk theorem example in the theoretical "continuation" community, but it was also used by Meyer and Riecke to argue the "unreasonableness" of continuations <ref> [26] </ref>. 13 The non-expressibility of abort appears to be an artifact of our modeling of Scheme. A more realistic model of Scheme systems (as opposed to the Scheme semantics [35]) would have to include the interactive loop, which provides a delimiter for control actions [9].
Reference: 27. <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 17, </volume> <year> 1978, </year> <pages> 348-375. 43 </pages>
Reference-contexts: A fl t program is not only closed but is also typable as either an integer or a higher-order functional on integers according to the type inference system in Figure 2. It easily follows from Milner's <ref> [27] </ref> initial work on polymorphism that typability is a recursive predicate for fl t . The semantics of fl t -programs is the same as that of their untyped counterparts. fl t is a typical example of a monomorphic language: all occurrences of a -bound variable have the same type. <p> greater flexibility, the new rule only requires that, at each occurrence of the abstracted variable, the named subexpression is typable with some type: A ` e : t ; A ` e [x=e 0 ] : t 0 fl t v + let is polymorphic in the spirit of ML <ref> [27, 28, 43:43, 44] </ref>. Unlike -bound variables, let-bound variables can have several types.
Reference: 28. <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: greater flexibility, the new rule only requires that, at each occurrence of the abstracted variable, the named subexpression is typable with some type: A ` e : t ; A ` e [x=e 0 ] : t 0 fl t v + let is polymorphic in the spirit of ML <ref> [27, 28, 43:43, 44] </ref>. Unlike -bound variables, let-bound variables can have several types.
Reference: 29. <author> Morris, J.H. </author> <title> Lambda-Calculus Models of Programming Languages. </title> <type> Ph.D. dissertation, </type> <institution> MIT, </institution> <year> 1968. </year>
Reference-contexts: In other words, replacing the original phrase with its translation does not affect the termination behavior of the surrounding programs. This relation between two phrases of programming languages is widely studied in semantics and is known as operational (or observational ) equivalence <ref> [25, 29, 33, 34] </ref>. After developing the formal definition of operational equivalence, we can characterize sufficient conditions for the eliminability of programming constructs.
Reference: 30. <author> Naur, P. (Ed.). </author> <title> Revised report on the algorithmic language ALGOL 60. </title> <booktitle> Com-mun. ACM 6(1), </booktitle> <year> 1963, </year> <pages> 1-17. </pages>
Reference: 31. <author> Ong, L C.-H. </author> <title> Fully abstract models of the lazy lambda-calculus. </title> <booktitle> In Proc. 29th Symposium on Foundation of Computer Science, </booktitle> <year> 1988, </year> <pages> 368-376. </pages>
Reference-contexts: Consider the phrases x ( n y:x (YK)y)(YK) and x (x (YK))(YK). The two are equivalent in an adequate model of fl n <ref> [31] </ref> and are therefore operationally equivalent: x ( n y:x (YK)y)(YK) ~ = fl n x (x (YK))(YK): The operational reasoning for a verification of this equivalence is as follows. <p> No matter which argument the procedure x evaluates first, the expression (YK) eventually appears in the hole of the evaluation context, which leads to an immediate termination of the program evaluation. 10 Gordon Plotkin pointed out Abramsky's [1] and Ong's <ref> [31] </ref> work on the lazy -calculus, which corrected a mistake in an early draft. 20 In the full language fl, the above analysis no longer holds: Call-by-value proce-dures can evaluate and discard the expression (YK) in a way that does not affect the rest of the program. <p> Some of his results may be relevant for future extensions of our work. A secondary piece of related work is the study of the full abstraction property of mathematical models <ref> [25, 31, 33] </ref> and the representability of functions in -calculi [3, 4]. In many cases, the natural denotational model of a programming language contains too many elements so that operationally equivalent phrases have different mathematical meanings.
Reference: 32. <editor> Paterson, M.S. and C.E. Hewitt. </editor> <booktitle> Comparative schematology. In Conf. Rec. ACM Conference on Concurrent Systems and Parallel Computation, </booktitle> <year> 1970, </year> <pages> 119-127. </pages>
Reference-contexts: simple statements and to state the purpose of a program in the concisest possible manner. 6 Related Work The earliest attempt at defining and comparing the expressive power of programming languages is the work on comparative schematology by Chandra, Hewitt, Manna, Paterson, and others in the early and mid seventies <ref> [6, 32] </ref>. Schematology studies programming languages with a simple set of control constructs, e.g., while-loop programs or recursion equations, and with uninterpreted constant and function symbols. As in predicate logic without arithmetic, it is possible to decide certain questions about such uninterpreted program schemas.
Reference: 33. <author> Plotkin, G.D. </author> <title> LCF considered as a programming language. </title> <journal> Theor. Comput. Sci. </journal> <volume> 5, </volume> <year> 1977, </year> <pages> 223-255. </pages>
Reference-contexts: In other words, replacing the original phrase with its translation does not affect the termination behavior of the surrounding programs. This relation between two phrases of programming languages is widely studied in semantics and is known as operational (or observational ) equivalence <ref> [25, 29, 33, 34] </ref>. After developing the formal definition of operational equivalence, we can characterize sufficient conditions for the eliminability of programming constructs. <p> Some of his results may be relevant for future extensions of our work. A secondary piece of related work is the study of the full abstraction property of mathematical models <ref> [25, 31, 33] </ref> and the representability of functions in -calculi [3, 4]. In many cases, the natural denotational model of a programming language contains too many elements so that operationally equivalent phrases have different mathematical meanings. <p> As a consequence, such models naturally lead to the discovery of non-expressible programming constructs. In the framework of -calculus languages, such facilities are multiple argument functions that do not require the values of all arguments to determine their result <ref> [33, 1] </ref>. Still, the study of full abstraction does not provide true insight into the expressive power of languages. On one hand, the discovery of new facilities directly depends on the choice of a model.
Reference: 34. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Com-put. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <pages> 125-159. </pages>
Reference-contexts: The set of fl-programs is the set of closed phrases, i.e., there is only one recursive constraint that distinguishes programs from arbitrary phrases. 6 The operational semantics of fl reflects the semantics of realistic programming languages like Iswim, ML, and Scheme <ref> [34] </ref>. 4 The specification of the semantics in adaptable to the imperative extensions of fl in the following section. An evaluation is a sequence of reduction steps on programs according to the normal-order strategy. If the program is a value (an abstraction), the evaluation stops. <p> In other words, replacing the original phrase with its translation does not affect the termination behavior of the surrounding programs. This relation between two phrases of programming languages is widely studied in semantics and is known as operational (or observational ) equivalence <ref> [25, 29, 33, 34] </ref>. After developing the formal definition of operational equivalence, we can characterize sufficient conditions for the eliminability of programming constructs. <p> Even worse there are two distinct explanations for a continuation-passing style subprogram in a call-by-name functional setting: it may either implement some sophisticated control structure, or it may implement a call-by-value protocol <ref> [34] </ref>. Only a thorough analysis of the details of the continuation-passing program fragment can reveal the true purpose behind the occurrence of the programming patterns.
Reference: 35. <editor> Rees, J. and W. Clinger (Eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21(12), </journal> <year> 1986, </year> <pages> 37-79. </pages>
Reference-contexts: In the following examples, this is obviously the case. 2 A notable exception is Scheme as defined in the standard report <ref> [35] </ref>, which only has a recursively enumerable set of programs: An expression is a Scheme program if and only if it has the same result for all possible evaluation orders in its applications. <p> A more realistic model of Scheme systems (as opposed to the Scheme semantics <ref> [35] </ref>) would have to include the interactive loop, which provides a delimiter for control actions [9]. By including an appropriate version of this delimiter in PS (control), abort becomes macro-expressible as a combination of call/cc and the control delimiter [39].
Reference: 36. <author> Reynolds, </author> <title> J.C. GEDANKEN|A simple typeless language based on the principle of completeness and the reference concept. </title> <journal> Commun. ACM 13(5), </journal> <year> 1970, </year> <pages> 308-319. </pages>
Reference-contexts: After all, repeat s until e is expressible as s; while :e do s: Others, most notably Reynolds <ref> [36, 37] </ref> and Steele and Sussman [40], followed Landin's example. They introduced the informal notion of the core of a language and studied the expressiveness of imperative extensions of higher-order functional languages. <p> . ; F n ; . . . 3.2 Macro Expressibility Although the definition of eliminable programming construct is a satisfactory first step towards a better understanding of the formal structure of programming languages, it does not completely account for the idealized notion of "syntactic sugar" of Landin and others <ref> [24, 36, 37, 40] </ref> as discussed in the introduction. In many cases, the elimination of "syntactic sugar" constructs not only preserves the global program structure but also the structure of the subexpressions of phrases built from eliminable constructs. Recall the two examples from the introduction: 16 1.
Reference: 37. <author> Reynolds, </author> <title> J.C. The essence of Algol. In Algorithmic Languages, </title> <editor> edited by de Bakker and van Vliet. </editor> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981, </year> <pages> 345-372. </pages>
Reference-contexts: After all, repeat s until e is expressible as s; while :e do s: Others, most notably Reynolds <ref> [36, 37] </ref> and Steele and Sussman [40], followed Landin's example. They introduced the informal notion of the core of a language and studied the expressiveness of imperative extensions of higher-order functional languages. <p> . ; F n ; . . . 3.2 Macro Expressibility Although the definition of eliminable programming construct is a satisfactory first step towards a better understanding of the formal structure of programming languages, it does not completely account for the idealized notion of "syntactic sugar" of Landin and others <ref> [24, 36, 37, 40] </ref> as discussed in the introduction. In many cases, the elimination of "syntactic sugar" constructs not only preserves the global program structure but also the structure of the subexpressions of phrases built from eliminable constructs. Recall the two examples from the introduction: 16 1.
Reference: 38. <author> Riecke, J.G. </author> <title> A complete and decidable proof system for call-by-value equalities. </title> <booktitle> In Proc. 17th International Conference on Automata, Languages and Programming. Lecture Notes in Computer Science, </booktitle> <volume> 443. </volume> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> 20-31. </pages>
Reference-contexts: Since n diverges, C 0 (x) = ( n xy:x)( n x:x) n terminates whereas C 0 (y) = ( n xy:y)( n x:x) n diverges. is used below in Proposition 3.7; the proof system is similar to Riecke's for a typed version of fl v <ref> [38] </ref>. The calculus proves equations over the language from premisses () that are finite sets of equations. It is sound but incomplete, i.e., if ; ` e = e 0 then e ~ = e 0 but not vice versa. Remark 3 (Weak Expressibility).
Reference: 39. <author> Sitaram, D. and M. Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <pages> 161-175. </pages>
Reference-contexts: By including an appropriate version of this delimiter in PS (control), abort becomes macro-expressible as a combination of call/cc and the control delimiter <ref> [39] </ref>. Put differently, interactive programming systems actually add expressive power to the programming language. <p> fact that such interactive programming environments add power to their underlying languages suggests that they should be specified as a part of the language standards! 30 Proposition 4.6 The control constructs abort and call/cc cannot express each other: (i ) PS (abort) cannot macro-express call/cc with respect to PS (control) <ref> [39] </ref>. (ii ) PS (call/cc) cannot (macro-) express abort with respect to PS (control). Proof Sketch. (i ) The proof of the first claim shows that call/cc destroys operational equivalences in PS (abort). <p> On one hand, the discovery of new facilities directly depends on the choice of a model. For example, whereas a direct model of fl n requires the above-mentioned facility for exploiting deterministic parallelism, a continuation model leads to operations on continuations and to restrictions of such operations <ref> [39] </ref>. On the other hand, by Theorem 3.14 we also know that a change in the operational equivalence relation is only a sufficient but not a necessary condition for the non-expressibility of a programming construct.
Reference: 40. <author> Steele, G.L., Jr. and G.J. Sussman. </author> <title> Lambda: The ultimate imperative. </title> <type> Memo 353, </type> <institution> MIT AI Lab, </institution> <year> 1976. </year>
Reference-contexts: After all, repeat s until e is expressible as s; while :e do s: Others, most notably Reynolds [36, 37] and Steele and Sussman <ref> [40] </ref>, followed Landin's example. They introduced the informal notion of the core of a language and studied the expressiveness of imperative extensions of higher-order functional languages. <p> . ; F n ; . . . 3.2 Macro Expressibility Although the definition of eliminable programming construct is a satisfactory first step towards a better understanding of the formal structure of programming languages, it does not completely account for the idealized notion of "syntactic sugar" of Landin and others <ref> [24, 36, 37, 40] </ref> as discussed in the introduction. In many cases, the elimination of "syntactic sugar" constructs not only preserves the global program structure but also the structure of the subexpressions of phrases built from eliminable constructs. Recall the two examples from the introduction: 16 1. <p> The extensions reflect the belief that these constructs increase the expressive power of the language <ref> [40, 41] </ref>. In this section, we demonstrate how to formulate these beliefs in our formal macro-expressiveness framework. Subsection 1 simultaneously deals with local control and type predicates because the two sets of constructs are closely related.
Reference: 41. <author> Sussman, G.J. and G.L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: We demonstrate the abstract concepts by proving some sample theorems about -calculus-based languages as well as a number of meta-theorems. Next, we study the expressiveness of an idealized version of Scheme and verify the informal expressiveness philosophy behind its design <ref> [41] </ref>. Following this analysis, we briefly speculate how the use of a more expressive language increases programming convenience. <p> The extensions reflect the belief that these constructs increase the expressive power of the language <ref> [40, 41] </ref>. In this section, we demonstrate how to formulate these beliefs in our formal macro-expressiveness framework. Subsection 1 simultaneously deals with local control and type predicates because the two sets of constructs are closely related.
Reference: 42. <author> Troelstra, A. S. </author> <title> Metamathematical Investigation of Intuitionistic Arithmetic and Analysis. </title> <booktitle> Lecture Notes in Mathematics 344. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1973. </year>
Reference: 43. <author> Wand, M. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1987, </year> <pages> 37-44. </pages>
Reference: 44. <author> Wand, M. </author> <title> A types-as-sets semantics for Milner-style polymorphism. </title> <booktitle> In Proc. 11th Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> 158-164. 44 </pages>
Reference-contexts: greater flexibility, the new rule only requires that, at each occurrence of the abstracted variable, the named subexpression is typable with some type: A ` e : t ; A ` e [x=e 0 ] : t 0 fl t v + let is polymorphic in the spirit of ML <ref> [27, 28, 43:43, 44] </ref>. Unlike -bound variables, let-bound variables can have several types. <p> in e 0 ) = = (x:e 0 )e and, for all values v , e = v ` (let x be e in e 0 ) = e 0 [x=v] = (x:e 0 )e; 6 An alternative approach to a formalization of this folk theorem is due to Wand <ref> [44] </ref>. 13 and therefore, (let x be e in e 0 ) ~ = fl+let (x:e 0 )e: The induction step proceeds along the same line. (ii ) Set '(let x be e in e 0 ) = (( v d:'(e 0 )[x='(e)])'(e)) where d does not occur free in e
Reference: 45. <author> Williams, J.G. </author> <title> On the formalization of semantic conventions. </title> <type> Draft version: </type> <month> September </month> <year> 1988. </year> <note> To appear in Journal of Symbolic logic, 1990. 45 </note>
Reference-contexts: The laws are based on denotational semantics, which are generally sound with respect to operational equivalences. Given our theorems that connect expressiveness with the validity of operational equivalences in programming languages, this approach seems to be a related attempt at formalizing 39 or comparing the expressiveness of languages. Williams <ref> [45] </ref> looks at a whole spectrum of formalization techniques for semantic conventions in formal systems and, in particular, programming languages. His work starts with ideas of applicative and definitional extensions of formal systems but also considers techniques that are more relevant in computational settings, e.g., compilation and interpretation.
References-found: 45

