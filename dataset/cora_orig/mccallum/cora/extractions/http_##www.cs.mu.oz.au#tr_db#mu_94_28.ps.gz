URL: http://www.cs.mu.oz.au/tr_db/mu_94_28.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: ftrb,leeg@cs.mu.oz.au  
Title: Declarative Debugging of a Logical-Functional Language  
Author: Tim Barbour Lee Naish 
Address: Parkville 3052, Australia  
Affiliation: Department of Computer Science University of Melbourne  
Abstract: Technical Report 94/28 December 1994 
Abstract-found: 1
Intro-found: 1
Reference: [BBLM85] <author> R. Barbuti, M. Bellia, G. Levi, and M. Martelli. LEAF: </author> <title> a language which integrates logic, equations and functions. </title> <editor> In Doug DeGroot and Gary Lindstrom, editors, </editor> <title> Logic programming: relations, functions, </title> <booktitle> and equations, </booktitle> <pages> pages 201-238. </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: There have been many different approaches including the use of narrowing, Knuth-Bendix completion, set-valued functions, and transformation to clausal form. The latter approach is the one taken by LEAF <ref> [BBLM85] </ref> and NUE-Prolog [Nai91]. Translation to clausal form, and subsequent use of SLD resolution is semantically equivalent to narrowing in equational theories with constructors [BL86].
Reference: [BL86] <author> Marco Bellia and Giorgio Levi. </author> <title> The relation between logic and functional languages: a survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 3(3) </volume> <pages> 217-236, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: For example a compiler may rearrange a program so it runs more efficiently. This is in contrast to imperative languages which typically exhibit side-effects, and lack declarative semantics. Clearly it would be interesting to combine logical and relational languages, and much research has been done in this area <ref> [BL86] </ref>. There have been many different approaches including the use of narrowing, Knuth-Bendix completion, set-valued functions, and transformation to clausal form. The latter approach is the one taken by LEAF [BBLM85] and NUE-Prolog [Nai91]. <p> The latter approach is the one taken by LEAF [BBLM85] and NUE-Prolog [Nai91]. Translation to clausal form, and subsequent use of SLD resolution is semantically equivalent to narrowing in equational theories with constructors <ref> [BL86] </ref>. The functional syntax provides enough control information, from the partial ordering relation of function calls, to support lazy evaluation. 1.1 NUE-Prolog NUE-Prolog (NU-Prolog with Equations) extends NU-Prolog by allowing evaluable functions to be defined by sets of mutually exclusive equations.
Reference: [Han94] <author> M. Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> Journal of Logic Programming, </journal> 19&20:583-628, 1994. 
Reference-contexts: In logical languages control flow is complicated by unification, backtracking, and (possibly) coroutining, while control flow in functional languages is complicated by lazy evaluation. Although these languages have very clear declarative semantics, their procedural semantics is complex. Thus they are difficult to debug by conventional procedural debuggers <ref> [Han94] </ref>, which attempt to locate bugs by tracing the progress of execution. Because of this difficulty, many functional languages, for example Miranda, have poor debugging facilities. A solution to the difficulty of debugging logical languages is to use declarative debugging. Declarative debugging was first described by Shapiro [Sha83].
Reference: [Nai91] <author> Lee Naish. </author> <title> Adding equations to NU-Prolog. </title> <booktitle> Number 528 in Lecture notes in computer science, </booktitle> <pages> pages 15-26, </pages> <address> Passau, Germany, </address> <month> August, </month> <title> 1991. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: There have been many different approaches including the use of narrowing, Knuth-Bendix completion, set-valued functions, and transformation to clausal form. The latter approach is the one taken by LEAF [BBLM85] and NUE-Prolog <ref> [Nai91] </ref>. Translation to clausal form, and subsequent use of SLD resolution is semantically equivalent to narrowing in equational theories with constructors [BL86].
Reference: [Nai92] <author> Lee Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10(3) </volume> <pages> 255-285, </pages> <year> 1992. </year>
Reference-contexts: Matching clauses: app ([], A, []). There are two kinds of bug which a declarative debugger can discover. Naish <ref> [Nai92] </ref> has precise definitions of these. The first is the incorrect clause instance, which can be defined by the following clause: bug ((A :- B)) :- is_clause (A, B), unsatisfiable (A), valid (B). <p> An uncovered atom is one which is valid in the intended interpretation, but which cannot be derived by any clause in the program. Naish <ref> [Nai92] </ref> defines an uncovered atom by the following clause: bug (atom (A)) :- valid (A), all B not (is_clause (A, B), valid (B)). 7 This states that, in the intended interpretation, A is valid but there is no matching clause instance with a valid body. <p> Is this set of answers complete? n For this goal: app ([], [c, d], [c, d]) These answers are returned: fail. Is this set of answers complete? n Uncovered atom: app ([], [c, d], [c, d]). It is more difficult to diagnose missing answers in the presence of coroutining <ref> [Nai92] </ref>. <p> Matching clauses: map (A, [B|C]) = [fapply (A, B), fapply (A, B)|map (A, C)]. Note that the questions contain no mention of fapply. valid treats a call to fapply as an ordinary function application, as shown by the questions about square. 15 Chapter 3 Missing Answers Naish <ref> [Nai92] </ref> gives the following algorithm for diagnosing missing answers in Prolog with left to right execution: miss ((A, B), R):- call (A), miss (B, R). miss ((A, B), R):- miss (A, R). miss (A, R):- user_pred (A), incomplete (A), ( clause (A, Y), miss (Y, R1) -&gt; R = R1 R <p> Recomputation is more expensive than the original computation. If the original computation takes time N , the cost of recomputing it is O (N 2 ) in the worst case. This is typical of debuggers that use recomputation, in particular those described by Naish <ref> [Nai92] </ref>. This is acceptable in practice, since the cost is spread out over the questions asked: the cost between successive questions is O (N ). The search order of our algorithm means that recomputation prior to the first question may take time O (N 2 ). <p> The bug seems to be a new species of uncovered atom, since no clause matches the goal. However it is not included by the definition of an uncovered atom given in Section 1.4, nor is it included by any of the definitions Naish gives <ref> [Nai92] </ref>. <p> It would probably not be difficult to extend the wrong failure algorithm. The algorithm for diagnosing missing answers in logical code is essentially independent of the wrong failure algorithm, and could be replaced by one of the algorithms described by Naish <ref> [Nai92] </ref> which handle coroutining. The top down search order used by the wrong failure algorithm seems to require more questions than that of the missing result algorithm. The search order of the former could be improved. Completeness of the algorithms could be investigated and the theoretical framework developed further.
Reference: [Nai93] <author> Lee Naish. </author> <title> Declarative debugging of lazy functional programs. </title> <journal> Australian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 287-294, </pages> <year> 1993. </year>
Reference-contexts: Surprisingly, there has been little work on declarative debugging of functional languages, and that has occurred only recently. Nilsson & Fritzson [NF92] have implemented an algorithmic debugger for a subset of Miranda, and Naish <ref> [Nai93] </ref> has implemented a declarative debugger for the functional part of NUE-Prolog. We have continued this work by implementing a debugger for the full NUE-Prolog language: a single debugger that can debug both wrong and missing answers in mixed logical and functional programs. <p> An incorrect clause instance allows invalid atoms to derived from valid ones. The debugger locates an incorrect clause instance by searching the derivation of a wrong answer for an invalid atom which was derived from valid ones. The algorithm is described succinctly by Naish <ref> [Nai93] </ref>: % from representation of incorrectly successful atom % return incorrect clause instance wrong_atom (A, Bug):- not valid (A), successful_clause (A, G), (if some [Bug1] wrong_rhs (G, Bug1) then Bug = Bug1 else Bug = (A :- G) % as above, but for an arbitrary goal (eg, RHS of a clause) <p> B) :- (if some [] A &gt;= 0 then B = A else '$eq$-'(A, C), ). $eq$amax (A, B, C) :- (if some [D, E] ($eq$abs (A, E), $eq$abs (B, D), E &gt; D) then C = A else C = B 2.2 Wrong Answers in Strict Functional Code Naish <ref> [Nai93] </ref> shows that exactly the same debugger can be used for debugging functional code. The flattening transformation used to implement NUE-Prolog is augmented so that each function call returns a representation of its computation (this is arranged by adding an extra argument to the flattened functions). <p> Matching clauses: concat ([], A) = []. 2.3 Wrong Answers in Lazy Functional Code As with strict functional code we follow the approach used by Naish <ref> [Nai93] </ref>, the only changes being those mentioned in the previous section: functions may call predicates and predicates may call functions. This does not cause much complication, since predicates cannot be lazy and any function call made by a predicate is always fully evaluated before the predicate obtains the result. <p> The debugging algorithm remains the same. Arguments typically still contain lazy closures after a function is evaluated. As described by Naish <ref> [Nai93] </ref>, this corresponds to a Prolog goal that succeeds without completely instantiating 11 its arguments. Thus when questioning the user, it is appropriate to replace such closures by universally quantified variables. <p> The search order of the former could be improved. Completeness of the algorithms could be investigated and the theoretical framework developed further. Debuggers could be implemented for other logical-functional languages. 4.2 Conclusion Naish <ref> [Nai93] </ref> describes a declarative debugger for wrong answers in the functional part of NUE-Prolog. We have extended this work to a declarative debugger for both wrong and missing answers in full NUE-Prolog.
Reference: [NDZ89] <author> L. Naish, P. W. Dart, and J. Zobel. </author> <title> The NU-prolog debugging environment. </title> <editor> In Antonio Porto, editor, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <address> Lisboa, Portugal, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: If the program gives an incorrect answer to a query, at least one of its formulas must be invalid in the intended interpretation. Missing answers can be diagnosed by similar means, leading to the identification of an uncovered atom. The NU-Prolog Debugging Environment <ref> [NDZ89] </ref> provides declarative debugging of wrong answers and missing answers for NU-Prolog programs, together with other tools such as type checking and loop analysis.
Reference: [NF92] <author> Henrik Nilsson and Peter Fritzson. </author> <title> Algorithmic debugging of lazy functional languages. </title> <booktitle> Proceedings of The Fourth International Symposium on Programming Language Implementation and Logic Programming, to appear, </booktitle> <month> August, </month> <year> 1992. </year>
Reference-contexts: Surprisingly, there has been little work on declarative debugging of functional languages, and that has occurred only recently. Nilsson & Fritzson <ref> [NF92] </ref> have implemented an algorithmic debugger for a subset of Miranda, and Naish [Nai93] has implemented a declarative debugger for the functional part of NUE-Prolog.
Reference: [Pla84] <author> David A. Plaisted. </author> <title> An efficient bug location algorithm. </title> <editor> In Sten Ake Tarnlund, editor, </editor> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <pages> pages 151-157, </pages> <institution> Uppsala, Sweden, </institution> <month> July </month> <year> 1984. </year>
Reference-contexts: However, when this happens, the number of questions asked will often be less than needed for a top-down search order. The alternative to recomputation is to save a representation of the original computation (as we do for wrong answers). Plaisted analyses the tradeoff between time and space <ref> [Pla84] </ref>. There is a class of bugs our algorithm cannot diagnose (we give a better algorithm in the next section).
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1983. </year> <month> 24 </month>
Reference-contexts: Because of this difficulty, many functional languages, for example Miranda, have poor debugging facilities. A solution to the difficulty of debugging logical languages is to use declarative debugging. Declarative debugging was first described by Shapiro <ref> [Sha83] </ref>. A pure logic program can be viewed as a set of first order logic formulas. In model-theoretic semantics, the meaning of 5 the symbols in the program is given by their interpretation. For a particular program there is normally a distinguished interpretation, called the intended interpretation.
References-found: 10

