URL: ftp://ftp.cs.unc.edu/pub/users/goddard/TR98-002.ps.Z
Refering-URL: http://www.cs.unc.edu/~goddard/papers.html
Root-URL: http://www.cs.unc.edu
Title: A Software Synthesis Method for Building Real-Time Systems from Processing Graphs  
Author: Steve Goddard Kevin Jeffay 
Keyword: Real-time systems, software engineering, embedded systems, processing graphs, scheduling theory.  
Note: January 1998  Supported, in part, by the  Alumni Fellowship, grants from the Intel and IBM corporations, and the National Science Foundation (grant CCR-9510156). Supported, in part, by grants from the Intel and IBM Corporations, and the National Science Foundation (grant CCR 9510156).  
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  University of North Carolina at Chapel Hill Department of Computer Science  
Pubnum: Technical Report TR98-002  
Email: fgoddard, jeffayg@cs.unc.edu  
Abstract: In this paper, we present software synthesis techniques that create a real-time uniprocessor system from processing graphs. Our synthesis method supports both latency and buffer management, though only buffer management is addressed in this paper (for space considerations). To achieve the synthesis, new rate theorems have been developed to derive the execution rate of each processing component in the graph. The processing graph is mapped to the existing Rate Based Execution (RBE) task model, and if the schedulability test for the resulting task set is affirmative, we show that efficient buffer management can be achieved using a simple Earliest Deadline First (EDF) scheduler. We evaluate our results using an International Maritime Satellite (INMARSAT) mobile receiver application. The case study shows that a dynamically scheduled implementation of the INMARSAT mobile satellite receiver uses less memory and introduces less latency than a comparable static implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, D.P., Tzou, S.Y., Wahbe, R., Govindan, R., Andrews, M., </author> <title> "Support for Live Digital Audio and Video", </title> <booktitle> Proc. of the Tenth International Conference on Distributed Computing Systems, </booktitle> <address> Paris, France, </address> <month> May </month> <year> 1990, </year> <pages> pp. 54-61. </pages>
Reference-contexts: Whereas RTP/C models processes as sporadic tasks, our paradigm uses the Rate-Based Execution (RBE) process model of [13] to more accurately predict processor demand. (The RBE process model is a generalization of sporadic tasks and the Linear-Bounded Arrival Process (LBAP) model employed by the DASH system <ref> [1] </ref>.) 3 An Introduction to Processing Graphs This section introduces some graph theory and notation, which will be used throughout the paper, followed by a summary of the U.S. Navy's Processing Graph Method (PGM).
Reference: [2] <author> Baruah, S., Goddard, S., Jeffay, K., </author> <title> "Feasibility Concerns in PGM Graphs with Bounded Buffers," </title> <booktitle> Proceedings of the Third International Conference on Engineering of Complex Computer Systems, </booktitle> <pages> pp 130-139, </pages> <address> Como, Italy. </address> <month> September, </month> <title> 1997. </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [2, 9, 10, 11] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory.
Reference: [3] <author> Baruah, S., Howell, R., Rosier, L., </author> <title> "Algorithms and Complexity Concerning the Preemptively Scheduling of Periodic, Real-Time Tasks on One Processor" Real-Time Systems Journal , Vol. </title> <type> 2, </type> <year> 1990, </year> <pages> pp. 301-324. </pages>
Reference-contexts: i e i (4.4) where f (a) = ( 0 if a &lt; 0 Note that if the cumulative processor utilization for a graph is strictly less than one (i.e., P n x i e i then condition (4.4) can be evaluated efficiently (in pseudo-polynomial time) using techniques developed in <ref> [3] </ref>. In [9] we established sufficiency of (4.4) by showing that the preemptive EDF scheduling algorithm can schedule releases of the tasks in T without a task missing a deadline if the task set satisfies (4.4).
Reference: [4] <author> Bhattacharyya, S.S., Murthy, P.K., Lee, </author> <title> E.A., Software Synthesis from Dataflow Graphs, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1996. </year>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [15, 20, 25, 21, 4] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> Navy's coarse-grain Processing Graph Method (PGM) [18], which is based on computation graphs introduced by Karp and Miller [14]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method <ref> [4, 15] </ref>. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [15, 20, 25, 21, 4] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> a state-of-the-art, static scheduler, which is designed to minimize memory requirements. 6.2 Buffer Requirements In this section we present the buffer requirements of each queue in the mobile satellite receiver application and compare the total memory requirements of our synthesis of the application with the bounds reported in [21] and <ref> [4] </ref>. Due to space limitations, we derive the bounds for one queue as an example and refer the reader to Table 2 for the buffer bounds on the remaining queues. <p> in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by [20, 25, 21] and <ref> [4] </ref>. The buffer space required for each of those queues in our model is 1 token. <p> Assuming a unique buffer for each queue, the minimum buffer requirement for the INMARSAT mobile satellite receiver graph is 1,545 tokens | derived by summing prd (q)cns (q) gcd (prd (q);cns (q)) = max (prd (q); cns (q)) over 19 all queues in the graph <ref> [4] </ref>. <p> This value is 3.5% greater than the minimum possible buffer requirement of 1,545 tokens. In comparison, the off-line Acyclic Pairwise Grouping of Adjacent Nodes (APGAN) scheduling algorithm of <ref> [4] </ref> 3 achieves the optimal buffer requirement of 1,542 for the queues listed in Table 2.
Reference: [5] <author> Bhattacharyya, S.S., Lee, </author> <title> E.A., "Scheduling Synchronous Dataflow Graphs for Efficient Looping", </title> <journal> Journal of VLSI Signal Processsing, </journal> <volume> Vol. 6, No. 3, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: Just as important, run-time complexity is comparable and scheduling state is reduced. 3 APGAN is the same algorithm as the Pairwise Grouping of Adjacent Nodes (PGAN) scheduling algorithm of <ref> [5] </ref> except the graph is assumed to be acyclic. 20 7 Summary In most "real-time" processing graph methodologies, system engineers are unable to analyze the properties of schedulability, latency, and memory requirements.
Reference: [6] <author> Berry, G., Cosserat, L., </author> <title> "The ESTEREL Synchronous Programming Language and its Mathematical Semantics", </title> <booktitle> Lecture Notes in Computer Science, Vol. 197 Seminar on Concurrency, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: An execution paradigm that supports expected rates of the form x executions in y time units is a much more natural and simpler task model for the analysis of schedulability, latency, and buffer requirements for a processing graph application. We assume the strong synchrony hypothesis of <ref> [6] </ref> to introduce the concept of node execution rates. The strong synchrony hypothesis is that the system instantly reacts to external stimuli by updating internal states such that the response to input appears instantaneously.
Reference: [7] <author> Gerber, R., Seongsoo, H., Saksena, M., </author> <title> "Guaranteeing Real-Time Requirements with Resource-Based Calibration of Periodic Processes", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1995. </year> <month> 21 </month>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [7, 8, 12, 16, 17, 19, 24, 22, 23] (to list a few). The processing graphs of <ref> [7, 19] </ref> and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12].
Reference: [8] <author> Kang, D.-I., Gerber, R., Saksena, M., </author> <booktitle> "Performance-Based Design of Distributed Real-Time Systems", Proc. of IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997, </year> <pages> pp. 2-13. </pages>
Reference-contexts: In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by <ref> [8, 22] </ref> and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of [7, 8, 19, 24, 22, 23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12].
Reference: [9] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of a Dataflow Execution Paradigm using a Synthetic Aperture Radar Application", </title> <type> Technical Report TR97-007, </type> <institution> Dept. of Computer Science, University of North Carolina at Chapel Hill, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [2, 9, 10, 11] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> In [11], we derived execution rates for nodes in a PGM chain. The execution rate theorem of that paper is reproduced here (without proof 1 ) since we will use this result to extend the analysis to include nodes with 1 See <ref> [9] </ref> for the proof of Theorem 4.2. 6 multiple input queues. Theorem 4.2. <p> We proved the following feasibility condition for an RBE task set in <ref> [9] </ref>. Lemma 4.5. Let T = f (x 1 ; y 1 ; d 1 ; e 1 ); : : : (x n ; y n ; d n ; e n )g be a set of tasks. <p> In <ref> [9] </ref> we established sufficiency of (4.4) by showing that the preemptive EDF scheduling algorithm can schedule releases of the tasks in T without a task missing a deadline if the task set satisfies (4.4).
Reference: [10] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of Processing Graphs Implemented with the Rate Based Execution Model", </title> <type> Technical Report TR98-001, </type> <institution> Dept. of Computer Science, University of North Carolina at Chapel Hill, </institution> <note> In Submission. </note>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [2, 9, 10, 11] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> Hence the producer and consumer nodes usually execute at the same rate, or one fires an integral number of times in the rate interval of the other. This property lets us find relatively 2 See <ref> [10] </ref> for a complete discussion on buffer bounds for graphs implemented with the RBE model. 12 tight buffer bounds even when we don't know exactly when the node will fire. <p> Let I (v) be a subset of the periodic input nodes I from which there exists a path from i 2 I to the vertex v, and F (i; v) = max (fF (i; v)g) when (5.1) is evaluated over all paths fi ; vg. It was shown in <ref> [10] </ref> that T 1 (v) = s (v) where s (v) is defined by (5.2). (For a full explanation of these equations and proof that they derive the first logical release time for node v, see [10].) 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; : l thr (q)size (q) <p> It was shown in <ref> [10] </ref> that T 1 (v) = s (v) where s (v) is defined by (5.2). (For a full explanation of these equations and proof that they derive the first logical release time for node v, see [10].) 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; : l thr (q)size (q) prd (q) if (q) = (i; v) l (F (u;v)1)cns (q)+thr (q)size (q) prd (q) if (q) = (i; u) ^ u 6= v ^ F (u; v) &gt; 0 (5.1) The first logical release time
Reference: [11] <author> Goddard, S., Jeffay, K. </author> <title> "Analyzing the Real-Time Properties of a Dataflow Execution Paradigm using a Synthetic Aperture Radar Application", </title> <booktitle> Proc. of IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> June </month> <year> 1997, </year> <pages> pp. 60-71. </pages>
Reference-contexts: Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. The primary goal of our synthesis method and related research has been to manage latency and buffer requirements of processing graphs executed with a work-conserving on-line scheduler <ref> [2, 9, 10, 11] </ref>. In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. <p> Corollary 4.1. If R (v) = (x; y) is a valid rate specification for node v, then m R (v) = (m x; m y) is also a valid rate specification for node v. Proof: The proof follows immediately from Definition 4.2. In <ref> [11] </ref>, we derived execution rates for nodes in a PGM chain. <p> Since d (u) affects processor demand, latency and buffer requirements, a good starting point for the selection of d (u) is one such that it is greater than or equal to the deadline of its predecessor node and less than or equal to y (u). As shown in <ref> [11] </ref>, when the deadline for each node is greater than or equal to its predecessor's deadline, release time inheritance can be used to minimize latency.
Reference: [12] <author> Jeffay, K., </author> <title> "The Real-Time Producer/Consumer Paradigm: A paradigm for the construction of efficient, predictable real-time systems", </title> <booktitle> Proc. of the ACM/SIGAPP Symposium on Applied Computing , Indianapolis, IN, </booktitle> <month> February </month> <year> 1993, </year> <pages> pp. 796-804. </pages>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay <ref> [12] </ref>. Unfortunately, neither of these paradigms correctly model the execution of PGM graphs. The dataflow graphs of the SARTOR project have different (and incompatible) node execution rules from PGM. Without creating a non-work-conserving execution of the graph, we cannot use a periodic task model.
Reference: [13] <author> Jeffay, K., Bennett, D. </author> <title> "A Rate-Based Execution Abstraction For Multimedia Computing", </title> <journal> ACM Multimedia Systems, </journal> <note> to appear. </note>
Reference-contexts: In this paper, we present new theorems that characterize the non-trivial node execution rate of every node in a PGM graph, and demonstrate the synthesis of real-time systems from acyclic processing graphs by mapping the graph to the existing Rate Based Execution (RBE) task model developed by Jeffay <ref> [13] </ref>. The accompanying RBE schedulability condition is used to verify processor capacity. An affirmative result from the schedulability condition lets us bound latency and buffer requirements for the application. Once the processing graph has been mapped to a task model, issues such as latency and memory requirements can be addressed. <p> However, our execution model is capable of supporting much more sophisticated data flow models than RTP/C. Whereas RTP/C models processes as sporadic tasks, our paradigm uses the Rate-Based Execution (RBE) process model of <ref> [13] </ref> to more accurately predict processor demand. (The RBE process model is a generalization of sporadic tasks and the Linear-Bounded Arrival Process (LBAP) model employed by the DASH system [1].) 3 An Introduction to Processing Graphs This section introduces some graph theory and notation, which will be used throughout the paper, <p> Once a processing graph has been created for the application, we identify the execution rates of graph nodes and map each node to a task in Jeffay's Rate Based Execution (RBE) task model <ref> [13] </ref>. <p> The jitter caused by such a release mechanism during execution makes it difficult to efficiently use the canonical sporadic tasking model. For this reason, we use the Rate Based Execution (RBE) paradigm <ref> [13] </ref> developed by Jeffay to model node execution in a graph implementation. This section provides a brief overview of the task model. RBE is a general task model consisting of a collection of independent processes specified by four parameters: (x; y; d; e).
Reference: [14] <author> Karp, R.M., Miller, R.E., </author> <title> "Properties of a model for parallel computations: Determinacy, termination, queuing", </title> <journal> SIAM J. Appl. Math, </journal> <volume> Vol. 14, No. 6, </volume> <pages> pp. 1390-1411, </pages> <year> 1966. </year>
Reference-contexts: Our contributions are summarized in Section 7. 2 Related Work Our software synthesis technique begins with the U.S. Navy's coarse-grain Processing Graph Method (PGM) [18], which is based on computation graphs introduced by Karp and Miller <ref> [14] </ref>. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method [4, 15]. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic.
Reference: [15] <author> Lee, E.A., Messerschmitt, D.G., </author> <title> "Static Scheduling of Synchronous Data Flow Programs for Digital Signal Processing", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, No. 1, </volume> <month> January </month> <year> 1987, </year> <pages> pp. 24-35. </pages>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [15, 20, 25, 21, 4] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> Navy's coarse-grain Processing Graph Method (PGM) [18], which is based on computation graphs introduced by Karp and Miller [14]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method <ref> [4, 15] </ref>. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3. However, the differences between the two synthesis methods are dramatic. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [15, 20, 25, 21, 4] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor.
Reference: [16] <author> Mok, A.K., Sutanthavibul, S., </author> <title> "Modeling and Scheduling of Dataflow Real-Time Systems", </title> <booktitle> Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <address> San Diego, CA, </address> <month> Dec. </month> <year> 1985, </year> <pages> pp. 178-187. </pages>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok <ref> [16, 17] </ref> and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12]. Unfortunately, neither of these paradigms correctly model the execution of PGM graphs. The dataflow graphs of the SARTOR project have different (and incompatible) node execution rules from PGM.
Reference: [17] <author> Mok, A. K., et al., </author> <title> "Synthesis of a Real-Time System with Data-driven Timing Constraints", </title> <booktitle> Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <address> San Jose, CA, </address> <month> Dec. </month> <year> 1987, </year> <pages> pp. 133-143. </pages>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok <ref> [16, 17] </ref> and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12]. Unfortunately, neither of these paradigms correctly model the execution of PGM graphs. The dataflow graphs of the SARTOR project have different (and incompatible) node execution rules from PGM.
Reference: [18] <editor> Processing Graph Method Specification, </editor> <title> prepared by the Naval Research Laboratory for use by the Navy Standard Signal Processing Program Office (PMS-412), </title> <note> Version 1.0, </note> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) <ref> [18] </ref>, there is no obvious mapping to existing task models. Without a real-time task model and accompanying schedulability condition one cannot evaluate the latency or memory requirements of the application. <p> We evaluate our results in Section 6 with a case study of an International Maritime Satellite (INMARSAT) mobile receiver application. Our contributions are summarized in Section 7. 2 Related Work Our software synthesis technique begins with the U.S. Navy's coarse-grain Processing Graph Method (PGM) <ref> [18] </ref>, which is based on computation graphs introduced by Karp and Miller [14]. Another synthesis methodology based on computation graphs is the Synchronous Dataflow (SDF) software synthesis method [4, 15]. For our purposes, the differences between SDF graphs and PGM graphs are minor and are presented in x3.
Reference: [19] <author> Ramamritham, K., </author> <title> "Allocation and Scheduling of Precedence-Related Periodic Tasks", </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 6, No. 4, </volume> <month> April </month> <year> 1995, </year> <pages> pp. 412-420. </pages>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [7, 8, 12, 16, 17, 19, 24, 22, 23] (to list a few). The processing graphs of <ref> [7, 19] </ref> and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12].
Reference: [20] <author> Ritz, S., Meyer, H., </author> <title> "Exploring the design space of a DSP-based mobile satellite receiver", </title> <booktitle> Proc. </booktitle> <address> of ICSPAT 94 , Dallas, TX, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [15, 20, 25, 21, 4] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [15, 20, 25, 21, 4] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [20, 25, 21] </ref> and [4]. The buffer space required for each of those queues in our model is 1 token.
Reference: [21] <author> Ritz, R., Willems, M., Meyer, H., </author> <title> "Scheduling for Optimum Data Memory Compaction in Block Diagram Oriented Software Synthesis", </title> <booktitle> Proc. of ICASSP 95 , Detroit, </booktitle> <address> MI, </address> <month> May </month> <year> 1995, </year> <pages> pp. 133-143. </pages>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [15, 20, 25, 21, 4] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [15, 20, 25, 21, 4] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> scheduled by a state-of-the-art, static scheduler, which is designed to minimize memory requirements. 6.2 Buffer Requirements In this section we present the buffer requirements of each queue in the mobile satellite receiver application and compare the total memory requirements of our synthesis of the application with the bounds reported in <ref> [21] </ref> and [4]. Due to space limitations, we derive the bounds for one queue as an example and refer the reader to Table 2 for the buffer bounds on the remaining queues. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [20, 25, 21] </ref> and [4]. The buffer space required for each of those queues in our model is 1 token. <p> If a shared buffer implementation is used for the RBE task set, as assumed in the statically scheduled implementation of <ref> [21] </ref>, we can reduce the upper bound of 1,599 to 1,101.
Reference: [22] <author> Sun, J., Liu, J., </author> <title> "Synchronization Protocols in Distributed Real-Time Systems", </title> <booktitle> Proc. of 16th International Conference on Distributed Computing Systems, </booktitle> <month> May, </month> <year> 1996. </year>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by <ref> [8, 22] </ref> and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of [7, 8, 19, 24, 22, 23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12].
Reference: [23] <author> Sun, J., Liu, J., </author> <title> "Bounding Completion Times of Jobs with Arbitrary Release Times and Variable Execution Times", </title> <booktitle> Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <address> Washington, DC, </address> <month> Dec. </month> <year> 1996, </year> <pages> pp. 2-12. </pages> <month> December, </month> <year> 1996. </year>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and <ref> [23] </ref>. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of [7, 8, 19, 24, 22, 23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12]. <p> Clearly neither a single periodic nor sporadic task can model node v. It is less obvious that three sporadic tasks are insufficient to model the execution of node v efficiently. As identified in <ref> [23] </ref>, jitter caused by the execution of other nodes can create an execution pattern that has a much less than expected inter execution time for a particular node.
Reference: [24] <author> Spuri, M., Stankovic, J.A., </author> <title> "How to Integrate Precedence Constraints and Shared Resources in Real-Time Scheduling", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 43, No. 12, </volume> <month> December </month> <year> 1994, </year> <pages> pp. 1407-1412. </pages>
Reference-contexts: The primary problem in developing embedded signal processing applications with a processing graph methodology is creating a predictable real-time system in which one can determine if the graph "fits" on a uniprocessor. Typically a processing graph is mapped to a real-time task model (e.g., <ref> [7, 12, 16, 17, 19, 24, 22, 23] </ref>) and the accompanying schedulability condition is used to see if the graph "fits" on the processor. Unfortunately for general processing graph methodologies, such as the U.S. Navy's Processing Graph Method (PGM) [18], there is no obvious mapping to existing task models. <p> In contrast to the off-line schedulers developed for SDF graphs, on-line scheduling of PGM graphs uses input data rates and schedulability conditions from real-time scheduling theory. The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems <ref> [7, 8, 12, 16, 17, 19, 24, 22, 23] </ref> (to list a few). The processing graphs of [7, 19] and [24] are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> The real-time literature is replete with examples in which some form of a processing graph is used to construct real-time systems [7, 8, 12, 16, 17, 19, 24, 22, 23] (to list a few). The processing graphs of [7, 19] and <ref> [24] </ref> are task graphs in which only precedence constraints are described. An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. <p> An even simpler processing graph, called task chains, is employed by [8, 22] and [23]. Both task graphs and task chains can be represented with PGM graphs, but this paper does not address the distributed or end-to-end latency 2 issues of <ref> [7, 8, 19, 24, 22, 23] </ref>. From the real-time literature, the results presented in this paper are most closely related to the dataflow graphs found in the Software Automation for Real-Time Operations (SARTOR) project led by Mok [16, 17] and the Real-Time Producer/Consumer (RTP/C) paradigm of Jeffay [12].
Reference: [25] <author> Zivojnovic, V., Ritz, S., Meyer, H., </author> <title> "High Performance DSP Software Using Data-Flow Graph Transformations", </title> <booktitle> Proc. </booktitle> <address> of ASILOMAR 94 , Pacific Grove, </address> <month> November </month> <year> 1994. </year> <month> 22 </month>
Reference-contexts: An important aspect in controlling memory usage is the node execution schedule since this impacts the buffer requirements of the edges in the graph. The state of the art in minimizing the memory requirements of a signal processing graph is to create a node execution schedule off-line <ref> [15, 20, 25, 21, 4] </ref>. In contrast, our approach is to use a dynamic, on-line scheduler for graph execution. <p> However, the differences between the two synthesis methods are dramatic. The main goal of the SDF synthesis method and related scheduling research has been to minimize memory usage by creating off-line scheduling algorithms (e.g., <ref> [15, 20, 25, 21, 4] </ref>). Off-line schedulers create a static schedule that is executed periodically (or cyclically) by the processor. <p> The high speed data option of the INMARSAT-B mobile terminal is also used to provide video teleconferencing and compressed or delayed video transmission services to remote locations on land or at sea. an INMARSAT mobile terminal <ref> [25] </ref>. The corresponding processing graph for this application is shown in receiving the satellite signal. The other unlabeled circle represents the terminal accepting the processed signal. <p> rest of the queues in the mobile satellite receiver graph (calculated with the RBE parameters of Table 1) are shown in Table 2 with the exception of the queues attached to input or output devices since the buffer space for these queues was ignored in the buffer calculations done by <ref> [20, 25, 21] </ref> and [4]. The buffer space required for each of those queues in our model is 1 token.
References-found: 25

