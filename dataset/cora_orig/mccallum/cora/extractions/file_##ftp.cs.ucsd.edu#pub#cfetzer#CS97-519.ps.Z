URL: file://ftp.cs.ucsd.edu/pub/cfetzer/CS97-519.ps.Z
Refering-URL: http://www.cs.ucsd.edu/%7ecfetzer/MODEL/CS97-519.html
Root-URL: http://www.cs.ucsd.edu
Email: e-mail: flaviu, cfetzer@cs.ucsd.edu.  
Title: The Timed Asynchronous Distributed System Model  
Author: Flaviu Cristian and Christof Fetzer 
Web: http: //www.cs.ucsd.edu/~flaviu,~cfetzer  
Address: UC San Diego La Jolla, CA 920930114  
Affiliation: Dept. of Computer Science  
Abstract: We propose a formal definition for the timed asynchronous distributed system model and we describe extensive measurements of actual message and process scheduling delays and hardware clock drifts that confirm that this model adequately describes current distributed systems built from networked workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Amir and A. Wool. </author> <title> Evaluating quorum systems over the internet. </title> <booktitle> In Proc. 26th Int Symp on Fault-tolerant Computing, </booktitle> <pages> pages 26-35, </pages> <address> Sendai, Japan, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, processes do not always know how good the synchronization with real-time is. There might not even exist an upper bound on the drift rate of a real-time clock because an operator can change the speed of the real-time clock <ref> [1] </ref>. More recent operating systems provide processes access to hardware clocks that are not subject to ad justments, i.e. the speed of such a clock is neither changed by the software nor operator.
Reference: [2] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the impossibility of group membership. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: This research was supported by grants F49620-93 and F49620-96 from the Air Force Office of Scientific Research. are of importance in practice, such as consensus, election or membership, are not implementable <ref> [18, 2] </ref>.
Reference: [3] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Progress assumptions have also a certain similarity with failure detectors <ref> [3] </ref> which are mechanisms for adding synchrony to the time-free model: certain failure detector classes provide their desired behavior based on the observation that the system eventually stabilizes. The quasi-synchronous model [23] is another approach to define a model that is in between synchronous systems and time-free asynchronous systems. <p> Most real-world applications have soft real-time constrains. Hence, such applications need a notion of time. Neither the original time-free model [18] nor its extension with failure detectors <ref> [3] </ref> provides that. 9 These models are therefore not necessarily an ade-quate foundation for the construction of applications with soft real-time constrains. The timed model instead provides these applications with a sufficiently strong notion of time.
Reference: [4] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: Many applications are specified using real-time constrains. For example, if a component fails, then within X time units the application has to perform some action. Hardware clocks allow one to implement application level "time-outs". The timed asynchronous system model was introduced (without being named) in <ref> [4] </ref>. It was further refined in [9] and renamed to avoid confusion with the time-free model [18].
Reference: [5] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: The datagram service does not ensure the existence of an upper bound for the transmission delay of messages. But since all services in our model are timed, we define a one-way time-out delay ffi, chosen so that the actual message sent or broadcast are likely <ref> [5] </ref> to be delivered within ffi. A message m whose transmis sion delay is at most ffi, i.e. td q (m) ffi, is called timely. <p> This can be done in a manner transparent to the processes. Note that message authentication can increase the transmission time substantially without special hardware assistance. In summary, the asynchronous datagram service is assumed to have an omission/performance failure semantics <ref> [5] </ref>: it can drop messages and it can fail to deliver messages in a timely manner, but one can neglect the probability of source address spoofing and that a message delivered by the system is corrupted or is delivered multiple times. <p> The process management service does not ensure the existence of an upper bound on scheduling delays. However, being a timed service, like all services in the timed model, we define a scheduling timeout delay , so that actual scheduling delays are likely <ref> [5] </ref> to be smaller than . We say that a process p suffers a performance failure when it is not awakened within time units of a specified real alarm time. Otherwise, p is said to be timely. <p> These measurements where performed during normal daytime use of the system (low load). it requested to be awakened. It is based on 350,000 measurements. 3.3.2 Process Failure Asssumption The timed model assumes that processes have crash/performance failure semantics <ref> [5] </ref>. This means that all instructions a process issues are executed correctly, i.e. according to the specification of the instructions. However, the execution of a process might stop prematurely (crash failure) or a process might suffer a performance failure. Processes can recover from crashes.
Reference: [6] <author> F. Cristian. </author> <title> Group, majority, and strict agreement in timed asynchronous distributed systems. </title> <booktitle> In Proc. of the 26th Int. Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 178-187, </pages> <address> Sendai, Japan., </address> <month> June </month> <year> 1996. </year>
Reference-contexts: As an example of the utility of the above stability predicate, consider an atomic broadcast protocol designed to achieve group agreement semantics <ref> [6] </ref>, where all messages that are possibly lost or late are re-sent up to F +1 times.
Reference: [7] <author> F. Cristian. </author> <title> Synchronous and asynchronous group communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 88-97, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Depending on whether the underlying communication and process management services make inter-process communication by messages "certain" or not, distributed systems can be classified as either synchronous or asynchronous <ref> [7] </ref>. Communication certainty means that any message sent by a correct process to a correct destination process is received and processed at the destination within a known amount of time. When communication is not certain, the system is asynchronous. <p> performance is described in [8]. 4.2 Stability and Progress Assumptions The timeliness requirements encountered in the specification of protocols designed for the timed asynchronous system model are often conditional in the sense that only when some "system stability" predicate is true, the system has to achieve "something good" (see e.g. <ref> [7] </ref>). Such conditional timeliness re quirements express that when some set of processes SP P is "stable", that is, the failures affecting SP and the communication between them have a bounded frequency of occurrence, the servers in SP have to guarantee progress within a bounded amount of time.
Reference: [8] <author> F. Cristian, S. Mishra, and Y. Hyun. </author> <title> Implementation and performance of a stable storage service for unix. </title> <booktitle> In Proceedings of the 15th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 86-95, </pages> <address> Niagara-on-the-Lake, Canada, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: A stable storage service can be implemented on top of Unix using the Unix file system. An implementation of such a service and its performance is described in <ref> [8] </ref>. 4.2 Stability and Progress Assumptions The timeliness requirements encountered in the specification of protocols designed for the timed asynchronous system model are often conditional in the sense that only when some "system stability" predicate is true, the system has to achieve "something good" (see e.g. [7]).
Reference: [9] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor-group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> Dept of Computer Science and Engineering, University of California, </institution> <address> San Diego, La Jolla, CA, </address> <year> 1995. </year>
Reference-contexts: For example, if a component fails, then within X time units the application has to perform some action. Hardware clocks allow one to implement application level "time-outs". The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in <ref> [9] </ref> and renamed to avoid confusion with the time-free model [18]. In particular, [9] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will <p> Hardware clocks allow one to implement application level "time-outs". The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in <ref> [9] </ref> and renamed to avoid confusion with the time-free model [18]. In particular, [9] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will make progress within a bounded time. <p> The concept of a stable partition is formalized by a stability predicate that defines if a set of processes SP forms a stable partition in some given time interval [s; t]. There are multiple reasonable definitions for stability predicates: examples are the stable predicate in <ref> [9] </ref>, or the majority-stable predicate in [11]. In this paper we formally define the stability predicate -F-partition introduced informally in [14]. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [9]. 4.2.1 -F-Partitions Two processes p and q are F-connected in the time interval <p> are multiple reasonable definitions for stability predicates: examples are the stable predicate in <ref> [9] </ref>, or the majority-stable predicate in [11]. In this paper we formally define the stability predicate -F-partition introduced informally in [14]. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [9]. 4.2.1 -F-Partitions Two processes p and q are F-connected in the time interval [s; t] iff (1) p and q are timely in [s; t], and (2) all but at most F messages sent between the two processes in [s; t] are delivered within at most ffi time units.
Reference: [10] <author> C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 288-323, </pages> <month> Feb </month> <year> 1988. </year>
Reference-contexts: Progress assumptions, which require that, infinitely often, some majority set of processes becomes "stable" for a certain amount of time, have a certain similarity to the global stabilization requirement of <ref> [10] </ref>, which postulates that eventually a system must permanently stabilize, in the sense that there must exist a time beyond which all messages and all non-crashed processes become timely.
Reference: [11] <author> C. Fetzer and F. Cristian. </author> <title> On the possibility of consensus in asynchronous systems. </title> <booktitle> In Proceedings of the 1995 Pacific Rim Int'l Symp. on Fault-Tolerant Systems, </booktitle> <address> Newport Beach, CA, </address> <month> Dec </month> <year> 1995. </year> <note> http://www-cse.ucsd.edu/~cfetzer/- CONS/cons.html. </note>
Reference-contexts: Well-tuned systems are expected to alternate between long periods of stability and short periods of unstability, in which the failure frequency increases beyond the assumed threshold. In <ref> [11] </ref> we introduced progress assumptions as an extension of the timed asynchronous system model: a progress assumption states that after an unstable period there always exists a time interval of minimum length in which the system will be stable. <p> There are multiple reasonable definitions for stability predicates: examples are the stable predicate in [9], or the majority-stable predicate in <ref> [11] </ref>. In this paper we formally define the stability predicate -F-partition introduced informally in [14]. <p> This can be explained by the bursty behavior of the network traffic which can cause temporary instabilities. For example, traffic bursts can be caused by occasional core dumps or file transfers via the network. Based on this observation, we introduced the concept of progress assumptions <ref> [11] </ref> to show that classical services, such as consensus, originally specified by using unconditional termination requirements, are implementable in the extended timed model.
Reference: [12] <author> C. Fetzer and F. Cristian. </author> <title> A fail-aware datagram service. </title> <booktitle> In Proceedings of the 2nd Annual Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <address> Geneva, Switzerland, </address> <month> Apr </month> <year> 1997. </year> <note> http://- www-cse.ucsd.edu/~cfetzer/FADS/fads.html. </note>
Reference-contexts: The calibrated clocks were implemented on top of the high resolution real-time clocks of Solaris. Variations in the message transmission delays introduce errors when reading remote clocks in a distributed system. We did read remote clocks using a fail-aware data-gram service <ref> [12] </ref> that calculates an upper bound on the transmission delay of each message it delivers 1 . 1 The service requires an upper bound on the drift rate of a clock. <p> FORTRESS uses UDP for interprocess communication. To model the dependence of message transmission times on the message size (see Figure 3), we could replace constants ffi and ffi min by two functions that increase with the size of a message. We actually use in <ref> [12] </ref> such a function for ffi min , i.e. ffi min increases with the size of a message. This allowed us to calculate round-trips for each of the 156 measured message sizes. a better upper bound for the transmission delay of a message. <p> A common situation in which two processes are -disconnected is when the network between them is overloaded or at least one of the pro cesses is slow. One can use a fail-aware datagram service <ref> [12] </ref> to detect all message that have transmission delay of more than while guaranteeing that no mes sage with a transmission delay of at most ffi is wrongly suspected to have a transmission delay of more than .
Reference: [13] <author> C. Fetzer and F. Cristian. </author> <title> A fail-aware membership service. </title> <booktitle> In Proceedings of the 16th Symposium on Reliable Distributed Systems, </booktitle> <month> Oct </month> <year> 1997. </year> <note> http://www-cse.ucsd.edu/~cfetzer/- FAMS/fams.html. </note>
Reference-contexts: Figure 7 shows the distribution of scheduling delays experienced by a process executing a membership protocol <ref> [13] </ref>. These measurements where performed during normal daytime use of the system (low load). it requested to be awakened. It is based on 350,000 measurements. 3.3.2 Process Failure Asssumption The timed model assumes that processes have crash/performance failure semantics [5]. <p> The average distance between two -1-stable periods was about 340ms. The typical behavior experienced during an "unstable" phase was that one of the six processes was slow. For this measurement, we used a modified membership service <ref> [13] </ref>: whenever a process declared that it cannot keep its membership up-to-date or not all six processes stayed in the membership, we knew that fp 1 ; :::; p 6 g is not -1-stable. From a theoretical point of view, one cannot determine perfectly if the system is -1-stable.
Reference: [14] <author> C. Fetzer and F. Cristian. Fail-awareness: </author> <title> An approach to construct fail-safe applications. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Fault-Tolerant Computing, </booktitle> <address> Seattle, </address> <month> Jun </month> <year> 1997. </year> <note> http://www-cse.ucsd.edu/~cfetzer/- FAPS/faps.html. </note>
Reference-contexts: There are multiple reasonable definitions for stability predicates: examples are the stable predicate in [9], or the majority-stable predicate in [11]. In this paper we formally define the stability predicate -F-partition introduced informally in <ref> [14] </ref>.
Reference: [15] <author> C. Fetzer and F. Cristian. Fortress: </author> <title> A system to support fail-aware real-time applications. </title> <booktitle> In IEEE Workshop on Middleware for Distributed Real-Time Systems and Services, </booktitle> <address> Seattle, </address> <month> Dec </month> <year> 1997. </year> <note> http://www-cse.ucsd.edu/~cfetzer/- FORTRESS/fortress.html. </note>
Reference-contexts: All measurements we describe were performed on our cluster of 9 Sun IPX workstations connected by a 10Mbit Ethernet. Seven of these computers run SunOS 4.1.2 while 2 machines run Solaris 2.5. The measurement programs use different services provided by the FORTRESS toolkit <ref> [15] </ref>. FORTRESS uses UDP for interprocess communication. To model the dependence of message transmission times on the message size (see Figure 3), we could replace constants ffi and ffi min by two functions that increase with the size of a message.
Reference: [16] <author> C. Fetzer and F. Cristian. </author> <title> A highly available local leader service. </title> <booktitle> In Proceedings of the Sixth IFIP International Working Conference on Dependable Computing for Critical Applications, </booktitle> <address> Grainau, Germany, </address> <month> Mar </month> <year> 1997. </year> <note> http://www-cse.- ucsd.edu/~cfetzer/HALL/hall.html. </note>
Reference-contexts: We call a set SP a stable partition <ref> [16] </ref> iff * all processes in SP are timely, * all but a bounded number of messages sent be tween processes in SP are delivered timely, and * from any other partition either no message or only "late" messages arrive in SP .
Reference: [17] <author> C. Fetzer and F. Cristian. </author> <title> in preparation. </title> <type> Technical report, UCSD, </type> <year> 1998. </year>
Reference-contexts: In particular, no process can determine that H p failed (before p crashed). One can implement this assumption by detecting clock failures at lower protocol levels (transparent to application) and transform them into process crash failures <ref> [17] </ref>. 3.2 Datagram Service The datagram service provides primitives for transmitting unicast and broadcast messages.
Reference: [18] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: In particular, one cannot make communication certain. Hence, systems with an unbounded failure frequency are asynchronous systems. The vast majority of distributed systems encountered in practice are asynchronous. Most published research on asynchronous systems is based on the well-known time-free model <ref> [18] </ref>, characterized by the following properties: 1) services are time-free: their specification describes what outputs and state transitions should occur in response to inputs without placing any bounds on the time it takes these outputs and state transitions to occur, 2) inter-process communication is reliable (some authors relax this condition): any <p> This research was supported by grants F49620-93 and F49620-96 from the Air Force Office of Scientific Research. are of importance in practice, such as consensus, election or membership, are not implementable <ref> [18, 2] </ref>. <p> Thus, the requirement that services be timed and processes access hardware clocks do not make the timed model less general than the time-free model from a practical point of view. In fact, the failure semantics of interprocess communication in the time-free model (as defined in <ref> [18] </ref>) is much stronger than in the timed model: while in the time-free model there cannot exist system runs in which correct processes are disconnected for the entire run, the timed model allows runs in which correct processes are permanently disconnected. <p> the timed asynchronous distributed system model, 2) provide extensive measurements of actual message and process scheduling delays and clock drifts that confirm that this model adequately describes current run-of-the-mill, distributed systems built from networked workstations. 2 Related Work The most important difference between the timed model and the time-free model <ref> [18] </ref> is the existence of local hardware clocks. Many applications are specified using real-time constrains. For example, if a component fails, then within X time units the application has to perform some action. Hardware clocks allow one to implement application level "time-outs". <p> Hardware clocks allow one to implement application level "time-outs". The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in [9] and renamed to avoid confusion with the time-free model <ref> [18] </ref>. In particular, [9] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will make progress within a bounded time. <p> Most real-world applications have soft real-time constrains. Hence, such applications need a notion of time. Neither the original time-free model <ref> [18] </ref> nor its extension with failure detectors [3] provides that. 9 These models are therefore not necessarily an ade-quate foundation for the construction of applications with soft real-time constrains. The timed model instead provides these applications with a sufficiently strong notion of time.
Reference: [19] <author> D. L. Mills. </author> <title> Internet time synchronization: the network time protocol. </title> <journal> IEEE Trans. Communications, </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: This real-time clock is more or less synchronized with real-time, e.g. UTC (universal time) or GPS time. In many Unix domains one tries to maintain a good synchronization with real-time using time services like NTP <ref> [19] </ref>. However, processes do not always know how good the synchronization with real-time is. There might not even exist an upper bound on the drift rate of a real-time clock because an operator can change the speed of the real-time clock [1].
Reference: [20] <author> D. L. Mills. </author> <title> Modelling and analysis of computer network clocks. </title> <type> Technical Report 92-5-2, </type> <institution> University of Delaware, Electrical Engineering Department, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The simplest hardware clock consists of an oscillator and a counting register that is incremented by the ticks of the oscillator. Each tick increments the clock value by a positive constant G, called the clock granularity. Other hardware clock implementations are described in <ref> [20] </ref>. Correct clocks display monotonically increasing values. We denote the set of real-time values with RT and the set of clock values with CT . The clock H p of process p is represented by a function H p from real-time to clock-time: H p : RT ! CT .
Reference: [21] <author> J. Postel. </author> <title> User datagram protocol. </title> <type> Technical Report RFC768, </type> <institution> USC / Information Sciences Institute, </institution> <year> 1980. </year>
Reference-contexts: The transmission delay of a message sent between two local processes can be smaller than ffi min . We also assume that the size of a message is not greater than some given upper bound. For example, the maximum message size for the U DP datagram service <ref> [21] </ref> is 64kByte. The datagram service does not ensure the existence of an upper bound for the transmission delay of messages.
Reference: [22] <author> B. Schneier. </author> <title> Applied Cryptography. </title> <publisher> John Wiley, </publisher> <year> 1996. </year>
Reference-contexts: The validity assumption implies that we assume that the probability of source address spoofing is negligible. When one cannot neglect this probability a priori, one can use message authentication <ref> [22] </ref> to reduce this probability so that it becomes negligible. This can be done in a manner transparent to the processes. Note that message authentication can increase the transmission time substantially without special hardware assistance.
Reference: [23] <author> P. Verissimo and C. Almeida. Quasi-synchronism: </author> <title> a step away from the traditional fault-tolerant real-time system models. </title> <journal> IEEE TCOS Bulletin, </journal> <volume> 7(4), </volume> <month> Dec </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: Progress assumptions have also a certain similarity with failure detectors [3] which are mechanisms for adding synchrony to the time-free model: certain failure detector classes provide their desired behavior based on the observation that the system eventually stabilizes. The quasi-synchronous model <ref> [23] </ref> is another approach to define a model that is in between synchronous systems and time-free asynchronous systems.
References-found: 23

