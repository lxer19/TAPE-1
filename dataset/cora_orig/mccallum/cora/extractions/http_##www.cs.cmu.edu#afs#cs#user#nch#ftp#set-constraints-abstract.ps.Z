URL: http://www.cs.cmu.edu/afs/cs/user/nch/ftp/set-constraints-abstract.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/nch/www/sba.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. Ackermann, </author> <title> "Solvable Cases of the Decision Problem", </title> <booktitle> Studies in Logic and Foundations of Mathematics, </booktitle> <publisher> North-Holland, </publisher> <year> 1962. </year>
Reference-contexts: Set based reasoning can be expressed in the predicate calculus by regarding a unary predicate as the set of values on which it is true. There are decid-ability results which deal with cases where symbols are unary; see <ref> [1] </ref> for example. (These results were in fact shown for the second-order calculus.) Rabin [8], using the second-order theory of k successors and a standard interpretation, showed that the sets definable are recursive, and furthermore, he showed that there are algorithms to decide questions such as emptiness and containment.
Reference: [2] <author> J. Doner, </author> <title> "Tree Acceptors and Some of their Applications", </title> <journal> Journal of Computer and System Sciences 4, </journal> <pages> pp 406 - 451, </pages> <year> 1970. </year>
Reference-contexts: We note that term grammar is essentially a parenthesis grammars [6]. Also a term grammar can be viewed as a description of a finite tree automaton. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see [10], <ref> [2] </ref>; also see [3] for a survey of relevant results). <p> Finally, we deal with eliminating intersection symbols. Given two term grammars, we can construct a third whose language is the intersection of the first two [10] <ref> [2] </ref>. We cannot, however, use this result to eliminate occurrences of the intersection symbol and reduce a set expression grammar into a term grammar.
Reference: [3] <author> F. Gecseg and M. Steinby, </author> <title> "Tree Automata", </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: Also a term grammar can be viewed as a description of a finite tree automaton. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see [10], [2]; also see <ref> [3] </ref> for a survey of relevant results).
Reference: [4] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <note> draft manuscript (abstract appears in Proc. ACM-POPL-90), </note> <month> November </month> <year> 1989, </year> <pages> 56 pp. </pages>
Reference-contexts: Mishra [7], in his framework for type inference in logic programs, used set constraints to model a superset of the success set of a program. Though a full decision procedure was not presented, algorithms for subcases were investigated. Heintze and Jaffar <ref> [4] </ref> used set constraints to obtain a recursive and accurate approximation of the meaning of a logic program. <p> The representations used in these papers are essentially the same as our term grammars. If, on the other hand, C does not contain any projection symbols (but may contain intersection), then a simplification algorithm contained in <ref> [4] </ref> solves the problem for lm (C). Once again, the explicit representation used there is essentially the same as a term grammar.
Reference: [5] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "Flow Analysis and Optimization of LISP-like Structures", </title> <booktitle> Proceedings 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp 244 - 256, </pages> <year> 1979. </year>
Reference-contexts: Set constraints can then be used to impose relationships between the set variables so that any model of these constraints defines a superset of the actual run-time values. In summary, set constraints provide a methodology of program approximation which ignores dependency between variables. Reynolds [9] and Jones and Muchnick <ref> [5] </ref>, for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. <p> In case C does not contain any intersection or projection symbols, the explicit representation of lm (C) is easy. In case C does not contain any intersection symbols (but may contain projection symbols), early work by Reynolds [9], and later by Jones and Muchnick <ref> [5] </ref>, gave algorithms for the explicit representation of lm (C). The representations used in these papers are essentially the same as our term grammars.
Reference: [6] <author> R. McNaughton, </author> <title> "Parenthesis Grammars", </title> <journal> Journal of the ACM 14(3), </journal> <pages> pp 490 - 500, </pages> <year> 1967. </year>
Reference-contexts: We note that term grammar is essentially a parenthesis grammars <ref> [6] </ref>. Also a term grammar can be viewed as a description of a finite tree automaton. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see [10], [2]; also see [3] for a survey of relevant results).
Reference: [7] <author> P. Mishra, </author> <title> "Toward a Theory of Types in PRO-LOG", </title> <booktitle> Proceedings 1 st IEEE Symposium on Logic Programming, Atlantic City, </booktitle> <pages> pp 289 - 298, </pages> <year> 1984. </year>
Reference-contexts: Reynolds [9] and Jones and Muchnick [5], for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. Mishra <ref> [7] </ref>, in his framework for type inference in logic programs, used set constraints to model a superset of the success set of a program. Though a full decision procedure was not presented, algorithms for subcases were investigated.
Reference: [8] <author> M.O. Rabin, </author> <title> "Decidability of Second-order The--ories and Automata on Infinite Trees", </title> <journal> Transactions of the American Math. Society 141, </journal> <pages> pp 1 - 35, </pages> <year> 1969. </year>
Reference-contexts: There are decid-ability results which deal with cases where symbols are unary; see [1] for example. (These results were in fact shown for the second-order calculus.) Rabin <ref> [8] </ref>, using the second-order theory of k successors and a standard interpretation, showed that the sets definable are recursive, and furthermore, he showed that there are algorithms to decide questions such as emptiness and containment.
Reference: [9] <author> J.C. Reynolds, </author> <title> "Automatic Computation of Data Set Definitions", </title> <booktitle> Information Processing 68, </booktitle> <publisher> North-Holland, </publisher> <pages> pp 456 - 461, </pages> <year> 1969. </year>
Reference-contexts: Set constraints can then be used to impose relationships between the set variables so that any model of these constraints defines a superset of the actual run-time values. In summary, set constraints provide a methodology of program approximation which ignores dependency between variables. Reynolds <ref> [9] </ref> and Jones and Muchnick [5], for example, considered functional programs and used a class of set constraints whose satisfiability is guaranteed. The focus of these works was to provide an explicit representation of the model defined by the constraints. <p> In case C does not contain any intersection or projection symbols, the explicit representation of lm (C) is easy. In case C does not contain any intersection symbols (but may contain projection symbols), early work by Reynolds <ref> [9] </ref>, and later by Jones and Muchnick [5], gave algorithms for the explicit representation of lm (C). The representations used in these papers are essentially the same as our term grammars.
Reference: [10] <author> J.W. Thatcher and J.B. Wright, </author> <title> "Generalized Finite Automata with an Application to a Decision Problem of Second-order Logic", </title> <booktitle> Mathematical Systems Theory 2, </booktitle> <pages> pp 57 - 82, </pages> <year> 1968. </year>
Reference-contexts: We note that term grammar is essentially a parenthesis grammars [6]. Also a term grammar can be viewed as a description of a finite tree automaton. Hence there are algorithms for combining term grammars over the boolean and projection operations, and for testing emptyness and containment (see <ref> [10] </ref>, [2]; also see [3] for a survey of relevant results). <p> Finally, we deal with eliminating intersection symbols. Given two term grammars, we can construct a third whose language is the intersection of the first two <ref> [10] </ref> [2]. We cannot, however, use this result to eliminate occurrences of the intersection symbol and reduce a set expression grammar into a term grammar.
References-found: 10

