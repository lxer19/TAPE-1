URL: http://www.cs.brown.edu/courses/cs227/papers/b2/pathexp.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: Vassilis.Christophides@inria.fr  Sophie.Cluet@inria.fr  moer@gom.informatik.rwth-aachen.de  
Title: Evaluating Queries with Generalized Path Expressions  
Author: Vassilis Christophides Sophie Cluet Guido Moerkotte 
Address: 78153 Le Chesnay, Cedex France  78153 Le Chesnay, Cedex France  Ahornstr. 55, 52074 Aachen Germany  
Affiliation: I.N.R.I.A.  I.N.R.I.A.  Lehrstuhl fur Informatik III  
Abstract: In this paper, we extend an object algebra with two new operators and present some interesting rewriting techniques for queries featuring generalized path expressions. We also show how a query optimizer can integrate the new techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat87] <author> D. Batory. </author> <title> Extensible cost models and query optimization in Genesis. </title> <journal> IEEE Database Engineering, </journal> <volume> 10(4), </volume> <month> November </month> <year> 1987. </year> <month> 9 </month>
Reference-contexts: However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations.
Reference: [Ber89] <author> E. Bertino. </author> <title> Issues in indexing techniques for object-oriented databases. </title> <booktitle> In Proc. of Advanced Database System Symposium, </booktitle> <pages> pages 151-160, </pages> <year> 1989. </year>
Reference-contexts: We are well aware that for very large schemata, this approach seems to be too expensive. Hence, we expect future research on this issue. 5.2 Using Indexes on D inst operations There are several kinds of indexes <ref> [Ber89] </ref> (path indexes, multi-indexes, etc.) for object-oriented databases, some of which are implemented in real systems. Obviously, it is our goal to use indexes on the D inst operations. The use of standard object indexes offers some interesting challenges.
Reference: [BF92] <author> E. Bertino and P. Foscoli. </author> <title> An analytical cost model of object-oriented query costs. </title> <booktitle> In Proc. Persistent Object Systems, </booktitle> <pages> pages 151-160, </pages> <year> 1992. </year>
Reference-contexts: Let us discuss the D inst operator first since its treatment is easier. The D inst operator starts with a set of schema paths to be evaluated, i.e. instantiated. To estimate the costs and number of instances touched, regular cost models developed for the evaluation of path expressions suffice <ref> [BF92, KM90] </ref>. For the S inst operator, things are not so easy. For evaluating its cost and derive information about the number of classes at the beginning or end of a schema path, we rely on statistics that are gathered from the schema.
Reference: [BMG93] <author> J. Blakeley, W. McKenna, and G. Graefe. </author> <title> Experiences building the Open OODB query optimizer. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 287-295, </pages> <year> 1993. </year>
Reference-contexts: This is one purpose of the map operator. Other purposes are dereferencing, method and function application. Also, our translation process pushes all nesting into map operators. The first definition corresponds to the standard map [KM93] or materialize <ref> [BMG93] </ref> operator. The second definition is just a shorthand for map with tuple construction.
Reference: [BRG88] <author> E. Bertino, F. Rabitti, and S. Gibbs. </author> <title> Query Processing in a Multimedia Document System. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 6(1) </volume> <pages> 1-41, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: 1 Introduction In the past few years there has been a growing interest towards query languages featuring generalized path expressions (GPE) <ref> [BRG88, KKS92, CACS94, QRS + 95] </ref>. With these languages, one may issue queries on data without exact knowledge of its structure. A GPE queries data and structure at the same time. <p> A GPE queries data and structure at the same time. Although very useful for standard database applications, these languages are vital for new applications dedicated, for instance, to (semi)structured documents. There have been some proposals for evaluating queries with generalized path expressions <ref> [BRG88, CACS94] </ref>. However, these proposals are rather naive and inefficient. In this paper, we present an algebraic approach to deal with GPE's in the object oriented context. Therefore, we extend an object algebra by two new operators and then demonstrate the advantages of this clean and flexible approach. <p> Sometimes, the structure of the data is imposed by the schema; sometimes some flexibility is left and there is no schema fixed in advance. Indeed, there are different motivations for introducing GPE's into query languages. In <ref> [BRG88, CACS94] </ref>, GPE's were used as a means to provide better tools for querying documents stored in an object base. The particularity of that kind of application is that users are interested in data at various granularity levels. <p> The situation is even worse, if path variables are involved since the number of possible paths is far larger than the number of attributes. Therefore, we look for alternatives. Another possibility, proposed in <ref> [BRG88] </ref>, is to use the Boolean connector or instead of a union 2 .
Reference: [CACS94] <author> V. Christophides, S. Abiteboul, S. Cluet, and M. Scholl. </author> <title> From structured documents to novel query facilities. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Minneapolis, Minnesota, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction In the past few years there has been a growing interest towards query languages featuring generalized path expressions (GPE) <ref> [BRG88, KKS92, CACS94, QRS + 95] </ref>. With these languages, one may issue queries on data without exact knowledge of its structure. A GPE queries data and structure at the same time. <p> A GPE queries data and structure at the same time. Although very useful for standard database applications, these languages are vital for new applications dedicated, for instance, to (semi)structured documents. There have been some proposals for evaluating queries with generalized path expressions <ref> [BRG88, CACS94] </ref>. However, these proposals are rather naive and inefficient. In this paper, we present an algebraic approach to deal with GPE's in the object oriented context. Therefore, we extend an object algebra by two new operators and then demonstrate the advantages of this clean and flexible approach. <p> Sometimes, the structure of the data is imposed by the schema; sometimes some flexibility is left and there is no schema fixed in advance. Indeed, there are different motivations for introducing GPE's into query languages. In <ref> [BRG88, CACS94] </ref>, GPE's were used as a means to provide better tools for querying documents stored in an object base. The particularity of that kind of application is that users are interested in data at various granularity levels. <p> Generalized Path Expressions At this point, the reader may be interested in seeing a GPE. Let us consider the following example featuring two GPE's in the from clause. The language is an extension of the OQL language and was introduced in <ref> [CACS94] </ref>. select struct (person: p, wine: w) from Personfpg.A, Winefwg.B where p.A = w.B The query pairs Persons together with appropriate birthday presents. All birthday presents are taken from our wine cellar. <p> Within the example, the ranges of A and B are restricted to the attributes of Person and Wine. The semantics of the query can be thought of as being the following (for a formal semantics see <ref> [CACS94] </ref>). For each possible attribute binding the query is evaluated. If a type error occurs, the binding does not result in any qualifying tuples. <p> The domain of a path variable is the set of all the "legal paths" that can be constructed from the database schema. We do not really care about the interpretation given to "legal path". Ours is similar to that of <ref> [CACS94] </ref> but any reasonable interpretation would do. The restriction on the domains is given by the predicate p. Note that the input set is not involved in the instantiations of the path/attribute variables. <p> Further, since the semantics of path variables is restricted to acyclic instantiations at schema level <ref> [CACS94] </ref>, trees are perfect for our representation. Indeed, this factorization is adequate for the paths in-stantiation through complex composition or inheritance graphs. Note that the internal representation of paths is a physical issue. <p> Also note that union types are required. This does not come as a surprise since GPE's usually introduce union types. To avoid unnecessary problems, we consider here marked unions as in <ref> [CACS94] </ref>. 4 Optimizing Queries with GPE Traditional optimizers first perform type inference. After this step, all type information is present and the "real" optimization can start. <p> Operation (2) finds all the possible attributes of a person. Operation (3) evaluates these attributes for each person. Operations (4,5,6) are similar. Operation (7) is a join. Two remarks are noteworthy: First, the join predicate involves union types (for more details on the manipulation of unions see <ref> [CACS94] </ref>). Second, the join operation has required some rewriting after the translation process. Usually, from-where clauses are translated into d-join and a selection.
Reference: [CM95a] <author> S. Cluet and G. Moerkotte. </author> <title> Classification and optimization of nested queries in object bases. </title> <type> Technical Report 95-6, </type> <institution> RWTH Aachen, </institution> <year> 1995. </year>
Reference-contexts: Hence, it is our goal, to integrate schema lookup and object base lookup, and to be able to apply optimization techniques in a homogeneous fashion to both lookups. For this, we extend the algebra of <ref> [CM95a] </ref> with two new operators that instantiate GPE's from a schema and a data perspective. We start by a short presentation of the algebra before introducing the new operators along with data structures for their implementation. <p> This guarantees some nice properties among which is the associativity of the join operator. We now present the algebraic operators that will be used in the sequel. Other operators and equivalences can be found in <ref> [CM95a] </ref>. Map Operations (and Projection) These operators are fundamental to the algebra. Since the other operators are defined on sets of tuples, sets of non-tuples (mostly sets of objects) must be transformed into sets of tuples. This is one purpose of the map operator. <p> query is translated into the algebra and how D inst/S inst operators are integrated in the rewriting process. select struct (person:p,wine:w) from Personfpg.A, Winefwg.A' where p.A = w.A' In a first step the query is translated into the algebra in the following way (for more details on the translation see <ref> [CM95a] </ref>). Note that a static type inference is performed before/during the translation process and that the S inst operations use the type information thus obtained.
Reference: [CM95b] <author> S. Cluet and G. Moerkotte. </author> <title> Query optimization techniques exploiting class hierarchies. </title> <type> Technical Report 95-7, </type> <institution> RWTH-Aachen, </institution> <year> 1995. </year>
Reference-contexts: Nonetheless, the problem sounds familiar even from the relational context: there, database statistics and cost functions where introduced in order to solve the problem. Further, within the context of object queries, the problem is faced when optimizing within a class hierarchy context <ref> [CM95b] </ref>. Our current approach to the problem is as follows. We rely on heuristics to push cheap operations especially selections after the S inst and D inst operators. More specifically, operators less expensive than S inst or D inst operators are pushed after them, the others are pulled before them.
Reference: [GD87] <author> G. Graefe and D. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 160-172, </pages> <address> San Francisco, </address> <year> 1987. </year>
Reference-contexts: However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations.
Reference: [GM91] <author> G. Graefe and W. McKenna. </author> <title> The Volcano optimizer generator. </title> <type> Tech. Report 563, </type> <institution> University of Colorado, Boulder, </institution> <year> 1991. </year>
Reference-contexts: However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations.
Reference: [GW89] <author> G. Graefe and K. Ward. </author> <title> Dynamic query evaluation plans. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 358-366, </pages> <year> 1989. </year>
Reference-contexts: The interpreter has to evaluate queries partially and use the resulting type information to simplify the remaining expression. A compiler could be implemented such that it generates different alternative plans depending on the possible outcomes, and then generates an according chose-plan operator <ref> [GW89] </ref> tying the different plans together. The when-question is more complicated. Indeed, one cannot expect the optimizer to partially evaluate all alternative query execution plans just to perform further optimization. In a nutshell: partial evaluation is needed to do further optimization but should be performed with circumspection.
Reference: [HFLP89] <author> L. M. Haas, J.C. Freytag, G.M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 377-388, </pages> <year> 1989. </year>
Reference-contexts: However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations.
Reference: [JWKL90] <author> P. Jenq, D. Woelk, W. Kim, and W. Lee. </author> <title> Query processing in distributed ORION. </title> <booktitle> In Proc. Int. Conf. on Extended Database Technology (EDBT), </booktitle> <pages> pages 169-187, </pages> <address> Venice, </address> <year> 1990. </year>
Reference-contexts: This implies clever splitting of D inst operations. In the same range of idea, whereas indexes usually concern paths of reasonable length, we are dealing with queries along potentially long paths. This can be solved by the use of standard path splitting techniques (e.g., <ref> [JWKL90] </ref>). These difficulties and the fact that GPE's were first introduced for documents led us to look at full text indexing techniques. Obviously, these techniques are not reasonable in an environment with many updates. However, their interest is clear if we consider retrieval applications (e.g., interrogation of a library).
Reference: [KKS92] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented databases. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 393-402, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction In the past few years there has been a growing interest towards query languages featuring generalized path expressions (GPE) <ref> [BRG88, KKS92, CACS94, QRS + 95] </ref>. With these languages, one may issue queries on data without exact knowledge of its structure. A GPE queries data and structure at the same time. <p> One may want to view a whole section as a text, or to see the different paragraphs involved in a section. The schema being fixed, this means that a user may want to ignore some parts of it. Thus the language must allow interrogation with partial schema knowledge. In <ref> [KKS92] </ref>, GPE's were used to deal with the fact that, in object-oriented (oo) systems, some information is captured by the schema and, thus, it is important to be able to query the schema.
Reference: [KM90] <author> A. Kemper and G. Moerkotte. </author> <title> Access support in object bases. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 364-374, </pages> <year> 1990. </year>
Reference-contexts: Let us discuss the D inst operator first since its treatment is easier. The D inst operator starts with a set of schema paths to be evaluated, i.e. instantiated. To estimate the costs and number of instances touched, regular cost models developed for the evaluation of path expressions suffice <ref> [BF92, KM90] </ref>. For the S inst operator, things are not so easy. For evaluating its cost and derive information about the number of classes at the beginning or end of a schema path, we rely on statistics that are gathered from the schema.
Reference: [KM93] <author> A. Kemper and G. Moerkotte. </author> <title> Query optimization in object bases: Exploiting relational techniques. </title> <booktitle> In Proc. Dagstuhl Workshop on Query Optimization (J.-C. </booktitle> <editor> Freytag, D. Maier und G. Vossen (eds.)). Morgan-Kaufman, </editor> <year> 1993. </year>
Reference-contexts: The next section will show how they can be used advantageously. 3.1 The Core Algebra We assume standard knowledge on oo data models. The algebra is an extension of the GOM algebra <ref> [KM93, KMP93] </ref>. Its main characteristic is that | with the exception of the map operator | it is defined on sets of tuples. This guarantees some nice properties among which is the associativity of the join operator. We now present the algebraic operators that will be used in the sequel. <p> This is one purpose of the map operator. Other purposes are dereferencing, method and function application. Also, our translation process pushes all nesting into map operators. The first definition corresponds to the standard map <ref> [KM93] </ref> or materialize [BMG93] operator. The second definition is just a shorthand for map with tuple construction.
Reference: [KMP93] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 543-554, </pages> <year> 1993. </year>
Reference-contexts: The next section will show how they can be used advantageously. 3.1 The Core Algebra We assume standard knowledge on oo data models. The algebra is an extension of the GOM algebra <ref> [KM93, KMP93] </ref>. Its main characteristic is that | with the exception of the map operator | it is defined on sets of tuples. This guarantees some nice properties among which is the associativity of the join operator. We now present the algebraic operators that will be used in the sequel. <p> However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations. <p> More specifically, operators less expensive than S inst or D inst operators are pushed after them, the others are pulled before them. The building block approach seems to be well suited for supporting this task <ref> [KMP93, Loh88] </ref>. The remaining problem then is to estimate the costs of the S inst and D inst operators as well as information about the number of schema paths/path instances and classes/objects at the start and end of a path.
Reference: [Loh88] <author> G. M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 18-27, </pages> <year> 1988. </year>
Reference-contexts: More specifically, operators less expensive than S inst or D inst operators are pushed after them, the others are pulled before them. The building block approach seems to be well suited for supporting this task <ref> [KMP93, Loh88] </ref>. The remaining problem then is to estimate the costs of the S inst and D inst operators as well as information about the number of schema paths/path instances and classes/objects at the start and end of a path.
Reference: [MZD92] <author> G. Mitchell, S. Zdonik, and U. Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <booktitle> In Proc. of the Hawaiian Conf. on Computer and System Sciences, </booktitle> <pages> pages 787-798, </pages> <year> 1992. </year>
Reference-contexts: However, there are also some difficulties. By these, we do not refer to the two additional algebraic operators and the dozen of new equivalences. These can easily be dealt with by extensible optimizers <ref> [Bat87, HFLP89, GM91, GD87, KMP93, MZD92] </ref>. The key issue here is the partial evaluation of plans before further optimization decisions are made, or to be more precise, the evaluation of partial plans. In addition, another interesting issue is the use of index for evaluating D inst operations.
Reference: [QRS + 95] <author> D. Quass, A. Rajaraman, Y. Sagiv, J. Ullman, and J. Widom. </author> <title> Querying semistructured heterogeneous information. </title> <booktitle> In Proc. Int. Conf. on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 319-344, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction In the past few years there has been a growing interest towards query languages featuring generalized path expressions (GPE) <ref> [BRG88, KKS92, CACS94, QRS + 95] </ref>. With these languages, one may issue queries on data without exact knowledge of its structure. A GPE queries data and structure at the same time. <p> In [KKS92], GPE's were used to deal with the fact that, in object-oriented (oo) systems, some information is captured by the schema and, thus, it is important to be able to query the schema. Another motivation for GPE's is related to the interrogation of semistructured data <ref> [QRS + 95] </ref> which has no absolute schema fixed in advance and its structure may be irregular or incomplete.
Reference: [Sim95] <author> J. Simeon. </author> <title> Recherche en texte integral et bases de donnees orientees-objet. </title> <type> Master's thesis, </type> <institution> Universite de Nancy I, </institution> <year> 1995. </year> <month> 10 </month>
Reference-contexts: The first point is easy, the second more tricky but can be done at a reasonable (storage) cost <ref> [Sim95] </ref>. Now, consider the following query: select f from Encyclopedia P (f) where f.caption like "*Mont-St-Michel*" The query retrieves the figures (or other elements featuring a caption attribute) of the encyclopedia whose caption contains the name "Mont-St-Michel".
References-found: 21

