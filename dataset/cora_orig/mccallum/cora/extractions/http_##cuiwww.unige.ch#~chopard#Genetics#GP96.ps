URL: http://cuiwww.unige.ch/~chopard/Genetics/GP96.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: mouloud@cui.unige.ch Switzerland marco.tomassini@di.ep.ch chopard@cui.unige.ch olivier@olsen.ch  
Title: Parallel Genetic Programming: an application to Trading Models Evolution machines. To overcome the time overhead
Author: Mouloud Oussaidne Bastien Chopard Olivier V. Pictet Marco Tomassini 
Note: memory  evaluate  models can be inferred and that the  
Address: CH-1211 Genve 4 Economics, Seefeldstr. 233 CH-1015 Lausanne-Ecublens Switzerland CH-8008 Zurich Switzerland  
Affiliation: CUI, Universit de Genve Olsen&Associates CSCS, Manno and 24 rue Gnral-Dufour Research Institute for Applied LSL, EPFL  
Abstract: We present a parallel implementation of with program evaluation, we propose and compute-intensive application. Our results show that reasonable trading genetic programming on distributed
Abstract-found: 1
Intro-found: 1
Reference: <author> Allen, F. and Karjalainen R. </author> <year> 1993. </year> <title> Using genetic algorithms to find technical trading rules. </title> <institution> Working paper,Wharton school, university of Pennsylvania. </institution>
Reference-contexts: When a processor is selected to perform a task its work load is increased by the size of that task. 5. Evolving trading models Besides alleviating the restrictions of fixed-length representation of genetic structures, genetic programming provides a natural way to represent and evolve decision trees <ref> (Allen and Karjalainen 1993) </ref>. The application presented here describes a way to use genetic programming to learn technical trading models for foreign exchange (FX) market. The recommendations given by a trading model are purely based on past prices of the exchange rate being analyzed.
Reference: <author> Fraser, A. P. </author> <year> 1994. </year> <title> Genetic programming in C++, public domain genetic programming system. </title>
Reference-contexts: The code was written in C++ using the PVM3 message passing library (Geist et al. 1994) and can be run on other parallel machines such as the Cray T3D. The sequential version of the code is based on <ref> (Fraser 1994) </ref>. The organization of this paper is as follows. The evolution of genetic programs is outlined in section 2. Section 3 discusses the PGPS architecture. Section 4 highlights the load balancing problem and analyzes two different techniques for solving the problem.
Reference: <author> Geist, A., Beguelin A., Dongarra J., Jiang W., Manchek R. and Sunderam V. </author> <year> 1994. </year> <title> PVM3 Users Guide and reference manual, </title> <address> ORNL/TM-12187, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Our implementation shows that, for problems of large enough size, the parallelization of genetic programming on distributed memory machines can deliver a nearly linear speed-up. The code was written in C++ using the PVM3 message passing library <ref> (Geist et al. 1994) </ref> and can be run on other parallel machines such as the Cray T3D. The sequential version of the code is based on (Fraser 1994). The organization of this paper is as follows. The evolution of genetic programs is outlined in section 2.
Reference: <author> Holland, J. </author> <year> 1975. </year> <title> Adaptation in Natural and Artificial Systems, </title> <institution> University of Michigan Press, Ann Arbor. IBM, </institution> <year> 1995. </year> <title> Scalable POWER Parallel Systems, </title> <month> February </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Artificial evolutionary processes, such as genetic algorithms (GA) <ref> (Holland 1975) </ref>, are based on reproduction, recombination and selection of the fittest members in an evolving population of candidate solutions. (Koza 1992) extended this genetic model of learning into the space of programs and thus introduced the concept of genetic programming.
Reference: <author> Koza, J. </author> <year> 1992. </year> <title> Genetic programming, </title> <publisher> MIT Press. </publisher>
Reference-contexts: 1. Introduction Artificial evolutionary processes, such as genetic algorithms (GA) (Holland 1975), are based on reproduction, recombination and selection of the fittest members in an evolving population of candidate solutions. <ref> (Koza 1992) </ref> extended this genetic model of learning into the space of programs and thus introduced the concept of genetic programming. Each solution in the search space is represented by a genetic program (GP), traditionally using the Lisp syntax.
Reference: <author> Koza, J. and Andre D. </author> <year> 1995. </year> <title> Parallel Genetic Programming on a Network of Transputers, </title> <institution> Computer Science Department, Stanford University, </institution> <note> Technical report CS-TR-95-1542. </note>
Reference-contexts: Other authors suggested fixing only the problem size and to average over many runs <ref> (Koza and Andre 1995) </ref> but their model is based on evolving several loosely-connected subpopulations and is different from ours. The speed-ups of both static and dynamic scheduling algorithms are shown in Figure 4. The elapsed time was measured in dedicated mode.
Reference: <author> Oussaidne, M., Chopard B. and Tomassini M. </author> <year> 1995. </year> <editor> Programmation volutionniste parallle, RenPar7 , PIP-FPMs Mons , Belgium. Libert G., Dekeyser J.L., Manneback P. </editor> <publisher> (editors). </publisher>
Reference-contexts: Parallelizing the evaluation phase on a parallel coarse-grain machine such as the IBM SP-2, can be done easily. After the reproduction phase, each GP is simply sent to a processing node for evaluation, independently of operations in other processing nodes <ref> (Oussaidne, Chopard and Tomassini 1995) </ref>. However, the run time GP complexity with programs of widely differing sizes makes the design of a parallel algorithm and its implementation to obtain large speed-ups a nontrivial task. This irregularity causes some processing nodes to be idle while others are active. <p> Experimental results This section discusses both parallel programming and trading model performances. Given the large size of our data set, the speed-up measurements were obtained by limiting the number of fitness cases to 1000 when fitting the logistic function <ref> (Oussaidne, Chopard and Tomassini 1995) </ref> and are consistent with the speed-ups obtained for the trading model application. p 1 p 2 X X R 2 2 R C 2 eff eff s eff 3 I x r j n, , , t ( ) fig 4: speed-up of PGPS for ,
Reference: <author> Pictet, O.V. , Dacorogna M.M. , Muller U. A. , Olsen R. B. and Ward J.R. </author> <year> 1992. </year> <title> Real-time trading models for foreign exchange rates , Neural Network World 6/92, </title> <type> 713-744. </type>
Reference-contexts: An EMA is characterized by its range (in days), r, and its order (the number of successive applications of EMA to the initial price time series). A full description of momentum computation is given in <ref> (Pictet et al. 1992) </ref>. We use the notation to refer to the normalized price momentum based on r days EMAs of order in [j .. n]. The major problem in optimizing trading models is to avoid overfitting caused by the presence of noise.
Reference: <author> Pictet, O.V., Dacorogna M.M., Chopard B., Oussaid-ene M., Schirru R. and Tomassini M. </author> <year> 1995. </year> <title> Using Genetic Algorithms for Robust Optimization in Financial Applications , Neural Network World 4/95, </title> <type> 573-587. </type>
Reference-contexts: In order to avoid this phenomena, the idea is to build genetic programs based on pre-optimized building blocks. These building blocks (robust indicators) were optimized using a niching genetic algorithm based on a fitness sharing scheme <ref> (Pictet et al. 1995) </ref>. The fitness measure of a trading model quantifies not only the return but also the risk involved by the model. The total return of a model is obtained by continuously accumulating the return of each transaction (which is null for transactions starting from the neutral position).
References-found: 9

