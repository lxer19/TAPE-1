URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications/tr/UCB-ERL-94-87.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications.html
Root-URL: 
Title: Synthesis of Software Programs for Embedded Control Applications  
Author: Massimiliano Chiodo, Paolo Giusto, Harry Hsieh Attila Jurecska, Luciano Lavagno, Alberto Sangiovanni-Vincentelli, Ellen Sentovich, Kei Suzuki 
Abstract: Software components for embedded reactive real-time applications must satisfy tight code size and run-time constraints. Cooperating Finite State Machines provide a convenient intermediate format for embedded system co-synthesis, between high-level specification languages and software or hardware implementations. We propose a software generation methodology that takes advantage of the very restricted class of specifications and allows for tight control over the implementation cost. The methodology exploits several techniques from the domain of Boolean function optimization. We also describe how the simplified control/data-flow graph used as an intermediate representation can be used to accurately estimate the size and timing cost of the final executable code. fl This author is supported by SRC Contract 94-DC-008.
Abstract-found: 1
Intro-found: 1
Reference: [Ake78] <author> S. B. Akers. </author> <title> Binary Decision Diagrams. </title> <journal> In IEEE Transactions on Computers, </journal> <volume> volume C-27, </volume> <pages> pages 509-516, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: easier satisfaction of "short term" timing constraints (e.g., those dictated by a specific interface protocol implemented directly in software) which may be more difficult to satisfy with classical scheduling techniques (designed for "long term" response and input rate constraints). 2.2 Binary Decision Diagrams and Characteristic Functions A Binary-Decision Diagram (BDD, <ref> [Ake78, Bry86] </ref>) is an efficient representation for storing and manipulating Boolean functions. A BDD is a directed acyclic graph with a root node for each output function and leaf nodes representing the value of each function for each input minterm.
Reference: [ASU88] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference: [BCG91] <author> G. Berry, P. Couronne, and G. Gonthier. </author> <title> The synchronous approach to reactive and real-time systems. </title> <journal> IEEE Proceedings, </journal> <volume> 79, </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: Section 4 describes the s-graph synthesis and optimization procedure. Section 5 shows some experimental results demonstrating the effectiveness of the approach. 3 2 Preliminaries 2.1 Previous Work Previous approaches to automated code generation for reactive real-time systems have started either from synchronous programming languages (e.g., Esterel, <ref> [BCG91] </ref>), or from other high-level languages ([CWB94, GJM94]). In the first case, the main problem is the identification of a single FSM equivalent to the Esterel specification, and its efficient implementation as a software program.
Reference: [Bry86] <author> R. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Translation of a given CFSM into an s-graph. 2. S-graph optimization. 3. Translation of the s-graph into a target language. 4. Scheduling of the CFSMs. 5. Compilation into machine code to be run on the target processor. Step 1 uses Binary Decision Diagrams (BDDs, <ref> [Bry86] </ref>) as an intermediate representation, to generate a very fast initial s-graph, potentially at the expense of code size. <p> easier satisfaction of "short term" timing constraints (e.g., those dictated by a specific interface protocol implemented directly in software) which may be more difficult to satisfy with classical scheduling techniques (designed for "long term" response and input rate constraints). 2.2 Binary Decision Diagrams and Characteristic Functions A Binary-Decision Diagram (BDD, <ref> [Ake78, Bry86] </ref>) is an efficient representation for storing and manipulating Boolean functions. A BDD is a directed acyclic graph with a root node for each output function and leaf nodes representing the value of each function for each input minterm.
Reference: [BS89] <author> R. K. Brayton and F. Somenzi. </author> <title> Boolean Relations and the Incomplete Specification of Logic Networks. </title> <booktitle> In Proceedings of VLSI 89, </booktitle> <month> August </month> <year> 1989. </year>
Reference: [CGH + 93a] <author> Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, and Alberto Sangiovanni-Vincentelli. </author> <title> A formal specification model for hard 15 ware/software codesign. </title> <type> Technical Report UCB/ERL M93/48, </type> <institution> U.C. Berkeley, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: FSMs are either explicitly used as input (both in graphic and in textual form [HLN + 90], [SSR89]), or as intermediate format ([Hal93], [WTHM92]) of embedded system design tools. Although we use the Codesign Finite State Machine (CFSM) model defined in <ref> [CGH + 93a, CGH + 93b] </ref> for the sake of explanation, our results can be applied to any FSM-based specification. The use of FSMs for embedded control specification offers several advantages over apparently more powerful formalisms (such as unrestricted programming languages). <p> More precisely, an input variable x j belongs to the support of y i if S x j y i (x 1 ; : : : x n ) 6= y i (x 1 ; : : : x n ). 2.3 Codesign Finite State Machines According to <ref> [CGH + 93a, CGH + 93b] </ref>, a CFSM is a reactive Finite State Machine with a set of input and output events. Events are entities that may occur at determinate instants of time and may or may not carry a value (cfr. the notion of signal in Esterel).
Reference: [CGH + 93b] <author> Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, and Alberto Sangiovanni-Vincentelli. </author> <title> A formal specification model for hardware/software codesign. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <year> 1993. </year>
Reference-contexts: FSMs are either explicitly used as input (both in graphic and in textual form [HLN + 90], [SSR89]), or as intermediate format ([Hal93], [WTHM92]) of embedded system design tools. Although we use the Codesign Finite State Machine (CFSM) model defined in <ref> [CGH + 93a, CGH + 93b] </ref> for the sake of explanation, our results can be applied to any FSM-based specification. The use of FSMs for embedded control specification offers several advantages over apparently more powerful formalisms (such as unrestricted programming languages). <p> More precisely, an input variable x j belongs to the support of y i if S x j y i (x 1 ; : : : x n ) 6= y i (x 1 ; : : : x n ). 2.3 Codesign Finite State Machines According to <ref> [CGH + 93a, CGH + 93b] </ref>, a CFSM is a reactive Finite State Machine with a set of input and output events. Events are entities that may occur at determinate instants of time and may or may not carry a value (cfr. the notion of signal in Esterel).
Reference: [CW91] <editor> R. Camposano and W. Wolf, editors. </editor> <title> High-level VLSI synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference: [CWB94] <author> Pai Chou, E. Walkup, and G. Borriello. </author> <title> Scheduling for reactive real-time systems. </title> <booktitle> IEEE Micro, </booktitle> <month> August </month> <year> 1994. </year>
Reference: [GJM94] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> Program implementation schemes for hardware-software systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-55, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The difference is that we can take advantage of the large body of research about scheduling for real-time systems (e.g., [LL73]) for the second step. On the other hand, some of the algorithms of <ref> [GJM94] </ref> can also be used to perform a preliminary optimization before our synthesis algorithm.
Reference: [Hal93] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference: [HLN + 90] <author> D. Har'el, H. Lachover, A. Naamad, A. Pnueli, et al. STATEMATE: </author> <title> a working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: Finite State Machines (FSMs) provide a convenient and common mechanism for specifying the intended behavior of such systems. FSMs are either explicitly used as input (both in graphic and in textual form <ref> [HLN + 90] </ref>, [SSR89]), or as intermediate format ([Hal93], [WTHM92]) of embedded system design tools. Although we use the Codesign Finite State Machine (CFSM) model defined in [CGH + 93a, CGH + 93b] for the sake of explanation, our results can be applied to any FSM-based specification.
Reference: [KM92] <author> D. Ku and G. De Micheli. </author> <title> High level synthesis of ASICs under timing and synchronization constraints. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: In the second case, the main emphasis is on the scheduling of operations derived from a concurrent high-level specification (e.g., hardware-C, <ref> [KM92] </ref>). The problem is that of choosing an order for potentially concurrent operations that satisfies the given timing constraints. In our case, we decompose the problem of satisfying timing constraints into two (possibly iterated) steps: 1. code generation for each CFSM, 2. scheduling of CFSM transitions to satisfy timing constraints.
Reference: [Lee59] <author> C. Y. Lee. </author> <title> Representation of switching functions by binary decision programs. </title> <journal> Bell System Technical Journal, </journal> <volume> 38 </volume> <pages> 985-999, </pages> <year> 1959. </year>
Reference: [LL73] <author> C. Liu and J.W Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 44-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: The difference is that we can take advantage of the large body of research about scheduling for real-time systems (e.g., <ref> [LL73] </ref>) for the second step. On the other hand, some of the algorithms of [GJM94] can also be used to perform a preliminary optimization before our synthesis algorithm.
Reference: [Mei89] <author> C. Meinel. </author> <title> Modified branching programs and their computational power. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: A simple s-graph is shown in Figure 1. The s-graph model resembles branching programs ([Lee59], <ref> [Mei89] </ref>) and Binary Decision Dia grams. Both branching programs and BDDs are different from s-graphs because they allow: * only single-variable predicates on TEST nodes and * only assignments to a single output variable (as the last level of nodes).
Reference: [Rud93] <author> R. Rudell. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In Proceedings International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: For this reason, it is very important to have a small BDD representing the transition function. Dynamic variable reordering is run to locally optimize the BDD size. The reordering is done with the "sift" algorithm <ref> [Rud93] </ref>, which sifts one variable at a time up and down in the ordering and freezes it in the position where the BDD size is minimized (with the constraint that no output can sift before any input in its support).
Reference: [SSL + 92] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The Boolean circuit is optimized using, e.g., the logic synthesis algorithms described in <ref> [SSL + 92] </ref>. The s-graph can now be constructed as a string of ASSIGN vertices, one for each output variable y j for each value k of the selection variable s.
Reference: [SSR89] <author> R. Saracco, J.R.W. Smith, and R. Reed. </author> <title> Telecommunications systems engineering using SDL. </title> <publisher> North-Holland - Elsevier, </publisher> <year> 1989. </year>
Reference-contexts: Finite State Machines (FSMs) provide a convenient and common mechanism for specifying the intended behavior of such systems. FSMs are either explicitly used as input (both in graphic and in textual form [HLN + 90], <ref> [SSR89] </ref>), or as intermediate format ([Hal93], [WTHM92]) of embedded system design tools. Although we use the Codesign Finite State Machine (CFSM) model defined in [CGH + 93a, CGH + 93b] for the sake of explanation, our results can be applied to any FSM-based specification.
Reference: [WTHM92] <author> W. Wolf, A. Takach, C.-Y. Huang, and R. </author> <title> Manno. The Princeton University behavioral synthesis system. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Finite State Machines (FSMs) provide a convenient and common mechanism for specifying the intended behavior of such systems. FSMs are either explicitly used as input (both in graphic and in textual form [HLN + 90], [SSR89]), or as intermediate format ([Hal93], <ref> [WTHM92] </ref>) of embedded system design tools. Although we use the Codesign Finite State Machine (CFSM) model defined in [CGH + 93a, CGH + 93b] for the sake of explanation, our results can be applied to any FSM-based specification.
Reference: [Yee94] <author> S.Y. Yee. </author> <title> An esterel to SHIFT compiler for a hardware/software codesign environment. </title> <type> Master's thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1994. </year> <month> 16 </month>
References-found: 21

