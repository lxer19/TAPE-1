URL: ftp://ftp.cs.purdue.edu/pub/hosking/papers/gc-workshop93c.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/hosking/papers.html
Root-URL: http://www.cs.purdue.edu
Email: hosking@cs.umass.edu  hudson@cs.umass.edu  
Title: Remembered sets can also play cards  
Author: Antony L. Hosking Richard L. Hudson 
Address: Amherst, MA 01003  
Affiliation: Object Systems Laboratory Department of Computer Science University of Massachusetts  
Abstract: Remembered sets and dirty bits have been proposed as alternative implementations of the write barrier for garbage collection. There are advantages to both approaches. Dirty bits can be efficiently maintained with minimal, bounded overhead per store operation, while remembered sets concisely, and accurately record the necessary information. Here we present evidence to show that hybrids can combine the virtues of both schemes and offer competitive performance. Moreover, we argue that a hybrid can better avoid the devils that are the downfall of the separate alternatives. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 108-120, </pages> <address> Santa Clara, California, </address> <month> Apr. </month> <year> 1991. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 4 (Apr. </month> <year> 1991). </year>
Reference-contexts: The system call would clear the user-level dirty bits and enable traps on the specified pages. Traps could then be handled directly in the operating system. This can have substantial savings. As reported for a MIPS R2000 <ref> [1] </ref>, the time for a user program to trap to a null C routine in the kernel and return to the user program is 15.4s round trip.
Reference: [2] <author> A. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software: Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: A number of schemes have been suggested for generating and maintaining the older-to-younger pointer information needed by generational collectors, including special-purpose hardware support [10, 11] and generation by compilers of the necessary inline code to perform the checks in software <ref> [2] </ref> (adding to the overhead of pointer stores). Ungar [10, 11] uses remembered sets to maintain the necessary information on a per-generation basis, recording the objects in older generations that may contain pointers into the generation.
Reference: [3] <author> A. W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, California, </address> <month> Apr. </month> <year> 1991. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 4 (Apr. </month> <year> 1991). </year>
Reference-contexts: This allows us to determine the optimal performance that could be expected if operating systems were to provide user-level dirty bits (as suggested by Shaw [8], and Appel and Li <ref> [3] </ref>). 2.1 Remembered sets To avoid making the remembered sets too large we record only those stores that create pointers from older objects to younger objects. <p> When a protection trap occurs the bit in the table corresponding to the modified page is set and the page unprotected. 2.3.1 User-level dirty bits If operating systems were to provide user-level dirty bits (as suggested by Shaw [8], and Appel and Li <ref> [3] </ref>), the overhead to reflect page traps through to the user-level protection violation handler can be avoided.
Reference: [4] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year> <pages> Page 7 </pages>
Reference-contexts: compare the performance of several implementations of this hybrid scheme (varying the card size, and using page traps to note updates) with the pure remembered set approach. 2 Implementation Our experiments are based on a high-performance Smalltalk interpreter of our own design, using the abstract definition of Goldberg and Robson <ref> [4] </ref>. The implementation consists of two components: the virtual machine and the virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. While we have retained the standard bytecode instruction set of Goldberg and Robson [4], our implementation <p> and Robson <ref> [4] </ref>. The implementation consists of two components: the virtual machine and the virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. While we have retained the standard bytecode instruction set of Goldberg and Robson [4], our implementation of the virtual machine differs somewhat from their original definition to allow for more efficient execution. Our virtual machine running on the DECstation 3100 performs around three times faster than a microcoded implementation on the Xerox Dorado.
Reference: [5] <author> A. L. Hosking, J. E. B. Moss, and D. Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, Canada, </address> <month> Oct. </month> <year> 1992. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 27, </volume> <month> 10 (Oct. </month> <year> 1992). </year>
Reference-contexts: Note that all writes to a clean page cause a protection trap, not just those that store pointers. The time required to determine the relevant older-to-younger pointers for garbage collection varies with the granularity of the information recorded. In an earlier study <ref> [5] </ref> Page 1 we showed that this is the dominant factor distinguishing different implementations of the write barrier, and that remembered sets offer the best performance because they compactly record just those locations that can possibly contain older-to-younger pointers. <p> The size and frequency of inline checks will affect overhead with respect to a non-garbage collected implementation, but in the absence of contrary evidence, it is reasonable to assume that the relative ranking of the various schemes will remain the same. 6 Discussion Our earlier results <ref> [5] </ref> showed that, despite the more complicated store checks, remembered sets gave best performance overall because of their precise representation of older-to-younger pointers, allowing the scavenge roots to be discovered quickly.
Reference: [6] <author> H. Lieberman and C. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Commun. ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Generational garbage collectors <ref> [6, 10, 11] </ref> achieve short pause times partly because they separate heap-allocated objects into two or more generations and do not process all generations during each collection.
Reference: [7] <author> K. McCall. </author> <title> The Smalltalk-80 benchmarks. </title> <editor> In G. Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 9, </booktitle> <pages> pages 153-173. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The first is a synthetic benchmark of our own devising based on tree creation. The second consists of several iterations through the standard macro benchmark suite that is used to compare the relative performance of Smalltalk implementations <ref> [7] </ref>. Our benchmarks have the following characteristics: * Destroytrees with destructive updates: A large initial tree (~2M bytes) is repeatedly mutated by randomly choosing a subtree to be replaced and fully recreated.
Reference: [8] <author> R. A. Shaw. </author> <title> Improving garbage collector performance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University, </institution> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: This allows us to determine the optimal performance that could be expected if operating systems were to provide user-level dirty bits (as suggested by Shaw <ref> [8] </ref>, and Appel and Li [3]). 2.1 Remembered sets To avoid making the remembered sets too large we record only those stores that create pointers from older objects to younger objects. <p> When a protection trap occurs the bit in the table corresponding to the modified page is set and the page unprotected. 2.3.1 User-level dirty bits If operating systems were to provide user-level dirty bits (as suggested by Shaw <ref> [8] </ref>, and Appel and Li [3]), the overhead to reflect page traps through to the user-level protection violation handler can be avoided.
Reference: [9] <author> P. G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers, 1988. B.S. </title> <type> Thesis, </type> <institution> Dept. of EECS, Massachusetts Institute of Technology, </institution> <address> Cambridge. </address>
Reference-contexts: The heap is divided into aligned logical regions of size 2 k bytesthe address of the first byte in the region will have k low bits zero. These regions are called cards <ref> [9, 12] </ref>. Each card has a corresponding entry in a table indicating whether the card might contain a pointer of interest to the garbage collector. Mapping an address to an entry in the table involves shifting the address right by k bits and using the result to index the table.
Reference: [10] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: 1 Introduction Generational garbage collectors <ref> [6, 10, 11] </ref> achieve short pause times partly because they separate heap-allocated objects into two or more generations and do not process all generations during each collection. <p> This special action constitutes an extra hurdle at every site in the program that might write a pointer into an object, hence the term write barrier. A number of schemes have been suggested for generating and maintaining the older-to-younger pointer information needed by generational collectors, including special-purpose hardware support <ref> [10, 11] </ref> and generation by compilers of the necessary inline code to perform the checks in software [2] (adding to the overhead of pointer stores). Ungar [10, 11] uses remembered sets to maintain the necessary information on a per-generation basis, recording the objects in older generations that may contain pointers into <p> A number of schemes have been suggested for generating and maintaining the older-to-younger pointer information needed by generational collectors, including special-purpose hardware support <ref> [10, 11] </ref> and generation by compilers of the necessary inline code to perform the checks in software [2] (adding to the overhead of pointer stores). Ungar [10, 11] uses remembered sets to maintain the necessary information on a per-generation basis, recording the objects in older generations that may contain pointers into the generation.
Reference: [11] <author> D. M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Generational garbage collectors <ref> [6, 10, 11] </ref> achieve short pause times partly because they separate heap-allocated objects into two or more generations and do not process all generations during each collection. <p> This special action constitutes an extra hurdle at every site in the program that might write a pointer into an object, hence the term write barrier. A number of schemes have been suggested for generating and maintaining the older-to-younger pointer information needed by generational collectors, including special-purpose hardware support <ref> [10, 11] </ref> and generation by compilers of the necessary inline code to perform the checks in software [2] (adding to the overhead of pointer stores). Ungar [10, 11] uses remembered sets to maintain the necessary information on a per-generation basis, recording the objects in older generations that may contain pointers into <p> A number of schemes have been suggested for generating and maintaining the older-to-younger pointer information needed by generational collectors, including special-purpose hardware support <ref> [10, 11] </ref> and generation by compilers of the necessary inline code to perform the checks in software [2] (adding to the overhead of pointer stores). Ungar [10, 11] uses remembered sets to maintain the necessary information on a per-generation basis, recording the objects in older generations that may contain pointers into the generation.
Reference: [12] <author> P. R. Wilson and T. G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> Oct. </month> <year> 1989. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 24, </volume> <month> 10 (Oct. </month> <year> 1989). </year> <pages> Page 8 </pages>
Reference-contexts: The heap is divided into aligned logical regions of size 2 k bytesthe address of the first byte in the region will have k low bits zero. These regions are called cards <ref> [9, 12] </ref>. Each card has a corresponding entry in a table indicating whether the card might contain a pointer of interest to the garbage collector. Mapping an address to an entry in the table involves shifting the address right by k bits and using the result to index the table.
References-found: 12

