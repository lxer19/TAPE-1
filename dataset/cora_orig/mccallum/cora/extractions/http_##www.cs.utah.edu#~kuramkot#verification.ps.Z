URL: http://www.cs.utah.edu/~kuramkot/verification.ps.Z
Refering-URL: http://www.cs.utah.edu/~kuramkot/
Root-URL: 
Title: Case Studies in Symbolic Model Checking  
Author: Ganesh Gopalakrishnan, Dilip Khandekar, Ravi Kuramkote and Ratan Nalumasu 
Date: March 15, 1994  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Pubnum: UUCS-94-009  
Abstract: Formal verification of hardware and software systems has long been recognized as an essential step in the development process of a system. It is of importance especially in concurrent systems that are more difficult to debug than sequential systems. Tools that are powerful enough to verify real-life systems have become available recently. Model checking tools have become quite popular because of their ability to carry out proofs with minimal human intervention. In this paper we report our experience with SMV, a symbolic model verifier on practical problems of significant sizes. We present verification of a software system, a distributed shared memory protocol, and a hardware system, the crossbar arbiter. We discuss modeling of these systems in SMV and their verification using temporal logic CTL queries. We also describe the problems encountered in tackling these examples and suggest possible solutions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year> <month> [2] </month> <year> 1992. </year> <title> Tutorial #9 on Formal Verification offered during the 1992 DAC by Edmund Clarke et. </title> <publisher> al. </publisher>
Reference-contexts: Second, most concurrent hardware and software systems are one-ofs, and hence it is very difficult to recoup human effort put into one project for use in another. In this paper, we report on our experience in using SMV <ref> [1] </ref>, a symbolic model checker, in a graduate class on Program Verification, on practical problems of significant sizes. SMV has previously been extensively used by several researchers [1, 2] in verifying non-trivial hardware and software systems. <p> In this paper, we report on our experience in using SMV [1], a symbolic model checker, in a graduate class on Program Verification, on practical problems of significant sizes. SMV has previously been extensively used by several researchers <ref> [1, 2] </ref> in verifying non-trivial hardware and software systems. In this paper we present the following case studies: (i) verification of a distributed shared memory protocol [3] that is widely known; (ii) verification of a new crossbar arbiter that the first author's group has developed. <p> We feel that the practical applicability of SMV can be greatly enhanced if the system offers users with sufficient insight into the problem being modeled, what might be causing the state explosion, and also help him/her determine a suitable variable ordering. Work done in <ref> [1] </ref> and [7] relating to the complexity characteristics of BDDs should help in this regard. 2.3.1 The First Deadlock The first deadlock situation detected by SMV is the following. <p> An informal ("paper and pencil") inductive proof of correctness for arbitrary sizes is easy to provide. Carrying out induction in the framework of SMV (through the use of a suitable network invariant <ref> [1] </ref>) is presently being looked into. 4.2 Details of the Crossbar Arbiter and its Verification The wavefront arbiter was specified at the structural level. Each cell contains an XOR gate and a LockC gate. <p> This was observed in our inability to verify arbiters of sizes higher than 3x3. Application of induction techniques to the arbiter circuit ended to be not so straightforward as the examples dealt with in <ref> [1] </ref>. The main idea used in [1] is to identify a network invariant and then to design a generic module that can simulate an arbitrary number of the modules in the original design. <p> This was observed in our inability to verify arbiters of sizes higher than 3x3. Application of induction techniques to the arbiter circuit ended to be not so straightforward as the examples dealt with in <ref> [1] </ref>. The main idea used in [1] is to identify a network invariant and then to design a generic module that can simulate an arbitrary number of the modules in the original design.
Reference: [3] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: SMV has previously been extensively used by several researchers [1, 2] in verifying non-trivial hardware and software systems. In this paper we present the following case studies: (i) verification of a distributed shared memory protocol <ref> [3] </ref> that is widely known; (ii) verification of a new crossbar arbiter that the first author's group has developed. We also discuss the problems encountered while tackling these examples using SMV, and suggest possible solutions. <p> The remainder of the paper is organized as follows. In Section 2 we discuss the verification of the centralized version of the distributed shared memory (DSM) protocol <ref> [3] </ref>. Section 3 presents the verification of a distributed version of the same protocol. This widely used protocol implements a demand-paged virtual memory system across a collection of computing nodes (Figure 1). <p> Both the centralized and the distributed DSM protocols described in this paper are widely referred to, and form the basis of several new protocols of a similar nature, for example [4, 5]. Descriptions of these protocols were taken verbatim, in the form of pseudo-code, from <ref> [3] </ref>, and encoded in SMV. Admittedly this is a less than perfect process, because pseudo-code descriptions can be ambiguous and therefore can be mis-interpreted. <p> Also, we do not have access to the final implementation of the algorithms of <ref> [3] </ref>; therefore, remarks regarding correctness made in this paper apply only to the pseudo-code. In Section 4, we present the verification of a symmetric crossbar arbiter|an asynchronous arbiter described in [6]. This example provides useful insight into asynchronous circuit verification using SMV. <p> These servers handle remote requests as elaborated in Section 2.2. 2.1 Overview of the Results Our main result concerning the verification of the centralized protocol is summarized before we go into the details. The pseudo-code appearing in <ref> [3] </ref> is scanty in detail about certain boundary cases. If special care is not taken in modeling these boundary cases, deadlocks will result. We were satisfied that this observation was confirmed by SMV, as detailed in Section 2. <p> Several solutions are possible and we have not pursued any particular solution, as that was not the purpose of our exercise. 3 Shared Virtual Memory: Distributed Manager The verification of the dynamic distributed manager (DDM) algorithm proposed in <ref> [3] </ref> is detailed in this section. In the DDM, there is no centralized manager. Every node has sufficient information to locate the required page. The nodes use message passing mechanism to communicate with each other. A page has three modes associated with it: invalid, read, and write.
Reference: [4] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: This widely used protocol implements a demand-paged virtual memory system across a collection of computing nodes (Figure 1). Both the centralized and the distributed DSM protocols described in this paper are widely referred to, and form the basis of several new protocols of a similar nature, for example <ref> [4, 5] </ref>. Descriptions of these protocols were taken verbatim, in the form of pseudo-code, from [3], and encoded in SMV. Admittedly this is a less than perfect process, because pseudo-code descriptions can be ambiguous and therefore can be mis-interpreted.
Reference: [5] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related communication in distributed shared memory systems. </title> <journal> ACM transactions on Computer Systems, </journal> <month> August </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: This widely used protocol implements a demand-paged virtual memory system across a collection of computing nodes (Figure 1). Both the centralized and the distributed DSM protocols described in this paper are widely referred to, and form the basis of several new protocols of a similar nature, for example <ref> [4, 5] </ref>. Descriptions of these protocols were taken verbatim, in the form of pseudo-code, from [3], and encoded in SMV. Admittedly this is a less than perfect process, because pseudo-code descriptions can be ambiguous and therefore can be mis-interpreted.
Reference: [6] <author> Ganesh Gopalakrishnan. </author> <title> Some unusual micropipeline circuits. </title> <type> Technical Report UUCS-93-015, </type> <institution> University of Utah, Department of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: Also, we do not have access to the final implementation of the algorithms of [3]; therefore, remarks regarding correctness made in this paper apply only to the pseudo-code. In Section 4, we present the verification of a symmetric crossbar arbiter|an asynchronous arbiter described in <ref> [6] </ref>. This example provides useful insight into asynchronous circuit verification using SMV. We provide concluding remarks in Section 5. 2 Shared Virtual Memory: Centralized Manager Consider a collection of computer nodes, each supporting one or more processes. <p> In response to any such request, the arbiter must grant the maximum possible number of requests (at most N ) that do not conflict on any row or column (i.e., that do not share any row- or column-wire of the crossbar). In <ref> [6] </ref>, we have developed a family of arbiters that meet the above specifications. As opposed to the circuits used by [8], our circuits are all asynchronous in nature. Furthermore, they are based on a new asynchronous component developed by the first author called the lockable C-element [9].
Reference: [7] <author> Alan Hu and David Dill. </author> <title> Reducing bdd size by exploiting functional dependencies. </title> <booktitle> In Proceedings of the 30th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 266-271, </pages> <year> 1993. </year>
Reference-contexts: We feel that the practical applicability of SMV can be greatly enhanced if the system offers users with sufficient insight into the problem being modeled, what might be causing the state explosion, and also help him/her determine a suitable variable ordering. Work done in [1] and <ref> [7] </ref> relating to the complexity characteristics of BDDs should help in this regard. 2.3.1 The First Deadlock The first deadlock situation detected by SMV is the following.
Reference: [8] <author> Yuval Tamir and Hsin-Chou Chi. </author> <title> Symmetric crossbar arbitration. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(1) </volume> <pages> 13-27, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The use of model checking tools such as SMV early in the design process can prevent this from happening. 4 Hardware Verification: Verification of a Crossbar Arbiter A symmetric crossbar arbiter <ref> [8] </ref> arbitrates requests for connections to be made on an N fi N crossbar switch. Assume that at any particular instant of time, a subset the N 2 switches can be requested to be closed. <p> In [6], we have developed a family of arbiters that meet the above specifications. As opposed to the circuits used by <ref> [8] </ref>, our circuits are all asynchronous in nature. Furthermore, they are based on a new asynchronous component developed by the first author called the lockable C-element [9]. We illustrate our verification efforts on one of these circuits given in Figure 3, called the wavefront arbiter.
Reference: [9] <author> Armin Liebchen and Ganesh Gopalakrishnan. </author> <title> Dynamic reordering of high latency transactions in time-warp simulation using a modified micropipeline. </title> <booktitle> In International Conference on Computer Design (ICCD), </booktitle> <pages> pages 336-340, </pages> <year> 1992. </year>
Reference-contexts: In [6], we have developed a family of arbiters that meet the above specifications. As opposed to the circuits used by [8], our circuits are all asynchronous in nature. Furthermore, they are based on a new asynchronous component developed by the first author called the lockable C-element <ref> [9] </ref>. We illustrate our verification efforts on one of these circuits given in Figure 3, called the wavefront arbiter. The operation of the wavefront arbiter is as follows. Each element shown in the figure is a lockable C-element|or, LockC for short.
Reference: [10] <author> Jerry Burch. </author> <title> Trace Algebra for Automatic Verification of Real-Time Concurrent Systems. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> August </month> <year> 1992. </year> <note> Technical Report CMU-CS-92-179. </note>
Reference-contexts: The circuits used to realize our crossbar arbiters require certain one-sided timing constraints to be obeyed in their implementation. Although these timing constraints can be encoded in SMV, we believe that other formalisms (e.g., <ref> [10, 11, 12] </ref>) may be more suitable for this level of verification. In conclusion, we are pleased with how SMV has fared in our hardware and software verification experiments. Coding styles that will prevent state explosion from occurring must be developed and discussed.
Reference: [11] <author> David L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year> <note> An ACM Distinguished Dissertation. </note>
Reference-contexts: The circuits used to realize our crossbar arbiters require certain one-sided timing constraints to be obeyed in their implementation. Although these timing constraints can be encoded in SMV, we believe that other formalisms (e.g., <ref> [10, 11, 12] </ref>) may be more suitable for this level of verification. In conclusion, we are pleased with how SMV has fared in our hardware and software verification experiments. Coding styles that will prevent state explosion from occurring must be developed and discussed.
Reference: [12] <author> Ganesh Gopalakrishnan, Nick Michell, Erik Brunvand, and Steven M. Nowick. </author> <title> A correctness criterion for asynchronous circuit verification and optimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <note> 1992. Accepted for Publication. </note>
Reference-contexts: The circuits used to realize our crossbar arbiters require certain one-sided timing constraints to be obeyed in their implementation. Although these timing constraints can be encoded in SMV, we believe that other formalisms (e.g., <ref> [10, 11, 12] </ref>) may be more suitable for this level of verification. In conclusion, we are pleased with how SMV has fared in our hardware and software verification experiments. Coding styles that will prevent state explosion from occurring must be developed and discussed.
Reference: [13] <author> Charles P. Thacker, David G. Conroy, and Lawrence C. Stewart. </author> <title> The alpha demonstration unit: A high-performance multiprocessor. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 55-66, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: The SMV system must also provide insight to the user on the source of state explosion and provide better insight into its operation. The examples discussed in this paper, a few other examples (including the description and validation of the Cache Coherence protocol obeyed by the Alpha Demonstration Unit <ref> [13] </ref> written by Yarden Livnat), and the code of Petriland are available upon request from ganesh@cs.utah.edu. Acknowledgements: Many thanks to all the students who participated in CS 611, "Program Verification" whose efforts made these experiments possible, and to NSF who supported this work in part through award MIP-9215878.
References-found: 12

