URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-195.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: landi@cadillac.siemens.com  ryder@cs.rutgers.edu xxzhang@cs.rutgers.edu  
Title: Interprocedural Modification Side Effect Analysis With Pointer Aliasing  
Author: William Landi Barbara G. Ryder Sean Zhang 
Address: 755 College Rd. East Princeton, NJ 08540  New Brunswick, NJ 08903  
Affiliation: Siemens Corporate Research Inc  Department of Computer Science Rutgers University Hill Center, Busch Campus  
Abstract: We present a new interprocedural modification side effects algorithm for C programs, that can discern side effects through general-purpose pointer usage. Ours is the first complete design and implementation of such an algorithm. Preliminary performance findings support the practicality of the technique, which is based on our previous approximation algorithm for pointer aliases [LR92]. Each indirect store through a pointer variable is found, on average, to correspond to a store into 1.1 locations. This indicates that our program-point-specific pointer aliasing information is quite precise when used to determine the effects of these stores.
Abstract-found: 1
Intro-found: 1
Reference: [All74] <author> F. E. Allen. </author> <title> Interprocedural data flow analysis. </title> <booktitle> In Proceedings of 1974 IFIP Congress, </booktitle> <pages> pages 398-402, </pages> <address> Amsterdam, Holland, 1974. </address> <publisher> Institute of Electrical and Electronics Engineers, Inc., North Holland Publishing Company. </publisher>
Reference-contexts: Existing techniques for Fortran can not supply this information; they only handle call-by-reference induced aliasing and are insufficient for languages with general-purpose pointer usage. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78].
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization <ref> [ASU86] </ref>, practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Ban79] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs [All74, Spi71]. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78]. Banning <ref> [Ban79] </ref> first noted the decomposition of the problem for Fortran (and other fl The research reported here was supported, in part, by Siemens Corporate Research and NSF grants CISE-CCR 92-08632 and CCR-9023628 1/5. languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow insensitive calculations on
Reference: [Ban88] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs [All74, Spi71]. Later, Barth explored the use of relations to capture side effects in recursive programs <ref> [Bar78] </ref>.
Reference: [BC86] <author> M. Burke and R. Cytron. </author> <title> Interprocedural depenodence analysis and parallelization. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 21, No 6. </volume>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Cooper and Kennedy [Coo85, CK84, CK87] further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition <ref> [Bur90] </ref>. Choi, Burke, and Carini mention a modification side effects algorithm for languages with pointers based on their flow insensitive pointer aliasing calculation [CBC93]; it is difficult to compare our work to theirs, because they give no description of their algorithm.
Reference: [CBC93] <author> Jong-Doek Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <month> January </month> <year> 1993. </year> <booktitle> to appear in Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90]. Choi, Burke, and Carini mention a modification side effects algorithm for languages with pointers based on their flow insensitive pointer aliasing calculation <ref> [CBC93] </ref>; it is difficult to compare our work to theirs, because they give no description of their algorithm. Clearly, the importance of work in this area must be judged by algorithm performance in practice, in terms of precision and resource needs. <p> In [LR92], we safely restrict the size of the alias sets (RA) to one, yielding a compact and effective encoding of the run-time stack. 4 Choi et. al. <ref> [CBC93] </ref> also use alias sets, called source alias sets, as part of their encoding of the run-time stack in their flow sensitive aliasing algorithm, but do not restrict the set size. It will be interesting to see what effects this has on precision and performance of their algorithm in practice.
Reference: [CK84] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: Cooper and Kennedy <ref> [Coo85, CK84, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [CK87] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <institution> Computer Science Department Technical Report TR87-61, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: Cooper and Kennedy <ref> [Coo85, CK84, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90]. <p> The function b call Q , specific to the call call Q , maps names from the called procedure (Q) to the calling procedure (P ) according to scoping rules <ref> [CK87] </ref> 9 . call (call Q ; RA) represents the set of reaching aliases at the entry of Q induced by the parameter bindings and aliases at call Q given RA reached the entry of P . (b call Q and call will be discussed in more detail in the full
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Cooper and Kennedy <ref> [Coo85, CK84, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year> <month> 11 </month>
Reference-contexts: Section 5 summarizes the contributions of this work. Appendix A gives an example of our analysis. 2 Pointer Aliasing Analysis Iterative data flow analysis is a fixed point calculation for recursive equations defined on a graph representing a program, that safely approximates the meet over all paths solution <ref> [Hec77] </ref> for the graph. For interprocedural data flow, not all paths in the obvious graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it [LR92].
Reference: [HRB88] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need a efficient method to report program-point-specific data flow information for these applications.
Reference: [JM82] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Paths on which a procedure does not return to the call site which invoked it, are unrealizable and can never happen in an actual execution. A fundamental problem of interprocedural analysis is how to restrict the propagation of data flow information to realizable paths. Jones and Muchnick <ref> [JM82] </ref> give a general approach for handling this problem for abstract interpretations, which is also valid for data flow analysis. They associate with each data flow fact, an abstraction of the run-time stack on paths on which the fact is created.
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This abstraction, cre ated at procedure entry, is used at procedure exit to determine to which call site (s), the data flow information should be propagated. Our conditional aliasing approach <ref> [LR91, LR92] </ref> can be seen as an application of this idea. The data flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> created at the same site. 3 Ignoring parameter bindings, this is simply RA alias solution at call site. 4 Use of this encoding yields a precise solution for aliasing in the presence of one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution for aliasing <ref> [LR91, LR92] </ref>. 5 In [LR92], we used may-holds to represent conditional aliasing information.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Our algorithm reports program-point specific possible modification side effects (i.e., MOD); our results are more precise than information derivable using the same alias summary for all statements of a procedure. Our algorithm is based on an initial interprocedural pass that computes a flow sensitive approximation of program-point-specific pointer-induced aliases <ref> [LR92] </ref>. These are used to gather procedure summary modification information, with subsequent flow insensitive propagation of modifications through the program call multigraph. Finally, call site modification information is calculated using the results of the procedure side effects summary. <p> Finally, call site modification information is calculated using the results of the procedure side effects summary. We have implemented our MOD algorithm as a back-end analysis on our pointer aliasing implementation <ref> [LR92] </ref>. Initial experiments have been run with ten of the programs which appeared in [LR92]. <p> Finally, call site modification information is calculated using the results of the procedure side effects summary. We have implemented our MOD algorithm as a back-end analysis on our pointer aliasing implementation <ref> [LR92] </ref>. Initial experiments have been run with ten of the programs which appeared in [LR92]. <p> and not-visible (within that procedure). 1 Measurements of average and maximum number of side effects found per procedure, per call site, and per assignment statement (i.e., flp =) have been made, as well as calculations of analysis times and the relative extra cost imposed by using our conditional analysis technique <ref> [LR92] </ref>. Most importantly, our results over the ten programs show that on average 1.1 locations are assigned values per assignment statement, indicating that often there is only one alias for a deref 1 Not-visibles are local variables of other procedures or an earlier instantiation of the current procedure [LR92]. 2 erenced <p> analysis technique <ref> [LR92] </ref>. Most importantly, our results over the ten programs show that on average 1.1 locations are assigned values per assignment statement, indicating that often there is only one alias for a deref 1 Not-visibles are local variables of other procedures or an earlier instantiation of the current procedure [LR92]. 2 erenced pointer variable at a program point (i.e., flp =). <p> For interprocedural data flow, not all paths in the obvious graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [LR92] </ref>. Paths on which a procedure does not return to the call site which invoked it, are unrealizable and can never happen in an actual execution. A fundamental problem of interprocedural analysis is how to restrict the propagation of data flow information to realizable paths. <p> This abstraction, cre ated at procedure entry, is used at procedure exit to determine to which call site (s), the data flow information should be propagated. Our conditional aliasing approach <ref> [LR91, LR92] </ref> can be seen as an application of this idea. The data flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> Our encoding of the run-time stack is the set of reaching aliases 2 (RA) that exists at entry of procedure p containing n when p is invoked. RA can be used to determine to which call sites, aliases should be propagated. Details can be found in <ref> [LR92] </ref>, but at a high level: 2 Reaching aliases were referred to in [LR92] by the term assumed aliases. 3 If the alias solution at a call site (C) is sufficient to create RA at entry of the called procedure, 3 then any alias associated with RA at the exit of <p> RA can be used to determine to which call sites, aliases should be propagated. Details can be found in <ref> [LR92] </ref>, but at a high level: 2 Reaching aliases were referred to in [LR92] by the term assumed aliases. 3 If the alias solution at a call site (C) is sufficient to create RA at entry of the called procedure, 3 then any alias associated with RA at the exit of the called procedure is valid at C. In [LR92], we safely restrict the <p> were referred to in <ref> [LR92] </ref> by the term assumed aliases. 3 If the alias solution at a call site (C) is sufficient to create RA at entry of the called procedure, 3 then any alias associated with RA at the exit of the called procedure is valid at C. In [LR92], we safely restrict the size of the alias sets (RA) to one, yielding a compact and effective encoding of the run-time stack. 4 Choi et. al. [CBC93] also use alias sets, called source alias sets, as part of their encoding of the run-time stack in their flow sensitive aliasing algorithm, <p> In this paper, we use our abstraction, reaching alias sets of size one. Calias (n; RA) represents the set of may aliases at program point n for reaching alias RA, obtained by our approximation alias algorithm <ref> [LR92] </ref> 5 . 3 Decomposition of the MOD problem We are solving for MOD (s), the set of variables possibly modified by execution of the statement at program point s. To elaborate on our approach, first we solve the conditional aliasing prob lem. <p> created at the same site. 3 Ignoring parameter bindings, this is simply RA alias solution at call site. 4 Use of this encoding yields a precise solution for aliasing in the presence of one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution for aliasing <ref> [LR91, LR92] </ref>. 5 In [LR92], we used may-holds to represent conditional aliasing information. <p> site. 3 Ignoring parameter bindings, this is simply RA alias solution at call site. 4 Use of this encoding yields a precise solution for aliasing in the presence of one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution for aliasing [LR91, LR92]. 5 In <ref> [LR92] </ref>, we used may-holds to represent conditional aliasing information. <p> MOD (n) = reaching alias RA for P CMOD (n; RA) MOD (P ) = reaching alias RA for P PMOD (P; RA) The precision of our MOD solution depends largely on the precision of the underlying alias analysis. Furthermore, when the alias algorithm is safe (i.e., erring conservatively <ref> [LR92] </ref>), our MOD decomposition is also safe. <p> over sets of fixed-locations. (This will be elaborated further in the full paper.) ALIAS DIRMOD (n) MOD (P) CMOD (n, RA) PMOD (P, RA) CondIMOD (P, RA) CondLMOD (n, RA) 4 Empirical Results We have implemented our MOD decomposition and have empirical results for ten of the programs analyzed in <ref> [LR92] </ref>. Our implementation is written in C and analyzes a reduced version of C that excludes: union types, casting 10 , pointers to functions, and exception handling. <p> In general, the MOD times are an order of magnitude smaller then the alias times. Because of several implementation optimizations, the alias times reported here are better than those we reported in <ref> [LR92] </ref>, even with our addition of more sophisticated tracking of dynamic storage. <p> The tot column of average/assign contains mostly 1.0s and a maximum value of 1.3. This indicates that our algorithm is highly precise. (In the full paper, we will present empirical evidence on the precision of our calculation in the manner we did for our aliasing algorithm <ref> [LR92] </ref>.) Average percent/assign indicates how much more precision is obtained from our MOD calculation in comparison to using the worst-case assumption that all fixed-locations are modified. The tot column runs from 1% to 9% indicating that it is worth doing our MOD calculation. <p> Our algorithm is based on our conditional analysis approach, that already has been used successfully in the approximation of pointer-induced aliases <ref> [LR92] </ref> and interprocedural reaching definitions [PRL91, PLR92]. Preliminary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need a efficient method to report program-point-specific data flow information for these applications.
Reference: [OW91] <author> T. J. Ostrand and E. Weyuker. </author> <title> Data flow based test adequecy analysis for languages with pointers. </title> <booktitle> In Proceedings of the 1991 Symposium on Software Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year> <institution> Victoria, B.C., Canada. </institution>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing <ref> [RW82, OW91] </ref>, incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [PLR92] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural def-use associations in the presence of single level pointers. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-193, Department of Computer Science, Rutgers University, </institution> <year> 1992. </year> <note> submitted for publication. </note>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations <ref> [PRL91, PLR92] </ref> and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. <p> Our algorithm is based on our conditional analysis approach, that already has been used successfully in the approximation of pointer-induced aliases [LR92] and interprocedural reaching definitions <ref> [PRL91, PLR92] </ref>. Preliminary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [PRL91] <author> H. Pande, B. G. Ryder, and W. Landi. </author> <title> Interprocedural def-use associations for C programs. </title> <booktitle> In Proceedings of the ACM SIGSOFT Conference on Testing, Analysis and Validation, </booktitle> <pages> pages 139-153, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations <ref> [PRL91, PLR92] </ref> and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. <p> Our algorithm is based on our conditional analysis approach, that already has been used successfully in the approximation of pointer-induced aliases [LR92] and interprocedural reaching definitions <ref> [PRL91, PLR92] </ref>. Preliminary results from our prototype implementation indicate that our algorithm is practical, efficient and quite accurate. Future work includes broadening the class of C programs handled by our prototype, making our algorithms incremental, and scaling up to handle large C systems.
Reference: [RM88] <author> C. Ruggieri and T. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: In our analyses, we report modifications to fixed-locations; these are either user-defined variable names or heap storage creation site names. For example in C syntax, x and x:f are fixed-locations whereas flp and p -&gt;f are not. We have named each dynamic allocation site, similar to <ref> [RM88] </ref>.
Reference: [RW82] <author> S. Rapps and E. Weyuker. </author> <title> Data flow analysis techniques for program test data selection. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering, </booktitle> <pages> pages 272-278, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing <ref> [RW82, OW91] </ref>, incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
Reference: [Ryd89] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software <ref> [Ryd89] </ref>, interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84]. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them.
Reference: [Spi71] <author> T. Spillman. </author> <title> Exposing side effects in a PL-I optimizing compiler. </title> <booktitle> In Proceedings of IFIPS Conference, </booktitle> <pages> pages TA-3-56:TA-3-62, </pages> <year> 1971. </year>
Reference-contexts: Existing techniques for Fortran can not supply this information; they only handle call-by-reference induced aliasing and are insufficient for languages with general-purpose pointer usage. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78].
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need a efficient method to report program-point-specific data flow information for these applications.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls [Ban88, BC86, Wol89], data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing <ref> [HRB88, OO84, Ven91, Wei84] </ref>. These are key problems in parallel and sequential programming environments; the utility of tools to solve these problems is directly dependent on the accuracy of the data flow information available to them. We need a efficient method to report program-point-specific data flow information for these applications.
Reference: [Wol89] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure calls <ref> [Ban88, BC86, Wol89] </ref>, data-flow based testing [RW82, OW91], incremental semantic change anal ysis of software [Ryd89], interprocedural def-use relations [PRL91, PLR92] and effective static interprocedural program slicing [HRB88, OO84, Ven91, Wei84].
References-found: 27

