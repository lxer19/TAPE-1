URL: http://www.cs.rutgers.edu/~ellman/kbse96.ps
Refering-URL: http://www.cs.rutgers.edu/~ellman/ellman-publications.html
Root-URL: 
Email: ellman@cs.rutgers.edu murata@cs.rutgers.edu  
Title: Deductive Synthesis of Numerical Simulation Programs from Networks of Algebraic and Ordinary Differential Equations  
Author: Thomas Ellman Takahiro Murata 
Address: New Brunswick, NJ 08855 New Brunswick, NJ 08855  
Affiliation: Department of Computer Science Department of Computer Science Rutgers University Rutgers University  
Abstract: Computational science and engineering design can benefit from software tools that facilitate construction of programs for simulating physical systems. Our research adapts the methodology of deductive program synthesis to the problem of synthesizing numerical simulation codes. We have focused on simulators that can be represented as second-order functional programs composed of numerical integration and root-extraction routines. Synthesis of second-order programs appears to present a problem for deductive systems that operate in first order logic. We present a recursive synthesis algorithm that overcomes this difficulty for a class of program synthesis problems. Our system has successfully constructed numerical simulators for computational design of jet-engine nozzles and sailing yachts, among others. 
Abstract-found: 1
Intro-found: 1
Reference: [ Constable, 1986 ] <author> R. L. et al. Constable. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: Another possibility would be to utilize a higher order logic. Finally, entirely different approaches to program synthesis may be considered, for example, a methodology based on specification morphisms [ Smith, 1993 ] or constructive type theory <ref> [ Constable, 1986 ] </ref> .
Reference: [ Ellman et al., 1993 ] <author> T. Ellman, J. Keane, and M. Schwabacher. </author> <title> Intelligent model selection for hill-climbing search in computer-aided design. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <address> Washington, D.C., </address> <year> 1993. </year>
Reference-contexts: A wide variety of systems can be modeled as networks of algebraic and ordinary differential equations. Examples include an aircraft simulator for computational design of jet-engine nozzles; [ Gelsey et al., 1996 ] a sailing yacht simulator for computational design of hull geometries <ref> [ Ellman et al., 1993 ] </ref> ; and a planetary scientist's model of the atmosphere of the moon Titan [ Keller et al., 1994 ] , among others. Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines.
Reference: [ Ellman et al., 1995 ] <author> T. Ell-man, J. Keane, M. Schwabacher, and T. Murata. </author> <title> A transformation system for interactive reformulation of design optimization strategies. </title> <booktitle> In Proceedings of the Tenth Knowledge-Based Software Engineering Conference, </booktitle> <address> Boston, MA, </address> <year> 1995. </year>
Reference-contexts: The catalog includes transforms for solving equations symbolically, selecting numerical methods or tolerance parameters, approximating functions and reformulating design parameter spaces, among others. The transformation system used in this stage was previously reported in <ref> [ Ellman et al., 1995 ] </ref> . At present, both the deductive synthesis system and the transformation system are implemented. The graphical interface for interacting with the transformation system is also implemented; however, the graphical interface for constructing the initial constraint network is not yet implemented. <p> The back-end translates PROLOG terms into LISP expressions and rewrites some function calls into a more readable keyword-oriented syntax. It also introduces variables representing seeds needed by the numeric root extraction functions. This LISP function has a form that is amenable to transformation using the tools described in <ref> [ Ellman et al., 1995 ] </ref> , e.g., transformations that use symbolic algebra to replace numeric root-extraction expressions with closed-form solutions. Insight into the behavior of our program synthesis algorithm may be gained by examining the hierarchic structure of the simple aircraft simulation program.
Reference: [ Gelsey et al., 1996 ] <author> Andrew Gelsey, Don Smith, Mark Schwabacher, Khaled Rasheed, and Keith Miyake. </author> <title> A search space toolkit. Decision Support Systems, </title> <note> special issue on Unification of Artificial Intelligence with Optimization, 1996. To appear. </note>
Reference-contexts: This unfortunate situation appears not to be inevitable. A wide variety of systems can be modeled as networks of algebraic and ordinary differential equations. Examples include an aircraft simulator for computational design of jet-engine nozzles; <ref> [ Gelsey et al., 1996 ] </ref> a sailing yacht simulator for computational design of hull geometries [ Ellman et al., 1993 ] ; and a planetary scientist's model of the atmosphere of the moon Titan [ Keller et al., 1994 ] , among others. <p> An example of such a system is described informally in Figure 1. This example is a simplified version of an aircraft simulation problem used in research on design of jet-engine nozzles <ref> [ Gelsey et al., 1996 ] </ref> . The required simulator takes as input the size n of the nozzle, the empty mass m e of the aircraft, and the velocity v and duration d of a flight.
Reference: [ Kant, 1993 ] <author> E. Kant. </author> <title> Synthesis of mathematical modeling software. </title> <journal> IEEE Software, </journal> <pages> pages 30-41, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Nevertheless, Amphion is not immediately applicable to our class of problems because it does not provide facilities for reasoning about differential equations. Our research may be seen as an approach to extending a system like Am-phion in order to handle such problems. The Synapse system <ref> [ Kant, 1993 ] </ref> constructs finite element codes for simulating systems governed by partial differential equations, a class of problems that is distinct from the one we have attacked.
Reference: [ Keane, 1996 ] <author> J. Keane. </author> <title> Extensions to the franz, inc.'s allegro common lisp foreign function interface. </title> <type> Technical Report HPCD-TR-41, </type> <institution> Department of Computer Science, Rutgers University, </institution> <year> 1996. </year>
Reference-contexts: The integral and root functions are implemented in a run-time system. The implementation is composed of C routines taken from [ Press et al., 1986 ] . The C routines are wrapped by LISP functions providing the interfaces described above <ref> [ Keane, 1996 ] </ref> . The integral function is computed using a fourth-order Runge-Kutta method. The root function is computed using the Newton-Raphson method. An example (in PROLOG syntax) of a program in our implementation language is shown in Figure 8.
Reference: [ Keller et al., 1994 ] <author> R. Keller, M. Rimon, and A. Das. </author> <title> A knowledge-based prototyping environment for construction of scientific modeling software. </title> <journal> Automated Software Engineering, </journal> <volume> 1 </volume> <pages> 79-128, </pages> <year> 1994. </year>
Reference-contexts: Examples include an aircraft simulator for computational design of jet-engine nozzles; [ Gelsey et al., 1996 ] a sailing yacht simulator for computational design of hull geometries [ Ellman et al., 1993 ] ; and a planetary scientist's model of the atmosphere of the moon Titan <ref> [ Keller et al., 1994 ] </ref> , among others. Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines. Libraries of such generic numerical tools are now widely available [ Press et al., 1986 ] . <p> In any case, a more complete diagnosis of the difficulty awaits further investigation. 4 Related Work Our research was originally motivated by difficulties encountered in attempting to apply the SIGMA scientific modeling system <ref> [ Keller et al., 1994 ] </ref> to the task of constructing numerical simulators for automated op Inputs: A point in time: t. Output: The state (x 1 (t); : : : ; x n (t)) of the system at time t.
Reference: [ Lowry et al., 1994 ] <author> M. Lowry, A. Philpot, T. Press-berger, and I. Underwood. </author> <title> A formal approach to domain-oriented software design environments. </title> <booktitle> In Proceedings of the Ninth Knowledge-Based Software Engineering Conference, </booktitle> <address> Monterey, CA, </address> <note> 1994. </note> [ <author> Manna and Waldinger, 1992 ] Z. Manna and R. Waldinger. </author> <title> Fundamentals of deductive program synthesis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 674-705, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: The solution was to split the representation into two parts. A network of algebraic and differential equations represents specifications. A second-order data-flow language represents executable models. Our deductive synthesis system provides a mapping between these two levels of representation. The Amphion system <ref> [ Lowry et al., 1994 ] </ref> is similar to the system we have described here. Amphion takes as input a problem specification in the form of a network of relationships among quantities and objects to be modeled. The network is provided by the user via a graphical user interface.
Reference: [ Matlab, 1992 ] <author> MATLAB: </author> <title> High Performance Numerical Computation and Visualization Software. The Math Works, </title> <publisher> Inc., </publisher> <address> Natick, MA, </address> <year> 1992. </year>
Reference-contexts: The Synapse system [ Kant, 1993 ] constructs finite element codes for simulating systems governed by partial differential equations, a class of problems that is distinct from the one we have attacked. Commercial mathematical toolkits, such as Matlab <ref> [ Matlab, 1992 ] </ref> provide tools for integrating dynamic systems; however, Matlab's tools require that the system derivatives be given explicitly in closed form.
Reference: [ Press et al., 1986 ] <author> W. Press, B. Flannery, S. Teukol-sky, and W. Vetterling. </author> <title> Numerical Recipes. </title> <publisher> Cam-bridge University Press, </publisher> <address> New York, NY, </address> <year> 1986. </year>
Reference-contexts: Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines. Libraries of such generic numerical tools are now widely available <ref> [ Press et al., 1986 ] </ref> . They are under-utilized because of the difficulty of bridging the gap between equations the language with which scientists and engineers are familiar and the facilities provided by numerical tool libraries. <p> It returns a list of values that represents the simultaneous root of the functions defined by the lambda expressions. The integral and root functions are implemented in a run-time system. The implementation is composed of C routines taken from <ref> [ Press et al., 1986 ] </ref> . The C routines are wrapped by LISP functions providing the interfaces described above [ Keane, 1996 ] . The integral function is computed using a fourth-order Runge-Kutta method. The root function is computed using the Newton-Raphson method. <p> Each synthesized program was translated into LISP by our back-end translator, and compiled and executed on test examples. Each program was verified to give qualitatively correct numerical results; however, detailed numerical validation was not attempted. We had hoped our system would synthesize a "shooting method" <ref> [ Press et al., 1986 ] </ref> for solving arbitrary boundary value problems. A general description of such problems is shown in Figure 10. We tested this hypothesis on a synthetic boundary-value problem involving a two dimensional dynamic system.
Reference: [ Smith, 1993 ] <author> D. Smith. </author> <title> Constructing specification morphisms. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 16, </volume> <year> 1993. </year>
Reference-contexts: One possibility would be to continue with deductive synthesis, but to go beyond horn logic to first order logic with equality. Another possibility would be to utilize a higher order logic. Finally, entirely different approaches to program synthesis may be considered, for example, a methodology based on specification morphisms <ref> [ Smith, 1993 ] </ref> or constructive type theory [ Constable, 1986 ] .
References-found: 11

