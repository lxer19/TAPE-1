URL: ftp://ftp.cl.cam.ac.uk/ml/cant-ozols.ps.gz
Refering-URL: ftp://ftp.cl.cam.ac.uk/ml/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: cant,maris@itd.dsto.oz.au  
Title: A Verification Environment for ML Programs  
Author: A. Cant and M. A. Ozols 
Address: PO Box 1500 SALISBURY 5108 SOUTH AUSTRALIA  
Affiliation: Information Technology Division Defence Science and Technology Organisation  
Abstract: A verification environment for Standard ML programs is described. The system is constructed within the Isabelle theorem prover, directly from the operational semantics definition of F, the functional subset of the Core of SML. Both the static and the dynamic semantics of F are incorporated. Simple proof procedures can prove F programs correct by inferring the result of evaluation or elaboration demanded by the Definition. The work will benefit those trying to understand the Definition of SML, and experts who wish to explore possible modifications and extensions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In this paper we report on progress towards the construction of a verification environment for reasoning about ML programs. The system we describe captures the formal operational semantics definition of Standard ML <ref> [1] </ref> within the theorem prover Isabelle. Our work has arisen from the desire to explore the role of formal semantics in the verification process, especially in the context of critical software, in which a single error could have disastrous consequences. <p> In Section 3 we give a brief overview of Isabelle. Section 4 describes how our system is constructed. Finally, Section 5 discusses the results and give suggestions for further work. 2 The Definition of SML The rigorous basis for Standard ML is formally given by the Definition <ref> [1] </ref>, and its companion Commentary [7]. To quote from [1]: This document is a formal description of both the grammar and the meaning of a language which is both designed for large projects and widely used. ... <p> Section 4 describes how our system is constructed. Finally, Section 5 discusses the results and give suggestions for further work. 2 The Definition of SML The rigorous basis for Standard ML is formally given by the Definition <ref> [1] </ref>, and its companion Commentary [7]. To quote from [1]: This document is a formal description of both the grammar and the meaning of a language which is both designed for large projects and widely used. ... <p> Once these translations have been provided, we can use the derived forms freely in goals, and they will be correctly dealt with. 1 Actually, L is an extension of First Order Logic. 3 4.2 Semantic Objects In the spirit of <ref> [1] </ref>, elaboration (static semantics) and evaluation (dynamic semantics) are treated separately; this is reflected in the design of the system. Thus, separate Isabelle theories are maintained: one for elaboration and one for evaluation. They have in common the syntax of F itself. <p> This information can quickly become too much to cope with. In future work, we would like to extend the system to allow for a larger subset of SML. Exceptions and imperative features will require proper handling of the state and exception conventions <ref> [1, 7] </ref>, while the inclusion of the modules system would allow experiments with subtle aspects of signature matching and elaboration of functors and signature expressions.
Reference: [2] <author> A. Cant and M. A. Ozols. </author> <title> The Role of Denotational Semantics in Program Verification. </title> <note> Formal Aspects of Computing (to be submitted), </note> <year> 1992. </year>
Reference-contexts: Our work has arisen from the desire to explore the role of formal semantics in the verification process, especially in the context of critical software, in which a single error could have disastrous consequences. It complements work described in <ref> [2] </ref>, where we explored the role of denotational semantics in the verification process.
Reference: [3] <author> R. Milner M. Gordon and C. Wadsworth. </author> <title> Edinburgh LCF: A Mechanised Logic of Computation. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> No 78. </volume> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: It complements work described in [2], where we explored the role of denotational semantics in the verification process. ML has evolved from its early days as a special purpose language for theorem provers <ref> [3, 4] </ref> to the point where it is a serious programming language, expressive enough for many real applications, and with numerous desirable features (such as strong typing, exception handling and modules) which modern software engineering and critical software development require.
Reference: [4] <author> L. C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: It complements work described in [2], where we explored the role of denotational semantics in the verification process. ML has evolved from its early days as a special purpose language for theorem provers <ref> [3, 4] </ref> to the point where it is a serious programming language, expressive enough for many real applications, and with numerous desirable features (such as strong typing, exception handling and modules) which modern software engineering and critical software development require.
Reference: [5] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Although, to our knowledge, ML has not yet been used in critical software projects, we believe that the techniques described below are applicable to any language built on rigorous principles. They will also be applicable to the problem of automated reasoning about programs in process algebras such as CCS <ref> [5] </ref> and CSP [6]. The rest of this paper is structured as follows. In Section 2 we describe the structure of the Definition of SML. In Section 3 we give a brief overview of Isabelle. Section 4 describes how our system is constructed. <p> The operational semantics rules which define SML will need to be strengthened to allow such reasoning. We are also planning to apply our methods to concurrency, where operational semantics is frequently used to give the meaning of language constructs: possibilities include CML [17], CCS <ref> [5] </ref> and the tasking model of Ada. 6 Acknowledgment The authors wish to thank Malcolm Newey (Australian National University) and Larry Paulson (University of Cambridge) for their helpful suggestions. 5
Reference: [6] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: They will also be applicable to the problem of automated reasoning about programs in process algebras such as CCS [5] and CSP <ref> [6] </ref>. The rest of this paper is structured as follows. In Section 2 we describe the structure of the Definition of SML. In Section 3 we give a brief overview of Isabelle. Section 4 describes how our system is constructed.
Reference: [7] <author> R. Milner and M. Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Section 4 describes how our system is constructed. Finally, Section 5 discusses the results and give suggestions for further work. 2 The Definition of SML The rigorous basis for Standard ML is formally given by the Definition [1], and its companion Commentary <ref> [7] </ref>. To quote from [1]: This document is a formal description of both the grammar and the meaning of a language which is both designed for large projects and widely used. ... <p> Recursion demands the unfolding operation on environments. These have been incorporated in the system. 4.5 Proof Procedures The proof procedures for reasoning about programs are quite simple Isabelle tactics which capture the way one would construct an inference tree <ref> [7] </ref>. Starting from the initial goal (the root of the tree), we 4 keep resolving with the appropriate inference rules, simplifying environments as we go, until all language phrases have disappeared. We then simplify using the inference rules for semantic objects until we reach the leaves of the tree. <p> This information can quickly become too much to cope with. In future work, we would like to extend the system to allow for a larger subset of SML. Exceptions and imperative features will require proper handling of the state and exception conventions <ref> [1, 7] </ref>, while the inclusion of the modules system would allow experiments with subtle aspects of signature matching and elaboration of functors and signature expressions.
Reference: [8] <author> G. D. Plotkin. </author> <title> A Structural Approach to Operational Semantics. </title> <type> Report, </type> <institution> University of Aarhus, Denmark. </institution>
Reference-contexts: The Definition uses operational semantics <ref> [8] </ref> to describe the meaning of phrases in the language. This method of language definition is a useful guide for the implementer of an interpreter or compiler for the language.
Reference: [9] <author> R. Sethi. </author> <title> Programming Languages, Concepts and Constructs. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: In constructing a system for reasoning about SML programs, our aim has been to capture the definition of SML in as natural a way as possible in a powerful proof assistant. One might consider using Prolog for this purpose <ref> [9] </ref>.
Reference: [10] <author> L. C. Paulson and T. Nipkow. </author> <title> Isabelle Tutorial and User's Manual. </title> <institution> Computer Laboratory, University of Cambridge, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: We believe, therefore, that Isabelle is an ideal tool for reasoning about operational semantics. 3 Isabelle The theorem prover Isabelle (itself constructed using SML!) has been under development by Larry Paulson at the University of Cambridge since 1986 <ref> [10, 11, 12] </ref>. Isabelle is a generic theorem prover, with an expressive meta-logic, in which the inference rules and axioms of object logics can be formulated. Isabelle emphasises the natural style of reasoning, and thrives on inference rules such as those of operational semantics.
Reference: [11] <author> L. C. Paulson. </author> <title> The Foundation of a Generic Theorem Prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 363-397, </pages> <year> 1989. </year>
Reference-contexts: We believe, therefore, that Isabelle is an ideal tool for reasoning about operational semantics. 3 Isabelle The theorem prover Isabelle (itself constructed using SML!) has been under development by Larry Paulson at the University of Cambridge since 1986 <ref> [10, 11, 12] </ref>. Isabelle is a generic theorem prover, with an expressive meta-logic, in which the inference rules and axioms of object logics can be formulated. Isabelle emphasises the natural style of reasoning, and thrives on inference rules such as those of operational semantics.
Reference: [12] <author> L. C. Paulson. </author> <title> Isabelle: The Next 700 Theorem Provers. Logic and Computer Science (P Odifreddi, </title> <publisher> ed), </publisher> <pages> pages 361-385, </pages> <year> 1990. </year>
Reference-contexts: We believe, therefore, that Isabelle is an ideal tool for reasoning about operational semantics. 3 Isabelle The theorem prover Isabelle (itself constructed using SML!) has been under development by Larry Paulson at the University of Cambridge since 1986 <ref> [10, 11, 12] </ref>. Isabelle is a generic theorem prover, with an expressive meta-logic, in which the inference rules and axioms of object logics can be formulated. Isabelle emphasises the natural style of reasoning, and thrives on inference rules such as those of operational semantics.
Reference: [13] <author> G. Huet. </author> <title> A Unification Algorithm for Typed calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: For a given rule, say [j B 1 ; :::; B k j] ==&gt; B resolution can form the next state by unifying the conclusion with the subgoal, replacing it by the instantiated premises. (Note that unification in Isabelle is full higher-order unification <ref> [13] </ref>).
Reference: [14] <author> D. T. Sannella and A. Tarlecki. </author> <title> Towards Formal Development of ML Programs: Foundations and Methodology. </title> <type> Report EFS-LFCS-89-71, </type> <institution> University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Such specification constructs are under investigation as part of the Extended ML language of Sannella and Tarlecki <ref> [14] </ref>, and in current work of Gene Rollins, Jeannette Wing, and Amy Moormann Zaremski at CMU on Larch/ML. Another important line of investigation is that of reasoning about program equivalences and transformations [15, 16]. The operational semantics rules which define SML will need to be strengthened to allow such reasoning.
Reference: [15] <author> R. J. R. Back and J. von Wright. </author> <title> Refinement Concepts Formalised in Higher Order Logic. </title> <journal> Formal Aspects of Computing Systems, </journal> <volume> 20:799, </volume> <year> 1990. </year>
Reference-contexts: Such specification constructs are under investigation as part of the Extended ML language of Sannella and Tarlecki [14], and in current work of Gene Rollins, Jeannette Wing, and Amy Moormann Zaremski at CMU on Larch/ML. Another important line of investigation is that of reasoning about program equivalences and transformations <ref> [15, 16] </ref>. The operational semantics rules which define SML will need to be strengthened to allow such reasoning.
Reference: [16] <author> R. Roxas and M. C. Newey. </author> <title> Proof of Program Transformations. HOL '91 User Meeting, </title> <institution> Aarhus, Denmark, Australian National University, </institution> <year> 1991. </year>
Reference-contexts: Such specification constructs are under investigation as part of the Extended ML language of Sannella and Tarlecki [14], and in current work of Gene Rollins, Jeannette Wing, and Amy Moormann Zaremski at CMU on Larch/ML. Another important line of investigation is that of reasoning about program equivalences and transformations <ref> [15, 16] </ref>. The operational semantics rules which define SML will need to be strengthened to allow such reasoning.
Reference: [17] <author> J. H. Reppy. </author> <title> Concurrent Programming with Events: The Concurrent ML Manual. </title> <institution> Dept of Computer Science, Cornell University, </institution> <address> Ithaca NY, </address> <month> October </month> <year> 1991. </year> <month> 6 </month>
Reference-contexts: The operational semantics rules which define SML will need to be strengthened to allow such reasoning. We are also planning to apply our methods to concurrency, where operational semantics is frequently used to give the meaning of language constructs: possibilities include CML <ref> [17] </ref>, CCS [5] and the tasking model of Ada. 6 Acknowledgment The authors wish to thank Malcolm Newey (Australian National University) and Larry Paulson (University of Cambridge) for their helpful suggestions. 5
References-found: 17

