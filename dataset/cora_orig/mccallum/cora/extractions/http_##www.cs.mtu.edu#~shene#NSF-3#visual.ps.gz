URL: http://www.cs.mtu.edu/~shene/NSF-3/visual.ps.gz
Refering-URL: http://www.cs.mtu.edu/~shene/NSF-3/
Root-URL: http://www.cs.mtu.edu
Email: [mjbedy|xlhuang]@mtu.edu  
Title: A Thread Visualization System  
Author: Michael Bedy and Xianglong Huang 
Address: Houghton, MI 49931-1295  
Affiliation: Department of Computer Science, Michigan Technological University,  
Abstract: It is very difficult for the average student to understand the concepts behind multithreaded programming. Even experienced programmers may have difficultly avoiding the risks involved in the execution of a multithreaded program. We are developing a system to help students learn to avoid these risks (e.g., race conditions and deadlocks). This system uses an easy to learn object-oriented thread class and a subsystem for visualizing thread activities on-the-fly. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. J. Courtois, F. Heymans and D. L. Parnas, </author> <title> Concurrent Control with "Readers" and "Writers," </title> <journal> Communications of ACM, </journal> <volume> Vol. 14 (1971), No. 10, </volume> <pages> pp. 667-668. </pages>
Reference-contexts: We also focus on letting students learn different policies of implementing the same synchronization primitive. For example, there are two different types of read-write locks; writer has higher priority and reader has higher priority. We provide both types in the RWLock class <ref> [1] </ref>. Our implementation of monitors also has two forms: Hoare and Mesa. Students can use either type and explore the differences between them. The visualization subsystem is unique in that it allows the student to see what their program is doing as it is running (Figure 1).
Reference: [2] <author> Thomas W. Doeppner, </author> <title> The Brown C++ Threads Package, </title> <type> Version 2.0, </type> <institution> Brown University. </institution> <year> (1996) </year>
Reference-contexts: This allows the student a deeper understanding of the program that they are developing. 2 Related Work Although multithreaded programming is an important and difficult skill, there are few educational tools available. Brown's thread package <ref> [2] </ref> wraps Pthread system calls into C++ classes. It is a step in the right direction, but it does little towards helping students write correct programs.
Reference: [3] <author> Richard C. Holt, </author> <title> Some Deadlock Properties of Computer Systems, </title> <journal> Computing Surveys, </journal> <volume> Vol. 4 (1972), No. 3, </volume> <pages> pp. 179-196. </pages>
Reference-contexts: In addition to thread execution, the visualization subsystem can help students monitor various synchronization primitives with multiple displays (Figure 2). Semaphore, mutex lock, barrier, monitor, read-write lock, and thread status are currently available displays, some of which have multiple modes of visualization. Deadlock detection is implemented using Holt's method <ref> [3] </ref>. When a resource request is made, the reduction of the resource graph for detecting deadlocks will be displayed. Hence, this helps the student understand not only what is happening, but why.
Reference: [4] <author> Barton P. Miller, </author> <title> What to Draw? When to Draw? An Essay on Parallel Program Visualization, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 18 (1993), </volume> <pages> pp. 265-269. </pages>
Reference-contexts: Work has also been done towards wrapping visualization support around thread system calls [6]. Miller's paper <ref> [4] </ref> has an excellent discussion of what is needed to create a useful visualization of a parallel process. He points out that the display that is colorful and "looks pretty" is not necessarily a useful one. This observation is central to our approach.
Reference: [5] <author> John T. Stasko, </author> <title> The PARADE Environment for Visualizing Parallel Program Executions: </title> <type> A Progress Report Technical Report GIT-GVU-95-03, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <year> 1995. </year>
Reference-contexts: He points out that the display that is colorful and "looks pretty" is not necessarily a useful one. This observation is central to our approach. Work on post-mortem visualization of thread systems can be found in Stasko <ref> [5] </ref>. Some of our displays, such as the thread history and the barrier visualization, are influenced by the work presented in this paper. 3 Approach and Uniqueness The most important goal is to help students learn mul-tithreaded programming techniques easily.
Reference: [6] <author> Qiang A. Zhao and John T. Stasko, </author> <title> Visualizing the execution of threads-based parallel programs. </title> <type> Technical Report GIT-GVU-95/01, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> January </month> <year> 1995. </year> <month> 2 </month>
Reference-contexts: Our system not only wraps Solaris fl This work was partially supported by the National Science Foundation under grant DUE-9752244. thread's system calls, but also adds some useful features not available in Solaris threads. Work has also been done towards wrapping visualization support around thread system calls <ref> [6] </ref>. Miller's paper [4] has an excellent discussion of what is needed to create a useful visualization of a parallel process. He points out that the display that is colorful and "looks pretty" is not necessarily a useful one. This observation is central to our approach.
References-found: 6

