URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/hudak-dir/fran/icfp97.ps
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/hudak-paul.html
Root-URL: http://www.cs.yale.edu
Email: conal@microsoft.com  paul.hudak@yale.edu  
Title: Functional Reactive Animation  
Author: Conal Elliott Paul Hudak 
Affiliation: Microsoft Research Graphics Group  Yale University Dept. of Computer Science  
Abstract: Fran (Functional Reactive Animation) is a collection of data types and functions for composing richly interactive, multimedia animations. The key ideas in Fran are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are sets of arbitrarily complex conditions, carrying possibly rich information. Most traditional values can be treated as behaviors, and when images are thus treated, they become animations. Although these notions are captured as data types rather than a programming language, we provide them with a denotational semantics, including a proper treatment of real time, to guide reasoning and implementation. A method to effectively and efficiently perform event detection using interval analysis is also described, which relies on the partial information structure on the domain of event times. Fran has been implemented in Hugs, yielding surprisingly good performance for an interpreter-based system. Several examples are given, including the ability to describe physical phenomena involving gravity, springs, velocity, acceleration, etc. using ordinary differential equations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kavi Arya. </author> <title> A functional approach to animation. </title> <journal> Computer Graphics Forum, </journal> <volume> 5(4) </volume> <pages> 297-311, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include [15, 23, 3, 10]. Arya used a lazy functional language to model 2D animation as lazy lists of pictures <ref> [1, 2] </ref>, constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
Reference: [2] <author> Kavi Arya. </author> <title> A functional animation starter-kit. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 1-18, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include [15, 23, 3, 10]. Arya used a lazy functional language to model 2D animation as lazy lists of pictures <ref> [1, 2] </ref>, constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
Reference: [3] <author> Joel F. Bartlett. </author> <title> Don't fidget with widgets, </title> <type> draw! Technical Report 6, </type> <institution> DEC Western Digital Laboratory, 250 University Avenue, Palo Alto, California 94301, US, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: We have not yet implemented this idea. 5 Related Work Henderson's functional geometry [12] was one of the first purely declarative approaches to graphics, although it does not deal with animation or reactivity. Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include <ref> [15, 23, 3, 10] </ref>. Arya used a lazy functional language to model 2D animation as lazy lists of pictures [1, 2], constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
Reference: [4] <author> P. Caspi, N. Halbwachs, D. Pilaud, and J.A. Plaice. Lustre: </author> <title> A declarative language for programming synchronous systems. </title> <booktitle> In 14th ACM Symp. on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1987. </year>
Reference-contexts: There are also several languages designed around a synchronous data-flow notion of computation. The general-purpose functional language Lucid [21] is an example of this style of language, but more importantly are the languages Signal [11] and Lustre <ref> [4] </ref>, which were specifically designed for control of real-time systems. In Signal, the most fundamental idea is that of a signal, a time-ordered sequence of values. Unlike Fran, however, time is not a value, but rather is implicit in the ordering of values in a signal.
Reference: [5] <author> R.B. Dannenberg. </author> <title> The Canon score language. </title> <journal> Computer Music Journal, </journal> <volume> 13(1) </volume> <pages> 47-56, </pages> <year> 1989. </year>
Reference-contexts: The Haskore work also points out useful algebraic properties that such declarative systems possess. Other computer music languages worth mentioning include Canon <ref> [5] </ref>, Fugue [6], and a language being developed at GRAME [16], only the latter of which is purely declarative.
Reference: [6] <author> R.B. Dannenberg, C.L. Fraley, and P. Velikonja. </author> <title> A functional language for sound synthesis with behavioral abstraction and lazy evaluation. In Denis Baggi, editor, Computer Generated Music. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: The Haskore work also points out useful algebraic properties that such declarative systems possess. Other computer music languages worth mentioning include Canon [5], Fugue <ref> [6] </ref>, and a language being developed at GRAME [16], only the latter of which is purely declarative.
Reference: [7] <author> Conal Elliott. </author> <title> A brief introduction to ActiveVRML. </title> <type> Technical Report MSR-TR-96-05, </type> <institution> Microsoft Research, </institution> <year> 1996. </year> <note> ftp://ftp.research.microsoft.com/ pub/tech-reports/Winter95-96/tr-96-05.ps. </note>
Reference-contexts: We treat them as a pair of mutually recursive polymorphic data types, and specify operations on them via a denotational semantics. (The "media types" we often use with events and behaviors will be treated formally in a later paper; but see also <ref> [7] </ref>.) 2.1 Semantic Domains The abstract domain of time is called Time. The abstract domains of polymorphic behaviors (ff-behaviors) and polymorphic events (ff-events) are denoted Behavior ff and Event ff , respectively. Most of our domains (integers, booleans, etc.) are stan-dard, and require no explanation. <p> Fran and DirectX Animation both grew out of the ideas in an earlier design called Ac-tiveVRML <ref> [7] </ref>. DirectX Animation is used from more mainstream imperative languages, and so mixes the functional and imperative approaches. There are also several languages designed around a synchronous data-flow notion of computation.
Reference: [8] <author> Conal Elliott, Greg Schechter, Ricky Yeung, and Salim Abi-Ezzi. TBAG: </author> <title> A high level framework for interactive, animated 3D graphics applications. </title> <editor> In Andrew Glassner, editor, </editor> <booktitle> Proceedings of SIGGRAPH '94 (Or-lando, Florida), </booktitle> <pages> pages 421-434. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: The TBAG system modeled 3D animations as functions over continuous time, using a "behavior" type family <ref> [8, 19] </ref>. These behaviors are built up via combinators that are automatically invoked during solution of high level constraints. Because it used continuous time, TBAG was able to support derivatives and integrals. It also used the idea of elevating functions on static values into functions on behaviors, which we adopted.
Reference: [9] <author> John Peterson et. al. </author> <title> Haskell 1.3: A non-strict, purely functional language. </title> <type> Technical Report YALEU/DCS/RR-1106, </type> <institution> Department of Computer Science, Yale University, </institution> <month> May </month> <year> 1996. </year> <note> WWW version at http://haskell.cs.yale.edu/haskell-report. </note>
Reference-contexts: Moreover, we have found that non-strict semantics, higher-order functions, strong polymorphic typing, and systematic overloading are valuable language properties for supporting modeled animations. For these reasons, Fran provides these data types in the programming language Haskell <ref> [9] </ref>. Advantages of Modeling over Presentation The benefits of a modeling approach to animation are similar to those in favor of a functional (or other declarative) programming paradigm, and include clarity, ease of construction, composability, and clean semantics.
Reference: [10] <author> Sigbjorn Finne and Simon Peyton Jones. </author> <title> Pictures: A simple structured graphics model. </title> <booktitle> In Glasgow Functional Programming Workshop, </booktitle> <address> Ullapool, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: We have not yet implemented this idea. 5 Related Work Henderson's functional geometry [12] was one of the first purely declarative approaches to graphics, although it does not deal with animation or reactivity. Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include <ref> [15, 23, 3, 10] </ref>. Arya used a lazy functional language to model 2D animation as lazy lists of pictures [1, 2], constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
Reference: [11] <author> Thierry Gautier, Paul Le Guernic, and Loic Besnard. </author> <title> Signal: A declarative language for synchronous programming of real-time systems. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 274 of Lect Notes in Computer Science, </booktitle> <editor> edited by G. Goos and J. </editor> <booktitle> Hartmanis, </booktitle> <pages> pages 257-277. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: There are also several languages designed around a synchronous data-flow notion of computation. The general-purpose functional language Lucid [21] is an example of this style of language, but more importantly are the languages Signal <ref> [11] </ref> and Lustre [4], which were specifically designed for control of real-time systems. In Signal, the most fundamental idea is that of a signal, a time-ordered sequence of values. Unlike Fran, however, time is not a value, but rather is implicit in the ordering of values in a signal.
Reference: [12] <author> Peter Henderson. </author> <title> Functional geometry. </title> <booktitle> In ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 179-187, </pages> <year> 1982. </year>
Reference-contexts: It is also possible to apply IA to positional user input. The idea is to place bounds on the rate or acceleration of the positional input, and then make a worst-case analysis based on these bounds. We have not yet implemented this idea. 5 Related Work Henderson's functional geometry <ref> [12] </ref> was one of the first purely declarative approaches to graphics, although it does not deal with animation or reactivity. Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include [15, 23, 3, 10].
Reference: [13] <author> Paul Hudak, Tom Makucevich, Syam Gadde, and Bo Whong. </author> <title> Haskore music notation an algebra of music, </title> <month> September </month> <year> 1994. </year> <note> To appear in the Journal of Functional Programming; preliminary version available via ftp://nebula.systemsz.cs.yale.edu/pub/ yale-fp/papers/haskore/hmn-lhs.ps. </note>
Reference-contexts: That is, expressions are evaluated without side-effects to yield concurrent, imperative computations, which are executed to perform the implied side-effects. In contrast, modeling entire behaviors as implicitly concurrent functions of continuous time yields what we consider a more declarative feel. Haskore <ref> [13] </ref> is a purely functional approach to constructing, analyzing, and performing computer music, which has much in common with Henderson's functional geometry, even though it is for a completely different medium. The Haskore work also points out useful algebraic properties that such declarative systems possess.
Reference: [14] <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In ACM Symposium on the Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: In contrast, our events are used purely for the values they generate. These values often turn out to be behaviors, although they can also be new events, tuples, functions, etc. Concurrent Haskell <ref> [14] </ref> extends the pure lazy functional programming language Haskell with a small set of primitives for explicit concurrency, designed around Haskell's monadic support for I/O. While this system is purely functional in the technical sense, its semantics has a strongly imperative feel.
Reference: [15] <author> Peter Lucas and Stephen N. Zilles. </author> <title> Graphics in an applicative context. </title> <type> Technical report, </type> <institution> IBM Almaden Research Center, </institution> <address> 650 Harry Road, San Jose, CA 95120-6099, </address> <month> July 8 </month> <year> 1987. </year>
Reference-contexts: We have not yet implemented this idea. 5 Related Work Henderson's functional geometry [12] was one of the first purely declarative approaches to graphics, although it does not deal with animation or reactivity. Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include <ref> [15, 23, 3, 10] </ref>. Arya used a lazy functional language to model 2D animation as lazy lists of pictures [1, 2], constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
Reference: [16] <author> O. Orlarey, D. Fober, S. Letz, and M. Bilton. </author> <title> Lambda calculus and music calculi. </title> <booktitle> In Proceedings of International Computer Music Conference. Int'l Computer Music Association, </booktitle> <year> 1994. </year>
Reference-contexts: The Haskore work also points out useful algebraic properties that such declarative systems possess. Other computer music languages worth mentioning include Canon [5], Fugue [6], and a language being developed at GRAME <ref> [16] </ref>, only the latter of which is purely declarative.
Reference: [17] <author> William H. Press, Saul A. Teukolsky, William T. Vet-terling, and Brian P. Flannery. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientific Computing (2nd ed.). </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1992. </year> <note> ISBN 0-521-43108-5. </note>
Reference-contexts: In this section, we describe the non-obvious implementation techniques used in Fran. One relatively minor item is integration. While symbolic integration could certainly be used for simple behaviors, we have instead adapted standard textbook numerical techniques. (We chiefly use fourth order Runge Kutta <ref> [17] </ref>.) 4.1 Representing Behaviors An early implementation of Fran represented behaviors as implied in the formal semantics: data Behavior a = Behavior (Time -&gt; a) This representation, however, leads to a serious inefficiency.
Reference: [18] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: It also used the idea of elevating functions on static values into functions on behaviors, which we adopted. Unlike our approach, however, reactivity was handled imperatively, through constraint assertion and retraction, performed by an application program. CML (Concurrent ML) formalized synchronous operations as first-class, purely functional, values called "events" <ref> [18] </ref>. Our event combinators ".|." and "==&gt;" correspond to CML's choose and wrap functions. There are substantial differences, however, between the meaning given to "events" in these two approaches.
Reference: [19] <author> Greg Schechter, Conal Elliott, Ricky Yeung, and Salim Abi-Ezzi. </author> <title> Functional 3D graphics in C++ with an object-oriented, </title> <booktitle> multiple dispatching implementation. In Proceedings of the 1994 Eurographics Object-Oriented Graphics Workshop. Eurographics, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The TBAG system modeled 3D animations as functions over continuous time, using a "behavior" type family <ref> [8, 19] </ref>. These behaviors are built up via combinators that are automatically invoked during solution of high level constraints. Because it used continuous time, TBAG was able to support derivatives and integrals. It also used the idea of elevating functions on static values into functions on behaviors, which we adopted.
Reference: [20] <author> John M. Snyder. </author> <title> Interval analysis for computer graphics. </title> <editor> In Edwin E. Catmull, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> volume 26, </volume> <pages> pages 121-130, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: An alternative technique is symbolic equation solving. Unfortunately, except for very simple examples, equations cannot be solved symbolically. The technique we use to detect predicate events is interval analysis (IA) <ref> [20] </ref>. It uses more information from a behavior than can be extracted purely through sampling, but it does not require symbolic equation solving. <p> b2 `during` iv The restriction on behaviors referred to in Section 2.3 that makes event detection possible, is that behaviors are composed of functions f for which a corresponding fi is known in the lift n functions. (These fi are called "inclusion functions.") Defining functions' behaviors over intervals is well-understood <ref> [20] </ref>, and we omit the details here, other than to point out that Haskell's type classes once again provide a convenient notation for interval versions of the standard arithmetic operators. For example, evaluating (2 `Upto` 4) + (10 `Upto` 30) yields the interval [12,34].
Reference: [21] <author> W.W. Wadge and E.A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press U.K., </publisher> <year> 1985. </year>
Reference-contexts: DirectX Animation is used from more mainstream imperative languages, and so mixes the functional and imperative approaches. There are also several languages designed around a synchronous data-flow notion of computation. The general-purpose functional language Lucid <ref> [21] </ref> is an example of this style of language, but more importantly are the languages Signal [11] and Lustre [4], which were specifically designed for control of real-time systems. In Signal, the most fundamental idea is that of a signal, a time-ordered sequence of values.
Reference: [22] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: e is the event that occurs when e 0 occurs, where e 0 is the value part of e. joinEv : Event Event ff ! Event ff occ [[joinEv e]] = occ [[snd (occ [[e]])]] (This function is so named because it is the "join" operator for the Event monad <ref> [22] </ref>.) For example, the event joinEv (lbp t 0 fl) predicate (b = 0)) occurs the first time that the behavior b has the value zero after the first left button press after time t 0 . 3 Some Larger Examples The previous section presented the primitive combinators for behaviors and
Reference: [23] <author> S.N. Zilles, P. Lucas, T.M. Linden, J.B. Lotspiech, and A.R. Harbury. </author> <title> The Escher document imaging model. </title> <booktitle> In Proceedings of the ACM Conference on Document Processing Systems (Santa Fe, </booktitle> <address> New Mexico), </address> <pages> pages 159-168, </pages> <month> December 5-9 </month> <year> 1988. </year>
Reference-contexts: We have not yet implemented this idea. 5 Related Work Henderson's functional geometry [12] was one of the first purely declarative approaches to graphics, although it does not deal with animation or reactivity. Several other researchers have also found declarative languages well-suited for modeling pictures. Examples include <ref> [15, 23, 3, 10] </ref>. Arya used a lazy functional language to model 2D animation as lazy lists of pictures [1, 2], constructed using list combinators. While this work was quite elegant, the use of lists implies a discrete model of time, which is somewhat unnatural.
References-found: 23

