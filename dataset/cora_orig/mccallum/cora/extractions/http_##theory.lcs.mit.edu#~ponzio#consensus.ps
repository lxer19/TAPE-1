URL: http://theory.lcs.mit.edu/~ponzio/consensus.ps
Refering-URL: http://theory.lcs.mit.edu/~ponzio/consensus.html
Root-URL: 
Title: Consensus in the Presence of Timing Uncertainty: Omission and Byzantine Failures (Extended abstract)  
Author: Stephen Ponzio 
Affiliation: MIT Laboratory for Computer Science  
Abstract: We consider the time complexity of reaching agreement in a semi-synchronous model of distributed systems, in the presence of omission and Byzantine failures. In our semi-synchronous model, processes have inexact knowledge about the time to perform certain primitive actions: messages arrive within time d of when they are sent and the time between two consecutive steps of any process is in the known interval [c 1 ; c 2 ]. We use C = c 2 =c 1 as a measure of the timing uncertainty. A simple adaptation of the synchronous lower bound shows that at least time (f + 1)d is required to tolerate f failures; time (f + 1)Cd is sufficient for stopping or omission failures by directly simulating synchronous rounds. By strengthening the algorithm for stopping failures of Attiya, Dwork, Lynch, and Stockmeyer ([1]), we derive an algorithm for omission failures that has minimal dependency on the uncertainty factor C. If fewer than half the processes are faulty then the running time is 4(f + 1)d + Cd, which is within a factor of 4 of optimal and may be much faster than direct rounds simulation if C is large. If more than half the processes are faulty, then the running time is shown to be greater by approximately a factor of min( f p Finally, we present a general simulation for n 3f + 1 that tolerates Byzantine failures and simulates any round-based synchronous algorithm at a cost of time 2Cd + d per round. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Attiya, C. Dwork, N. Lynch, and L. Stock-meyer. </author> <title> Bounds on the time to reach agreement in the presence of timing uncertainty. </title> <type> Report TM-435, </type> <institution> Laboratory for Computer Science, MIT, </institution> <month> November </month> <year> 1990. </year> <note> Also in STOC 1991. </note>
Reference-contexts: Thus each round takes approximately time Cd to simulate. When failures are arbitrary, it is not clear even how to simulate a synchronous algorithm correctly. In <ref> [1] </ref>, Attiya, Dwork, Lynch, and Stockmeyer prove nearly tight upper and lower bounds on the time to reach consensus in the presence of stopping failures. By combining several lower bound techniques, they prove a lower bound of (f 1)d + Cd. <p> More surprisingly, they give a clever algorithm for consensus that runs in time 2fd + Cd, much faster than a direct simulation when C is large. This paper makes three contributions: the strengthening the algorithm of <ref> [1] </ref> to tolerate omission failures requiring a finer analysis, the characterization both algorithms as the simulation of a simple synchronous algorithm, and a general simulation tolerant of Byzantine failures. <p> If n 2f, then a more involved analysis proves two different upper bounds for the running time: (3 f p We identify our algorithm and that of <ref> [1] </ref> as optimized simulations of a synchronous algorithm. This view may help in understanding what problems can and cannot be efficiently solved in this semi synchronous model. <p> Other problems recently studied in our model of timing uncertainty include the problem of mutual exclusion [2] and the complexity of a network synchronizer algorithm [3]. 2 Model Our underlying formal model is essentially the same as that used in <ref> [1] </ref>. Our model differs by assuming for ease of presentation that all processes begin executing the algorithm at time 0 and all messages are delivered in the order sent. <p> The latter assumption is easily removed from both of our algorithms; for our omissions algorithm, the former may be replaced by the formalism of <ref> [1] </ref> whereby processes receive "input (v i )" actions and running time is measured beginning with the latest of these. We consider a system of n processes 1; : : : ; n. Each process is modeled as a deterministic (possibly infinite) state machine. <p> We consider the binary version of the problem, where the initial values are 0 or 1. Like the algorithm of <ref> [1] </ref>, our algorithm for omission failures can be extended to work for any value set, using the same extension given there ([1], x5.4). <p> work for any value set, using the same extension given there (<ref> [1] </ref>, x5.4). Our algorithm for Byzantine failures is a general simulation for any rounds based algorithm and therefore can simulate any synchronous agreement algorithm for any value set. 3 Omissions failures In this section, we strengthen the algorithm of [1] to tolerate omission failures. Unlike [1], our algorithm requires an a priori bound f on the number of failures to be tolerated. <p> the same extension given there (<ref> [1] </ref>, x5.4). Our algorithm for Byzantine failures is a general simulation for any rounds based algorithm and therefore can simulate any synchronous agreement algorithm for any value set. 3 Omissions failures In this section, we strengthen the algorithm of [1] to tolerate omission failures. Unlike [1], our algorithm requires an a priori bound f on the number of failures to be tolerated. <p> It is, however, "early stopping": the running time for a given execution is a function of the number of processes that fail in that execution, not of the maximum number of failures to be tolerated. 3.1 Intuition: the underlying synchronous algorithm Our algorithm and the algorithm of <ref> [1] </ref> may be interpreted as simulations of the following simple synchronous algorithm: Round 0: If v = 1, then send "I didn't decide in Round 0" and goto Round 1. If v = 0, then send "I decided in Round 0" and decide 0. <p> Both our algorithm and that of <ref> [1] </ref> simulate this synchronous algorithm, making several important optimizations in order to improve the running time for our model. <p> The key to the improved efficiency of our algorithm relative to that of <ref> [1] </ref> is the addition of a mechanism for a process to detect its own failure. We require that a process receive at least n f acknowledgments for every message of the synchronous algorithm that it sends. <p> For C large, this algorithm may be far more efficient that a direct rounds simulation. The bound we obtain for n 2f + 1 is within approximately a factor of 4 of optimal: our bound is 4 (f + 1)d + Cd; the lower bound proved in <ref> [1] </ref> is (f 1)d + Cd. Theorem 3.17 For n 2f + 1, the algorithm above solves the consensus problem for f omission failures within time 4 (f + 1)d + Cd. Proof: For any given execution, let h be the first quiet phase.
Reference: [2] <author> H. Attiya and N. A. Lynch. </author> <title> Time bounds for real-time process control in the presence of timing uncertainty. </title> <booktitle> Proc. 10th IEEE Real-Time Systems Symposium, </booktitle> <year> 1989, </year> <pages> pp. 268-284. </pages> <note> Also: Technical Memo MIT/LCS/TM-403, </note> <institution> Laboratory for Computer Science, MIT, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: Algorithms from [22] and the previously mentioned consensus work of [11] include ideas similar to those in our simulation tolerant of arbitrary failures. Other problems recently studied in our model of timing uncertainty include the problem of mutual exclusion <ref> [2] </ref> and the complexity of a network synchronizer algorithm [3]. 2 Model Our underlying formal model is essentially the same as that used in [1].
Reference: [3] <author> H. Attiya and M. Mavronicolas. </author> <title> Efficiency of asynchronous vs. semi-synchronous networks. </title> <booktitle> the 28th annual Allerton Conference on Communication, Control and Computing, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Algorithms from [22] and the previously mentioned consensus work of [11] include ideas similar to those in our simulation tolerant of arbitrary failures. Other problems recently studied in our model of timing uncertainty include the problem of mutual exclusion [2] and the complexity of a network synchronizer algorithm <ref> [3] </ref>. 2 Model Our underlying formal model is essentially the same as that used in [1]. Our model differs by assuming for ease of presentation that all processes begin executing the algorithm at time 0 and all messages are delivered in the order sent.
Reference: [4] <author> F. Cristian, H. Aghili, R. Strong and D. Dolev. </author> <title> Atomic broadcast: from simple message diffusion to Byzantine agreement. </title> <booktitle> Proc. 15th Int. Conf. on Fault Tolerant Computing, </booktitle> <year> 1985, </year> <pages> pp. 1-7. </pages> <note> Also: IBM Research Report RJ5244, revised October 1989. </note>
Reference: [5] <author> B. A. Coan and C. Dwork. </author> <title> Simultaneity is harder than agreement. </title> <booktitle> Proc. 5th IEEE Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <year> 1986, </year> <pages> pp. 141-150. </pages>
Reference: [6] <author> B. Coan and G. Thomas. </author> <title> Agreeing on a leader in real-time. </title> <booktitle> Proc. 11th IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference: [7] <author> R. DeMillo, N. A. Lynch and M. Merritt. </author> <title> Cryptographic protocols. </title> <booktitle> Proc. 14th Annual ACM Symp. on Theory of Computing, </booktitle> <month> May </month> <year> 1982, </year> <pages> pp. 383-400. </pages>
Reference-contexts: Byzantine (arbitrary) failures. The time complexity of the consensus problem has been well studied in the synchronous "rounds" model (see, for example, <ref> [16, 18, 13, 10, 7] </ref>). The synchronous lower bound of f + 1 rounds ([17, 12, 5]) can be adapted in a straightforward way to yield a lower bound of (f + 1)d in our semi-synchronous model.
Reference: [8] <author> D. Dolev, C. Dwork and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 34, No. 1 (Jan-uary 1987), </volume> <pages> pp. 77-97. </pages>
Reference-contexts: We assume that processes begin executing a given algorithm at the same time and measure the amount of real time until all nonfaulty processes reach a decision. In this paper, we consider two kinds of process failure: send-omission failures and 1 Results of [14] and <ref> [8] </ref> imply that if any of the bounds d, c 1 , and c 2 does not exist then there is no algorithm for consensus tolerating even a single stopping failure. Byzantine (arbitrary) failures.
Reference: [9] <author> D. Dolev, R. Reischuk, and H. R. </author> <title> Strong. Eventual is earlier than immediate. </title> <booktitle> Proceedings of the 23rd IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1982, </year> <pages> pp. 196-203. </pages>
Reference: [10] <author> D. Dolev and H. R. </author> <title> Strong. Authenticated algorithms for Byzantine agreement. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 12, No. </volume> <month> 3 (November </month> <year> 1983), </year> <pages> pp. 656-666. </pages>
Reference-contexts: Byzantine (arbitrary) failures. The time complexity of the consensus problem has been well studied in the synchronous "rounds" model (see, for example, <ref> [16, 18, 13, 10, 7] </ref>). The synchronous lower bound of f + 1 rounds ([17, 12, 5]) can be adapted in a straightforward way to yield a lower bound of (f + 1)d in our semi-synchronous model.
Reference: [11] <author> C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 35 (1988), </volume> <pages> pp. 288-323. </pages>
Reference-contexts: Our general simulation tolerates Byzantine failures and works for any round-based synchronous algorithm for n 3f + 1 at a cost of time 2Cd + d per round, implying a consensus algorithm for our semi-synchronous model requiring time (f + 1)(2Cd + d). 1.1 Related work In <ref> [11] </ref>, the consensus problem was studied using a model of partial synchrony in which upper bounds on message delivery time and/or processes' relative step rates exist, but are unknown a priori to the processes. The algorithms of [11] are concerned with fault tolerance rather than timing efficiency, and therefore translate to <p> semi-synchronous model requiring time (f + 1)(2Cd + d). 1.1 Related work In <ref> [11] </ref>, the consensus problem was studied using a model of partial synchrony in which upper bounds on message delivery time and/or processes' relative step rates exist, but are unknown a priori to the processes. The algorithms of [11] are concerned with fault tolerance rather than timing efficiency, and therefore translate to relatively slow algorithms for our model. In contrast, we concentrate on exact time complexity. Current work also concentrating on the real time complexity of the consensus problem appears in [21]. <p> Other work in this area includes the extensive literature on clock synchronization algorithms (see [20] for a survey). Algorithms from [22] and the previously mentioned consensus work of <ref> [11] </ref> include ideas similar to those in our simulation tolerant of arbitrary failures.
Reference: [12] <author> C. Dwork and Y. Moses. </author> <title> Knowledge and common knowledge in Byzantine environments I: crash failures. </title> <booktitle> Proc. 1st Conf. on Theoretical Aspects of Reasoning About Knowledge, </booktitle> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1986, </year> <pages> pp. </pages> <note> 149-170; Information and Computation, to appear. </note>
Reference: [13] <author> M. Fischer and N. Lynch. </author> <title> A lower bound for the time to assure interactive consistency. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 14, No. </volume> <month> 4 (June </month> <year> 1982), </year> <pages> pp. 183-186. </pages>
Reference-contexts: Byzantine (arbitrary) failures. The time complexity of the consensus problem has been well studied in the synchronous "rounds" model (see, for example, <ref> [16, 18, 13, 10, 7] </ref>). The synchronous lower bound of f + 1 rounds ([17, 12, 5]) can be adapted in a straightforward way to yield a lower bound of (f + 1)d in our semi-synchronous model.
Reference: [14] <author> M. Fischer, N. Lynch and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. 2 (1985), </volume> <pages> pp. 374-382. </pages>
Reference-contexts: We assume that processes begin executing a given algorithm at the same time and measure the amount of real time until all nonfaulty processes reach a decision. In this paper, we consider two kinds of process failure: send-omission failures and 1 Results of <ref> [14] </ref> and [8] imply that if any of the bounds d, c 1 , and c 2 does not exist then there is no algorithm for consensus tolerating even a single stopping failure. Byzantine (arbitrary) failures.
Reference: [15] <author> A. Herzberg and S. Kutten. </author> <title> Efficient Detection of Message Forwarding Faults. </title> <booktitle> Proc. 8th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1989, </year> <pages> pp. 339-353. </pages>
Reference-contexts: In contrast to our results, the results there are stated in terms of process clock time, not absolute time. It is unclear how to translate results back and forth between their model and ours; this is posed as a direction for further research. A related model is proposed in <ref> [15] </ref> to study the time complexity of detecting failures along a network path. This model assumes synchronous processes but differentiates between the worst-case a priori bound on message delay and the actual worst-case message delay ffi in a given execution, which may be much less. <p> In this model, our algorithms yield an improvement over direct simulation strategies similar to the corresponding improvement in our semi-synchronous model. In fact, our algorithms may be run without modification (with c 1 = c 2 ) in the model of <ref> [15] </ref>, yielding the running times derived here with the syntactic substitution of ffi for d and =ffi for C. Other work in this area includes the extensive literature on clock synchronization algorithms (see [20] for a survey).
Reference: [16] <author> L. Lamport, R. Shostak and M. Pease. </author> <title> The Byzan-tine generals problem. </title> <journal> ACM Transaction on Prog. Lang. and Sys., </journal> <volume> Vol. 4, No. </volume> <month> 3 (July </month> <year> 1982), </year> <pages> pp. 382-401. </pages>
Reference-contexts: Byzantine (arbitrary) failures. The time complexity of the consensus problem has been well studied in the synchronous "rounds" model (see, for example, <ref> [16, 18, 13, 10, 7] </ref>). The synchronous lower bound of f + 1 rounds ([17, 12, 5]) can be adapted in a straightforward way to yield a lower bound of (f + 1)d in our semi-synchronous model.
Reference: [17] <author> M. Merritt. </author> <title> Notes on the Dolev-Strong lower bound for Byzantine agreement. </title> <type> Unpublished manuscript, </type> <year> 1985. </year>
Reference: [18] <author> M. Pease, R. Shostak and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 27, No. 2 (1980), </volume> <pages> pp. 228-234. </pages>
Reference-contexts: Byzantine (arbitrary) failures. The time complexity of the consensus problem has been well studied in the synchronous "rounds" model (see, for example, <ref> [16, 18, 13, 10, 7] </ref>). The synchronous lower bound of f + 1 rounds ([17, 12, 5]) can be adapted in a straightforward way to yield a lower bound of (f + 1)d in our semi-synchronous model.
Reference: [19] <author> S. Ponzio. </author> <title> The Real-time Cost of Timing Uncertainty: Consensus and Failure Detection. </title> <type> SM thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1991. </year>
Reference: [20] <author> B. Simons, J. L. Welch and N. Lynch. </author> <title> An overview of clock synchronization. </title> <booktitle> Proceedings of IBM Fault-Tolerant Computing Workshop, </booktitle> <month> March, </month> <year> 1986. </year>
Reference-contexts: Other work in this area includes the extensive literature on clock synchronization algorithms (see <ref> [20] </ref> for a survey). Algorithms from [22] and the previously mentioned consensus work of [11] include ideas similar to those in our simulation tolerant of arbitrary failures.
Reference: [21] <author> R. Strong, D. Dolev and F. Cristian. </author> <title> New latency bounds for atomic broadcast. </title> <booktitle> 11th IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: The algorithms of [11] are concerned with fault tolerance rather than timing efficiency, and therefore translate to relatively slow algorithms for our model. In contrast, we concentrate on exact time complexity. Current work also concentrating on the real time complexity of the consensus problem appears in <ref> [21] </ref>. There, process clocks are assumed to be synchronized to within a fixed additive error. In contrast to our results, the results there are stated in terms of process clock time, not absolute time.
Reference: [22] <author> J. L. Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> Vol. 77, No. </volume> <month> 1 (April </month> <year> 1988), </year> <pages> pp. 1-36. </pages>
Reference-contexts: Other work in this area includes the extensive literature on clock synchronization algorithms (see [20] for a survey). Algorithms from <ref> [22] </ref> and the previously mentioned consensus work of [11] include ideas similar to those in our simulation tolerant of arbitrary failures. <p> The partial synchronization works by using a combination of two criteria for advancing to further rounds, one based on elapsed local time and the other based on messages received. A similar technique is used in <ref> [22] </ref> to initiate new rounds of clock resynchronization. Processes are synhro-nized only to the extent that a nonfaulty process does not advance to round r until it has received a round r 1 message from every nonfaulty process.
References-found: 22

