URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/lhopu96.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: filianojfpg@cs.cmu.edu  
Title: Linear Higher-Order Pre-Unification  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213-3891  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We develop an efficient representation and a pre-unification algorithm in the style of Huet for the This extended abstract has been submitted to the Twelfth Annual Symposium on Logic in Computer Science - LICS'97, Warsaw, Poland, June 29th - July 2nd 1997. linear -calculus !ffi&&gt; which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit (&gt;). Applications lie in proof search, logic programming, and logical frameworks based on linear type theories. We also show that, surprisingly, a similar pre-unification algorithm does not exist for certain sublanguages. fl This work was supported by NSF Grant CCR-9303383. The second author was supported by the Alexander-von-Humboldt-Stiftung when working on this paper, during a visit to the Department of Mathematics of the Technical University Darmstadt. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar96] <author> Andrew Barber. </author> <title> Dual intuitionistic linear logic. </title> <type> Technical Report ECS-LFCS-96-347, </type> <institution> Laboratory for Foundations of Computer Sciences, University if Edinburgh, </institution> <year> 1996. </year>
Reference-contexts: Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [HM94] and LLF [CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in <ref> [Bar96] </ref>. Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms.
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system RLF [IP96], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games <ref> [Cer96] </ref>. When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references [CP96]). <p> Note that the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term. Similarly to ! , !ffi&&gt; enjoys a number of highly desirable properties <ref> [Cer96] </ref>. In particular, since every extension introduces commutative conversions, it is the largest linear -calculus for which strong normalization holds and yields unique normal forms. We write Can (M ) for the canonical form of the term M , defined as the -expansion of its fi-normal form. <p> By strong normalization and the Church-Rosser theorem <ref> [Cer96] </ref>, it suffices to compute Can (U 1 ) and Can (U 2 ) and check whether they are syntactically equal (modulo renaming of bound variables).
Reference: [CHP96] <author> Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, March 1996. </address> <publisher> Springer-Verlag LNAI 1050. </publisher>
Reference-contexts: The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum [Mil94], concerns the management of linear context formulas <ref> [CHP96] </ref>. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> As expected, equations among intuitionistic operands are created with an empty linear context (pu iapp). Context splitting in rule pu lapp represents a new form of non-determinism not present in Huet's algorithm. Standard techniques of lazy context management <ref> [CHP96] </ref> can however be used in order to handle it efficiently and deterministically in an actual implementation. A new inherent form of non-determinism arises in the generation of the spine of substitution terms.
Reference: [CP] <author> Iliano Cervesato and Frank Pfenning. </author> <title> Linear higher-order unification. </title> <publisher> Forthcoming. </publisher>
Reference-contexts: More details on the topics covered in this extended abstracts can be found in the forthcoming technical report <ref> [CP] </ref>, which will be available shortly as http://www.cs.cmu.edu/~iliano/LLF/lhou.ps. Our presentation is organized as follows. In Section 2, we define !ffi&&gt; and give an equivalent formulation better suited for our purposes. The pre-unification algorithm is the subject of Section 3. <p> For reasons of space, we omit the typing rules for these judgments <ref> [CP] </ref>, although they will indirectly appear in the inference system for pre-unification. There exists a structural translation of terms in !ffi&&gt; to terms in S !ffi&&gt; , and vice versa [CP]. <p> For reasons of space, we omit the typing rules for these judgments <ref> [CP] </ref>, although they will indirectly appear in the inference system for pre-unification. There exists a structural translation of terms in !ffi&&gt; to terms in S !ffi&&gt; , and vice versa [CP]. Space constraints do not allow presenting this mapping and the proofs of soundness and completeness for the respective typing derivations. <p> We do not show the deduction rules for these judgments. The interested reader can extract them from the non-flexible cases in Figures 2 or consult <ref> [CP] </ref>. Equality checking becomes a unification problem as soon as we admit objects containing logical variables (sometimes called existential variables or meta-variables), standing for unknown terms. <p> It is also non-deterministically complete, i.e., every solution to the original system is an instance of a unifier or pre-unifier which can be found with our procedure. These properties are expressed by 7 the theorems below. Detailed proofs can be found in <ref> [CP] </ref>. We write D :: J if D is a derivation of the judgment J , and [fi]ffi for the result of applying the substitution fi to each equation in ffi.
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [Cer96, CP96] </ref> and the system RLF [IP96], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> Linear terms provide a statically checkable notation for natural deductions [IP96] or sequent derivations <ref> [CP96] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96]. <p> When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references <ref> [CP96] </ref>). Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. <p> be devised for linear sublanguages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [HM94] and LLF <ref> [CP96] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [Bar96]. Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms.
Reference: [DHKP96] <author> Gilles Dowek, Therese Hardin, Claude Kirchner, and Frank Pfenning. </author> <title> Unification via explicit substitutions: The case of higher-order patterns. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <address> Bonn, Germany, </address> <month> September </month> <year> 1996. </year> <note> MIT Press. To appear. </note>
Reference-contexts: The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf [Pfe91] and preliminary experiments we believe that this will be a practical solution when combined with the machinery of explicit substitutions as in <ref> [DHKP96] </ref>. 5 Conclusion and Future Work In this extended abstract, we have studied the problem of higher-order unification in the context of the linear simply typed -calculus !ffi&&gt; .
Reference: [Dug93] <author> Dominic Duggan. </author> <title> Unification with extended patterns. </title> <type> Technical Report CS-93-37, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, </address> <month> July </month> <year> 1993. </year> <month> Revised March </month> <year> 1994 </year> <month> and September </month> <year> 1994. </year>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in <ref> [Dug93] </ref> and [FL96], respectively. The appropriate restrictions of the rules in Figures 2-3 instead implement a general pre-unification procedure for these calculi. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by <ref> [Dug93] </ref> and [FL96] for products to the linear case, leads to a decidable unification problem for !ffi&&gt; .
Reference: [FL96] <author> Roland Fettig and Bernd Lochner. </author> <title> Unification of higher-order patterns in a simply typed lambda-calculus with finite products and terminal type. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 347-361, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in [Dug93] and <ref> [FL96] </ref>, respectively. The appropriate restrictions of the rules in Figures 2-3 instead implement a general pre-unification procedure for these calculi. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by [Dug93] and <ref> [FL96] </ref> for products to the linear case, leads to a decidable unification problem for !ffi&&gt; . On this fragment (which is beyond the scope of the present paper), termination of the pre-unification algorithm in Section 3 is assured if we also incorporate an appropriate occurs-check as in the simply-typed case.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [Gir87] </ref> enriches more traditional logical formalisms with a notion of consumable resource, which provides direct means for expressing and reasoning about mutable state. Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. <p> In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification [Hue75] and linear logic <ref> [Gir87] </ref>. 1 con lvar ; x : A ` x : A ivar ; x: A; ` x : A unit ; ` hi : &gt; (No elimination rule for &gt;) ; ` M : A ; ` N : B pair ; ` hM; N i : A & B
Reference: [Her95] <institution> Hugo Herbelin. Sequents qu'on calcule: de l'interpretation du calcul des sequents comme calcul de lambda-termes et comme calcul de stratgies gagnantes. </institution> <type> PhD thesis, </type> <institution> Universite Paris 7, </institution> <year> 1995. </year>
Reference-contexts: This approach was suggested by an empirical study of higher-order logic programs based on ! terms [MP92] and is reminiscent of the notion of abstract Bohm trees <ref> [Her95] </ref>; its practical merits in our setting are currently assessed in an experimental implementation. The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor.
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli <ref> [HM94] </ref>, Lygon [HP94] and Forum [Mil94], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> such algorithm can be devised for linear sublanguages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the connectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli <ref> [HM94] </ref> and LLF [CP96]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [Bar96]. Its theoretical relevance derives from the fact that it is the biggest linear -calculus that admits unique long fi-normal forms. <p> The inference rules for 2 this judgment are displayed in Figure 1. Deleting the terms that appear in them results in the usual rules for the (! ffi&&gt;) fragment of intuitionistic linear logic, ILL !ffi&&gt; <ref> [HM94] </ref>, in a natural deduction style formulation. !ffi&&gt; and ILL !ffi&&gt; are related by a form of the Curry-Howard isomorphism. Note that the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term.
Reference: [HP94] <author> James Harland and David Pym. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon <ref> [HP94] </ref> and Forum [Mil94], concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. In particular, Huet's pre-unification algorithm <ref> [Hue75] </ref> factorizes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> We discuss new sources of non-determinism, study the unification problem in sublanguages of !ffi&&gt; , and hint at the possibility of a practical implementation in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification <ref> [Hue75] </ref> and linear logic [Gir87]. 1 con lvar ; x : A ` x : A ivar ; x: A; ` x : A unit ; ` hi : &gt; (No elimination rule for &gt;) ; ` M : A ; ` N : B pair ; ` hM; N i
Reference: [IP96] <author> Samin Ishtiaq and David Pym. </author> <title> A relevant analysis of natural deduction, </title> <month> December </month> <year> 1996. </year> <note> Unpublished. </note>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF [Cer96, CP96] and the system RLF <ref> [IP96] </ref>, introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions <ref> [IP96] </ref> or sequent derivations [CP96] in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [CP96] or sequences of moves in games [Cer96].
Reference: [JP76] <author> D. C. Jensen and T. Pietrzykowski. </author> <title> Mechanizing !-order type theory through unification. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 123-171, </pages> <year> 1976. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions <ref> [JP76] </ref>. In particular, Huet's pre-unification algorithm [Hue75] factorizes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [NM88]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> The achievability of algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to <ref> [JP76] </ref> or [Mil89]. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations.
Reference: [Lev96] <author> Jordi Levy. </author> <title> Linear second-order unification. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 332-346, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: An example are Miller's higher-order patterns [Mil89], that have been implemented in the higher-order constraint logic programming language Elf [Pfe91]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated <ref> [Lev96] </ref>. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . We give a pre-unification procedure in the style of Huet and discuss the new sources of non-determinism due to linearity. <p> In conclusion, pre-unification procedures in the sense of Huet are not achievable in the calculi with ffi but without &gt;. 9 Finally, a restricted form of unification in the purely linear calculus ffi has been studied in <ref> [Lev96] </ref>.
Reference: [Mil89] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Proceedings of the International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen, Germany, 1989. </address> <publisher> Springer-Verlag LNAI 475. </publisher>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns <ref> [Mil89] </ref>, that have been implemented in the higher-order constraint logic programming language Elf [Pfe91]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. <p> The achievability of algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to [JP76] or <ref> [Mil89] </ref>. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations. <p> However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections. For ! , this problem has been addressed by Miller's higher-order patterns <ref> [Mil89] </ref>, a static restriction on the occurrences of logical variables which guarantees decidability and most general unifiers. Its dynamic counterpart has been successfully implemented in the higher-order logic programming language Elf [Pfe91].
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [HM94], Lygon [HP94] and Forum <ref> [Mil94] </ref>, concerns the management of linear context formulas [CHP96]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [MP92] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Application and ";" have opposite associativity so that M 1 is the innermost subterm of M while U 1 is outermost in the spine of U . This approach was suggested by an empirical study of higher-order logic programs based on ! terms <ref> [MP92] </ref> and is reminiscent of the notion of abstract Bohm trees [Her95]; its practical merits in our setting are currently assessed in an experimental implementation.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Wash-ington, August 1988. </address> <publisher> MIT Press. </publisher> <pages> 11 </pages>
Reference-contexts: Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [JP76]. In particular, Huet's pre-unification algorithm [Hue75] factorizes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages <ref> [NM88] </ref>. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [Mil89], that have been implemented in the higher-order constraint logic programming language Elf [Pfe91]. <p> clearly apply also in this setting, but we have no result about the decidability of higher-order unification in this fragment. 4.3 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle [NP92] and logic programming languages such as Prolog <ref> [NM88] </ref> and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [NP92] <editor> Tobias Nipkow and Lawrence C. Paulson. Isabelle-91. In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <address> Saratoga Springs, NY, </address> <year> 1992. </year> <note> Springer-Verlag LNAI 607. System abstract. </note>
Reference-contexts: The above counterexamples clearly apply also in this setting, but we have no result about the decidability of higher-order unification in this fragment. 4.3 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle <ref> [NP92] </ref> and logic programming languages such as Prolog [NM88] and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [Mil89], that have been implemented in the higher-order constraint logic programming language Elf <ref> [Pfe91] </ref>. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [Lev96]. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . <p> For ! , this problem has been addressed by Miller's higher-order patterns [Mil89], a static restriction on the occurrences of logical variables which guarantees decidability and most general unifiers. Its dynamic counterpart has been successfully implemented in the higher-order logic programming language Elf <ref> [Pfe91] </ref>. Unfortunately, an analogous restriction for !ffi&&gt; which would cover the situations arising in practice does not admit most general unifiers. <p> The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf <ref> [Pfe91] </ref> and preliminary experiments we believe that this will be a practical solution when combined with the machinery of explicit substitutions as in [DHKP96]. 5 Conclusion and Future Work In this extended abstract, we have studied the problem of higher-order unification in the context of the linear simply typed -calculus !ffi&&gt;
Reference: [SG89] <author> Wayne Snyder and Jean H. Gallier. </author> <title> Higher order unification revisited: Complete sets of transformations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8(1-2):101-140, </volume> <year> 1989. </year> <month> 12 </month>
Reference-contexts: Proof: By induction on the structure of X . 2 Note that it is not difficult to generalize this procedure to full unification (as, for example, in <ref> [SG89] </ref>), although we fail to see its practical value.
References-found: 23

