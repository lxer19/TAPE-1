URL: http://www.cs.gatech.edu/reverse/repository/CtoSC.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Title: Reverse Engineering with a CASE Tool  
Author: Bret Johnson Research advisors: Spencer Rugaber and Rich LeBlanc 
Date: October 6, 1994  
Abstract: We examine using a CASE tool, Interactive Development Environment's Software through Pictures (StP), to support reverse engineering. We generate structure charts in StP from the automated analysis of C source code. The advantages of this approach are that one can use the CASE tool's support for drawing, linking, and modifying pictorial notations for program design in order to make it easier to construct a reverse engineering tool. Additionally, one can then use the design rep resentations with the CASE tool to do reengineering for maintenance.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Johnson, </author> <title> "Yacc: Yet Another Compiler-Compiler," </title> <institution> Bell Laboratories, </institution> <year> 1979. </year>
Reference-contexts: To better illustrate the actions of the various phases of the tool, we show the of the intermediate text files that are generated by the different phases when analyzing the simple C program in Figure 1. The first phase uses an enhanced version the parser generator Yacc <ref> [1] </ref> 2 int a, b; main () - init (); process (); - init () - init_a (); init_b (); - init_a () - - init_b () - - process () - for (i = 0; i &lt; a; ++i) printf ("b == %d"n", b); - 3 DCL:example.c:0:&lt;1,5&gt;-<1,5&gt;:a DCL:example.c:0:&lt;1,8&gt;-<1,8&gt;:b FDC:example.c:0:&lt;3,1&gt;-<3,4&gt;:main FRF:example.c:2:&lt;5,3&gt;-<5,6&gt;:init
Reference: [2] <author> E. White, J. Callahan, and J. Purtilo, </author> <title> "The NewYacc User's Manual," </title> <institution> University of Maryland. </institution>
Reference-contexts: (); - init_a () - - init_b () - - process () - for (i = 0; i &lt; a; ++i) printf ("b == %d"n", b); - 3 DCL:example.c:0:&lt;1,5&gt;-<1,5&gt;:a DCL:example.c:0:&lt;1,8&gt;-<1,8&gt;:b FDC:example.c:0:&lt;3,1&gt;-<3,4&gt;:main FRF:example.c:2:&lt;5,3&gt;-<5,6&gt;:init FRF:example.c:2:&lt;6,3&gt;-<6,9&gt;:process FDC:example.c:0:&lt;10,1&gt;-<10,4&gt;:init FRF:example.c:2:&lt;12,3&gt;-<12,8&gt;:init_a FRF:example.c:2:&lt;13,3&gt;-<13,8&gt;:init_b FDC:example.c:0:&lt;17,1&gt;-<17,6&gt;:init_a DEF:example.c:2:&lt;19,3&gt;-<19,3&gt;:a FDC:example.c:0:&lt;23,1&gt;-<23,6&gt;:init_b DEF:example.c:2:&lt;25,3&gt;-<25,3&gt;:b FDC:example.c:0:&lt;29,1&gt;-<29,7&gt;:process DCL:example.c:2:&lt;31,9&gt;-<31,9&gt;:i DEF:example.c:2:&lt;34,8&gt;-<34,8&gt;:i REF:example.c:2:&lt;34,15&gt;-<34,15&gt;:i REF:example.c:2:&lt;34,19&gt;-<34,19&gt;:a REF:example.c:2:&lt;34,24&gt;-<34,24&gt;:i FRF:example.c:2:&lt;35,5&gt;-<35,10&gt;:printf REF:example.c:2:&lt;35,25&gt;-<35,25&gt;:b called NewYacc <ref> [2] </ref>. NewYacc contains a number of features which make it easy to write a source code analyzer. These features are detailed in [2]. We augmented the C grammar provided with NewYacc to output information concerning the definition of and references to functions, variables, and labels. <p> ("b == %d"n", b); - 3 DCL:example.c:0:&lt;1,5&gt;-<1,5&gt;:a DCL:example.c:0:&lt;1,8&gt;-<1,8&gt;:b FDC:example.c:0:&lt;3,1&gt;-<3,4&gt;:main FRF:example.c:2:&lt;5,3&gt;-<5,6&gt;:init FRF:example.c:2:&lt;6,3&gt;-<6,9&gt;:process FDC:example.c:0:&lt;10,1&gt;-<10,4&gt;:init FRF:example.c:2:&lt;12,3&gt;-<12,8&gt;:init_a FRF:example.c:2:&lt;13,3&gt;-<13,8&gt;:init_b FDC:example.c:0:&lt;17,1&gt;-<17,6&gt;:init_a DEF:example.c:2:&lt;19,3&gt;-<19,3&gt;:a FDC:example.c:0:&lt;23,1&gt;-<23,6&gt;:init_b DEF:example.c:2:&lt;25,3&gt;-<25,3&gt;:b FDC:example.c:0:&lt;29,1&gt;-<29,7&gt;:process DCL:example.c:2:&lt;31,9&gt;-<31,9&gt;:i DEF:example.c:2:&lt;34,8&gt;-<34,8&gt;:i REF:example.c:2:&lt;34,15&gt;-<34,15&gt;:i REF:example.c:2:&lt;34,19&gt;-<34,19&gt;:a REF:example.c:2:&lt;34,24&gt;-<34,24&gt;:i FRF:example.c:2:&lt;35,5&gt;-<35,10&gt;:printf REF:example.c:2:&lt;35,25&gt;-<35,25&gt;:b called NewYacc <ref> [2] </ref>. NewYacc contains a number of features which make it easy to write a source code analyzer. These features are detailed in [2]. We augmented the C grammar provided with NewYacc to output information concerning the definition of and references to functions, variables, and labels. Only about 20 lines of the C grammar file needed to be modified and a few auxiliary functions written.
Reference: [3] <author> A. Aho, B. Kernighan, and P. Weinberger, </author> <title> "Awk A Pattern Scanning and Processing Language," </title> <institution> Bell Laboratories. </institution>
Reference-contexts: The output also tells the file name and line and column numbers where each identifier appears and the level of nesting of that identifier's scope. The second phase uses Awk <ref> [3] </ref>, a programming language especially good for parsing simple text file formats and scanning for patterns.
Reference: [4] <author> Interactive Development Environments, </author> <title> Software through Pictures User Manual, </title> <booktitle> 1988. </booktitle> <pages> 10 </pages>
Reference-contexts: This output for our continuing example is in Figure 4. A description of the StP structure chart file format can be found on pages 9-39 - 9-41 of <ref> [4] </ref>. The reverse engineer has some control over the generation of the structure chart: he can specify predefined subprograms and subprograms to be ignored.
References-found: 4

