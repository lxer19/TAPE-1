URL: http://www.cc.gatech.edu/computing/Telecomm/people/Phd/rhk/papers/ps/ulpaa.ps
Refering-URL: http://www.cc.gatech.edu/computing/Telecomm/people/Phd/rhk.html
Root-URL: 
Email: fcalvert,robink,rdkg@cc.gatech.edu  
Title: An Extensible End-to-End Protocol and Framework  
Author: K. L. Calvert R. H. Kravets R. D. Krupczak 
Address: Atlanta, Georgia, USA  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: We describe a framework for composing end-to-end protocol functions. The framework comprises: a generic model of protocol processing; a metaheader protocol supporting per-packet configuration of protocol function and efficient demultiplexing of incoming data units; and an extensible set of modular protocol functions. This paper describes the pieces of the framework and motivates some of the design decisions.
Abstract-found: 1
Intro-found: 1
Reference: [AP93] <author> M. B. Abbott and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Because the variety of applications we envision includes those for which performance (especially bandwidth) is important, the composition mechanism of t is friendly to performance-oriented implementation techniques, in particular to the integration of data-handling functions <ref> [AP93, CT90] </ref> and parallel processing [ZT93, NYKT94, Bjo94]. Thus, in addition to being a protocol that defines the form and meaning of "bits on the wire", t is also a framework, which defines the possible interactions between protocol functions. <p> The need for this capability has been noted by others <ref> [Haa91, AP93] </ref>. In t , protocol functions update state information (and the user is notified of incoming data) according to a two-step process, where every function must agree on the acceptability of the received data unit, and only then, when all are agreed, do they all commit their state updates.
Reference: [Bjo94] <author> Mats Bjorkman. </author> <title> The xx-kernel parallel protocol execution environment. </title> <type> Technical Report Draft, </type> <institution> Department of Computer Science, Uppsala University, Sweeden, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Because the variety of applications we envision includes those for which performance (especially bandwidth) is important, the composition mechanism of t is friendly to performance-oriented implementation techniques, in particular to the integration of data-handling functions [AP93, CT90] and parallel processing <ref> [ZT93, NYKT94, Bjo94] </ref>. Thus, in addition to being a protocol that defines the form and meaning of "bits on the wire", t is also a framework, which defines the possible interactions between protocol functions. <p> Some of these have attempted parallel implementations to improve performance <ref> [LKAS93b, Bjo94, Zit91] </ref>. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [Cal93] <author> Kenneth L. Calvert. </author> <title> Beyond layering: Modularity considerations for protocol architectures. </title> <booktitle> In Proceedings International Conference on Network Protocols, </booktitle> <address> San Francisco, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: The distinctive feature of t is that it abandons the traditional layered encapsulation approach to protocol composition, in order to support performance-enhancing techniques like those just discussed. The basic idea is to replace layering with an explicit mechanism (a meta-protocol) for composing functions <ref> [Cal93] </ref>, while also providing a single, uniform multiplexing function for all upper-layer protocols. 1 We use the term "protocol function" in a manner similar to Tantawy and Zitterbart [ZT93], to denote an "atomic" unit of functionality. 2 3 Design Overview The primary design objective of t is to provide two mechanisms
Reference: [CT90] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In ACM SIGCOMM-1990 Symposium, </booktitle> <pages> pages 200-208, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Because the variety of applications we envision includes those for which performance (especially bandwidth) is important, the composition mechanism of t is friendly to performance-oriented implementation techniques, in particular to the integration of data-handling functions <ref> [AP93, CT90] </ref> and parallel processing [ZT93, NYKT94, Bjo94]. Thus, in addition to being a protocol that defines the form and meaning of "bits on the wire", t is also a framework, which defines the possible interactions between protocol functions. <p> As Feldmeier has shown, however, for most reasonable models of state storage, it is faster to retrieve state information all at once [Fel90]. Unfortunately, with traditional layering, this is difficult, especially when one layer may transform the header of another. Clark and Tennenhouse <ref> [CT90] </ref> identified poorly-structured layered implementations as a performance bottleneck because they may require separate passes over the data for each layer, an expensive approach in modern computer architectures. They proposed integrated layer processing, in which all data-touching operations are performed in a single pass over the data. <p> Moreover, this form of integration hinders certain other optimizations, such as dynamic inclusion and exclusion of protocol functions [OP92, Zit91]. To get around this, it has been proposed that different functions be "next to, rather than on top of" each other <ref> [CT90] </ref>. Another key observation [CT90] is that whenever data "comes to rest" inside the protocol stack |for re-sequencing, fragment reassembly, or whatever| this "lost time" can never be made up if the protocol stack is the bottleneck between the application and the network. <p> Moreover, this form of integration hinders certain other optimizations, such as dynamic inclusion and exclusion of protocol functions [OP92, Zit91]. To get around this, it has been proposed that different functions be "next to, rather than on top of" each other <ref> [CT90] </ref>. Another key observation [CT90] is that whenever data "comes to rest" inside the protocol stack |for re-sequencing, fragment reassembly, or whatever| this "lost time" can never be made up if the protocol stack is the bottleneck between the application and the network. <p> The generic interface to protocol functions supports the principles of Application Layer Framing <ref> [CT90] </ref> by assuming that data does not "stop" within t , either on the way in from the network or on the way out from the user.
Reference: [Fel90] <author> David C. Feldmeier. </author> <title> Multiplexing issues in communication system design. </title> <booktitle> In Proceedings ACM SIGCOMM '90 Symposium, Philadelphia, </booktitle> <pages> pages 209-219, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Section 4 presents some details of the metaheader protocol and the generic interface. Section 5 offers some concluding remarks. 2 Related Work This section presents the main ideas that have influenced the design of t . Several researchers have identified layered multiplexing as an impediment to protocol performance <ref> [Fel90, Ten89] </ref>. In addition to detrimental effects on flow and congestion control, layered multiplexing forces the state information relevant to an incoming data unit to be retrieved sequentially, one protocol at a time. <p> As Feldmeier has shown, however, for most reasonable models of state storage, it is faster to retrieve state information all at once <ref> [Fel90] </ref>. Unfortunately, with traditional layering, this is difficult, especially when one layer may transform the header of another. Clark and Tennenhouse [CT90] identified poorly-structured layered implementations as a performance bottleneck because they may require separate passes over the data for each layer, an expensive approach in modern computer architectures.
Reference: [Fel93] <author> David C. Feldmeier. </author> <title> A framework of architectural concepts for high-speed communication systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(4) </volume> <pages> 480-488, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: As such, t is designed to accommodate functions that reside between two natural layer boundaries: above the (inter)network layer and below the application. In terms of Feldmeier's taxonomy of architectural concepts for high performance <ref> [Fel93] </ref>, t supports reduced processing requirements through separation of control and data functions, configurability, and elimination of duplicated functionality. It also supports increased processing availability, via parallel implementation and data-handling integration. 1 The remainder of this paper is organized as follows.
Reference: [FRS93] <author> M. Fry, A. Richards, and A. Seneviratne. </author> <title> Framework for implementing the next generation of transport protocols. </title> <booktitle> In Proceedings Fourth International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <address> Lancaster, England, </address> <year> 1993. </year>
Reference-contexts: Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [fS86] <author> International Organization for Standardization. </author> <title> Connection-oriented transport protocol specification, </title> <year> 1986. </year>
Reference-contexts: Together, these two pieces of information determine how t handles the message. * The state retrieval information (SRI) is used by the recipient to locate any state information relevant to this data unit. The SRI is similar in function to the reference number used in the ISO transport protocol <ref> [fS86] </ref>. It is chosen by the recipient and communicated to the sender (s) either at connection setup time or through some other channel. An SRI value of 0 indicates that the data unit is not associated with any existing state information.
Reference: [Haa91] <author> Zygmunt Haas. </author> <title> A protocol structure for high-speed communication over broadband ISDN. </title> <journal> IEEE Network Magazine, </journal> <pages> pages 64-70, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation. <p> The need for this capability has been noted by others <ref> [Haa91, AP93] </ref>. In t , protocol functions update state information (and the user is notified of incoming data) according to a two-step process, where every function must agree on the acceptability of the received data unit, and only then, when all are agreed, do they all commit their state updates. <p> There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
Reference: [LKAS93a] <author> Bert Lindgren, Bobby Krupczak, Mostafa Ammar, and Karsten Schwan. </author> <title> An architecture and toolkit for parallel and configurable protocols. </title> <booktitle> In Proceedings of the International Conference on Network Protocols (ICNP-93), </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [LKAS93b] <author> Bert Lindgren, Bobby Krupczak, Mostafa Ammar, and Karsten Schwan. </author> <title> Parallelism and configurability in high performance protocol architectures. </title> <booktitle> In Proceedings of the Second Workshop on High-Performance Communications, </booktitle> <month> September </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: Some of these have attempted parallel implementations to improve performance <ref> [LKAS93b, Bjo94, Zit91] </ref>. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [NYKT94] <author> Erich M. Nahum, David J. Yates, James F. Kurose, and Don Towsley. </author> <title> Performance issues in parallelized network protocols. </title> <booktitle> In Proceedings of the First Symposium on Operating System Design and Implementation. </booktitle> <institution> Department of Computer Science, University of Massachusetts, </institution> <year> 1994. </year>
Reference-contexts: Because the variety of applications we envision includes those for which performance (especially bandwidth) is important, the composition mechanism of t is friendly to performance-oriented implementation techniques, in particular to the integration of data-handling functions [AP93, CT90] and parallel processing <ref> [ZT93, NYKT94, Bjo94] </ref>. Thus, in addition to being a protocol that defines the form and meaning of "bits on the wire", t is also a framework, which defines the possible interactions between protocol functions.
Reference: [OP92] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10 </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Again, when the header of a higher layer is treated as data by a lower layer that performs encryption or other transformations, this may not be possible. Moreover, this form of integration hinders certain other optimizations, such as dynamic inclusion and exclusion of protocol functions <ref> [OP92, Zit91] </ref>. To get around this, it has been proposed that different functions be "next to, rather than on top of" each other [CT90]. <p> There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
Reference: [Pos80] <author> J. Postel. </author> <title> User Datagram Protocol. Network Information Center, Internet Request for Comments No. </title> <type> 768, </type> <month> August </month> <year> 1980. </year>
Reference-contexts: It can provide a range of services, from simple best-effort datagram to reliable byte stream, including a variety of options for encryption. We are currently implementing t . Our initial goal is a datagram service capable of throughput rates comparable to those of decent UDP <ref> [Pos80] </ref> implementations. We plan to add functions to t to support a variety of applications, including multimedia and distributed simulation.
Reference: [PPVW93] <author> Thomas Plagemann, Bernhard Plattner, Martin Vogt, and Thomas Walter. </author> <title> Modules as building blocks for protocol configuration. </title> <booktitle> In Proceedings of the International Conference on Network Protocols (ICNP-93). </booktitle> <institution> Swiss Federal Institute of Technology Zurich, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation. <p> There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
Reference: [PS91] <author> Thomas F. La Porta and Mischa Schwartz. </author> <title> Architectures, features, and implementation of high-speed transport protocols. </title> <journal> IEEE Network Magazine, </journal> <volume> 4(2) </volume> <pages> 14-22, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [PS93] <author> Thomas F. La Porta and Mischa Schwartz. </author> <title> The multistream protocol: A highly flexible high-speed transport protocol. </title> <journal> IEEE Journal on Selected Areas of Communications, </journal> <volume> 11(4) </volume> <pages> 519-530, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
Reference: [SBS93] <author> Douglas C. Schmidt, Donald F. Box, and Tatsuya Suda. </author> <title> Adaptive: A dynamically assembled protocol transformation, integration, and evaluation environment. </title> <journal> Journal of concurrency: Practice and Experience, </journal> <month> June </month> <year> 1993. </year>
Reference-contexts: There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
Reference: [Ten89] <author> David L. Tennenhouse. </author> <title> Layered multiplexing considered harmful. </title> <booktitle> In Proceedings of IFIP Workshop on Protocols for High-Speed Networks, </booktitle> <pages> pages 143-148, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Section 4 presents some details of the metaheader protocol and the generic interface. Section 5 offers some concluding remarks. 2 Related Work This section presents the main ideas that have influenced the design of t . Several researchers have identified layered multiplexing as an impediment to protocol performance <ref> [Fel90, Ten89] </ref>. In addition to detrimental effects on flow and congestion control, layered multiplexing forces the state information relevant to an incoming data unit to be retrieved sequentially, one protocol at a time.
Reference: [Zit91] <author> Martina Zitterbart. </author> <title> High-speed transport components. </title> <journal> IEEE Network, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Again, when the header of a higher layer is treated as data by a lower layer that performs encryption or other transformations, this may not be possible. Moreover, this form of integration hinders certain other optimizations, such as dynamic inclusion and exclusion of protocol functions <ref> [OP92, Zit91] </ref>. To get around this, it has been proposed that different functions be "next to, rather than on top of" each other [CT90]. <p> Protocol configurability, the idea that an application should be able to select from a "menu" exactly those protocol functions 1 it requires in order to reduce overhead and increase performance, has been addressed in a number of recent projects <ref> [Haa91, Zit91, PPVW93, PS91, LKAS93a, FRS93] </ref>. Some of these have attempted parallel implementations to improve performance [LKAS93b, Bjo94, Zit91]. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation. <p> Some of these have attempted parallel implementations to improve performance <ref> [LKAS93b, Bjo94, Zit91] </ref>. To our knowledge, all of these approaches focus on a closed set of protocol functions, in the context of traditional layered encapsulation.
Reference: [ZT93] <author> Martina Zitterbart and Ahmed N. Tantawy. </author> <title> A model for flexible high-performance communication subsystems. </title> <journal> IEEE Journal on Selected Areas of Communications, </journal> <volume> 11(4) </volume> <pages> 507-518, </pages> <month> May </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Because the variety of applications we envision includes those for which performance (especially bandwidth) is important, the composition mechanism of t is friendly to performance-oriented implementation techniques, in particular to the integration of data-handling functions [AP93, CT90] and parallel processing <ref> [ZT93, NYKT94, Bjo94] </ref>. Thus, in addition to being a protocol that defines the form and meaning of "bits on the wire", t is also a framework, which defines the possible interactions between protocol functions. <p> The basic idea is to replace layering with an explicit mechanism (a meta-protocol) for composing functions [Cal93], while also providing a single, uniform multiplexing function for all upper-layer protocols. 1 We use the term "protocol function" in a manner similar to Tantawy and Zitterbart <ref> [ZT93] </ref>, to denote an "atomic" unit of functionality. 2 3 Design Overview The primary design objective of t is to provide two mechanisms (protocol function composition and multiplexing) in a manner that supports various performance-enhancing techniques, while preserving modularity in some form. <p> There are, however certain functions that the t infrastructure needs to deal with in a special way; some of these are considered in the next section. 5 3.3 Protocol Functions and t We envision communication services implemented by composing atomic single-function protocols from a "menu of functionality", as have others <ref> [OP92, ZT93, Haa91, PPVW93, PS93, SBS93] </ref>. For example, a service for a transaction-oriented application could be implemented with a soft-state connection management function, a sequence numbering function, and two different reliability functions (one for request retransmission and one for response error detection and retransmission).
References-found: 21

