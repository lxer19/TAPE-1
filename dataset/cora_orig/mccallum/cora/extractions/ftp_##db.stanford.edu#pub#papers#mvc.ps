URL: ftp://db.stanford.edu/pub/papers/mvc.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: fzhuge,wiener,hectorg@cs.stanford.edu  
Title: Multiple View Consistency for Data Warehousing  
Author: Yue Zhuge, Janet L. Wiener and Hector Garcia-Molina 
Web: http://db.stanford.edu/pub/zhuge/1996/mvc.ps  
Address: Stanford, CA 94305-2140, USA  
Affiliation: Computer Science Department Stanford University  
Abstract: A data warehouse stores integrated information from multiple distributed data sources. In effect, the warehouse stores materialized views over the source data. The problem of ensuring data consistency at the warehouse can be divided into two components: ensuring that each view reflects a consistent state of the base data, and ensuring that multiple views are mutually consistent. In this paper we study the latter problem, that of guaranteeing multiple view consistency (MVC). We identify and define formally three layers of consistency for materialized views in a distributed environment. We present a scalable architecture for consistently handling multiple views in a data warehouse, which we have implemented in the WHIPS(WareHousing Information Project at Stanford) prototype. Finally, we develop simple, scalable, algorithms for achieving MVC at a warehouse. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Blakeley, P.-A. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 61-71, </pages> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: However, after time t 2 , V 1 reflects the new state of relation S but V 2 does not. The two views are not consistent with each other. Notice that computing consistent values for each view, e.g., inserting tuple <ref> [1; 2; 3] </ref> into V 1 , is not as simple as it may first appear. <p> However, most of these definitions can be adapted to obtain the levels of consistency we define in the next section for single views. There are many view maintenance algorithms, both centralized and distributed <ref> [1, 5, 3, 13] </ref>. In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm. <p> Assume the merge process first receives REL i for i = 1; 2; 3. Then it receives AL 1 3 to update V 1 for both U 1 and U 3 , i.e., there is no separate AL 1 1 . At this point, SPA makes VUT <ref> [3; 1] </ref>:color equal to red. If we do not make VUT [1; 1]:color red too, then we will never apply row 1, so let us assume we do make VUT [1; 1]:color red. <p> Then it receives AL 1 3 to update V 1 for both U 1 and U 3 , i.e., there is no separate AL 1 1 . At this point, SPA makes VUT [3; 1]:color equal to red. If we do not make VUT <ref> [1; 1] </ref>:color red too, then we will never apply row 1, so let us assume we do make VUT [1; 1]:color red. Later, the merge process receives all other ALs corresponding to U 1 and U 2 , as shown in the table entries below. <p> At this point, SPA makes VUT [3; 1]:color equal to red. If we do not make VUT <ref> [1; 1] </ref>:color red too, then we will never apply row 1, so let us assume we do make VUT [1; 1]:color red. Later, the merge process receives all other ALs corresponding to U 1 and U 2 , as shown in the table entries below. At this time, SPA would apply rows 1 and 2 because all entries are either red or black. <p> In the above Example 4, when the merge process receives AL 1 3 , it fills in the state of entry VUT <ref> [1; 1] </ref>:state = 3. This shows that U 1 is intertwined with U 3 . At this time, even if all other actions corresponding to U 1 have been received, they cannot be applied unless all actions in W T 3 can be applied as well. <p> At time t 1 , AL 2 1 is received. Since VUT <ref> [1; 1] </ref>:color = white, P rocessRow (1) returns f alse. No views can be updated at this time. At time t 2 , P rocessRow (3) returns f alse and no views can be updated.
Reference: [2] <author> Y. Breitbart, H. Garcia-Molina, and A. Silberschatz. </author> <title> Overview of multidatabase transaction management. </title> <journal> VLDB Journal, </journal> <volume> 1(2) </volume> <pages> 181-239, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: At t 1 , a tuple <ref> [2; 3] </ref> is inserted into S. At t 2 , changes to V 1 are computed (by joining tuple [2; 3] with relation R) and the result is inserted into view V 1 . <p> At t 1 , a tuple <ref> [2; 3] </ref> is inserted into S. At t 2 , changes to V 1 are computed (by joining tuple [2; 3] with relation R) and the result is inserted into view V 1 . At t 3 , changes to V 2 are computed and the result is inserted into view V 2 . For both V 1 and V 2 , the above view maintenance steps are correct. <p> However, after time t 2 , V 1 reflects the new state of relation S but V 2 does not. The two views are not consistent with each other. Notice that computing consistent values for each view, e.g., inserting tuple <ref> [1; 2; 3] </ref> into V 1 , is not as simple as it may first appear. <p> A delta computation not only takes time but it may be intertwined with subsequent updates. For instance, in Example 1, in between times t 1 and t 2 we computed the join of the new S tuple <ref> [2; 3] </ref> with R. If R is updated before we read it, we may get fewer or more tuples than what we wanted. <p> In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm. Finally, in a multi-database system <ref> [2, 9] </ref>, updating the global view is within the same global transaction as reading source base data and therefore multiple views can be updated consistently in a single global transaction. We consider a more loosely coupled system where data sources are autonomous.
Reference: [3] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 328-339, </pages> <address> San Jose, California, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: At t 1 , a tuple <ref> [2; 3] </ref> is inserted into S. At t 2 , changes to V 1 are computed (by joining tuple [2; 3] with relation R) and the result is inserted into view V 1 . <p> At t 1 , a tuple <ref> [2; 3] </ref> is inserted into S. At t 2 , changes to V 1 are computed (by joining tuple [2; 3] with relation R) and the result is inserted into view V 1 . At t 3 , changes to V 2 are computed and the result is inserted into view V 2 . For both V 1 and V 2 , the above view maintenance steps are correct. <p> However, after time t 2 , V 1 reflects the new state of relation S but V 2 does not. The two views are not consistent with each other. Notice that computing consistent values for each view, e.g., inserting tuple <ref> [1; 2; 3] </ref> into V 1 , is not as simple as it may first appear. <p> A delta computation not only takes time but it may be intertwined with subsequent updates. For instance, in Example 1, in between times t 1 and t 2 we computed the join of the new S tuple <ref> [2; 3] </ref> with R. If R is updated before we read it, we may get fewer or more tuples than what we wanted. <p> However, most of these definitions can be adapted to obtain the levels of consistency we define in the next section for single views. There are many view maintenance algorithms, both centralized and distributed <ref> [1, 5, 3, 13] </ref>. In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm. <p> Assume the merge process first receives REL i for i = 1; 2; 3. Then it receives AL 1 3 to update V 1 for both U 1 and U 3 , i.e., there is no separate AL 1 1 . At this point, SPA makes VUT <ref> [3; 1] </ref>:color equal to red. If we do not make VUT [1; 1]:color red too, then we will never apply row 1, so let us assume we do make VUT [1; 1]:color red.
Reference: [4] <author> A. Gupta, H. Jagadish, and I. Mumick. </author> <title> Data integration using self-maintainable views. </title> <booktitle> In EDBT, </booktitle> <year> 1996. </year>
Reference-contexts: The two sub-views must be consistent with each other whenever V is computed. Auxiliary views may also be stored to guarantee view self-maintainability <ref> [4, 11] </ref>. The key problems in keeping multiple views consistent at the warehouse are as follows. 1. One source update transaction may invoke a set of actions on multiple warehouse views, as we saw in Example 1. These actions must be applied at the warehouse as an atomic unit.
Reference: [5] <author> A. Gupta and I. Mumick. </author> <title> Maintenance of materialized views: Problems, techniques, </title> <journal> and applications. IEEE Data Engineering Bulletin, Special Issue on Materialized Views and Data Warehousing, </journal> <volume> 18(2) </volume> <pages> 3-18, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: However, most of these definitions can be adapted to obtain the levels of consistency we define in the next section for single views. There are many view maintenance algorithms, both centralized and distributed <ref> [1, 5, 3, 13] </ref>. In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm.
Reference: [6] <author> R. Hull and G. Zhou. </author> <title> A framework for supporting data integration using the materialized and virtual approaches. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 481-492, </pages> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Clearly, this does not allow for any concurrency, and given Problem 2 above, is not acceptable in a high update rate environment. However, note that this sequential approach to the MVC problem is taken (by default) by many current proposed view maintenance algorithms, e.g., <ref> [6] </ref>. 1.2 Merge process to enforce MVC Instead, we propose an architecture that allows as much parallelism as possible while still guaranteeing a correct solution to the MVC problem. Our architecture is shown in Figure 1. <p> In our previous papers, [16] and [17], we defined single view consistency in a data warehousing environment. Hull and Zhou also defined single view consistency in <ref> [6] </ref> for the Squirrel system, a data warehouse that materializes intermediate views and uses incremental view maintenance. In the Squirrel system, it is possible to achieve MVC by sequencing the propagation of each source update.
Reference: [7] <author> N. C. J.A. Blakeley and P.-A. Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <booktitle> In VLDB, </booktitle> <pages> pages 457-466, </pages> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Then it can include in REL i all views that use R in their definition. We could be more discerning by using selection conditions in the view definitions to rule out irrelevant updates <ref> [7] </ref>. Other optimizations can also be done but are not discussed here. 3. The integrator sends REL i to the merge process. The subscript i is implicitly sent, so that the merge process knows to which update REL i refers.
Reference: [8] <author> W. Labio, D. Quass, and B. Adelberg. </author> <title> Physical database design for data warehousing. </title> <booktitle> In ICDE, </booktitle> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: It is also important to note that MVC is required by some view maintenance algorithms. For example, in the multiple view maintenance problem described in <ref> [12, 8] </ref>, auxiliary views are stored in order to maintain primary views efficiently. For example, in order to maintain V = R ./ S ./ T , the algorithm might choose (according to some heuristic) to materialize relations R ./ S and S ./ T and compute V from them.
Reference: [9] <author> W. Litwin, L. Mark, and N. Roussopoulos. </author> <title> Interoperability of multiple autonomous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 267-293, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm. Finally, in a multi-database system <ref> [2, 9] </ref>, updating the global view is within the same global transaction as reading source base data and therefore multiple views can be updated consistently in a single global transaction. We consider a more loosely coupled system where data sources are autonomous.
Reference: [10] <author> D. Lomet and J. Widom, </author> <title> editors. Special Issue on Materialized Views and Data Warehousing, </title> <journal> IEEE Data Engineering Bulletin 18(2), </journal> <month> June </month> <year> 1995. </year>
Reference-contexts: Data at the warehouse are usually read-only; they can be seen as materialized views defined over base data at the sources <ref> [10] </ref>. When base data at sources change, views at the warehouse need to be updated accordingly.
Reference: [11] <author> D. Quass, A. Gupta, I. Mumick, and J. Widom. </author> <title> Making views self-maintainable for data warehousing. </title> <booktitle> In PDIS, </booktitle> <address> Miami Beach, Florida, </address> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: The two sub-views must be consistent with each other whenever V is computed. Auxiliary views may also be stored to guarantee view self-maintainability <ref> [4, 11] </ref>. The key problems in keeping multiple views consistent at the warehouse are as follows. 1. One source update transaction may invoke a set of actions on multiple warehouse views, as we saw in Example 1. These actions must be applied at the warehouse as an atomic unit.
Reference: [12] <author> K. A. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Materialized view maintenance and integrity constraint checking: Trading space for time. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 447-458, </pages> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: It is also important to note that MVC is required by some view maintenance algorithms. For example, in the multiple view maintenance problem described in <ref> [12, 8] </ref>, auxiliary views are stored in order to maintain primary views efficiently. For example, in order to maintain V = R ./ S ./ T , the algorithm might choose (according to some heuristic) to materialize relations R ./ S and S ./ T and compute V from them.
Reference: [13] <author> M. Staudt and M. Jarke. </author> <title> Incremental maintenance of externally materialized views. </title> <booktitle> In VLDB, </booktitle> <pages> pages 75-86, </pages> <address> Bombay, India, </address> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: The warehouse then applies these changes to the views. Incremental view maintenance typically out-performs re-computation in cases where the volume of source data is large, source data is unavailable, or no down time is permitted at the warehouse for recomputation <ref> [16, 13] </ref>. In this paper we focus on maintaining data consistency at the warehouse as it is incrementally maintained. Intuitively, consistency means that the warehouse state makes sense, that is, that it reflects (e.g., is a copy or summary of) an actual source state at some recent time. <p> However, most of these definitions can be adapted to obtain the levels of consistency we define in the next section for single views. There are many view maintenance algorithms, both centralized and distributed <ref> [1, 5, 3, 13] </ref>. In our system, each view manager may implement any of these existing algorithms. The merge process only needs to know the consistency level provided by each view manager so that it can run the proper merge algorithm.
Reference: [14] <author> G. Wiederhold. </author> <title> Mediators in the architecture of future information systems. </title> <journal> IEEE Computer, </journal> <volume> 25(3) </volume> <pages> 38-49, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction A data warehouse stores integrated information from multiple distributed data sources. It can be used for storing cleaned, summarized, analytical data; storing historical data or backup data; or caching query results for fast query response time, e.g., in a mediation system <ref> [14] </ref>. Data at the warehouse are usually read-only; they can be seen as materialized views defined over base data at the sources [10]. When base data at sources change, views at the warehouse need to be updated accordingly.
Reference: [15] <author> J. Wiener, H. Gupta, W. Labio, Y. Zhuge, H. Garcia-Molina, and J. Widom. </author> <title> A system prototype for warehouse view maintenance. </title> <booktitle> In Workshop on Materialized Views, </booktitle> <pages> pages 26-33, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In this architecture, each view is managed by a separate concurrent process, increasing concurrency and easily allowing different algorithms for materializing each view. This architecture is implemented in our WHIPS (WareHousing Information Project at Stan ford) warehouse prototype <ref> [15] </ref>. * We develop simple, scalable algorithms for achieving MVC at a warehouse. The algorithms coordinate concurrent view managers so that their warehouse updates do not violate consistency. <p> Further, we showed that the merging work can be itself distributed over a collection of merge processes. Each process can perform part of the merge in a pre-defined but flexible manner. The Simple Painting Algorithm and Painting Algorithm will be implemented in the WHIPS <ref> [15] </ref> system at Stanford. We plan to study the performance of the two algorithms and evaluate their performance.
Reference: [16] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In SIG-MOD, </booktitle> <pages> pages 316-327, </pages> <address> San Jose, California, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The warehouse then applies these changes to the views. Incremental view maintenance typically out-performs re-computation in cases where the volume of source data is large, source data is unavailable, or no down time is permitted at the warehouse for recomputation <ref> [16, 13] </ref>. In this paper we focus on maintaining data consistency at the warehouse as it is incrementally maintained. Intuitively, consistency means that the warehouse state makes sense, that is, that it reflects (e.g., is a copy or summary of) an actual source state at some recent time. <p> For example, while we are computing this tuple, base relation R or S could be updated, leading us to insert into V 1 a tuple that never really existed in the join of R and S. The algorithms we developed in <ref> [16, 17] </ref> can be used to ensure that each view does reflect consistent data. However, those algorithms only ensure the consistency of each individual view. <p> Our architecture also makes it easy to add and delete views on the fly. 1.3 Related work and organization of this paper We believe that MVC is an important problem that has not been addressed in previous research. In our previous papers, <ref> [16] </ref> and [17], we defined single view consistency in a data warehousing environment. Hull and Zhou also defined single view consistency in [6] for the Squirrel system, a data warehouse that materializes intermediate views and uses incremental view maintenance. <p> End Procedure End Algorithm 2 5 Painting Algorithm In this section we develop a merge algorithm for underlying view managers that are strongly consistent but not necessarily complete (e.g., Strobe view managers [17]). We showed in <ref> [16] </ref>, [17] that strongly consistent view managers are usually more efficient and easier to implement than complete view managers in a distributed warehouse environment.
Reference: [17] <author> Y. Zhuge, H. Garcia-Molina, and J. Wiener. </author> <title> The Strobe algorithms for multi-source warehouse consistency. </title> <booktitle> In PDIS, </booktitle> <pages> pages 146-157, </pages> <address> Miami Beach, Florida, </address> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: For example, while we are computing this tuple, base relation R or S could be updated, leading us to insert into V 1 a tuple that never really existed in the join of R and S. The algorithms we developed in <ref> [16, 17] </ref> can be used to ensure that each view does reflect consistent data. However, those algorithms only ensure the consistency of each individual view. <p> Our architecture also makes it easy to add and delete views on the fly. 1.3 Related work and organization of this paper We believe that MVC is an important problem that has not been addressed in previous research. In our previous papers, [16] and <ref> [17] </ref>, we defined single view consistency in a data warehousing environment. Hull and Zhou also defined single view consistency in [6] for the Squirrel system, a data warehouse that materializes intermediate views and uses incremental view maintenance. <p> We defined four levels in <ref> [17] </ref>. In this paper we focus on the two most common levels: strong consistency and completeness. <p> End Procedure End Algorithm 2 5 Painting Algorithm In this section we develop a merge algorithm for underlying view managers that are strongly consistent but not necessarily complete (e.g., Strobe view managers <ref> [17] </ref>). We showed in [16], [17] that strongly consistent view managers are usually more efficient and easier to implement than complete view managers in a distributed warehouse environment. <p> End Procedure End Algorithm 2 5 Painting Algorithm In this section we develop a merge algorithm for underlying view managers that are strongly consistent but not necessarily complete (e.g., Strobe view managers <ref> [17] </ref>). We showed in [16], [17] that strongly consistent view managers are usually more efficient and easier to implement than complete view managers in a distributed warehouse environment. <p> When there is more than one source, a source state can be seen as a vector with one element for each source, representing the state of each source at a given instant in time. A more detailed description of possible transaction scenarios is given in <ref> [17] </ref>. We still define V (ss i ) as the result of evaluating the definition of V at source state ss i . After defining source states, the definition of view consistency and MVC are the same as in Section 2.
Reference: [18] <author> Y. Zhuge, J. L. Wiener, and H. Garcia-Molina. </author> <title> Multiple view consistency for data warehousing. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <month> Sept. </month> <year> 1997. </year> <note> Available via anonymous ftp from host db.stanford.edu as pub/papers/mvc-full.ps. </note>
Reference-contexts: The proof of completeness is given in <ref> [18] </ref>. The completeness of SPA guarantees that when SPA is applied to an initially consistent warehouse state, it generates a complete warehouse state sequence. That is, the warehouse views reflect every single change of the source base data in the correct order. <p> The factors that affect the decision include the number of views in the system, the update frequency and update patterns, the cost of message passing, the cost of temporarily storing the action lists, and the overhead of running a merge process. In <ref> [18] </ref> we provide examples and discuss different merging alternatives. 6.2 Transactions and multiple sources A source transaction may update more than one base relation that belongs to more than one view.
References-found: 18

