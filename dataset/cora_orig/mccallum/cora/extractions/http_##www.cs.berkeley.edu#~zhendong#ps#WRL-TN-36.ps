URL: http://www.cs.berkeley.edu/~zhendong/ps/WRL-TN-36.ps
Refering-URL: http://http.cs.berkeley.edu/~zhendong/cs252/ref.html
Root-URL: 
Title: J U N E  Combining Branch Predictors  
Author: Scott McFarling 
Pubnum: 1 9 9 3 Technical Note TN-36  
Abstract-found: 0
Intro-found: 1
Reference: [BL93] <author> T. Ball and J. R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, NM, </address> <year> 1993. </year>
Reference-contexts: Both the local and global branch prediction schemes were described by Yeh and Patt [YP92, YP93]. Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor. Ball and Larus <ref> [BL93] </ref> describe several techniques for guessing the most common branches directions at compile time using static information. Several studies [Wal91, JW89, LW93] have looked at the implications of branches on available instruction level parallelism.
Reference: [FF92] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Proceedings of ASPLOS V, </booktitle> <pages> pages 85-95, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: McFarling and Hennessy [MH86] compared various hardware and software approaches to reducing branch cost including using profile information. Hwu, Conte, and Chang [HCC89] performed a similar study for a wider range of pipeline lengths. Fisher and Freudenberger <ref> [FF92] </ref> studied the stability of profile information across separate runs of a program. Both the local and global branch prediction schemes were described by Yeh and Patt [YP92, YP93]. Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor.
Reference: [HCC89] <author> W. W. Hwu, T. M. Conte, and P. P. Chang. </author> <title> Comparing software and hardware schemes for reducing the cost of branches. </title> <booktitle> In Proc. 16th Int. Sym. on Computer Architecture, </booktitle> <pages> pages 224-233, </pages> <month> May </month> <year> 1989. </year> <month> 18 </month>
Reference-contexts: In addition, they showed how branch target buffers can be used to reduce the pipeline delays normally encountered when branches are taken. McFarling and Hennessy [MH86] compared various hardware and software approaches to reducing branch cost including using profile information. Hwu, Conte, and Chang <ref> [HCC89] </ref> performed a similar study for a wider range of pipeline lengths. Fisher and Freudenberger [FF92] studied the stability of profile information across separate runs of a program. Both the local and global branch prediction schemes were described by Yeh and Patt [YP92, YP93].
Reference: [JW89] <author> N. P. Jouppi and D. W. Wall. </author> <title> Available instruction-level parallelism for superscalar and superpipelined machines. </title> <booktitle> In Proceedings of ASPLOS III, </booktitle> <pages> pages 272-282, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor. Ball and Larus [BL93] describe several techniques for guessing the most common branches directions at compile time using static information. Several studies <ref> [Wal91, JW89, LW93] </ref> have looked at the implications of branches on available instruction level parallelism. These studies show that branch prediction errors are a critical factor determining the amount of local parallelism that can be exploited. 3 Bimodal Branch Prediction The behavior of typical branches is far from random.
Reference: [Kil86] <author> E. A. Killian. </author> <title> In RISCompiler and C Programmer's Guide. MIPS Computer Systems, </title> <address> 930 Arques Ave., Sunnyvale, CA 94086, </address> <year> 1986. </year>
Reference-contexts: These benchmarks include a mix of symbolic and numeric applications. However, to limit simulation time, only the first 10 million instructions from each benchmark was simulated. Execution traces were obtained on a DECstation 5000 using the pixie tracing facility <ref> [Kil86, Smi91] </ref>. Finally, all counters are initially set as if all previous branches were taken. benchmark simulated for 10 million instructions. The accuracy increases with predictor size since fewer branches share counters as the number of counters increases.
Reference: [LS84] <author> J.K.L. Lee and A.J. Smith. </author> <title> Branch prediction strategies and branch target buffer design. </title> <journal> Computer, </journal> <volume> 17(1), </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: This paper focuses on predicting branch directions. The alternatives available for providing target instructions will not be discussed. The reader is referred to Lee and Smith <ref> [LS84] </ref> for more information. Hardware branch prediction strategies have been studied extensively. The most well known technique, referred to here as bimodal branch prediction, makes a prediction based on the direction the branch went the last few times it was executed. <p> J. E. Smith [Smi81] presented several hardware schemes for predicting branch directions including the bimodal scheme that will be described in Section 3. Lee and A. J. Smith <ref> [LS84] </ref> evaluated several branch prediction schemes. In addition, they showed how branch target buffers can be used to reduce the pipeline delays normally encountered when branches are taken. McFarling and Hennessy [MH86] compared various hardware and software approaches to reducing branch cost including using profile information.
Reference: [LW93] <author> M. S. Lam and R. P. Wilson. </author> <title> Limits of control flow on parallelism. </title> <booktitle> In Proc. 20th Int. Sym. on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor. Ball and Larus [BL93] describe several techniques for guessing the most common branches directions at compile time using static information. Several studies <ref> [Wal91, JW89, LW93] </ref> have looked at the implications of branches on available instruction level parallelism. These studies show that branch prediction errors are a critical factor determining the amount of local parallelism that can be exploited. 3 Bimodal Branch Prediction The behavior of typical branches is far from random.
Reference: [MH86] <author> S. McFarling and J. Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In Proc. 13th Int. Sym. on Computer Architecture, </booktitle> <pages> pages 396-403, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Lee and A. J. Smith [LS84] evaluated several branch prediction schemes. In addition, they showed how branch target buffers can be used to reduce the pipeline delays normally encountered when branches are taken. McFarling and Hennessy <ref> [MH86] </ref> compared various hardware and software approaches to reducing branch cost including using profile information. Hwu, Conte, and Chang [HCC89] performed a similar study for a wider range of pipeline lengths. Fisher and Freudenberger [FF92] studied the stability of profile information across separate runs of a program.
Reference: [PSR92] <author> S. T. Pan, K. So, and J. T. Rahmeh. </author> <title> Improving the accuracy of dynamic branch prediction using branch correlation. </title> <booktitle> In Proceedings of ASPLOS V, </booktitle> <pages> pages 76-84, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Fisher and Freudenberger [FF92] studied the stability of profile information across separate runs of a program. Both the local and global branch prediction schemes were described by Yeh and Patt [YP92, YP93]. Pan, So, and Rahmeh <ref> [PSR92] </ref> described how both global history and branch address information can be used in one predictor. Ball and Larus [BL93] describe several techniques for guessing the most common branches directions at compile time using static information. <p> If so, we should be able to make a better prediction than if we had no information about the value of x. Pan, So, and Rahmeh <ref> [PSR92] </ref> showed several examples of neighboring branches in the SPEC benchmarks with conditions that are correlated in this way. A second way that global branch prediction can be effective is by duplicating the behavior of local branch prediction. <p> This suggests that a more efficient prediction might be made using both the branch address and the global history. Such a scheme was proposed by Pan, So, and Rahmeh <ref> [PSR92] </ref>. Their approach is shown in branch address bits. The performance of global prediction with selected address bits (gselect) is shown in bits or more address bits. For a predictor table with 2 K counters, we could use anywhere from 1 to (K-1) address bits.
Reference: [Sit93] <author> R. L. </author> <title> Sites. Alpha AXP architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 33-44, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: In particular, delayed branches are decreasingly effective as the number of delay slots to fill increases. Also, multiple implementations of an architecture with different superscalar or superpipelining choices make the use of delay slots problematic <ref> [Sit93] </ref>. Together, these trends increase the importance of hardware methods of reducing branch cost. The branch performance problem can be divided into two subproblems. First, a prediction of the branch direction is needed.
Reference: [Smi81] <author> J. E Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In Proc. 8th Int. Sym. on Computer Architecture, </booktitle> <pages> pages 135-148, </pages> <month> May </month> <year> 1981. </year> <month> 19 </month>
Reference-contexts: Section 9 gives some concluding remarks. Section 10 gives some suggestions for future work. Finally, Appendix A presents some additional comparisons to variations of the local prediction method. 2 Related Work Branch performance issues have been studied extensively. J. E. Smith <ref> [Smi81] </ref> presented several hardware schemes for predicting branch directions including the bimodal scheme that will be described in Section 3. Lee and A. J. Smith [LS84] evaluated several branch prediction schemes.
Reference: [Smi91] <author> M. D. Smith. </author> <title> Tracing with pixie. </title> <type> Technical Report CSL-TR-91-497, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: These benchmarks include a mix of symbolic and numeric applications. However, to limit simulation time, only the first 10 million instructions from each benchmark was simulated. Execution traces were obtained on a DECstation 5000 using the pixie tracing facility <ref> [Kil86, Smi91] </ref>. Finally, all counters are initially set as if all previous branches were taken. benchmark simulated for 10 million instructions. The accuracy increases with predictor size since fewer branches share counters as the number of counters increases.
Reference: [SPE90] <author> SPEC. </author> <title> The SPEC Benchmark Report. </title> <publisher> Waterside Associates, </publisher> <address> Fremont, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: This would not be the case if the tags were already needed to support a branch target buffer. To compare various branch prediction strategies, we will use the SPEC'89 benchmarks <ref> [SPE90] </ref> shown in Figure 2. These benchmarks include a mix of symbolic and numeric applications. However, to limit simulation time, only the first 10 million instructions from each benchmark was simulated. Execution traces were obtained on a DECstation 5000 using the pixie tracing facility [Kil86, Smi91].
Reference: [Wal91] <author> D. W. Wall. </author> <title> Limits of instruction-level parallelism. </title> <booktitle> In Proceedings of ASPLOS IV, </booktitle> <pages> pages 176-188, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor. Ball and Larus [BL93] describe several techniques for guessing the most common branches directions at compile time using static information. Several studies <ref> [Wal91, JW89, LW93] </ref> have looked at the implications of branches on available instruction level parallelism. These studies show that branch prediction errors are a critical factor determining the amount of local parallelism that can be exploited. 3 Bimodal Branch Prediction The behavior of typical branches is far from random.
Reference: [YP92] <author> T. Y. Yeh and Y. N. Patt. </author> <title> Alternative implementations of two-level adaptive branch prediction. </title> <booktitle> In Proc. 19th Int. Sym. on Computer Architecture, </booktitle> <pages> pages 124-134, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Hwu, Conte, and Chang [HCC89] performed a similar study for a wider range of pipeline lengths. Fisher and Freudenberger [FF92] studied the stability of profile information across separate runs of a program. Both the local and global branch prediction schemes were described by Yeh and Patt <ref> [YP92, YP93] </ref>. Pan, So, and Rahmeh [PSR92] described how both global history and branch address information can be used in one predictor. Ball and Larus [BL93] describe several techniques for guessing the most common branches directions at compile time using static information. <p> Clearly, if we knew the direction this branch had gone on the previous three executions, then we could always be able to predict the next branch direction. A branch prediction method close to one developed by Yeh and Patt <ref> [YP92] </ref> that can take advantage of this type of pattern is shown in Figure 4. The figure shows a branch predictor that uses two tables. The first table records the history of recent branches. Many different organizations are possible for this table. <p> For large predictors, the accuracy approaches 97.1% correct, with less than half as many misspredictions as the bimodal scheme. 5 Global Branch Prediction In the local branch prediction scheme, the only patterns considered are those of the current branch. Another scheme proposed by Yeh and Patt <ref> [YP92] </ref> is able to take advantage of other recent branches to make a prediction. One implementation of such an approach is shown in Figure 6. A single shift register GR, records the direction taken by the most recent n conditional branches.

References-found: 15

