URL: http://www.graphics.stanford.edu/papers/displace/displace.ps
Refering-URL: http://www.graphics.stanford.edu/papers/displace/
Root-URL: http://www.cs.stanford.edu
Title: Geometry Caching for Ray-Tracing Displacement Maps  
Author: Matt Pharr Pat Hanrahan 
Affiliation: Computer Science Department Stanford University  
Abstract: We present a technique for rendering displacement mapped geometry in a ray-tracing renderer. Displacement mapping is an important technique for adding detail to surface geometry in rendering systems. It allows complex geometric variation to be added to simpler geometry, without the cost in geometric complexity of completely describing the nuances of the geometry at modeling time and with the advantage that the detail can be added adaptively at rendering time. The cost of displacement mapping is geometric complexity. Renderers that provide it must be able to efficiently render scenes that have effectively millions of geometric primitives. Scan-line renderers process primitives one at a time, so this complexity doesn't tax them, but traditional ray-tracing algorithms require random access to the entire scene database, so any part of the scene geometry may need to be available at any point during rendering. If the displaced geometry is fully instantiated in memory, it is straightforward to intersect rays with it, but displacement mapping has not yet been practical in ray-tracers due to the memory cost of holding this much geometry. We introduce the use of a geometry cache in order to handle the large amounts of geometry created by displacement mapping. By caching a subset of the geometry created and rendering the image in a coherent manner, we are able to take advantage of the fact that the rays spawned by traditional ray-tracing algorithms are spatially coherent. Using our algorithm, we have efficiently rendered highly complex scenes while using a limited amount of memory.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> BLINN, J. F. </author> <title> Simulation of wrinkled surfaces. </title> <booktitle> In Computer Graphics (SIGGRAPH '78 Proceedings) (Aug. 1978), </booktitle> <volume> vol. 12, </volume> <pages> pp. 286-292. </pages>
Reference-contexts: Bump mapping is a technique that perturbs the normal across a smooth surface to give the appearance of greater detail <ref> [1] </ref>. It is often used as a substitute for displacement mapping since it is easy to implement and gives similar effects without creating large amounts of geometry.
Reference: [2] <author> COOK, R. L. </author> <title> Shade trees. </title> <booktitle> In Computer Graphics (SIGGRAPH '84 Proceedings) (July 1984), </booktitle> <editor> H. Chris-tiansen, Ed., </editor> <volume> vol. 18, </volume> <pages> pp. 223-231. </pages>
Reference-contexts: 1 Introduction Displacement mapping is a valuable technique for modeling variation in surface geom etry for computer graphics <ref> [2] </ref>. It allows the user to describe surface detail with either displacement maps (analogous to texture maps, except they define an offset from the base surface), or displacement shaders, which algorithmically describe the detail being added to the surface [6]. <p> We will then describe the algorithm that we have implemented, report on its performance, and discuss some of the trade-offs we made. Finally, we will summarize our results and suggest directions for future work. 2 Background and Previous Work Displacement mapping was first introduced by Cook <ref> [2] </ref>, and later described in detail as part of the REYES algorithm [3]. In REYES, all geometric primitives are subdivided into grids of pixel-sized micropolygons. The vertices of these micropolygons can be displaced before the polygons are shaded.
Reference: [3] <author> COOK, R. L., CARPENTER, L., AND CATMULL, E. </author> <title> The Reyes image rendering architecture. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Proceedings) (July 1987), </booktitle> <editor> M. C. Stone, </editor> <publisher> Ed., </publisher> <pages> pp. 95-102. </pages>
Reference-contexts: However, ray-tracing algorithms can compute accurate shad ows, and are desirable because of their support for complex luminaires, realistic surface reflection models, and global illumination algorithms. fl fmmp,hanrahang@graphics.stanford.edu URL: http://www-graphics.stanford.edu 1 The first implementation of displacement mapping was in the REYES render-ing algorithm <ref> [3] </ref>. REYES subdivides the original geometry into pixel-sized polygons whose vertices can then be displaced. <p> Finally, we will summarize our results and suggest directions for future work. 2 Background and Previous Work Displacement mapping was first introduced by Cook [2], and later described in detail as part of the REYES algorithm <ref> [3] </ref>. In REYES, all geometric primitives are subdivided into grids of pixel-sized micropolygons. The vertices of these micropolygons can be displaced before the polygons are shaded. Once the micropolygons have been shaded, they are stochastically sampled and the samples are filtered to generate image pixels.
Reference: [4] <author> GLASSNER, A. E. </author> <title> An Introduction to Ray Tracing. </title> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: Though there are techniques for ray-tracing complex scenes <ref> [4] </ref>, and although work has been done to manage large databases for walkthroughs [18] and flight simulators, none of this work examined methods for ray-tracing scenes with more geometry than could fit in memory at once. (Snyder and Barr rendered scenes with billions of primitives, but this geometric complexity was a
Reference: [5] <author> GREENE, N., AND KASS, M. </author> <title> Hierarchical Z-buffer visibility. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <year> 1993 (1993), </year> <pages> pp. 231-240. </pages>
Reference-contexts: before rendering it. * If a displaced object is obscured by a closer object, REYES still performs displacement (and shading) calculations, since no visibility checks are performed until after the micropolygons have been created and shaded. (However, hierarchical visibility techniques can reduce the impact of this problem in scan-line systems <ref> [5] </ref>.) This is one of the classic trade-offs between ray-tracers and scan-line renderers. Since we do not create the displaced triangles until a ray approaches the geometry being displaced, we defer creation until the geometry is needed.
Reference: [6] <author> HANRAHAN, P., AND LAWSON, J. </author> <title> A language for shading and lighting calculations. </title> <booktitle> In Computer Graphics (SIGGRAPH '90 Proceedings) (Aug. </booktitle> <year> 1990), </year> <editor> F. Baskett, Ed., </editor> <volume> vol. 24, </volume> <pages> pp. 289-298. </pages>
Reference-contexts: It allows the user to describe surface detail with either displacement maps (analogous to texture maps, except they define an offset from the base surface), or displacement shaders, which algorithmically describe the detail being added to the surface <ref> [6] </ref>. Displacement mapping is unusual in that it is essentially a mod eling operation that is performed at rendering-time; this has a number of advantages, including easy inclusion of adaptive detail and reduced computation for geometry that is not visible. <p> If we determine that more than some fixed number of displaced triangles is in the geometry cache, we discard the least recently used entries. 3.1 Subdivision and Displacement Our system allows the user to write displacement shaders in a C-like language similar to the RenderMan shading language <ref> [6] </ref>. The shader can access information about the local differential geometry at the point where it is being applied; it can displace this point anywhere in space. Given an input triangle, we execute the shader on its three vertices.
Reference: [7] <author> JEVANS, D., AND WYVILL, B. </author> <title> Adaptive voxel subdivision for ray tracing. </title> <booktitle> In Proceedingsof Graphics Interface '89 (Toronto, </booktitle> <address> Ontario, </address> <month> June </month> <year> 1989), </year> <booktitle> Canadian Information Processing Society, </booktitle> <pages> pp. 164-72. </pages>
Reference-contexts: If we were too aggressive in adding these sub-voxel grids or if they were excessively high-resolution, total memory use would be unacceptable. This technique is similar to a technique for accelerating ray-tracing proposed by Jevans <ref> [7] </ref>. 3.2 Cache Management Good performance from the geometry cache is central to our algorithm. Three factors can be adjusted to improve cache performance: capacity, access coherence, and replacement strategy.
Reference: [8] <author> KAJIYA, J. T. </author> <title> New techniques for ray tracing procedurally defined objects. </title> <booktitle> In Computer Graphics (SIGGRAPH '83 Proceedings) (July 1983), </booktitle> <volume> vol. 17, </volume> <pages> pp. 91-102. </pages>
Reference-contexts: Second, this technique only handles displacements along the surface normal. Kajiya has developed a technique for rendering fractal terrains that creates triangles lazily <ref> [8] </ref>. This technique is similar to our method for displacement mapping, though it did not cache the geometry it created and does not try to remove unnecessary geome-try from the triangle mesh.
Reference: [9] <author> KAJIYA, J. T. </author> <title> The rendering equation. </title> <booktitle> In Computer Graphics (SIGGRAPH '86 Proceedings) (Aug. </booktitle> <year> 1986), </year> <editor> D. C. Evans and R. J. Athay, Eds., </editor> <volume> vol. 20, </volume> <pages> pp. 143-150. </pages>
Reference-contexts: Some rendering algorithms access the scene in a very incoherent manner (traditional implementations of path tracing <ref> [9] </ref>, for example); our algorithm performs poorly when these algorithms are used unless the cache is big enough to hold almost all of the geometry created. Similarly, a scene with a hundreds of light sources in the scene would have poor access patterns.
Reference: [10] <author> KOLB, C., HANRAHAN, P., AND MITCHELL, D. </author> <title> A realistic camera model for computer graphics. </title> <booktitle> In SIGGRAPH 95 Conference Proceedings, </booktitle> <editor> R. Cook, </editor> <publisher> Ed., </publisher> <pages> pp. 317-324. </pages>
Reference-contexts: We remove the triangle from these lists in the contributor grid. size difficult <ref> [10] </ref>, but we would also like to be able to account for geometry between the viewer and the displaced object that magnifies or reduces the size of the object.
Reference: [11] <author> MAX, N. L. </author> <title> Horizon mapping: shadows for bump-mapped surfaces. </title> <booktitle> The Visual Computer 4, </booktitle> <month> 2 (July </month> <year> 1988), </year> <pages> 109-117. </pages>
Reference: [12] <author> MUSGRAVE, F. K., KOLB, C. E., AND MACE, R. S. </author> <title> The synthesis and rendering of eroded fractal terrains. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <editor> J. Lane, Ed., </editor> <volume> vol. 23, </volume> <pages> pp. 41-50. </pages>
Reference-contexts: This technique is similar to our method for displacement mapping, though it did not cache the geometry it created and does not try to remove unnecessary geome-try from the triangle mesh. Musgrave et al. also discuss lazy creation of fractal terrain data <ref> [12] </ref>, but do not provide details or statistics about this part of their algorithm. 3 Basic Algorithm Our algorithm has three phases (Figure 1). Starting with an input triangle mesh, we insert the triangles into a regular grid of voxels 1 .
Reference: [13] <author> PATTERSON, J. W., HOGGAR, S. G., AND LOGIE, J. R. </author> <title> Inverse displacement mapping. </title> <booktitle> Computer Graphics Forum 10, </booktitle> <month> 2 (June </month> <year> 1991), </year> <pages> 129-139. </pages>
Reference: [14] <author> REEVES, W. T., SALESIN, D. H., AND COOK, R. L. </author> <title> Rendering antialiased shadows with depth maps. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Proceedings), </booktitle> <editor> M. C. Stone, Ed., </editor> <volume> vol. 21, </volume> <pages> pp. 283-291. </pages>
Reference: [15] <author> SNYDER, J. M., AND BARR, A. H. </author> <title> Ray tracing complex models containing surface tessellations. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Proceedings) (July 1987), </booktitle> <editor> M. C. Stone, Ed., </editor> <volume> vol. 21, </volume> <pages> pp. 119-128. </pages>
Reference-contexts: databases for walkthroughs [18] and flight simulators, none of this work examined methods for ray-tracing scenes with more geometry than could fit in memory at once. (Snyder and Barr rendered scenes with billions of primitives, but this geometric complexity was a result of instancing a few simple models many times <ref> [15] </ref>.) We have developed an efficient algorithm (both in running time and memory use) for ray-tracing displacement maps. The input geometry is lazily triangulated and adaptively subdivided and displaced, and then stored in a geometry cache.
Reference: [16] <author> TAILLEFER, F. </author> <title> Fast inverse displacement mapping and shading in shadow. </title> <booktitle> In Graphics Interface '92 Workshop on Local Illumination (May 1992), </booktitle> <pages> pp. 53-60. </pages>
Reference: [17] <author> TELLER, S., FOWLER, C., FUNKHOUSER, T., AND HANRAHAN, P. </author> <title> Partitioning and ordering large radiosity computations. </title> <note> In Proceedings of SIGGRAPH '94 (July 1994), </note> <editor> A. Glassner, </editor> <publisher> Ed., </publisher> <pages> pp. 443-450. </pages>
Reference: [18] <author> TELLER, S. J., AND S EQUIN, C. H. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <booktitle> In Computer Graphics (SIGGRAPH '91 Proceedings) (July 1991), </booktitle> <editor> T. W. Sederberg, Ed., </editor> <volume> vol. 25, </volume> <pages> pp. 61-69. </pages>
Reference-contexts: Though there are techniques for ray-tracing complex scenes [4], and although work has been done to manage large databases for walkthroughs <ref> [18] </ref> and flight simulators, none of this work examined methods for ray-tracing scenes with more geometry than could fit in memory at once. (Snyder and Barr rendered scenes with billions of primitives, but this geometric complexity was a result of instancing a few simple models many times [15].) We have developed
Reference: [19] <author> VOORHIES, D. </author> <title> Space-filling curves and a measure of coherence. In Graphics Gems II, </title> <editor> J. Arvo, Ed. </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 26-30. </pages>
Reference-contexts: Most ray-tracers render the image one scan-line at a time, rendering pixels sequentially in each scan line. This is not a very coherent sampling pattern. To improve coherence, a Hilbert curve can be used, which processes the pixels in a much more coherent manner <ref> [19] </ref>. Another effective sampling strategy is to divide the screen into rectangular buckets and render them sequentially. Our replacement strategy is to discard the geometry stored in the least recently accessed voxel when the cache is full.
Reference: [20] <author> WILLIAMS, L. </author> <title> Casting curved shadows on curved surfaces. </title> <booktitle> In Computer Graphics (SIGGRAPH '78 Proceedings) (Aug. 1978), </booktitle> <volume> vol. 12, </volume> <pages> pp. 270-274. </pages>
Reference: [21] <author> WOO, A., POULIN, P., AND FOURNIER, A. </author> <title> A survey of shadow algorithms. </title> <journal> IEEE Computer Graphics and Applications 10, </journal> <volume> 6 (Nov. </volume> <year> 1990), </year> <pages> 13-32. </pages>
References-found: 21

