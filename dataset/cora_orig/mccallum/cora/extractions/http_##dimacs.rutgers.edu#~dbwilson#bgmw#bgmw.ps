URL: http://dimacs.rutgers.edu/~dbwilson/bgmw/bgmw.ps
Refering-URL: http://dimacs.rutgers.edu/~dbwilson/bgmw/
Root-URL: http://www.cs.rutgers.edu
Title: Fast Exponentiation with Precomputation: Algorithms and Lower Bounds  
Author: Ernest F. Brickell, Daniel M. Gordon Kevin S. McCurley, and David B. Wilson 
Keyword: Exponentiation, Cryptography.  
Note: AMS (MOS) subject classifications: 11Y16, 68Q25. This research was supported by the U.S. Department of Energy under contract number DE-AC04-76DP00789. Current address: Center for Communications Research,  Supported in part by an ONR-NDSEG fellowship. Current address:  
Date: November 30, 1995  
Address: Albuquerque, NM 87185  San Diego, CA 92121  Cambridge, MA 02139  
Affiliation: Sandia National Laboratories Organization 1423  Department of Mathematics, M.I.T.,  
Abstract: In several cryptographic systems, a fixed element g of a group of order N is repeatedly raised to many different powers. In this paper we present a practical method of speeding up such systems, using precomputed values to reduce the number of multiplications needed. In practice this provides a substantial improvement over the level of performance that can be obtained using addition chains, and allows the computation of g n for n &lt; N in O(log N= log log N ) multiplications. We show that this method is asymptotically optimal given polynomial storage, and for specific cases, within a small factor of optimal. We also show how these methods can be parallelized, to compute powers in time O(log log N ) with O(log N= log 2 log N ) processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> A Proposed Federal Information Processing Standard for Digital Signature Standard, Federal Register, </institution> <note> Volume 56, No. 169, August 31, </note> <year> 1991, </year> <pages> pp. 42980-42982. </pages>
Reference-contexts: The Schnorr scheme [17] uses N of 140 bits, the DSS scheme <ref> [1] </ref> uses N of 160 bits, and the Brickell-McCurley scheme [6] has N of 512 bits. We will assume that operations other than multiplications mod q will use negligible time.
Reference: [2] <editor> G.B. Agnew, R.C. Mullin, and S.A. Vanstone, </editor> <title> Fast exponentiation in GF (2 n ), in Advances in Cryptology-Eurocrypt '88, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 330, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988, </year> <pages> pp. 251-255. </pages>
Reference-contexts: This is a generalization of the methods given in <ref> [2] </ref>, [9], and [18]. It has been shown [18] that exponentiation in GF (2 n ) can be done in dn=ke + 2 k1 2 multiplications. <p> By comparison, the binary method requires 765 + 3=2 512 multiplications on average and 1022 in the worst case. our system takes only dn=ke + 2 k2 2 multiplications. But Agnew, Mullin, and Vanstone <ref> [2] </ref> show that g 1 can be computed in blog 2 nc + -(n) 2 multiplications. Thus, without any precomputation, our system requires only dn=ke + 2 k2 + blog 2 nc + -(n) 4 multiplications.
Reference: [3] <author> S. Arno and F. S. Wheeler, </author> <title> Signed digit representations of minimal ham-ming weight, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42 (1993), </volume> <pages> pp. 1007-1010. </pages>
Reference-contexts: When b = 2, there is a unique representation with no two adjacent nonzeros, which reduces the worst case number of multiplications to dlog Ne=2 and the average to dlog Ne=3 (see <ref> [3] </ref>). By taking a slightly larger multiplier set, we may further reduce h. Theorem 5. Suppose b is odd. Let M = f1; 2g and h = bb=3c. Then D (M; h) is a basic digit set. <p> Even when N is not a power of b, it can be shown that the expected number of zero digits is at least blog b N c b 1=2 : For redundant digit sets there are often other algorithms which have a higher probability of zeros <ref> [3] </ref>. A lower bound for the amount of computation required using this method is given by the fact that for a fixed value of jM j, we require hjMj b 1 in order for the set D (M; h) to represent every value modulo b.
Reference: [4] <author> J. Bos and M. Coster, </author> <title> Addition Chain Heuristics, </title> <booktitle> in Advances in Cryptology Proceedings of Crypto '89, Lecture Notes in Computer Science, </booktitle> <volume> Volume 435, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990, </year> <pages> pp. 400-407. </pages>
Reference-contexts: For a randomly chosen 512-bit exponent, we expect the binary algorithm to take an average of about 765 multiplications. Results in <ref> [4] </ref> report that addition chains of length around 605 are relatively easy to compute, resulting in a 21% improvement. Note that no addition chain could do better than 512 multiplications.
Reference: [5] <author> W. Diffie and M. Hellman, </author> <title> New Directions in Cryptography, </title> <journal> IEEE Transactions on Information Theory 22 (1976), </journal> <pages> pp. 472-492. </pages>
Reference: [6] <author> E.F. Brickell and K.S. McCurley, </author> <title> An Interactive Identification Scheme Based on Discrete Logarithms and Factoring, </title> <note> to appear in Journal of Cryptology. </note>
Reference-contexts: The Schnorr scheme [17] uses N of 140 bits, the DSS scheme [1] uses N of 160 bits, and the Brickell-McCurley scheme <ref> [6] </ref> has N of 512 bits. We will assume that operations other than multiplications mod q will use negligible time.
Reference: [7] <author> P. Erd-os and A. Renyi, </author> <title> Probabilistic methods in group theory, </title> <journal> Journal d'Analyse Math., </journal> <volume> 14 (1965), </volume> <pages> pp. 127-138. </pages>
Reference: [8] <author> Ryo Fuji-Hara, </author> <title> Cipher Algorithms and Computational Complexity, </title> <note> Bit 17 (1985), pp. 954-959 (in Japanese). </note>
Reference-contexts: The Schnorr scheme [17] uses N of 140 bits, the DSS scheme [1] uses N of 160 bits, and the Brickell-McCurley scheme [6] has N of 512 bits. We will assume that operations other than multiplications mod q will use negligible time. One simple method (see <ref> [8] </ref>) is to precompute the set S = g 2 i j i = 1; : : : ; dlog N e 1 o Then g n may be computed in -(n)1 multiplications by multiplying together the powers corresponding to nonzero digits in the binary representation of n. <p> Note also that the number of multiplications for the algorithm of Section 3 differ from the lower bounds we give by a factor of between 1.23 and 1.75. Acknowledgment. We would like to thank Professor Tsutomu Matsumoto of Yokohama National University for informing us of reference <ref> [8] </ref>, and for providing a partial translation.
Reference: [9] <author> J. von zur Gathen, </author> <title> Efficient exponentiation in finite fields, </title> <booktitle> Proceedings of the 32nd IEEE Symposium on the Foundations of Computer Science, to appear. </booktitle>
Reference-contexts: This is a generalization of the methods given in [2], <ref> [9] </ref>, and [18]. It has been shown [18] that exponentiation in GF (2 n ) can be done in dn=ke + 2 k1 2 multiplications.
Reference: [10] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 1, </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1981. </year>
Reference-contexts: Other number systems could be used, such as the Fibonacci number system (see <ref> [10, exercise 1.2.8.34] </ref>), where a number is represented as the sum of Fibonacci numbers. Other possibilities include representing numbers by sums 14 of terms of other recurrent sequences, binomial coefficients, or arbitrary sets that happen to work well. These, and a number of other number systems, are given in [11].
Reference: [11] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 2, </volume> <booktitle> Seminumerical Algorithms, Second Edition, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1981. </year>
Reference-contexts: 1 Introduction The problem of efficiently evaluating powers has been studied by many people (see <ref> [11, section 4.6.4] </ref> for an extensive survey). <p> As an example, the "square-and-multiply" method of exponentiation (also known as the left-to-right binary method, see <ref> [11, page 441] </ref>) can be viewed as an addition chain of the form 1; 2d 0 ; 2d 0 + d 1 ; 2 (2d 0 + d 1 ); 2 (2d 0 + d 1 ) + d 2 ; : : : ; n; where n is written in <p> The algorithm for finding such a representation was published by Matula [13], and a particularly simple description was later given in <ref> [11, Exercise 4.1.19] </ref>. In searching for good basic digit sets, we can make use of the following result of Matula [13], which provides a very efficient algorithm for determining if a set is basic. Theorem 3. Suppose that D contains a representative of each residue class modulo b. <p> Other possibilities include representing numbers by sums 14 of terms of other recurrent sequences, binomial coefficients, or arbitrary sets that happen to work well. These, and a number of other number systems, are given in <ref> [11] </ref>. For a given N and amount of storage, it seems difficult to prove that a scheme is optimal. In this section we derive lower bounds for the number of multiplications required for a given value of N and a given amount of storage.
Reference: [12] <author> R. Lidl and H. Niederreiter, </author> <title> Finite Fields, </title> <publisher> Cambridge University Press, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: Suppose that g is in GF (p n ), where p is a small prime (p = 2 is the most-studied case, and has been proposed for use in cryptographic systems [15]). A normal basis has the form ffi; fi p ; fi p 2 g (see, for example, <ref> [12] </ref> for details). Using a normal basis representation, the pth power of an element is simply a cyclic shift, and so is almost free compared to a standard multiplication. This fact may be used to eliminate the extra storage.
Reference: [13] <author> D.W. Matula, </author> <title> Basic digit sets for radix representation, </title> <journal> Journal of the ACM, </journal> <volume> 29 (1982), </volume> <pages> pp. 1131-1143. </pages>
Reference-contexts: This definition differs from that in <ref> [13] </ref> in that we allow redundancy; there may be more than b numbers in D, and so the representation may not be unique. <p> The algorithm for finding such a representation was published by Matula <ref> [13] </ref>, and a particularly simple description was later given in [11, Exercise 4.1.19]. In searching for good basic digit sets, we can make use of the following result of Matula [13], which provides a very efficient algorithm for determining if a set is basic. Theorem 3. <p> The algorithm for finding such a representation was published by Matula <ref> [13] </ref>, and a particularly simple description was later given in [11, Exercise 4.1.19]. In searching for good basic digit sets, we can make use of the following result of Matula [13], which provides a very efficient algorithm for determining if a set is basic. Theorem 3. Suppose that D contains a representative of each residue class modulo b. Let d min = minfs j s 2 Dg and d max = maxfs j s 2 Dg.
Reference: [14] <author> F. Morain and J. Olivos, </author> <title> Speeding up the computations on an elliptic curve using addition-subtraction chains, </title> <journal> Inform. Theor. Appl., </journal> <volume> 24 (1990), </volume> <pages> pp. 531-543. </pages>
Reference-contexts: M = f1g; h = d (b 1)=2e; is a basic digit set. This digit set is particularly useful when inverses are easy to compute, as for elliptic curves (see <ref> [14] </ref>). When b = 2, there is a unique representation with no two adjacent nonzeros, which reduces the worst case number of multiplications to dlog Ne=2 and the average to dlog Ne=3 (see [3]). By taking a slightly larger multiplier set, we may further reduce h. Theorem 5.
Reference: [15] <author> A. M. Odlyzko, </author> <title> "Discrete logarithms in finite fields and their crypto-graphic significance," </title> <booktitle> Advances in Cryptology (Proceedings of Eurocrypt 84), Lecture Notes in Computer Science 209, </booktitle> <publisher> Springer-Verlag, NY, </publisher> <pages> pp. 224-314. </pages>
Reference-contexts: Suppose that g is in GF (p n ), where p is a small prime (p = 2 is the most-studied case, and has been proposed for use in cryptographic systems <ref> [15] </ref>). A normal basis has the form ffi; fi p ; fi p 2 g (see, for example, [12] for details). Using a normal basis representation, the pth power of an element is simply a cyclic shift, and so is almost free compared to a standard multiplication.
Reference: [16] <author> Jorge Olivos, </author> <title> "On Vectorial Addition Chains", </title> <journal> Journal of Algorithms, </journal> <note> 2 (1981) pp. 13-21. </note>
Reference-contexts: Let C (l) denote the set of scalar addition chains of length l, where the numbers in each chain are arranged in strictly increasing order, and C (l) = jC (l)j. The following lemma is from <ref> [16] </ref>: Lemma 4. A vector v = (v 1 ; : : : ; v s ) is in P (s; l) if and only if there is a scalar addition chain of length l s + 1 such that each v i is in the chain.
Reference: [17] <author> C.P. Schnorr, </author> <title> Efficient signature generation by smart cards, </title> <note> to appear in Journal of Cryptology. </note>
Reference-contexts: Unless otherwise noted, we will assume that g is an element of Z=qZ, where q is a large integer (say 512 bits), and we need to repeatedly calculate 2 powers of g up to g N1 , where N is also large. The Schnorr scheme <ref> [17] </ref> uses N of 140 bits, the DSS scheme [1] uses N of 160 bits, and the Brickell-McCurley scheme [6] has N of 512 bits. We will assume that operations other than multiplications mod q will use negligible time.
Reference: [18] <author> D.R. Stinson, </author> <title> Some observations on parallel algorithms for fast exponentiation in GF (2 n ), Siam. </title> <journal> J. Comput., </journal> <volume> 19, </volume> <year> (1990), </year> <pages> pp. 711-717. </pages>
Reference-contexts: This is a generalization of the methods given in [2], [9], and <ref> [18] </ref>. It has been shown [18] that exponentiation in GF (2 n ) can be done in dn=ke + 2 k1 2 multiplications. <p> This is a generalization of the methods given in [2], [9], and <ref> [18] </ref>. It has been shown [18] that exponentiation in GF (2 n ) can be done in dn=ke + 2 k1 2 multiplications. <p> Then any power g mb j for m 2 M can be calculated by shifting g m by the appropriate amount, so we only need dn=ke 1 multiplications to combine these terms. With multiple processors, this may easily be parallelized using binary fan-in multiplication as in <ref> [18] </ref>. For example, consider computations in GF (2 593 ). In [18], Stinson shows that exponentiation can be done in at most 129 multiplications with one processor, 77 rounds with four processors, and 11 rounds with 32 processors. <p> With multiple processors, this may easily be parallelized using binary fan-in multiplication as in <ref> [18] </ref>. For example, consider computations in GF (2 593 ). In [18], Stinson shows that exponentiation can be done in at most 129 multiplications with one processor, 77 rounds with four processors, and 11 rounds with 32 processors. <p> Then the c d d 's may be combined by multiplying them together in pairs repeatedly to form g n (this is referred to as binary fan-in multiplication in <ref> [18] </ref>). This takes log h rounds. Therefore, taking h = O (log N= log 2 log N ), we may calculate powers in O (log log N) expected rounds with O (log N= log 2 log N) processors, given random inputs.
Reference: [19] <author> J.S. Vitter and P. Flajolet, </author> <title> Average-case analysis of algorithms and data structures, </title> <booktitle> in Handbook of Theoretical Computer Science, </booktitle> <editor> ed. J. van Leeuwen, </editor> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990, </year> <pages> pp. 431-524. 21 </pages>
Reference-contexts: Then the digits a j of n will be approximately uniformly distributed, so that the time for step 2 is equivalent to the maximum 13 bucket occupancy problem: given m balls randomly distributed in h buck-ets, what is the expected maximum bucket occupancy? This is discussed in <ref> [19] </ref>, in connection with analysis of hashing algorithms. Taking b to be O (log N= log 2 log N ), so m=h = fi (log log N ), the expected maximum value is O (log log N ).
References-found: 19

