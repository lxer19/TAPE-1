URL: http://www.cs.rice.edu/CS/PLT/Publications/thesis-wright.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Practical Soft Typing  
Author: by Andrew K. Wright Robert S. Cartwright, Co-chairman Matthias Felleisen, Co-chairman Bruce F. Duba 
Degree: A Thesis Submitted in Partial Fulfillment of the Requirements for the Degree Doctor of Philosophy Approved, Thesis Committee:  Professor of Computer Science  Professor of Computer Science Robert Bixby Professor of Computational and Applied Mathematics  
Date: August, 1994  
Address: Houston, Texas  
Affiliation: RICE UNIVERSITY  Research Associate of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abadi, M., Cardelli, L., Pierce, B., and Plotkin, G. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Programming Languages and Systems 13, </journal> <month> 2 (April </month> <year> 1991), </year> <pages> 237-268. </pages> <booktitle> Previously appeared in: Proc. 16th Annual Symposium on Principles of Programming Languages (January 1989), </booktitle> <pages> 213-227. </pages>
Reference-contexts: Modern type safe languages like Standard ML [44] and Modula 3 [9] have sophisticated type systems that include polymorphism and subtyping to achieve greater flexibility, but even 91 implementations of these languages invariably include loopholes, like the procedure System.Unsafe.cast in Standard ML of New Jersey. Several authors <ref> [1, 2, 37] </ref> have developed extensions that add a dynamic type to the ML type system. These extensions provide an explicit operation that pairs a statically typed value with its type to yield a self-describing value of type dynamic.
Reference: [2] <author> Abadi, M., Cardelli, L., Pierce, B., and R emy, D. </author> <title> Dynamic typing in polymorphic languages. </title> <note> In Proc. 1992 Workshop on ML and Its Applications (June 1992). </note>
Reference-contexts: Modern type safe languages like Standard ML [44] and Modula 3 [9] have sophisticated type systems that include polymorphism and subtyping to achieve greater flexibility, but even 91 implementations of these languages invariably include loopholes, like the procedure System.Unsafe.cast in Standard ML of New Jersey. Several authors <ref> [1, 2, 37] </ref> have developed extensions that add a dynamic type to the ML type system. These extensions provide an explicit operation that pairs a statically typed value with its type to yield a self-describing value of type dynamic.
Reference: [3] <author> Aiken, A., and Wimmers, E. L. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> Proceedings of the International Conference on Functional Programming Languages and Computer Architecture (1993), </booktitle> <pages> 31-41. </pages>
Reference-contexts: We have therefore been able to evaluate the practicality of soft typing as a tool to improve programming productivity. We present our conclusions in Chapter 7. 88 6.1.2 Aiken, Wimmers, and Lakshman Aiken, Wimmers, and Lakshman recently developed a sophisticated soft type system for the functional language FL <ref> [3, 4] </ref>. Their system supports a rich type language that includes union types, recursive types, intersection types, conditional types, and subtype constraints. Their type inference method is based on a procedure for solving type constraints of the form t 1 t 2 by reducing compound constraints to simpler ones. <p> This sharing is crucial to the efficient implementation of unification-based type inference algorithms [53], particularly in the presence of recursive types. Other possible solutions to the reverse flow problem are type inference methods based on constraint solving systems like that of Aiken et al. <ref> [3, 4] </ref> and Heintze [24]. Chapter 6 discusses these systems in more detail. 8.1.3 Assignment Because assignment interferes with polymorphism, and therefore with subtyping, assignment can be a major source of imprecise types (see Section 5.1). Scheme includes both assignable identifiers and mutable data structures. <p> This is the solution that Standard ML adopted and has proven practical for accommodating both polymorphism and assignment in the same language. 126 8.2 Type Size While our presentation types are concise and easy to understand, especially in comparison with types like those that Aiken's system <ref> [3, 4] </ref> infers, the types our system infers for procedures can still be quite large. Figure 5.5 illustrates a conceptually simple type that occupies an entire page. Ordinary static type systems solve this problem in two ways. Both solutions could be adapted to a soft type system.
Reference: [4] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proc. 21st Annual Symposium on Principles of Programming Languages (January 1994), </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: Hence the standard algorithm 29 cannot directly accommodate union types. We could base a polymorphic union type system directly on union types and attempt to find an alternative method of inferring types. Aiken et al. <ref> [4] </ref> have pursued this approach, but its computational complexity is significantly worse than Hindley-Milner typing. <p> We have therefore been able to evaluate the practicality of soft typing as a tool to improve programming productivity. We present our conclusions in Chapter 7. 88 6.1.2 Aiken, Wimmers, and Lakshman Aiken, Wimmers, and Lakshman recently developed a sophisticated soft type system for the functional language FL <ref> [3, 4] </ref>. Their system supports a rich type language that includes union types, recursive types, intersection types, conditional types, and subtype constraints. Their type inference method is based on a procedure for solving type constraints of the form t 1 t 2 by reducing compound constraints to simpler ones. <p> This sharing is crucial to the efficient implementation of unification-based type inference algorithms [53], particularly in the presence of recursive types. Other possible solutions to the reverse flow problem are type inference methods based on constraint solving systems like that of Aiken et al. <ref> [3, 4] </ref> and Heintze [24]. Chapter 6 discusses these systems in more detail. 8.1.3 Assignment Because assignment interferes with polymorphism, and therefore with subtyping, assignment can be a major source of imprecise types (see Section 5.1). Scheme includes both assignable identifiers and mutable data structures. <p> This is the solution that Standard ML adopted and has proven practical for accommodating both polymorphism and assignment in the same language. 126 8.2 Type Size While our presentation types are concise and easy to understand, especially in comparison with types like those that Aiken's system <ref> [3, 4] </ref> infers, the types our system infers for procedures can still be quite large. Figure 5.5 illustrates a conceptually simple type that occupies an entire page. Ordinary static type systems solve this problem in two ways. Both solutions could be adapted to a soft type system.
Reference: [5] <author> Amadio, R. M., and Cardelli, L. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. 17th Annual Symposium on Principles of Programming Languages (January 1990), </booktitle> <pages> pp. 104-118. </pages>
Reference-contexts: The types assigned to program identifiers and expressions have label ;. We usually omit labels when writing types as they can be easily reconstructed. Similarly, an implementation of type inference need not manipulate labels. Recursive types ff: t represent infinite regular trees <ref> [5] </ref>. The type ff: t binds ff in t ; the usual renaming rules apply to the bound variable ff, and we have ff: t = [ff=ff: t ]t . Recursive types must be formally contractive, i.e., phrases like ff: ff are not types.
Reference: [6] <institution> Standard ML of New Jersey release notes (version 0.93). AT&T Bell Laboratories, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [7] <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics, revised ed., </title> <booktitle> vol. 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Expressions include values and applications (e 1 e 2 ) of a procedure e 1 to a single argument e 2 . The free and bound identifiers of an expression are defined as usual, with lambda-expressions binding their identifiers. Following Barendregt <ref> [7] </ref>, we adopt the convention that bound identifiers are always distinct from free identifiers in distinct expressions, and we identify expressions that differ only by a consistent renaming of the bound identifiers. Closed expressions (resp. values) are expressions (resp. values) that have no free identifiers. <p> The free identifiers, FV (e), and bound identifiers of an expression are defined as usual, with lambda- and let-expressions binding their identifiers. The let-expression binds x in e 2 but not e 1 , i.e., let-bindings are not recursive. Following Barendregt <ref> [7] </ref>, we adopt the convention that bound identifiers are always 25 distinct from free identifiers in distinct expressions, and we identify expressions that differ only by a consistent renaming of the bound identifiers. Programs are closed expressions; that is, programs have no free variables.
Reference: [8] <author> Beer, R. D. </author> <title> Preliminary report on a practical type inference system for Common Lisp. Lisp Pointers 1, </title> <booktitle> 2 (1987), </booktitle> <pages> 5-11. 154 </pages>
Reference-contexts: It appears that the programmer must understand the coercion insertion algorithm to understand the meaning of a program. 6.2.2 Flow Analysis The designers of optimizing compilers for Scheme and Lisp have developed type recovery procedures based on iterative flow analysis <ref> [8, 33, 39, 40] </ref>. Some object-oriented languages use similar methods [12, 34]. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. <p> Unboxing certain kinds of values could also simplify the problem of integrating Soft Scheme with other languages, like C. We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers <ref> [8, 33, 39, 40] </ref> and some object-oriented systems [12, 34] use iterative flow analysis techniques to determine type information for optimization.
Reference: [9] <author> Cardelli, L., Donahue, J., Jordan, M., Kalsow, B., and Nelson, G. </author> <title> The Modula-3 type system. </title> <booktitle> In Proc. 16th Annual ACM Symposium on Principles of Programming Languages (January 1989), </booktitle> <pages> pp. 202-212. </pages>
Reference-contexts: Consequently, realistic statically typed languages like C usually have some means of circumventing the type checker. These type loopholes make debugging and writing portable code more difficult. Modern type safe languages like Standard ML [44] and Modula 3 <ref> [9] </ref> have sophisticated type systems that include polymorphism and subtyping to achieve greater flexibility, but even 91 implementations of these languages invariably include loopholes, like the procedure System.Unsafe.cast in Standard ML of New Jersey.
Reference: [10] <author> Cartwright, R., and Fagan, M. </author> <title> Soft typing. </title> <booktitle> Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> 278-292. </pages>
Reference-contexts: Furthermore, since x consists only of numbers, the numbers in the list '(1 2 3) do not need tags to distinguish them from non-numbers. This thesis explores the issues involved in designing a practical soft type system to provide type information for languages like Scheme. Soft typing <ref> [10, 16] </ref> is a generalization of traditional static typing that accommodates both static and dynamic typing in one framework. <p> Finally, the type information inferred by a soft type system provides opportunities for compiler optimizations. In particular, soft type systems optimize the placement of run-time checks and the representations of data. 1.4 Practical Soft Typing Cartwright and Fagan <ref> [10, 16] </ref> pioneered soft typing in 1991. Their work, which we discuss in greater detail later, established the theoretical feasibility of soft typing for a idealized core language. They found a type inference algorithm that assigns reasonably precise types to all purely functional programs. <p> For example, the above internal type 4.2 denotes the conjunction ((+ true false) &gt; (+ true false)) and (true &gt; true) and (false &gt; false) and ((+) &gt; (+)): 57 (Note that (+) is the empty presentation type corresponding to t.) Cartwright and Fagan <ref> [10] </ref> suggest decoding types that share flag variables at different polarities by enumerating all elements of the conjunction not implied by other elements. <p> Coincidentally with our work, Aiken, Wimmers, and Lakshman developed a soft type system for the functional language FL. 6.1.1 Cartwright and Fagan Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [10, 16] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an early encoding technique Remy developed to reduce record subtyping to polymorphism [50].
Reference: [11] <author> Cartwright, R., and Felleisen, M. </author> <title> Extensible denotational language specifications. </title> <booktitle> In Symposium on Theoretical Aspects of Computer Science (1994), </booktitle> <address> p. </address> ?? 
Reference-contexts: The difficulty of inserting the necessary injections and projections into data values to be passed to taut impedes reusing existing procedures as boolean formula. Hence an ML programmer would most likely choose a different representation for boolean formulae than ours. Cartwright and Felleisen <ref> [11] </ref> present a more complex example that illustrates how our soft type system overcomes the limitations of traditional static type systems. 101 datatype formula = C of bool | O of bool -&gt; formula fun ml_taut (C true) = true | ml_taut (C false) = false | ml_taut (O p) = <p> We can measure the speed at which our prototype analyses typical programs. 7.4.1 Minimizing Run-time Checking Common Lisp bench marks 4 and two other programs. The extra two programs, Dtype and Interp, are Henglein's dynamic type inference prototype applied to itself [26] and Cartwright and Felleisen's extensible denotational framework <ref> [11] </ref>. The former is representative of a large Scheme program that has not been engineered with soft typing in mind. The latter is a large Scheme program that was specifically designed using Soft Scheme. The percentages indicate how frequently our system inserts run-time checks compared to conventional dynamic typing.
Reference: [12] <author> Chambers, C. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Some object-oriented languages use similar methods <ref> [12, 34] </ref>. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. Few of the systems infer polymorphic types; none accommodate higher-order functions in an accurate manner. <p> We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers [8, 33, 39, 40] and some object-oriented systems <ref> [12, 34] </ref> use iterative flow analysis techniques to determine type information for optimization.
Reference: [13] <editor> Clinger, W., Rees, J., et al. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <booktitle> ACM Lisp Pointers IV (July-September 1991). </booktitle>
Reference-contexts: We develop correctness proofs in a formal setting for our system, and discuss the implementation of an efficient type inference algorithm. Finally, we describe an implementation of a soft type system for R4RS Scheme <ref> [13] </ref> and we discuss the effectiveness of our prototype from the perspectives of the programmer and of the compiler. From the programmer's perspective, our system helps structure programs and find bugs. <p> In general, a static type with free flag variables designates a finite 4 It is feasible to further distinguish exact and inexact numbers as defined by the Scheme report <ref> [13] </ref>. 31 set of possible types corresponding to the instances of the free flag variables. <p> ) . . . user's program With the interpretation of Scheme programs as letrec-expressions in Section 5.5, our treatment of set! handles assignment to primitives. 5.2 First-class Continuations Scheme and some dialects of Standard ML provide the ability to access a program's continuation through the use of a call-with-current-continuation operator <ref> [13] </ref>. This operator provides a powerful form of non-local control that can be used to define exceptions, build back-tracking algorithms, schedule multiple threads of control, etc. In this section, we extend Box Scheme to Imperative Scheme, which includes both boxes and first-class continuations. <p> We show how soft typing compares in practice to static and dynamic typing and how Soft Scheme may be used to engineer prototypes into robust and efficient programs. some problems we have encountered in using our prototype. 7.1 Soft Scheme Soft Scheme performs batch type checking for complete R4RS Scheme <ref> [13] </ref> programs. When applied to a program, the type checker writes a version of the program containing explicit run-time checks to an output file and displays only a summary of the inserted run-time checks. Programmers may then inspect type information interactively according to their interest.
Reference: [14] <author> Damas, L. M. M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [15] <author> Dzeng, H., and Haynes, C. T. </author> <title> Type reconstruction for variable-arity procedures. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 239-249. </pages>
Reference-contexts: i.e., (add1 0) = 1, (add1 1) = 2, etc. 122 ((X1 &gt; X0) (list X1) &gt; X0) and ((X1 X2 &gt; X0) (list X1) (list X2) &gt; X0) and ((X1 X2 X3 &gt; X0) (list X1) (list X2) (list X3) &gt; X0) and : : : Dzeng and Haynes <ref> [15] </ref> adapt Remy's encoding technique to give a precise type to variable-arity functions like Scheme's map. It seems straightforward to extend our soft type system to include their encoding.
Reference: [16] <author> Fagan, M. </author> <title> Soft Typing: An Approach to Type Checking for Dynamically Typed Languages. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Furthermore, since x consists only of numbers, the numbers in the list '(1 2 3) do not need tags to distinguish them from non-numbers. This thesis explores the issues involved in designing a practical soft type system to provide type information for languages like Scheme. Soft typing <ref> [10, 16] </ref> is a generalization of traditional static typing that accommodates both static and dynamic typing in one framework. <p> Finally, the type information inferred by a soft type system provides opportunities for compiler optimizations. In particular, soft type systems optimize the placement of run-time checks and the representations of data. 1.4 Practical Soft Typing Cartwright and Fagan <ref> [10, 16] </ref> pioneered soft typing in 1991. Their work, which we discuss in greater detail later, established the theoretical feasibility of soft typing for a idealized core language. They found a type inference algorithm that assigns reasonably precise types to all purely functional programs. <p> Coincidentally with our work, Aiken, Wimmers, and Lakshman developed a soft type system for the functional language FL. 6.1.1 Cartwright and Fagan Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [10, 16] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an early encoding technique Remy developed to reduce record subtyping to polymorphism [50].
Reference: [17] <author> Felleisen, M. </author> <title> On the expressive power of programming languages. </title> <booktitle> Science of Computer Programming 17 (1991), </booktitle> <pages> 35-75. </pages> <note> Preliminary version in: Proc. Eu-ropean Symposium on Programming, Lecture Notes in Computer Science, 432. Springer-Verlag (1990), 134-151. </note>
Reference-contexts: Proof. The proof is a routine induction on the length of the reduction sequence, using case analysis on the structure of expression e. For a proof of a similar theorem, see Felleisen <ref> [17] </ref>. Type safe implementations of dynamically typed languages like Pure Scheme interpret all occurrences of primitive operations in source programs as checked operations. <p> Fortunately, this imperfection does not seem to matter for practical programming. 58 Chapter 5 Beyond Pure Scheme Practical programming languages extend our idealized language Pure Scheme with facilities like assignment, non-local control operators, and data definition. These facilities increase the expressiveness of a programming language <ref> [17] </ref>. Other facilities like pattern matching and records permit more precise type assignment. And other features like macro definition provide important syntactic convenience. In this chapter, we extend our soft type system for Pure Scheme to encompass many features of realistic programming languages.
Reference: [18] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science 102 (1992), </booktitle> <pages> 235-271. </pages> <note> Preliminary version in: Technical Report TR-100, </note> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: For the remainder of this chapter, we imagine fl and its variants as having procedures accepting multiple arguments. We specify the meaning of programs in fl with a specific kind of term rewriting system called a reduction semantics <ref> [18] </ref>, which is a form of operational semantics. The rewriting relation 7!, defined in Figure 2.1, is a partial function mapping programs to programs. The definition is structured so that any closed expression other than a value can be uniquely decomposed into an evaluation context and a redex. <p> For example, the expression (ap 1 2) is meaningless, while (CHECK-ap 1 2) produces an error message like "Error: 1 is not a procedure". 3.2 Operational Semantics We use reduction semantics <ref> [18] </ref> to specify the operational behavior of Pure Scheme programs. Definition 3.2 (Semantics of Pure Scheme).
Reference: [19] <author> Freeman, T. </author> <title> Refinement Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year> <month> 155 </month>
Reference-contexts: This projection operation is usually incorporated in the programming language by extending the pattern matching construct. Because of their explicit nature, dynamic type extensions are primarily useful for limited applications like persistent storage. These extensions do not alter the fundamental character of static type systems. Freeman and Pfenning <ref> [20, 19] </ref> have developed a system of refinement types for ML that permits more precise type assignment within datatypes. Their system does not expand the set of typable programs. Rather, with the aid of explicit annotations, refinement types permit more precise static checking of the use of variants within datatypes.
Reference: [20] <author> Freeman, T., and Pfenning, F. </author> <title> Refinement types for ML. </title> <booktitle> Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> 268-277. </pages>
Reference-contexts: This projection operation is usually incorporated in the programming language by extending the pattern matching construct. Because of their explicit nature, dynamic type extensions are primarily useful for limited applications like persistent storage. These extensions do not alter the fundamental character of static type systems. Freeman and Pfenning <ref> [20, 19] </ref> have developed a system of refinement types for ML that permits more precise type assignment within datatypes. Their system does not expand the set of typable programs. Rather, with the aid of explicit annotations, refinement types permit more precise static checking of the use of variants within datatypes.
Reference: [21] <author> Gomard, C. K. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> Proceedings of the 1990 ACM Conference on LISP and Functional Programming (June 1990), </booktitle> <pages> 282-287. </pages>
Reference-contexts: These systems insert tagging and checking coercions to ensure type safety. Henglein's system for optimizing run-time tagging and checking [26] inserts only atomic coercions like num ; &gt; and &gt; ; num that are small, constant time operations. Systems proposed by Gomard <ref> [21] </ref> and Thatte [58, 59] and studied by 89 O'Keefe and Wand [46], as well as a more general system proposed by Henglein [25], insert compound coercions like (list num) ; &gt; and &gt; ; (list num) that may be much more expensive than atomic coercions.
Reference: [22] <author> Greiner, J. </author> <title> Standard ML weak polymorphism can be sound. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-160R, Carnegie Mellon University, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [23] <author> Harper, R., and Lillibridge, M. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Proc. 20th Annual ACM Symposium on Principles of Programming Languages (January 1993), </booktitle> <pages> pp. 206-219. </pages>
Reference-contexts: An A-expression may have any type, regardless of the type of its subexpression, because it never returns a value to its surrounding context. Harper and Lillibridge <ref> [23] </ref> discovered that navely combining first-class continuations with polymorphism leads to an unsound type system, just as navely combining assignment and polymorphism does. Fortunately, the same solution of restricting polymorphism to values works for both assignment and first-class continuations [64].
Reference: [24] <author> Heintze, N. </author> <title> Set based analysis of ML programs. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-193, Carnegie Mellon University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Hence this algorithm is likely to be impractical for large programs that make extensive use of higher-order functions. Heintze has recently developed a method of performing flow analysis for higher-order languages based on ignoring dependencies between identifiers <ref> [24] </ref>. He reports reasonable execution times to analyze ML programs of several thousand lines. As the information his system infers is fairly precise, we believe that his analysis could be used to perform type recovery. To our knowledge, this application of his analysis has not been investigated. <p> This sharing is crucial to the efficient implementation of unification-based type inference algorithms [53], particularly in the presence of recursive types. Other possible solutions to the reverse flow problem are type inference methods based on constraint solving systems like that of Aiken et al. [3, 4] and Heintze <ref> [24] </ref>. Chapter 6 discusses these systems in more detail. 8.1.3 Assignment Because assignment interferes with polymorphism, and therefore with subtyping, assignment can be a major source of imprecise types (see Section 5.1). Scheme includes both assignable identifiers and mutable data structures. Assignments to local identifiers seldom cause imprecise types.
Reference: [25] <author> Henglein, F. </author> <title> Dynamic typing. </title> <booktitle> In Proceedings of the European Symposium on Programming, LNCS 582 (February 1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 233-253. </pages>
Reference-contexts: Systems proposed by Gomard [21] and Thatte [58, 59] and studied by 89 O'Keefe and Wand [46], as well as a more general system proposed by Henglein <ref> [25] </ref>, insert compound coercions like (list num) ; &gt; and &gt; ; (list num) that may be much more expensive than atomic coercions. These systems are designed primarily to optimize tagging and checking, but not to determine useful type information for programmers.
Reference: [26] <author> Henglein, F. </author> <title> Global tagging optimization by type inference. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 205-215. </pages>
Reference-contexts: These systems insert tagging and checking coercions to ensure type safety. Henglein's system for optimizing run-time tagging and checking <ref> [26] </ref> inserts only atomic coercions like num ; &gt; and &gt; ; num that are small, constant time operations. <p> We can measure the speed at which our prototype analyses typical programs. 7.4.1 Minimizing Run-time Checking Common Lisp bench marks 4 and two other programs. The extra two programs, Dtype and Interp, are Henglein's dynamic type inference prototype applied to itself <ref> [26] </ref> and Cartwright and Felleisen's extensible denotational framework [11]. The former is representative of a large Scheme program that has not been engineered with soft typing in mind. The latter is a large Scheme program that was specifically designed using Soft Scheme.
Reference: [27] <author> Hindley, R. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society 146 (December 1969), </journal> <pages> 29-60. </pages>
Reference-contexts: Pascal is a prominent example of a programming language that suffers from this problem. The Hindley-Milner type discipline <ref> [27, 43] </ref> extends the above static type system to permit the definition of polymorphic procedures. A procedure is polymorphic if its behavior does not depend on the type of some part of its arguments. For example, a list reversal procedure is polymorphic in the element type.
Reference: [28] <author> Hindley, R. J., and Seldin, J. P. </author> <title> Introduction to Combinators and - Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [29] <author> Hoang, M., Mitchell, J., and Viswanathan, R. </author> <title> Standard ML-NJ weak polymorphism and imperative constructs. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Logic in Computer Science (June 1993), </booktitle> <pages> pp. 15-25. </pages>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [30] <editor> Hudak, P., et al. </editor> <title> Report on the programming language Haskell: A non-strict, purely functional language. </title> <journal> SIGPLAN Notices 27, </journal> <month> 5 (May </month> <year> 1992). </year> <month> 156 </month>
Reference-contexts: An interpreter for a complete language is constructed by composing appropriate layers of interpreter fragments. Cartwright and Felleisen have fully implemented their framework in Soft Scheme using parameterized modules for interpreter layers. In contrast, Steele [56] attempts to use a similar approach in Haskell <ref> [30] </ref> to compose interpreters from pseudo-monads. His program implements interpreter layers as association-lists of functions. While the program is semantically correct and individual layers are typable, Haskell's static type system is unable to type the complete program that composes layers to build an interpreter.
Reference: [31] <author> Jagannathan, S., and Weeks, S. </author> <title> Analyzing stores and references in a parallel symbolic language. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (June 1994), </booktitle> <pages> pp. 294-305. </pages>
Reference-contexts: He reports reasonable execution times to analyze ML programs of several thousand lines. As the information his system infers is fairly precise, we believe that his analysis could be used to perform type recovery. To our knowledge, this application of his analysis has not been investigated. Jagannathan and Weeks <ref> [31] </ref> have recently implemented an extension of Shivers's 0CFA technique.
Reference: [32] <author> Kaes, S. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 193-204. </pages>
Reference-contexts: Hence no reverse flow occurs at the application (f y), and no unnecessary run-time check is inserted at (add1 y). Addressing the reverse flow problem requires a more sophisticated approach to type inference than unification-based algorithms yield. To this end, we have investigated several adaptations of structural subtyping <ref> [32, 45] </ref>. Structural subtyping permits subtyping at all function applications and handles if-expressions more precisely. By permitting more subtyping, a soft type system based on structural subtyping could infer more precise types. However, our experience to date with such systems has been 125 disappointing.
Reference: [33] <author> Kaplan, M. A., and Ullman, J. D. </author> <title> A scheme for the automatic inference of variable types. </title> <journal> Journal of the Association for Computing Machinery 27, </journal> <month> 1 (January </month> <year> 1980), </year> <pages> 128-145. </pages>
Reference-contexts: It appears that the programmer must understand the coercion insertion algorithm to understand the meaning of a program. 6.2.2 Flow Analysis The designers of optimizing compilers for Scheme and Lisp have developed type recovery procedures based on iterative flow analysis <ref> [8, 33, 39, 40] </ref>. Some object-oriented languages use similar methods [12, 34]. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. <p> Unboxing certain kinds of values could also simplify the problem of integrating Soft Scheme with other languages, like C. We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers <ref> [8, 33, 39, 40] </ref> and some object-oriented systems [12, 34] use iterative flow analysis techniques to determine type information for optimization.
Reference: [34] <author> Kind, A., and Friedrich, H. </author> <title> A practical approach to type inference in EuLisp. </title> <booktitle> Lisp and Symbolic Computation 6, </booktitle> <month> 1/2 (August </month> <year> 1993), </year> <pages> 159-175. </pages>
Reference-contexts: Some object-oriented languages use similar methods <ref> [12, 34] </ref>. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. Few of the systems infer polymorphic types; none accommodate higher-order functions in an accurate manner. <p> We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers [8, 33, 39, 40] and some object-oriented systems <ref> [12, 34] </ref> use iterative flow analysis techniques to determine type information for optimization.
Reference: [35] <author> Leroy, X. </author> <title> Typage polymorphe d'un langage algorithmique. </title> <type> PhD thesis, </type> <address> L'Universite Paris 7, </address> <year> 1992. </year>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [36] <author> Leroy, X. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Proc. 19th Annual Symposium on Principles of Programming Languages (January 1992), </booktitle> <pages> pp. 177-188. </pages>
Reference-contexts: In our type system, values whose union type contains only one component are never mixed with values of a different type, except through polymorphic functions. A technique similar to Leroy's method for unboxing values in ML <ref> [36] </ref> could permit unboxing values of singular union types. Unboxing certain kinds of values could also simplify the problem of integrating Soft Scheme with other languages, like C. We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations.
Reference: [37] <author> Leroy, X., and Mauny, M. </author> <title> Dynamics in ML. </title> <journal> Journal of Functional Programming 3, </journal> <volume> 4 (1993), </volume> <pages> 431-463. </pages>
Reference-contexts: Modern type safe languages like Standard ML [44] and Modula 3 [9] have sophisticated type systems that include polymorphism and subtyping to achieve greater flexibility, but even 91 implementations of these languages invariably include loopholes, like the procedure System.Unsafe.cast in Standard ML of New Jersey. Several authors <ref> [1, 2, 37] </ref> have developed extensions that add a dynamic type to the ML type system. These extensions provide an explicit operation that pairs a statically typed value with its type to yield a self-describing value of type dynamic.
Reference: [38] <author> Leroy, X., and Weis, P. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> pp. 291-302. </pages>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [39] <author> Ma, K. L., and Kessler, R. R. </author> <title> TICL|a type inference system for Common Lisp. </title> <journal> Software Practice and Experience 20, </journal> <month> 6 (June </month> <year> 1990), </year> <pages> 593-623. </pages>
Reference-contexts: It appears that the programmer must understand the coercion insertion algorithm to understand the meaning of a program. 6.2.2 Flow Analysis The designers of optimizing compilers for Scheme and Lisp have developed type recovery procedures based on iterative flow analysis <ref> [8, 33, 39, 40] </ref>. Some object-oriented languages use similar methods [12, 34]. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. <p> Unboxing certain kinds of values could also simplify the problem of integrating Soft Scheme with other languages, like C. We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers <ref> [8, 33, 39, 40] </ref> and some object-oriented systems [12, 34] use iterative flow analysis techniques to determine type information for optimization.
Reference: [40] <author> MacLachlan, R. A. </author> <title> The Python compiler for CMU Common Lisp. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (1992), </booktitle> <pages> pp. 235-246. </pages>
Reference-contexts: It appears that the programmer must understand the coercion insertion algorithm to understand the meaning of a program. 6.2.2 Flow Analysis The designers of optimizing compilers for Scheme and Lisp have developed type recovery procedures based on iterative flow analysis <ref> [8, 33, 39, 40] </ref>. Some object-oriented languages use similar methods [12, 34]. The information gathered by these systems is important for program optimization, but it is generally too coarse to serve as the basis for a soft type system. <p> Unboxing certain kinds of values could also simplify the problem of integrating Soft Scheme with other languages, like C. We also believe that type information such as Soft Scheme infers has the potential to guide many kinds of program-global optimizations. Various Lisp compilers <ref> [8, 33, 39, 40] </ref> and some object-oriented systems [12, 34] use iterative flow analysis techniques to determine type information for optimization.
Reference: [41] <author> MacQueen, D., Plotkin, G., and Sethi, R. </author> <title> An ideal model for recursive polymorphic types. Information and Control 71 (1986), 95-130. Preliminary version in: </title> <booktitle> Proc. 11th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> pp. 165-174. 157 </pages>
Reference-contexts: We refrain from developing a complete denotational semantics for Pure Scheme and showing that it corresponds to our operational semantics [49]. B.1 Internal Types We use the ideal model developed by MacQueen, Plotkin, and Sethi <ref> [41] </ref> to assign meaning to the internal types of Chapter 3.
Reference: [42] <author> Martelli, A., and Montanari, U. </author> <title> Unification in linear time and space: A structured presentation. </title> <type> Tech. Rep. </type> <institution> B76-16, Ist. di Elaborazione delle Infor-mazione, Consiglio Nazionale delle Ricerche, Pisa, Italy, </institution> <month> July </month> <year> 1976. </year>
Reference-contexts: Informally, the primitive operations of Pure Scheme induce the following partition 3 Ordinary Hindley-Milner typing relies on simple unification of finite terms, which can be implemented in linear time <ref> [42, 47] </ref>. Our modification of Hindley-Milner typing requires unification of infinite terms, for which no linear algorithm is known.
Reference: [43] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: Pascal is a prominent example of a programming language that suffers from this problem. The Hindley-Milner type discipline <ref> [27, 43] </ref> extends the above static type system to permit the definition of polymorphic procedures. A procedure is polymorphic if its behavior does not depend on the type of some part of its arguments. For example, a list reversal procedure is polymorphic in the element type.
Reference: [44] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Consequently, realistic statically typed languages like C usually have some means of circumventing the type checker. These type loopholes make debugging and writing portable code more difficult. Modern type safe languages like Standard ML <ref> [44] </ref> and Modula 3 [9] have sophisticated type systems that include polymorphism and subtyping to achieve greater flexibility, but even 91 implementations of these languages invariably include loopholes, like the procedure System.Unsafe.cast in Standard ML of New Jersey.
Reference: [45] <author> Mitchell, J. C. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming 1, </journal> <month> 3 (July </month> <year> 1991), </year> <month> 245-286. </month> <title> Preliminary version in: Coercion and Type Inference, </title> <booktitle> Proc. 11th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> pp. 175-185. </pages>
Reference-contexts: Hence no reverse flow occurs at the application (f y), and no unnecessary run-time check is inserted at (add1 y). Addressing the reverse flow problem requires a more sophisticated approach to type inference than unification-based algorithms yield. To this end, we have investigated several adaptations of structural subtyping <ref> [32, 45] </ref>. Structural subtyping permits subtyping at all function applications and handles if-expressions more precisely. By permitting more subtyping, a soft type system based on structural subtyping could infer more precise types. However, our experience to date with such systems has been 125 disappointing.
Reference: [46] <author> O'Keefe, P. M., and Wand, M. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proceedings of the European Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 408-417. </pages>
Reference-contexts: Henglein's system for optimizing run-time tagging and checking [26] inserts only atomic coercions like num ; &gt; and &gt; ; num that are small, constant time operations. Systems proposed by Gomard [21] and Thatte [58, 59] and studied by 89 O'Keefe and Wand <ref> [46] </ref>, as well as a more general system proposed by Henglein [25], insert compound coercions like (list num) ; &gt; and &gt; ; (list num) that may be much more expensive than atomic coercions.
Reference: [47] <author> Paterson, M. S., and Wegman, M. N. </author> <title> Linear unification. </title> <journal> Journal of Computing Systems Science 16, </journal> <month> 2 (April </month> <year> 1978), </year> <pages> 158-167. </pages>
Reference-contexts: Informally, the primitive operations of Pure Scheme induce the following partition 3 Ordinary Hindley-Milner typing relies on simple unification of finite terms, which can be implemented in linear time <ref> [42, 47] </ref>. Our modification of Hindley-Milner typing requires unification of infinite terms, for which no linear algorithm is known.
Reference: [48] <author> Plotkin, G. D. </author> <title> Call-by-name, call-by-value and the lambda-calculus. </title> <booktitle> Theoretical Computer Science 1 (1975), </booktitle> <pages> 125-159. </pages>
Reference-contexts: We also introduce the Hindley-Milner static type discipline, which underlies our soft type system. 2.1 fl We define a simple call-by-value functional language fl that is based on the call-by-value -calculus <ref> [48] </ref>. fl omits many features of realistic programming languages like interactive input/output and assignment, but it serves to illustrate the notions of dynamic typing, static typing, and soft typing.
Reference: [49] <author> Plotkin, G. D. </author> <title> LCF considered as a programming language. </title> <booktitle> Theoretical Computer Science 5 (1977), </booktitle> <pages> 223-255. </pages>
Reference-contexts: We refrain from developing a complete denotational semantics for Pure Scheme and showing that it corresponds to our operational semantics <ref> [49] </ref>. B.1 Internal Types We use the ideal model developed by MacQueen, Plotkin, and Sethi [41] to assign meaning to the internal types of Chapter 3.
Reference: [50] <author> R emy, D. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proc. 16th Annual Symposium on Principles of Programming Languages (Jan-uary 1989), </booktitle> <pages> pp. 77-87. </pages>
Reference-contexts: We elect instead to modify Hindley-Milner typing to accommodate union types and subtyping without compromising its practical efficiency. 3 To combine union types and subtyping with Hindley-Milner polymorphism, we adapt an encoding Remy developed for record subtyping <ref> [50, 52] </ref>. Our encoding permits many union types to be expressed as terms in a free algebra, as with conventional Hindley-Milner types. Flag variables enable polymorphism to encode subtyping as subset on union types. Types are inferred by a simple variant of the standard Hindley-Milner algorithm. <p> Other record operations (test for a record, test for a field, extend a record, modify a field, concatenate records, etc. [51]) can also soft typed. We derive a static type inference system for records by adapting Remy's work <ref> [50, 52] </ref>. <p> Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an early encoding technique Remy developed to reduce record subtyping to polymorphism <ref> [50] </ref>. In Cartwright and Fagan's system (henceforth called CF ), types consist of either a type variable or a union that enumerates every available type constructor.
Reference: [51] <author> R emy, D. </author> <title> Record concatenation for free. </title> <type> Tech. Rep. 1430, </type> <institution> INRIA, </institution> <year> 1991. </year>
Reference-contexts: Other record operations (test for a record, test for a field, extend a record, modify a field, concatenate records, etc. <ref> [51] </ref>) can also soft typed. We derive a static type inference system for records by adapting Remy's work [50, 52].
Reference: [52] <author> R emy, D. </author> <title> Type inference for records in a natural extension of ML. </title> <type> Tech. Rep. 1431, </type> <institution> INRIA, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: We elect instead to modify Hindley-Milner typing to accommodate union types and subtyping without compromising its practical efficiency. 3 To combine union types and subtyping with Hindley-Milner polymorphism, we adapt an encoding Remy developed for record subtyping <ref> [50, 52] </ref>. Our encoding permits many union types to be expressed as terms in a free algebra, as with conventional Hindley-Milner types. Flag variables enable polymorphism to encode subtyping as subset on union types. Types are inferred by a simple variant of the standard Hindley-Milner algorithm. <p> Other record operations (test for a record, test for a field, extend a record, modify a field, concatenate records, etc. [51]) can also soft typed. We derive a static type inference system for records by adapting Remy's work <ref> [50, 52] </ref>.
Reference: [53] <author> R emy, D. </author> <title> Extension of ML type system with a sorted equational theory on types. </title> <type> Tech. Rep. 1766, </type> <institution> INRIA, </institution> <month> October </month> <year> 1992. </year> <month> 158 </month>
Reference-contexts: Remy <ref> [53] </ref> describes the basic algorithms for unification, generalization, and instantiation of types in detail. 51 Chapter 4 Types for Programmers The soft type system developed in the previous chapter infers relatively precise types for Pure Scheme programs. <p> The problem is that the known techniques for implementing structural subtyping do not preserve sharing between representations of the same type. This sharing is crucial to the efficient implementation of unification-based type inference algorithms <ref> [53] </ref>, particularly in the presence of recursive types. Other possible solutions to the reverse flow problem are type inference methods based on constraint solving systems like that of Aiken et al. [3, 4] and Heintze [24].
Reference: [54] <author> Shao, Z., and Appel, A. K. </author> <title> Smartest recompilation. </title> <booktitle> In Proc. 20th Annual Symposium on Principles of Programming Languages (January 1993), </booktitle> <pages> pp. 439-450. </pages>
Reference-contexts: Modifying our type assignment method to compute type information incrementally should be straightforward. We envision using a technique related to but simpler than one that Shao and Appel proposed for separately compiling ML <ref> [54] </ref>. Types are inferred independently for separate program modules or definitions. Where a module refers to identifiers from some other module, each external reference is assigned a fresh type variable.
Reference: [55] <author> Shivers, O. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <note> Also: Tech. Rep. CMU-CS-91-145. </note>
Reference-contexts: Most infer types that are simple unions of type constants and constructions. And regrettably, we have been unable to find any precise formal definitions of these kinds of systems. 90 Shivers developed a family of techniques based on abstract interpretation to perform flow analysis for Scheme-like languages <ref> [55] </ref>. His techniques accommodate higher-order functions and can be used to perform type recovery. The simplest technique (0CFA) is too imprecise to yield useful types.
Reference: [56] <author> Steele Jr., G. L. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proc. 21st Annual Symposium on Principles of Programming Languages (January 1994), </booktitle> <pages> pp. 472-492. </pages>
Reference-contexts: Each layer provides parsing, evaluation, and printing routines for different language facilities. An interpreter for a complete language is constructed by composing appropriate layers of interpreter fragments. Cartwright and Felleisen have fully implemented their framework in Soft Scheme using parameterized modules for interpreter layers. In contrast, Steele <ref> [56] </ref> attempts to use a similar approach in Haskell [30] to compose interpreters from pseudo-monads. His program implements interpreter layers as association-lists of functions.
Reference: [57] <author> Talpin, J.-P., and Jouvelot, P. </author> <title> The type and effect discipline. </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Logic in Computer Science (June 1992), </booktitle> <pages> pp. 162-173. </pages>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [58] <author> Thatte, S. R. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, LNCS 317 (July 1988), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 615-629. </pages>
Reference-contexts: These systems insert tagging and checking coercions to ensure type safety. Henglein's system for optimizing run-time tagging and checking [26] inserts only atomic coercions like num ; &gt; and &gt; ; num that are small, constant time operations. Systems proposed by Gomard [21] and Thatte <ref> [58, 59] </ref> and studied by 89 O'Keefe and Wand [46], as well as a more general system proposed by Henglein [25], insert compound coercions like (list num) ; &gt; and &gt; ; (list num) that may be much more expensive than atomic coercions.
Reference: [59] <author> Thatte, S. R. </author> <title> Quasi-static typing. </title> <booktitle> In Proc. 17th Annual Symposium on Principles of Programming Languages (January 1990), </booktitle> <pages> pp. 367-381. </pages>
Reference-contexts: These systems insert tagging and checking coercions to ensure type safety. Henglein's system for optimizing run-time tagging and checking [26] inserts only atomic coercions like num ; &gt; and &gt; ; num that are small, constant time operations. Systems proposed by Gomard [21] and Thatte <ref> [58, 59] </ref> and studied by 89 O'Keefe and Wand [46], as well as a more general system proposed by Henglein [25], insert compound coercions like (list num) ; &gt; and &gt; ; (list num) that may be much more expensive than atomic coercions.
Reference: [60] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values. <p> All of the other solutions add notational complexity to types, which makes reasoning with types difficult. Furthermore, we strongly suspect that the additional notations introduced by these systems would preclude decoding types into a simple presentation type language. For example, Tofte's system <ref> [60] </ref> would introduce two different kinds of type variables and two different kinds of flag variables. While the two kinds of type variables would pose little problem, decoded components of union types would likely require annotations to indicate the kind of flag variable they possess internally.
Reference: [61] <author> Wright, A. K. </author> <title> Typing references by effect inference. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 473-491. </pages>
Reference-contexts: If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values.
Reference: [62] <author> Wright, A. K. </author> <title> Simple imperative polymorphism. Lisp and Symbolic Computation (1994). </title> <note> To appear in the special issue on State in Programming Languages. </note>
Reference-contexts: Figure 5.2 presents the additional static type inference rules for box operations. If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system <ref> [62] </ref>. Many solutions to this problem have been proposed [6, 14, 22, 29, 35, 38, 57, 60, 61, 62]. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values. <p> If our type system did not include polymorphic let-expressions, the preceding changes would suffice to type Box Scheme. But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system [62]. Many solutions to this problem have been proposed <ref> [6, 14, 22, 29, 35, 38, 57, 60, 61, 62] </ref>. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values. <p> But as many authors have noted, navely combining Hindley-Milner polymorphism and assignment leads to an unsound type system <ref> [62] </ref>. Many solutions to this problem have been proposed [6, 14, 22, 29, 35, 38, 57, 60, 61, 62]. We adapt our own solution [62], which is the simplest of all. This solution restricts polymorphism to syntactic values. <p> Figure 5.3 presents the additional soft typing rules for boxes and the modified rule for let-expressions. Given Type Soundness, the proofs for an extended Correctness theorem are simple extensions of those for Pure Scheme. We discuss the general advantages of our method of integrating polymorphism and assignment elsewhere <ref> [62] </ref>. In the context of soft typing, the primary advantage of our solution is simplicity: it requires no changes to the set of types. All of the other solutions add notational complexity to types, which makes reasoning with types difficult.
Reference: [63] <author> Wright, A. K., and Duba, B. F. </author> <title> Pattern matching for Scheme. </title> <type> Unpublished manuscript, </type> <year> 1993. </year> <note> Available as World Wide Web URL "ftp://cs.rice.edu/public/wright/match.ps.Z". </note>
Reference-contexts: To find a tidy upper bound of the pattern types, we use a unification algorithm. Our prototype supports a subset of a general pattern matching extension that we developed for Scheme <ref> [63] </ref>.
Reference: [64] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> To appear in: Information and Computation, </note> <year> 1994. </year>
Reference-contexts: : : [x n 7! t n ] ` v n : t n ` hx 1 ; v 1 i : : : hx n ; v n i ! e : t The details of this proof are a straightforward adaptation and simplification of our type soundness proof <ref> [64] </ref> for Tofte's method of typing boxes. The soft type inference rules for Box Scheme can be derived from the static type inference rules in the same manner as the soft typing rules for Pure Scheme are derived from its static typing rules. <p> Harper and Lillibridge [23] discovered that navely combining first-class continuations with polymorphism leads to an unsound type system, just as navely combining assignment and polymorphism does. Fortunately, the same solution of restricting polymorphism to values works for both assignment and first-class continuations <ref> [64] </ref>. By building Imperative Scheme on top of Box Scheme, we have already incorporated this restriction in our type system for Imperative Scheme. Because A-expressions can return a value of any type, proving type soundness for Imperative Scheme is not as simple as for Pure Scheme or Box Scheme. <p> Our work on type soundness for a language including call/cc shows how to exploit this observation to obtain a proof <ref> [64] </ref>. The technique adapts without difficulty to a proof of Type Soundness for Imperative Scheme. <p> , hence ~ SA ` (let ([x e 0 1 ]) e 0 The remaining cases are straightforward. 137 Appendix B Semantics of Types We use operational semantics throughout this thesis because we believe that language semantics and proofs of type soundness are most clearly expressed in an operational framework <ref> [64] </ref>. But denotational models of types as sets of values can also lend valuable intuition to reasoning about programs and types. In this appendix, we present two denotational models of types as sets of values for Pure Scheme.
References-found: 64

