URL: http://www.cs.nmsu.edu/lldap/download/jicslp/ferreira.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/ferr.html
Root-URL: http://www.cs.nmsu.edu
Email: E-mail: fmichel,luisg@ncc.up.pt  
Title: Unfolding WAM Code  
Author: Michel Ferreira and Luis Damas 
Date: September 9, 1996  
Address: 4150 Porto, Portugal  
Affiliation: LIACC, Universidade do Porto, Rua do Campo Alegre 823,  
Abstract: We present a Prolog compiler that can unfold WAM code towards obtaining efficient code for Prolog programs. The unfolder implements the principles of efficiency as stated by Van Roy: reduce instruction granularity, exploit determinism, specialize unification. It can operate without requiring abstract interpretation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Philippe Codognet and Daniel Diaz. wamcc: </author> <title> Compiling Prolog to C. </title> <booktitle> In 12th International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Suppose that we were executing the WAM code of the predicate $exec 1. From the put list (2) instruction we know that register X [2] has type list, from instruction put list (1) we deduce the same for register X <ref> [1] </ref>, and from instruction put x variable (3,3) we know that register X [3] is a new variable. <p> We now unfold this code, get list (1), unify x variable (4), unify x variable (1), get list (3), unify x value (4), unify x variable (3), execute (append/3), making use of knowing that register X <ref> [1] </ref> has type list, register X [2] has also type list, and register X [3] is a new variable, that is, a variable without any references to it. <p> In get list (1,list) we simply set S to the value of register 1. In an 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology implementation in C of the WAM instruction get list (1), while the general code would be: if (IsVar (X <ref> [1] </ref>) d1 = deref (X [1]); else d1=X [1]; if (IsVar (d1)) - trailbind (d1,MakeList ((int) H)); H++; mode = write; - else if (IsList (d1)) - S = (int *) Value (d1); mode = read; - else fail = 1; if (fail) backtrak (); the code for the complemented instruction <p> In an 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology implementation in C of the WAM instruction get list (1), while the general code would be: if (IsVar (X <ref> [1] </ref>) d1 = deref (X [1]); else d1=X [1]; if (IsVar (d1)) - trailbind (d1,MakeList ((int) H)); H++; mode = write; - else if (IsList (d1)) - S = (int *) Value (d1); mode = read; - else fail = 1; if (fail) backtrak (); the code for the complemented instruction get list (1,list) would be: <p> In an 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology implementation in C of the WAM instruction get list (1), while the general code would be: if (IsVar (X <ref> [1] </ref>) d1 = deref (X [1]); else d1=X [1]; if (IsVar (d1)) - trailbind (d1,MakeList ((int) H)); H++; mode = write; - else if (IsList (d1)) - S = (int *) Value (d1); mode = read; - else fail = 1; if (fail) backtrak (); the code for the complemented instruction get list (1,list) would be: S = (int <p> - trailbind (d1,MakeList ((int) H)); H++; mode = write; - else if (IsList (d1)) - S = (int *) Value (d1); mode = read; - else fail = 1; if (fail) backtrak (); the code for the complemented instruction get list (1,list) would be: S = (int *) Value (X <ref> [1] </ref>); Not even the mode flag would have to be set, has it will be propagated while unfolding the code, and it will complement the instructions were mode information is relevant. The unify instructions are also simplified by the propagation of information. <p> Both Parma and Aquarius depend by much on their performance on the global analysis phase. 6 1996 Compulog Net Meeting on Parallelism and Implementation Technology 2.3. wamcc The wamcc <ref> [1] </ref> compiler differs substantially from the two compilers described above. A first difference is the fact that this compiler does not compile Prolog to native code, as do both Aquarius and Parma. It compiles into C code, which can then be compiled using gcc, to generate a executable file.
Reference: [2] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and 4):103-179, 1992. 10 </volume> 1996 Compulog Net Meeting on Parallelism and Implementation Technology 
Reference-contexts: The traditional approach to this problem in logic programming is to use abstract interpretation <ref> [2] </ref> to obtain information about execution of program for standard queries. This information then allows program specialisation. <p> The only information needed is the WAM code of the clauses of the program. Figure 1 shows the WAM code for the program presented above. Suppose that we were executing the WAM code of the predicate $exec 1. From the put list (2) instruction we know that register X <ref> [2] </ref> has type list, from instruction put list (1) we deduce the same for register X [1], and from instruction put x variable (3,3) we know that register X [3] is a new variable. <p> We now unfold this code, get list (1), unify x variable (4), unify x variable (1), get list (3), unify x value (4), unify x variable (3), execute (append/3), making use of knowing that register X [1] has type list, register X <ref> [2] </ref> has also type list, and register X [3] is a new variable, that is, a variable without any references to it.
Reference: [3] <author> A. Krall and U. Neumerkel. </author> <title> The Vienna Abstract Machine. </title> <booktitle> In International Workshop in Programming Language Implementation and Logic Programming (PLIP'90), number 456 in Lecture Notes in Computer Science, </booktitle> <pages> pages 121-135. </pages> <address> Sweeden, </address> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: From the put list (2) instruction we know that register X [2] has type list, from instruction put list (1) we deduce the same for register X [1], and from instruction put x variable (3,3) we know that register X <ref> [3] </ref> is a new variable. <p> This idea has some similarities with what is done in the VAM (Vienna Abstract Machine) <ref> [3] </ref>, where goals and heads were directly unified, with the major advantage that we do not need to create a new abstract machine. <p> We now unfold this code, get list (1), unify x variable (4), unify x variable (1), get list (3), unify x value (4), unify x variable (3), execute (append/3), making use of knowing that register X [1] has type list, register X [2] has also type list, and register X <ref> [3] </ref> is a new variable, that is, a variable without any references to it. <p> In this case, we simply copy to the address register 3 points to a new list cell: *((int *) X <ref> [3] </ref>) = MakeList (H); The unify x variable (3) that appears next is known to be executed in write mode, and so register X [3] will have type var. The propagation of such information will cause the execute (append/3) instruction to be executed with arguments any, list, var. <p> In this case, we simply copy to the address register 3 points to a new list cell: *((int *) X <ref> [3] </ref>) = MakeList (H); The unify x variable (3) that appears next is known to be executed in write mode, and so register X [3] will have type var. The propagation of such information will cause the execute (append/3) instruction to be executed with arguments any, list, var. The reason why register X [0] has type any is because it was read from the heap.
Reference: [4] <author> A. Taylor. </author> <title> High Performance Prolog Implementation. </title> <type> PhD thesis, </type> <institution> University of Sydney, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: Specialize unification 4. Dataflow analysis The implementation of these principles is quite complex in the Aquarius compiler. A new intermediate language, the BAM was developed to implement the reduce instruction granularity principle. The other three principles were based on a complex dataflow analysis phase. 2.2. Parma The Parma <ref> [4] </ref> system was developed by A.Taylor in Australia in parallel with Aquarius. Many of its ideas are similar to the principles used in Aquarius. It compiles into MIPS assembly code. Parma compilation proceeds in 10 steps.
Reference: [5] <author> P. Van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> University of California at Berkeley, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: We first present three state of the art Prolog compilers. We use the wamcc compiler as the system to experiment with our ideas. We then present our unfolding algorithm in detail, and present conclusions and future work. 2. Efficient Prolog compilers 2.1. Aquarius The Aquarius compiler <ref> [5] </ref> is currently the most efficient complete system in Prolog execution. Its performance is based in four principles: 1. Reduce instruction granularity 2. Exploit determinism 3. Specialize unification 4. Dataflow analysis The implementation of these principles is quite complex in the Aquarius compiler.
Reference: [6] <author> P. Van Roy. </author> <year> 1983-1993: </year> <title> The Wonder Years of Sequential Prolog Implementation. </title> <journal> The Journal of Logic Programming, </journal> <month> 19/20, May/July </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Since the development of the WAM [7] in 1983 by D.Warren, Prolog compilation has been the subject of a great amount of investigation, deriving new optimizations and solutions <ref> [6] </ref>, aiming at leveling the execution time of Prolog programs and the execution time of programs written in imperative languages such as C or PASCAL.
Reference: [7] <author> David H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: 1. Introduction Since the development of the WAM <ref> [7] </ref> in 1983 by D.Warren, Prolog compilation has been the subject of a great amount of investigation, deriving new optimizations and solutions [6], aiming at leveling the execution time of Prolog programs and the execution time of programs written in imperative languages such as C or PASCAL.
References-found: 7

