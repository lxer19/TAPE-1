URL: http://www.ai.sri.com/~heller/Lisp/jfp.ps.Z
Refering-URL: http://www.ai.sri.com/~heller/Lisp/
Root-URL: 
Email: fhudak-paul,jones-markg@cs.yale.edu  
Title: Haskell vs. Ada vs. C++ vs. Awk vs. An Experiment in Software Prototyping Productivity  
Author: Paul Hudak Mark P. Jones 
Note: This work was supported by the Advanced Research Project Agency and the Office of Naval Research under Arpa Order 8888, Contract N00014-92-C-0153.  
Date: July 4, 1994  
Address: New Haven, CT 06518  
Affiliation: Yale University Department of Computer Science  
Abstract: We describe the results of an experiment in which several conventional programming languages, together with the functional language Haskell, were used to prototype a Naval Surface Warfare Center (NSWC) requirement for a Geometric Region Server. The resulting programs and development metrics were reviewed by a committee chosen by the Navy. The results indicate that the Haskell prototype took significantly less time to develop and was considerably more concise and easier to understand than the corresponding prototypes written in several different imperative languages, including Ada and C++. 
Abstract-found: 1
Intro-found: 1
Reference: [Car93] <author> J. Caruso. </author> <title> Prototyping demonstration problem for the prototech hiper-d joint proto-typing demonstration project. </title> <type> CCB Report 0.2, </type> <institution> Naval Surface Warfare Center, </institution> <month> August </month> <year> 1993. </year> <title> Last modified October 27, 1993; further changes specified by J. Caruso are described in "Addendum to Prototyping Demonstration Problem for the Prototech HiPer-D Joint Prototyping Demonstration Project," </title> <month> November 9, </month> <year> 1993. </year>
Reference-contexts: An informal, English-language description of the geo-server was given to all participants in the experiment. This description was oriented toward black-box behavior, and did not include performance requirements <ref> [Car93] </ref>. 3. A meeting was held at NSWC in Dahlgren, Virginia, at which participants were briefed on the geo-server problem and given additional clarifying material. 4. <p> The scope of this experiment can be gleaned somewhat from reference <ref> [Car93] </ref>, from which we quote: The AEGIS Weapons System (AWS) is an extensive array of sensors and weapons designed to defend a battle group against air, surface, and subsurface threats. The AWS is undergoing a major redesign. <p> The current AEGIS consists of millions of lines of CMS-2 code. This experiment, on the other hand, was to take place during a two week period, and the initial guidance was that about five person days of effort should be devoted to each prototype. Reference <ref> [Car93] </ref> also carefully defines the objectives for the experiment: * prototype "algorithms which compute presence of tracks within geometric regions in space." These are referred to as "doctrine-like capabilities." * "minimize work to achieve a first delivery" * "allow room for incremental enhancement." as well as the criteria for evaluating the
Reference: [CHJ93] <author> W.E. Carlson, P. Hudak, and M.P. Jones. </author> <title> An experiment using Haskell to prototype "geometric region servers" for navy command and control. </title> <type> Research Report 1031, </type> <institution> Department of Computer Science, Yale University, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Note that one consequence of the problem simplification process is evident here: the input data uses a geometric model that is two-dimensional and cartesian. An enhanced Haskell geo-server for both three dimensions and a curved-earth model was developed, but is not reported here (see <ref> [CHJ93] </ref>). <p> (110.0,37.0) -- In tight zone And to get a feel for the potential of the geo-server, here is the output of an enhanced version of the Haskell prototype, which satisfies several extra credit options posed in the original specification (but whose development metrics are not included in this paper; see <ref> [CHJ93] </ref>): Time 0.0: commercial aircraft: (38.0,25.0) --&gt; (0.0,0.0) -- Currently in tight zone hostile craft: (258.0,183.0) --&gt; (0.0,0.0) Time 20.0: commercial aircraft: (58.0,30.0) --&gt; (1.0,0.25) -- Expected in weapon doctrine at t+131.3 -- Expected in engageability zone at t+52.5 -- Expected in missile range at t+52.5 6 -- Expected in carrier <p> The code and generated output were reviewed independently by personnel at Intermetrics, Inc., who concluded that it was an accurate, extensible, understandable, and compact solution to the NSWC requirements for a prototype GEO Server <ref> [CHJ93] </ref>. <p> There were two kinds of responses: In conducting the independent design review at Intermetrics, there was a significance sense of disbelief. We quote from <ref> [CHJ93] </ref>: It is significant that Mr. Domanski, Mr. Banowetz and Dr. Brosgol were all surprised and suspicious when we told them that Haskell prototype P1 (see appendix B) is a complete tested executable program.
Reference: [Hen86] <author> P. Henderson. </author> <title> Functional programming, formal spepcification, and rapid prototyping. </title> <journal> IEEE Transactions on SW Engineering, </journal> <volume> SE-12(2):241-250, </volume> <year> 1986. </year>
Reference-contexts: This idea has of course been recognized for a long time (see for example <ref> [Hen86] </ref>), but recent trends in the software industry have increased the importance of this idea: a strong interest in the disciplined use of prototyping has arisen in contemporary theories of software engineering.
Reference: [HHLH92] <author> M.C. Harrison, C-H. Hsieh, C. Laufer, and F. Henglein. </author> <title> Polymorphism and type abstraction in the Griffin prototyping language. </title> <booktitle> In Proceedings of Software Technology Conference, </booktitle> <pages> pages 458-470. DARPA, </pages> <year> 1992. </year>
Reference-contexts: Griffin, a language designed at NYU, can be seen as somewhat of a blend of Ada, SETL, and ML. It is targeted for the same kinds of applications as Ada <ref> [HHLH92] </ref>. 3. Proteus, a language designed jointly by Duke and the University of North Carolina, is a parallel programming language with high-level, machine-independent notions of various kinds of parallelism [MRNP92]. 4.
Reference: [HPJWe92] <editor> P. Hudak, S. Peyton Jones, and P. Wadler (editors). </editor> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.2). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: The resulting ProtoTech program yielded several useful technologies, most notably a series of programming languages targeted specifically for prototyping applications. Yale University's involvement emphasized the use of the then-new functional language Haskell <ref> [HPJWe92] </ref>. In the fall of 1993, in an effort to measure the success of the ProtoTech program, ARPA conducted an experiment in collaboration with the Office of Naval Research (ONR) and the Naval Surface Warfare Center (NSWC). The experiment was conducted as follows: 1.
Reference: [LBK + 94] <author> J.A.N. Lee, B. Blum, P. Kanellakis, H. </author> <title> Crisp, and J.A. Caruso. ProtoTech HiPer-D Joint Prototyping Demonstration Project, </title> <month> February </month> <year> 1994. </year> <pages> Unpublished; 400 pages. </pages>
Reference-contexts: A second meeting was held at NSWC, at which the participants presented their solutions. Discussions also transpired concerning the proper metrics by which a good prototype should be judged. 2 7. The review panel wrote a final report summarizing their findings <ref> [LBK + 94] </ref>. The remainder of this paper discusses not only the results of the experiment as reported by the review panel, but many other issues relating to the experiment and the prototypes, in particular the Haskell prototype. <p> We will instead describe it briefly, giving an example of its behavior, and refer the interested reader to reference <ref> [LBK + 94] </ref> for the full specification. <p> This table is somewhat different from that in <ref> [LBK + 94] </ref>, and in any case should not be used alone to infer any conclusions about the experiment, especially because some of the prototypes did not actually execute. The following paragraphs describe important information that must be factored in when interpreting the results. <p> The line count of 767 is based on the actual code in <ref> [LBK + 94] </ref>, and does not include lines with only termination characters. (3) The Ada9X solution was written by an independent consultant hired by Intermetrics, Inc. The consultant was given not only the problem specification, but the Haskell solution as well. <p> It is interesting to note that the developer originally reported only 101 lines of code, but fully admitted attempting to pack as many statements into each 80-column row as possible! The line count of 250 is based on looking at the actual code in <ref> [LBK + 94] </ref> and estimating a line count based on a more reasonable notion of program formatting. <p> The developers chose instead to address software architecture issues, emphasizing Rapide's utility in that domain. For purposes of comparison, it may be best to ignore this entry, but we did not want to eliminate it from the results, since it is included in <ref> [LBK + 94] </ref>. (7) The Griffin solution was written by two members of the NYU development team. It shares the same difficulty of comparison as Rapide, in that the code was never executed; it did, however, undergo a design review, and was intended to satisfy the problem specification.
Reference: [LVB + 92] <author> D. Luckham, J. Vera, D. Bryan, L. Augustin, and F. Belz. </author> <title> Partial orderings of event sets and their application to prototyping concurrent timed systems. </title> <booktitle> In Proceedings of Software Technology Conference, </booktitle> <pages> pages 443-457. DARPA, </pages> <year> 1992. </year>
Reference-contexts: Rapide, a language developed at Stanford, uses a partial-ordering-on-events semantics and a high-level-module structure, and is targeted primarily for simulation and software archi tecture modeling <ref> [LVB + 92] </ref>. 2. Griffin, a language designed at NYU, can be seen as somewhat of a blend of Ada, SETL, and ML. It is targeted for the same kinds of applications as Ada [HHLH92]. 3.
Reference: [MRNP92] <author> P. Mills, J.H. Reif, L.S. Nyland, and J.F. Prins. </author> <title> Prototyping high-performance parallel computing applications in Proteus. </title> <booktitle> In Proceedings of Software Technology Conference, </booktitle> <pages> pages 433-442. DARPA, </pages> <year> 1992. </year> <month> 16 </month>
Reference-contexts: It is targeted for the same kinds of applications as Ada [HHLH92]. 3. Proteus, a language designed jointly by Duke and the University of North Carolina, is a parallel programming language with high-level, machine-independent notions of various kinds of parallelism <ref> [MRNP92] </ref>. 4. Relational Lisp, a language developed at ISI, is essentially Lisp enhanced with notions of relational abstraction: a database-like facility having a logic-programming feel. 5 Results The table shown in Figure 3 is a concise summary of the development metrics associated with each of the prototypes.
References-found: 8

