URL: ftp://ftp.cs.rutgers.edu/pub/allender/cc.bruschi.ps.Z
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Title: THE COMPLEXITY OF COMPUTING MAXIMAL WORD FUNCTIONS  
Author: Eric Allender, Danilo Bruschi and Giovanni Pighizzini 
Abstract: Maximal word functions occur in data retrieval applications and have connections with ranking problems, which in turn were first investigated in relation to data compression [21]. By the "maximal word function" of a language L fl , we mean the problem of finding, on input x, the lexicographically largest word belonging to L that is smaller than or equal to x. In this paper we present a parallel algorithm for computing maximal word functions for languages recognized by one-way nondeterministic auxiliary pushdown automata (and hence for the class of context-free languages). This paper is a continuation of a stream of research focusing on the problem of identifying properties others than membership which are easily computable for certain classes of languages. For a survey, see [24]. Subject classifications. 68Q15,68Q25,68Q45. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho and J. D. Ullman, </author> <title> The Theory of Parsing, Translation and Compiling, Volume I: Parsing. </title> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference: [2] <author> E. Allender, </author> <title> Invertible functions. </title> <type> Ph.D thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1985. </year>
Reference-contexts: This led for example to the complexity class ]P introduced by Valiant [36] for dealing with combinatorial enumeration problems. Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in <ref> [21, 27, 2, 11, 12] </ref>), and detector, constructor and lexicographic constructor functions considered in [35, 28]. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets
Reference: [3] <author> E. Allender, </author> <title> P-Uniform Circuit Complexity. </title> <journal> J. Assoc. Comput. Mach. </journal> <month> 36 </month> <year> (1989), </year> <month> 912-928. </month> <title> Maximal word functions 21 </title>
Reference-contexts: The following proposition indicates that this is unlikely. Proposition 5.1. There is a 1-NAuxPDA M such that NC is equal to P-uniform NC if and only if the maximal word function for M is computable by logspace-uniform NC circuits. Proof. It was shown in <ref> [3] </ref> that there is a tally set T 2 P such that T is in NC if and only if P-uniform NC is equal to NC; and it was also observed there that every tally set in P is accepted by a 1-NAuxPDA.
Reference: [4] <author> E. Allender and V. Gore, </author> <title> Rudimentary reductions revisited. </title> <booktitle> Information Processing Letters 40 (1991), </booktitle> <pages> 89-95. </pages>
Reference-contexts: If i is greater than the length of the input, then M reads an "out-of-range" symbol, "$". For more background, see <ref> [34, 4, 16] </ref> Proposition 3.1.
Reference: [5] <author> E. Allender and J. Jiao, </author> <title> Depth reduction for noncommutative arithmetic circuits. </title> <booktitle> Proc. Twenty-fifth Ann. ACM Symp. Theor. Comput., </booktitle> <pages> 515-522, </pages> <year> 1993. </year>
Reference-contexts: Now one simply applies steps 3 and 4 of Algorithm 2 to obtain the desired output. 2 (Subsequent improvements along this line may be found in <ref> [5] </ref>.) 5. Concluding comments It is natural to wonder if the results of the preceding section can be improved. The most obvious way in which one might wish to improve Theorem 4.4 is to remove the P-uniformity condition. The following proposition indicates that this is unlikely. Proposition 5.1.
Reference: [6] <author> E. Allender and R. Rubinstein, </author> <title> P-printable sets. </title> <journal> SIAM J. Comput. </journal> <volume> 17 (1988), </volume> <pages> 1193-1202. </pages>
Reference-contexts: Also, it is easy to see that if a set L is sparse, then L has a ranking function computable in polynomial time if and only if its maximal word function is feasible; it was noted in <ref> [6] </ref> that a sparse set has a feasible ranking function if and only if it is P-printable, and any P-printable set clearly has an easy-to-compute maximal word function.
Reference: [7] <author> C. Alvarez and B. Jenner, </author> <title> A note on log space optimization. </title> <type> Report, </type> <institution> L.S.I., Universitat Politecnica Catalunya, Barcelona, </institution> <year> 1992. </year>
Reference-contexts: This yields an improvement of an NC 3 algorithm for the lexicographic constructor function presented in [28]. It also yields as a corollary that Opt-L is contained in AC 1 ; this was proved earlier by Alvarez and Jenner in <ref> [7] </ref> (although it is stated in [8] that we obtained this result independently from them, we had in fact been told of their results previously). <p> Subsequently, the authors of [8] were able to improve this result to show inclusion in AC 1 <ref> [7] </ref>. Our main theorem yields this inclusion as a corollary. Corollary 4.6. [7] Opt-L AC 1 Proof. <p> Subsequently, the authors of [8] were able to improve this result to show inclusion in AC 1 <ref> [7] </ref>. Our main theorem yields this inclusion as a corollary. Corollary 4.6. [7] Opt-L AC 1 Proof. It was shown in [8] that the following problem is complete for Opt-L: take as input a nondeterministic finite automaton M and a string x, and find the largest string w x such that M accepts w.
Reference: [8] <author> C. Alvarez and B. Jenner, </author> <title> A very hard log-space counting class. </title> <institution> The-oret. Comput. Sci. </institution> <month> 107 </month> <year> (1993), </year> <pages> 3-30. </pages>
Reference-contexts: Maximal word functions were considered earlier in <ref> [8] </ref>, where they were used in characterizing the complexity class Opt-L (a subset of NC 2 ). More precisely, it was proved in [8] that the problem of computing the maximal word function for nondeterministic finite automata is complete for the class Opt-L. The paper is organized as follows. <p> Maximal word functions were considered earlier in <ref> [8] </ref>, where they were used in characterizing the complexity class Opt-L (a subset of NC 2 ). More precisely, it was proved in [8] that the problem of computing the maximal word function for nondeterministic finite automata is complete for the class Opt-L. The paper is organized as follows. <p> This yields an improvement of an NC 3 algorithm for the lexicographic constructor function presented in [28]. It also yields as a corollary that Opt-L is contained in AC 1 ; this was proved earlier by Alvarez and Jenner in [7] (although it is stated in <ref> [8] </ref> that we obtained this result independently from them, we had in fact been told of their results previously). <p> Proof. A very slight modification of the circuits Q n constructed above will yield a circuit that will produce the lexicographically minimal element of L =n if L =n 6= ;. 2 18 Allender, Bruschi & Pighizzini It was shown in <ref> [8] </ref> that the class of functions Opt-L is contained in NC 2 . Subsequently, the authors of [8] were able to improve this result to show inclusion in AC 1 [7]. Our main theorem yields this inclusion as a corollary. Corollary 4.6. [7] Opt-L AC 1 Proof. <p> Q n constructed above will yield a circuit that will produce the lexicographically minimal element of L =n if L =n 6= ;. 2 18 Allender, Bruschi & Pighizzini It was shown in <ref> [8] </ref> that the class of functions Opt-L is contained in NC 2 . Subsequently, the authors of [8] were able to improve this result to show inclusion in AC 1 [7]. Our main theorem yields this inclusion as a corollary. Corollary 4.6. [7] Opt-L AC 1 Proof. It was shown in [8] that the following problem is complete for Opt-L: take as input a nondeterministic finite automaton M <p> Subsequently, the authors of <ref> [8] </ref> were able to improve this result to show inclusion in AC 1 [7]. Our main theorem yields this inclusion as a corollary. Corollary 4.6. [7] Opt-L AC 1 Proof. It was shown in [8] that the following problem is complete for Opt-L: take as input a nondeterministic finite automaton M and a string x, and find the largest string w x such that M accepts w. <p> Maximal word functions 19 That is, one might wish to make the 1-NAuxPDA M be part of the input (as, for example, the NFA is part of the input to the maximal word problem for NFAs shown to complete for Opt-L in <ref> [8] </ref>). As stated here, the problem is not even in P, because the 1-NAuxPDA M is required only to use space at most c log n for some c that depends only on M |and thus c can be jxj for an input instance M; x.
Reference: [9] <author> J. Balc azar, J. D az and J. Gabarr o, </author> <title> Structural Complexity I. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: We also discuss relationships between maximum word functions and other related notions that have appeared in the literature. Maximal word functions 3 2. Basic Definitions It is expected that the reader is familiar with basic concepts from formal language theory and complexity theory (see <ref> [26, 9] </ref>). In the following, we briefly describe the conventions adopted throughout the paper.
Reference: [10] <author> D. A. Mix Barrington, N. Immerman, and H. Straubing, </author> <title> On uniformity within N C 1 . J. </title> <journal> Comput. System Sci. </journal> <volume> 41 (1990), </volume> <pages> 274-306. </pages>
Reference-contexts: Using the characterizations of AC 0 in terms of alternating Turing machines or in terms of first-order logic (as presented in <ref> [10] </ref>), it is easy to see that this computation can be carried out inside AC 0 . 2 As pointed out in [27], the language L considered in the proof of Proposition 3.1 can be accepted by a deterministic two-way pushdown automaton. Thus, the following corollary is immediate. Corollary 3.3.
Reference: [11] <author> A. Bertoni, D. Bruschi, and M. Goldwurm, </author> <title> Ranking and formal power series. </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 79 </month> <year> (1991), </year> <pages> 25-35. </pages>
Reference-contexts: This led for example to the complexity class ]P introduced by Valiant [36] for dealing with combinatorial enumeration problems. Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in <ref> [21, 27, 2, 11, 12] </ref>), and detector, constructor and lexicographic constructor functions considered in [35, 28]. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets
Reference: [12] <author> A. Bertoni, M. Goldwurm, and N. Sabadini, </author> <title> The complexity of computing the number of strings of given length in context free languages. </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 86 </month> <year> (1991), </year> <pages> 325-342. </pages>
Reference-contexts: This led for example to the complexity class ]P introduced by Valiant [36] for dealing with combinatorial enumeration problems. Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in <ref> [21, 27, 2, 11, 12] </ref>), and detector, constructor and lexicographic constructor functions considered in [35, 28]. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets
Reference: [13] <author> A. Borodin, S. Cook, P. Dymond, W. Ruzzo, and M. Tompa, </author> <title> Two applications of inductive counting for complementation problems. </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> 559-578. </pages>
Reference-contexts: We recall that the class of languages accepted by two-way, polynomial-time-bounded NAuxPDAs is equal to the class of languages logspace-reducible to context-free languages; for references and recent results relating to this class see <ref> [13] </ref>. Related work by Lautemann [32] shows that the class of languages accepted by 1-NAuxPDA p s is exactly the class of languages that are reducible to context-free languages via one-way logspace reductions (see also [15]).
Reference: [14] <author> F.-J. Brandenberg, </author> <title> On one-way auxiliary pushdown automata. </title> <booktitle> Proc. 3rd GI Conference, Lecture Notes in Computer Science 48 (1977), </booktitle> <pages> 133-144. </pages>
Reference-contexts: Corollary 3.3 shows that the one-way restriction cannot be removed. Although co-NTIME (log n) is incomparable with the class of languages accepted by logspace-bounded 1-NauxPDAs (1-NauxPDAs can compute parity, which is not in co-NTIME (log n) (see [20]), and <ref> [14] </ref> presents a set in co-NTIME (log n) that is not accepted by any 1-NAuxPDA using sublinear space), it seems to us that most natural and interesting extensions to 1-NAuxPDAs would include co-NTIME (log n). Maximal word functions 9 4.
Reference: [15] <author> G. Buntrock and K. </author> <title> Lory s, On Growing Context-Sensitive Languages. </title> <booktitle> Proc. 19th Int. Coll. Automata, Languages, and Programming, Lecture Notes in Computer Science 623 (1992), </booktitle> <pages> 77-88. </pages>
Reference-contexts: Related work by Lautemann [32] shows that the class of languages accepted by 1-NAuxPDA p s is exactly the class of languages that are reducible to context-free languages via one-way logspace reductions (see also <ref> [15] </ref>). Maximal word functions 5 A pushdown automaton (PDA) is a 1-NAuxPDA without the logspace-bounded auxiliary worktape. If the input head of a PDA is allowed to move left also, then it is a 2PDA.
Reference: [16] <author> S. Buss, S. Cook, A. Gupta, and V. Ramachandran, </author> <title> An optimal parallel algorithm for formula evaluation. </title> <journal> SIAM J. Comput. </journal> <volume> 21 (1992), </volume> <pages> 755-780. </pages> <note> 22 Allender, Bruschi & Pighizzini </note>
Reference-contexts: If i is greater than the length of the input, then M reads an "out-of-range" symbol, "$". For more background, see <ref> [34, 4, 16] </ref> Proposition 3.1.
Reference: [17] <author> A. Chandra, L. Stockmeyer, and U. Vishkin, </author> <title> Constant Depth Reducibility. </title> <journal> SIAM J. Comput. </journal> <volume> 13 (1984), </volume> <pages> 423-439. </pages>
Reference-contexts: Thus matrix multiplication over this semiring is easier than over the integers; integer matrix multiplication can easily be seen to be constant-depth reducible to integer multiplication (see <ref> [17, 19] </ref>), and thus cannot be done with AC 0 circuits.) It is not difficult to see that the circuits Q 1 ; : : : ; Q n have O (n 3 ) nodes and linear degree over R.
Reference: [18] <author> S. Cook, </author> <title> Characterization of pushdown machines in terms of time-bounded computers. </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 18 (1971), </volume> <pages> 4-18. </pages>
Reference-contexts: Phase 1. To define this phase of the algorithm we will make use of the notions of surface configurations and realizable pairs as introduced in <ref> [18] </ref>. <p> Using a simple variant of the algorithm presented in <ref> [18] </ref>, the following theorem can be proved. Theorem 4.1. For every 1-NAuxPDA M , the set n defined above can be computed from input 1 n in time polynomial in n.
Reference: [19] <author> S. Cook, </author> <title> A Taxonomy of Problems which have a Fast Parallel Algorithm. </title> <journal> Inf. and Comp. </journal> <volume> 64 (1985), </volume> <pages> 2-22. </pages>
Reference-contexts: An arithmetic circuit is a circuit where the OR (addition) gates and the AND (multiplication) gates are interpreted over a suitable semi-ring. For further notions of parallel computation and arithmetic circuits the reader is referred to <ref> [19, 33] </ref>. 3. How hard is it to compute maximal word functions? The purpose of this section is to capture the computational complexity of computing maximal word functions. In particular, we will give evidence that maximal word functions are harder to compute than membership functions. <p> Thus matrix multiplication over this semiring is easier than over the integers; integer matrix multiplication can easily be seen to be constant-depth reducible to integer multiplication (see <ref> [17, 19] </ref>), and thus cannot be done with AC 0 circuits.) It is not difficult to see that the circuits Q 1 ; : : : ; Q n have O (n 3 ) nodes and linear degree over R.
Reference: [20] <author> M. Furst, J. Saxe, and M. Sipser, </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <booktitle> Mathematical Systems Theory 17 (1984), </booktitle> <pages> 13-27. </pages>
Reference-contexts: Corollary 3.3 shows that the one-way restriction cannot be removed. Although co-NTIME (log n) is incomparable with the class of languages accepted by logspace-bounded 1-NauxPDAs (1-NauxPDAs can compute parity, which is not in co-NTIME (log n) (see <ref> [20] </ref>), and [14] presents a set in co-NTIME (log n) that is not accepted by any 1-NAuxPDA using sublinear space), it seems to us that most natural and interesting extensions to 1-NAuxPDAs would include co-NTIME (log n). Maximal word functions 9 4.
Reference: [21] <author> A. Goldberg and M. Sipser, </author> <title> Compression and ranking. </title> <journal> SIAM J. Com-put. </journal> <volume> 20 (1991), </volume> <pages> 524-536. </pages>
Reference-contexts: This led for example to the complexity class ]P introduced by Valiant [36] for dealing with combinatorial enumeration problems. Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in <ref> [21, 27, 2, 11, 12] </ref>), and detector, constructor and lexicographic constructor functions considered in [35, 28]. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets
Reference: [22] <author> L. Goldschlager, </author> <title> *-productions in context-free grammars. </title> <booktitle> Acta Infor-matica 16 (1981), </booktitle> <pages> 303-318. </pages>
Reference-contexts: Thus we do not get a fast parallel algorithm. This seems to be unavoidable. Recall that, for a CFG G, the problem of deciding if the empty string is in L (G) is complete for P under logspace reductions <ref> [22] </ref>. Given a CFG G, one can, in logspace, construct a 1-NAuxPDA M such that L (M ) = f*g if * 2 L (G), and otherwise L (M ) = ;.
Reference: [23] <author> L. Hemachandra and S. Rudich, </author> <title> On the complexity of ranking. </title> <journal> J. Comput. System Sci. </journal> <volume> 41 (1990), </volume> <pages> 251-271. </pages>
Reference-contexts: We write x y to indicate that string x strictly precedes y in this ordering. Given a language L fl we make the following definitions. ffi The ranking function (more precisely, such a definition of ranking function corresponds to the definition of strong ranking function as given in <ref> [23] </ref>) rank L : fl ! IN is defined by rank L (x) = #fy 2 L : y xg, ffi the detector function d L : f1g fl ! f0; 1g is defined by d L (1 n ) = 1 if and only if L contains a string of <p> In <ref> [23] </ref>, Hemachandra and Rudich study a notion related to ranking that they call p-ranking.
Reference: [24] <author> L. Hemachandra, </author> <title> Algorithms from complexity theory: polynomial-time operations for complex sets. </title> <booktitle> Proc. SIGAL Conference, Lecture Notes in Computer Science 450 (1991), </booktitle> <pages> 221-231. </pages>
Reference: [25] <author> H. Hoover, M. Klawe, and N. Pippenger, </author> <title> Bounding fan-out in logical networks. </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 31 (1984), </volume> <pages> 13-18. </pages>
Reference: [26] <author> J. Hopcroft and J. Ullman, </author> <title> Introduction to automata theory, languages and computations. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We also discuss relationships between maximum word functions and other related notions that have appeared in the literature. Maximal word functions 3 2. Basic Definitions It is expected that the reader is familiar with basic concepts from formal language theory and complexity theory (see <ref> [26, 9] </ref>). In the following, we briefly describe the conventions adopted throughout the paper. <p> We briefly recall that a one-way nondeterministic auxiliary pushdown automaton (1-NAuxPDA) is a nondeterministic Turing machine having a one-way, end-marked, read-only input tape, a pushdown tape, and one two-way, read/write work tape with a logarithmic space bound. (For more formal definitions, see <ref> [26] </ref>.) "Space" on an 1-NAuxPDA means space on the work tape only (excluding the pushdown). Without loss of generality, we make the following assumptions about 1-NAuxPDAs. 1. <p> Thus, our final goal is to compute predeq S (x). The algorithm we present consists of defining and evaluating an arithmetic circuit over a suitable commutative semiring that will be defined subsequently. The definition of the circuit is based on the well-known Cocke-Kasami-Younger recognition algorithm (see <ref> [26] </ref>). (A similar Boolean circuit construction can be found in [38].) The arithmetic circuit Q n (Q, when n is understood), is defined in the following way.
Reference: [27] <author> D. Huynh, </author> <title> The complexity of ranking simple languages. Math. </title> <booktitle> Systems Theory 23 (1990), </booktitle> <pages> 1-20. </pages>
Reference-contexts: This led for example to the complexity class ]P introduced by Valiant [36] for dealing with combinatorial enumeration problems. Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in <ref> [21, 27, 2, 11, 12] </ref>), and detector, constructor and lexicographic constructor functions considered in [35, 28]. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets <p> It was observed in <ref> [27] </ref> that L is in co-NTIME (log n). <p> Using the characterizations of AC 0 in terms of alternating Turing machines or in terms of first-order logic (as presented in [10]), it is easy to see that this computation can be carried out inside AC 0 . 2 As pointed out in <ref> [27] </ref>, the language L considered in the proof of Proposition 3.1 can be accepted by a deterministic two-way pushdown automaton. Thus, the following corollary is immediate. Corollary 3.3.
Reference: [28] <author> D. Huynh, </author> <title> Efficient detectors and constructors for simple languages. </title> <institution> In-ternat. J. Found. Comput. Sci. </institution> <month> 2 </month> <year> (1991), </year> <pages> 183-205. </pages>
Reference-contexts: Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in [21, 27, 2, 11, 12]), and detector, constructor and lexicographic constructor functions considered in <ref> [35, 28] </ref>. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets that, when considering only membership problems, are computationally equivalent. <p> This yields an improvement of an NC 3 algorithm for the lexicographic constructor function presented in <ref> [28] </ref>. It also yields as a corollary that Opt-L is contained in AC 1 ; this was proved earlier by Alvarez and Jenner in [7] (although it is stated in [8] that we obtained this result independently from them, we had in fact been told of their results previously). <p> Theorem 4.4. For all languages accepted by a 1-NAuxPDA the maximal word function is in P-uniform AC 1 . It is in logspace-uniform AC 1 for all languages accepted by a 1-NAuxPDA running in polynomial time. The following corollary improves an NC 3 algorithm that was presented in <ref> [28] </ref>. Corollary 4.5. For all languages accepted by a 1-NAuxPDA (1-NAuxPDA p ) the lexicographic constructor function is computable in P-uniform (logspace-uniform) AC 1 . Proof.
Reference: [29] <author> M. Jerrum, G. Valiant, and V. Vazirani, </author> <title> Random generation of combinatorial structures from a uniform distribution. </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 43 </month> <year> (1986), </year> <month> 169-188. </month> <title> Maximal word functions 23 </title>
Reference: [30] <author> R. Karp and V. Ramachandran, </author> <title> A survey of parallel algorithms for shared-memory machines. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <volume> vol. I, </volume> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference: [31] <author> M. Krentel, </author> <title> The complexity of optimization problems. </title> <journal> J. Comput. System Sci. </journal> <volume> 36 (1988), </volume> <pages> 490-509. </pages>
Reference-contexts: However, if P=NP, then Theorem 2.1 of <ref> [31] </ref> shows that all Opt-P functions are computable in polynomial time. (() Let M be a machine accepting some NP-complete set, running in time p (n), let p 0 (n) &gt; p (n) be a polynomial large enough to encode any configuration of M on an input of length n, and
Reference: [32] <author> C. Lautemann, </author> <title> One pushdown and a small tape. </title> <booktitle> In Dirk Siefkes, zum 50. Geburtstag (proceedings of a meeting honoring Dirk Siefkes on his fiftieth birthday), </booktitle> <editor> K. Wagner, ed., </editor> <address> Technische Universitat Berlin and Universitat Augsburg, </address> <year> 1988, </year> <pages> 42-47. </pages>
Reference-contexts: We recall that the class of languages accepted by two-way, polynomial-time-bounded NAuxPDAs is equal to the class of languages logspace-reducible to context-free languages; for references and recent results relating to this class see [13]. Related work by Lautemann <ref> [32] </ref> shows that the class of languages accepted by 1-NAuxPDA p s is exactly the class of languages that are reducible to context-free languages via one-way logspace reductions (see also [15]). Maximal word functions 5 A pushdown automaton (PDA) is a 1-NAuxPDA without the logspace-bounded auxiliary worktape.
Reference: [33] <author> G. L. Miller, V. Ramachandran, and E. Kaltofen, </author> <title> Efficient Parallel Evaluation of Straight-Line Code and Arithmetic Circuits. </title> <journal> SIAM J. Comput. </journal> <volume> 17 (1988), </volume> <pages> 687-695. </pages>
Reference-contexts: An arithmetic circuit is a circuit where the OR (addition) gates and the AND (multiplication) gates are interpreted over a suitable semi-ring. For further notions of parallel computation and arithmetic circuits the reader is referred to <ref> [19, 33] </ref>. 3. How hard is it to compute maximal word functions? The purpose of this section is to capture the computational complexity of computing maximal word functions. In particular, we will give evidence that maximal word functions are harder to compute than membership functions. <p> The most expensive step is 1, whose complexity was given in Theorem 4.1. We now wish to apply Theorem 5.3 of <ref> [33] </ref>, showing how to evaluate the circuits Q 1 ; : : : ; Q n efficiently in parallel. However, in order to apply those results, we have to define a suitable commutative semiring representing the set fl [ f?g with operations MAX and CONCAT. <p> Thus, we can make use of the algorithm of <ref> [33] </ref> for evaluation of these circuits. The algorithm presented in [33] consists of O (log n) applications of a routine called Phase, where a single application of Phase consists of nothing more complicated than matrix multiplication over the semiring R. <p> Thus, we can make use of the algorithm of <ref> [33] </ref> for evaluation of these circuits. The algorithm presented in [33] consists of O (log n) applications of a routine called Phase, where a single application of Phase consists of nothing more complicated than matrix multiplication over the semiring R. <p> Since we have observed above that, for the particular choice of R we are using, matrix multiplication can be done in constant depth, it follows that the algorithm of <ref> [33] </ref> can be implemented in logarithmic depth with unbounded fan-in AND and OR circuits.
Reference: [34] <author> W. Ruzzo, </author> <title> On uniform circuit complexity. </title> <journal> J. Comput. System Sci. </journal> <volume> 21 (1981), </volume> <pages> 365-383. </pages>
Reference-contexts: If i is greater than the length of the input, then M reads an "out-of-range" symbol, "$". For more background, see <ref> [34, 4, 16] </ref> Proposition 3.1.
Reference: [35] <author> L. Sanchis and M. Fulk, </author> <title> On the efficient generation of languages instances. </title> <journal> SIAM J. Comput. </journal> <volume> 19(2) (1990), </volume> <pages> 281-295. </pages>
Reference-contexts: Other examples are given by the notions of ranking and census functions (investigated in connection with data compression in [21, 27, 2, 11, 12]), and detector, constructor and lexicographic constructor functions considered in <ref> [35, 28] </ref>. 2 Allender, Bruschi & Pighizzini This broadening of scope turns out to be useful not only in providing a basis for theoretical investigations of applied problems, but also by helping to draw distinctions among sets that, when considering only membership problems, are computationally equivalent.
Reference: [36] <author> L. Valiant, </author> <title> The complexity of enumeration and reliability problems. </title> <journal> SIAM J. Comput. </journal> <volume> 8 (1979), </volume> <pages> 410-412. </pages>
Reference-contexts: However, beginning already with some early work in complexity theory, it was realized that focusing on zero-one-valued functions is an inadequate theoretical framework for studying the computational complexity of certain problems. This led for example to the complexity class ]P introduced by Valiant <ref> [36] </ref> for dealing with combinatorial enumeration problems.
Reference: [37] <author> H. Venkateswaran, </author> <title> Properties that characterize LOGCFL. </title> <journal> J. Comput. System Sci. </journal> <volume> 42 (1991), </volume> <pages> 380-404. </pages>
Reference-contexts: M runs in polynomial time can be seen to follow from the fact that the set f1 n ; ff : ff 2 n g can easily be recognized by a 1-NAuxPDA p , and the class of languages accepted by 1-NAuxPDA p s is a subclass of AC 1 <ref> [37] </ref>.) Now we will show how to construct a context-free grammar G n = ( = f0; 1g; V n ; P n ; S n ) generating exactly the strings of length n accepted by M , using M 's surface configurations and the set n .
Reference: [38] <author> H. Venkateswaran, </author> <title> Two dynamic programming algorithms for which interpreted pebbling helps. </title> <journal> Inf. and Comp. </journal> <volume> 92 (1991), </volume> <pages> 237-252. </pages> <institution> Manuscript received 23 April 1992 Eric Allender Department of Computer Science Rutgers University New Brunswick New Jersey 08903, USA allender@cs.rutgers.edu Danilo Bruschi Dipartimento di Scienze dell'Informazione Universita degli Studi via Comelico, 39 20135 Milano, ITALY bruschi@imiucca.csi.unimi.it 24 Allender, Bruschi & Pighizzini Giovanni Pighizzini Dipartimento di Scienze dell'Informazione Universita degli Studi via Comelico, 39 20135 Milano, ITALY pighizzi@ghost.dsi.unimi.it </institution>
Reference-contexts: The algorithm we present consists of defining and evaluating an arithmetic circuit over a suitable commutative semiring that will be defined subsequently. The definition of the circuit is based on the well-known Cocke-Kasami-Younger recognition algorithm (see [26]). (A similar Boolean circuit construction can be found in <ref> [38] </ref>.) The arithmetic circuit Q n (Q, when n is understood), is defined in the following way.
References-found: 38

