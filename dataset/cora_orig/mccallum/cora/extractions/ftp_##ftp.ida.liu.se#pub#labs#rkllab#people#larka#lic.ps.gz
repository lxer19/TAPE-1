URL: ftp://ftp.ida.liu.se/pub/labs/rkllab/people/larka/lic.ps.gz
Refering-URL: http://www.ida.liu.se/labs/rkllab/groups/FF/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Specification and Synthesis of Plans Using the Features and Fluents Framework  
Author: Lars Karlsson 
Date: March 14, 1995  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Proceedings of the Eleventh National Conference on Artificial Intelligence. AAAI Press, </institution> <address> Menlo Park, California, </address> <year> 1993. </year>
Reference-contexts: Goal: [S 2 ]clear (B) ^ [S 2 ]on (B; A) ^ [S 2 ]handEmpty. Clearly, W [ j~ [0]clear (B) ^ [0]on (B; A) ^ [0]handEmpty. 5. Proceeding from 3. Action scd1 <ref> [0; 1] </ref>U nstack (B; A) can now be added to the plan 0 , and t = 1. Remaining goal: [S 1 ]holding (B). Clearly, W [ 0 j~ [1]holding (B). 6. Proceeding from 2. <p> Proceeding from 3. Action scd1 [0; 1]U nstack (B; A) can now be added to the plan 0 , and t = 1. Remaining goal: [S 1 ]holding (B). Clearly, W [ 0 j~ [1]holding (B). 6. Proceeding from 2. Action scd2 <ref> [1; 2] </ref>P utdown (B) can now be added to the plan 0 , and t = 2. Clearly, W [ 0 j~ [2]onT able (B). The first part of goal1 has now been achieved. Remaining goal: [S 0 ]on (A; B). Select: [S 0 ]on (A; B). <p> Action scd4 [3; 4]Stack (A; B) can now be added to the plan 0 , and t = 4 Clearly, W [ 0 j~ [4]onT able (B) ^ [4]on (A; B). Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 <ref> [0; 1] </ref>U nstack (B; A) scd2 [1; 2]P utdown (B) scd3 [2; 3]P ickup (A) scd4 [3; 4]Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 <ref> [1; 2] </ref>P utdown (B) scd3 [2; 3]P ickup (A) scd4 [3; 4]Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework.
Reference: [2] <institution> Proceedings of the Second International Conference on Artificial Intelligence Planning Systems. </institution> <note> Morgan Kaufmann, </note> <year> 1994. </year>
Reference-contexts: First, all action statements are expanded according to the action expansion laws. For instance, if [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]dead (y):=T 33 is an action expansion law, then <ref> [2; 4] </ref>F ire (Rifle; F red) will expand to [2]loaded (Rifle) ) [2; 4]dead (F red):=T . Second, the abbreviations are used to translate the expanded scenario description to L (SD). 3.2.3 Occlusion and Reassignment The purpose of the Occlude predicate is to explicitly suspend the inertia assumption. <p> First, all action statements are expanded according to the action expansion laws. For instance, if [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]dead (y):=T 33 is an action expansion law, then <ref> [2; 4] </ref>F ire (Rifle; F red) will expand to [2]loaded (Rifle) ) [2; 4]dead (F red):=T . Second, the abbreviations are used to translate the expanded scenario description to L (SD). 3.2.3 Occlusion and Reassignment The purpose of the Occlude predicate is to explicitly suspend the inertia assumption. Inertia implies the minimization of changes in fluents in a scenario description. <p> The classical Yale Shooting Scenario can be expressed as below, in unexpanded version. law1 [s; t]Load (x) ; [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 <ref> [2; 4] </ref>Load (Rifle) scd2 [5; 6]F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). <p> [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 <ref> [2; 4] </ref>Load (Rifle) scd2 [5; 6]F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). This scenario can then be easily reduced to the base language. 3.2.5 Object and Fluent Domains The object domain consists of a set of distinct objects. <p> [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest (3.22) The goal of the agent is to stop being hungry; the time-point is specified as 10. goal1 [10]:hungry (3.23) The agent forms a plan to enter the restaurant and then dine. scd1 <ref> [2; 5] </ref>EnterRestaurant scd2 [7; 9]Dine (3.24) Let denote the scenario description obtained by applying the plan to the initial state. <p> The pmon completion [57] of is as follows: <ref> [0; 2] </ref>hungry ^ inStreet ^ :inRest [3; 4]hungry [5; 7]hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has <p> that hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action is added to the plan. scd1 <ref> [2; 5] </ref>EnterRestaurant scd2 [7; 9]Dine (3.31) Now, Qlaw (Scd 00 ) = f [2]inStreet; [7]inRestg. Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. <p> Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. By theorem 2, the plan is executable and achieves the goal. The solution is hK; O; hIA; Elawi; f <ref> [2; 5] </ref>EnterRestaurant; [7; 9]Dineg; ;i. 3.6 Summary In this chapter, we have defined a nonmonotonic fluent logic for scenario descriptions. The fluent logic is based on second-order circumscription, where an occlusion predicate is minimized using a minimization policy called pmon. The resulting theories are reducible to first-order logic. <p> Proceeding from 3. Action scd1 [0; 1]U nstack (B; A) can now be added to the plan 0 , and t = 1. Remaining goal: [S 1 ]holding (B). Clearly, W [ 0 j~ [1]holding (B). 6. Proceeding from 2. Action scd2 <ref> [1; 2] </ref>P utdown (B) can now be added to the plan 0 , and t = 2. Clearly, W [ 0 j~ [2]onT able (B). The first part of goal1 has now been achieved. Remaining goal: [S 0 ]on (A; B). Select: [S 0 ]on (A; B). <p> Goal: [S 4 ]clear (A) ^ [S 4 ]onT able (A) ^ [S 4 ]handEmpty. Clearly, W [ 0 j~ [2]clear (A) ^ [2]onT able (A) ^ [2]handEmpty. 9. Proceeding from 7. Action scd3 <ref> [2; 3] </ref>P ickup (A) can now be added to the plan 0 , and t = 3. Remaining goal: [S 3 ]clear (B) ^ [S 3 ]holding (A). Clearly, W [ 0 j~ [3]clear (B) ^ [3]holding (A). 60 10. Proceeding from 6. <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 <ref> [1; 2] </ref>P utdown (B) scd3 [2; 3]P ickup (A) scd4 [3; 4]Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework. <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 [1; 2]P utdown (B) scd3 <ref> [2; 3] </ref>P ickup (A) scd4 [3; 4]Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework. <p> Overlapping tasks fall within the ontological speciality C (concurrency). However, in nonlin the concurrency is of a very restricted kind, with no interaction between the overlapping actions. Therefore, we shall permit ourselves to speculate about pmon and non-primitive plan. Consider two overlapping actions, resulting in the following effects. scd1 <ref> [2; 6] </ref>p:=T (6.48) We are almost certain that pmon gives the intended results provided all cases of concurrency are of this restricted type.
Reference: [3] <editor> James Allen, James Hendler, and Austin Tate, editors. </editor> <booktitle> Readings in Planning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: The pmon completion [57] of is as follows: [0; 2]hungry ^ inStreet ^ :inRest <ref> [3; 4] </ref>hungry [5; 7]hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has to reason about partial plans where <p> Goal: [S 4 ]clear (A) ^ [S 4 ]onT able (A) ^ [S 4 ]handEmpty. Clearly, W [ 0 j~ [2]clear (A) ^ [2]onT able (A) ^ [2]handEmpty. 9. Proceeding from 7. Action scd3 <ref> [2; 3] </ref>P ickup (A) can now be added to the plan 0 , and t = 3. Remaining goal: [S 3 ]clear (B) ^ [S 3 ]holding (A). Clearly, W [ 0 j~ [3]clear (B) ^ [3]holding (A). 60 10. Proceeding from 6. <p> Action scd3 [2; 3]P ickup (A) can now be added to the plan 0 , and t = 3. Remaining goal: [S 3 ]clear (B) ^ [S 3 ]holding (A). Clearly, W [ 0 j~ [3]clear (B) ^ [3]holding (A). 60 10. Proceeding from 6. Action scd4 <ref> [3; 4] </ref>Stack (A; B) can now be added to the plan 0 , and t = 4 Clearly, W [ 0 j~ [4]onT able (B) ^ [4]on (A; B). Both parts of goal1 have now been achieved (let S 0 = 4). <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 [1; 2]P utdown (B) scd3 <ref> [2; 3] </ref>P ickup (A) scd4 [3; 4]Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework. <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 [1; 2]P utdown (B) scd3 [2; 3]P ickup (A) scd4 <ref> [3; 4] </ref>Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework. First, we identified the epistemological and ontological assumptions underlying the strips formalism.
Reference: [4] <author> James F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <year> 1984. </year> <note> Reprinted in [3]. </note>
Reference-contexts: The planning strategy is defined in terms of problem-solving rules. However, McDermott provides no formal semantics for his apparently non-monotonic logic. A similar model of time can be found in ADL [50]. Another concept of time is expressed in Allen's logic of temporal intervals <ref> [4, 5] </ref>. Instead of situations and states and instantaneous actions, properties and actions are modelled to hold over (possibly overlapping) intervals of time. The intervals can be ordered in time, and the start and end points of an interval can be associated with metric time-points. <p> First, all action statements are expanded according to the action expansion laws. For instance, if [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]dead (y):=T 33 is an action expansion law, then <ref> [2; 4] </ref>F ire (Rifle; F red) will expand to [2]loaded (Rifle) ) [2; 4]dead (F red):=T . Second, the abbreviations are used to translate the expanded scenario description to L (SD). 3.2.3 Occlusion and Reassignment The purpose of the Occlude predicate is to explicitly suspend the inertia assumption. <p> First, all action statements are expanded according to the action expansion laws. For instance, if [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]dead (y):=T 33 is an action expansion law, then <ref> [2; 4] </ref>F ire (Rifle; F red) will expand to [2]loaded (Rifle) ) [2; 4]dead (F red):=T . Second, the abbreviations are used to translate the expanded scenario description to L (SD). 3.2.3 Occlusion and Reassignment The purpose of the Occlude predicate is to explicitly suspend the inertia assumption. Inertia implies the minimization of changes in fluents in a scenario description. <p> The classical Yale Shooting Scenario can be expressed as below, in unexpanded version. law1 [s; t]Load (x) ; [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 <ref> [2; 4] </ref>Load (Rifle) scd2 [5; 6]F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). <p> [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 <ref> [2; 4] </ref>Load (Rifle) scd2 [5; 6]F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). This scenario can then be easily reduced to the base language. 3.2.5 Object and Fluent Domains The object domain consists of a set of distinct objects. <p> The pmon completion [57] of is as follows: [0; 2]hungry ^ inStreet ^ :inRest <ref> [3; 4] </ref>hungry [5; 7]hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has to reason about partial plans where <p> Action scd3 [2; 3]P ickup (A) can now be added to the plan 0 , and t = 3. Remaining goal: [S 3 ]clear (B) ^ [S 3 ]holding (A). Clearly, W [ 0 j~ [3]clear (B) ^ [3]holding (A). 60 10. Proceeding from 6. Action scd4 <ref> [3; 4] </ref>Stack (A; B) can now be added to the plan 0 , and t = 4 Clearly, W [ 0 j~ [4]onT able (B) ^ [4]on (A; B). Both parts of goal1 have now been achieved (let S 0 = 4). <p> Both parts of goal1 have now been achieved (let S 0 = 4). The plan 0 is scd1 [0; 1]U nstack (B; A) scd2 [1; 2]P utdown (B) scd3 [2; 3]P ickup (A) scd4 <ref> [3; 4] </ref>Stack (A; B). (4.17) It is easily verified that the plan is executable and achieves the goal. 4.5 Summary In this chapter, we have analysed and reconstructed the strips planner within the Features and Fluents framework. First, we identified the epistemological and ontological assumptions underlying the strips formalism. <p> Condition typing will be explained later. Each entry is associated with a list of contributors. An example of a GOST entry during a house building task is &lt;<SUPERVISED &lt;<SCAFFOLDING ERECTED&gt;> TRUE 6&gt;> with the contributor list <ref> [4] </ref>. nonlin-type causal links state that the value of a condition should be protected during an interval; we will refer to such causal links as value-protective causal links. 86 6.3 SNLP | a Causal Link Planner McAllester's and Rosenblitt's systematic nonlinear planner (snlp) [40] refines the use of causal links. snlp
Reference: [5] <author> James F. Allen. </author> <title> Temporal reasoning and planning. </title> <editor> In Allen, Kautz, Pelavin, and Tenenberg, editors, </editor> <title> Reasoning About Plans. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1991. </year>
Reference-contexts: The planning strategy is defined in terms of problem-solving rules. However, McDermott provides no formal semantics for his apparently non-monotonic logic. A similar model of time can be found in ADL [50]. Another concept of time is expressed in Allen's logic of temporal intervals <ref> [4, 5] </ref>. Instead of situations and states and instantaneous actions, properties and actions are modelled to hold over (possibly overlapping) intervals of time. The intervals can be ordered in time, and the start and end points of an interval can be associated with metric time-points. <p> The classical Yale Shooting Scenario can be expressed as below, in unexpanded version. law1 [s; t]Load (x) ; [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]Load (Rifle) scd2 <ref> [5; 6] </ref>F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). <p> (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]Load (Rifle) scd2 <ref> [5; 6] </ref>F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). This scenario can then be easily reduced to the base language. 3.2.5 Object and Fluent Domains The object domain consists of a set of distinct objects. <p> [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest (3.22) The goal of the agent is to stop being hungry; the time-point is specified as 10. goal1 [10]:hungry (3.23) The agent forms a plan to enter the restaurant and then dine. scd1 <ref> [2; 5] </ref>EnterRestaurant scd2 [7; 9]Dine (3.24) Let denote the scenario description obtained by applying the plan to the initial state. <p> The pmon completion [57] of is as follows: [0; 2]hungry ^ inStreet ^ :inRest [3; 4]hungry <ref> [5; 7] </ref>hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has to reason about partial plans where unexecutable actions <p> that hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action is added to the plan. scd1 <ref> [2; 5] </ref>EnterRestaurant scd2 [7; 9]Dine (3.31) Now, Qlaw (Scd 00 ) = f [2]inStreet; [7]inRestg. Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. <p> Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. By theorem 2, the plan is executable and achieves the goal. The solution is hK; O; hIA; Elawi; f <ref> [2; 5] </ref>EnterRestaurant; [7; 9]Dineg; ;i. 3.6 Summary In this chapter, we have defined a nonmonotonic fluent logic for scenario descriptions. The fluent logic is based on second-order circumscription, where an occlusion predicate is minimized using a minimization policy called pmon. The resulting theories are reducible to first-order logic.
Reference: [6] <author> Michael Beetz and Drew McDermott. </author> <title> Improving robot plans and their execution. </title> <booktitle> In AIPS94 [2]. </booktitle>
Reference-contexts: The classical Yale Shooting Scenario can be expressed as below, in unexpanded version. law1 [s; t]Load (x) ; [s; t]loaded (y):=T law2 [s; t]F ire (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]Load (Rifle) scd2 <ref> [5; 6] </ref>F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). <p> (x; y) ; [s]loaded (x) ) [s; t]alive (y):=F obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]Load (Rifle) scd2 <ref> [5; 6] </ref>F ire (Rifle; F red) (3.8) In expanded version, it reads as follows. obs1 [0]alive (F red) ^ :loaded (Rifle) scd1 [2; 4]loaded (Rifle):=T scd2 [5]loaded (Rifle) ) [5; 6]alive (F red):=F (3.9) Observe that the elements labeled scd are now members of Law (Scd). This scenario can then be easily reduced to the base language. 3.2.5 Object and Fluent Domains The object domain consists of a set of distinct objects. <p> Overlapping tasks fall within the ontological speciality C (concurrency). However, in nonlin the concurrency is of a very restricted kind, with no interaction between the overlapping actions. Therefore, we shall permit ourselves to speculate about pmon and non-primitive plan. Consider two overlapping actions, resulting in the following effects. scd1 <ref> [2; 6] </ref>p:=T (6.48) We are almost certain that pmon gives the intended results provided all cases of concurrency are of this restricted type. <p> Naturally, in a realistically complex environment it is only possible to anticipate for a limited span of time forward. 7.2.5 Replanning Everything cannot be anticipated. If an unanticipated event occurs that interferes with the plan, the agent will have to revise its plan to suit the new 115 circumstances <ref> [63, 6] </ref>. 7.2.6 Structural Partiality We can assume that in many real-life domains, the agent has no possibility to anticipate the future in any detail, and even less so, plan in any detail for more than the very closest future. There are several reasons for this.
Reference: [7] <author> Susanne Biundo and Dietmar Dengler. </author> <title> The logical language for planning LLP. </title> <note> Research Report, German Research Center for Artificial Intelligence, </note> <year> 1994. </year>
Reference-contexts: In addition modal logics have been used for temporal reasoning and planning. Rosenschein [53], using dynamic logic, is a pioneer in this area, and there is further dynamic-logic-based work by Stephan and Biundo [60]. The logical language for planning (LLP) <ref> [8, 7] </ref> is an interval-based modal temporal logic. The temporal ontology of LLP is based on discrete sets of states, and intervals are sequences of states. There is no metric time in LLP and actions are instantaneous. Planning is performed deductively and guided by proof tactics. <p> ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest (3.22) The goal of the agent is to stop being hungry; the time-point is specified as 10. goal1 [10]:hungry (3.23) The agent forms a plan to enter the restaurant and then dine. scd1 [2; 5]EnterRestaurant scd2 <ref> [7; 9] </ref>Dine (3.24) Let denote the scenario description obtained by applying the plan to the initial state. <p> The pmon completion [57] of is as follows: [0; 2]hungry ^ inStreet ^ :inRest [3; 4]hungry <ref> [5; 7] </ref>hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has to reason about partial plans where unexecutable actions <p> intermediate stages of the plan synthesis process partial plans. 39 Consider the following example. law1 [t; t 0 ]EnterRestaurant ; [t]inStreet ) [t; t 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T law2 [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.26) In this partial plan for satisfying the hunger of the agent, one action has been added to the plan: [7; 9]Dine. In this situation, we might want to reason about how adding this action affects the world. <p> 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T law2 [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.26) In this partial plan for satisfying the hunger of the agent, one action has been added to the plan: [7; 9]Dine. In this situation, we might want to reason about how adding this action affects the world. However, no new conclusions can be obtained by reasoning in the epistemological speciality K. The precondition [7]inRest of [7; 9]Dine is not true, and therefore the action has no effects. <p> satisfying the hunger of the agent, one action has been added to the plan: <ref> [7; 9] </ref>Dine. In this situation, we might want to reason about how adding this action affects the world. However, no new conclusions can be obtained by reasoning in the epistemological speciality K. The precondition [7]inRest of [7; 9]Dine is not true, and therefore the action has no effects. Generally, in K a partial plan might be totally without any effects, or only a few of the intended effects occur. <p> problem can be observed. qlaw1 [t; t 0 ]EnterRestaurant ; [t]inStreet elaw1 [t; t 0 ]EnterRestaurant ; [t; t 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T qlaw2 [t; t 0 ]Dine ; [t]inRest elaw2 [t; t 0 ]Dine ; [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.27) In Q, an unexecutable action results in the undefined state. In either case, we might be in trouble when it comes to drawing interesting conclusions from a partial plan. There is nothing wrong about the presence of unexecutable actions in a partial plan. <p> By a transfor- mation to K, we can conclude that hK; O; hIA; Elawi; Scd; Obsi j~ hN ; O; f [4]hungrygi In order to achieve f [4]:hungryg, an action is added to the plan. The new schedule is called Scd 0 . scd1 <ref> [7; 9] </ref>Dine (3.30) Now we can observe that hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action <p> hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action is added to the plan. scd1 [2; 5]EnterRestaurant scd2 <ref> [7; 9] </ref>Dine (3.31) Now, Qlaw (Scd 00 ) = f [2]inStreet; [7]inRestg. Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. <p> By theorem 2, the plan is executable and achieves the goal. The solution is hK; O; hIA; Elawi; f [2; 5]EnterRestaurant; <ref> [7; 9] </ref>Dineg; ;i. 3.6 Summary In this chapter, we have defined a nonmonotonic fluent logic for scenario descriptions. The fluent logic is based on second-order circumscription, where an occlusion predicate is minimized using a minimization policy called pmon. The resulting theories are reducible to first-order logic.
Reference: [8] <author> Susanne Biundo, Dietmar Dengler, and Jana Koehler. </author> <title> Deductive planning and plan reuse in a command language environment. </title> <booktitle> In Proceedings of the Tenth European Conference on Artificial Intelligence, </booktitle> <pages> pages 628-632. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: In addition modal logics have been used for temporal reasoning and planning. Rosenschein [53], using dynamic logic, is a pioneer in this area, and there is further dynamic-logic-based work by Stephan and Biundo [60]. The logical language for planning (LLP) <ref> [8, 7] </ref> is an interval-based modal temporal logic. The temporal ontology of LLP is based on discrete sets of states, and intervals are sequences of states. There is no metric time in LLP and actions are instantaneous. Planning is performed deductively and guided by proof tactics.
Reference: [9] <author> George S. Boolos and Richard C. Jeffrey. </author> <title> Computability and Logic. </title> <publisher> Cambridge University Press, </publisher> <address> 2nd edition, </address> <year> 1980. </year> <month> 123 </month>
Reference-contexts: A theory of this domain, including &lt; and the successor function 0 , is decidable as proven by Presburger (see e.g. <ref> [9, p. 219] </ref>). Besides the integers, which are fixed temporal constants, a set of unfixed temporal constants is available. <p> ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest (3.22) The goal of the agent is to stop being hungry; the time-point is specified as 10. goal1 [10]:hungry (3.23) The agent forms a plan to enter the restaurant and then dine. scd1 [2; 5]EnterRestaurant scd2 <ref> [7; 9] </ref>Dine (3.24) Let denote the scenario description obtained by applying the plan to the initial state. <p> The pmon completion [57] of is as follows: [0; 2]hungry ^ inStreet ^ :inRest [3; 4]hungry [5; 7]hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest <ref> [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10] </ref>:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis process where the ego has to reason about partial plans where unexecutable actions occur. <p> intermediate stages of the plan synthesis process partial plans. 39 Consider the following example. law1 [t; t 0 ]EnterRestaurant ; [t]inStreet ) [t; t 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T law2 [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.26) In this partial plan for satisfying the hunger of the agent, one action has been added to the plan: [7; 9]Dine. In this situation, we might want to reason about how adding this action affects the world. <p> 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T law2 [t; t 0 ]Dine ; [t]inRest ) [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.26) In this partial plan for satisfying the hunger of the agent, one action has been added to the plan: [7; 9]Dine. In this situation, we might want to reason about how adding this action affects the world. However, no new conclusions can be obtained by reasoning in the epistemological speciality K. The precondition [7]inRest of [7; 9]Dine is not true, and therefore the action has no effects. <p> satisfying the hunger of the agent, one action has been added to the plan: <ref> [7; 9] </ref>Dine. In this situation, we might want to reason about how adding this action affects the world. However, no new conclusions can be obtained by reasoning in the epistemological speciality K. The precondition [7]inRest of [7; 9]Dine is not true, and therefore the action has no effects. Generally, in K a partial plan might be totally without any effects, or only a few of the intended effects occur. <p> problem can be observed. qlaw1 [t; t 0 ]EnterRestaurant ; [t]inStreet elaw1 [t; t 0 ]EnterRestaurant ; [t; t 0 ]inStreet:=F ^ [t; t 0 ]inRest:=T qlaw2 [t; t 0 ]Dine ; [t]inRest elaw2 [t; t 0 ]Dine ; [t; t 0 ]hungry:=F obs1 [0]hungry obs2 [0]inStreet obs3 [0]:inRest scd1 <ref> [7; 9] </ref>Dine goal1 [10]:hungry (3.27) In Q, an unexecutable action results in the undefined state. In either case, we might be in trouble when it comes to drawing interesting conclusions from a partial plan. There is nothing wrong about the presence of unexecutable actions in a partial plan. <p> By a transfor- mation to K, we can conclude that hK; O; hIA; Elawi; Scd; Obsi j~ hN ; O; f [4]hungrygi In order to achieve f [4]:hungryg, an action is added to the plan. The new schedule is called Scd 0 . scd1 <ref> [7; 9] </ref>Dine (3.30) Now we can observe that hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action <p> hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [10]:hungrygi However, Qlaw (Scd) = f [7]inRestg and hK; O; hIA; Elawi; Scd 0 ; Obsi j~ hN ; O; f [7]:inRestgi In order to achieve f [7]inRestg, another action is added to the plan. scd1 [2; 5]EnterRestaurant scd2 <ref> [7; 9] </ref>Dine (3.31) Now, Qlaw (Scd 00 ) = f [2]inStreet; [7]inRestg. Furthermore, hK; O; hIA; Elawi; Scd 00 ; Obsi j~ hN ; O; f [2]inStreet; [7]inRest; [10]:hungrygi Thus, the plan achieves both the goal and the qualifications of all actions. <p> By theorem 2, the plan is executable and achieves the goal. The solution is hK; O; hIA; Elawi; f [2; 5]EnterRestaurant; <ref> [7; 9] </ref>Dineg; ;i. 3.6 Summary In this chapter, we have defined a nonmonotonic fluent logic for scenario descriptions. The fluent logic is based on second-order circumscription, where an occlusion predicate is minimized using a minimization policy called pmon. The resulting theories are reducible to first-order logic.
Reference: [10] <author> Michael E. Bratman, David J. Israel, and Martha E. Pollack. </author> <title> Plans and resource-bounded practical reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 4(4) </volume> <pages> 349-355, </pages> <year> 1988. </year>
Reference-contexts: has several advantages [66]. * The search space can be reduced. * It simplifies the task of encoding domain knowledge. * It facilitates the interleaving of planning and execution, by making it possible to fully expand only some portions of the plan, including those that need to be executed immediately <ref> [10] </ref>. The third point is of great interest for agents operating under time constraints and with limited knowledge, as in the advanced case identified in chapter 2. A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. <p> However, the agent might have goals that require reasoning about more than the very closest future, and therefore will have to form plans that stretch over a relatively long time span into the future. A solution to this conflict might be found in the use of structurally partial plans <ref> [10] </ref>. As explained by Durfee and Lesser [20]: A plan represents specific actions for the near future and more general actions for the distant future.
Reference: [11] <author> Rodney A. Brooks. </author> <title> How to build complete creatures rather than isolated cognitive simulators. </title> <editor> In Kurt VanLehn, editor, </editor> <booktitle> Architectures for Intelligence, </booktitle> <pages> pages 225-240. </pages> <publisher> Lawrence Erlbaum Associates, </publisher> <address> Hillsdale, New Jersey, </address> <year> 1991. </year>
Reference-contexts: There are alternative approaches where symbolic reasoning is not taken as a primitive aspect of intelligence, but (if it exists at all) as a property emerging from lower sub-symbolic processes. Connectionist models (see e.g. [30]) and Brook's subsumption architecture <ref> [11] </ref> are examples of such approaches. Having adopted a symbolic approach, we have to find ways to represent and compute the problems of reasoning the agent will face in its environment.
Reference: [12] <author> David Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32 </volume> <pages> 333-377, </pages> <year> 1987. </year> <note> Reprinted in [3]. </note>
Reference-contexts: Restrictions on the world structure can therefore result in considerable gains in planning efficiency. When discussing efficiency, we should observe that planning with a first-order representation with variables or function symbols (e.g. strips) generally is undecidable <ref> [12, 22] </ref>. Consequently, conventional measures from complexity theory do not suffice when it comes to assessing the difficulty of non-trivial planning problems and techniques. However, measures from complexity theory can be applied to subproblems such as temporal projection. <p> The planner that is analysed and reconstructed is strips. The epistemological and ontological assumptions underlying the planner are identified, an FL representation is presented, and finally the algorithm is adapted to this new representation. Chapter 5 analyses partial-order precondition-achievement planning in the shape of tweak <ref> [12] </ref>. The key result in this chapter is the truth criterion for partial-order plans, an FL version of the modal truth criterion of tweak. Chapter 6 analyses two principles that might have a considerable value also for non-traditional planning: causal links and task decomposition. <p> Thus, precondition-achievement planning has a regressive character. In this chapter, we analyse and reconstruct the total-order planner strips [24]. In the next two chapters, we will do the same thing for the partial-order planners tweak <ref> [12] </ref> and McAllester's and Rosenblitt's systematic non-linear planner (snlp) [40]. 4.2 Introduction to STRIPS strips is a total-order planner. The search space of plans is traversed in a regressive manner. <p> Qlaw represents the qualification laws in the form: qlaw [t; t 0 ]A ( x ) ; [t]fi ( x ) (4.13) where [t]fi (x) is the precondition description. 4.4.1 A Truth Criterion for STRIPS-I The concept of truth criteria was first introduced by Chapman <ref> [12] </ref> for his partial-order planner tweak, which is presented in the next section. A truth criterion supports the computation of whether a predicate is true or false in a particular situation in the plan. <p> The operators of the original strips formalism are very restricted in their expressiveness. Basically the same kind of operators are used in many other planners, for instance tweak <ref> [12] </ref>, snlp [40] and for primitive (non-decomposable) operators in hierarchical planners such as O-Plan [14] and sipe [63] (with the addition of resource specification). In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. <p> In the next chapter, we will take the step of removing the g (for ground) from Q pg , thereby introducing the least commitment principle as realized in non-linear planning. 62 Chapter 5 TWEAK: a Partial-Order Planner 5.1 An Introduction to TWEAK The tweak planner <ref> [12] </ref> is based on the least commitment principle, stating that during the planning process, decisions about for instance the order between two steps should not be made until they have to be made. tweak has two new major features compared to strips. 1. The plans of tweak are partially ordered. <p> Chapman suggests using a dependency-directed breadth-first search strategy (see e.g. [13]). As the algorithm is based on the necessary and sufficient MTC, it is correct and complete. Theorem 5 (Correctness/Completeness) <ref> [12] </ref> If tweak, given a problem, terminates claiming a solution, the plan it produces does in fact solve the problem. <p> S 4 + 1]P ickup (A) scd3 [S 2 ; S 2 + 1]Stack (A; B). (5.34) It is easily verified that the plan is executable and achieves the goal. 74 5.3.4 Proof of the Truth Criterion for TWEAK The proof presented here follows the structure of Chapman's original proof <ref> [12] </ref>. Recall that [t]ffi fl def = Occlude (t; ffi). Furthermore, when something is stated to be a plan, this means an FL-tweak plan = hLaw; Scd; Obsi as previ ously defined. Nch is the corresponding no-change premises. <p> The QA mechanism can be considered to serve purposes similar to those of a truth criterion. Compare the concept of critical nodes to the establishers and clobberers in the modal truth criterion of tweak <ref> [12] </ref>. nonlin starts with a single goal representing the task to be planned. The control cycle is as follows. procedure NONLIN (initial network ) 1. Decompose a node in the network using an appropriate schema. 2. Correct for any interactions introduced. 3. <p> Unfortunately, it is not perfectly clear how this criterion should be formulated, and this has lead to some confusion. Chapman provides two definitions. The first is in plain language. Theorem 9 (Modal Truth Criterion) <ref> [12] </ref> A proposition p is necessarily true in a situation s iff two conditions hold: there is a situation t equal or necessarily previous to s in which p is necessarily asserted; and for every step C possibly before s and every proposition q possibly codesignating with p which C denies, <p> the status of the statements on the last line: asserts (W; r) and (p q ) p r)? Should these statements hold in the incomplete plan, or should they hold in all completions (necessary truth)? To sort these questions out, we shall go back to Chapman's proof of the MTC <ref> [12, pp. 553-555] </ref>. The proof is divided into three parts. The two first parts prove the contrapositive of the "only if" direction: if there is no establisher, or if there is a clobberer, then p is not necessarily true.
Reference: [13] <author> Eugene Charniak and Drew McDermott. </author> <title> Introduction to Artificial Intelligence. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: The symbols _ and 9 represent nondeterministic choice-points; ^ denotes that all outgoing branches must be followed. the goal-achievement procedure is called and the preconditions of any new steps become new goals. Chapman suggests using a dependency-directed breadth-first search strategy (see e.g. <ref> [13] </ref>). As the algorithm is based on the necessary and sufficient MTC, it is correct and complete. Theorem 5 (Correctness/Completeness) [12] If tweak, given a problem, terminates claiming a solution, the plan it produces does in fact solve the problem.
Reference: [14] <author> Ken Currie and Austin Tate. O-Plan: </author> <title> the open planning architecture. </title> <journal> Artificial Intelligence, </journal> <volume> 52(1) </volume> <pages> 49-86, </pages> <year> 1991. </year>
Reference-contexts: The operators of the original strips formalism are very restricted in their expressiveness. Basically the same kind of operators are used in many other planners, for instance tweak [12], snlp [40] and for primitive (non-decomposable) operators in hierarchical planners such as O-Plan <ref> [14] </ref> and sipe [63] (with the addition of resource specification). In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. Research is currently in progress to incorporate ramification [58] and concurrency [65] into FL. <p> Causal links constitute one of the basic elements in hierarchical or de-compositional operator planning. Higher-level tasks can be decomposed into subtasks on a lower level of detail. This powerful planning technique has been realized in many of the most successful planning systems, such as non-lin, O-Plan <ref> [14] </ref> and sipe [63]. 6.1 Causal Links Causal links encode teleological information; a causal link on condition p between step W and step S states that one of the purposes of W is to supply p for S. A causal link has two implications. <p> A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. Some of 94 the more notable are noah [56], nonlin [61], Deviser [62], O-Plan <ref> [14] </ref> and sipe [63]. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning. <p> It does not possess all the features of planners such as sipe [63] and its own successor, O-Plan <ref> [14] </ref>. However, nonlin suffices to touch upon the main features regarding decomposition. 6.6.1 Plan Representation The data structure representing a nonlin plan is a network of nodes and links between these nodes. There is a distinction between goal nodes, action nodes and phantom nodes.
Reference: [15] <author> Ernest Davis. </author> <title> Representation of Commonsense Reasoning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: To deal with qualifications, the trajectory semantics will be modified slightly. We introduce the undefined state f, which is a function from features to the undefined value ?. It is essentially the same thing as what Davis <ref> [15] </ref> calls the "twilight zone", a distinguished impossible state from which there is no escape. <p> Levesque et.al. [59, 35] adapt Moore's possible-worlds model of knowledge to situation calculus. They define a logical programming language, golog, for robot behavior where perception and knowledge acquisition are integral parts. Knowledge-preconditions have also been studied by Morgenstern [47] and Davis <ref> [15] </ref>. The SENS P by Etzioni et.al. [23] is a strips-style operator-based planner which distinguishes between pre- and postconditions of information and of cause. 118 Appendix A Some Clarifying Remarks Concerning TWEAK The central concept of tweak is the so-called modal truth criterion.
Reference: [16] <author> Thomas Dean, R. James Firby, and David Miller. </author> <title> Hierarchical planning involving deadlines, travel time, and resources. </title> <journal> Computational Intelligence, </journal> <volume> 4(4) </volume> <pages> 381-398, </pages> <year> 1988. </year> <note> Reprinted in [3]. </note>
Reference-contexts: A regressive planner that exploits this capability is presented in [51]. An alternative to temporal logics is to store temporal information in a time map manager (TMM). The hierarchical planner FORBIN <ref> [16] </ref> is built on top of a TMM that records the partial plan the planner is currently working on and calculates information needed during the planning process. When the planner modifies the plan, e.g. by adding an action or a constraint, this is realised as a change in the TMM.
Reference: [17] <author> Patrick Doherty. </author> <title> Notes on PMON circumscription. </title> <type> Technical report, </type> <institution> Department of Computer and Information Science, Linkoping University, </institution> <year> 1994. </year>
Reference-contexts: Here, we will define a reified and typed fluent logic (FL) with the non-negative integers for time domain. It is an extension of a fluent logic introduced in Doherty and Lukaszewicz [19] and used in [18] and specified in detail in <ref> [17] </ref>. It is based on Sandewall [57]. The extension lies in the introduction of fluents with arguments. 1 FL is a representation which is not restricted to plan synthesis. <p> Occlude; ()) = (Occlude) ^ 8::[() ^ &lt; Occlude] (3.17) We shall write j~ ff (3.18) M OD P MON () (3.19) for M OD (P M ON ()) where M OD (T ) denotes the model set of a theory T . 3.2.8 FL Chronicles as Logic Programs Doherty <ref> [18, 17] </ref> has shown that pmon circumscription results in first-order-reducible theories. Consequently, classical theorem proving techniques can be applied to scenario descriptions. 3.2.9 Restricted Monotonicity of FL Scenario Descriptions As shown by Doherty [17], FL chronicles have the restricted monotonicity property [38]. <p> Consequently, classical theorem proving techniques can be applied to scenario descriptions. 3.2.9 Restricted Monotonicity of FL Scenario Descriptions As shown by Doherty <ref> [17] </ref>, FL chronicles have the restricted monotonicity property [38]. Some classes of statements of a non-monotonic formalism monotonically increases the set of valid conclusions when added to a set of premises. Such classes can be identified for FL scenario descriptions. <p> A chronicle 00 = hO; Law; Scd; Obs [ fli is a monotonic extension of for any set of observations fl. 37 Proof See Doherty <ref> [17] </ref>. 2 To summarize, temporal and atemporal constraints and observations can be added without invalidating any previous conclusions. 3.2.10 FL for Q No logic for the epistemological speciality Q is presented by Sandewall [57], and none will be proposed here. <p> Three aspects have to be considered. * Scenario representation. A preliminary study as how to and how much of a scenario description can be encoded into a logic program is considered in Doherty <ref> [17] </ref>. Further research is needed to decide to what extent this can be attained and how efficient such an implementation would be. * Operations on scenarios. The elementary reasoning problems occurring in planning have to be encoded in some way.
Reference: [18] <author> Patrick Doherty. </author> <title> Reasoning about action and change using occlusion. </title> <booktitle> In Proceedings of the Eleventh European Conference on Artificial Intelligence. </booktitle> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: Here, we will define a reified and typed fluent logic (FL) with the non-negative integers for time domain. It is an extension of a fluent logic introduced in Doherty and Lukaszewicz [19] and used in <ref> [18] </ref> and specified in detail in [17]. It is based on Sandewall [57]. The extension lies in the introduction of fluents with arguments. 1 FL is a representation which is not restricted to plan synthesis. <p> The capital letter S with index is used to denote these. 3.2.7 Minimizing change in FL The criterion used for minimization of change is called pmon (Pointwise Minimization of Occlusion with No-Change premises). pmon has been proven correct for the K-IA class of scenarios [57] and reformulated in Doherty <ref> [18] </ref>. The idea is to minimize occlusion | "allowed change" | and then filter away those models where there are unoccluded changes. For this purpose, we use an additional axiom set of nochange premises as follows ( denotes 'exclusive or'). <p> Occlude; ()) = (Occlude) ^ 8::[() ^ &lt; Occlude] (3.17) We shall write j~ ff (3.18) M OD P MON () (3.19) for M OD (P M ON ()) where M OD (T ) denotes the model set of a theory T . 3.2.8 FL Chronicles as Logic Programs Doherty <ref> [18, 17] </ref> has shown that pmon circumscription results in first-order-reducible theories. Consequently, classical theorem proving techniques can be applied to scenario descriptions. 3.2.9 Restricted Monotonicity of FL Scenario Descriptions As shown by Doherty [17], FL chronicles have the restricted monotonicity property [38].
Reference: [19] <author> Patrick Doherty and Witold Lukaszewicz. </author> <title> Circumscribing features and fluents. </title> <booktitle> In Proceedings of the 1st International Conference on Temporal Reasoning, </booktitle> <pages> pages 82-100. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Here, we will define a reified and typed fluent logic (FL) with the non-negative integers for time domain. It is an extension of a fluent logic introduced in Doherty and Lukaszewicz <ref> [19] </ref> and used in [18] and specified in detail in [17]. It is based on Sandewall [57]. The extension lies in the introduction of fluents with arguments. 1 FL is a representation which is not restricted to plan synthesis.
Reference: [20] <author> Edmund H. Durfee and Victor R. Lesser. </author> <title> Incremental planning to control a blackboard-based problem solver. </title> <booktitle> In Proceedings of the Fifth National Conference on Artificial Intelligence. </booktitle> <publisher> AAAI Press, </publisher> <address> Menlo Park, California, </address> <year> 1986. </year> <month> 124 </month>
Reference-contexts: A solution to this conflict might be found in the use of structurally partial plans [10]. As explained by Durfee and Lesser <ref> [20] </ref>: A plan represents specific actions for the near future and more general actions for the distant future.
Reference: [21] <author> Kutluhan Erol, James Hendler, and Dana Nau. UCMP: </author> <title> A sound and complete procedure for hierarchical task network planning, </title> <note> 1994. Submitted to AAAI-94. </note>
Reference-contexts: In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning. Young et.al. [66] and Erol et.al. <ref> [21] </ref> have given formal descriptions of hierarchical planning systems. These formalizations have in common a sequential modelling of actions and no advanced condition typing.
Reference: [22] <author> Kutluhan Erol, Dana S. Nau, </author> <title> and V.S. Subrahmanian. When is planning decidable? In Artificial Intelligence Planning Systems: </title> <booktitle> Proceedings of the First International Conference, </booktitle> <year> 1992. </year>
Reference-contexts: Restrictions on the world structure can therefore result in considerable gains in planning efficiency. When discussing efficiency, we should observe that planning with a first-order representation with variables or function symbols (e.g. strips) generally is undecidable <ref> [12, 22] </ref>. Consequently, conventional measures from complexity theory do not suffice when it comes to assessing the difficulty of non-trivial planning problems and techniques. However, measures from complexity theory can be applied to subproblems such as temporal projection.
Reference: [23] <author> Oren Etzioni, Steve Hanks, Daniel Weld, Denise Draper, Neal Lesh, and Mike Williamson. </author> <title> An approach to planning with incomplete information. </title> <booktitle> In Principles of Knowledge Representation and Reasoning: Proceedings of the Third International Conference. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Levesque et.al. [59, 35] adapt Moore's possible-worlds model of knowledge to situation calculus. They define a logical programming language, golog, for robot behavior where perception and knowledge acquisition are integral parts. Knowledge-preconditions have also been studied by Morgenstern [47] and Davis [15]. The SENS P by Etzioni et.al. <ref> [23] </ref> is a strips-style operator-based planner which distinguishes between pre- and postconditions of information and of cause. 118 Appendix A Some Clarifying Remarks Concerning TWEAK The central concept of tweak is the so-called modal truth criterion.
Reference: [24] <author> Richard E. Fikes and Nils J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> <volume> 2 </volume> <pages> 189-208, </pages> <year> 1971. </year> <note> Reprinted in [3]. </note>
Reference-contexts: These planners generally follow an operator-based approach and fall under two main categories: precondition-achievement planners, and hierarchical or decompositional planners. The concept of situations from the situation calculus appears in precondition-achievement planning as well. The strips planner by Fikes and Nilsson <ref> [24] </ref> represents situations as sets of first-order logic sentences. In order to sidestep the problem with frame axioms in situation calculus, strips does not represent actions (called operators) and their effects as entities within the logic, but as transformations on sets of sentences. <p> For instance, the ontological designator IAdC characterizes the assumption of strong inertia, alternative but deterministic results of actions and possible concurrency of actions. Let us see how the ontological taxonomy relates to traditional planning. The most well-known formalism is the strips formalism <ref> [24] </ref>, where actions are characterized by one set of preconditions and one set of effects, independent of state. (Actually the effects are defined in terms of two sets, called 18 the add and delete lists. strips will be investigated in more detail later in the thesis.) strips appears to fall within <p> Thus, precondition-achievement planning has a regressive character. In this chapter, we analyse and reconstruct the total-order planner strips <ref> [24] </ref>. In the next two chapters, we will do the same thing for the partial-order planners tweak [12] and McAllester's and Rosenblitt's systematic non-linear planner (snlp) [40]. 4.2 Introduction to STRIPS strips is a total-order planner. The search space of plans is traversed in a regressive manner. <p> An advantage of this mode of procedure is that the resulting partial plans are always executable. We will now make an attempt to characterize the semantics underlying the strips assumption, and from there move on to a strips in Fluent Logic. As the original article by Fikes and Nilsson <ref> [24] </ref> only gives a syntactic characterization of operators and states, we will have to start from this and try to translate it to a state-based semantics. <p> The points of reassignment are easily identified in a totally or partially ordered plan. It's usefulness is most clear in tweak and snlp. 7.1.3 STRIPS The total-order precondition-achievement planner strips <ref> [24] </ref> is analysed in a five-step process. First a formal model of the planner is presented.
Reference: [25] <author> Maria Fox and Derek Long. </author> <title> A note on Chapman's modal truth criterion. </title> <booktitle> In Progress in Artificial Intelligence, 6th Portugese Conference on AI, </booktitle> <pages> pages 307-310. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Observe that the disjunction after the denial statement has been turned into an implication, and that the negation there consequently has been eliminated. This should avoid the problems observed by Fox and Long <ref> [25] </ref>, which they claim makes the MTC an unnecessary condition (although still sufficient). 2true (p; s) 9t:2t s ^ 2asserted-in (p; t) ^ 8C: 2s C _ 8q: 2denies (C; q) ) 2 (p 6 q) _ 2W s ^ 9r:2asserts (W; r) ^ 2 (p q ) p r) (A.3)
Reference: [26] <author> Michael J. Genesereth and Nils J. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: There appears to be no restriction that this set of formulae should give a complete description of the world. Consequently, world models will be interpreted as partial states (or sets of states). An alternative approach 48 is to use a closed world assumption <ref> [26] </ref>: everything not explicitly stated to be true is assumed to be false. 4.2.2 STRIPS Operators and Plans A strips operator ff is a transformation on world models. An operator description for ff is a triple (P re ff ; Del ff ; Add ff ).
Reference: [27] <author> Michael Georgeff and Amy Lansky. </author> <title> Reactive reasoning and planning. </title> <booktitle> In Proceedings of the Sixth National Conference on Artificial Intelligence. </booktitle> <publisher> AAAI Press, </publisher> <address> Menlo Park, California, </address> <year> 1987. </year>
Reference-contexts: However, most hierarchical planners use structural partial plans only as intermediate representations during the planning process. The idea is to act upon structurally partial plans; to use the plan before it is completely specified. The PRS system by Georgeff and Lansky <ref> [27] </ref> does this. If we think of structural partiality in terms of scenarios, the agent may maintain scenario descriptions of the future on a number of different levels of detail.
Reference: [28] <editor> M.P. Georgeff and A.L. Lansky, editors. </editor> <booktitle> Reasoning about Actions and Plans: Proceedings of the 1986 Workshop. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference: [29] <author> Cordell Green. </author> <title> Applications of theorem proving to problem solving. </title> <booktitle> In Proceedings of the First International Joint Conference on Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1969. </year> <note> Reprinted in [3]. </note>
Reference-contexts: McCarthy and Hayes [43] were the first to describe the so-called frame problem. In short, it concerns how to represent the persistence of all the facts that are not influenced when a specific action is performed. Green <ref> [29] </ref> used a situation calculus-type representation, and showed how theorem proving could be used to find plans which solve specific problems.
Reference: [30] <author> Stephen Grossberg, </author> <title> editor. </title> <booktitle> Neural Networks and Natural Intelligence. </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: There are alternative approaches where symbolic reasoning is not taken as a primitive aspect of intelligence, but (if it exists at all) as a property emerging from lower sub-symbolic processes. Connectionist models (see e.g. <ref> [30] </ref>) and Brook's subsumption architecture [11] are examples of such approaches. Having adopted a symbolic approach, we have to find ways to represent and compute the problems of reasoning the agent will face in its environment.
Reference: [31] <author> J.R. Hobbs and R.C. Moore, </author> <title> editors. Formal Theories of the Common-sense World. </title> <publisher> Ablex, </publisher> <address> Norwood, New Jersey, </address> <year> 1985. </year> <month> 125 </month>
Reference: [32] <institution> Proceedings of the Fifth International Joint Conference on Artificial Intelligence. </institution> <note> Morgan Kaufmann, </note> <year> 1977. </year>
Reference: [33] <author> Subbarao Kambhampati and Dana S. Nau. </author> <title> On the nature and role of modal truth criteria in planning. </title> <booktitle> In AIPS94 [2]. </booktitle>
Reference-contexts: For instance, all completions of a plan are totally ordered and instantiated, and therefore the plan itself is necessarily totally ordered and instantiated <ref> [33] </ref>. 65 A plan P is a solution to a problem iff for each completion ff 2 Comp (P ) the following holds. 1. For all ff i in ff, ff i 2 O. 2. Applicable (ff; M 0 ). 3. G Result (ff; M 0 ). <p> A subject of discussion is whether the truth criterion applies to partial plans or to complete and valid (executable) plans alone. Kambhampati and 66 Nau <ref> [33] </ref> distinguishes between modal truth and modal conditional truth; the latter assumes that steps always have effects. Modal conditional truth is independent of the validity of plans and therefore more suitable for partial plans.
Reference: [34] <author> Robert Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> Elsevier Science Publishing, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: Kowalski <ref> [34] </ref> introduced a reified representation. Reification means that statements about the world are represented as terms and not as predicates in the language. In temporal reasoning, a H olds predicate is often used to represent what holds in a situation.
Reference: [35] <author> Yves Lesperance, Hector J. Levesque, Fangzhen Lin, Daniel Marcu, Raymond Reiter, and Richard B. Scherl. </author> <title> A logical approach to high-level robot programming | a progress report, </title> <booktitle> 1994. Submitted to the AAAI Fall Symposium on Control of the Physical World by Intelligent Systems. </booktitle>
Reference-contexts: The theory is based on a possible worlds-semantics, which elegantly combines two sorts of accessibility relations: one for knowledge, and one for the external result of different actions. Actions which result in 117 a change of the agent's knowledge are called informative actions. Levesque et.al. <ref> [59, 35] </ref> adapt Moore's possible-worlds model of knowledge to situation calculus. They define a logical programming language, golog, for robot behavior where perception and knowledge acquisition are integral parts. Knowledge-preconditions have also been studied by Morgenstern [47] and Davis [15].
Reference: [36] <author> Vladimir Lifschitz. </author> <title> Computing circumscription. </title> <booktitle> In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 121-127. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1985. </year>
Reference-contexts: For this purpose, we use an additional axiom set of nochange premises as follows ( denotes 'exclusive or'). NCH = f 8f; t:Holds (t; f )Holds (t+1; f ) ) Occlude (t+1; f ) g (3.15) The pmon minimization policy is defined as follows, using second-order circumscription <ref> [36, 39] </ref> to minimize Occlude while keeping Holds fixed. The circumscription operation is performed on scenario descriptions in the base language. We will use the abbreviation U &lt; V for 8x:(U (x) ) V (x)) ^ :(U (x) ) V (x)).
Reference: [37] <author> Vladimir Lifschitz. </author> <title> On the semantics of STRIPS. </title> <note> In Georgeff and Lansky [28]. </note>
Reference-contexts: As the original article by Fikes and Nilsson [24] only gives a syntactic characterization of operators and states, we will have to start from this and try to translate it to a state-based semantics. The formal description of strips in the following subsections is inspired by Lifschitz <ref> [37] </ref>. 4.2.1 World Models and States Fikes and Nilsson use world models to describe states. A world model is represented by a set of well-formed closed FOPC (first-order predicate calculus) formulae. There appears to be no restriction that this set of formulae should give a complete description of the world. <p> Applicable (ff; M 0 ). 3. Result (ff; M 0 ) ` G. 50 4.2.4 Soundness and Essential Formulae Operators are defined as syntactic transformations of world models. This is problematic; it is easy to construct strips systems that are unsound. Lifs-chitz <ref> [37] </ref> suggests selecting a set E of formulae as essential. Only essential formulae are allowed to change by means of Del and Add; non-essential formulae occurring in M 0 (or in the add- or deletelist of any operator) have to be true in all world models. <p> Finally, a world model M is satisfied in a state s if every element of M is satisfied in s. Lifschitz definition of soundness is as follows. 2 Definition 7 <ref> [37] </ref> An operator description (P re; Del; Add) is sound relative to an action f if, for every state s such that P re is satisfied in s, 1. f is applicable in state s, 2. every essential sentence which is satisfied in s and does not belong to Del is <p> Theorem 3 <ref> [37] </ref> If is sound, and a plan ff is accepted by , then the action f ff is applicable in the initial state s 0 and the world model Result (ff; M 0 ) is satisfied in the state f ff (s 0 ). 4.2.5 The STRIPS Algorithm The strips algorithm
Reference: [38] <author> Vladimir Lifschitz. </author> <title> Restricted monotonicity. </title> <booktitle> In AAAI93 [1]. </booktitle>
Reference-contexts: Consequently, classical theorem proving techniques can be applied to scenario descriptions. 3.2.9 Restricted Monotonicity of FL Scenario Descriptions As shown by Doherty [17], FL chronicles have the restricted monotonicity property <ref> [38] </ref>. Some classes of statements of a non-monotonic formalism monotonically increases the set of valid conclusions when added to a set of premises. Such classes can be identified for FL scenario descriptions.
Reference: [39] <author> Witold Lukaszewicz. </author> <title> Non-monotonic Reasoning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: For this purpose, we use an additional axiom set of nochange premises as follows ( denotes 'exclusive or'). NCH = f 8f; t:Holds (t; f )Holds (t+1; f ) ) Occlude (t+1; f ) g (3.15) The pmon minimization policy is defined as follows, using second-order circumscription <ref> [36, 39] </ref> to minimize Occlude while keeping Holds fixed. The circumscription operation is performed on scenario descriptions in the base language. We will use the abbreviation U &lt; V for 8x:(U (x) ) V (x)) ^ :(U (x) ) V (x)).
Reference: [40] <author> David McAllester and David Rosenblitt. </author> <title> Systematic nonlinear planning. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence. </booktitle> <publisher> AAAI Press, </publisher> <address> Menlo Park, California, </address> <year> 1991. </year>
Reference-contexts: Chapter 6 analyses two principles that might have a considerable value also for non-traditional planning: causal links and task decomposition. The latter principle is commonly called hierarchical planning. The causal-link planner snlp <ref> [40] </ref> and the decompositional planner nonlin [61] are analysed and reconstructed. Chapter 7 contains a concluding discussion. It also draws the lines for future research and suggests methods for planning in the advanced case. <p> Thus, precondition-achievement planning has a regressive character. In this chapter, we analyse and reconstruct the total-order planner strips [24]. In the next two chapters, we will do the same thing for the partial-order planners tweak [12] and McAllester's and Rosenblitt's systematic non-linear planner (snlp) <ref> [40] </ref>. 4.2 Introduction to STRIPS strips is a total-order planner. The search space of plans is traversed in a regressive manner. <p> The operators of the original strips formalism are very restricted in their expressiveness. Basically the same kind of operators are used in many other planners, for instance tweak [12], snlp <ref> [40] </ref> and for primitive (non-decomposable) operators in hierarchical planners such as O-Plan [14] and sipe [63] (with the addition of resource specification). In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. <p> A common means for handling precondition-effect interferences in partial-order planning is by causal links between steps requiring certain conditions and steps asserting these conditions. The technique has been used for instance in nonlin [61] and snlp <ref> [40] </ref>. Causal links constitute one of the basic elements in hierarchical or de-compositional operator planning. Higher-level tasks can be decomposed into subtasks on a lower level of detail. <p> ERECTED&gt;> TRUE 6&gt;> with the contributor list [4]. nonlin-type causal links state that the value of a condition should be protected during an interval; we will refer to such causal links as value-protective causal links. 86 6.3 SNLP | a Causal Link Planner McAllester's and Rosenblitt's systematic nonlinear planner (snlp) <ref> [40] </ref> refines the use of causal links. snlp is a partial-order lifted planning algorithm in the tradition of strips and tweak. 6.3.1 Operators and Plans The operators of snlp are strips-style: hP re; Add; Deli. <p> The snlp causal links are more constraining, as any influence on the condition is considered a violation. Such causal links will be called influence-protective causal links. A nonlinear plan consists of a symbol table, a set of causal links, and a set of safety conditions. Definition 10 <ref> [40] </ref> A nonlinear plan is called complete if the following conditions hold. * Every step name appearing in the causal links and safety conditions has an entry in the symbol table. * If w is a step name in the symbol table, and w has precondition P , then the plan <p> Lemma 5 (rewording of <ref> [40] </ref>) Any completion of a complete nonlinear plan is a solution. 6.3.2 Planning Besides being a sound and complete planner like tweak, snlp also possesses the property of systematicity. A systematic planner never examines the same plan more than once. <p> Furthermore, snlp make no use of a modal truth criterion. No such criterion is needed: the definition of a complete nonlinear plan above ensures that the MTC holds for every precondition of every step in the plan. The snlp planning procedure is as follows <ref> [40] </ref>. Procedure FIND-COMPLETION (fi; c) 1. If the nonlinear plan fi is order inconsistent, or the total cost of the steps in fi is not greater than c, then fail. 2. If the nonlinear plan fi is complete then return fi. 3.
Reference: [41] <author> John McCarthy. </author> <title> Situations, actions, and causal laws. </title> <type> Technical Report Memo nr 2, </type> <institution> Stanford Artificial Intelligence Project, </institution> <year> 1962. </year>
Reference-contexts: As they are two closely related topics, their respective histories have much in common and the influence has been mutual. The first temporal representation used in AI was the situation calculus, introduced by McCarthy and Hayes <ref> [41, 43] </ref>. Situation calculus is based on first-order logic. It models the state of the world over time in terms of situations. No notion of metric time is involved; time progression is generated by the sequential application of actions, which take the world from one situation to another.
Reference: [42] <editor> John McCarthy. </editor> <booktitle> Epistemological problems of artificial intelligence. In IJCAI77 [32]. </booktitle>
Reference-contexts: The lack of information is strictly limited to the case when the action is not executable, and can be interpreted as "it should not be possible for this action to occur". The term "qualification" as used here should not be confused with the qualification problem <ref> [42] </ref>. The latter, also epistemological in nature, denotes the problem of knowing all those conditions which normally hold (e.g. the presence of air when lighting a match) but which in rare cases can prevent the action from being executed. To deal with qualifications, the trajectory semantics will be modified slightly.
Reference: [43] <author> John McCarthy and Patrick J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <journal> Machine Intelligence, </journal> <volume> 4 </volume> <pages> 463-502, </pages> <year> 1969. </year> <note> Reprinted in [3]. </note>
Reference-contexts: As they are two closely related topics, their respective histories have much in common and the influence has been mutual. The first temporal representation used in AI was the situation calculus, introduced by McCarthy and Hayes <ref> [41, 43] </ref>. Situation calculus is based on first-order logic. It models the state of the world over time in terms of situations. No notion of metric time is involved; time progression is generated by the sequential application of actions, which take the world from one situation to another. <p> McCarthy and Hayes <ref> [43] </ref> were the first to describe the so-called frame problem. In short, it concerns how to represent the persistence of all the facts that are not influenced when a specific action is performed. <p> In the future scenarios with branching time suggested above, observations are needed after each branching to decide which branch was realised. The problem was treated as early as 1969 by McCarthy and Hayes <ref> [43] </ref>, where they presented the first temporal representation in A.I. Their term "knowledge-preconditions" denotes epistemic conditions on the execution of an action. Moore [46] presents a first-order modal theory of knowledge and actions.
Reference: [44] <author> Drew McDermott. </author> <title> A temporal logic for reasoning about processes and plans. </title> <journal> Cognitive Science, </journal> <volume> 6, </volume> <year> 1982. </year> <note> Reprinted in [3]. 126 </note>
Reference-contexts: Not much can be found about planning with a metric time model. Mc-Dermott <ref> [44, 45] </ref> sketches a logic where metric time is added to a situation-based representation. Each situation is associated with a point in time. A branching time structure supports reasoning about different possible courses of events.
Reference: [45] <author> Drew McDermott. </author> <title> Reasoning about plans. </title> <note> In Hobbs and Moore [31]. </note>
Reference-contexts: Not much can be found about planning with a metric time model. Mc-Dermott <ref> [44, 45] </ref> sketches a logic where metric time is added to a situation-based representation. Each situation is associated with a point in time. A branching time structure supports reasoning about different possible courses of events.
Reference: [46] <author> Robert C. Moore. </author> <title> A formal theory of knowledge and action. </title> <note> In Hobbs and Moore [31], chapter 9. </note>
Reference-contexts: The problem was treated as early as 1969 by McCarthy and Hayes [43], where they presented the first temporal representation in A.I. Their term "knowledge-preconditions" denotes epistemic conditions on the execution of an action. Moore <ref> [46] </ref> presents a first-order modal theory of knowledge and actions. The theory is based on a possible worlds-semantics, which elegantly combines two sorts of accessibility relations: one for knowledge, and one for the external result of different actions.
Reference: [47] <author> Leora Morgenstern. </author> <title> Knowledge preconditions for actions and plans. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: Levesque et.al. [59, 35] adapt Moore's possible-worlds model of knowledge to situation calculus. They define a logical programming language, golog, for robot behavior where perception and knowledge acquisition are integral parts. Knowledge-preconditions have also been studied by Morgenstern <ref> [47] </ref> and Davis [15]. The SENS P by Etzioni et.al. [23] is a strips-style operator-based planner which distinguishes between pre- and postconditions of information and of cause. 118 Appendix A Some Clarifying Remarks Concerning TWEAK The central concept of tweak is the so-called modal truth criterion.
Reference: [48] <author> Allen Newell. </author> <title> The knowledge level. </title> <journal> Artificial Intelligence, </journal> <volume> 18(1) </volume> <pages> 81-132, </pages> <year> 1982. </year>
Reference-contexts: It consists of one or more agents and a material system M. An agent has two parts: an ego K where the reasoning capabilities of the agent resides, corresponding to Newell's knowledge level <ref> [48] </ref>; and a vehicle V which is the physical and pre-symbolic interface between the ego and the reality (the material system and the other agents). The vehicle is typically equipped with perceptors (e.g. sensors, cameras) and actuators (e.g. robot arms, wheels, speakers).
Reference: [49] <author> Nils J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1980. </year> <note> Also published by Springer-Verlag 1982. </note>
Reference-contexts: The recursive version presented here is based upon a version by Nilsson <ref> [49] </ref>, but has been modified to suit our notation. The symbol denotes a (partial) plan, S denotes a world model, and finally G is a set of goal sentences.
Reference: [50] <author> Edwin P.D. Pednault. </author> <title> Formulating multiagent, dynamic-world problems in the classical planning framework. </title> <note> In Georgeff and Lansky [28]. </note>
Reference-contexts: Each line of branches is called a chronicle, and all the chronicles have a common dense time-line. The planning strategy is defined in terms of problem-solving rules. However, McDermott provides no formal semantics for his apparently non-monotonic logic. A similar model of time can be found in ADL <ref> [50] </ref>. Another concept of time is expressed in Allen's logic of temporal intervals [4, 5]. Instead of situations and states and instantaneous actions, properties and actions are modelled to hold over (possibly overlapping) intervals of time. <p> This makes it easy to compute what is true or false in a situation, but limits the expressiveness 7 considerably. For instance, the strips formalism cannot represent context--dependent actions. Furthermore, there is no metric time and actions are instantaneous. Pednault's Action Description Language (ADL) <ref> [50] </ref> combines properties of the situation calculus and the strips formalism. Unlike strips, ADL can represent context-dependent actions, i.e. actions whose effects depend on the situation in which they are executed. A regressive planner that exploits this capability is presented in [51].
Reference: [51] <author> Edwin P.D. Pednault. </author> <title> Synthesizing plans that contain actions with context-dependent effects. </title> <journal> Computational Intelligence, </journal> <volume> 4 </volume> <pages> 356-372, </pages> <year> 1988. </year>
Reference-contexts: Pednault's Action Description Language (ADL) [50] combines properties of the situation calculus and the strips formalism. Unlike strips, ADL can represent context-dependent actions, i.e. actions whose effects depend on the situation in which they are executed. A regressive planner that exploits this capability is presented in <ref> [51] </ref>. An alternative to temporal logics is to store temporal information in a time map manager (TMM). The hierarchical planner FORBIN [16] is built on top of a TMM that records the partial plan the planner is currently working on and calculates information needed during the planning process. <p> Some recent planners such as Sipe [63] deal with concurrency in terms of resource sharing, and would consequently belong to the IebC assumption. Pednault's ADL supports planning with context-dependent actions (A or Ad) <ref> [51] </ref>. 2.1.5 The Epistemological Taxonomy The ego might have more or less correct and complete knowledge about action laws, action and event occurrences and feature values. This knowledge is usually expressed in scenario descriptions.
Reference: [52] <author> Mark A. Peot and David E. Smith. </author> <title> Threat-removal strategies for partial-order planning. </title> <booktitle> In AAAI93 [1]. </booktitle>
Reference-contexts: These formalizations have in common a sequential modelling of actions and no advanced condition typing. Some formal studies about conflict resolving in partial-order plans that are applicable to hierarchical planning have also been made, for instance Peot and Smith <ref> [52] </ref>. 6.6 NONLIN | a Decompositional Planner As an example of a decompositional planner, we will study Tate's nonlin [61]. It does not possess all the features of planners such as sipe [63] and its own successor, O-Plan [14].
Reference: [53] <author> Stanley J. Rosenschein. </author> <title> Plan synthesis: A logical perspective. </title> <booktitle> In Proceedings of the Seventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 331-37. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1981. </year> <note> Reprinted in [3]. </note>
Reference-contexts: The intervals can be ordered in time, and the start and end points of an interval can be associated with metric time-points. Planning is implemented in a deductive manner, with a Horn-clause logic. In addition modal logics have been used for temporal reasoning and planning. Rosenschein <ref> [53] </ref>, using dynamic logic, is a pioneer in this area, and there is further dynamic-logic-based work by Stephan and Biundo [60]. The logical language for planning (LLP) [8, 7] is an interval-based modal temporal logic.
Reference: [54] <author> Eric Rutten and Joachim Hertzberg. </author> <title> Temporal planner = nonlinear planner + time map manager. </title> <journal> AI Communications, </journal> <volume> 6(1) </volume> <pages> 18-26, </pages> <year> 1993. </year>
Reference-contexts: When the planner modifies the plan, e.g. by adding an action or a constraint, this is realised as a change in the TMM. The intricate interaction between planner and TMM has been studied by Rutten and Hertzberg <ref> [54] </ref>. For hierarchical planners such as nonlin [61], planning information and temporal information is encoded in a so-called hierarchical task network (HTN). The effects of actions are propagated in the network, and a query-answering system is used to decide the truth of a statement in a node in the network.
Reference: [55] <author> Earl D. Sacerdoti. </author> <title> Planning in a hierarchy of abstraction spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5 </volume> <pages> 115-135, </pages> <year> 1974. </year>
Reference-contexts: The term "hierarchical planning" is commonly used in the literature. However, this term is also often used for planners that rely on other kinds of hierarchies such as hierarchical search trees and abstraction by removing less important predicates from the domain description <ref> [55] </ref>. Therefore, we will stick to the less ambiguous term "decomposition" here.
Reference: [56] <author> Earl D. Sacerdoti. </author> <title> The nonlinear nature of plans. </title> <booktitle> In Proceedings of the Fourth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 206-214. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1975. </year> <note> Reprinted in [3]. </note>
Reference-contexts: Causal links in NONLIN The roots of causal links can be traced back to the decompositional planner nonlin [61], although the term did not come into use until later. nonlin keeps a "Goal Structure" (GOST) which stores preconditions of steps together with a list of their "contributors". nonlin's predecessor NOAH <ref> [56] </ref> could not make this distinction between effects required and effects not required by some subsequent step. A GOST entry has the schematic form &lt;<conditiontype condition value step&gt;> where step is the name of the step requiring that condition has value. Condition typing will be explained later. <p> A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. Some of 94 the more notable are noah <ref> [56] </ref>, nonlin [61], Deviser [62], O-Plan [14] and sipe [63]. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning.
Reference: [57] <author> Erik Sandewall. </author> <title> Features and Fluents. </title> <publisher> Oxford Press, </publisher> <year> 1994. </year>
Reference-contexts: In TMM's the emphasis has been on representing temporal relations, whereas an HTN action-subaction relations have played an important role. 1.2 Features and Fluents This thesis follows the tradition of using temporal logics for planning. The subject is treated within Sandewall's Features and Fluents framework <ref> [57] </ref>, which takes a systematic approach to the analysis and construction of temporal logics. <p> Temporal logics can here provide a common basis suitable for comparison and evaluation. 1.3.2 Planning and the Systematic Approach Our investigation will be based on Sandewall's systematic approach. Sande-wall states that <ref> [57, p.32] </ref> ...The ego's understanding of its world is in terms of (discrete valued) features and occurrences. The understanding is intended to be used for prediction, postdiction (e.g. diagnosis), generalization, planning etc. <p> Chapter 7 contains a concluding discussion. It also draws the lines for future research and suggests methods for planning in the advanced case. We assume that the reader has a sufficient background in the fields of logic and artificial intelligence. Acquaintance with Sandewall's Features and Fluents <ref> [57] </ref> is an advantage but not a prerequisite. The parts that are relevant for this work will recapitulated in chapters 2 and 3. 12 Chapter 2 Playing the Game: Anticipation and Planning in Ego-World Semantics 2.1 Introduction to Inhabited Dynamical Systems Erik Sandewall's book Features and Fluents [57] addresses the knowledge <p> Features and Fluents <ref> [57] </ref> is an advantage but not a prerequisite. The parts that are relevant for this work will recapitulated in chapters 2 and 3. 12 Chapter 2 Playing the Game: Anticipation and Planning in Ego-World Semantics 2.1 Introduction to Inhabited Dynamical Systems Erik Sandewall's book Features and Fluents [57] addresses the knowledge representation and reasoning about inert and inhabited dynamical systems. A system is a dynamical if properties of objects and relationships between objects may change over time. <p> We shall make a number of extensions to Sandewall's game concept <ref> [57] </ref>. The basic case with a single-agent IDS without material events can be considered a special case. Each occurrence designator E 2 E is associated with an initiator Init (E), which can be a specific agent or the material system. <p> Goal descriptions, stating nothing outside what the goals are, typically belong to speciality N . Plans are typically combined with future scenario descriptions, and will therefore belong to the same speciality. 2.6 Summary This chapter has presented the IDS concept and the underlying semantics <ref> [57] </ref>. The ego-world game, when complemented with a minimal model of the ego, provides a formal basis for a definition of the planning concept. In short, the purpose of planning is to find ways to play the game so that the goals of the ego are achieved. <p> A language for scenario descriptions is presented, a fluent logic. We also show how the fluent logic can be used for representing plans, and problems with partial plans are discussed. 3.1 Formal Definition of Reasoning Problems Definition 1 A scenario description <ref> [57] </ref> is a tuple hZ; 1 ; 2 ; : : :; k i where Z identifies the epistemological assumptions made about the scenario, and the succeeding elements are sets of formulae or other formal objects. <p> Definition 2 <ref> [57] </ref> For a given scenario description , M od () shall denote the set of infinite developments which are correctly described by . The entailment relation fl is defined fl 0 , M od () M od ( 0 ). Definition 3 [57] The set M od (; rm) of weakened <p> Definition 2 <ref> [57] </ref> For a given scenario description , M od () shall denote the set of infinite developments which are correctly described by . The entailment relation fl is defined fl 0 , M od () M od ( 0 ). Definition 3 [57] The set M od (; rm) of weakened models for is defined as fhM; Ri j hB; M; R; A; Ci 2 M od () for some B; A; Cg The weakened entailment relation fl rm is defined fl rm 0 , M od (; rm) M od ( 0 <p> Definition 4 A k-adic reasoning problem <ref> [57] </ref> is a fourtuple hh 1 ; 2 ; : : : ; k i; ffi; ;; ti where all i are scenario descriptions, ffi is a set of scenario descriptions wherein the solution is to be found, ; is a (k+1)-ary relation over scenario descriptions written as 1 ; 2 <p> Here, we will define a reified and typed fluent logic (FL) with the non-negative integers for time domain. It is an extension of a fluent logic introduced in Doherty and Lukaszewicz [19] and used in [18] and specified in detail in [17]. It is based on Sandewall <ref> [57] </ref>. The extension lies in the introduction of fluents with arguments. 1 FL is a representation which is not restricted to plan synthesis. <p> The capital letter S with index is used to denote these. 3.2.7 Minimizing change in FL The criterion used for minimization of change is called pmon (Pointwise Minimization of Occlusion with No-Change premises). pmon has been proven correct for the K-IA class of scenarios <ref> [57] </ref> and reformulated in Doherty [18]. The idea is to minimize occlusion | "allowed change" | and then filter away those models where there are unoccluded changes. For this purpose, we use an additional axiom set of nochange premises as follows ( denotes 'exclusive or'). <p> [ fli is a monotonic extension of for any set of observations fl. 37 Proof See Doherty [17]. 2 To summarize, temporal and atemporal constraints and observations can be added without invalidating any previous conclusions. 3.2.10 FL for Q No logic for the epistemological speciality Q is presented by Sandewall <ref> [57] </ref>, and none will be proposed here. As will be shown, this problem can be side-stepped by reasoning in K. 3.2.11 Intended Models FL with pmon is a logic which is applicable to the K-IA class. We will give a brief explanation here what this means. <p> We will give a brief explanation here what this means. Scenario descriptions are used in two ways: as descriptions of sets of ego-world games M od (), and as FL chronicles where M OD P MON () is the set of preferred logical models of . Sandewall <ref> [57] </ref> uses the same symbols for features/fluents and constants in the underlying semantics and in the logics. We will have to define a function T from FL models to IDS developments, where FL fluent and constant symbols are mapped to the features, objects and constants of the development. <p> The set of intended models () of a scenario is defined by the following equation: T (()) = M od (; RM) (3.20) pmon is applicable for scenario descriptions of K-IA <ref> [57] </ref>: () = M OD P MON () (3.21) For more on assessment of applicability, consult Sandewall [57]. 3.3 Plan Specification The intention is to use scenario descriptions to specify the world of a planning problem, the goals, and the resulting plan. <p> The set of intended models () of a scenario is defined by the following equation: T (()) = M od (; RM) (3.20) pmon is applicable for scenario descriptions of K-IA <ref> [57] </ref>: () = M OD P MON () (3.21) For more on assessment of applicability, consult Sandewall [57]. 3.3 Plan Specification The intention is to use scenario descriptions to specify the world of a planning problem, the goals, and the resulting plan. This is illustrated with the 38 restaurant example under a K-IA assumption. <p> The pmon completion <ref> [57] </ref> of is as follows: [0; 2]hungry ^ inStreet ^ :inRest [3; 4]hungry [5; 7]hungry ^ :inStreet ^ inRest [8]:inStreet ^ inRest [9; 1):hungry ^ :inStreet ^ inRest (3.25) The goal [10]:hungry is clearly achieved by the plan. 3.4 Reasoning about Partial Plans There might be stages in the plan synthesis <p> We shall use an intermediate transformation to K pg as described in the previous section. K pg Isb is within the range of applicability of pmon <ref> [57] </ref>. The time domain is the non-negative integers N. Furthermore, a set of fluents are selected as essential. <p> primitive nonlin plan can be interpreted as a K- or Q-scenario. 109 110 Chapter 7 Conclusions and Future Work 7.1 Summary and Conclusions In the introductory chapter, we declared that the objective of this thesis was to analyse the planning problem and existing planning techniques within the Features and Fluents <ref> [57] </ref> framework. The keys to these analyses are the plan representation and the basic operations of the planning process. 7.1.1 The Basic and the Advanced Cases Two types of world, implying two cases for planning, are identified. <p> An alternative is to use a branching time structure, where different branches represent different courses of events. Sandewall have shown how the logics in Features and Fluents can be extended to deal with a combination of metric time and event branching <ref> [57] </ref>. The nonmonotonic entailment criteria in the book, for instance pmon, work perfectly well with the metric branching time structure. Two additional problems will have to be taken into consideration.
Reference: [58] <author> Erik Sandewall. </author> <title> Ramification by minimization of change with and without occlusion. </title> <type> Manuscript, </type> <institution> Linkoping University, </institution> <month> November </month> <year> 1994. </year> <month> 127 </month>
Reference-contexts: In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. Research is currently in progress to incorporate ramification <ref> [58] </ref> and concurrency [65] into FL. If we are to construct planners for these specialities, we will only have to make minor modifications to our representation.
Reference: [59] <author> Richard B. Scherl and Hector J. Levesque. </author> <title> The frame problem and knowledge-producing actions. </title> <booktitle> In AAAI93 [1]. </booktitle>
Reference-contexts: The theory is based on a possible worlds-semantics, which elegantly combines two sorts of accessibility relations: one for knowledge, and one for the external result of different actions. Actions which result in 117 a change of the agent's knowledge are called informative actions. Levesque et.al. <ref> [59, 35] </ref> adapt Moore's possible-worlds model of knowledge to situation calculus. They define a logical programming language, golog, for robot behavior where perception and knowledge acquisition are integral parts. Knowledge-preconditions have also been studied by Morgenstern [47] and Davis [15].
Reference: [60] <author> W Stephan and Susanne Biundo. </author> <title> A new logical framework for deductive planning. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Planning is implemented in a deductive manner, with a Horn-clause logic. In addition modal logics have been used for temporal reasoning and planning. Rosenschein [53], using dynamic logic, is a pioneer in this area, and there is further dynamic-logic-based work by Stephan and Biundo <ref> [60] </ref>. The logical language for planning (LLP) [8, 7] is an interval-based modal temporal logic. The temporal ontology of LLP is based on discrete sets of states, and intervals are sequences of states. There is no metric time in LLP and actions are instantaneous.
Reference: [61] <author> Austin Tate. </author> <title> Generating project networks. </title> <booktitle> In IJCAI77 [32], </booktitle> <pages> pages 888-93. </pages> <note> Reprinted in [3]. </note>
Reference-contexts: When the planner modifies the plan, e.g. by adding an action or a constraint, this is realised as a change in the TMM. The intricate interaction between planner and TMM has been studied by Rutten and Hertzberg [54]. For hierarchical planners such as nonlin <ref> [61] </ref>, planning information and temporal information is encoded in a so-called hierarchical task network (HTN). The effects of actions are propagated in the network, and a query-answering system is used to decide the truth of a statement in a node in the network. The HTN and TMM concepts are overlapping. <p> Chapter 6 analyses two principles that might have a considerable value also for non-traditional planning: causal links and task decomposition. The latter principle is commonly called hierarchical planning. The causal-link planner snlp [40] and the decompositional planner nonlin <ref> [61] </ref> are analysed and reconstructed. Chapter 7 contains a concluding discussion. It also draws the lines for future research and suggests methods for planning in the advanced case. We assume that the reader has a sufficient background in the fields of logic and artificial intelligence. <p> A common means for handling precondition-effect interferences in partial-order planning is by causal links between steps requiring certain conditions and steps asserting these conditions. The technique has been used for instance in nonlin <ref> [61] </ref> and snlp [40]. Causal links constitute one of the basic elements in hierarchical or de-compositional operator planning. Higher-level tasks can be decomposed into subtasks on a lower level of detail. <p> Using causal links, it is possible to discriminate between unexpected changes that interfere with the plan, and changes that have no effect on the plan. 6.2 Causal links in NONLIN The roots of causal links can be traced back to the decompositional planner nonlin <ref> [61] </ref>, although the term did not come into use until later. nonlin keeps a "Goal Structure" (GOST) which stores preconditions of steps together with a list of their "contributors". nonlin's predecessor NOAH [56] could not make this distinction between effects required and effects not required by some subsequent step. <p> A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. Some of 94 the more notable are noah [56], nonlin <ref> [61] </ref>, Deviser [62], O-Plan [14] and sipe [63]. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning. <p> Some formal studies about conflict resolving in partial-order plans that are applicable to hierarchical planning have also been made, for instance Peot and Smith [52]. 6.6 NONLIN | a Decompositional Planner As an example of a decompositional planner, we will study Tate's nonlin <ref> [61] </ref>. It does not possess all the features of planners such as sipe [63] and its own successor, O-Plan [14].
Reference: [62] <author> Steven A. Vere. </author> <title> Planning in time: Windows and duration for activities and goals. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 5(3) </volume> <pages> 246-267, </pages> <year> 1983. </year>
Reference-contexts: A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. Some of 94 the more notable are noah [56], nonlin [61], Deviser <ref> [62] </ref>, O-Plan [14] and sipe [63]. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning.
Reference: [63] <author> David E. Wilkins. </author> <title> Practical Planning: extending the classical AI paradigm. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Some recent planners such as Sipe <ref> [63] </ref> deal with concurrency in terms of resource sharing, and would consequently belong to the IebC assumption. <p> The operators of the original strips formalism are very restricted in their expressiveness. Basically the same kind of operators are used in many other planners, for instance tweak [12], snlp [40] and for primitive (non-decomposable) operators in hierarchical planners such as O-Plan [14] and sipe <ref> [63] </ref> (with the addition of resource specification). In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. Research is currently in progress to incorporate ramification [58] and concurrency [65] into FL. <p> Causal links constitute one of the basic elements in hierarchical or de-compositional operator planning. Higher-level tasks can be decomposed into subtasks on a lower level of detail. This powerful planning technique has been realized in many of the most successful planning systems, such as non-lin, O-Plan [14] and sipe <ref> [63] </ref>. 6.1 Causal Links Causal links encode teleological information; a causal link on condition p between step W and step S states that one of the purposes of W is to supply p for S. A causal link has two implications. <p> A number of different decompositional planners have been constructed and in some cases also successfully applied to realistic problems. Some of 94 the more notable are noah [56], nonlin [61], Deviser [62], O-Plan [14] and sipe <ref> [63] </ref>. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning. Young et.al. [66] and Erol et.al. [21] have given formal descriptions of hierarchical planning systems. <p> It does not possess all the features of planners such as sipe <ref> [63] </ref> and its own successor, O-Plan [14]. However, nonlin suffices to touch upon the main features regarding decomposition. 6.6.1 Plan Representation The data structure representing a nonlin plan is a network of nodes and links between these nodes. There is a distinction between goal nodes, action nodes and phantom nodes. <p> Naturally, in a realistically complex environment it is only possible to anticipate for a limited span of time forward. 7.2.5 Replanning Everything cannot be anticipated. If an unanticipated event occurs that interferes with the plan, the agent will have to revise its plan to suit the new 115 circumstances <ref> [63, 6] </ref>. 7.2.6 Structural Partiality We can assume that in many real-life domains, the agent has no possibility to anticipate the future in any detail, and even less so, plan in any detail for more than the very closest future. There are several reasons for this.
Reference: [64] <author> Qiang Yang. </author> <title> Formalizing planning knowledge for hierarchical planning. </title> <journal> Computational Intelligence, </journal> <volume> 6 </volume> <pages> 12-24, </pages> <year> 1990. </year>
Reference-contexts: Some of 94 the more notable are noah [56], nonlin [61], Deviser [62], O-Plan [14] and sipe [63]. In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang <ref> [64] </ref> has studied how planning knowledge should be structured to support efficient planning. Young et.al. [66] and Erol et.al. [21] have given formal descriptions of hierarchical planning systems. These formalizations have in common a sequential modelling of actions and no advanced condition typing.
Reference: [65] <author> Choong-Ho Yi. </author> <title> Towards assessment of logics for concurrent actions. </title> <note> Accepted to the AAAI 1995 Spring Symposium: Extended Theories of Action, </note> <institution> Stanford University, </institution> <year> 1995. </year>
Reference-contexts: In contrast, FL is 61 able to represent actions with duration, detailed trajectories, and context--dependent or random effects. Research is currently in progress to incorporate ramification [58] and concurrency <ref> [65] </ref> into FL. If we are to construct planners for these specialities, we will only have to make minor modifications to our representation.
Reference: [66] <author> R. Michael Young, Martha E. Pollack, and Johanna D. Moore. </author> <title> Decomposition and causality in partial-order planning. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence Planning Systems, </booktitle> <pages> pages 188-193. </pages> <publisher> AAAI Press, </publisher> <address> Menlo Park, California, </address> <year> 1994. </year> <month> 128 </month>
Reference-contexts: However, this term is also often used for planners that rely on other kinds of hierarchies such as hierarchical search trees and abstraction by removing less important predicates from the domain description [55]. Therefore, we will stick to the less ambiguous term "decomposition" here. Decompositional planning has several advantages <ref> [66] </ref>. * The search space can be reduced. * It simplifies the task of encoding domain knowledge. * It facilitates the interleaving of planning and execution, by making it possible to fully expand only some portions of the plan, including those that need to be executed immediately [10]. <p> In the 90's, some researches have taken a more formal approach to studying some of the aspects of the problem. Yang [64] has studied how planning knowledge should be structured to support efficient planning. Young et.al. <ref> [66] </ref> and Erol et.al. [21] have given formal descriptions of hierarchical planning systems. These formalizations have in common a sequential modelling of actions and no advanced condition typing.
References-found: 66

