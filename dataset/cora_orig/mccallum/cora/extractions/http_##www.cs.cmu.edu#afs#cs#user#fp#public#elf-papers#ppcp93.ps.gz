URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/elf-papers/ppcp93.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/elf-papers/
Root-URL: 
Email: spiro@cis.ohio-state.edu  fp@cs.cmu.edu  
Title: Higher-Order Logic Programming as Constraint Logic Programming  
Author: Spiro Michaylov Frank Pfenning 
Address: Columbus, OH 43210-1277, U.S.A.  Pittsburgh, PA 15213-3891, U.S.A.  
Affiliation: Department of Computer and Information Science The Ohio State University  School of Computer Science Carnegie Mellon University  
Abstract: Higher-order logic programming (HOLP) languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via - abstraction. They have been used for a wide range of applications including theorem proving, programming language interpretation, type inference, compilation, and natural language parsing. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages, and show how this can be expected to lead to more practical implementations by applying the known principles for the design and implementation of practical CLP systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pascal Brisset and Olivier Ridoux. </author> <title> The architecture of an implementation of Prolog: </title> <editor> Prolog/mali. In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 195-200, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Many of these features have been addressed in a satisfactory way in ongoing implementation projects at Duke and IRISA/INRIA in Rennes. Surveys and further references to the design of these implementations can be found in [11] and <ref> [1] </ref>.
Reference: [2] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: We conclude that functor/argument representation is an essential optimization for a Prolog or Elf implementation. 2 In principle, an important part of term comparison in these languages is the test for ff-convertibility. The Duke representation proposal [19] suggests a de Bruijn representation <ref> [2] </ref> of terms for this reason. While that suggestion may well be appropriate, the empirical study showed the comparison of two abstractions to be a rare occurrence, and so this consideration alone should probably not be allowed to determine the choice of term representation.
Reference: [3] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-87-109. </note>
Reference-contexts: These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction. They have been used for a wide range of applications including theorem proving <ref> [3] </ref>, programming language interpretation [5, 13], type inference [21], compilation [6], and natural language parsing [20]. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8].
Reference: [4] <author> Juergen Haas and Bharat Jayaraman. </author> <title> Interactive synthesis of definite-clause grammars. </title> <editor> In Krzystof Apt, editor, </editor> <booktitle> Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 541-555, </pages> <address> Washington, DC, November 1992. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Furthermore, most programs dynamically conform to the L restriction even without delay, and we are aware of only one useful program that does not run properly when hard constraints are delayed <ref> [4] </ref>. On the other hand, there are programs that run significantly more efficiently when hard constraints are delayed (for example, type inference in the polymorphic -calculus [21]).
Reference: [5] <author> John Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Language for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> January </month> <year> 1991. </year> <note> Available as technical report MS-CIS-91-09. </note>
Reference-contexts: These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction. They have been used for a wide range of applications including theorem proving [3], programming language interpretation <ref> [5, 13] </ref>, type inference [21], compilation [6], and natural language parsing [20]. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8].
Reference: [6] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction. They have been used for a wide range of applications including theorem proving [3], programming language interpretation [5, 13], type inference [21], compilation <ref> [6] </ref>, and natural language parsing [20]. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8].

Reference: [8] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Munich, Germany, </address> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages <ref> [8] </ref>. Measurements with an instrumented Elf interpreter confirm that such a view can produce practical benefits, as the known principles for the design and implementation of practical CLP systems [9, 12] are directly applicable to making implementations of HOLP languages more efficient. <p> There are other features of these languages that distinguish them from the CLP language scheme as defined in <ref> [8] </ref>, for example, higher-order predicates, dependent or polymorphic types, modules, embedded implication and universal quantification. Many of these features have been addressed in a satisfactory way in ongoing implementation projects at Duke and IRISA/INRIA in Rennes.
Reference: [9] <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey, and Roland H. C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8]. Measurements with an instrumented Elf interpreter confirm that such a view can produce practical benefits, as the known principles for the design and implementation of practical CLP systems <ref> [9, 12] </ref> are directly applicable to making implementations of HOLP languages more efficient. The core domain of the languages we consider is the set of typed -expressions, where abstraction and application are the only interpreted operations and equality is the only relation (interpreted as fiff-convertibility). <p> It has been observed <ref> [9, 12] </ref> that the constraints that occur most frequently in the execution of programs in many CLP systems are relatively simple. However, the generality needed to solve the more complicated, but rarely occurring constraints tends to introduce overheads for solving all constraints. <p> The issue of how to restrict a CLP language appropriately has often arisen and been addressed in different ways in real systems. In CLP (R) <ref> [9] </ref>, the selection rule is modified to delay nonlinear constraints until they become linear. A similar approach to nonlinear arithmetic has been adopted in recent commercial versions of Prolog III.
Reference: [10] <author> Joxan Jaffar, Spiro Michaylov, and Roland Yap. </author> <title> A methodology for managing hard constraints in CLP systems. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 306-316, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Under this philosophy, the delaying approach achieves some amount of independence of the order in which constraints arrive at the solver without unduly restricting programs. This philosophy and the justification of delay is described in considerable detail by Jaf-far et al. in <ref> [10] </ref>, where it is argued further that delay does not require the programmer to think substantially more algorithmically. <p> Under this view, the delaying semantics is simply a design decision in the specification of the language permitting a larger range of algorithms to be expressed concisely and naturally. It is shown in <ref> [10] </ref> that delay can be implemented with overhead proportional to the number of delayed constraints whose state is affected by each additional constraint, rather than the total number of delayed constraints. <p> In this section, we state precisely which constraints are deemed to be hard in Prolog and Elf and how they arise, and show how the methodology described in <ref> [10] </ref> can be used to manage hard constraints in this context. 5.1 Classification of Higher-Order Terms In Prolog each term can be classified as either a variable, a constant, or a compound term. Solving constraints over higher-order terms requires a finer classification. <p> The second situation is unusual for constraint languages, since a conjunction of directly solvable constraints may be simplified into a hard constraint. However, this is not problematic in the context of the methodology described in <ref> [10] </ref>: it merely requires that Flex-Flex pairs be treated as if they were hard constraints when designing the wakeup system, as described below. 5.3 A Wakeup System In this section, our aim is to describe the management of hard constraints in Elf in terms of the framework developed by Jaffar et <p> requires that Flex-Flex pairs be treated as if they were hard constraints when designing the wakeup system, as described below. 5.3 A Wakeup System In this section, our aim is to describe the management of hard constraints in Elf in terms of the framework developed by Jaffar et al. in <ref> [10] </ref>. We need five wakeup degrees in addition to awakened. These are for Flex-Flex, Flex-Rigid, Rigid-Flex, Flex-Gvar, and Gvar-Flex. We note that it is not desirable to combine symmetric cases, because the transitions of the two sides of the equation depend on the binding of different variables.
Reference: [11] <author> Keehang Kwon and Gopalan Nadathur. </author> <title> An instruction set for higher-order hereditary harrop formulas (extended abstract). </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 195-200, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Many of these features have been addressed in a satisfactory way in ongoing implementation projects at Duke and IRISA/INRIA in Rennes. Surveys and further references to the design of these implementations can be found in <ref> [11] </ref> and [1].
Reference: [12] <author> Spiro Michaylov. </author> <title> Design and Implementation of Practical Constraint Logic Programming Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year> <note> Available as technical report CMU-CS-92-168. </note>
Reference-contexts: In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8]. Measurements with an instrumented Elf interpreter confirm that such a view can produce practical benefits, as the known principles for the design and implementation of practical CLP systems <ref> [9, 12] </ref> are directly applicable to making implementations of HOLP languages more efficient. The core domain of the languages we consider is the set of typed -expressions, where abstraction and application are the only interpreted operations and equality is the only relation (interpreted as fiff-convertibility). <p> It has been observed <ref> [9, 12] </ref> that the constraints that occur most frequently in the execution of programs in many CLP systems are relatively simple. However, the generality needed to solve the more complicated, but rarely occurring constraints tends to introduce overheads for solving all constraints.
Reference: [13] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.- H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNCS/LNAI 595. </note>
Reference-contexts: These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction. They have been used for a wide range of applications including theorem proving [3], programming language interpretation <ref> [5, 13] </ref>, type inference [21], compilation [6], and natural language parsing [20]. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8].
Reference: [14] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <booktitle> In Proc. Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, PA, USA, </address> <month> July/August </month> <year> 1992. </year> <note> Appears as University of Pennsylvania technical report MS-CIS-92-86. </note>
Reference-contexts: Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. Higher-order unification in its full power can be implemented if some additional control constructs (when) are available [16]. However, our empirical analysis <ref> [14] </ref> suggests that this solution is unsatisfactory, since it has a detrimental effect on programming methodology, and potentially introduces a new efficiency problem. Object-level variables are typically represented by meta-level variables, which means that object-level capture-avoiding substitution can be implemented via meta-level fi-reduction. <p> We have studied a selection of 12 representative and non-trivial Elf programs with a total of about 3500 lines of code <ref> [14] </ref>. We analyzed these programs from a static and dynamic perspective. Our study demonstrates that the above observations and strategies for dealing with the problems of CLP languages in general are directly applicable to HOLP languages, and that a considerable performance improvement can be expected.
Reference: [15] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming: International Workshop, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen FRG, </address> <month> December </month> <year> 1991. </year> <note> Springer-Verlag LNCS 475. </note>
Reference-contexts: Moreover, in a straightforward implementation, common cases of unification incur a high overhead compared to first-order unification. These problems have led to a search for natural, decidable subcases of higher-order unification where most general unifiers exist. Miller <ref> [15] </ref> has suggested a syntactic restriction (L ) to Prolog, easily extensible to related languages [23], where most general unifiers are unique modulo fiff-equivalence. Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided.
Reference: [16] <author> Dale Miller. </author> <title> Unification of simply typed lambda-terms as logic programming. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 255-269. </pages> <publisher> MIT Press, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. Higher-order unification in its full power can be implemented if some additional control constructs (when) are available <ref> [16] </ref>. However, our empirical analysis [14] suggests that this solution is unsatisfactory, since it has a detrimental effect on programming methodology, and potentially introduces a new efficiency problem. Object-level variables are typically represented by meta-level variables, which means that object-level capture-avoiding substitution can be implemented via meta-level fi-reduction.
Reference: [17] <author> Dale A. Miller and Gopalan Nadathur. </author> <title> Higher-order logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 448-462, </pages> <address> London, July 1986. </address> <publisher> Springer Verlag LNCS 225. </publisher>
Reference-contexts: 1 Introduction Higher-order logic programming (HOLP) languages <ref> [17] </ref> typically use a typed -calculus as their domain of computation. In the case of Prolog [18] it is the simply-typed -calculus, while in the case of Elf [22] it is a dependently typed -calculus.
Reference: [18] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Seattle, WA, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Higher-order logic programming (HOLP) languages [17] typically use a typed -calculus as their domain of computation. In the case of Prolog <ref> [18] </ref> it is the simply-typed -calculus, while in the case of Elf [22] it is a dependently typed -calculus. These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction.
Reference: [19] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In Proceedings of the 1990 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348, </pages> <address> Nice, France, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We conclude that functor/argument representation is an essential optimization for a Prolog or Elf implementation. 2 In principle, an important part of term comparison in these languages is the test for ff-convertibility. The Duke representation proposal <ref> [19] </ref> suggests a de Bruijn representation [2] of terms for this reason. While that suggestion may well be appropriate, the empirical study showed the comparison of two abstractions to be a rare occurrence, and so this consideration alone should probably not be allowed to determine the choice of term representation.
Reference: [20] <author> Fernando C. N. Pereira. </author> <title> Semantic interpretation as higher-order deduction. </title> <booktitle> In Proceedings of the Second European Workshop on Logics and AI, </booktitle> <pages> pages 78-96. </pages> <publisher> Springer-Verlag LNCS 478, </publisher> <month> September </month> <year> 1990. </year>
Reference-contexts: They have been used for a wide range of applications including theorem proving [3], programming language interpretation [5, 13], type inference [21], compilation [6], and natural language parsing <ref> [20] </ref>. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8].
Reference: [21] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction. They have been used for a wide range of applications including theorem proving [3], programming language interpretation [5, 13], type inference <ref> [21] </ref>, compilation [6], and natural language parsing [20]. Despite their utility, current language implementations have acquired a well-deserved reputation for being inefficient. In this paper we argue that HOLP languages can reasonably be viewed as Constraint Logic Programming (CLP) languages [8]. <p> On the other hand, there are programs that run significantly more efficiently when hard constraints are delayed (for example, type inference in the polymorphic -calculus <ref> [21] </ref>). The operational semantics of Elf, in contrast to Prolog, is based on solving all dynamically arising equations that lie within an appropriate extension of L to dependent types. All other equations (solvable or not) are delayed.
Reference: [22] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Higher-order logic programming (HOLP) languages [17] typically use a typed -calculus as their domain of computation. In the case of Prolog [18] it is the simply-typed -calculus, while in the case of Elf <ref> [22] </ref> it is a dependently typed -calculus. These languages are particularly useful for various kinds of meta-programming and theorem proving tasks because of the logical support for variable binding via -abstraction.
Reference: [23] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: These problems have led to a search for natural, decidable subcases of higher-order unification where most general unifiers exist. Miller [15] has suggested a syntactic restriction (L ) to Prolog, easily extensible to related languages <ref> [23] </ref>, where most general unifiers are unique modulo fiff-equivalence. Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. Higher-order unification in its full power can be implemented if some additional control constructs (when) are available [16].
References-found: 22

