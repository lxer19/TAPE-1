URL: http://www.cs.purdue.edu/homes/linh/ps/flatten.ps
Refering-URL: http://www.cs.purdue.edu/homes/linh/pubs.htm
Root-URL: http://www.cs.purdue.edu
Title: Flattening Higher-Order Gamma  
Author: Hong Lin, Guoliang Chen Min Wang 
Keyword: Operational semantics, Computability theory  
Address: China  China  
Affiliation: Department of Computer Science University of Science and Technology of  Department of Electronic Engineering and Information Science University of Science and Technology of  
Abstract: Higher-order Gamma is introduced to strengthen the expressivity of Gamma. It can express more sophisticated control strategies. As a conseguence of this extension, higher-order Gamma can define the Chemical Abstract Machine (Cham), which is believed to be difficult to express within Gamma model. This paper, however, proves that control strategies can be expressed within the structure of tuples (viz. multiset elements) rather than within the structure of programs. It is firstly shown that compositions with operator "ffi" and "+" can be expressed in Gamma; and then proved that higher-order Gamma can be expressed in Gamma with compositions. As a consequence, the expressivity of Gamma is equal to that of higher-order Gamma, and thus equal to that of Cham. The transformation method we present can also be viewed as an implementation technique of higher-order Gamma. Key words: Very high-level languages, Methodologies, Parallelism and concurrency, 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.-P. Ban^atre and D. Le Metayer, </author> <title> The Gamma model and its discipline of programming, </title> <booktitle> Science of Computer Programming, 1990, </booktitle> <volume> 15, </volume> <pages> 55-77. </pages>
Reference-contexts: 1 Introduction Gamma <ref> [1, 2] </ref> is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm [3]. Existing work has demonstrated its significance for the construction of massively parallel programs.
Reference: [2] <author> J.-P. Ban^atre and D. Le Metayer, </author> <title> Programming by multiset transformation, </title> <journal> Communications of the ACM, 1993, </journal> <volume> 36(1), </volume> <pages> 98-111. </pages>
Reference-contexts: 1 Introduction Gamma <ref> [1, 2] </ref> is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm [3]. Existing work has demonstrated its significance for the construction of massively parallel programs.
Reference: [3] <author> C. Creveuil, </author> <title> Implementation of Gamma on the Connection Machine, </title> <booktitle> Proc. Workshop on Research Directions in High-Level Parallel Programming Languages, Mont-Saint Michel, 1991, </booktitle> <publisher> Springer-Verlag, LNCS 574, </publisher> <pages> 219-230. </pages>
Reference-contexts: 1 Introduction Gamma [1, 2] is a kernel language in which programs are described in terms of multiset transformations. It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm <ref> [3] </ref>. Existing work has demonstrated its significance for the construction of massively parallel programs. Cham [4] is an elaboration on Gamma to model asynchronous computations.
Reference: [4] <author> G. Berry and G. Boudol, </author> <title> The Chemical Abstract Machine, </title> <booktitle> Theoretical Computer Science, 1992, </booktitle> <volume> 96, </volume> <pages> 217-248. </pages>
Reference-contexts: It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm [3]. Existing work has demonstrated its significance for the construction of massively parallel programs. Cham <ref> [4] </ref> is an elaboration on Gamma to model asynchronous computations. To describe CCS [5] in Cham, notions of membrane and airlock are added to Gamma and these extensions are believed to be difficult for Gamma to describe.
Reference: [5] <author> R. Milner, </author> <title> Communications and concurrency, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: It is a high-level programming language in which parallelism is left implicit and especially suitable for data parallel paradigm [3]. Existing work has demonstrated its significance for the construction of massively parallel programs. Cham [4] is an elaboration on Gamma to model asynchronous computations. To describe CCS <ref> [5] </ref> in Cham, notions of membrane and airlock are added to Gamma and these extensions are believed to be difficult for Gamma to describe. Higher-order Gamma [6] (written HoGamma in this paper) unifies the program and data syntactic categories.
Reference: [6] <author> D. Le Metayer, </author> <title> Higher-order multiset processing, </title> <booktitle> DIMACS Series in Discrete Mathematical and Theoretical Computer Science, 1994, </booktitle> <volume> 18, </volume> <pages> 179-200. </pages>
Reference-contexts: Cham [4] is an elaboration on Gamma to model asynchronous computations. To describe CCS [5] in Cham, notions of membrane and airlock are added to Gamma and these extensions are believed to be difficult for Gamma to describe. Higher-order Gamma <ref> [6] </ref> (written HoGamma in this paper) unifies the program and data syntactic categories. As a consequence, active programs can be inserted into multisets. [6] shows that more sophisticated control strategies can be expressed within the language. <p> Higher-order Gamma <ref> [6] </ref> (written HoGamma in this paper) unifies the program and data syntactic categories. As a consequence, active programs can be inserted into multisets. [6] shows that more sophisticated control strategies can be expressed within the language. <p> We will prove Par can be expressed within Imc with each Sim being expressed within a thread, thus complete our proofs. To examine the structure of Sim, we show the (concrete) syntax of Exp <ref> [6] </ref> below: Exp = Conf j Conf:V ar i j x i j Arithexp j Boolexp j M ultexp j card (M ultexp) j : : : Conf = P assive j Active P assive = [; Env] Active = [P rog; Env] Env = (V ar 1 = Multexp 1 <p> So it is a recursive construction. Reaction can take place (nondeterministically) at each level according to the structural operational semantics of HoGamma <ref> [6] </ref>. For any HoGamma program H, the set of its active configurations is written as C (H) (Note that structures of configurations are statically determined). L is the set of labels. Bimorphism S H : C (H) ! L signs each active configuration in C (H) to a label.
Reference: [7] <author> D.W. Barnes and J.M. Mack, </author> <title> An algebraic introduction to mathematical logic, </title> <year> 1975. </year>
Reference-contexts: Then Section 4 proves that HoGamma can be expressed within CoGamma. We conclude the paper in Section 5. The exposition assumes familarity with Gamma, higher-order Gamma and their operational semantics. 2 Gamma and Turing Machine Before comparing Gamma to HoGamma, we examine the power of Gamma. Turing Proposition <ref> [7, 8] </ref> says: algorithmic computability equals Turing computability. In other words, if any feasible computation model, say Gamma, is not less powerful than Turing Machine, it is not less powerful than any other computation models. We will show that Gamma is not less powerful than Turing Machine.
Reference: [8] <author> F. Wang, </author> <title> Mathematical logic: principles for discrete mathematics, part III, </title> <publisher> USTC Press, </publisher> <year> 1990. </year>
Reference-contexts: Then Section 4 proves that HoGamma can be expressed within CoGamma. We conclude the paper in Section 5. The exposition assumes familarity with Gamma, higher-order Gamma and their operational semantics. 2 Gamma and Turing Machine Before comparing Gamma to HoGamma, we examine the power of Gamma. Turing Proposition <ref> [7, 8] </ref> says: algorithmic computability equals Turing computability. In other words, if any feasible computation model, say Gamma, is not less powerful than Turing Machine, it is not less powerful than any other computation models. We will show that Gamma is not less powerful than Turing Machine.
Reference: [9] <author> L. Mussat, </author> <title> Parallel programming with bags, </title> <booktitle> Proc. Workshop on Research Directions in High-Level Parallel Programming Languages, Mont-Saint Michel, 1991, </booktitle> <publisher> Springer-Verlag, LNCS 574, </publisher> <pages> 219-230. </pages>
Reference-contexts: Each quadriple (a; b; c; d) will be translated into a fl-command <ref> [9] </ref> by the following method: Case 1: c 62 fL; Rg (a; i) : SP; (i; b) : P L!(d; i) : SP; (i; c) : P L Case 2: c = L (a; i) : SP; (i; b) : P L!(d; i 1) : SP; (i; b) : P L
Reference: [10] <author> C. Hankin, D. Le Metayer and D. Sands, </author> <title> A parallel programming style and its algebra of programs, </title> <booktitle> Proc. </booktitle> <address> PARLE'93, </address> <publisher> LNCS 694, Springer-Verlag. </publisher>
Reference-contexts: The most important thing is to prove that for any Gamma program P 1 ; P 2 , There exists a Gamma Program P , which is operational equivalent <ref> [10] </ref> to P 1 ffiP 2 .
References-found: 10

