URL: http://www.cs.brown.edu/people/mph/sv.ps
Refering-URL: http://www.cs.brown.edu/people/mph/sv.html
Root-URL: http://www.cs.brown.edu/
Email: herlihy@cs.brown.edu  rajsbaum@crl.dec.com  
Phone: 2  
Title: Algebraic Topology and Distributed Computing A Primer  
Author: Maurice Herlihy and Sergio Rajsbaum 
Address: Providence, RI 02912  One Kendall Square, Cambridge, MA 02139  
Affiliation: 1 Computer Science Department Brown University,  Digital Equipment Corporation, Cambridge Research Lab  
Abstract: Models and techniques borrowed from classical algebraic topology have recently yielded a variety of new lower bounds and impossibility results for distributed and concurrent computation. This paper explains the basic concepts underlying this approach, and shows how they apply to a simple distributed problem.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Peleg, and R. Reischuk. </author> <title> Renaming in an asynchronous environment. </title> <journal> Journal of the ACM, </journal> <volume> 37(3) </volume> <pages> 524-548, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The output complex consists of two disjoint n-simplexes, corresponding to decision values 0 and 1. Figure 1 illustrates the input and output complexes for two-process binary consensus. As an example of an interesting output complex, consider the renaming task <ref> [1] </ref>, in which each process is given a unique input name taken from a large name space, and must choose a unique output name taken from a much smaller name space. <p> In 1993, three independent research teams, Borowsky and Gafni [4], Herlihy and Shavit [14], and Saks and Zaharoglou [20] proved this conjecture correct. Attiya, Bar-Noy, Dolev, Koller, Peleg, and Reischuk <ref> [1] </ref> showed that in asynchronous systems, the renaming task has a solution if the output name space is sufficiently large, but they were unable to demonstrate the existence of a solution for a range of smaller output name spaces.
Reference: 2. <author> H. Attiya and S. Rajsbaum. </author> <title> A combinatorial topology framework for wait-free computability. </title> <type> Preprint. </type>
Reference-contexts: Most of the technical content this paper is adapted from Herlihy and Rajs-baum [13], which simplifies the impossibility results of [14] by eliminating the need for certain continuous arguments. Attiya and Rajsbaum <ref> [2] </ref> take a different approach, proving a number of results about wait-free read/write memory by extending the simplicial model with a combinatorial notion called a "divided image".
Reference: 3. <author> O. Biran, S. Moran, and S. Zaks. </author> <title> A combinatorial characterization of the distributed tasks which are solvable in the presence of one faulty processor. </title> <booktitle> In Proceedings 7th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 263-275, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: In 1988, Biran, Moran, and Zaks <ref> [3] </ref> gave a graph-theoretic characterization of a class of tasks that could be solved in asynchronous message-passing systems in the presence of a single failure.
Reference: 4. <author> E. Borowsky and E. Gafni. </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations. </title> <booktitle> In Proceedings 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 206-215, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Corollary 5. There is no wait-free read/write n-consensus protocol <ref> [4, 14, 20] </ref>. For t-resilient protocols, a similar argument shows: Corollary 6. There is no t-resilient read/write t-consensus protocol. Although read/write memories are important from a theoretical point of view, modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set, fetch-and-add, compare-and-swap, and load-linked/store-conditional operations. <p> The k-set agreement task was first proposed by Soma Chaudhuri [7] in 1989, along with a conjecture that it could not be solved in asynchronous systems. In 1993, three independent research teams, Borowsky and Gafni <ref> [4] </ref>, Herlihy and Shavit [14], and Saks and Zaharoglou [20] proved this conjecture correct.
Reference: 5. <author> E. Borowsky, E. Gafni, and Y. </author> <title> Afek. </title> <booktitle> Consensus power makes (some) sense! In Proceedings 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 363-373, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: We close with a brief summary of some open problems. The problem of classifying the computational power of objects for wait-free computation has attracted the attention of many researchers <ref> [5, 6, 16, 17, 19] </ref>. We have seen that the protocol complexes for different kinds of objects share certain topological properties: read/write complexes have no holes, set-agreement complexes have no holes below a certain dimension, and so on.
Reference: 6. <author> T Chandra, V. Hadzilacos, P. Jayanti, and S. Toueg. </author> <title> Wait-freedom vs. t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proceedings 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: We close with a brief summary of some open problems. The problem of classifying the computational power of objects for wait-free computation has attracted the attention of many researchers <ref> [5, 6, 16, 17, 19] </ref>. We have seen that the protocol complexes for different kinds of objects share certain topological properties: read/write complexes have no holes, set-agreement complexes have no holes below a certain dimension, and so on.
Reference: 7. <author> S. Chaudhuri. </author> <title> Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. </title> <booktitle> In Proceedings 9th Annual ACM Symposium On Principles of Distributed Computing, </booktitle> <pages> pages 311-234, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: In Section 5, we show how these combinatorial and algebraic notions can be applied to prove a variety of lower bounds for a well-known problem in distributed computing, the k-set agreement task <ref> [7] </ref>. 2 Model A set of n + 1 sequential threads of control, called processes, communicate by applying operations to objects in shared memory. Examples of shared objects include message queues, read/write variables, test-and-set variables, or objects of arbitrary abstract type. Processes are asynchronous: they run at arbitrarily varying speeds. <p> The consensus task was originally studied as an idealization of the transaction commitment problem, in which a number of database sites must agree on whether to commit or abort a distributed transaction. A natural generalization of consensus is k-set agreement <ref> [7] </ref>. Like consensus, each process's output value must be some process's input value. Unlike consensus, which requires that all processes agree, k-set agreement requires that no more than k distinct output values be chosen. Consensus is 1-set agreement. A program that solves a decision task is called a protocol. <p> This map is not chain homotopic to or , which "wrap around" only once. 5 An Application Recall that in the k-set agreement task <ref> [7] </ref>, each process is required to choose some process's input value, and the set of values chosen should have size at most k. <p> Herlihy and Rajsbaum [12] showed that if read/write variables are augmented by more powerful shared objects than read/write registers, then the protocol complexes may have holes (non-trivial homology), but only in the higher dimensions. The k-set agreement task was first proposed by Soma Chaudhuri <ref> [7] </ref> in 1989, along with a conjecture that it could not be solved in asynchronous systems. In 1993, three independent research teams, Borowsky and Gafni [4], Herlihy and Shavit [14], and Saks and Zaharoglou [20] proved this conjecture correct.
Reference: 8. <author> S. Chaudhuri, M.P. Herlihy, N. Lynch, </author> <title> and M.R. Tuttle. A tight lower bound for k-set agreement. </title> <booktitle> In Proceedings 34th annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 206-215, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: There is no wait-free (n + 1; J (n + 1) 1)-consensus protocol if processes share a read/write memory and (m; j)-consensus objects. Finally, we turn our attention to synchronous models. Chaudhuri, Herlihy, Lynch, and Tuttle <ref> [8] </ref> considered a model in which n+1 processes communicate by sending messages over a completely connected network. Computation in this model proceeds in a sequence of rounds. <p> Corollary 9. There is no t-resilient (n+1; k)-consensus protocol that takes fewer than bt=kc + 1 rounds in the synchronous fail-stop message-passing model <ref> [8] </ref>. 6 Related Work In 1985, Fischer, Lynch, and Paterson [9] showed that the consensus task has no 1-resilient solution in a system where asynchronous processes communicate by exchanging messages.
Reference: 9. <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: An output value models an effect on the outside world, such as an irrevocable decision to commit a transaction, to dispense cash, or to launch a missile. Perhaps the simplest example of a decision task is consensus <ref> [9] </ref>. Each process starts with an input value and chooses an output value. All output values must agree, and each output value must have been some process's input value. If the input values are boolean, the task is called binary consensus. <p> Corollary 9. There is no t-resilient (n+1; k)-consensus protocol that takes fewer than bt=kc + 1 rounds in the synchronous fail-stop message-passing model [8]. 6 Related Work In 1985, Fischer, Lynch, and Paterson <ref> [9] </ref> showed that the consensus task has no 1-resilient solution in a system where asynchronous processes communicate by exchanging messages.
Reference: 10. <author> E. Gafni and E. Koutsoupias. </author> <title> 3-processor tasks are undecidable. </title> <booktitle> In Proceedings 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: Attiya and Rajsbaum [2] take a different approach, proving a number of results about wait-free read/write memory by extending the simplicial model with a combinatorial notion called a "divided image". In an intriguing recent development, Gafni and Koutsoupias <ref> [10] </ref> have shown that it is undecidable whether a wait-free read/write protocol exists for three-process tasks, using an argument based on the impossibility of computing the protocol complex's fundamental group, a topological invariant related to the first homology group. 7 Conclusions We believe that these techniques and models, borrowed from classical
Reference: 11. <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 123-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: How do these primitives affect the ability to solve k-set agreement? One way to classify these synchronization primitives is by consensus number <ref> [11, 16] </ref>: how many processes can solve consensus using such primitives. For example, test-and-set has consensus number 2, meaning that protocols using read, write, and test-and-set operations can solve consensus for two processes, but not three.
Reference: 12. <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Set consensus using arbitrary objects. </title> <booktitle> In Proceedings 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: There is a direct connection between an object's consensus number and the homology of its protocol complexes. Consider a system in which processes share both read/write variables and objects that allow any c processes to reach consensus. Using shared objects that solve consensus among c processes, Her-lihy and Rajsbaum <ref> [12] </ref> showed that it is possible to solve k-set agreement for k = d (n + 1)=ce (via an easy protocol, left to the reader), but for no lower value of k. <p> This carrier does not directly satisfy Equation 2, because c (S) may include processes not in ids (S). Nevertheless, it is possible to modify the decision values of the processes in ids ( c (S)) ids (S) so as to satisfy Equation 2 (see <ref> [12] </ref> for details). Corollary 7. There is no wait-free (d (n + 1)=ce 1)-set agreement protocol if processes share read/write variables and objects with consensus number c [12]. <p> possible to modify the decision values of the processes in ids ( c (S)) ids (S) so as to satisfy Equation 2 (see <ref> [12] </ref> for details). Corollary 7. There is no wait-free (d (n + 1)=ce 1)-set agreement protocol if processes share read/write variables and objects with consensus number c [12]. This result can be further generalized by including objects that allow any m processes to solve j-set agreement, a task we call (m; j)-consensus. <p> They showed that the protocol complex for every wait-free read/write protocol is simply connected with trivial homology (i.e., it has no holes). They also give a complete characterization of tasks that have a wait-free solution in read/write memory [14, 15]. Herlihy and Rajsbaum <ref> [12] </ref> showed that if read/write variables are augmented by more powerful shared objects than read/write registers, then the protocol complexes may have holes (non-trivial homology), but only in the higher dimensions.
Reference: 13. <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Algebraic spans. </title> <booktitle> In Proceedings 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: We first give a theorem specifying an algebraic property that prevents a protocol from solving k-set agreement, and then we apply this theorem to a variety of different models of computation. The arguments presented here are taken from Herlihy and Rajsbaum <ref> [13] </ref>. Theorem 4. Let S ` be a simplex each of whose vertexes is labeled with a distinct input value, and S ` the complex of its faces. Let be a protocol, P its protocol complex, and ffi its decision map. <p> In 1993, Herlihy and Shavit [14] showed that the task has no solution for these smaller name spaces. Most of the technical content this paper is adapted from Herlihy and Rajs-baum <ref> [13] </ref>, which simplifies the impossibility results of [14] by eliminating the need for certain continuous arguments. Attiya and Rajsbaum [2] take a different approach, proving a number of results about wait-free read/write memory by extending the simplicial model with a combinatorial notion called a "divided image".
Reference: 14. <author> M.P. Herlihy and N. Shavit. </author> <title> The asynchronous computability theorem for t-resilient tasks. </title> <booktitle> In Proceedings 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 111-120, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Consider a model in which processes communicate by reading and writing shared variables. For any wait-free protocol, Herlihy and Shavit <ref> [14] </ref> showed that P (S m ) is acyclic for every input simplex S m , 0 m n. Let S n be an input simplex where each vertex has a distinct input. <p> Corollary 5. There is no wait-free read/write n-consensus protocol <ref> [4, 14, 20] </ref>. For t-resilient protocols, a similar argument shows: Corollary 6. There is no t-resilient read/write t-consensus protocol. Although read/write memories are important from a theoretical point of view, modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set, fetch-and-add, compare-and-swap, and load-linked/store-conditional operations. <p> Each of these complexes has non-trivial homology in dimension d4=2e 1 = 1, but trivial homology in dimension d4=2e 2 = 0 (being connected). More generally, at one extreme, when c = 1, P (S n ) is acyclic <ref> [14] </ref>. For higher consensus numbers, however, the complex may have holes. If the consensus number is low, then holes appear only in higher dimensions, but as the consensus number grows, the holes spread into increasingly lower dimensions. Finally, when c = n + 1, the protocol complex may become disconnected. <p> In 1988, Biran, Moran, and Zaks [3] gave a graph-theoretic characterization of a class of tasks that could be solved in asynchronous message-passing systems in the presence of a single failure. Herlihy and Shavit <ref> [14] </ref> were the first to use simplicial complexes to model decision tasks, and to formulate properties of decision tasks in terms of sim-plicial homology. They showed that the protocol complex for every wait-free read/write protocol is simply connected with trivial homology (i.e., it has no holes). <p> They showed that the protocol complex for every wait-free read/write protocol is simply connected with trivial homology (i.e., it has no holes). They also give a complete characterization of tasks that have a wait-free solution in read/write memory <ref> [14, 15] </ref>. Herlihy and Rajsbaum [12] showed that if read/write variables are augmented by more powerful shared objects than read/write registers, then the protocol complexes may have holes (non-trivial homology), but only in the higher dimensions. <p> The k-set agreement task was first proposed by Soma Chaudhuri [7] in 1989, along with a conjecture that it could not be solved in asynchronous systems. In 1993, three independent research teams, Borowsky and Gafni [4], Herlihy and Shavit <ref> [14] </ref>, and Saks and Zaharoglou [20] proved this conjecture correct. <p> In 1993, Herlihy and Shavit <ref> [14] </ref> showed that the task has no solution for these smaller name spaces. Most of the technical content this paper is adapted from Herlihy and Rajs-baum [13], which simplifies the impossibility results of [14] by eliminating the need for certain continuous arguments. <p> In 1993, Herlihy and Shavit <ref> [14] </ref> showed that the task has no solution for these smaller name spaces. Most of the technical content this paper is adapted from Herlihy and Rajs-baum [13], which simplifies the impossibility results of [14] by eliminating the need for certain continuous arguments. Attiya and Rajsbaum [2] take a different approach, proving a number of results about wait-free read/write memory by extending the simplicial model with a combinatorial notion called a "divided image".
Reference: 15. <author> M.P. Herlihy and N. Shavit. </author> <title> A simple constructive computability theorem for wait-free computation. </title> <booktitle> In Proceedings 26th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 243-252, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: They showed that the protocol complex for every wait-free read/write protocol is simply connected with trivial homology (i.e., it has no holes). They also give a complete characterization of tasks that have a wait-free solution in read/write memory <ref> [14, 15] </ref>. Herlihy and Rajsbaum [12] showed that if read/write variables are augmented by more powerful shared objects than read/write registers, then the protocol complexes may have holes (non-trivial homology), but only in the higher dimensions.
Reference: 16. <author> P. Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proceedings 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 145-158, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: How do these primitives affect the ability to solve k-set agreement? One way to classify these synchronization primitives is by consensus number <ref> [11, 16] </ref>: how many processes can solve consensus using such primitives. For example, test-and-set has consensus number 2, meaning that protocols using read, write, and test-and-set operations can solve consensus for two processes, but not three. <p> We close with a brief summary of some open problems. The problem of classifying the computational power of objects for wait-free computation has attracted the attention of many researchers <ref> [5, 6, 16, 17, 19] </ref>. We have seen that the protocol complexes for different kinds of objects share certain topological properties: read/write complexes have no holes, set-agreement complexes have no holes below a certain dimension, and so on.
Reference: 17. <author> J. Kleinberg and S. Mullainathan. </author> <title> Resource bounds and combinations of consensus objects. </title> <booktitle> In Proceedings 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 133-145, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: We close with a brief summary of some open problems. The problem of classifying the computational power of objects for wait-free computation has attracted the attention of many researchers <ref> [5, 6, 16, 17, 19] </ref>. We have seen that the protocol complexes for different kinds of objects share certain topological properties: read/write complexes have no holes, set-agreement complexes have no holes below a certain dimension, and so on.
Reference: 18. <author> J.R. Munkres. </author> <title> Elements Of Algebraic Topology. </title> <publisher> Addison Wesley, </publisher> <address> Reading MA, </address> <year> 1984. </year> <note> ISBN 0-201-04586-9. </note>
Reference-contexts: Part of this work was done while visiting the Laboratory for Computer Science, MIT. Partly supported by DGAPA Projects. abstract, they are elementary, being fully covered in the first chapter of Munkres' standard textbook <ref> [18] </ref>. Our discussion focuses on a class of problems called decision tasks, described in Section 2. In Section 3, we show how decision tasks can be modeled using simplicial complexes, a standard combinatorial structure from elementary topology. <p> To analyze the topological structure of simplicial complexes, however, we now need to introduce some algebraic concepts. Our discussion closely follows that of Munkres <ref> [18, Section 1.13] </ref>, which the reader is encouraged to consult for more details. Let K be an n-dimensional simplicial complex, and S q = (s 0 ; : : : ; s q ) a q-simplex of K. <p> The first chain group, C 1 ( _ S 1 ), is generated by the S 1 i , and all 1-chains have the form 0 S 1 1 + 2 S 1 7 Munkres <ref> [18] </ref> calls this operator an augmentation, and denotes it by *. where the S 1 0 each have standard orientation. Since _ S 1 contains no simplexes of higher dimension, the higher chain groups are trivial. <p> It can be shown that H 1 ( _ S 1 ) is infinite cyclic, generated by the equivalence class of @S 2 <ref> [18, 31.8] </ref>. The chain complex C (K) is the sequence of groups and homomorphisms fC q (K); @ q g. Let C (K) = fC q (K); @ q g and C (L) = C q (L); @ 0 be chain com plexes for simplicial complexes K and L. <p> (K) ! C (L) are chain maps, then a chain homotopy from to is a family of homomorphisms D q : C q (K) ! C q+1 (L); such that @ 0 Very roughly, if two chain maps are homotopic, then one can be deformed into the other; see Munkres <ref> [18] </ref> for intuitive justification for this definition. 8 Strictly speaking, these are the reduced homology groups [18, p.71]. Definition 1. <p> of homomorphisms D q : C q (K) ! C q+1 (L); such that @ 0 Very roughly, if two chain maps are homotopic, then one can be deformed into the other; see Munkres [18] for intuitive justification for this definition. 8 Strictly speaking, these are the reduced homology groups <ref> [18, p.71] </ref>. Definition 1. <p> A proof of this theorem can be found in Munkres's text <ref> [18, 13.3] </ref>. The fol lowing lemma is an immediate consequence of the definitions. Lemma 3.
Reference: 19. <author> G. Peterson, R. Bazzi, and G. Neiger. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proceedings 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 344-354, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: We close with a brief summary of some open problems. The problem of classifying the computational power of objects for wait-free computation has attracted the attention of many researchers <ref> [5, 6, 16, 17, 19] </ref>. We have seen that the protocol complexes for different kinds of objects share certain topological properties: read/write complexes have no holes, set-agreement complexes have no holes below a certain dimension, and so on.
Reference: 20. <author> M. Saks and F. Zaharoglou. </author> <title> Wait-free k-set agreement is impossible: The topology of public knowledge. </title> <booktitle> In Proceedings 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 101-110, </pages> <month> May </month> <year> 1993. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Corollary 5. There is no wait-free read/write n-consensus protocol <ref> [4, 14, 20] </ref>. For t-resilient protocols, a similar argument shows: Corollary 6. There is no t-resilient read/write t-consensus protocol. Although read/write memories are important from a theoretical point of view, modern multiprocessor architectures provide a variety of more powerful synchronization primitives, including test-and-set, fetch-and-add, compare-and-swap, and load-linked/store-conditional operations. <p> The k-set agreement task was first proposed by Soma Chaudhuri [7] in 1989, along with a conjecture that it could not be solved in asynchronous systems. In 1993, three independent research teams, Borowsky and Gafni [4], Herlihy and Shavit [14], and Saks and Zaharoglou <ref> [20] </ref> proved this conjecture correct.
References-found: 20

