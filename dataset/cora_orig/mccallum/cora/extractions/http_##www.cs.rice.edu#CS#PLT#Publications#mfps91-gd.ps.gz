URL: http://www.cs.rice.edu/CS/PLT/Publications/mfps91-gd.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Call-by-Value Combinatory Logic and the Lambda-Value Calculus  
Author: John Gateley and Bruce F. Duba 
Keyword: v -calculus.  
Affiliation: Rice University  
Abstract: Since it is unsound to reason about call-by-value languages using call-by name equational theories, we present two by-value combinatory logics and translations from the -value ( v ) calculus to the logics. The first by-value logic is constructed in a manner similar to the v -calculus: it is based on the by-name combinatory logic, but the combinators are strict. The translation is non-standard to account for the strictness of the input program. The second by-value logic introduces laziness to K terms so that the translation can preserve the structure of functions that do not use their argument. Both logics include constants and delta rules, and we prove their equivalence with the 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Substitution is hygienic. That is, when substituting a term N for a variable x in a term M , we assume that the free variables of N and the bound variables of M are disjoint. 2 Background Church [3] developed the -calculus <ref> [1] </ref>. Its term language fl is: M ::= x j x:M j M M and the axiom and inference rule is: (x:M )N = M [x=N ] fi where M [x=N] denotes substitution. <p> We use the notation M [x=N ] to denote the result of substituting all free occurrences x in M by N. The set of free variables of a term M , F V (M), and substitution are defined as usual <ref> [1] </ref>. When an equation M = N is derivable in the v -calculus we write v ` M = N. The delta axiom is used to provide meaning to terms of the form a f V , such as succ 5. <p> This is the simplest algorithm for simulating abstraction as well as handling the issue of preserving values. The translation algorithm is called 1 following Barendregt <ref> [1, page 157] </ref>.
Reference: [2] <author> W. Burge. </author> <title> Recursive Programming Techniques. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1975. </year>
Reference-contexts: An open problem is the construction of a set of axioms, corresponding to A fi , for CL v that are equivalent to the inference rule 0 . The logic CL q is useful for creating implementations of by-value languages. Burge <ref> [2] </ref> rediscovered combinators for computer science. Turner [14] popularized and improved the translation using a larger set of combinators so that the resulting CL programs were shorter. Then Hughes [8] developed supercombinators that made the translation linear in terms of size.
Reference: [3] <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <address> Prince-ton, </address> <year> 1941. </year>
Reference-contexts: Substitution is hygienic. That is, when substituting a term N for a variable x in a term M , we assume that the free variables of N and the bound variables of M are disjoint. 2 Background Church <ref> [3] </ref> developed the -calculus [1]. Its term language fl is: M ::= x j x:M j M M and the axiom and inference rule is: (x:M )N = M [x=N ] fi where M [x=N] denotes substitution.
Reference: [4] <author> H. B. </author> <title> Curry. </title> <journal> Grundlagen der kombinatorischen Logik. Amer. J. Math, </journal> <volume> 52 </volume> <pages> 509-536; 789-834, </pages> <year> 1930. </year>
Reference-contexts: M = M (reflexivity) M = N ) N = M (symmetry) M = N; N = L ) M = L (transitivity) M = N ) ML = NL; LM = LN (compatibility) theories of this paper. Schonfinkel [10] and Curry <ref> [4] </ref> independently developed combinatory logic, based on the combinators S and K.
Reference: [5] <author> H. B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North Holland, </publisher> <year> 1958. </year>
Reference-contexts: Just as languages are paired with calculi [12], calculi should be paired with combinatory logics. In this paper, we show that a variant of Goodman's simplified combinatory logic [6] corresponds, in the sense of Curry <ref> [5] </ref>, to Plotkin's v -calculus [12]. We also present a technique for determining if a combinatory logic and calculus are equivalent when both include constants. Unfortunately, the revised by-value combinatory logic leads to inefficient implementations, since the translation algorithm cannot preserve redexes that occur within abstractions. <p> The term language CL is: M ::= x j S j K j M M ; the axioms are: KM N = M The equational theory generated, including the axioms and inference rules of figure 1, is denoted by CL. Curry <ref> [5] </ref> also developed functions, [] and [] CL , that translate terms from CL to fl and vice versa, respectively. However, CL is strictly weaker than : some terms that are not equal in CL have translations that are equal in . <p> Second, Curry <ref> [5, pages 201|202] </ref> proved that a single inference rule, 0 , is equivalent to A fi . Let Funs be the syntactic category of functions; for the -calculus, functions are -terms, for CL they are terms of the form: S; K; SM; KM; SM N.
Reference: [6] <author> N. D. Goodman. </author> <title> A simplification of combinatory logic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 37(2), </volume> <year> 1972. </year>
Reference-contexts: A solution to this problem is to translate by-value -terms with constants into a by-value combinatory logic with constants. Just as languages are paired with calculi [12], calculi should be paired with combinatory logics. In this paper, we show that a variant of Goodman's simplified combinatory logic <ref> [6] </ref> corresponds, in the sense of Curry [5], to Plotkin's v -calculus [12]. We also present a technique for determining if a combinatory logic and calculus are equivalent when both include constants. <p> Then, if the v -calculus contains a constant function integer?, we can show that (integer? (x:3x)) = false, and (integer? 3) = true, resulting in an inconsistent theory. Thus, 0 is the appropriate choice. 4 A Simple Combinatory Logic The combinatory logic presented here is a variant of Goodman's <ref> [6] </ref>: we also include functional extensionality ( 0 ) and constants. We refer to it as CL v ; it is based on the by-value combinators S, K and I 2 .
Reference: [7] <author> P. Hudak and B. Goldberg. </author> <title> Serial Combinators: "Optimal" Grains of Parallelism. </title> <booktitle> In Proc of Conf. on Functional Prog. Langs. and Comp. Arch., </booktitle> <year> 1985. </year>
Reference-contexts: Burge [2] rediscovered combinators for computer science. Turner [14] popularized and improved the translation using a larger set of combinators so that the resulting CL programs were shorter. Then Hughes [8] developed supercombinators that made the translation linear in terms of size. Hudak and Goldberg <ref> [7] </ref> created serial combinators that are used to execute CL programs on multiprocessors without shared memory. Finally, Kennaway and Sleep [9] developed director strings that allow even more efficient implementations.
Reference: [8] <author> R. Hughes. Super-combinators: </author> <title> A new implementation method for applicative lan-guages. </title> <booktitle> In Sym. on Lisp and Functional Prog., </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <month> Aug </month> <year> 1982. </year>
Reference-contexts: The logic CL q is useful for creating implementations of by-value languages. Burge [2] rediscovered combinators for computer science. Turner [14] popularized and improved the translation using a larger set of combinators so that the resulting CL programs were shorter. Then Hughes <ref> [8] </ref> developed supercombinators that made the translation linear in terms of size. Hudak and Goldberg [7] created serial combinators that are used to execute CL programs on multiprocessors without shared memory. Finally, Kennaway and Sleep [9] developed director strings that allow even more efficient implementations.
Reference: [9] <author> Kennaway, R. and R. Sleep. </author> <title> Director strings as combinators. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 10(4) </volume> <pages> 602-626, </pages> <year> 1988. </year>
Reference-contexts: Then Hughes [8] developed supercombinators that made the translation linear in terms of size. Hudak and Goldberg [7] created serial combinators that are used to execute CL programs on multiprocessors without shared memory. Finally, Kennaway and Sleep <ref> [9] </ref> developed director strings that allow even more efficient implementations. Just as CL has been improved in various ways, CL q is the appropriate starting point for a parallel line of research for by-value languages. 7 Acknowledgements We would like to thank our families for their support.
Reference: [10] <author> M. Schonfinkel. </author> <title> Uber die Bausteine der Mathematischen Logik. </title> <journal> Math. Annalen, </journal> <volume> 92 </volume> <pages> 305-316, </pages> <year> 1924. </year>
Reference-contexts: M = M (reflexivity) M = N ) N = M (symmetry) M = N; N = L ) M = L (transitivity) M = N ) ML = NL; LM = LN (compatibility) theories of this paper. Schonfinkel <ref> [10] </ref> and Curry [4] independently developed combinatory logic, based on the combinators S and K.
Reference: [11] <author> A. Meyer. </author> <title> What is a model of the lambda calculus? Information and Control, </title> <booktitle> 52 </booktitle> <pages> 87-122, </pages> <year> 1982. </year>
Reference-contexts: The simple logic, CL v , may be useful for developing an algebraic model for the v -calculus, as CL was used to create a model of the -calculus <ref> [11] </ref>. An open problem is the construction of a set of axioms, corresponding to A fi , for CL v that are equivalent to the inference rule 0 . The logic CL q is useful for creating implementations of by-value languages. Burge [2] rediscovered combinators for computer science.
Reference: [12] <author> G. Plotkin. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: However, most realistic programming languages rely on call-by-value as the parameter-passing mechanism, for which a call-by-name combinatory logic (CL) is unsound. In addition, an evaluator for a language usually does not produce normal forms as in the -calculus <ref> [12] </ref>, but instead produces values. <p> A solution to this problem is to translate by-value -terms with constants into a by-value combinatory logic with constants. Just as languages are paired with calculi <ref> [12] </ref>, calculi should be paired with combinatory logics. In this paper, we show that a variant of Goodman's simplified combinatory logic [6] corresponds, in the sense of Curry [5], to Plotkin's v -calculus [12]. <p> Just as languages are paired with calculi <ref> [12] </ref>, calculi should be paired with combinatory logics. In this paper, we show that a variant of Goodman's simplified combinatory logic [6] corresponds, in the sense of Curry [5], to Plotkin's v -calculus [12]. We also present a technique for determining if a combinatory logic and calculus are equivalent when both include constants. Unfortunately, the revised by-value combinatory logic leads to inefficient implementations, since the translation algorithm cannot preserve redexes that occur within abstractions. <p> Functions are either -terms or functional constants. The calculus needs some form of extensionality, otherwise equations such as x:succ x = succ are not provable. Full extensionality () is too strong; it is unsound with respect to operational equivalence <ref> [12] </ref> because it does not respect values. Even with -value, x:3x = 3 because (x:3x)x = 3x for all x. Then, if the v -calculus contains a constant function integer?, we can show that (integer? (x:3x)) = false, and (integer? 3) = true, resulting in an inconsistent theory.
Reference: [13] <author> R. Smullyan. </author> <title> To Mock a Mockingbird and Other Logic Puzzles. </title> <editor> Alfred A. Knopf, </editor> <publisher> Inc., </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: This is exactly what the Q combinator does. In addition, functional extensionality is incorporated into the algorithm: terms of the form ] x:F x are replaced with F , since this aids in producing shorter terms. 3 The Q combinator is not related to that appearing in Smullyan <ref> [13] </ref>.
Reference: [14] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software| Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: An open problem is the construction of a set of axioms, corresponding to A fi , for CL v that are equivalent to the inference rule 0 . The logic CL q is useful for creating implementations of by-value languages. Burge [2] rediscovered combinators for computer science. Turner <ref> [14] </ref> popularized and improved the translation using a larger set of combinators so that the resulting CL programs were shorter. Then Hughes [8] developed supercombinators that made the translation linear in terms of size.
References-found: 14

