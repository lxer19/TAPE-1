URL: http://www.cs.princeton.edu/prism/papers-ps/graphics-computer.ps
Refering-URL: http://www.cs.princeton.edu/prism/html/all-papers.html
Root-URL: http://www.cs.princeton.edu
Title: Parallel Visualization Algorithms: Performance and Architectural Implications  
Author: Jaswinder Pal Singh, Anoop Gupta and Marc Levoy 
Date: July 1994.  
Note: Slightly modified version appears in IEEE Computer,  
Affiliation: Computer Systems Laboratory Stanford University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Pat. Hanrahan, D. Salzman and L. Aupperle. </author> <title> A Rapid Hierarchical Radiosity Algorithm. </title> <booktitle> Proc. SIGGRAPH, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction Several recent algorithms have substantially sped up complex and time-consuming visualization tasks. In particular, novel algorithms for radiosity computation <ref> [1] </ref> and volume rendering [2][3] have demonstrated performance far superior to earlier methods. Despite these advances, visualization of complex scenes or data sets remains computationally expensive. <p> We demonstrate our claims through parallel versions of three state-of-the-art algorithms: a recent hierarchical radiosity algorithm by Hanrahan et al <ref> [1] </ref>, a ray-casting volume renderer by Levoy (parallelized in [2]), and an optimized ray-tracer [12]. <p> The number of form factors among all pairs of n patches is O (n 2 ), which makes traditional radiosity methods (including progressive radiosity [7]) very expensive. A new hierarchical method <ref> [1] </ref> dramatically reduces the complexity of computing radiosities. The method is inspired by recent advances in using hierarchical methods to solve the N-body problem. <p> Good speedups are also obtained on the Challenge, although data distribution is not an issue there given its centralized shared memory. The speedups shown are for the relatively small room scene (174 input polygons, see Figure 3 (a)) used by Hanrahan et al in <ref> [1] </ref>, which is why they scale more slowly after 32 processors on DASH. <p> In Section 4.4, we also examine a new shear-warp algorithm that is much faster, and by par-allelizing which we are able to obtain interactive frame rates for a rotation sequence of a 256-by-256-by-256 voxel data set on a Silicon Graphics Challenge multiprocessor. area refinement threshold to 2000 units <ref> [1] </ref>. The algorithm took 7 iterations to converge on a uniprocessor. Sec.Procs Dash Challenge 1 290.0 1 88.0 (a) Speedups (b) Working Sets 6 4.1 Sequential Ray-casting Algorithm The volume to be rendered is represented by a cube of voxels (or volume elements).
Reference: [2] <author> Jason Nieh and Marc Levoy. </author> <title> Volume Rendering on Scalable Shared Memory MIMD Architectures. </title> <booktitle> Proc. Boston Workshop on Volume Visualization, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: volume rendering <ref> [2] </ref>[3] have demonstrated performance far superior to earlier methods. Despite these advances, visualization of complex scenes or data sets remains computationally expensive. Rendering a 256-by-256-by-256 voxel volume data set takes about 5 seconds per frame on a 100 MHz Silicon Graphics Indigo workstation using the ray-casting algorithm in [2], and about a second per frame using a new shear-warp algorithm [3]. These times are much larger than the 0.03 seconds per frame required for real-time rendering or the 0.1 seconds per frame required for interactive rendering. Realistic radiosity and ray tracing computations are much more time-consuming. <p> We demonstrate our claims through parallel versions of three state-of-the-art algorithms: a recent hierarchical radiosity algorithm by Hanrahan et al [1], a ray-casting volume renderer by Levoy (parallelized in <ref> [2] </ref>), and an optimized ray-tracer [12]. We also briefly discuss the parallelization of a new, shear-warp volume rendering algorithm [3] which results in what is to our knowledge the first demonstration of interactive frame rates for a 256-by-256-by-256 voxel data set on a general-purpose multiprocessor. <p> Let us now turn our attention now to volume rendering. 4 Volume Rendering Volume rendering techniques are of key importance in the analysis and understanding of multidimensional sampled data, such as those generated in various scientific disciplines. The first parallel algorithm we use, developed in <ref> [2] </ref>, renders volumes using optimized ray casting techniques. Until very recently, the sequential algorithm was one of the fastest known algorithms for volume rendering. <p> Color pictures will appear here. 7 opacity threshold, (ii) the use of an octree representation of space to avoid unnecessary sampling in transparent regions of the volume, and (iii) adaptive image sampling. Adaptive sampling introduces some synchronization at partition boundaries <ref> [2] </ref>, and we present parallel performance both with and without it. 4.2 Exploiting Parallelism In a shared address space, every processor can directly reference any voxel in the data set. <p> Since an equal partitioning of the image plane among processors is not necessarily load balanced, owing to the nonuniformity of the volume data, task stealing is once again required for load balancing. Given p processors, the image plane is partitioned into p rectangular blocks of comparable size <ref> [2] </ref>. Every image block or partition is further subdivided into fixed sized square image tiles, which are the units of task granularity and stealing.
Reference: [3] <author> Phillipe Lacroute and Marc Levoy. </author> <title> Fast Volume Rendering Using a Shear-Warp Factorization of the Viewing Transformation. </title> <booktitle> Proc. SIGGRAPH, </booktitle> <year> 1994. </year>
Reference-contexts: Rendering a 256-by-256-by-256 voxel volume data set takes about 5 seconds per frame on a 100 MHz Silicon Graphics Indigo workstation using the ray-casting algorithm in [2], and about a second per frame using a new shear-warp algorithm <ref> [3] </ref>. These times are much larger than the 0.03 seconds per frame required for real-time rendering or the 0.1 seconds per frame required for interactive rendering. Realistic radiosity and ray tracing computations are much more time-consuming. Multiprocessing provides an attractive solution to this computational bottleneck. <p> We demonstrate our claims through parallel versions of three state-of-the-art algorithms: a recent hierarchical radiosity algorithm by Hanrahan et al [1], a ray-casting volume renderer by Levoy (parallelized in [2]), and an optimized ray-tracer [12]. We also briefly discuss the parallelization of a new, shear-warp volume rendering algorithm <ref> [3] </ref> which results in what is to our knowledge the first demonstration of interactive frame rates for a 256-by-256-by-256 voxel data set on a general-purpose multiprocessor. The rest of the paper is organized as follows. <p> working set for this algorithm is therefore likely to remain small for some time to come. 4.4 Interactive Frame Rates with the Parallel Shear-Warp Method A new shear-warp algorithm has recently been developed that can render a 256-cube voxel data set in one second on a Silicon Graphics Indigo workstation <ref> [3] </ref>. We have parallelized this algorithm both on DASH and on the Challenge. The shear-warp algorithm proceeds in two phases. It first factors the viewing transformation into a three-dimensional shear parallel to the data slices, and projects the data to form a distorted intermediate (composited) image.
Reference: [4] <author> Daniel E. Lenoski et al. </author> <title> The directory-based cache coherence protocol for the DASH multiprocessor. </title> <booktitle> In Proc. 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 148-159, </pages> <year> 1990. </year>
Reference-contexts: When a processor reads or writes a word, that word is brought into the processors cache. Modifying locally cached shared data introduces the cache coherence problem, which is solved by using a distributed directory-based protocol supported in hardware <ref> [4] </ref>. The two important goals in parallelizing an algorithm to run on such a machine are balancing the workload across the cooperating processors and preserving locality of data referencing. <p> The specific machine that we use in most of our experiments is the Stanford DASH multiprocessor, an experimental cache-coherent machine built at Stanford University <ref> [4] </ref>. The machine we use has 48 processors organized in 12 clusters. A cluster consists of four 33MHz MIPS R3000 processors connected by a shared bus, and clusters are connected together in a two-dimensional mesh network.
Reference: [5] <author> Helen Davis, Stephen Goldschmidt and John L. Hennessy. </author> <title> Multiprocessor Simulation and Tracing using Tango. </title> <booktitle> Proc. Intl. Conf. on Parallel Processing, </booktitle> <month> August </month> <year> 1991. </year>
Reference: [6] <author> Edward Rothberg, Jaswinder Pal Singh and Anoop Gupta. </author> <title> Working Sets, Cache Sizes, and Node Granularity for Large-Scale Multiprocessors. </title> <booktitle> In Proc. 20th Annual International Symposium on Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: To analyze temporal locality, we measure the size and impact of the important per-processors working sets of the applications. We measure working sets by using a simulated multiprocessor with fully associative caches to plot the read miss rate versus the cache size used, following the methodology described in <ref> [6] </ref>. input, and reduces the miss rate to a negligible quantity. The algorithm spends the vast majority of its time computing the visibility between interacting patches (say i and j).
Reference: [7] <author> Michael Cohen et al. </author> <title> A progressive refinement approach to fast radiosity image generation. </title> <booktitle> Proc. SIGGRAPH, </booktitle> <year> 1983. </year>
Reference-contexts: The number of form factors among all pairs of n patches is O (n 2 ), which makes traditional radiosity methods (including progressive radiosity <ref> [7] </ref>) very expensive. A new hierarchical method [1] dramatically reduces the complexity of computing radiosities. The method is inspired by recent advances in using hierarchical methods to solve the N-body problem.
Reference: [8] <author> Alan G. Chalmers and Derek J. Paddon. </author> <title> Parallel processing of progressive refinement radiosity methods. </title> <booktitle> Proc. Second Eurographics Workshop on Rendering, </booktitle> <address> Barcelona, </address> <year> 1991. </year>
Reference-contexts: In fact, gathering has been observed to work better than shooting in parallel even for traditional radiosity algorithms on message-passing machines <ref> [8] </ref>. Let us now turn our attention now to volume rendering. 4 Volume Rendering Volume rendering techniques are of key importance in the analysis and understanding of multidimensional sampled data, such as those generated in various scientific disciplines.
Reference: [9] <author> Jaswinder Pal Singh. </author> <title> Parallel Hierarchical N-body Methods and their Implications for Multiprocessors. </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <type> Technical Report No. </type> <institution> CSL-TR-93-563, </institution> <month> February </month> <year> 1993. </year> <title> See also Load Balancing and Data Locality in Hierarchical N-body Methods, </title> <type> Technical Report CSL-TR-92-505, </type> <institution> Stanford University, </institution> <note> to appear in Journal of Parallel and Distributed Computing. </note>
Reference: [10] <author> Susan Spach and Ronald Pulleyblank. </author> <title> Parallel Raytraced Image Generation. </title> <journal> Hewlett-Packard Journal, </journal> <volume> vol. 43, no. 3, </volume> <pages> pages 76-83, </pages> <month> June </month> <year> 1992. </year>
Reference: [11] <author> Stuart A. Green and Derek J. Paddon. </author> <title> A highly flexible multiprocessor solution for ray tracing. </title> <journal> The Visual Computer, </journal> <volume> vol. 6, </volume> <year> 1990, </year> <pages> pp. 62-73. </pages>
Reference-contexts: It then steals tasks from other processors queues, which it can directly access in the shared address space. While this task stealing provides load balancing, it can compromise data locality. However, locality is preserved as follows <ref> [11] </ref>. A processor inserts tasks at the head of its queue. <p> The hierarchical algorithm s use of gathering rather than shooting also results in better communication behaviorsince only a processor that owns a patch writes the radiosity of that patchand avoids the tradeoff between concurrency and preserving the sorted order of patches in a shooting approach <ref> [11] </ref>. In fact, gathering has been observed to work better than shooting in parallel even for traditional radiosity algorithms on message-passing machines [8]. <p> However, it has been an exercise in frustration, and only yielded 11-fold speedups on 32 processors before the project was abandoned as not being worthwhile. We briefly describe some of the main problems here. Detailed descriptions and explanations can be found in <ref> [11] </ref>.
Reference: [12] <author> H. Kobayashi et. al. </author> <title> Load balancing strategies for a parallel ray tracing system based on constant subdivision. </title> <journal> The Visual Computer, </journal> <volume> vol. 4, no. 4, </volume> <pages> pp. 197-209. </pages>
Reference-contexts: We demonstrate our claims through parallel versions of three state-of-the-art algorithms: a recent hierarchical radiosity algorithm by Hanrahan et al [1], a ray-casting volume renderer by Levoy (parallelized in [2]), and an optimized ray-tracer <ref> [12] </ref>. We also briefly discuss the parallelization of a new, shear-warp volume rendering algorithm [3] which results in what is to our knowledge the first demonstration of interactive frame rates for a 256-by-256-by-256 voxel data set on a general-purpose multiprocessor. The rest of the paper is organized as follows. <p> Thus, both image-order and object-order algorithms can be parallelized effectively on cache-coherent multiprocessors. 5 Ray Tracing Our final application is an optimized ray tracer. The ray tracer was originally developed in <ref> [12] </ref> for a message-passing machine, with duplication of the entire scene data set on every processing node, and was later adapted to the current implementation on a shared address space machine without data set duplication. 5.1 Sequential Algorithm As in the ray-casting volume renderer, primary rays are fired from a viewpoint, <p> A hierarchical uniform grid (similar to an octree but with not necessarily binary subdivisions) is used to traverse scene data efficiently <ref> [12] </ref>, and early ray tracing and adaptive sampling are implemented. 5.2 Exploiting Parallelism Like the ray-casting volume renderer, the ray tracing algorithm affords substantial parallelism across rays, and the scene data are read-only.
References-found: 12

