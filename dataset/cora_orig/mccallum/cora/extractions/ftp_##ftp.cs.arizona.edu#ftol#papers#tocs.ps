URL: ftp://ftp.cs.arizona.edu/ftol/papers/tocs.ps
Refering-URL: http://www.cs.arizona.edu/cactus/public.html
Root-URL: http://www.cs.arizona.edu
Title: Coyote: A System for Constructing Fine-Grain Configurable Communication Services  
Author: Nina T. Bhatti, Matti A. Hiltunen, Richard D. Schlichting, and Wanda Chiu 
Keyword: Categories and Subject Descriptors: C.2.2 [Computer-Communication Networks]: Network Protocols Protocol architecture; C.2.4 [Computer-Communication Networks]: Distributed Systems Distributed applications; D.1.3 [Programming Techniques]: Concurrent Programming Distributed programming; D.2.m [Software Engineering]: Miscellaneous Reusable software; D.4.4 [Operating Systems]: Communication Management Network communication; D.4.5 [Operating Systems]: Reliability Fault-tolerance; D.4.7 [Operating Systems]: Organization and Design Distributed systems. General Terms: Design, Experimentation, Performance, Reliability Additional Key Words and Phrases: Configurable services, customization, event-driven execution, event handlers, membership, mobile computing, micro-protocols, modularity, multicast, protocols, remote procedure call, -kernel.  
Affiliation: The University of Arizona  
Abstract: Communication-oriented abstractions such as atomic multicast, group RPC, and protocols for location-independent mobile computing can simplify the development of complex applications built on distributed systems. This paper describes Coyote, a system that supports the construction of highly modular and configurable versions of such abstractions. Coyote extends the notion of protocol objects and hierarchical composition found in existing systems with support for finer-grain micro-protocol objects and a non-hierarchical composition scheme for use within a single layer of a protocol stack. A customized service is constructed by selecting micro-protocols based on their semantic guarantees and configuring them together with a standard runtime system to form a composite protocol implementing the service. This composite protocol is then composed hierarchically with other protocols to form a complete network subsystem. The overall approach is described and illustrated with examples of services that have been constructed using Coyote, including atomic multicast, group RPC, membership, and mobile computing protocols. A prototype implementation based on extending x-kernel version 3.2 running on Mach 3.0 with support for micro-protocols is also presented, together with performance results from a suite of micro-protocols from which over 60 variants of group RPC can be constructed. 
Abstract-found: 1
Intro-found: 1
Reference: [AB93] <author> A. Acharya and B. Badrinath. </author> <title> Delivering multicast messages in networks with mobile hosts. </title> <booktitle> In Proceedings of 13th IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 292-299, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan <ref> [AB93, BBIM93] </ref>, InfoPad [LSBR94, LBSR95], and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [ACG86] <author> S. Ahuja, N. Carriero, and D. Gelernter. </author> <title> Linda and friends. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 26-34, </pages> <month> Aug </month> <year> 1986. </year>
Reference-contexts: This section provides an overview of these three micro-protocol suites. 5.1 Atomic Multicast The atomic multicast service is a customized version designed for the runtime system of a fault-tolerant version of the Linda coordination language <ref> [ACG86] </ref> called FT-Linda [BS95]. Linda is a language for parallel programming based on tuple space (TS), a communication abstraction defined as a bag that can hold data elements called tuples. Processes use TS to communicate and synchronize by depositing and withdrawing tuples from a TS.
Reference: [ADF + 97] <author> T. Abdelzaher, S. Dawson, W. Feng, S. Ghosh, F. Jahanian, S. Johnson, A. Mehra, T. Mitton, J. Norton, A. Shaikh, K. Shin, V. Vaidyan, Z. Wang, and H. Zou. </author> <title> ARMADA middleware suite. </title> <booktitle> In Proceedings of the IEEE Workshop on Middleware for Distributed Real-time Systems and Services, </booktitle> <pages> pages 11-18, </pages> <address> San Francisco, CA, </address> <month> Dec </month> <year> 1997. </year>
Reference-contexts: Other investigators have also reported substantial improvements by moving communication protocols into kernel space on Mach, both for protocols implemented using the x-kernel <ref> [OIOP93, ADF + 97] </ref> and for protocols done using traditional approaches [Bar91].
Reference: [AGSW93] <author> N. Adams, R. Gold, B. Schilit, and R. </author> <title> Want. An infrared network for mobile computers. </title> <booktitle> In Proceedings of the USENIX Mobile and Location-Independent Computing Symposium, </booktitle> <pages> pages 41-51, </pages> <month> Aug </month> <year> 1993. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan [AB93, BBIM93], InfoPad [LSBR94, LBSR95], and PARC TAB <ref> [AGSW93, STW93] </ref>. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [AP93] <author> M. Abbott and L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Trans. on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> Oct </month> <year> 1993. </year> <month> 36 </month>
Reference-contexts: This is similar to optimization techniques used in layered protocol architectures in which headers from multiple protocols are collected together and written in a single operation to avoid the performance overhead of multiple copies <ref> [AP93, Ren96] </ref>. Both 13 of these translation routines are supplied by the user and are invoked automatically by the framework at the appropriate time. Although coordinated sending is the expected norm, there are occasions when a particular micro-protocol might wish to send a message without another micro-protocol's interference or knowledge. <p> In particular, Coyote represents a new non-hierarchical approach to constructing a variety of communication services and high-level network 3 However, similar optimizations have been investigated in the context of the layered x-kernel model on which Coyote is based and its successor Scout system <ref> [AP93, MP96] </ref>. 32 protocols, while Horus and Ensemble are specific highly configurable instances of group communication services. 7.2 Adaptive The Adaptive system [SBS93] proposes a configurable and adaptive framework for building communication protocols for applications like multi-media that have special quality-of-service (QoS) requirements.
Reference: [AS94] <author> G. Agha and D. Sturman. </author> <title> A methodology for adapting to patterns of faults. </title> <editor> In G. Koob and C. Lau, editors, </editor> <booktitle> Foundations of Dependable Computing: Models and Frameworks for Dependable Systems, </booktitle> <pages> pages 23-60. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: In contrast to this framework, the approach used in Coyote is applicable beyond group communication systems and provides a more flexible model to the designer. Object-oriented structuring and the use of reflection to alter behavior in fault-tolerant distributed programs or general operating systems are described in <ref> [AS94, FP98, Yok92] </ref>. As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches.
Reference: [ASJS96] <author> T. Abdelzaher, A. Shaikh, F. Jahanian, and K. Shin. RTCAST: </author> <title> Lightweight multicast for real-time process groups. </title> <booktitle> In Proceedings of the IEEE Real-Time Technology and Applications Symposium, </booktitle> <pages> pages 250-259, </pages> <month> Jun </month> <year> 1996. </year>
Reference-contexts: Many of our goals related to system customization, code reuse, and protocol configurability are adopted from the x-kernel. Armada <ref> [ASJS96] </ref> and OSF/RI MK [TMR96] extend the x-kernel model to support real-time, but with the same protocol object and composition model. Other x-kernel related work has explored the use of finer-grain protocol objects [OP92], but the emphasis there is on syntactic decomposition of higher-level protocols within a hierarchical framework.
Reference: [Bar91] <author> J. Barrera. </author> <title> A fast Mach network IPC implementation. </title> <booktitle> In Proceedings of the USENIX Mach Symposium, </booktitle> <pages> pages 1-12, </pages> <month> Nov </month> <year> 1991. </year>
Reference-contexts: Other investigators have also reported substantial improvements by moving communication protocols into kernel space on Mach, both for protocols implemented using the x-kernel [OIOP93, ADF + 97] and for protocols done using traditional approaches <ref> [Bar91] </ref>. We would expect a similar improvement for GRPC as well. 5 Other Services In addition to group RPC, a number of other configurable services have been designed using Coyote, including an atomic multicast service, a group membership service, and communication support for mobile computing.
Reference: [BBIM93] <author> B. Badrinath, A. Bakre, T. Imielinski, and R. Marantz. </author> <title> Handling mobile clients: A case for indirect interaction. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <address> Napa, CA, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan <ref> [AB93, BBIM93] </ref>, InfoPad [LSBR94, LBSR95], and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [Bha96] <author> N. Bhatti. </author> <title> A System for Constructing Configurable High-Level Protocols. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Nov </month> <year> 1996. </year>
Reference-contexts: A subset has also been ported to the x-kernel prototype. 5.3 Protocols for Mobile Computing To illustrate the value of the approach for other types of applications, a micro-protocol suite has been developed to support customization of communication protocols for mobile computing <ref> [Bha96] </ref>. This suite supports customization of the underlying communication software for different types of mobile hosts, for the base stations that function as gateways between the wired network and mobile host, and for stationary agent processes that act as proxies on the wired network for mobile hosts.
Reference: [BHG87] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions <ref> [BHG87] </ref>, and protocols related to multimedia applications [KE93, Yav92].
Reference: [BK98] <author> N. Brown and C. Kindel. </author> <title> Distributed Component Object Model ProtocolDCOM/1.0. </title> <institution> Microsoft Corp., </institution> <address> Redmond, WA, </address> <month> Jan </month> <year> 1998. </year> <title> Network Working Group Internet Draft. </title>
Reference-contexts: Examples include Microsoft's Component Object Model (COM) and Distributed Component Object Model (DCOM) <ref> [Mic95, BK98] </ref>, Sun's JavaBeans [Sun97], and OMG's Common Object Request Broker Architecture (CORBA) [OMG98]. While differing substantially in their details, all define an object specification and API that allow any object developed according to the specification to communicate with other compatible objects using the API.
Reference: [Bla91] <author> A. Black. </author> <title> Understanding transations in an operating system context. </title> <journal> ACM Op. Syst. Review, </journal> <volume> 20(1) </volume> <pages> 73-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches. Also in the area of fault-tolerance, a number of papers describe abstract properties of services or certain components such as failure detectors <ref> [Bla91, CT96, SR93] </ref>, or present families of related services [CASD85, WS95].
Reference: [BS95] <author> D. Bakken and R. Schlichting. </author> <title> Supporting fault-tolerant parallel programming in Linda. </title> <journal> IEEE Trans. on Parallel and Distr. Syst., </journal> <volume> 6(3) </volume> <pages> 287-302, </pages> <month> Mar </month> <year> 1995. </year>
Reference-contexts: This section provides an overview of these three micro-protocol suites. 5.1 Atomic Multicast The atomic multicast service is a customized version designed for the runtime system of a fault-tolerant version of the Linda coordination language [ACG86] called FT-Linda <ref> [BS95] </ref>. Linda is a language for parallel programming based on tuple space (TS), a communication abstraction defined as a bag that can hold data elements called tuples. Processes use TS to communicate and synchronize by depositing and withdrawing tuples from a TS.
Reference: [BSP + 95] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety, and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. In addition, our approach is related to recent work in configurable operating systems <ref> [BSP + 95, EKO95, HPM93, MMO + 94] </ref> and on the use of object-orientation and reflection to build customizable operating systems [MHM + 95, Yok92] and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model <p> Although not yet implemented, two other possible optimizations that would reduce this overhead further are in-lining of handlers, and support for handler guards similar to those found in SPIN <ref> [BSP + 95] </ref>. In-lining involves replacing calls to the framework raiseEvent () procedure with the micro-protocol code using appropriate compiler support. The compiler would enforce visibility rules and rename variables in the handler code that clash with variables in the surrounding micro-protocol code. <p> These include Exokernel [EKO95], Scout [MP96], SLIC [GRPA97], SPIN <ref> [BSP + 95] </ref>, and VINO [SESS96], as well as work on subcontracts [HPM93] and application-controlled file caching [CFL94]. These projects attempt to increase the ability of users to configure different types of services, but for many aspects of operating system functionality rather than just the type of services considered here.
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Complex applications built on a distributed architecture can be simplified if the underlying software provides suitably tailored communication-oriented abstractions. For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications <ref> [BSS91, CASD85, MSMA90, PBS89] </ref>. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92]. <p> This section outlines relevant work. 7.1 Horus and Ensemble Horus [RBM96] and Ensemble [Hay98] are successive generations of systems for constructing configurable distributed services based on the original ISIS system <ref> [BSS91] </ref>. As with Coyote, services in Horus and Ensemble are composed of combinations of software modulesalso called micro-protocolsthat allow different tradeoffs to be made regarding semantics and performance.
Reference: [CAB + 86] <author> R. Constable, S. Allen, H. Bromley, W. Cleaveland, J. Cremer, R. Harper, D. Howe, T. Knoblock, N. Mendler, P. Panangaden, J. Sasaki, and S. Smith. </author> <title> Implementing Mathematics with the Nuprl Development System. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: The Horus/Ensemble project has also investigated a number of issues beyond those addressed in Coyote to date, including development of a theoretical framework based on Nuprl <ref> [CAB + 86] </ref> for reasoning about semantics, and investigation of techniques for optimizing data and control transfer between layered micro-protocols [HR97, RBF + 95, Ren96]. 3 Despite these similarities, however, there are a number of differences between our approach and that used for Horus and Ensemble.
Reference: [CASD85] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Proceedings of the 15th IEEE International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206, </pages> <address> Ann Arbor, MI, </address> <month> Jun </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Complex applications built on a distributed architecture can be simplified if the underlying software provides suitably tailored communication-oriented abstractions. For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications <ref> [BSS91, CASD85, MSMA90, PBS89] </ref>. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92]. <p> Also in the area of fault-tolerance, a number of papers describe abstract properties of services or certain components such as failure detectors [Bla91, CT96, SR93], or present families of related services <ref> [CASD85, WS95] </ref>.
Reference: [CBM + 94] <author> M. Condict, D. Bolinger, E. McManus, D. Mitchell, and S. Lewontin. </author> <title> Microkernel modularity with integrated kernel performance. </title> <type> Technical report, </type> <institution> OSF Research Institute, </institution> <address> Cambridge, MA, </address> <month> Apr </month> <year> 1994. </year>
Reference-contexts: For example, a 50% performance penalty has been reported for a single-server Unix implementation executing on Mach relative to an integrated version, largely because all operating system service requests use a heavyweight IPC mechanism <ref> [CBM + 94] </ref>. Other investigators have also reported substantial improvements by moving communication protocols into kernel space on Mach, both for protocols implemented using the x-kernel [OIOP93, ADF + 97] and for protocols done using traditional approaches [Bar91].
Reference: [CFL94] <author> P. Cao, E. Felten, and K. Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proceedingsof the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 165-178, </pages> <address> Monterey, CA, </address> <month> Nov </month> <year> 1994. </year>
Reference-contexts: These include Exokernel [EKO95], Scout [MP96], SLIC [GRPA97], SPIN [BSP + 95], and VINO [SESS96], as well as work on subcontracts [HPM93] and application-controlled file caching <ref> [CFL94] </ref>. These projects attempt to increase the ability of users to configure different types of services, but for many aspects of operating system functionality rather than just the type of services considered here.
Reference: [CGR88] <author> R. Cmelik, N. Gehani, and W. Roome. </author> <title> Fault Tolerant Concurrent C: A tool for writing fault tolerant distributed programs. </title> <booktitle> In Proceedings of the 18th IEEE International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 55-61, </pages> <address> Tokyo, </address> <month> Jun </month> <year> 1988. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC <ref> [Che86, CGR88, Coo90] </ref>, membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [Che86] <author> D. Cheriton. VMTP: </author> <title> A transport protocol for the next generation of communication systems. </title> <booktitle> In Proceedings of SIGCOMM'86, </booktitle> <pages> pages 406-415, </pages> <month> Aug </month> <year> 1986. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC <ref> [Che86, CGR88, Coo90] </ref>, membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [CLR95] <author> D. Comer, J. Lin, and V. Russo. </author> <title> An architecture for a campus-scale wireless mobile internet. </title> <type> Technical Report CSD-TR95-058, </type> <institution> Purdue University, Department of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint <ref> [CR94, CLR95] </ref>, DataMan [AB93, BBIM93], InfoPad [LSBR94, LBSR95], and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [Coo90] <author> E. Cooper. </author> <title> Programming language support for multicast communication in distributed systems. </title> <booktitle> In Proceedings of the 10th IEEE Conference on Distributed Computing Systems, </booktitle> <pages> pages 450-457, </pages> <address> Paris, France, </address> <year> 1990. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC <ref> [Che86, CGR88, Coo90] </ref>, membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [CR94] <author> D. Comer and V. Russo. </author> <title> Using ATM for a campus-wide wireless internetwork. </title> <booktitle> In Proceedings of the IEEE Workshop on Mobile Computing, </booktitle> <address> Santa Cruz, CA, </address> <year> 1994. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint <ref> [CR94, CLR95] </ref>, DataMan [AB93, BBIM93], InfoPad [LSBR94, LBSR95], and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [Cri91] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership <ref> [Cri91, KGR91, MPS92] </ref>, distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [CT96] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Jour. of the ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> Mar </month> <year> 1996. </year>
Reference-contexts: As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches. Also in the area of fault-tolerance, a number of papers describe abstract properties of services or certain components such as failure detectors <ref> [Bla91, CT96, SR93] </ref>, or present families of related services [CASD85, WS95].
Reference: [EKO95] <author> D. Engler, M. Kaashoek, and J. O'Toole. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> Dec </month> <year> 1995. </year> <month> 37 </month>
Reference-contexts: The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. In addition, our approach is related to recent work in configurable operating systems <ref> [BSP + 95, EKO95, HPM93, MMO + 94] </ref> and on the use of object-orientation and reflection to build customizable operating systems [MHM + 95, Yok92] and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model <p> These include Exokernel <ref> [EKO95] </ref>, Scout [MP96], SLIC [GRPA97], SPIN [BSP + 95], and VINO [SESS96], as well as work on subcontracts [HPM93] and application-controlled file caching [CFL94].
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Jour. of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: The relations may result from fundamental relations between the properties being implemented or from implementation choices made during the design process. For example, failure detection cannot be both live and accurate in asynchronous systems <ref> [FLP85, SM94] </ref>, so micro-protocols implementing these variants conflict based on their underlying properties. <p> For configurability, the key is designing a micro-protocol to minimize conflicts and dependencies with other micro-protocols, as discussed in section 2.6. As noted there, some of these relations are inherent in the properties being implementedthe conflict between accurate and live failure detection, for example <ref> [FLP85, SM94] </ref>but others are influenced by how the properties are implemented. Based on our experience, it is relatively easy to ensure that micro-protocol implementations preserve the independence of the corresponding properties.
Reference: [Fon94] <author> H. Fonseca. </author> <title> Support environments for the modularization, implementation and execution of communication protocols. </title> <type> Master's thesis, </type> <institution> Instituto Superior Tecnico, Lisboa, Portugal, </institution> <month> Jun </month> <year> 1994. </year> <note> In Portuguese. </note>
Reference-contexts: The developers of xAMP, a real-time atomic multicast protocol, report a similar experience <ref> [Fon94, VRB89] </ref>. The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. <p> As already noted, the inclusion of facilities for non-hierarchical composition was prompted in large part by limitations in a purely hierarchical model encountered when using hierarchical systems to construct group communication protocols <ref> [Fon94, MPS93b] </ref>. With Coyote, designers have the ability to use both hierarchical and non-hierarchical composition within the same system as needed. The computational model supported by Coyote also results in differences with the Horus and Ensemble approach.
Reference: [FP98] <author> J.-C. Fabre and T. Perennou. </author> <title> A metaobject architecture for fault-tolerant distributed systems: The FRIENDS approach. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 47(1) </volume> <pages> 78-95, </pages> <month> Jan </month> <year> 1998. </year>
Reference-contexts: In addition, our approach is related to recent work in configurable operating systems [BSP + 95, EKO95, HPM93, MMO + 94] and on the use of object-orientation and reflection to build customizable operating systems [MHM + 95, Yok92] and services for distributed systems <ref> [FP98] </ref>. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model with the ability to internally structure x-kernel protocol objects using micro-protocols. <p> In contrast to this framework, the approach used in Coyote is applicable beyond group communication systems and provides a more flexible model to the designer. Object-oriented structuring and the use of reflection to alter behavior in fault-tolerant distributed programs or general operating systems are described in <ref> [AS94, FP98, Yok92] </ref>. As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches.
Reference: [GNI92] <author> M. Goldberg, G. Neufeld, and M. Ito. </author> <title> The parallel protocol framework. </title> <type> Technical Report 92-16, </type> <institution> Dept. of Computer Science, University of British Columbia, Vancouver, British Columbia, </institution> <month> Aug </month> <year> 1992. </year>
Reference-contexts: System V Streams [Rit84] also supports modularization of protocols, but its model is also hierarchical and relatively coarse 33 grained. Several other efforts have concentrated on supporting parallel execution of modular protocols, including <ref> [GNI92, LAKS93] </ref>. While similar to our work in the sense of decomposing protocols along semantic lines, these efforts differ in their emphasis on using parallel execution to improve throughput and latency for high-performance scientific applications.
Reference: [Gol92] <author> R. Golding. </author> <title> Weak-Consistency Group Communication and Membership. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of California, </institution> <address> Santa Cruz, Santa Cruz, CA, </address> <year> 1992. </year>
Reference-contexts: While not configurable software modules in the sense of Coyote micro-protocols, a given transparency can be added to an application level service by replacing the original service by a new service that includes the chosen transparency. Another example is the modular framework for group communication systems proposed in <ref> [Gol92] </ref>. This framework has four fixed components: the application, message delivery, message ordering, and group membership. Each component may have different implementations. For example, different ordering components can implement different variations, such as unordered, FIFO, causal, and total order.
Reference: [GRPA97] <author> D. Ghormley, S. Rodrigues, D. Petrou, and T. Anderson. </author> <title> Interposition as an operating system extension mechanism. </title> <type> Technical Report CSD-96-920, </type> <institution> University of California, Berkeley, </institution> <month> Sept </month> <year> 1997. </year>
Reference-contexts: These include Exokernel [EKO95], Scout [MP96], SLIC <ref> [GRPA97] </ref>, SPIN [BSP + 95], and VINO [SESS96], as well as work on subcontracts [HPM93] and application-controlled file caching [CFL94].
Reference: [Hay98] <author> M. Hayden. </author> <title> The Ensemble system. </title> <type> Technical Report TR 98-1662, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <month> Jan </month> <year> 1998. </year>
Reference-contexts: This paper describes Coyote, a system that supports the construction of highly modular and configurable versions of complex high-level protocols. Coyote extends the notion of protocol objects supported by systems such as Adaptive [SBS93], Horus/Ensemble <ref> [Hay98, RBM96] </ref>, and the x-kernel [HP91] to finer-grain modules called micro-protocols that implement individual properties of the target service as separate modules. For example, with atomic multicast, one micro-protocol might implement the consistent ordering requirements, while another might implement reliable transmission. <p> A number of other researchers and systems have addressed similar issues in a variety of contexts, including networking, fault tolerance in distributed systems, and distributed applications. This section outlines relevant work. 7.1 Horus and Ensemble Horus [RBM96] and Ensemble <ref> [Hay98] </ref> are successive generations of systems for constructing configurable distributed services based on the original ISIS system [BSS91]. As with Coyote, services in Horus and Ensemble are composed of combinations of software modulesalso called micro-protocolsthat allow different tradeoffs to be made regarding semantics and performance.
Reference: [Her89] <author> A. Herbert. </author> <title> ANSA Project and Standards. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 17, </booktitle> <pages> pages 391-438. </pages> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: The use of modularization or system customization has been explored for constructing other types of distributed services as well. One example is the ANSA system, a software architecture for building distributed systems <ref> [Her89, Her94, OOW91] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how they interact.
Reference: [Her94] <author> A. Herbert. </author> <title> An ANSA overview. </title> <journal> IEEE Network, </journal> <volume> 8(1), </volume> <month> Jan </month> <year> 1994. </year>
Reference-contexts: The use of modularization or system customization has been explored for constructing other types of distributed services as well. One example is the ANSA system, a software architecture for building distributed systems <ref> [Her89, Her94, OOW91] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how they interact.
Reference: [Hil96] <author> M. Hiltunen. </author> <title> Configurable Distributed Fault-Tolerant Services. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Jul </month> <year> 1996. </year>
Reference-contexts: Unbinding and cancellation are especially useful for dynamically altering handler execution <ref> [Hil96] </ref>. Note also that there are no restrictions on binding handlers to events, so that a given handler may be registered for multiple events and multiple handlers may be registered for a single event. <p> Techniques for identifying and formally specifying properties are beyond the scope of this paper, but are addressed in <ref> [Hil96, HS95b] </ref> for the case of membership services. In building micro-protocols for a service, a basic initial issue is selecting an overall implementation strategy for the service. For example, the suite may be based on a centralized strategy using a coordinating site or may be fully decentralized. <p> This leads to the dependency relation between micro-protocols. The relations between micro-protocols and the underlying abstract properties can be represented graphically using configuration and dependency graphs, respectively <ref> [Hil96] </ref>. These graphs can be used to evaluate if a proposed configuration is feasible, as well as to enumerate all possible valid configurations. <p> Servers must communicate reliably or communication would halt if an ordering message was lost. This functionality is provided by CRET. Formal dependency and configuration graphs for a similar suite of group RPC micro-protocols can be found in <ref> [HS95a, Hil96] </ref>. 4.3 Performance Measurements Tests consisted of one or more clients sending a 4-byte integer to one or more servers, which respond with an integer. Each test makes 1000 RPC calls and was run 10 times. The round trip times are the average of the 10 test runs. <p> For example, a TokenDriver micro 27 protocol handles the mechanics of passing the token between the sites and dealing with lost tokens. The micro-protocols can be configured to realize over 1000 semantically different composite protocols <ref> [Hil96] </ref>. The complete suite of micro-protocols has been implemented and tested using the C++ prototype (see section 6.1).
Reference: [HP91] <author> N. Hutchinson and L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: This paper describes Coyote, a system that supports the construction of highly modular and configurable versions of complex high-level protocols. Coyote extends the notion of protocol objects supported by systems such as Adaptive [SBS93], Horus/Ensemble [Hay98, RBM96], and the x-kernel <ref> [HP91] </ref> to finer-grain modules called micro-protocols that implement individual properties of the target service as separate modules. For example, with atomic multicast, one micro-protocol might implement the consistent ordering requirements, while another might implement reliable transmission. Micro-protocols can also be used to implement different semantic variants of the same property.
Reference: [HPM93] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <address> Asheville, NC, </address> <month> Dec </month> <year> 1993. </year>
Reference-contexts: The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. In addition, our approach is related to recent work in configurable operating systems <ref> [BSP + 95, EKO95, HPM93, MMO + 94] </ref> and on the use of object-orientation and reflection to build customizable operating systems [MHM + 95, Yok92] and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model <p> These include Exokernel [EKO95], Scout [MP96], SLIC [GRPA97], SPIN [BSP + 95], and VINO [SESS96], as well as work on subcontracts <ref> [HPM93] </ref> and application-controlled file caching [CFL94]. These projects attempt to increase the ability of users to configure different types of services, but for many aspects of operating system functionality rather than just the type of services considered here.
Reference: [HR97] <author> M. Hayden and R. van Renesse. </author> <title> Optimizing layered communication protocols. </title> <booktitle> In Proceedings of the 6th IEEE Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 169-177, </pages> <address> Portland, OR, </address> <month> Aug </month> <year> 1997. </year>
Reference-contexts: The Horus/Ensemble project has also investigated a number of issues beyond those addressed in Coyote to date, including development of a theoretical framework based on Nuprl [CAB + 86] for reasoning about semantics, and investigation of techniques for optimizing data and control transfer between layered micro-protocols <ref> [HR97, RBF + 95, Ren96] </ref>. 3 Despite these similarities, however, there are a number of differences between our approach and that used for Horus and Ensemble.
Reference: [HS93] <author> M. Hiltunen and R. Schlichting. </author> <title> An approach to constructing modular fault-tolerant protocols. </title> <booktitle> In Proceedings of the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 105-114, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Internally, the framework implements an event-driven execution paradigm, in which event handlers within micro-protocols are executed whenever events for which they are registeredfor example, message arrival or a timeoutoccur <ref> [HS93] </ref>. Thus, in relation to standard x-kernel protocols, micro-protocols are finer-grain objects that interact more closely and do so using mechanisms provided by the framework rather than the x-kernel Uniform Protocol Interface (UPI). The second prototype is written in C++.
Reference: [HS95a] <author> M. Hiltunen and R. Schlichting. </author> <title> Constructing a configurable group RPC service. </title> <booktitle> In Proceedings of the 15th IEEE Conference on Distributed Computing Systems, </booktitle> <pages> pages 288-295, </pages> <address> Vancouver, BC, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Thus, for each request, the coordinator sends an ordering message, Order (Req (x)), to all other servers. 4.1 Micro-protocols The micro-protocol suite is based on the semantic variations of GRPC described in <ref> [HS95a] </ref>; the categories that follow represent semantic variations of termination, ordering, communication, collation, call style, membership, and failure handling. Termination semantics. Termination semantics specify the guarantees that are given about the termination of a call. These micro-protocols are included in the client composite protocol. 19 * BOUNDED (BND). <p> Servers must communicate reliably or communication would halt if an ordering message was lost. This functionality is provided by CRET. Formal dependency and configuration graphs for a similar suite of group RPC micro-protocols can be found in <ref> [HS95a, Hil96] </ref>. 4.3 Performance Measurements Tests consisted of one or more clients sending a 4-byte integer to one or more servers, which respond with an integer. Each test makes 1000 RPC calls and was run 10 times. The round trip times are the average of the 10 test runs.
Reference: [HS95b] <author> M. Hiltunen and R. Schlichting. </author> <title> Properties of membership services. </title> <booktitle> In Proceedings of the Second IEEE Symp. on Autonomous Decentralized Systems, </booktitle> <pages> pages 200-207, </pages> <address> Phoenix, AZ, </address> <month> Apr </month> <year> 1995. </year>
Reference-contexts: Techniques for identifying and formally specifying properties are beyond the scope of this paper, but are addressed in <ref> [Hil96, HS95b] </ref> for the case of membership services. In building micro-protocols for a service, a basic initial issue is selecting an overall implementation strategy for the service. For example, the suite may be based on a centralized strategy using a coordinating site or may be fully decentralized.
Reference: [HS95c] <author> M. Hiltunen and R. Schlichting. </author> <title> Understanding membership. </title> <type> Technical Report 95-07, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Jul </month> <year> 1995. </year>
Reference-contexts: These membership messages can report, for example, failures, recoveries, or the joining of two partitions. Given such a system, the properties of a membership service can be defined in terms of what membership messages it generates and when they are delivered to the application <ref> [HS95c] </ref>. For the purposes of constructing a micro-protocol suite, we divided the properties of a membership service as follows: * Change detection. Includes variants involving the tradeoff between accuracya change is reported only if the change has indeed occurredand livenessall changes are eventually reported. * Agreement.
Reference: [HS96] <author> M. Hiltunen and R. Schlichting. </author> <title> Adaptive distributed and fault-tolerant systems. </title> <journal> Computer Systems Science and Engineering, </journal> <volume> 11(5) </volume> <pages> 125-133, </pages> <month> Sep </month> <year> 1996. </year>
Reference-contexts: Of course, in many cases, such changes require coordination among sites <ref> [HS96] </ref>. A second more powerful technique is to change the actual micro-protocols within a composite protocol at runtime. This can be done, for example, using active networking techniques to introduce the needed changes, and runtime compilation to make the actual code modifications.
Reference: [HS98] <author> M. Hiltunen and R. Schlichting. </author> <title> A configurable membership service. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 47(5), </volume> <month> May </month> <year> 1998. </year> <pages> 573-586. </pages>
Reference-contexts: messages to stable storage. 2.5 An Example Micro-protocol To illustrate the programming style and event-driven paradigm, figure 3 presents a failure detection micro-protocol, which is taken from a configurable process group membership service that provides consistent information about which sites are functioning and which have failed at any given time <ref> [HS98] </ref>. In this service, micro-protocols are provided 7 that implement different variants of multiple properties, including site failure detection, agreement among sites on changes, partition handling, and consistent ordering of membership change notification relative to other membership changes and application messages.
Reference: [KE93] <author> R. Keller and W. Effelsberg. MCAM: </author> <title> An application layer protocol for Movie Control, Access, </title> <booktitle> and Management. In Computer Graphics (Multimedia '93 Proceedings), </booktitle> <pages> pages 21-30. </pages> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications <ref> [KE93, Yav92] </ref>. Such abstractions logically form a distribution support layerthat is, a layer that provides execution guarantees regarding the distributed state of the applicationthat occupies a place in the system hierarchy fl This work supported in part by the Office of Naval Research under grants N00014-91-J-1015, N00014-94-1-0015, and N00014-96-0207.
Reference: [KGR91] <author> H. Kopetz, G. Grunsteidl, and J. Reisinger. </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system. </title> <editor> In A. Avizienis and J.C. Laprie, editors, </editor> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 411-429. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, </address> <year> 1991. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership <ref> [Cri91, KGR91, MPS92] </ref>, distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [LAKS93] <author> B. Lindgren, M. Ammar, B. Krupczak, and K. Schwan. </author> <title> Parallel and configurable protocols: Experiences with a prototype and an architectural framework. </title> <booktitle> In Proceedings of International Conference on Network Protocols, </booktitle> <month> Mar </month> <year> 1993. </year>
Reference-contexts: System V Streams [Rit84] also supports modularization of protocols, but its model is also hierarchical and relatively coarse 33 grained. Several other efforts have concentrated on supporting parallel execution of modular protocols, including <ref> [GNI92, LAKS93] </ref>. While similar to our work in the sense of decomposing protocols along semantic lines, these efforts differ in their emphasis on using parallel execution to improve throughput and latency for high-performance scientific applications.
Reference: [LBSR95] <author> M. T. Le, F. Burghardt, S. Seshan, and J. Rabaey. InfoNet: </author> <booktitle> The networking infrastructure of InfoPad. In Proceedings of Compcon, </booktitle> <address> San Francisco, California, </address> <month> Mar </month> <year> 1995. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan [AB93, BBIM93], InfoPad <ref> [LSBR94, LBSR95] </ref>, and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [LSBR94] <author> M. T. Le, S. Seshan, F. Burghardt, and J. </author> <title> Rabaey. </title> <booktitle> Software architecture of the InfoPad system. In Proceedings of the Mobidata Workshop on Mobile and Wireless Information Systems, Rutgers, </booktitle> <address> New Jersey, </address> <month> Nov </month> <year> 1994. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan [AB93, BBIM93], InfoPad <ref> [LSBR94, LBSR95] </ref>, and PARC TAB [AGSW93, STW93]. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [MHM + 95] <author> K. Murata, R. Horspool, E. Manning, Y. Yokote, and M. Tokoro. </author> <title> Unification of active and passive objects in an object-oriented operating system. </title> <booktitle> In Proceedings of 1995 Int. Workshop of Object Orientation in Operating Systems (IWOOOS'95), </booktitle> <month> Aug </month> <year> 1995. </year> <month> 38 </month>
Reference-contexts: In addition, our approach is related to recent work in configurable operating systems [BSP + 95, EKO95, HPM93, MMO + 94] and on the use of object-orientation and reflection to build customizable operating systems <ref> [MHM + 95, Yok92] </ref> and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model with the ability to internally structure x-kernel protocol objects using micro-protocols.
Reference: [Mic95] <institution> The Component Object Model Specification (version 0.9). Microsoft Corp., </institution> <address> Redmond, WA, </address> <month> Oct </month> <year> 1995. </year>
Reference-contexts: Examples include Microsoft's Component Object Model (COM) and Distributed Component Object Model (DCOM) <ref> [Mic95, BK98] </ref>, Sun's JavaBeans [Sun97], and OMG's Common Object Request Broker Architecture (CORBA) [OMG98]. While differing substantially in their details, all define an object specification and API that allow any object developed according to the specification to communicate with other compatible objects using the API.
Reference: [MMO + 94] <author> A. Montz, D. Mosberger, S. O'Malley, L. Peterson, T. Proebsting, and J. Hartman. </author> <title> Scout: A communications-oriented operating system. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Design and Implementation (OSDI), </booktitle> <month> Nov </month> <year> 1994. </year>
Reference-contexts: The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. In addition, our approach is related to recent work in configurable operating systems <ref> [BSP + 95, EKO95, HPM93, MMO + 94] </ref> and on the use of object-orientation and reflection to build customizable operating systems [MHM + 95, Yok92] and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model
Reference: [MMSA + 96] <author> L. Moser, P.M. Melliar-Smith, D. Agarwal, R. Budhia, and C. Lingley-Papadopoulos. Totem: </author> <title> A fault-tolerant multicast group communication system. </title> <journal> Commun. of the ACM, </journal> <volume> 39(4) </volume> <pages> 54-63, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: On the other hand, the relation between a micro-protocol implementing consistent total message ordering and one 10 implementing causal ordering depends on the implementation design, since it is possible to implement total order either with or without an underlying causal order (e.g., [MPS93a] and <ref> [MMSA + 96] </ref>, respectively). Similarly, whether two micro-protocols have a dependency or inclusion relation is often based on implementation convenience. For example, causal message ordering also trivially realizes FIFO ordering and could be built on a FIFO ordering micro-protocol.
Reference: [MP96] <author> D. Mosberger and L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Design and Implementation (OSDI), </booktitle> <pages> pages 153-168, </pages> <address> Seattle, WA, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: In particular, Coyote represents a new non-hierarchical approach to constructing a variety of communication services and high-level network 3 However, similar optimizations have been investigated in the context of the layered x-kernel model on which Coyote is based and its successor Scout system <ref> [AP93, MP96] </ref>. 32 protocols, while Horus and Ensemble are specific highly configurable instances of group communication services. 7.2 Adaptive The Adaptive system [SBS93] proposes a configurable and adaptive framework for building communication protocols for applications like multi-media that have special quality-of-service (QoS) requirements. <p> These include Exokernel [EKO95], Scout <ref> [MP96] </ref>, SLIC [GRPA97], SPIN [BSP + 95], and VINO [SESS96], as well as work on subcontracts [HPM93] and application-controlled file caching [CFL94].
Reference: [MPS92] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> A membership protocol based on partial order. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <booktitle> Dependable Computing for Critical Applications 2, </booktitle> <pages> pages 309-331. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, </address> <year> 1992. </year>
Reference-contexts: For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications [BSS91, CASD85, MSMA90, PBS89]. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership <ref> [Cri91, KGR91, MPS92] </ref>, distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [MPS93a] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering, </journal> <volume> 1(3) </volume> <pages> 87-103, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: The need for a new approach has been reinforced by experience with existing systems. For example, using the x-kernel to construct Consul, a protocol suite implementing atomic multicast <ref> [MPS93a, PBS89] </ref>, highlighted deficiencies in several areas, including support for complex interactions among protocol objects, limited facilities for data sharing, and an orientation towards hierarchical protocol composition at the expense of more flexible combinations [MPS93b]. The developers of xAMP, a real-time atomic multicast protocol, report a similar experience [Fon94, VRB89]. <p> This can be important, for example, in an atomic multicast protocol that requires waiting for a collection of messages to arrive and then deterministically sorting the collection before presenting messages to higher levels <ref> [MPS93a, PBS89] </ref>. Second, a shared bag of messages allows multiple micro-protocols to access messages concurrently. This can be important, for example, in a situation where a message is acknowledged by one micro-protocol while concurrently being ordered relative to other messages by a second micro-protocol. <p> On the other hand, the relation between a micro-protocol implementing consistent total message ordering and one 10 implementing causal ordering depends on the implementation design, since it is possible to implement total order either with or without an underlying causal order (e.g., <ref> [MPS93a] </ref> and [MMSA + 96], respectively). Similarly, whether two micro-protocols have a dependency or inclusion relation is often based on implementation convenience. For example, causal message ordering also trivially realizes FIFO ordering and could be built on a FIFO ordering micro-protocol. <p> Maintains information about whether a message is stable, i.e., known to be have been received by all functioning sites. The last three use an approach similar to that used in Psync [PBS89] and the Consul system <ref> [MPS93a] </ref>. In particular, messages sent to the progress group are stored in a context graph that maintains causality information about messages 26 i.e., the predecessors of a message m are those messages that the sender of m received before sending m.
Reference: [MPS93b] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Experience with modularity in Consul. </title> <journal> Software: Practice and Experience, </journal> <volume> 23(10) </volume> <pages> 1059-1075, </pages> <month> Oct </month> <year> 1993. </year>
Reference-contexts: For example, using the x-kernel to construct Consul, a protocol suite implementing atomic multicast [MPS93a, PBS89], highlighted deficiencies in several areas, including support for complex interactions among protocol objects, limited facilities for data sharing, and an orientation towards hierarchical protocol composition at the expense of more flexible combinations <ref> [MPS93b] </ref>. The developers of xAMP, a real-time atomic multicast protocol, report a similar experience [Fon94, VRB89]. The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96]. <p> As already noted, the inclusion of facilities for non-hierarchical composition was prompted in large part by limitations in a purely hierarchical model encountered when using hierarchical systems to construct group communication protocols <ref> [Fon94, MPS93b] </ref>. With Coyote, designers have the ability to use both hierarchical and non-hierarchical composition within the same system as needed. The computational model supported by Coyote also results in differences with the Horus and Ensemble approach.
Reference: [MSMA90] <author> P.M. Melliar-Smith, L. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Trans. on Parallel and Distr. Syst., </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> Jan </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Complex applications built on a distributed architecture can be simplified if the underlying software provides suitably tailored communication-oriented abstractions. For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications <ref> [BSS91, CASD85, MSMA90, PBS89] </ref>. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92].
Reference: [OIOP93] <author> H. Orman, E. Menze III, S. O'Malley, and L. Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Proceedings of USENIX 1993 Mach Symposium, </booktitle> <pages> pages 75 - 88, </pages> <month> Apr </month> <year> 1993. </year>
Reference-contexts: As noted, the x-kernel Sun RPC is included primarily for comparison purposes. However, the fact that this number is consistent with that reported elsewhere <ref> [OIOP93] </ref> for an RPC system constructed using the x-kernel on almost identical hardware suggests that our implementations are also competitive in an absolute sense given the target hardware configuration. In general, increasing the guarantees the communication service provides results in a slower roundtrip execution time. <p> Other investigators have also reported substantial improvements by moving communication protocols into kernel space on Mach, both for protocols implemented using the x-kernel <ref> [OIOP93, ADF + 97] </ref> and for protocols done using traditional approaches [Bar91].
Reference: [OMG97] <institution> Object Management Group. </institution> <month> CORBAservices: </month> <title> Common Object Services Specification (updated), </title> <month> November </month> <year> 1997. </year>
Reference-contexts: Communication in COM/DCOM and JavaBeans is based on generating events 34 that are translated into method calls on other object (s), while communication in CORBA is oriented primarily around using method calls directly, although events are also supported in the associated Common Object Service Specification (COSS) <ref> [OMG97] </ref>. Coyote differs from these component architectures primarily in its orientation and scope. Our system provides a two-level composition model for constructing services on a single machine, with coarse-grain components organized hierarchically and fine-grain micro-protocol components within a composite protocol organized non-hierarchically.
Reference: [OMG98] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (Revision 2.2), </title> <month> Feb </month> <year> 1998. </year>
Reference-contexts: In addition to serving as a prototyping platform, this version illustrates the ease with which the event-driven approach can be implemented using standard operating system facilities. The system could also be used as the starting point for a true distributed implementation based on C++ using, for example, CORBA <ref> [OMG98] </ref> for underlying distribution support. <p> Examples include Microsoft's Component Object Model (COM) and Distributed Component Object Model (DCOM) [Mic95, BK98], Sun's JavaBeans [Sun97], and OMG's Common Object Request Broker Architecture (CORBA) <ref> [OMG98] </ref>. While differing substantially in their details, all define an object specification and API that allow any object developed according to the specification to communicate with other compatible objects using the API.
Reference: [OOW91] <author> M. Olsen, E. Oskiewicz, and J. Warne. </author> <title> A model for interface groups. </title> <booktitle> In Proceedings of the 10th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 98-107, </pages> <address> Pisa, Italy, </address> <month> Sep </month> <year> 1991. </year>
Reference-contexts: The use of modularization or system customization has been explored for constructing other types of distributed services as well. One example is the ANSA system, a software architecture for building distributed systems <ref> [Her89, Her94, OOW91] </ref>. ANSA provides a general computational model that defines how objects in a distributed system are specified and how they interact.
Reference: [OP92] <author> S. O'Malley and L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Armada [ASJS96] and OSF/RI MK [TMR96] extend the x-kernel model to support real-time, but with the same protocol object and composition model. Other x-kernel related work has explored the use of finer-grain protocol objects <ref> [OP92] </ref>, but the emphasis there is on syntactic decomposition of higher-level protocols within a hierarchical framework. This work, however, does lend credence to the claim that such fine-grain modularity can be introduced without sacrificing performance.
Reference: [PBS89] <author> L. Peterson, N. Buchholz, and R. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> Aug </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Complex applications built on a distributed architecture can be simplified if the underlying software provides suitably tailored communication-oriented abstractions. For example, ordered atomic multicast provides atomic and consistently ordered message delivery to a group of processes, which can be useful for writing real-time and fault-tolerant distributed applications <ref> [BSS91, CASD85, MSMA90, PBS89] </ref>. Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications [KE93, Yav92]. <p> The need for a new approach has been reinforced by experience with existing systems. For example, using the x-kernel to construct Consul, a protocol suite implementing atomic multicast <ref> [MPS93a, PBS89] </ref>, highlighted deficiencies in several areas, including support for complex interactions among protocol objects, limited facilities for data sharing, and an orientation towards hierarchical protocol composition at the expense of more flexible combinations [MPS93b]. The developers of xAMP, a real-time atomic multicast protocol, report a similar experience [Fon94, VRB89]. <p> This can be important, for example, in an atomic multicast protocol that requires waiting for a collection of messages to arrive and then deterministically sorting the collection before presenting messages to higher levels <ref> [MPS93a, PBS89] </ref>. Second, a shared bag of messages allows multiple micro-protocols to access messages concurrently. This can be important, for example, in a situation where a message is acknowledged by one micro-protocol while concurrently being ordered relative to other messages by a second micro-protocol. <p> Ensures that messages are delivered in a consistent total order on all sites. * Stability. Maintains information about whether a message is stable, i.e., known to be have been received by all functioning sites. The last three use an approach similar to that used in Psync <ref> [PBS89] </ref> and the Consul system [MPS93a]. In particular, messages sent to the progress group are stored in a context graph that maintains causality information about messages 26 i.e., the predecessors of a message m are those messages that the sender of m received before sending m.
Reference: [RBF + 95] <author> R. van Renesse, K. Birman, R. Friedman, M. Hayden, and D. Karr. </author> <title> A framework for protocol composition in Horus. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 80-89, </pages> <address> Ottawa, Canada, </address> <month> Aug </month> <year> 1995. </year>
Reference-contexts: The Horus/Ensemble project has also investigated a number of issues beyond those addressed in Coyote to date, including development of a theoretical framework based on Nuprl [CAB + 86] for reasoning about semantics, and investigation of techniques for optimizing data and control transfer between layered micro-protocols <ref> [HR97, RBF + 95, Ren96] </ref>. 3 Despite these similarities, however, there are a number of differences between our approach and that used for Horus and Ensemble.
Reference: [RBM96] <author> R. van Renesse, K. Birman, and S. Maffeis. Horus, </author> <title> a flexible group communication system. </title> <journal> Commun. of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: This paper describes Coyote, a system that supports the construction of highly modular and configurable versions of complex high-level protocols. Coyote extends the notion of protocol objects supported by systems such as Adaptive [SBS93], Horus/Ensemble <ref> [Hay98, RBM96] </ref>, and the x-kernel [HP91] to finer-grain modules called micro-protocols that implement individual properties of the target service as separate modules. For example, with atomic multicast, one micro-protocol might implement the consistent ordering requirements, while another might implement reliable transmission. <p> The developers of xAMP, a real-time atomic multicast protocol, report a similar experience [Fon94, VRB89]. The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus <ref> [RBM96] </ref>. <p> A number of other researchers and systems have addressed similar issues in a variety of contexts, including networking, fault tolerance in distributed systems, and distributed applications. This section outlines relevant work. 7.1 Horus and Ensemble Horus <ref> [RBM96] </ref> and Ensemble [Hay98] are successive generations of systems for constructing configurable distributed services based on the original ISIS system [BSS91]. As with Coyote, services in Horus and Ensemble are composed of combinations of software modulesalso called micro-protocolsthat allow different tradeoffs to be made regarding semantics and performance.
Reference: [Ren96] <author> R. van Renesse. </author> <title> Masking the overhead of protocol layering. </title> <booktitle> In Proceedings of ACM SIGCOMM '96, </booktitle> <pages> pages 96-104, </pages> <address> Palo Alto, CA, </address> <month> Aug </month> <year> 1996. </year>
Reference-contexts: This is similar to optimization techniques used in layered protocol architectures in which headers from multiple protocols are collected together and written in a single operation to avoid the performance overhead of multiple copies <ref> [AP93, Ren96] </ref>. Both 13 of these translation routines are supplied by the user and are invoked automatically by the framework at the appropriate time. Although coordinated sending is the expected norm, there are occasions when a particular micro-protocol might wish to send a message without another micro-protocol's interference or knowledge. <p> The Horus/Ensemble project has also investigated a number of issues beyond those addressed in Coyote to date, including development of a theoretical framework based on Nuprl [CAB + 86] for reasoning about semantics, and investigation of techniques for optimizing data and control transfer between layered micro-protocols <ref> [HR97, RBF + 95, Ren96] </ref>. 3 Despite these similarities, however, there are a number of differences between our approach and that used for Horus and Ensemble.
Reference: [RHB94] <author> R. van Renesse, T. Hickey, and K. Birman. </author> <title> Design and performance of Horus: A lightweight group communications system. </title> <type> Technical Report 94-1442, </type> <institution> Cornell University, Department of Computer Science, </institution> <month> Aug </month> <year> 1994. </year>
Reference-contexts: Events are also used for communication between micro-protocols in Ensemble, while the MUTS runtime system for Horus resembles the combination of the Coyote framework and x-kernel in the way it manages threads, provides multiple invocation options, and optimizes thread creation using procedure calls <ref> [RHB94] </ref>.
Reference: [Rit84] <author> D. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 311-324, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: This work, however, does lend credence to the claim that such fine-grain modularity can be introduced without sacrificing performance. System V Streams <ref> [Rit84] </ref> also supports modularization of protocols, but its model is also hierarchical and relatively coarse 33 grained. Several other efforts have concentrated on supporting parallel execution of modular protocols, including [GNI92, LAKS93].
Reference: [SBS93] <author> D. Schmidt, D. Box, and T. Suda. </author> <title> ADAPTIVE: A dynamically assembled protocol transformation, integration, and evaluation environment. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 5(4) </volume> <pages> 269-286, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: This paper describes Coyote, a system that supports the construction of highly modular and configurable versions of complex high-level protocols. Coyote extends the notion of protocol objects supported by systems such as Adaptive <ref> [SBS93] </ref>, Horus/Ensemble [Hay98, RBM96], and the x-kernel [HP91] to finer-grain modules called micro-protocols that implement individual properties of the target service as separate modules. For example, with atomic multicast, one micro-protocol might implement the consistent ordering requirements, while another might implement reliable transmission. <p> and high-level network 3 However, similar optimizations have been investigated in the context of the layered x-kernel model on which Coyote is based and its successor Scout system [AP93, MP96]. 32 protocols, while Horus and Ensemble are specific highly configurable instances of group communication services. 7.2 Adaptive The Adaptive system <ref> [SBS93] </ref> proposes a configurable and adaptive framework for building communication protocols for applications like multi-media that have special quality-of-service (QoS) requirements. The model used by Adaptive is based on dividing the communication service into functions, with each function being implemented by a chosen protocol object.
Reference: [Sch90] <author> F. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Stable tuple spaces in particular are implemented by replicating the TS on all participating sites and using the replicated state machine approach to maintain consistency <ref> [Sch90] </ref>. This requires a communication substrate that provides totally ordered atomic multicast, failure detection, and membership services for the process group implementing the TS. The Coyote micro-protocol suite realizing these requirements consists of a dozen micro-protocols implementing the following: * Membership.
Reference: [SESS96] <author> M. Seltzer, Y. Endo, C. Small, and K. Smith. </author> <title> Dealing with disaster: Surviving misbehaved kernel extensions. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating Design and Implementation (OSDI), </booktitle> <pages> pages 213-227, </pages> <address> Seattle, WA, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: These include Exokernel [EKO95], Scout [MP96], SLIC [GRPA97], SPIN [BSP + 95], and VINO <ref> [SESS96] </ref>, as well as work on subcontracts [HPM93] and application-controlled file caching [CFL94]. These projects attempt to increase the ability of users to configure different types of services, but for many aspects of operating system functionality rather than just the type of services considered here.
Reference: [SM94] <author> L. Sabel and K. Marzullo. </author> <title> Simulating fail-stop in asynchronous distributed systems. </title> <booktitle> In Proceedings of the 13th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 138-147, </pages> <publisher> Dana Point, </publisher> <address> CA, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: The relations may result from fundamental relations between the properties being implemented or from implementation choices made during the design process. For example, failure detection cannot be both live and accurate in asynchronous systems <ref> [FLP85, SM94] </ref>, so micro-protocols implementing these variants conflict based on their underlying properties. <p> For configurability, the key is designing a micro-protocol to minimize conflicts and dependencies with other micro-protocols, as discussed in section 2.6. As noted there, some of these relations are inherent in the properties being implementedthe conflict between accurate and live failure detection, for example <ref> [FLP85, SM94] </ref>but others are influenced by how the properties are implemented. Based on our experience, it is relatively easy to ensure that micro-protocol implementations preserve the independence of the corresponding properties.
Reference: [SR93] <author> A. Schiper and A. Ricciardi. </author> <title> Virtually-synchronous communication based on a weak failure suspector. </title> <booktitle> In Proceedings of the 23rd IEEE International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 534-543, </pages> <address> Toulouse, France, </address> <month> Jun </month> <year> 1993. </year>
Reference-contexts: As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches. Also in the area of fault-tolerance, a number of papers describe abstract properties of services or certain components such as failure detectors <ref> [Bla91, CT96, SR93] </ref>, or present families of related services [CASD85, WS95].
Reference: [SS94] <author> D. Schmidt and T. Suda. </author> <title> The service configurator framework: An extensible architecture for dynamically configuring concurrent, multi-service network deamons. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 190-201, </pages> <address> Pittsburgh, PA, </address> <month> Mar </month> <year> 1994. </year>
Reference-contexts: Configuration is based on automatic selection of library modules that satisfy user requirementsexpressed either at compile time or during executionand the status of the underlying network. The work has also been extended to support construction of configurable network daemons <ref> [SS94] </ref>. Compared to a function-based approach such as Adaptive, the approach used in Coyote is more flexible and more extensible.
Reference: [STW93] <author> B. Schilit, M. Theimer, and B. Welch. </author> <title> Customizing mobile applications. </title> <booktitle> In Proceedings of the USENIX Mobile and Location-Independent Computing Symposium, </booktitle> <pages> pages 129-138, </pages> <month> Aug </month> <year> 1993. </year>
Reference-contexts: This collection of micro-protocols can be used to built any number of custom communication services for mobile computing, including those with semantics similar to existing systems such as Crosspoint [CR94, CLR95], DataMan [AB93, BBIM93], InfoPad [LSBR94, LBSR95], and PARC TAB <ref> [AGSW93, STW93] </ref>. For example, Crosspoint combines ICMP for handoff detection, negative acknowledgments for effecting the handoff, and forwarding for disconnection, while PARC TAB combines a beacon strategy, agent-based handoff, and packet dropping. InfoPad includes QoS guarantees as well.
Reference: [Sun97] <institution> JavaBeans API Specification (version 1.01). Sun Microsystems, Mountain View, </institution> <address> CA, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: Examples include Microsoft's Component Object Model (COM) and Distributed Component Object Model (DCOM) [Mic95, BK98], Sun's JavaBeans <ref> [Sun97] </ref>, and OMG's Common Object Request Broker Architecture (CORBA) [OMG98]. While differing substantially in their details, all define an object specification and API that allow any object developed according to the specification to communicate with other compatible objects using the API.
Reference: [TMR96] <author> F. Travostino, E. Menze, and F. Reynolds. </author> <title> Paths: Programming with system resources in support of real-time distributed applications. </title> <booktitle> In Proceedings of the IEEE Workshop on Object-Oriented Real-Time Dependable Systems, </booktitle> <month> Feb </month> <year> 1996. </year>
Reference-contexts: Coyote and its associated micro-protocol suites are also currently being ported to a Pentium-based cluster running the Open Group Research Institute MK 7.3 operating system and CORDS, the x-kernel augmented with paths for resource allocation <ref> [TMR96] </ref>. The prototype differs somewhat from the model outlined in the previous sections, most importantly by not supporting event cancellation. A second C++ prototype that illustrates the generality of the approach is briefly discussed in section 6.1. 3.2 Framework 3.2.1 Uniform interfaces. <p> Many of our goals related to system customization, code reuse, and protocol configurability are adopted from the x-kernel. Armada [ASJS96] and OSF/RI MK <ref> [TMR96] </ref> extend the x-kernel model to support real-time, but with the same protocol object and composition model. Other x-kernel related work has explored the use of finer-grain protocol objects [OP92], but the emphasis there is on syntactic decomposition of higher-level protocols within a hierarchical framework.
Reference: [VRB89] <author> P. Verissimo, L. Rodrigues, and M. Baptista. </author> <title> Amp: A highly parallel atomic multicast protocol. </title> <booktitle> In Proceedings of SIGCOMM'89, </booktitle> <pages> pages 83-93, </pages> <address> Austin, TX, </address> <month> Sep </month> <year> 1989. </year>
Reference-contexts: The developers of xAMP, a real-time atomic multicast protocol, report a similar experience <ref> [Fon94, VRB89] </ref>. The lack of a sufficiently rich protocol object interface has also been cited as one of the motivations for developing Horus [RBM96].
Reference: [WS95] <author> U. Wilhelm and A. Schiper. </author> <title> A hierarchy of totally ordered multicasts. </title> <booktitle> In Proceedings of the 14th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 106-115, </pages> <address> Bad Neuenahr, Germany, </address> <month> Sept </month> <year> 1995. </year>
Reference-contexts: Also in the area of fault-tolerance, a number of papers describe abstract properties of services or certain components such as failure detectors [Bla91, CT96, SR93], or present families of related services <ref> [CASD85, WS95] </ref>.
Reference: [Yav92] <author> R. Yavantkar. MCP: </author> <title> A protocol for coordination and temporal synchronization in multimedia collaborative applications. </title> <booktitle> In Proceedings of the 12th IEEE Conference on Distributed Computing Systems, </booktitle> <pages> pages 606-613, </pages> <address> Yokohama, Japan, </address> <month> Jun </month> <year> 1992. </year>
Reference-contexts: Other abstractions of this type include group RPC [Che86, CGR88, Coo90], membership [Cri91, KGR91, MPS92], distributed transactions [BHG87], and protocols related to multimedia applications <ref> [KE93, Yav92] </ref>. Such abstractions logically form a distribution support layerthat is, a layer that provides execution guarantees regarding the distributed state of the applicationthat occupies a place in the system hierarchy fl This work supported in part by the Office of Naval Research under grants N00014-91-J-1015, N00014-94-1-0015, and N00014-96-0207.
Reference: [Yok92] <author> Y. Yokote. </author> <title> The Apertos reflective operating system: The concepts and its implementation. </title> <booktitle> In Proceedings of OOPSLA 1992, </booktitle> <pages> pages 414-434, </pages> <address> Vancouver, BC, </address> <month> Oct </month> <year> 1992. </year> <month> 40 </month>
Reference-contexts: In addition, our approach is related to recent work in configurable operating systems [BSP + 95, EKO95, HPM93, MMO + 94] and on the use of object-orientation and reflection to build customizable operating systems <ref> [MHM + 95, Yok92] </ref> and services for distributed systems [FP98]. 2 Two prototype versions of Coyote have been constructed, including one that augments the x-kernel's standard hierarchical object composition model with the ability to internally structure x-kernel protocol objects using micro-protocols. <p> In contrast to this framework, the approach used in Coyote is applicable beyond group communication systems and provides a more flexible model to the designer. Object-oriented structuring and the use of reflection to alter behavior in fault-tolerant distributed programs or general operating systems are described in <ref> [AS94, FP98, Yok92] </ref>. As demonstrated with the C++ prototype, our approach can also be mapped into an object-oriented paradigm, but is general enough to be implemented using more traditional approaches.
References-found: 85

