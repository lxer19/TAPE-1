URL: http://www.psrg.lcs.mit.edu/~james/thesis-final.ps
Refering-URL: http://www.psrg.lcs.mit.edu/~james/whoami.html
Root-URL: 
Title: Effective Information Sharing Using Update Logs  
Author: by James William O'Toole Jr. David K. Gifford 
Degree: (1989) Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy at the  Signature of Author Department of Electrical Engineering and Computer Science  Certified by  Professor of Computer Science Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology  
Date: (1984)  February 1996  1996  February 2, 1996  
Address: College Park  
Affiliation: B.S., University of Maryland at  S.M., Massachusetts Institute of Technology  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Guy T. Almes. </author> <title> Garbage Collection in a Object-Oriented System. </title> <type> Technical Report CMU-CS-80-128, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: Earlier descriptions of replicating garbage collection appear in work by O'Toole and Nettles [52, 49, 40, 41], and an instance of the basic technique is also described by Huelsbergen and Larus [25]. There is one earlier working implementation of a concurrent collector for a persistent heap. Almes <ref> [1] </ref> designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep 18 algorithm [18]. There are two key differences between this work and our own.
Reference: [2] <author> A. Appel. </author> <title> Simple Generational Garbage Collection and Fast Allocation. </title> <journal> Software-Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The purpose of the prototype implementation was to test the feasibility of this design. 52 Standard ML of New Jersey (SML/NJ) is an implementation of a type-safe program-ming language that includes an optimizing compiler, a runtime system, and a generational garbage collector <ref> [2] </ref>. The SML/NJ source code is freely available and is easy to modify for experimental purposes. I chose to test the replicating garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience.
Reference: [3] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: These collectors require the client to access the to-space version of an object 19 during collections and sometimes force objects to be copied so that the client may access them. The technique of Ellis, Li, and Appel <ref> [3] </ref> enforces this restriction by using virtual memory protection traps to detect certain client accesses and perform required collector work. In contrast, our technique does not constrain the order in which objects are copied nor does it require any special operating system support. <p> The collector only needs to replicate all the live data soon enough to terminate and reuse the memory in from-space before the application runs out of memory. In the algorithm of Appel, Ellis, and Li <ref> [3] </ref>, the application may frequently be blocked waiting for the collector to copy the objects that it must use. I believe that the flexibility of this invariant offers potentially important optimization opportunities to any replicating-style implementation. For example, the collector can copy objects in essentially any desired order. <p> The effects of replication are unobservable by the client, so it continues to operate on the original objects in from-space. This differs from other concurrent compacting collection algorithms, which require the client to operate on objects in to-space <ref> [5, 3] </ref>. Because the client and the collector execute concurrently, the replicas become inconsistent when the client modifies the original objects. To solve this problem, the client records all write operations in a redo log, shown in Figure 3-4.
Reference: [4] <author> M. P. Atkinson, K. J. Chisolm, and W. P. Cockshott. </author> <title> PS-Algol: an Algol with a persistent heap. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol <ref> [4] </ref> and Argus [34]. Earlier descriptions of replicating garbage collection appear in work by O'Toole and Nettles [52, 49, 40, 41], and an instance of the basic technique is also described by Huelsbergen and Larus [25]. There is one earlier working implementation of a concurrent collector for a persistent heap. <p> No deallocation operation is exposed to the clients. Instead, objects that the clients can access by dereferencing pointers starting from either root are considered live and will be preserved by the system. A garbage collector will identify unreachable objects and recycle their storage. The heap interface provides orthogonal persistence <ref> [4] </ref>: objects that are reachable via the persistent root are guaranteed to survive system failures. In Figure 3-3, the stability of the persistent root and the stable heap to which it points are indicated by their gray background.
Reference: [5] <author> H. G. Baker. </author> <title> List Processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: Although it would be interesting to compare the hybrid log housekeeping system with replicating garbage collection in spite of these differences, I believe the snapshot-based concurrent housekeeping algorithm was not implemented [48]. There is a long history of incremental and concurrent copying collectors dating back to Baker <ref> [5] </ref>. These collectors require the client to access the to-space version of an object 19 during collections and sometimes force objects to be copied so that the client may access them. <p> The effects of replication are unobservable by the client, so it continues to operate on the original objects in from-space. This differs from other concurrent compacting collection algorithms, which require the client to operate on objects in to-space <ref> [5, 3] </ref>. Because the client and the collector execute concurrently, the replicas become inconsistent when the client modifies the original objects. To solve this problem, the client records all write operations in a redo log, shown in Figure 3-4.
Reference: [6] <author> Brian N. Bershad and C. Brian Pinkerton. Watchdogs: </author> <title> Extending the UNIX file system. </title> <booktitle> In USENIX Association 1988 Winter Conference Proceedings, </booktitle> <pages> pages 267-275, </pages> <address> Dallas, Texas, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: process file system [29], enabling process observation and control via file operations. * Services appear as special directories in Plan 9 [57], enabling service access in a distributed system through file system operations in the service's name space. * Arbitrary semantics can be associated with files and directories using Watchdogs <ref> [6] </ref>, Pseudo Devices [75], and Filters [43], enabling file system extensions such as terminal drivers, network protocols, X servers, file access control, file compression, mail notification, user specific directory views, heterogeneous file access, and service access. * The ATTIC system [8] uses a modified NFS server to provide transparent access to
Reference: [7] <author> Brent Callaghan and Tom Lyon. </author> <booktitle> The automounter. In USENIX Association 1989 Winter Conference Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: [59] in the /dev directory, enabling them to be used as ordinary files from UNIX applications. 17 * UNIX System III named pipes [60, p. 159f] appear as special files, enabling pro- grams to rendezvous using file system operations. * File systems appear as special directories in Automount daemon directories <ref> [7, 54, 55] </ref>, enabling the binding of a name to a file system to be computed at the time of reference. * Processes appear as special directories in Killian's process file system [29], enabling process observation and control via file operations. * Services appear as special directories in Plan 9 [57],
Reference: [8] <author> Vincent Cate and Thomas Gross. </author> <title> Combining the concepts of compression and caching for a two-level filesystem. </title> <booktitle> In Fourth International Conference on Architec 80 tural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 200-211, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: semantics can be associated with files and directories using Watchdogs [6], Pseudo Devices [75], and Filters [43], enabling file system extensions such as terminal drivers, network protocols, X servers, file access control, file compression, mail notification, user specific directory views, heterogeneous file access, and service access. * The ATTIC system <ref> [8] </ref> uses a modified NFS server to provide transparent access to automatically compressed files. 1.7.2 Garbage Collection The basic literature on uniprocessor garbage collection techniques is surveyed by Wil-son [76]. Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [34].
Reference: [9] <author> R. G. G. Cattell. </author> <title> An Engineering Database Benchmark. </title> <editor> In Jim Gray, editor, </editor> <booktitle> The Benchmark Handbook for Database and Transaction Processing Systems, </booktitle> <pages> pages 247-281. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: This 100,000 line program is compute-intensive and contains long-running transactions. * The TP-OO1-V benchmark is a variant of the OO1 Engineering Database benchmark described by Cattell <ref> [9] </ref>. The benchmark models an engineering application using a database of parts, performing traversals of the database, adding parts, etc. I implemented this algorithm in order to have a representative object-oriented 64 database application.
Reference: [10] <author> CCITT. </author> <title> The Directory Overview of Concepts, Models and Services. Recommendation X.500, </title> <year> 1988. </year>
Reference-contexts: NSE is a network transparent software development tool that allows different views of a file system hierarchy called environments to be defined. Unlike virtual directories, these views must be explicitly created before being accessed. * Wide-area naming systems such as X.500 <ref> [10] </ref>, Profile [56], and the Networked Resource Discovery Project [64] provide attribute-based access to a wide variety of objects, but they are not integrated into a file system nor do they provide automatic attribute-based access to the contents of a file system. 1.7.1 File System Extensions Previous research supports the view <p> This could permit access by time, frame number, or content. * The entities indexed by a semantic file system could include a wide variety of object types, including I/O devices and file servers. Wide-area naming systems such as X.500 <ref> [10] </ref> could be presented in terms of virtual directories. 2.2 An NFS Implementation I have built a semantic file system that implements the NFS [62, 71] protocol as its external interface.
Reference: [11] <institution> Claris Corporation, </institution> <address> Santa Clara, California, </address> <month> January </month> <year> 1990. </year> <title> News Release. </title>
Reference-contexts: These systems all create indexes to reduce search time. On Location automatically indexes files in the background, while Magellan and the Digital Librarian require users to explicitly create indexes. Both On Location and the Digital Librarian permit users to add appropriate keyword generation programs <ref> [11, 45] </ref> to index new types of files.
Reference: [12] <author> Eric Cooper, Scott Nettles, and Indira Subramanian. </author> <title> Improving the Performance of SML Garbage Collection using Application-Specific Virtual Memory Management. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 43-52, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It would be much more efficient to discard these log records instead. Garbage collectors sometimes benefit from similar features in data caches and virtual memory systems <ref> [12] </ref>. When the garbage collector reclaims a semi-space it is better that cache lines and virtual memory pages that contain reclaimed data be reset to a zero-fill-on-demand status because there is no need for the underlying memory system to preserve their old contents.
Reference: [13] <author> Lotus Corporation. </author> <title> Lotus Magellan: Quick Launch. Product tutorial, </title> <publisher> Lotus Corporation, </publisher> <address> Cambridge, Massachusetts. Part number 35115. </address>
Reference-contexts: The previous research includes work on personal computer indexing 15 systems, information retrieval systems, distributed file systems, new naming models for file systems, and wide-area naming systems: * Personal computer indexing systems such as On Location [72], Magellan <ref> [13] </ref>, and the Digital Librarian [45, 44] provide window-based file system browsers that permit word-based associative access to file system contents. Magellan and the Digital Librarian permit searches based upon boolean combinations of words, while On Location is limited to conjunctions of words.
Reference: [14] <editor> Transactions Processing Council. TPC-B. In Jim Gray, editor, </editor> <booktitle> The Benchmark Handbook for Database and Transaction Processing Systems, </booktitle> <pages> pages 79-114. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: This benchmark is a slightly non standard implementation in Standard ML of the TPC-B benchmark from Gray <ref> [14] </ref>. 3.5.2 Experimental Setup All benchmarks were executed on a Silicon Graphics 4D/340 equipped with 256 megabytes of physical memory. The clock resolution on this system is 1 millisecond. The machine contains four MIPS R3000 processors clocked at 33 megahertz.
Reference: [15] <author> P. B. Danzig et al. </author> <title> Distributed indexing: A scalable mechanism for distributed information retrieval. </title> <type> Technical Report USC-TR 91-06, </type> <institution> University of Southern Cal-ifornia, Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: The WAIS system permits information at remote sites to be queried, but relies upon the user to choose an appropriate remote host from a directory of services [27, 68]. Distributed information retrieval systems <ref> [21, 15] </ref> perform query routing based upon database content labels to ensure that all relevant hosts are contacted in response to a query. * Distributed file systems [71, 28] provide remote access to files with tree structured names.
Reference: [16] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs [17] described how to apply this algorithm in the transactional environment of Avalon/C++ <ref> [16] </ref>, while Kolodner [31] worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence.
Reference: [17] <author> David L. Detlefs. </author> <title> Concurrent, atomic garbage collection. </title> <type> Technical Report CMU-CS-90-177, </type> <institution> Carnegie Mellon University, </institution> <month> October </month> <year> 1990. </year> <month> 81 </month>
Reference-contexts: I believe that the ability to freely choose the traversal order may be especially important in systems that need to optimize disk access costs. There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs <ref> [17] </ref> described how to apply this algorithm in the transactional environment of Avalon/C++ [16], while Kolodner [31] worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence.
Reference: [18] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Steffens. </author> <title> On-the-fly Garbage Collection:An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: There is one earlier working implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep 18 algorithm <ref> [18] </ref>. There are two key differences between this work and our own. First, it cannot relocate objects and therefore offers no opportunities for heap compaction or clustering of objects for fast access.
Reference: [19] <author> John R. Ellis, Kai Li, and Andrew W. Appel. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <type> Technical Report DEC-SRC-TR-25, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The collector could choose to concentrate early replication effort on only immutable objects, and thereby delay the need to process the log until the last possible moment. The actual copying of an object can be delayed until the object is scanned using an optimization suggested by Ellis <ref> [19] </ref>. The collector could replicate mutable objects into a segregated portion of the to-space, and delay copying and scanning mutable objects as long as possible.
Reference: [20] <author> Ferdinando Gallo, Regis Minot, and Ian Thomas. </author> <title> The object management system of PCTE as a software engineering database management system. </title> <booktitle> In Second ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 12-15. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: Existing UNIX tools such as grep and find [23] are often used to perform associative searches in distributed file systems. 16 * New naming models for file systems include the Portable Common Tool Envi--ronment (PCTE) <ref> [20] </ref>, the Property List DIRectory system (PLDIR) [37], Virtual Systems [43] and Sun's Network Software Environment (NSE) [69]. PCTE provides an entity-relationship database that models the attributes of objects including files. PCTE has been implemented as a compatible extension to UNIX.
Reference: [21] <author> David K. Gifford, Robert G. Cote, and David A. Segal. </author> <title> Walter user's manual. </title> <type> Technical Report MIT/LCS/TR-399, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: User interfaces based upon browsers [26, 73] have proven to be effective for query-based access to information, and browsers could also be provided by semantic file system implementations. Application programming interfaces that permit remote access include specialized protocols for information retrieval [46], and remote procedure call based interfaces <ref> [21] </ref>. It is also possible to export the facilities of a semantic file system without introducing any new interfaces. This can be accomplished by extending the naming semantics of files and directories to support associative access. <p> The WAIS system permits information at remote sites to be queried, but relies upon the user to choose an appropriate remote host from a directory of services [27, 68]. Distributed information retrieval systems <ref> [21, 15] </ref> perform query routing based upon database content labels to ensure that all relevant hosts are contacted in response to a query. * Distributed file systems [71, 28] provide remote access to files with tree structured names.
Reference: [22] <author> David K. Gifford, Pierre Jouvelot, Mark A. Sheldon, and James W. O'Toole. </author> <title> Semantic file systems. </title> <booktitle> In Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 16-25. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year> <title> Available as Operating Systems Review Volume 25, Number 5. </title>
Reference-contexts: At the same time, I redefined the transducer interfaces and reimplemented portions of the indexing and server systems to obtain performance that was tolerable for daily use in our research group. Dave, Mark, Pierre and I co-authored a paper describing SFS <ref> [22] </ref>, and I've used that paper with only minor changes to report on SFS in Chapter 2 of this dissertation.
Reference: [23] <institution> Computer Systems Research Group. </institution> <note> UNIX User's Reference Manual. </note> <institution> 4.3 Berkeley Software Distribution, Berkeley, California, </institution> <month> April </month> <year> 1986. </year> <note> Virtual VAX-11 Version. </note>
Reference-contexts: These systems have enabled file sharing among groups of people and over wide geographic areas. Existing UNIX tools such as grep and find <ref> [23] </ref> are often used to perform associative searches in distributed file systems. 16 * New naming models for file systems include the Portable Common Tool Envi--ronment (PCTE) [20], the Property List DIRectory system (PLDIR) [37], Virtual Systems [43] and Sun's Network Software Environment (NSE) [69].
Reference: [24] <author> Olivier Gruber. Eos: </author> <title> An Environment for Persistent and Distributed Applications in a Shared Object Space. host ftp.inria.fr directory INRIA/Projects/RODIN file Olivier.Gruber.phd.ps.Z, </title> <month> December </month> <year> 1992. </year>
Reference-contexts: Because of the rather unusual environment in which it operated, we cannot make any performance comparison between it and our work. There is recent work ongoing in the EOS system <ref> [24] </ref>. The EOS design proposes to combine a marking process and a compaction process. An implementation of EOS is underway but details are not available at this time. Brian Oki designed the Hybrid Log storage organization for Argus [35].
Reference: [25] <author> Lorenz Huelsbergen and James R. Larus. </author> <title> A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data. </title> <booktitle> In Proceedings of the 1993 ACM Symposiym on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year> <month> 82 </month>
Reference-contexts: Earlier descriptions of replicating garbage collection appear in work by O'Toole and Nettles [52, 49, 40, 41], and an instance of the basic technique is also described by Huelsbergen and Larus <ref> [25] </ref>. There is one earlier working implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep 18 algorithm [18].
Reference: [26] <institution> Information Dimensions, Inc. </institution> <month> BASISplus. </month> <title> The Key To Managing The World Of Information. Information Dimensions, </title> <publisher> Inc., </publisher> <address> Dublin, Ohio, </address> <year> 1990. </year> <title> Product description. </title>
Reference-contexts: For example, files can be located based upon transducer-generated attributes such as author, exported or imported procedures, words contained, type, and title. A semantic file system provides both a user interface and an application programming interface to its associative access facilities. User interfaces based upon browsers <ref> [26, 73] </ref> have proven to be effective for query-based access to information, and browsers could also be provided by semantic file system implementations. Application programming interfaces that permit remote access include specialized protocols for information retrieval [46], and remote procedure call based interfaces [21]. <p> Both On Location and the Digital Librarian permit users to add appropriate keyword generation programs [11, 45] to index new types of files. However, Magellan, On Location, and the Digital Librarian are limited to a list of words for file description. * Information retrieval systems such as Basis <ref> [26] </ref>, Verity [73], and Boss DMS [36] extend the semantics of personal computer indexing systems by adding field specific queries. Fields that can be queried include document category, author, type, title, identifier, status, date, and text contents.
Reference: [27] <author> Brewster Kahle and Art Medlar. </author> <title> An information system for corporate users: Wide Area Information Servers. </title> <type> Technical Report TMC-199, </type> <institution> Thinking Machines, Inc., </institution> <month> April </month> <year> 1991. </year> <note> Version 3. </note>
Reference-contexts: The WAIS system permits information at remote sites to be queried, but relies upon the user to choose an appropriate remote host from a directory of services <ref> [27, 68] </ref>. Distributed information retrieval systems [21, 15] perform query routing based upon database content labels to ensure that all relevant hosts are contacted in response to a query. * Distributed file systems [71, 28] provide remote access to files with tree structured names.
Reference: [28] <author> Michael Leon Kazar. </author> <title> Synchronization and caching issues in the Andrew File System. </title> <booktitle> In USENIX Association Winter Conference Proceedings, </booktitle> <pages> pages 31-43, </pages> <year> 1988. </year>
Reference-contexts: Because semantic file systems are compatible with existing tree structured file systems, implementations of semantic file systems can be fully compatible with existing network file system protocols such as NFS [62, 70] and AFS <ref> [28] </ref>. NFS compatibility permits existing client machines to use the indexing and associative access features of a semantic file system without modification. Files stored in a semantic file system via NFS will be indexed automatically and query result sets will appear as virtual directories in the NFS name space. <p> Distributed information retrieval systems [21, 15] perform query routing based upon database content labels to ensure that all relevant hosts are contacted in response to a query. * Distributed file systems <ref> [71, 28] </ref> provide remote access to files with tree structured names. These systems have enabled file sharing among groups of people and over wide geographic areas. <p> the extension c: % cd /sfs/exports:/lookup_fault % ls -F virtdir_query.c@ virtdir_query.o@ % cd ext:/c virtdir_query.c@ % Because semantic file systems are compatible with existing tree structured file systems, implementations of semantic file systems can be fully compatible with existing network file system protocols such as NFS [62, 70] and AFS <ref> [28] </ref>. NFS compatibility permits existing client machines to use the indexing and associative access features of a semantic file system without modification.
Reference: [29] <author> T. J. Killian. </author> <title> Processes as files. </title> <booktitle> In USENIX Association 1984 Summer Conference Proceedings, </booktitle> <address> Salt Lake City, Utah, </address> <year> 1984. </year>
Reference-contexts: grams to rendezvous using file system operations. * File systems appear as special directories in Automount daemon directories [7, 54, 55], enabling the binding of a name to a file system to be computed at the time of reference. * Processes appear as special directories in Killian's process file system <ref> [29] </ref>, enabling process observation and control via file operations. * Services appear as special directories in Plan 9 [57], enabling service access in a distributed system through file system operations in the service's name space. * Arbitrary semantics can be associated with files and directories using Watchdogs [6], Pseudo Devices [75],
Reference: [30] <author> S. R. Kleiman. Vnodes: </author> <title> An architecture for multiple file system types in Sun UNIX. </title> <booktitle> In USENIX Association 1986 Winter Conference Proceedings, </booktitle> <pages> pages 238-247, </pages> <year> 1986. </year>
Reference-contexts: The file server process could be integrated into the kernel by a VFS based implementation <ref> [30] </ref> of an semantic file system. I implemented the prototype system using a user level NFS server to simplify development.
Reference: [31] <author> Eliot K. Kolodner. </author> <title> Atomic Incremental Garbage Collection and Recovery for a Large Stable Heap. </title> <type> Technical Report MIT/LCS/TR-534, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs [17] described how to apply this algorithm in the transactional environment of Avalon/C++ [16], while Kolodner <ref> [31] </ref> worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence.
Reference: [32] <institution> Legato Systems, Inc. Nhfsstone. Software package. Legato Systems, Inc., Palo Alto, California, </institution> <year> 1989. </year>
Reference-contexts: To determine the increased latency of overlaid NFS operations introduced by interposing my SFS server between the client and the native file system, I used the nhfsstone benchmark <ref> [32] </ref> at low loads. The delays observed from an unmodified client machine were smaller than the variation in latencies of the native NFS operations.
Reference: [33] <author> M. E. Lesk. </author> <title> Some applications of inverted indexes on the UNIX system. UNIX Supplementary Document, </title> <type> Section 30. </type>
Reference-contexts: If no special transducer is found a default transducer is used. The output of the transducer is fed to the Indexer module that inserts the computed attributes into the index. Indexing and retrieval are based upon Peter Weinberger's BTree package [74] and an adapted version of the refer <ref> [33] </ref> software to maintain the mappings between attributes and objects. * The mount daemon is contacted to determine the root file handle of the underlying UNIX file system.
Reference: [34] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 382-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus <ref> [34] </ref>. Earlier descriptions of replicating garbage collection appear in work by O'Toole and Nettles [52, 49, 40, 41], and an instance of the basic technique is also described by Huelsbergen and Larus [25]. There is one earlier working implementation of a concurrent collector for a persistent heap.
Reference: [35] <author> Barbara H. Liskov. </author> <title> Overview of the argus language and system. </title> <type> Technical Report Programming Methodology Group Memo 40, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1984. </year> <month> 83 </month>
Reference-contexts: There is recent work ongoing in the EOS system [24]. The EOS design proposes to combine a marking process and a compaction process. An implementation of EOS is underway but details are not available at this time. Brian Oki designed the Hybrid Log storage organization for Argus <ref> [35] </ref>. Oki [47] described two possible housekeeping (compaction) methods for the Hybrid Log, one based on a copying collection of the old log to produce a new log, the other based on a copying collection of the stable state.
Reference: [36] <author> Boss Logic, Inc. </author> <title> Boss DMS development specification. Technical documentation, Boss Logic, </title> <publisher> Inc., Fairfield, </publisher> <address> IA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: However, Magellan, On Location, and the Digital Librarian are limited to a list of words for file description. * Information retrieval systems such as Basis [26], Verity [73], and Boss DMS <ref> [36] </ref> extend the semantics of personal computer indexing systems by adding field specific queries. Fields that can be queried include document category, author, type, title, identifier, status, date, and text contents.
Reference: [37] <author> Jeffrey C. Mogul. </author> <title> Representing information about files. </title> <type> Technical Report 86-1103, </type> <institution> Stanford Univ. Department of CS, </institution> <month> March </month> <year> 1986. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: Existing UNIX tools such as grep and find [23] are often used to perform associative searches in distributed file systems. 16 * New naming models for file systems include the Portable Common Tool Envi--ronment (PCTE) [20], the Property List DIRectory system (PLDIR) <ref> [37] </ref>, Virtual Systems [43] and Sun's Network Software Environment (NSE) [69]. PCTE provides an entity-relationship database that models the attributes of objects including files. PCTE has been implemented as a compatible extension to UNIX. <p> The Property List DIRectory system implements a file system model designed around file properties and offers a Unix front-end user interface. Similarly, Virtual Systems permit users to hand-craft customized views of services, files, and directories. However, neither system provides automatic attribute extraction (although <ref> [37] </ref> alludes to it as a possible extension) or attribute-based access to their contents. NSE is a network transparent software development tool that allows different views of a file system hierarchy called environments to be defined.
Reference: [38] <author> Scott M. Nettles. </author> <title> Safe and Efficient Persistent Heaps. </title> <type> Technical Report CMU-CS-95-225, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: Scott and I each reimplemented the log-processing module at least once, and made essentially all implementation decisions jointly. We conceived a large number of additional optimizations, one of which we reported together [39], and many of which Scott subsequently explored in his Ph.D. dissertation <ref> [38] </ref>. Later, Scott modified the concurrent garbage collector's convergence strategy to improve pause time performance, and we collaborated on a paper explaining some implementation details of the concurrent collector [52].
Reference: [39] <author> Scott M. Nettles and James W. O'Toole. </author> <title> Implementing Orthogonal Persistence: </title>
Reference-contexts: Scott and I each reimplemented the log-processing module at least once, and made essentially all implementation decisions jointly. We conceived a large number of additional optimizations, one of which we reported together <ref> [39] </ref>, and many of which Scott subsequently explored in his Ph.D. dissertation [38]. Later, Scott modified the concurrent garbage collector's convergence strategy to improve pause time performance, and we collaborated on a paper explaining some implementation details of the concurrent collector [52].
References-found: 39

