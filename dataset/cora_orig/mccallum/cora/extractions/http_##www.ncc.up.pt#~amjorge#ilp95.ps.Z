URL: http://www.ncc.up.pt/~amjorge/ilp95.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/publications.html
Root-URL: 
Email: email: -amjorge,pbrazdil-@ncc.up.pt  
Phone: tel. (+351) 2 600 16 72, fax. (+351) 2 600 36 54  
Title: Architecture for Iterative Learning of Recursive Definitions  
Author: Alpio Jorge and Pavel Brazdil 
Address: Portugal  
Affiliation: LIACC-University of Porto Rua do Campo Alegre, 823, 4150 PORTO  
Abstract: In this paper we are concerned with the problem of inducing recursive Horn clauses from small sets of training examples. The method of iterative bootstrap induction is presented. In the first step, the system generates simple clauses, which can be regarded as properties of the required definition. Properties represent generalizations of the positive examples, simulating the effect of having larger number of examples. Properties are used subsequently to induce the required recursive definitions. This paper describes the method together with a series of experiments. The results support the thesis that iterative bootstrap induction is indeed an effective technique that could be of general use in ILP. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aha D W, Lapointe S, Ling C X, </author> <title> Matwin S (1994): Inverting Implication with Small Training Set, </title> <booktitle> in Proceedings of the European Conference on Machine Learning, ECML 94, </booktitle> <editor> ed. F. Bergadano and L De Raedt, </editor> <publisher> Springer Verlag. </publisher>
Reference-contexts: Small sets of examples tend to be incomplete making recursive clauses hard to induce. Thus it is crucial to develop inductive strategies that generate recursive definitions from small sets of examples. Several solutions have been proposed (e.g. <ref> [1] </ref>, [8], [10]). The solution described in [1], and incorporated in CRUSTACEAN , exploits common substructures in the examples. Although encouraging results have been achieved, the method seems to be difficult to extend and integrate into a general purpose inductive system. <p> Small sets of examples tend to be incomplete making recursive clauses hard to induce. Thus it is crucial to develop inductive strategies that generate recursive definitions from small sets of examples. Several solutions have been proposed (e.g. <ref> [1] </ref>, [8], [10]). The solution described in [1], and incorporated in CRUSTACEAN , exploits common substructures in the examples. Although encouraging results have been achieved, the method seems to be difficult to extend and integrate into a general purpose inductive system. <p> Then we have proceeded with experiments where the examples were sampled randomly. The predicates chosen for these experiments ranged from simple ones like member/2 to more complicated predicates like qsort/2 or union/2. 3.1 Manually selected example sets Following a similar demonstration in <ref> [1] </ref>, we provided SKILit with small sets of manually chosen positive and negative examples of 10 predicates, namely append/3, member/2, delete/3, noneiszero/1, plus/3, extractNth/3, factorial/2, rv/2, last_of/2, and split/3. Furthermore, we tried to generate the definitions of insertion sort (isort/2) and quick sort (qsort/2). <p> For that, we generated positive and negative examples randomly and ran SKILit with that input. The theories generated were evaluated on independent test sets. For the generation of random positive examples we followed the evaluation methodology described in <ref> [1] </ref>. For each predicate we sampled positive examples from a universe of facts involving lists and peano integers (like s (s (0))). The depth of those terms varies from 0 to 4 with uniform distribution. <p> It is difficult to foresee how RTL would behave with small random training samples, as no such experiments were reported in [7]. However, we believe that RTL would not perform particularly well, because of its dependence on FOIL-like gain heuristic. The system CRUSTACEAN <ref> [1] </ref> uses a quite different strategy. It looks for common decomposition of the arguments of pairs of positive examples. Each possible decomposition suggests a candidate recursive theory. One disadvantage of CRUSTACEAN is that the concept language is highly restricted. <p> In addition, the search is constrained by program structure schemata. These are expressed using definite clause grammars (DCG). The main advantage of iterative bootstrap induction is that it does not rely on analysis of term structure alone. This is, in our view, a disadvantage of other approaches (e.g. <ref> [1] </ref>). The regularities within the positive examples are expressed in terms of the available background knowledge. This language is richer than in [1], enabling us to handle larger classes of problems. <p> This is, in our view, a disadvantage of other approaches (e.g. <ref> [1] </ref>). The regularities within the positive examples are expressed in terms of the available background knowledge. This language is richer than in [1], enabling us to handle larger classes of problems.
Reference: [2] <author> Baroglio C, </author> <title> Giordana A, Saitta L (1992):Learning Mutually Dependent Relations in Journal of Intelligent Information Systems 1 , pp. </title> <address> 159-176, </address> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston. </address>
Reference-contexts: The solution presented here corrects this problem. We believe that this is why SKILit obtained good results on very small example sets. System RTL (Baroglio et al. <ref> [2] </ref>, Giordana et al. [7]), employs also an iterative method for the induction of recursive definitions. In the first step the system generates auxiliary non-recursive definitions of the target predicate. In the subsequent step these definitions are transformed into recursive ones. <p> In the first step the system generates auxiliary non-recursive definitions of the target predicate. In the subsequent step these definitions are transformed into recursive ones. It is difficult to say how the system would behave with random samples. The experiments described in <ref> [2] </ref> and [7] were very limited. However, as the construction of clauses in RTL is guided using a kind of FOIL-like gain heuristic, we have reasons to believe that RTL would not perform as well as SKILit on small samples. This paper is organized as follows.
Reference: [3] <author> Brazdil P, </author> <title> Jorge A (1992): Modular Approach to ILP: Learning from interaction between Modules. </title> <booktitle> ECAI 92, Logical Approaches to Machine Learning, Workshop notes. </booktitle>
Reference: [4] <author> Brazdil P, </author> <title> Jorge A (1994): Learning by Refining Algorithm Sketches, </title> <booktitle> in Proceedings of ECAI-94 , T. </booktitle> <editor> Cohn (ed.), </editor> <address> Amsterdam, The Netherlands. </address>
Reference-contexts: In each step a tentative theory is produced which can be reused in the next cycle of the induction process. If certain stopping criteria are satisfied, the process terminates. The implemented system which incorporates this method is called SKILit. The subsystem that constructs clauses is called SKIL <ref> [4] </ref>. Let us see how SKILit generates a definition of member/2 on the basis of the two positive examples shown in Table 1. Let us assume that the appropriate negative examples and background knowledge have also been given. <p> As most systems of this kind, it proceeds by refining the set of candidate clauses. Here, the clause to be refined is referred to as the sketch clause. This terminology is used for the following reasons. In <ref> [4] </ref> we have argued that we should be able to guide the process of induction. One way of doing this is by providing algorithm sketches. SKIL was designed to accept such sketches.
Reference: [5] <author> Cohen W W (1993): </author> <title> Rapid prototyping of ILP systems using explicit bias in Proceedings of 1993 IJCAI Workshop on ILP. </title>
Reference-contexts: The system performs a kind of relational pathfinding similar to [ 11 ] which we think is particularly suited for this task. The search for a clause is, in addition, constrained by means of a definite clause grammar (DCG), in some ways similar to <ref> [5] </ref>. Extensive experiments were carried out with the system that implements this method. Special attention was paid to the problem of synthesis of recursive definitions from small sets of positive examples generated at random. Overall results were good. <p> We have tried to capture this kind of knowledge and express it using a definite clause grammar (DCG). The approach is similar to <ref> [5] </ref>. Our grammar defines, in the first place, different groups (types) of literals. The first group decomposes certain arguments in the clause head into subterms (using predicates like dest/3 separating a list into its head and tail). The second group enables to introduce recursive calls. <p> Similar rules define the base clause. Our rules do not constrain the arguments of literals. They simply define acceptable sequences of predicates that can appear in a clause. This has the advantage that the rules are easier to define than those used in <ref> [5] </ref>. The clause structure grammar enables us to define the suitable language bias. The method is rather powerful. The same grammar covers a wide class of predicate definitions. In fact, the grammar shown (in part) above was used in all the experiments described in this paper without modification.
Reference: [6] <author> De Raedt L, </author> <title> Lavrac N, </title> <booktitle> Dzeroski S (1993):Multiple Predicate Learning in Proceedings of IJCAI-93 , Chamberry, </booktitle> <address> France. </address>
Reference-contexts: One area we have been concerned with is the synthesis of mutually dependent clauses. In one of the experiments carried out, the system was given small sets of examples of even/2 and odd/2, which are mutually dependent. Unlike in <ref> [ 6 ] </ref> the knowledge concerning the dependency was simply given (i.e. even/2 could call odd/2). SKILit generated the following correct definitions: even (A) :- pred (A,B), odd (B). odd (A) :- pred (A,B), zero (B). even (A) :- zero (A). odd (A) :- pred (A,B), pred (B,C), odd (C).
Reference: [7] <author> Giordana A, </author> <title> Saitta L, </title> <booktitle> Baroglio C (1993):Learning Simple Recursive Theories in Proceedings of the 7th International Symposium, ISMIS93 , Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The solution presented here corrects this problem. We believe that this is why SKILit obtained good results on very small example sets. System RTL (Baroglio et al. [2], Giordana et al. <ref> [7] </ref>), employs also an iterative method for the induction of recursive definitions. In the first step the system generates auxiliary non-recursive definitions of the target predicate. In the subsequent step these definitions are transformed into recursive ones. It is difficult to say how the system would behave with random samples. <p> In the first step the system generates auxiliary non-recursive definitions of the target predicate. In the subsequent step these definitions are transformed into recursive ones. It is difficult to say how the system would behave with random samples. The experiments described in [2] and <ref> [7] </ref> were very limited. However, as the construction of clauses in RTL is guided using a kind of FOIL-like gain heuristic, we have reasons to believe that RTL would not perform as well as SKILit on small samples. This paper is organized as follows. <p> For that reason, the probability that a recursive clause is generated in a given iteration is higher than in the previous ones. It is important to note that this strategy is still more efficient than generating all possible recursive literals. The systems CHILLIN [12] and RTL <ref> [7] </ref> use somewhat similar iterative strategies that attempt to solve the problem of inducing recursion from incomplete examples sets. However, there are some significant differences between these approaches and the method described here. The system CHILLIN initiates the clause construction using the bottom-up operation of LGG. <p> Although SKILit may quite often generate non-recursive definitions first, it is not forced to, if enough data is available. It is difficult to foresee how RTL would behave with small random training samples, as no such experiments were reported in <ref> [7] </ref>. However, we believe that RTL would not perform particularly well, because of its dependence on FOIL-like gain heuristic. The system CRUSTACEAN [1] uses a quite different strategy. It looks for common decomposition of the arguments of pairs of positive examples. Each possible decomposition suggests a candidate recursive theory.
Reference: [8] <institution> Idestam-Almquist P (1993) Generalization under implication by recursive anti unification, in Proceedings of ILP-93 , Jozef Stefan Institute, </institution> <type> technical report. </type>
Reference-contexts: Small sets of examples tend to be incomplete making recursive clauses hard to induce. Thus it is crucial to develop inductive strategies that generate recursive definitions from small sets of examples. Several solutions have been proposed (e.g. [1], <ref> [8] </ref>, [10]). The solution described in [1], and incorporated in CRUSTACEAN , exploits common substructures in the examples. Although encouraging results have been achieved, the method seems to be difficult to extend and integrate into a general purpose inductive system.
Reference: [9] <author> Michalski R S, </author> <title> (1994):Inferential Theory of Learning: Developing Foundations for Multistrategy Learning, in Machine Learning, A Multistrategy Approach, </title> <editor> Volume IV , ed.by Ryszard Michalski and Gheorghe Tecuci, </editor> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: In this paper we investigate another method called iterative bootstrap induction, which represents an alternative approach to this problem, and implement it as the system SKILit. The method of iterative bootstrap induction can be seen as an adaptation of closed-loop learning strategy <ref> [9] </ref> to the problem of induction of recursive definitions. The induced clauses are reused in order to facilitate the induction of new, more general, clauses. The system performs a kind of relational pathfinding similar to [ 11 ] which we think is particularly suited for this task. <p> Section 4 describes our experiments oriented towards generation of recursive definitions and the results. The last section concludes the paper. 2. Iterative Bootstrap Induction The method of iterative bootstrap induction can be seen as an adaptation of closed loop learning <ref> [9] </ref>. It constructs theories in a stepwise manner. In each step a tentative theory is produced which can be reused in the next cycle of the induction process. If certain stopping criteria are satisfied, the process terminates. The implemented system which incorporates this method is called SKILit.
Reference: [10] <author> Muggleton S. </author> <year> (1993): </year> <title> Inductive Logic Programming: derivations, </title> <booktitle> successes and shortcomings in Proceedings of ECML-93 , Springer-Verlag. </booktitle>
Reference-contexts: Small sets of examples tend to be incomplete making recursive clauses hard to induce. Thus it is crucial to develop inductive strategies that generate recursive definitions from small sets of examples. Several solutions have been proposed (e.g. [1], [8], <ref> [10] </ref>). The solution described in [1], and incorporated in CRUSTACEAN , exploits common substructures in the examples. Although encouraging results have been achieved, the method seems to be difficult to extend and integrate into a general purpose inductive system.
Reference: [11] <author> Richards B, </author> <title> Mooney R (1992): </title> <booktitle> Learning relations by pathfinding in Proceedings of the Tenth National Conference on Artificial Intelligence, </booktitle> <address> Cambridge, MA, </address> <publisher> MIT Press. </publisher>
Reference-contexts: The induced clauses are reused in order to facilitate the induction of new, more general, clauses. The system performs a kind of relational pathfinding similar to <ref> [ 11 ] </ref> which we think is particularly suited for this task. The search for a clause is, in addition, constrained by means of a definite clause grammar (DCG), in some ways similar to [5]. Extensive experiments were carried out with the system that implements this method.
Reference: [12] <editor> Zelle J M, Mooney R J, Konvisser J B, </editor> <booktitle> (1994):Combining Top-down and Bottom-up Techniques in Inductive Logic Programming in Proceedings of the Eleventh International Conference on Machine Learning ML-94 , Morgan-Kaufmann. </booktitle>
Reference-contexts: Overall results were good. Although our system SKILit employs techniques reported elsewhere, the architecture of the system is quite unique. Other approaches suffer from various deficiencies. The iterative nature of the method is essentially similar to the one used in CHILLIN by Zelle et al. <ref> [12] </ref>. They have pointed out that generalization of the original examples can significantly improve the chance of generating the correct clause. However, there are significant differences between CHILLIN and the approach described here. <p> For that reason, the probability that a recursive clause is generated in a given iteration is higher than in the previous ones. It is important to note that this strategy is still more efficient than generating all possible recursive literals. The systems CHILLIN <ref> [12] </ref> and RTL [7] use somewhat similar iterative strategies that attempt to solve the problem of inducing recursion from incomplete examples sets. However, there are some significant differences between these approaches and the method described here. The system CHILLIN initiates the clause construction using the bottom-up operation of LGG.
References-found: 12

