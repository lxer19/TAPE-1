URL: ftp://ftp.cs.unc.edu/pub/users/munson/CSCW96.ps
Refering-URL: http://www.cs.unc.edu/~munson/papers.html
Root-URL: http://www.cs.unc.edu
Email: munson, dewan-@cs.unc.edu  
Title: A Concurrency Control Framework for Collaborative Systems  
Author: Jonathan Munson and Prasun Dewan 
Keyword: Concurrency control, collaborative systems, consistency criteria, coupling, merging, transactions  
Address: Carolina-Chapel Hill  
Affiliation: Department of Computer Science University of North  
Abstract: We have developed a new framework for supporting con-currency control in collaborative applications. It supports multiple degrees of consistency and allows users to choose concurrency control policies based on the objects they are manipulating, the tasks they are performing, and the coupling and merge policies they are using. Concurrency control policies are embodied in hierarchical, constructor-based lock compatibility tables. Entries in these tables may be specified explicitly or derived automatically from coupling and merge policies. In this paper, we motivate and describe the framework, identify several useful concurrency control policies it can support, evaluate its flexibility, and give conclusions and directions for future work. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bancilhon, F., Kim, W., and Korth, H. </author> <title> A model of CAD transactions. </title> <booktitle> In Proceedings of 11th International Conference on Very Large Databases 1985, </booktitle> <pages> pp. 2533. </pages>
Reference-contexts: This increases concur-rency by allowing schedules that otherwise would have been disallowed to avoid cascading aborts. Other researchers have presented work based on formal notions of program correctness, in which application semantics is encoded in predicates that must be satisfied by transactions. Bancilhon et al. <ref> [1] </ref> require each transaction to provide an invariant of the database that its execution maintains; Korth and Speegle [18] require each transaction to supply precondition and postcondition predicates. Since satisfaction of arbitrary predicates would be infeasible, the authors provide for an efficiently executed subset.
Reference: 2. <author> Barghouti, N.S. and Kaiser, G.E. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys 23, </journal> <month> 3 (September </month> <year> 1991), </year> <month> 223317. </month>
Reference-contexts: As a result of these characteristics, collaborative applications have their own peculiar concurrency control requirements. Some, such as support for long transactions, user control over transaction execution, relaxed consistency criteria, and integration with access control, may be found in <ref> [2] </ref> and [15]. We offer the following additional requirements which so far have not been addressed in previous work. Concurrency control for collaborative applications should: permit high-level definition of applicationspecific consistency criteria. <p> Thus we offer a high-level, but restricted language for postcondi-tions, as well as a low-level, but unrestricted language. We are currently investigating a language of intermediate level and restrictiveness. Other Advanced Transaction Models Barghouti and Kaiser <ref> [2] </ref> describe many advanced transaction models, among them Split/Join transactions and participant transactions. Our framework offers some of the capabilities of these models, in a lightweight fashion. The Suite Accept command by default commits changes to all application structures. But through selection a user can selectively commit changes to substructures. <p> Important future work includes adding to our framework support for other commonly used constructors such as trees and tables (directories). Work is also necessary to integrate our work with advanced transaction models further supporting nested transactions, participant transactions, altruistic locking, and split/join transactions <ref> [2] </ref>, and groupware con-currency control schemes addressing performance issues. ACKNOWLEDGMENTS This research was supported in part by an IBM Fellowship and National Science Foundations grant IRI-9408708. We would also like to thank the reviewers, whose insightful comments on our work significantly improved it.
Reference: 3. <author> Dewan, P. and Choudhary, R. </author> <title> A high-level flexible framework for implementing multiuser user interfaces. </title> <journal> ACM Transactions on Information Systems 10, </journal> <month> 4 (October </month> <year> 1992), </year> <month> 345380. </month>
Reference-contexts: Third, it motivates and describes several new concurrency control policies. Fourth, it provides programmer-defined dependency relations that automatically link items not related through structural hierarchy. Suite Data Model The basis of our concurrency control framework is the Suite collaboration framework <ref> [3] </ref>. Suite provides general structured objects, fine-grained object attributes, and flexible coupling among object views. Suite applications consist of user-defined data structures hierarchically composed of simple values, records, and sequences, and user-written functions that respond to users changes to the data structure.
Reference: 4. <author> Dewan, P. and Choudhary, R. </author> <title> Coupling the user interfaces of a multiuser program. </title> <booktitle> ACM Transactions on Computer Human Interaction 2, </booktitle> <month> 1 (March </month> <year> 1995), </year> <month> 139. </month>
Reference-contexts: It is based on the expectation that shared locks are most desirable between those users who are closely coupled, i.e., those users who see each others partial results. So we offer a mechanism that consults an objects coupling tables <ref> [4] </ref> and adds shared lock rows for those users who are closely coupled. The user may customize the new entries to achieve the desired sharing. Lock rows that specify a specific user as a parameter allow lock policies to be based on user roles/identities.
Reference: 5. <author> Ellis, C. and Gibbs, S. </author> <title> Concurrency control in groupware systems. </title> <booktitle> In Proceedings of ACM SIGMOD Conference on Management of Data 1989, </booktitle> <pages> pp. 399407. </pages>
Reference-contexts: If the lock is refused the actions are undone automatically. A non-locking, non-blocking approach is offered by Ellis and Gibbs <ref> [5, 6] </ref> through their dOPT algorithm for replicated architectures. The algorithm is designed to provide consistent displays in the face of out-of-order message delivery. The dOPT algorithm relies on operation transformation rather than blocking and so provides excellent response time, but it is not a synchronization mechanism.
Reference: 6. <author> Ellis, C.A., Gibbs, S.J., and Rein, G.L. </author> <title> Groupware: some issues and experiences. </title> <journal> Communications of the ACM 34, </journal> <month> 1 (January, </month> <year> 1991), </year> <month> 928. </month>
Reference-contexts: Concurrency control has also been addressed in collaborative systems. Early collaborative applications (e.g., [23]) used floor control (one person acting at a time) to prevent users from colliding. This was found to be too restrictive for many applications, and later systems dispensed with synchronization altogether <ref> [6, 13] </ref>, or provided visual feedback to indicate which objects were in use [25]. These systems rely upon social protocols and users awareness of others actions to prevent conflicts, and hope that if conflicts do occur they can be quickly and easily resolved. <p> If the lock is refused the actions are undone automatically. A non-locking, non-blocking approach is offered by Ellis and Gibbs <ref> [5, 6] </ref> through their dOPT algorithm for replicated architectures. The algorithm is designed to provide consistent displays in the face of out-of-order message delivery. The dOPT algorithm relies on operation transformation rather than blocking and so provides excellent response time, but it is not a synchronization mechanism.
Reference: 7. <author> Eswaran, K.P., Gray, J., Lorie, R., and Traiger, </author> <title> I.L. The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM 19, </journal> <month> 11 (November </month> <year> 1976), </year> <pages> 624 633. </pages>
Reference-contexts: Traditional Database Systems Concurrency control has been most actively studied within the domain of database systems, where its goal is usually to provide serializable transactions <ref> [7] </ref>. A transaction is a sequence of operations that together perform a logical task; serializable transactions are concurrent transactions whose operations are interleaved in such a way that there exists an equivalent serial (one after the other) execution of the transactions.
Reference: 8. <author> Farrag, A.A. and Ozsu, </author> <title> M.T. Using semantic knowledge of transactions to increase concurrency. </title> <journal> ACM Transactions on Database Systems 14, </journal> <month> 4 (December </month> <year> 1989), </year> <month> 503525. </month>
Reference-contexts: If the concurrency control system is made aware of this information, significantly less restrictive control may result. This approach is of particular interest to the database community because it layers on top of conventional read/write operations. Garcia-Molina [9], Lynch [20], and Farrag and Ozsu <ref> [8] </ref> described transaction models in which transaction programmers explicitly declared how a particular kind of transaction may be interleaved with other transactions in ways that would have otherwise been disallowed. Sagas, as defined by Garcia-Molina in [10], are sequences of subtransactions that can be interleaved arbitrarily with other transactions.
Reference: 9. <author> Garcia-Molina, H. </author> <title> Using semantic knowledge for transaction processing in a distributed database. </title> <journal> ACM Transactions on Database Systems 8, </journal> <month> 2 (June </month> <year> 1983), </year> <month> 186213. </month>
Reference-contexts: If the concurrency control system is made aware of this information, significantly less restrictive control may result. This approach is of particular interest to the database community because it layers on top of conventional read/write operations. Garcia-Molina <ref> [9] </ref>, Lynch [20], and Farrag and Ozsu [8] described transaction models in which transaction programmers explicitly declared how a particular kind of transaction may be interleaved with other transactions in ways that would have otherwise been disallowed.
Reference: 10. <author> Garcia-Molina, H. and Salem, K. Sagas. </author> <booktitle> In Proceedings of ACM SIGMOD Annual Conference 1987, </booktitle> <pages> pp. 249259. </pages>
Reference-contexts: Garcia-Molina [9], Lynch [20], and Farrag and Ozsu [8] described transaction models in which transaction programmers explicitly declared how a particular kind of transaction may be interleaved with other transactions in ways that would have otherwise been disallowed. Sagas, as defined by Garcia-Molina in <ref> [10] </ref>, are sequences of subtransactions that can be interleaved arbitrarily with other transactions. Thus sagas can view partial results of other sagas.
Reference: 11. <author> Gray, J. </author> <title> Notes on database operating systems, In Operating Systems: An Advanced Course. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Gray et al. addressed this problem with multiple granularity locking <ref> [11, 12] </ref>. Document locking under this scheme would allow a user to lock either a chapter, a section, or a subsection. In addition to conventional read and write locks (Share and Exclusive in their terminology), the authors defined two additional locks, Intent Share and Intent Exclusive. <p> GroupKit policy Multiple Granularity Locks Our framework subsumes in functionality the multiple granularity locking scheme of <ref> [11] </ref>, with the exception that we do not offer an Update mode, which gives read access to the holder with the option of upgrading the lock to an Exclusive lock. Serializable Queues Schwarz and Spector give examples of policies for queues, which Suite does not directly support.
Reference: 12. <author> Gray, J., Lorie, R.A., Putzolu, G.R., and Traiger, </author> <title> I.L. Granularity of locks and degrees of consistency in a shared database, In Modeling in Database Management Systems. </title> <publisher> Elsevier North-Holland, </publisher> <address> Amsterdam, </address> <year> 1976. </year>
Reference-contexts: Gray et al. addressed this problem with multiple granularity locking <ref> [11, 12] </ref>. Document locking under this scheme would allow a user to lock either a chapter, a section, or a subsection. In addition to conventional read and write locks (Share and Exclusive in their terminology), the authors defined two additional locks, Intent Share and Intent Exclusive. <p> Fortunately, the core of our frameworkhierarchical constructor-based lock tablesis a straightforward extension of mechanisms (multi-granularity locking, typespecific locking) for which formal proofs of correctness already exist <ref> [12, 24] </ref>. It only remains for us to prove that their interaction will not admit of incorrect behavior, which we do here informally. In our framework a users locks are held until the end of the transaction (marked by the user indicating Accept), as in conventional two-phase locking.
Reference: 13. <author> Greenberg, S. and Bohnet, R. GroupSketch: </author> <title> a multiuser sketchpad for geographically distributed small groups. </title> <booktitle> In Proceedings of Graphics Interface 1991, </booktitle> <pages> pp. </pages> <year> 207215. </year>
Reference-contexts: Concurrency control has also been addressed in collaborative systems. Early collaborative applications (e.g., [23]) used floor control (one person acting at a time) to prevent users from colliding. This was found to be too restrictive for many applications, and later systems dispensed with synchronization altogether <ref> [6, 13] </ref>, or provided visual feedback to indicate which objects were in use [25]. These systems rely upon social protocols and users awareness of others actions to prevent conflicts, and hope that if conflicts do occur they can be quickly and easily resolved.
Reference: 14. <author> Greenberg, S. and Marwood, D. </author> <title> Real time groupware as a distributed system: concurrency control and its effect on the interface. </title> <booktitle> In Proceedings of ACM Conference on Computer Supported Cooperative Work 1994, </booktitle> <pages> pp. </pages> <year> 207217. </year>
Reference-contexts: DistView [22] is a collaborative applications framework employing a replicated architecture. Concurrency control is provided via locking. For performance reasons lock tables are replicated so that all accesses are local. GroupKit <ref> [14] </ref> is an applications toolkit that also employs locking. In DistView, user actions are blocked between the time a lock is requested and the time it is granted; in GroupKit, however, user actions are allowed to continue while waiting for the lock to be granted. <p> While a DM is waiting for its lock request to be granted or denied, the user is allowed to proceed editing the structure for which the lock was requested, and may move on to edit other structures. Greenberg and Marwood <ref> [14] </ref> refer to this as fully optimistic locking. If another request is received before its own is received, the DM undoes the users changes and blocks further editing on the corresponding item.
Reference: 15. <author> Greif, I. and Sarin, S. </author> <title> Data sharing in group work. </title> <booktitle> In Proceedings of ACM Conference on Computer Supported Cooperative Work ACM, </booktitle> <address> New York, </address> <year> 1986, </year> <pages> pp. 175183. </pages>
Reference-contexts: As a result of these characteristics, collaborative applications have their own peculiar concurrency control requirements. Some, such as support for long transactions, user control over transaction execution, relaxed consistency criteria, and integration with access control, may be found in [2] and <ref> [15] </ref>. We offer the following additional requirements which so far have not been addressed in previous work. Concurrency control for collaborative applications should: permit high-level definition of applicationspecific consistency criteria.
Reference: 16. <author> Herlihy, M. </author> <title> Apologizing versus asking permission: optimistic concurrency control for abstract data types. </title> <journal> ACM Transactions on Database Systems 15, </journal> <month> 1 (March </month> <year> 1990), </year> <pages> 96 124. </pages>
Reference-contexts: Such a queue preserves the property of fairness rather than serializability. Being lock-based, the mechanisms above are pessimistic concurrency control techniques. Herlihy <ref> [16] </ref> uses similar type information in an optimistic scheme, in which transactions run without synchronization and are checked for consistency when they attempt to commit. Exploiting Application Semantics An application will typically have semantics beyond those coded in the data types it employs.
Reference: 17. <author> Knister, M. and Prakash, A. </author> <title> Issues in the design of a toolkit for supporting multiple group editors. </title> <booktitle> Computing Systems 6, 2 (Spring 1993), </booktitle> <pages> 135166. </pages>
Reference-contexts: This policy may be preferred for a WYSIWIS (What You See Is What I See) text editor for synchronous collaboration, in order to prevent two users inserting characters at the same position. The DistEdit <ref> [17] </ref> collaborative editor uses a like policy. Entries in rows and columns for Modify and Read locks are as expected and are the same for all policies.
Reference: 18. <author> Korth, H. and Speegle, G. </author> <title> Formal model of correctness without serializability. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data 1988, </booktitle> <pages> pp. 379386. </pages>
Reference-contexts: Other researchers have presented work based on formal notions of program correctness, in which application semantics is encoded in predicates that must be satisfied by transactions. Bancilhon et al. [1] require each transaction to provide an invariant of the database that its execution maintains; Korth and Speegle <ref> [18] </ref> require each transaction to supply precondition and postcondition predicates. Since satisfaction of arbitrary predicates would be infeasible, the authors provide for an efficiently executed subset. As will be seen when we describe our own work, we have borrowed much from the large body of database concur-rency control research. <p> Weakly FIFO queue policy In addition to these policies simulating the policies of other systems, we have defined several new policies for concur-rency control, as found in Tables 5, 6, 9, and 10. Predicate Satisfaction In the transaction model of Korth and Speegle <ref> [18] </ref>, a transactions precondition must be satisfied before it can begin executing, and its postcondition satisfied before it can commit. The merge matrix of our merge procedure, to which transaction updates are subject when users have been working asynchronously (uncoupled Dialogue Manager views) is a language for postconditions.
Reference: 19. <author> Korth, H.F. </author> <title> Locking primitives in a database system. </title> <journal> Journal of the Association for Computing Machinery 30, </journal> <month> 1 (January </month> <year> 1983), </year> <month> 5579. </month>
Reference-contexts: A number of researchers have demonstrated that basing concurrency control on the semantics of the interface an object presentsits typerather than the reads and writes of the objects constituent members, results in less restrictive scheduling <ref> [19, 24, 26] </ref>. Concurrency control based on read/write semantics must necessarily be conservative because there is no awareness of what operations in a transaction actually depend on each other. It must be assumed, for example, that a write following a read depends on that read. <p> It must be assumed, for example, that a write following a read depends on that read. Consideration of the object semantics may reveal that there is no dependency, but this information is not available to the concurrency control system. Korth <ref> [19] </ref> and Schwarz and Spector [24] developed lock compatibility tables based on this idea, using a data types operations as lock modes rather than, or in addition to, simple read and write operations. They demonstrated that greater concurrency resulted, still using serializability as the consistency criterion.
Reference: 20. <author> Lynch, N.A. </author> <title> Multilevel atomicity: a new correctness criterion for database concurrency control. </title> <journal> ACM Transactions on Database Systems 8, </journal> <month> 4 (December </month> <year> 1983), </year> <month> 484502. </month>
Reference-contexts: If the concurrency control system is made aware of this information, significantly less restrictive control may result. This approach is of particular interest to the database community because it layers on top of conventional read/write operations. Garcia-Molina [9], Lynch <ref> [20] </ref>, and Farrag and Ozsu [8] described transaction models in which transaction programmers explicitly declared how a particular kind of transaction may be interleaved with other transactions in ways that would have otherwise been disallowed.
Reference: 21. <author> Munson, J. and Dewan, P. </author> <title> A flexible object merging framework. </title> <booktitle> In Proceedings of ACM Conference on Computer Supported Cooperative Work 1994, </booktitle> <pages> pp. 231242. </pages>
Reference-contexts: In this section we would like to present a third way, which is to transform existing concurrency control policies based on the policies of other collaboration functions. Concurrency Control Policy from Merge Policy A merge policy specifies how conflicts are to be resolved at merge time <ref> [21] </ref>. This information can be used during the transaction to resolve conflicts as they occur, in ways different from a conventional concurrency control policy. Merge policies typically use different criteria than do con-currency control policies.
Reference: 22. <author> Prakash, A. and Shim, H.S. DistView: </author> <title> support for building efficient collaborative applications using replicated objects. </title> <booktitle> In Proceedings of ACM Conference on Computer Supported Cooperative Work 1994, </booktitle> <pages> pp. 153164. </pages>
Reference-contexts: But suppose B had decided to lock the entire chapter in Exclusive mode. This would fail because an X lock is not compatible with an IX lock. Concurrency Control For Collaborative Applications We discuss here some recent efforts that address the need for concurrency control in collaborative applications. DistView <ref> [22] </ref> is a collaborative applications framework employing a replicated architecture. Concurrency control is provided via locking. For performance reasons lock tables are replicated so that all accesses are local. GroupKit [14] is an applications toolkit that also employs locking.
Reference: 23. <author> Sarin, S. and Greif, I. </author> <title> Computer-based real-time conferencing systems. </title> <booktitle> Computer 18, </booktitle> <month> 10 (October </month> <year> 1985), </year> <month> 3345. </month>
Reference-contexts: For a user about to commit a large number of changes to a document, this would not only be very unpleasant, but is probably unnecessary; the user may only need to discard changes to one paragraph. Concurrency control has also been addressed in collaborative systems. Early collaborative applications (e.g., <ref> [23] </ref>) used floor control (one person acting at a time) to prevent users from colliding. This was found to be too restrictive for many applications, and later systems dispensed with synchronization altogether [6, 13], or provided visual feedback to indicate which objects were in use [25].
Reference: 24. <author> Schwarz, P.M. and Spector, A.Z. </author> <title> Synchronizing shared abstract types. </title> <journal> ACM Transactions on Computer Systems 2, </journal> <month> 3 (August </month> <year> 1984), </year> <month> 223250. </month>
Reference-contexts: A number of researchers have demonstrated that basing concurrency control on the semantics of the interface an object presentsits typerather than the reads and writes of the objects constituent members, results in less restrictive scheduling <ref> [19, 24, 26] </ref>. Concurrency control based on read/write semantics must necessarily be conservative because there is no awareness of what operations in a transaction actually depend on each other. It must be assumed, for example, that a write following a read depends on that read. <p> It must be assumed, for example, that a write following a read depends on that read. Consideration of the object semantics may reveal that there is no dependency, but this information is not available to the concurrency control system. Korth [19] and Schwarz and Spector <ref> [24] </ref> developed lock compatibility tables based on this idea, using a data types operations as lock modes rather than, or in addition to, simple read and write operations. They demonstrated that greater concurrency resulted, still using serializability as the consistency criterion. <p> Therefore we maintain maps that translate an elements original position to its new position, and vice versa, and use them to map lock requests between corresponding elements. Comparison With TypeSpecific Locking Our lock tables are similar to the typespecific tables of Schwarz and Spector <ref> [24] </ref>. They differ in a subtle respect, however, in that ours are constructorspecific rather than typespecific. <p> Fortunately, the core of our frameworkhierarchical constructor-based lock tablesis a straightforward extension of mechanisms (multi-granularity locking, typespecific locking) for which formal proofs of correctness already exist <ref> [12, 24] </ref>. It only remains for us to prove that their interaction will not admit of incorrect behavior, which we do here informally. In our framework a users locks are held until the end of the transaction (marked by the user indicating Accept), as in conventional two-phase locking.
Reference: 25. <author> Stefik, M., Bobrow, D.G., Foster, G., Lanning, S., and Tatar, D. </author> <title> WYSYIWIS revised: early experiences with multiuser interfaces. </title> <journal> ACM Transactions on Office Information Systems 5, </journal> <month> 2 (April </month> <year> 1987), </year> <month> 147167. </month>
Reference-contexts: Early collaborative applications (e.g., [23]) used floor control (one person acting at a time) to prevent users from colliding. This was found to be too restrictive for many applications, and later systems dispensed with synchronization altogether [6, 13], or provided visual feedback to indicate which objects were in use <ref> [25] </ref>. These systems rely upon social protocols and users awareness of others actions to prevent conflicts, and hope that if conflicts do occur they can be quickly and easily resolved. But this approach may also not be acceptable in many situations.
Reference: 26. <author> Weihl, W. and Liskov, B. </author> <title> Implementation of resilient, atomic data types. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 2 (April </month> <year> 1985), </year> <month> 244269. </month>
Reference-contexts: A number of researchers have demonstrated that basing concurrency control on the semantics of the interface an object presentsits typerather than the reads and writes of the objects constituent members, results in less restrictive scheduling <ref> [19, 24, 26] </ref>. Concurrency control based on read/write semantics must necessarily be conservative because there is no awareness of what operations in a transaction actually depend on each other. It must be assumed, for example, that a write following a read depends on that read.
References-found: 26

