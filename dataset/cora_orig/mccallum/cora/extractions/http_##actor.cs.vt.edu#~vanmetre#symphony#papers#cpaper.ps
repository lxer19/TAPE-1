URL: http://actor.cs.vt.edu/~vanmetre/symphony/papers/cpaper.ps
Refering-URL: http://actor.cs.vt.edu/~vanmetre/symphony/papers.html
Root-URL: http://www.cs.vt.edu
Title: Symphony: A Java-based Composition and Manipulation Framework for Distributed Legacy Resources  
Author: Ashish Shah Dennis Kafura 
Abstract: This paper presents Symphony, an open and extensible Java-based framework for composition and manipulation of distributed legacy resources. Symphony allows users to compose visually a collection of programs and data by specifying data-flow relationships among them and provides a client/server framework for transparently executing the composed application. Additionally, the framework is web-aware and helps integrate web-based resources with legacy resources. It also enables programmers to provide a graphical interface to legacy applications and to write visualization components. Symphony uses Sun Microsystems' JavaBeans component architecture for providing components that represent legacy resources. These components can be customized and composed in any standard JavaBeans builder tool. Executable components communicate with a server, implemented using Java Remote Method Invocation mechanism, for executing remote legacy applications. Symphony enables extensibility by providing abstract components which can be extended by implementing simple interfaces. Beans implemented from the abstract beans can act as data producers, consumers or filters.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Craig Upson, Thomas Faulhaber, David Kamins, Davin Laidlaw, David Schlegel, Jeffrey Vroom, Robert Gurwitz, and Andries van Dam. </author> <title> The Application Visualization System: a Computational Environment for Scientific Visualization. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 30-42, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The data-flow paradigm was chosen as a way of connecting components and specifying the execution sequence of related programs. This paradigm has been popularized by visualization systems such as AVS <ref> [1] </ref> and Khoros [8]. A visual program is described as a directed graph, where each node represents an operator or function and each directed arc represents a path over which data flows. In Symphony, such an integrated collection of components is termed as a meta-program.
Reference: [2] <institution> Department of Computer Science, Virginia Tech. Research in Problem Solving Environments at Virginia Tech. </institution> <address> URL: http://www.cs.vt.edu/ pse/, </address> <year> 1998. </year>
Reference-contexts: Our work on Symphony, while applicable to any set of legacy resources, was motivated by a larger interest at Virginia Tech in Problem Solving Environments (PSEs) for science and engineering applications <ref> [2] </ref>. A Problem Solving Environment (PSE) can be defined as a computer system that provides all computational facilities necessary to solve a target class of problems efficiently. <p> At the end of a stop operation, all beans are in the ABORTED status indicated by the color red. 4 Application Example This section describes a sample meta-program based on the Radio Frequency Pressing (RFP) simulation developed at the Department of Wood Science and Forest Products at Virginia Tech <ref> [2] </ref>. This system simulates heat and mass transfer in wood when subject to power input by an alternating electric field.
Reference: [3] <institution> Department of Computer Sciences, Purdue University. </institution> <note> Problem Solving Environments. URL: http://www.cs.purdue.edu/research/cse/pses/, 1998. </note>
Reference-contexts: The need for a PSE increases with the complexity and heterogeneity of the application. Most existing PSEs are focused on providing problem-solving facilities for narrow application domains, such as solving partial differential equations (PDEs), data visualization, numerical analysis and others <ref> [3] </ref>. These PSEs are built around software libraries which are either modified or rewritten to adapt to the architecture of the PSE. Although these PSEs function very well in their own domain, they do not attempt to provide a generic framework for solving general-purpose science and engineering problems.
Reference: [4] <author> E. Houstis, J. Rice, S. Weerawarana, A. Catlin, P. Papachiou, K.-W. Wang and M. Gaitatzes. </author> <title> Parallel ELLPACK: A Problem-Solving Environment for PDE Based Applications on Multicomputer Platforms. </title> <journal> ACM Transactions on Mathematical Software, </journal> <note> (To Appear) 1998. </note>
Reference-contexts: Consider the example of Parallel ELLPACK (//ELLPACK), which is a problem solving environment for partial differential equations (PDEs) <ref> [4] </ref>. The //ELLPACK system consists of about one million lines of C, Lisp, and Fortran code. It's easy to see how complex it must be just to install a copy of the PSE on a new machine.
Reference: [5] <author> Efstratois Gallopoulos, Elias Houstis and John Rice. </author> <title> Computer as a Thinker/Doer: Problem Solving Environments for Computational Sciences. </title> <journal> IEEE Computational Science and Engineering, </journal> <pages> pages 11-23, </pages> <year> 1994. </year>
Reference-contexts: Some properties shared by all PSEs are that they allow a user to formulate a problem solution in a language suitable for the target class of problems and to view or assess the correctness of the solution through analysis or visualization tools <ref> [5] </ref>. Depending on the problem domain, different features are desired in a PSE.
Reference: [6] <author> Philip Isenhour. </author> <title> Sieve: A Java-Based Framework for Collaborative Component Composition. </title> <type> Master's thesis, </type> <institution> Virginia Tech, Blacksburg, VA, </institution> <year> 1998. </year>
Reference-contexts: Thus, Symphony can be used in any tool that conforms to the JavaBeans standard. The current Symphony implementation has been executed on window 95, Dec and Sparc systems and tested in the BeanBox reference container developed by Sun, and in the Sieve workspace <ref> [6] </ref>, an experimental, collaborative environment. Our work on Symphony, while applicable to any set of legacy resources, was motivated by a larger interest at Virginia Tech in Problem Solving Environments (PSEs) for science and engineering applications [2].
Reference: [7] <author> John Ambrosiano, Steve Fines and Mladen Vouk. </author> <booktitle> Problem-Solving Environments in the Year 2000 and Beyond, </booktitle> <year> 1995. </year> <month> 21 </month>
Reference-contexts: In fact, no existing PSE or PSE-like system, including our own, has all of the features described above. Problem solving environments have predominantly focused on science and engineering applications <ref> [7, 9] </ref>. In this paper too, the term PSE will be interpreted with this application domain in mind.
Reference: [8] <institution> Khoral Research, Inc. </institution> <note> What is khoros? URL: http://www.khoral.com/khoros/whatis.html, 1998. </note>
Reference-contexts: The data-flow paradigm was chosen as a way of connecting components and specifying the execution sequence of related programs. This paradigm has been popularized by visualization systems such as AVS [1] and Khoros <ref> [8] </ref>. A visual program is described as a directed graph, where each node represents an operator or function and each directed arc represents a path over which data flows. In Symphony, such an integrated collection of components is termed as a meta-program.
Reference: [9] <author> John Rice and Ronald Boisvert. </author> <title> From Scientific Software Libraries to Problem-Solving Environments. </title> <journal> IEEE Computational Science and Engineering, </journal> <pages> pages 44-53, </pages> <year> 1996. </year>
Reference-contexts: In fact, no existing PSE or PSE-like system, including our own, has all of the features described above. Problem solving environments have predominantly focused on science and engineering applications <ref> [7, 9] </ref>. In this paper too, the term PSE will be interpreted with this application domain in mind.
Reference: [10] <author> Sun Microsystems, Inc. </author> <title> Java Object Serialization Specification. </title> <address> URL: http://www.javasoft.com/- products/jdk/1.1/docs/guide/serialization/spec/serialTOC.doc.html, </address> <year> 1997. </year>
Reference-contexts: This file can be loaded into the BeanBox at a later time to reproduce the meta-program and modify or execute it. The BeanBox uses object serialization to save and restore the current contents of the workspace (the beans in the workspace, their state, and connections) <ref> [10] </ref>. On selecting the File ! Save menu item in the BeanBox, a file dialog box appears, which can be used to save the current workspace to a named file.
Reference: [11] <author> Sun Microsystems, Inc. </author> <title> The JavaBeans (tm) Tutorial. </title> <address> URL: http://www.javasoft.com/beans/docs/- Tutorial-Nov97.pdf, </address> <year> 1998. </year> <month> 22 </month>
Reference-contexts: It also describes important BeanBox operations at a higher level in terms of the steps required for composing a meta-program <ref> [11] </ref>. Two modifications have been made to the BeanBox provided by Sun purely for aesthetic purposes. First, the original BeanBox displays an empty property sheet when a bean that does not export any properties is selected in the workspace.
References-found: 11

