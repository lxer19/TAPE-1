URL: http://www.cs.gatech.edu/grads/p/Jeff.Pittges/tkde.ps
Refering-URL: http://www.cs.gatech.edu/grads/p/Jeff.Pittges/pittges.html
Root-URL: 
Email: fpittges, leomark, shamg@cc.gatech.edu  
Title: Metadata View Graphs: Maintaining Dynamic Semantic Rules for Query Optimization  
Author: Jeff Pittges Leo Mark Sham Navathe 
Keyword: Metadata View Graph, Metadata Maintenance, Dynamic Semantic Rules, Query Optimization.  
Date: October 1, 1995  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Although previous experimental results have shown that dynamic semantic rules may significantly reduce query execution time, the problem of how to maintain dynamic semantic rules has remained an open research problem. The Metadata View Graph is a metadatabase that maintains semantic, statistical, and structural metadata for views of a database. Capturing dynamic rules for relevant views increases the amount of information contained in the rules and improves the performance of discovering, retrieving, maintaining, and using the rules. This paper presents a set of strategies, methods, and algorithms for efficiently maintaining dynamic rules in the Metadata View Graph Framework. The paper describes how dynamic rules are retrieved, maintained, and applied during query processing. The paper also presents a run-time cost model that determines when metadata maintenance is cost effective during query processing. 
Abstract-found: 1
Intro-found: 1
Reference: [BCL89] <author> J. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating derived relations: Detecting ir-relevent and autonomously computable updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: When an exception occurs, an invalid rule can be rewritten such that the modified rule is valid for the current state of the database. However, a rule that is repeatedly rewritten will eventually become useless. Another alternative involves the identification of autonomously computable updates <ref> [BCL89] </ref>. A rule can be modified if an update is found to be autonomously computable. The fourth approach is to leave the invalid rule unmodified, but require that the rule reference the exception. This approach requires the optimizer to modify queries using the rule and the exceptions to the rule.
Reference: [BCVG88] <author> A. Buchmann, R. Carrerra, and M. Vasquez-Galindo. </author> <title> A generalized constraint and exception handler for an object-oriented cad-dbms. </title> <booktitle> In Proceedings of the 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 38-49, </pages> <address> Pacific Grove, California, </address> <year> 1988. </year>
Reference-contexts: The fourth approach is to leave the invalid rule unmodified, but require that the rule reference the exception. This approach requires the optimizer to modify queries using the rule and the exceptions to the rule. Methods for referencing exceptions are described in <ref> [Bor85, BCVG88] </ref>. 4.5 Run-Time Maintenance Cost As described in Section 3.1, when a query is processed at run-time, the query's execution packet is retrieved from the QEP Network and the query execution plans that apply to the 23 given query are considered.
Reference: [Bla81] <author> B. Blaustein. </author> <title> Enforcing Database Assertions: Techniques and Applications. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1981. </year>
Reference-contexts: Once the update logs have been processed and the view node to refreshed has been retrieved, exceptions can be detected using well-established integrity checking algorithms <ref> [Bla81, HS78] </ref>. Once a rule becomes invalid, the rule must be invalidated or rewritten. As described in [SSS92], there are four methods for handling invalid rules. The simplest approach is to delete the invalid rule.
Reference: [BLT86] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <editor> In C. Zaniolo, editor, </editor> <booktitle> Proceedings of the 1986 ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: However, only a subset of the updates will apply to a given view node based on the definition of the node (e.g., gpa 3.0). Therefore, the updates must be filtered to remove the irrelevant updates <ref> [BLT86] </ref>. An example is provided below. example database. The figure also illustrates an update log for the base relation which contains a number of tuples to be inserted into the base relation.
Reference: [Bor85] <author> A. Borgida. </author> <title> Language features for flexible handling of exceptions in information systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 565-603, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The fourth approach is to leave the invalid rule unmodified, but require that the rule reference the exception. This approach requires the optimizer to modify queries using the rule and the exceptions to the rule. Methods for referencing exceptions are described in <ref> [Bor85, BCVG88] </ref>. 4.5 Run-Time Maintenance Cost As described in Section 3.1, when a query is processed at run-time, the query's execution packet is retrieved from the QEP Network and the query execution plans that apply to the 23 given query are considered.
Reference: [CG94] <author> R.L. Cole and G. Graefe. </author> <title> Optimization of dynamic query evaluation plans. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 150-160, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year> <month> 26 </month>
Reference-contexts: The QEP Network stores query execution plans. The network contains a query execution packet for each query that is compiled by the system. Query execution packets store two types of query execution plans, dynamic plans and semantic plans. A dynamic plan <ref> [GW89, CG94] </ref> links several query execution plans together with choose-plan operators that allow a decision to be postponed until the run-time conditions are known. The choose-plan operators are linked to the view nodes that contain relevant statistics. Semantic plans contain pointers to the rules that they depend on.
Reference: [CGM90] <author> S. Chakravarthy, J. Grant, and J. Minker. </author> <title> Logic based approach to semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 162-207, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [GW89] <author> G. Graefe and K. Ward. </author> <title> Dynamic query evaluation plans. </title> <booktitle> In Proceedings of the 1989 ACM-SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 358-366, </pages> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: The QEP Network stores query execution plans. The network contains a query execution packet for each query that is compiled by the system. Query execution packets store two types of query execution plans, dynamic plans and semantic plans. A dynamic plan <ref> [GW89, CG94] </ref> links several query execution plans together with choose-plan operators that allow a decision to be postponed until the run-time conditions are known. The choose-plan operators are linked to the view nodes that contain relevant statistics. Semantic plans contain pointers to the rules that they depend on.
Reference: [HK93] <author> C. Hsu and C.A. Knoblock. </author> <title> Reformulating query plans for multidatabase systems. </title> <booktitle> In Proceedings of the Second International Conference on Information and Knowledge Management, </booktitle> <address> Washington, DC, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [HK94] <author> Chun-Nan Hsu and Craig Knoblock. </author> <title> Rule induction for semantic query optimization. </title> <booktitle> Machine Learning, </booktitle> <pages> pages 1-10, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [HS78] <author> M. Hammer and S. Sarin. </author> <title> Efficient monitoring of database assertions. </title> <booktitle> In Proceedings of the 1978 ACM-SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 38-49, </pages> <address> Austin, Texas, </address> <year> 1978. </year>
Reference-contexts: Once the update logs have been processed and the view node to refreshed has been retrieved, exceptions can be detected using well-established integrity checking algorithms <ref> [Bla81, HS78] </ref>. Once a rule becomes invalid, the rule must be invalidated or rewritten. As described in [SSS92], there are four methods for handling invalid rules. The simplest approach is to delete the invalid rule.
Reference: [HZ80] <author> M. Hammer and S.B. Zdonik. </author> <title> Knowledge-based query processing. </title> <booktitle> In Proceedings of the Sixth International Conference on Very Large Data Bases, </booktitle> <pages> pages 137-147, </pages> <address> Montreal, </address> <month> October </month> <year> 1980. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [Kin81] <author> J. King. Quist: </author> <title> A system for semantic query optimization in relational databases. </title> <booktitle> In Proceedings of the Seventh International Conference on Very Large Data Bases, </booktitle> <pages> pages 510-517, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [Pit95] <author> J. Pittges. </author> <title> Metadata View Graphs: A Framework for Query Optimization and Metadata Management. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: The first process estimates the number of log pages that will be read and written to refresh a given view node. The second process updates the log map whenever the logs are processed. Algorithms for these processes, and other implementation details, are given in <ref> [Pit95] </ref>. 20 4.3 Managing View Nodes The previous section presented several strategies for managing update logs. This section will discuss the problem of managing nodes in the View Network, primarily how to organize and the store the nodes on disk.
Reference: [PMN95] <author> J. Pittges, L. Mark, and S. Navathe. </author> <title> Metadata view graphs: A framework for query optimization and metadata management. </title> <journal> ACM Transactions on Information Systems, </journal> <year> 1995. </year> <month> Submitted November </month> <year> 1994. </year>
Reference-contexts: Section 2 describes the Metadata View Graph, Section 3 illustrates how query execution plans are selected at run-time, Section 4 presents our maintenance algorithms, and the last section contains our concluding remarks. 2 2 Metadata View Graphs The Metadata View Graph <ref> [PMN95] </ref> is a metadatabase capable of maintaining semantic, statistical, and structural metadata for views of a database. As shown in Figure 1, the Metadata View Graph consists of four components: (1) a lexicon, (2) a semantic network, (3) a view network, and (4) a QEP Network.
Reference: [Rou82] <author> N. Roussopoulos. </author> <title> The logical access path scheme of a database. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-8(6):563-573, </volume> <month> November </month> <year> 1982. </year>
Reference-contexts: The semantic network captures domain knowledge and can be used to disambiguate queries. The lexicon and semantic network are used for query interpretation and will not be discussed further. The View Network is an extension of Roussopoulos' Logical Access Path schema <ref> [Rou82] </ref>. The View Network stores semantic, statistical, and structural metadata that improves query optimization. The view nodes in the network (V 1 V 11 in Figure 1) represent views of the database and store metadata specific to the particular data set. The links represent logical operations and semantic relationships.
Reference: [SO89] <author> S.T. Shenoy and Z.M. Ozsoyoglu. </author> <title> Design and implementation of a semantic query optimizer. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 344-361, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [SSD92] <author> S. Shekhar, J. Srivastava, and S. Dutta. </author> <title> A formal model of trade-off between optimization and execution costs in semantic query optimization. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 8 </volume> <pages> 131-151, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful.
Reference: [SSS92] <author> M. Siegel, E. Sciore, and S. Salveter. </author> <title> A method for automatic rule derivation to support semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(4) </volume> <pages> 563-600, </pages> <month> December </month> <year> 1992. </year> <month> 27 </month>
Reference-contexts: 1 Introduction Previous experimental results have shown that semantic query optimization may significantly reduce query execution time by reformulating a query into a semantically equivalent query that is more efficient to execute <ref> [HK94, HK93, SSS92, SSD92, CGM90, SO89, Kin81, HZ80] </ref>. Semantic query optimization has traditionally derived transformation rules from schema-based constraints which are valid for all instances of a database. However, schema-based constraints are often difficult to define and are typically too general to be useful. <p> Although several researchers have acknowledged the need to maintain dynamic rules <ref> [YS89, SSS92] </ref>, no one has formally addressed the problem. This paper presents a set of strategies, methods, and algorithms for maintaining dynamic semantic rules in the Metadata View Graph Framework. The rest of the paper is organized as follows. <p> Once the update logs have been processed and the view node to refreshed has been retrieved, exceptions can be detected using well-established integrity checking algorithms [Bla81, HS78]. Once a rule becomes invalid, the rule must be invalidated or rewritten. As described in <ref> [SSS92] </ref>, there are four methods for handling invalid rules. The simplest approach is to delete the invalid rule. However, deleting the rule may invalidate a semantic plan that is still valid for the current state of the database.
Reference: [YS89] <author> C. Yu and W. Sun. </author> <title> Automatic knowledge acquisition and maintenance for seman-tic query optimization. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 362-375, </pages> <month> September </month> <year> 1989. </year> <month> 28 </month>
Reference-contexts: Although several researchers have acknowledged the need to maintain dynamic rules <ref> [YS89, SSS92] </ref>, no one has formally addressed the problem. This paper presents a set of strategies, methods, and algorithms for maintaining dynamic semantic rules in the Metadata View Graph Framework. The rest of the paper is organized as follows.
References-found: 20

