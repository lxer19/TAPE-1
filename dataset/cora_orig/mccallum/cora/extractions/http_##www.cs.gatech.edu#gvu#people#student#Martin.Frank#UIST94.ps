URL: http://www.cs.gatech.edu/gvu/people/student/Martin.Frank/UIST94.ps
Refering-URL: http://www.cs.gatech.edu/gvu/people/student/Martin.Frank.html
Root-URL: 
Title: A Pure Reasoning A Pure Reasoning Engine for Programming By Demonstration design environment that provides
Author: Frank, M. and Foley J. En g in e f o r Pr o g ra m mi ng B D e mo ns tr a t io n. I n Martin R. Frank James D. Foley 
Keyword: Programming by Demonstration.  
Affiliation: Graphics, Visualization Usability Center Georgia Institute of Technology  
Address: Marina del Rey, California) ACM, New York,  Atlanta, Georgia 30332-0280  
Note: This is  Proceedings of UIST94, ACM Symposium on User Interface Software and Technology, (November 2-4,  The engine can easily be incorporated into an existing  The first goal, responsiveness, is best accommodated by  This, however is in obvious  
Email: -martin,foley-@cc.gatech.edu  
Phone: 1994.  (404) 853-9382 (404) 853-0672  
Abstract: We present an inference engine that can be used for creating Programming By Demonstration systems. The class of systems addressed are those which infer a state change description from examples of state [9,11]. The main design goals of the inference engine are responsiveness and generality. All demonstrational systems must respond quickly because of their interactive use. They should also be general - they should be able to make inferences for any attribute that the user may want to def ine by demonstration, and they should be able to treat any other attributes as parameters of this definition. This conflict is intrinsic to the class of demonstrational system described above. The challenge is to f ind an algorithm which responds quickly but does not heuristically limit the number of attributes it looks at. We present such an algorithm in this paper. A companion paper describes Inference Bear [4], an actual demonstrational system that we have built using this inference engine and an existing user interface builder [5]. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Cypher, A. Eager: </author> <title> Programming Repetitive Tasks by Example. </title> <booktitle> In Proceedings of CHI91 (Apr. </booktitle> <address> 27-May. 2, New Orleans, </address> <publisher> LA) ACM, </publisher> <address> N.Y., </address> <year> 1991, </year> <pages> pp. 33-39. </pages>
Reference-contexts: These systems can often infer relationships from a single example. Other systems that are not addressed are those that automate repetition by watching the user , such as Eager <ref> [1] </ref> and M e t a m o u s e [ 7 ] .
Reference: 2. <author> Cypher, A., Ed. </author> <title> Watch What I Do: Pr ogramming By Demonstration. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address> <year> 1993. </year>
Reference-contexts: They can then demonstrate how user interface elements are created, deleted and modified in response to runtime events. Programming By Demonstration is a young discipline which has just recently emer ged as a recognized subfield of user interface software <ref> [2] </ref>. This becomes apparent when one compares the prototypes that have been built - the most striking observation is that each one uses a unique approach and that most are tightly coupled to the domain they were built for. <p> Other systems that are not addressed are those that automate repetition by watching the user , such as Eager [1] and M e t a m o u s e [ 7 ] . A I D E ( i n <ref> [ 2 ] </ref> ) i s a p r o p o s e d d o m a i n independent f r a m e w o r k f o r t h i s c l a s s o f demonstrational system.
Reference: 3. <author> Fisher, G., Busse, D. </author> <title> Adding Rule-Based Reasoning to a Demonstrational Interface Builder. </title> <booktitle> In Proceedings of UIST92 (Nov. </booktitle> <pages> 15-18, </pages> <address> Monterey, </address> <publisher> Cal.) ACM, </publisher> <address> N.Y., </address> <year> 1992, </year> <pages> pp. 89-97. </pages>
Reference-contexts: The best solution may be to combine both approaches by first checking if domainspecific rules fire and by then falling back on a domain-independent reasoning engine such as ours. At least one demonstrational system has used such a hybrid approach <ref> [3] </ref>. The solution is correct for the given examples. Correct here means that the resulting generalized state change description will indeed work for each of the examples you provided.
Reference: 4. <author> Frank, M., and Foley, J. </author> <title> Inference Bear: Inferring Behavior from Before and After Snapshots . Technical Report git-gvu-94-12, </title> <institution> Georgia Institute of Technology, Graphics, Visualization and Usability Center, </institution> <month> Apr. </month> <year> 1994. </year> <note> (available via: http://www.gatech.edu/gvu/gvutop.html) </note>
Reference: 5. <author> Khme, T., and Schneider-Hufschmidt, M. </author> <title> SX/Tools A n O p e n D e s i g n E n v i r o n m e n t f o r A d a p t a b l e Multimedia User Interfaces. </title> <booktitle> Computer Graphics Forum 1, </booktitle> <address> 3 (Sept. </address> <year> 1992), </year> <pages> pp. 93-105. </pages>
Reference: 6. <author> Kurlander, D., and Feiner, S. </author> <title> Inferring Constraints from Multiple Snapshots. </title> <journal> ACM Transactions On Graphics 12, </journal> <month> 4 (Oct. </month> <year> 1993), </year> <pages> pp. 277-304. </pages>
Reference-contexts: This subclass consists of systems that infer a generalized state change description given several examples of state. Existing demonstrational systems that fall into that category are DEMO [11] and the Geometric Interactive Technique Solver [9]. The constraint solver of Chimera <ref> [6] </ref> roughly falls into this class, but has no notion of time - it uses valid states rather than before and after states. 2 Demonstrational systems not addressed by our engine include those that use a domainspecific rule base to guess relationships between objects, such as Peridot [8] and Druid [10].
Reference: 7. <author> Maulsby, D., Witten, I., and Kittlitz, K. Metamouse: </author> <title> Specifying Graphical Procedures by Example. </title> <booktitle> In Proceedings of Siggraph89 (Jul. </booktitle> <address> 31-Aug. 4, Boston, Mass.) </address> <publisher> ACM, </publisher> <address> N.Y., </address> <year> 1989, </year> <pages> pp. 127-136. </pages>
Reference-contexts: These systems can often infer relationships from a single example. Other systems that are not addressed are those that automate repetition by watching the user , such as Eager [1] and M e t a m o u s e <ref> [ 7 ] </ref> .
Reference: 8. <author> Myers, B. </author> <title> Creating User Interfaces By Demonstration . Academic Press, </title> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: solver of Chimera [6] roughly falls into this class, but has no notion of time - it uses valid states rather than before and after states. 2 Demonstrational systems not addressed by our engine include those that use a domainspecific rule base to guess relationships between objects, such as Peridot <ref> [8] </ref> and Druid [10]. These systems can often infer relationships from a single example. Other systems that are not addressed are those that automate repetition by watching the user , such as Eager [1] and M e t a m o u s e [ 7 ] . <p> It does not guess. A specialized demonstrational system can incorporate domain knowledge to help it make inferences. For example, Peridot <ref> [8] </ref> has built-in knowledge about the concepts of centering and aligning. This allows it to guess the user s intention when they are centering elements, making the system easy to use.
Reference: 9. <author> Olsen, D., and Allan, K. </author> <title> Creating Interactive Techniques by Symbolically Solving Geometric Constraints. </title> <booktitle> In Proceedings of UIST90 (Oct. </booktitle> <pages> 3-5, </pages> <address> Snowbird, Utah), </address> <publisher> ACM, </publisher> <address> N.Y., </address> <year> 1990, </year> <pages> pp. 102-107. </pages>
Reference-contexts: We present such an engine which addresses a subclass of demonstrational systems. This subclass consists of systems that infer a generalized state change description given several examples of state. Existing demonstrational systems that fall into that category are DEMO [11] and the Geometric Interactive Technique Solver <ref> [9] </ref>.
Reference: 10. <author> Singh, G., Kok, C. and Ngan, T . Druid: </author> <title> A System For Demonstrational Rapid User Interface Development. </title> <booktitle> In Proceedings of UIST90 (Oct. </booktitle> <pages> 3-5, </pages> <address> Snowbird, Utah), </address> <publisher> ACM, </publisher> <address> N.Y., </address> <year> 1990, </year> <pages> pp. 167-177. </pages>
Reference-contexts: [6] roughly falls into this class, but has no notion of time - it uses valid states rather than before and after states. 2 Demonstrational systems not addressed by our engine include those that use a domainspecific rule base to guess relationships between objects, such as Peridot [8] and Druid <ref> [10] </ref>. These systems can often infer relationships from a single example. Other systems that are not addressed are those that automate repetition by watching the user , such as Eager [1] and M e t a m o u s e [ 7 ] .
Reference: 11. <author> Wolber, D., and Fisher, G. </author> <title> A Demonstrational Technique For Developing Interfaces With Dynamically Created Objects. </title> <booktitle> In Proceedings of UIST91 (Nov. </booktitle> <pages> 11-13, </pages> <address> Hilton Head, S.C.), </address> <publisher> ACM, </publisher> <address> N.Y., </address> <year> 1991, </year> <pages> pp. 221-230. </pages>
Reference-contexts: We present such an engine which addresses a subclass of demonstrational systems. This subclass consists of systems that infer a generalized state change description given several examples of state. Existing demonstrational systems that fall into that category are DEMO <ref> [11] </ref> and the Geometric Interactive Technique Solver [9]. <p> A demonstration can consist of a single example for simple behavior or two or more examples for more complex behavior. An example consists of a Before snapshot, a parameterized event, and an After snapshot. The event is the stimulus, the After snapshot the response in the terminology of <ref> [11] </ref> (the Before snapshot provides context). The inference engine generalizes from the examples and returns a script. A script describes a change of state triggered by an event. Scripts can create, delete and change objects.
References-found: 11

