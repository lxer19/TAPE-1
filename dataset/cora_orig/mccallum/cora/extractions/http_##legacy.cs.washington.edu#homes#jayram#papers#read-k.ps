URL: http://legacy.cs.washington.edu/homes/jayram/papers/read-k.ps
Refering-URL: http://legacy.cs.washington.edu/homes/jayram/
Root-URL: http://www.cs.washington.edu
Title: On Separating the Read-k-Times Branching Program Hierarchy  
Author: Jayram S. Thathachar 
Note: n  
Date: January 12, 1998  
Abstract: We obtain an exponential separation between consecutive levels in the hierarchy of classes of functions computable by polynomial-size syntactic read-k-times branching programs, for all k &gt; 0, as conjectured by various authors [Weg87, SS93, Pon95]. For every k, we exhibit two explicit functions that can be com jo to be computed by any read-k-times branching program. The result actually gives the strongest possible separation | the exponential lower bound applies to both non-deterministic read-k-times branching programs and randomized read-k-times branching programs with 2-sided error ", for some " &gt; 0. The only previously known results are the separation between k = 1 and k = 2 [BRS93] and a separation of non-deterministic read-k from deterministic read-(k ln k= ln 2 + C), where C is some appropriate constant, for each k [Oko97]. A simple corollary of our results is that randomization is not more powerful than non-determinism for read-k-times branching programs. A combinatorial result that we prove along the way is a "hash-mixing lemma" (see [MNT93]) for families of hash functions that are almost universal, which may be of independent interest. puted by linear-sized read-(k+1)-times branching programs but require size exp
Abstract-found: 1
Intro-found: 1
Reference: [BCL + 94] <author> J.R. Burch, E.M. Clarke, D.E. Long, K.L. MacMillan, and D.L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Another important motivation for studying read-restricted variants is that some of them are used in practice as data structures for boolean functions. For example, ordered read-once branching programs [Bry86], also known as OBDDs, have been applied in computer-aided design as tools for hardware verification and symbolic model checking <ref> [BCL + 94] </ref>. Unordered read-once branching programs have also shown some promise in this regard [GM94, SW95].
Reference: [Bor93] <author> Borodin. </author> <title> Time-space tradeoffs (getting closer to the barrier?). </title> <booktitle> In ISAAC: 4th International Symposium on Algorithms and Computation, </booktitle> <pages> pages 209-220, </pages> <year> 1993. </year>
Reference-contexts: However, the best size lower bound for an explicit function in N P is ( n 2 log 2 n ) due to Neciporuk [Nec66] (see, also [BS90]). Branching programs are also useful for studying time-space tradeoffs (see <ref> [Bor93] </ref> for a survey of results and open problems). It is a major open problem to exhibit a function that requires super-polynomial size branching programs of linear length. Such a result would imply that there are functions that cannot be simultaneously computed in log-space and linear time.
Reference: [BRS93] <author> Borodin, Razborov, and Smolensky. </author> <title> On lower bounds for read-k-times branching programs. </title> <journal> Computational Complexity, </journal> <volume> 3 </volume> <pages> 1-18, </pages> <year> 1993. </year>
Reference-contexts: Wegener [Weg87] conjectured that the hierarchy of classes of functions computable by polynomial-size read-k-times branching programs, for k 1, is proper. Borodin, Razborov and Smolensky <ref> [BRS93] </ref> observed (and clarified) that there are actually two potentially different classes of read-k-times branching programs that can be considered | the semantic type where the restriction on multiple reads applies only to computational paths and syntactic type where this restriction applies to the non-computational paths as well (for k = <p> For k 2, no non-trivial bounds have been proved for semantic read-k-times branching programs. On the other hand, for the syntactic model, Borodin et al. <ref> [BRS93] </ref> were able to show exponential size bounds for some explicit function, for each k c log n, where c is some appropriate constant. Here again, a natural problem is to separate the syntactic read-k-times branching program hierarchy for k 2. <p> An easy corollary of our result is that randomization is not more powerful than non-determinism for read-k-times branching programs. Our results and proof techniques are inspired by the work of Borodin et al. <ref> [BRS93] </ref>, Ponzio [Pon97] and Sauerhoff [Sau97b]. It is evident that lower bounds, hierarchy and separation results contribute to our understanding of branching program based complexity classes. <p> For randomized read-k-times branching programs, Sauerhoff [Sau97a] has exhibited exponential size bounds for the same function considered by Borodin et al. <ref> [BRS93] </ref>. Some authors have considered further restrictions of read-k-times branching programs. For example, k-OBDDs [BSSW93] are branching programs that can be partitioned into k layers such that each layer uses the same order to access the variables. <p> The Lower Bound Technique Non-deterministic and randomized branching programs are natural generalizations of deterministic branching programs analogous to other computing models such as Turing machines. We refer the reader to [Raz91] for a formal definition of these and related models. Recall that in a non-deterministic branching program <ref> [BRS93] </ref>, the edges are either unlabeled or labeled with "x = 0" or "x = 1", for some variable x. The inputs for which it computes a 1 are those that have at least one consistent path 4 from the source to an accepting sink. <p> Intuitively, R = R 0 ^ R 00 , where only R 0 depends on S and only R 00 depends on T and they share common variables Xn (S [T ). The motivation for this definition is the following: Borodin et al. <ref> [BRS93] </ref> showed that one way to prove lower bounds on the sizes of non-deterministic read-k-times branching programs computing a boolean function f is to analyze the "covering" of the satisfying assignments of f by special types of functions called "(k; p)-rectangles". (Similar approaches were taken by Okolnishnikova [Oko93] and Sauerhoff [Sau97a] <p> We now show that (k; p)-rectangles can be transformed to pseudo-rectangles, for a suitable choice of p. This strengthens the arguments in Borodin et al. <ref> [BRS93] </ref> who obtain a similar but somewhat weaker result for functions that are defined on a pair of variable sets. 5 Lemma 4: Let X be a variable set of size N and set p = 144 k 2 k .
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Thus, the arguments do not apply to general syntactic read-k-times branching programs. Another important motivation for studying read-restricted variants is that some of them are used in practice as data structures for boolean functions. For example, ordered read-once branching programs <ref> [Bry86] </ref>, also known as OBDDs, have been applied in computer-aided design as tools for hardware verification and symbolic model checking [BCL + 94]. Unordered read-once branching programs have also shown some promise in this regard [GM94, SW95].
Reference: [BS90] <author> Boppana and Sipser. </author> <title> The complexity of finite functions. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <editor> Ed. Jan van Leeuwen (Volume A (= "1"). </editor> <publisher> Elsevier and MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: A superpolynomial size lower bound for a function f would imply that f is not computable in non-uniform log-space. However, the best size lower bound for an explicit function in N P is ( n 2 log 2 n ) due to Neciporuk [Nec66] (see, also <ref> [BS90] </ref>). Branching programs are also useful for studying time-space tradeoffs (see [Bor93] for a survey of results and open problems). It is a major open problem to exhibit a function that requires super-polynomial size branching programs of linear length.
Reference: [BSSW93] <author> B. Bollig, M. Sauerhoff, D. Sieling, and I. Wegener. </author> <title> Read k times ordered binary decision diagrams efficient algorithms in the presence of null chains. </title> <type> Technical Report Forschungs-bericht Nr. 474, </type> <institution> Universitat Dortmund, </institution> <year> 1993. </year>
Reference-contexts: For randomized read-k-times branching programs, Sauerhoff [Sau97a] has exhibited exponential size bounds for the same function considered by Borodin et al. [BRS93]. Some authors have considered further restrictions of read-k-times branching programs. For example, k-OBDDs <ref> [BSSW93] </ref> are branching programs that can be partitioned into k layers such that each layer uses the same order to access the variables. Although separation results are known for such models, they are even weaker than oblivious branching programs.
Reference: [GM94] <author> J. Gergov and C. Meinel. </author> <title> Efficient analysis and manipulation of OBDDs can be extended to FBDDs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43 </volume> <pages> 1197-1209, </pages> <year> 1994. </year> <month> Techreport 92-10. </month>
Reference-contexts: For example, ordered read-once branching programs [Bry86], also known as OBDDs, have been applied in computer-aided design as tools for hardware verification and symbolic model checking [BCL + 94]. Unordered read-once branching programs have also shown some promise in this regard <ref> [GM94, SW95] </ref>.
Reference: [Gou72] <author> H. W. Gould. </author> <title> Combinatorial identities; A Standardized Set of Tables Listing 500 Binomial Coefficient Summations. </title> <editor> Morgantown, W. </editor> <address> Va., </address> <year> 1972. </year>
Reference-contexts: The number S of solutions z 2 f1; 1g n to the equation u z j c (mod q) is exactly given by the formula (e.g., see <ref> [Gou72] </ref>) 1 X ! cs Y (! u j s + ! u j s ) = q 1 X ! cs Y (! u j s + ! u j s ): Let jj denote the magnitude of a complex number.
Reference: [KN97] <author> Eyal Kushilevitz and Noam Nisan. </author> <title> Communication complexity. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge [England] ; New York, </address> <year> 1997. </year>
Reference-contexts: as considered in communication complexity and (b) but for the coefficients c and u i 's, the polynomial H 1 d ae (A [ B) is similar to the standard inner product function over GF (q) | a function which has been studied extensively in communication complexity (for example, see <ref> [KN97] </ref>). An important difference that makes the problem non-trivial is that the assignments to the a i 's and the b i 's are distributed over f1; 1g m rather than GF (q) m .
Reference: [MNT93] <author> Y. Mansour, N. Nisan, and P. Tiwari. </author> <title> The computational complexity of universal hashing. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 121-133, </pages> <year> 1993. </year>
Reference-contexts: of the important features of our techniques are (i) a combinatorial argument that reduces the lower bound problem to analyzing the structure of pseudo-rectangles (Section 3), (ii) interesting properties about the structure of the two hyperplanar predicates and (iii) an analogue of the "hash-mixing lemma" of Mansour, Nisan and Tiwary <ref> [MNT93] </ref> for almost universal families of hash functions (Section 4.2), which may be of independent interest. For the rest of the paper, we deal only with the syntactic variant of read-k-times branching programs. <p> oe 2 H such that for any assignment to B h oe () = H 1 d ae (oe; ) = i Ideally, we want to say that H is a universal family of hash functions and then argue that the distribution in any rectangle is balanced (as done in <ref> [MNT93] </ref>, for example). But H is not a universal family; for example, when m = 1, h 2 H is not uniform over GF (q) because it can output only 2 values in GF (q). <p> Note: When ffi = 0, we obtain the standard universal family of hash functions. In our applications, ffi will be exponentially small in jIj. The following lemma, which generalizes the well-known "hash-mixing lemma" <ref> [MNT93] </ref>, shows that rectangles corresponding to almost universal families of hash functions are "balanced". It will be proved in the next section. 12 Lemma 12: Let H = fh : I ! Og be a ffi-almost universal family of hash functions. Let A I, G H, and B O.
Reference: [Nec66] <author> E. Neciporuk. </author> <title> On a Boolean function. </title> <journal> Soviet Math. Doklady, </journal> <volume> 7 </volume> <pages> 999-1000, </pages> <year> 1966. </year>
Reference-contexts: A superpolynomial size lower bound for a function f would imply that f is not computable in non-uniform log-space. However, the best size lower bound for an explicit function in N P is ( n 2 log 2 n ) due to Neciporuk <ref> [Nec66] </ref> (see, also [BS90]). Branching programs are also useful for studying time-space tradeoffs (see [Bor93] for a survey of results and open problems). It is a major open problem to exhibit a function that requires super-polynomial size branching programs of linear length.
Reference: [Oko93] <author> E. Okol'nishnikova. </author> <title> On lower bounds for branching programs. </title> <booktitle> Siberian Advances in Mathematics, </booktitle> <volume> 3(1) </volume> <pages> 152-166, </pages> <year> 1993. </year>
Reference-contexts: Our results and proof techniques are inspired by the work of Borodin et al. [BRS93], Ponzio [Pon97] and Sauerhoff [Sau97b]. It is evident that lower bounds, hierarchy and separation results contribute to our understanding of branching program based complexity classes. Okolnishnikova <ref> [Oko93] </ref> has given exponential lower bounds on the size of (deterministic) read-k-times branching programs computing some function, for k c log n= log log n, where c is some appropriate constant. <p> Borodin et al. [BRS93] showed that one way to prove lower bounds on the sizes of non-deterministic read-k-times branching programs computing a boolean function f is to analyze the "covering" of the satisfying assignments of f by special types of functions called "(k; p)-rectangles". (Similar approaches were taken by Okolnishnikova <ref> [Oko93] </ref> and Sauerhoff [Sau97a] for deterministic and randomized branching programs, respectively.) Although this reduction is a significant step, these rectangles are still too complex for our purposes.
Reference: [Oko97] <author> E. Okol'nishnikova. </author> <title> On the hierarchy of nondeterministic branching k-programs. </title> <booktitle> In Fundamentals of computation theory : 11th International Symposium, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 376-387, </pages> <address> Krakow, Poland, 1997. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Various authors [Pon95, SS93, Weg87] have worked on this problem and conjectured candidate predicates for separating the hierarchy for k 2; for example, Ponzio [Pon95] suggests looking at the generalization of the permutation matrix predicate in the k-dimensional hypercube. Okolnishnikova <ref> [Oko97] </ref> has made the only progress in this direction by showing that there are functions that can be computed by syntactic read-(k ln k= ln 2 + C)-times branching programs, for some constant C, but require exponential size non-deterministic syntactic read-k-times branching programs.
Reference: [Pon95] <author> Stephen Ponzio. </author> <title> Restricted Branching Programs and Hardware Verification. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Here again, a natural problem is to separate the syntactic read-k-times branching program hierarchy for k 2. Various authors <ref> [Pon95, SS93, Weg87] </ref> have worked on this problem and conjectured candidate predicates for separating the hierarchy for k 2; for example, Ponzio [Pon95] suggests looking at the generalization of the permutation matrix predicate in the k-dimensional hypercube. <p> Here again, a natural problem is to separate the syntactic read-k-times branching program hierarchy for k 2. Various authors [Pon95, SS93, Weg87] have worked on this problem and conjectured candidate predicates for separating the hierarchy for k 2; for example, Ponzio <ref> [Pon95] </ref> suggests looking at the generalization of the permutation matrix predicate in the k-dimensional hypercube. <p> replace each node and its two outgoing edges with an appropriate branching program computing h.) For example, the generalization of the permutation predicate to k dimensions, ... ... ... 1 X n 2 X n k X n h h h h h h h h h conjectured by Ponzio <ref> [Pon95] </ref> to separate the read-k-times hierarchy, can be easily seen to belong to this class.
Reference: [Pon97] <author> Stephen Ponzio. </author> <title> Towards a new lower bound for read-twice branching programs. </title> <type> Private Communication, </type> <year> 1997. </year>
Reference-contexts: An easy corollary of our result is that randomization is not more powerful than non-determinism for read-k-times branching programs. Our results and proof techniques are inspired by the work of Borodin et al. [BRS93], Ponzio <ref> [Pon97] </ref> and Sauerhoff [Sau97b]. It is evident that lower bounds, hierarchy and separation results contribute to our understanding of branching program based complexity classes. <p> The following combinatorial lemma forms the basis for the proof of Theorem 6; it is inspired by the k = 2 case due to Ponzio <ref> [Pon97] </ref>. Lemma 5: Let S and T be disjoint sets of variables in the (k+1)-dimensional hypercube [1; n] k+1 each having size at least (2=3) N=2 k , where N = n k+1 .
Reference: [Raz91] <author> A. A. Razborov. </author> <title> Lower bounds for deterministic and nondeterministic branching programs. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 529 </volume> <pages> 47-61, </pages> <year> 1991. </year>
Reference-contexts: 1. Introduction Branching programs and their many variants have long been a popular model for studying the complexity of functions (see, for example, the survey paper of Razborov <ref> [Raz91] </ref>). <p> The case k = 1, i.e. read-once branching programs, is well understood and a variety of lower bound and separation results have been shown for it (see <ref> [Raz91] </ref> for an overview, [SS93] for an overview and summary of proof techniques and [Sau97b] for a discussion on the separation results). Wegener [Weg87] conjectured that the hierarchy of classes of functions computable by polynomial-size read-k-times branching programs, for k 1, is proper. <p> The Lower Bound Technique Non-deterministic and randomized branching programs are natural generalizations of deterministic branching programs analogous to other computing models such as Turing machines. We refer the reader to <ref> [Raz91] </ref> for a formal definition of these and related models. Recall that in a non-deterministic branching program [BRS93], the edges are either unlabeled or labeled with "x = 0" or "x = 1", for some variable x.
Reference: [Sau97a] <author> M. Sauerhoff. </author> <title> A lower bound for randomized read-k-times branching programs. Technical Report TR-97-019, </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <year> 1997. </year>
Reference-contexts: Okolnishnikova [Oko93] has given exponential lower bounds on the size of (deterministic) read-k-times branching programs computing some function, for k c log n= log log n, where c is some appropriate constant. For randomized read-k-times branching programs, Sauerhoff <ref> [Sau97a] </ref> has exhibited exponential size bounds for the same function considered by Borodin et al. [BRS93]. Some authors have considered further restrictions of read-k-times branching programs. <p> The inputs for which it computes a 1 are those that have at least one consistent path 4 from the source to an accepting sink. A randomized branching program <ref> [Sau97a] </ref> is syntactically similar to a deterministic branching program and has two types of variables | input variables and stochastic variables. <p> [BRS93] showed that one way to prove lower bounds on the sizes of non-deterministic read-k-times branching programs computing a boolean function f is to analyze the "covering" of the satisfying assignments of f by special types of functions called "(k; p)-rectangles". (Similar approaches were taken by Okolnishnikova [Oko93] and Sauerhoff <ref> [Sau97a] </ref> for deterministic and randomized branching programs, respectively.) Although this reduction is a significant step, these rectangles are still too complex for our purposes.
Reference: [Sau97b] <author> M. Sauerhoff. </author> <title> On nondeterminism versus randomness for read-once branching programs. Technical Report TR-97-030, </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <year> 1997. </year> <month> 18 </month>
Reference-contexts: The case k = 1, i.e. read-once branching programs, is well understood and a variety of lower bound and separation results have been shown for it (see [Raz91] for an overview, [SS93] for an overview and summary of proof techniques and <ref> [Sau97b] </ref> for a discussion on the separation results). Wegener [Weg87] conjectured that the hierarchy of classes of functions computable by polynomial-size read-k-times branching programs, for k 1, is proper. <p> An easy corollary of our result is that randomization is not more powerful than non-determinism for read-k-times branching programs. Our results and proof techniques are inspired by the work of Borodin et al. [BRS93], Ponzio [Pon97] and Sauerhoff <ref> [Sau97b] </ref>. It is evident that lower bounds, hierarchy and separation results contribute to our understanding of branching program based complexity classes.
Reference: [SS93] <author> Janos Simon and Mario Szegedy. </author> <title> A new lower bound theorem for read only once branching programs and its applications. </title> <booktitle> In Advances in COmputational Complexity (J. Cai, editor), volume 13 of DIMACS Series in Discrete Mathematics, </booktitle> <pages> pages 183-193. </pages> <publisher> AMS, </publisher> <year> 1993. </year>
Reference-contexts: The case k = 1, i.e. read-once branching programs, is well understood and a variety of lower bound and separation results have been shown for it (see [Raz91] for an overview, <ref> [SS93] </ref> for an overview and summary of proof techniques and [Sau97b] for a discussion on the separation results). Wegener [Weg87] conjectured that the hierarchy of classes of functions computable by polynomial-size read-k-times branching programs, for k 1, is proper. <p> Here again, a natural problem is to separate the syntactic read-k-times branching program hierarchy for k 2. Various authors <ref> [Pon95, SS93, Weg87] </ref> have worked on this problem and conjectured candidate predicates for separating the hierarchy for k 2; for example, Ponzio [Pon95] suggests looking at the generalization of the permutation matrix predicate in the k-dimensional hypercube.
Reference: [SW95] <author> Detlef Sieling and Ingo Wegener. </author> <title> Graph driven BDDs|a new data structure for Boolean functions. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 141(1-2):283-310, </address> <month> 17 April </month> <year> 1995. </year>
Reference-contexts: For example, ordered read-once branching programs [Bry86], also known as OBDDs, have been applied in computer-aided design as tools for hardware verification and symbolic model checking [BCL + 94]. Unordered read-once branching programs have also shown some promise in this regard <ref> [GM94, SW95] </ref>.
Reference: [Weg87] <author> Ingo Wegener. </author> <title> The Complexity of Boolean Functions. </title> <publisher> B.G. Teubner, </publisher> <address> Stuttgart, 1 edition, </address> <year> 1987. </year>
Reference-contexts: Branching programs are an important abstraction of many computing models and are closely related to other well studied models of computation (see, for e.g. <ref> [Weg87] </ref>). In a natural way, the size and length measure the space and time, respectively, used in a computation. A superpolynomial size lower bound for a function f would imply that f is not computable in non-uniform log-space. <p> Since linear length implies that on average each variable is tested only a constant number of times on any path, researchers have looked at restricted variants of branching programs that capture this property in the hope of proving better bounds. Read-k-times branching programs (see <ref> [Weg87] </ref>) have the restriction that along each path from source to sink, each variable may be tested at most k times. <p> Wegener <ref> [Weg87] </ref> conjectured that the hierarchy of classes of functions computable by polynomial-size read-k-times branching programs, for k 1, is proper. <p> Here again, a natural problem is to separate the syntactic read-k-times branching program hierarchy for k 2. Various authors <ref> [Pon95, SS93, Weg87] </ref> have worked on this problem and conjectured candidate predicates for separating the hierarchy for k 2; for example, Ponzio [Pon95] suggests looking at the generalization of the permutation matrix predicate in the k-dimensional hypercube.
References-found: 21

