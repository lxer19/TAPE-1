URL: http://www.cs.cornell.edu/Info/People/ronitt/PAP/rs.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/ronitt/papers.html
Root-URL: 
Title: Robust Characterizations of Polynomials with Applications to Program Testing  
Author: Ronitt Rubinfeld Madhu Sudan 
Note: To appear: SIAM J. on Computing, manuscript no. 0255151.  
Abstract: The study of self-testing and self-correcting programs leads to the search for robust characterizations of functions. Here we make this notion precise and show such a characterization for polynomials. From this characterization, we get the following applications. We construct simple and efficient self-testers for polynomial functions. Our characterizations provide results in the area of coding theory, by giving extremely fast and efficient error-detecting schemes for some well known codes. This error-detection scheme plays a crucial role in subsequent results on the hardness of approximating some NP-optimization problems.
Abstract-found: 1
Intro-found: 1
Reference: [AHK] <author> L. Adleman, M. Huang, and K. Kompella. </author> <title> Efficient checkers for number-theoretic computations. </title> <note> Submitted to Information and Computation. </note>
Reference-contexts: For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91].
Reference: [ALMSS92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and the intractability of approximation problems. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: The task of low-degree testing forms a central ingredient in the proof of MIP = NEXPTIME due to [BFL91]. The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations <ref> [FGLSS91, ALMSS92] </ref> and therefore a lot of attention has been paid to this problem [BFL91, BFLS91, FGLSS91, AS92]. However all these results focus on tests that are close variants of the test given in [BFL91]. <p> It turns out that this tester is particularly well-suited to such multiple prover applications and provides a one round, constant prover proof that a function is a low degree polynomial over finite fields. This is observed in subsequent work of <ref> [ALMSS92] </ref> (see also [Sud92]) and follows by using an improved analysis for Lemma 11 from [AS92]. This turns out to play a crucial role in the NP = PCP (log n; O (1)) result of [ALMSS92], which in turn provides hardness results for a wide variety of approximation problems. <p> This is observed in subsequent work of <ref> [ALMSS92] </ref> (see also [Sud92]) and follows by using an improved analysis for Lemma 11 from [AS92]. This turns out to play a crucial role in the NP = PCP (log n; O (1)) result of [ALMSS92], which in turn provides hardness results for a wide variety of approximation problems. An exact description of the relevance of the various testers and the chronology of contributions maybe found in Section 8. Organization of Paper The rest of this paper is organized as follows. <p> just p (randomly chosen) letters, the verifier can test if it close to a valid codeword and if not rejects it with probability at least ffi. 3 These definitions are motivated by subsequent work in the area of proof checking where our tester has found applications, most notably that of <ref> [ALMSS92] </ref>. 19 Definition 24 (Locally Testable Code) For a positive integer p and a positive real num-ber ffi, an (n; k; ; a)-code C over the alphabet is (p; ffi)-locally testable if the following exist * A probability space which can be efficiently sampled. * Functions q 1 ; q 2 <p> We consider especially probabilistically checkable proofs over a large alphabet in which number of alphabets that a verifier is allowed to probe is a parameter. This concept is an important ingredient in the recursive construction of probabilistically checkable proofs <ref> [AS92, ALMSS92, BGLR93] </ref> and is also of independent interest in complexity theory [LS91, FL92a]. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. <p> A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of <ref> [AS92, ALMSS92, FHS94, PS94, FS94] </ref>. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> However, the dependence of ffi on m, is inherent for such codes and ffi ! 0 as m ! 1. The Polynomial-Line Codes described in Section 7 seem to have no inherent reason why ffi should go to zero. This turns out to be indeed the case. <ref> [ALMSS92] </ref> observe that a combination of the analysis of [AS92] and that of Section 5 implies that there exists a constant ffi &gt; 0 such that the Polynomial-Line Codes are (2; ffi)- locally testable, provided that the field F is of cardinaltity at least d 2 . <p> As mentioned in Section 7 this translates into a proof of NP PCP [log; O (1); polylog; (1)] in <ref> [ALMSS92] </ref>. By employing the technique of recursive proof checking, due to [AS92], on such proof systems [ALMSS92] go on to prove that NP PCP [log; O (1); O (1); (1)]. <p> As mentioned in Section 7 this translates into a proof of NP PCP [log; O (1); polylog; (1)] in <ref> [ALMSS92] </ref>. By employing the technique of recursive proof checking, due to [AS92], on such proof systems [ALMSS92] go on to prove that NP PCP [log; O (1); O (1); (1)].
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <booktitle> In Proceedings of the 33rd Annual IEEE Symposium of the Foundations of Computer Science, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: For the case of polynomials over Z p , our testers are very simple and do not even need to multiply elements of the field. Our testers are the first testers that directly attempt to test the total degree of a polynomial (as opposed to the testers of <ref> [BFLS91, FGLSS91, AS92] </ref>, all of which test that the degree in each variable is not too large). <p> The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations [FGLSS91, ALMSS92] and therefore a lot of attention has been paid to this problem <ref> [BFL91, BFLS91, FGLSS91, AS92] </ref>. However all these results focus on tests that are close variants of the test given in [BFL91]. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. <p> This is observed in subsequent work of [ALMSS92] (see also [Sud92]) and follows by using an improved analysis for Lemma 11 from <ref> [AS92] </ref>. This turns out to play a crucial role in the NP = PCP (log n; O (1)) result of [ALMSS92], which in turn provides hardness results for a wide variety of approximation problems. <p> All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, [Sud92]). The robustness of 4 follows from the work of [BFL91] (see also <ref> [BFLS91, FGLSS91, AS92, Lun92] </ref>). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5. <p> We consider especially probabilistically checkable proofs over a large alphabet in which number of alphabets that a verifier is allowed to probe is a parameter. This concept is an important ingredient in the recursive construction of probabilistically checkable proofs <ref> [AS92, ALMSS92, BGLR93] </ref> and is also of independent interest in complexity theory [LS91, FL92a]. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. <p> This concept is an important ingredient in the recursive construction of probabilistically checkable proofs [AS92, ALMSS92, BGLR93] and is also of independent interest in complexity theory [LS91, FL92a]. The original definition of probabilistically checkable proofs is due to <ref> [AS92] </ref> based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. The particular choice of parameters made in the following definition is due to [BGLR93]. <p> A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of <ref> [AS92, ALMSS92, FHS94, PS94, FS94] </ref>. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in [BFL91, BFLS91] gives rise to good codes which also have nice local checkability property. A sequence of improvements [BFL91, BFLS91, FGLSS91] culminated in the work of <ref> [AS92] </ref> which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. The highlight of the work of [AS92] is that the locality bounds are independent of the degree of the polynomial that they work with. <p> A sequence of improvements [BFL91, BFLS91, FGLSS91] culminated in the work of <ref> [AS92] </ref> which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. The highlight of the work of [AS92] is that the locality bounds are independent of the degree of the polynomial that they work with. However, the dependence of ffi on m, is inherent for such codes and ffi ! 0 as m ! 1. <p> The Polynomial-Line Codes described in Section 7 seem to have no inherent reason why ffi should go to zero. This turns out to be indeed the case. [ALMSS92] observe that a combination of the analysis of <ref> [AS92] </ref> and that of Section 5 implies that there exists a constant ffi &gt; 0 such that the Polynomial-Line Codes are (2; ffi)- locally testable, provided that the field F is of cardinaltity at least d 2 . <p> As mentioned in Section 7 this translates into a proof of NP PCP [log; O (1); polylog; (1)] in [ALMSS92]. By employing the technique of recursive proof checking, due to <ref> [AS92] </ref>, on such proof systems [ALMSS92] go on to prove that NP PCP [log; O (1); O (1); (1)].
Reference: [Bab93] <author> L. Babai. </author> <title> Transparent (holographic) proofs. </title> <booktitle> Springer-Verlag Lecture Notes on Computer Science, 10th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <volume> 665 </volume> <pages> 525-533, </pages> <year> 1993. </year>
Reference: [BF90] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instances in multioracle queries. </title> <booktitle> In Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer Verlag LNCS 415, </publisher> <pages> pages 37-48, </pages> <year> 1990. </year>
Reference: [BF91] <author> L. Babai and L. Fortnow. Arithmetization: </author> <title> A new method in structural complexity theory. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 41-66, </pages> <year> 1991. </year>
Reference-contexts: For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91].
Reference: [BFL91] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: The testers given here define similar quantities related to low-degree polynomials and show similar approximate relationships. Such inequalities may be of independent interest. The task of low-degree testing forms a central ingredient in the proof of MIP = NEXPTIME due to <ref> [BFL91] </ref>. The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations [FGLSS91, ALMSS92] and therefore a lot of attention has been paid to this problem [BFL91, BFLS91, FGLSS91, AS92]. <p> The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations [FGLSS91, ALMSS92] and therefore a lot of attention has been paid to this problem <ref> [BFL91, BFLS91, FGLSS91, AS92] </ref>. However all these results focus on tests that are close variants of the test given in [BFL91]. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. <p> However all these results focus on tests that are close variants of the test given in <ref> [BFL91] </ref>. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. The efficiency of the tester shown here may also be found in [RS92]. <p> All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, [Sud92]). The robustness of 4 follows from the work of <ref> [BFL91] </ref> (see also [BFLS91, FGLSS91, AS92, Lun92]). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5. <p> Better analysis of some portions of our proof yields even better statements about the Polynomial-Line Codes. This is described in the next section. 8 Conclusions There has been a spate of results about low-degree tests in the last few years. A brief listing includes the low-degree test of <ref> [BFL91, Lun92] </ref> which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results. <p> Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of <ref> [BFL91, BFLS91] </ref>. Program checking The test of [BFL91][Lun92], in the program checking setting allows the self-tester to be convinced that the program is computing a multivariate polynomial 21 function of low degree in polynomial time. <p> Relationship with proof checking. The low-degree tester forms a crucial ingredient in the recent results on proof checking. Our result from Section 4 gives a very simple proof of one of the relatively hard parts of the proof of MIP=NEXPTIME shown by <ref> [BFL91] </ref>. The hardness of the analysis of the tester of [BFL91] (and its simplifications, see for instance, [FGLSS91]) is in their need to rely on the isoperimetric properties of the m-dimensional grid. <p> The low-degree tester forms a crucial ingredient in the recent results on proof checking. Our result from Section 4 gives a very simple proof of one of the relatively hard parts of the proof of MIP=NEXPTIME shown by <ref> [BFL91] </ref>. The hardness of the analysis of the tester of [BFL91] (and its simplifications, see for instance, [FGLSS91]) is in their need to rely on the isoperimetric properties of the m-dimensional grid. Our proof on the other hand does not seem to require any combinatorics, and is instead based on elementary algebraic/probabilistic techniques. <p> This difference may be explained as follows: The success of the test does indeed depend on the isoperimetric properties of a graph related to the neighborhood structure. In the case of the test of <ref> [BFL91] </ref> this graph turns out to be in the m-dimensional grid. In our case, the underlying graph turns out to be a complete graph. This graph is obviously much easier to analyse for its properties and hence the proof is devoid of any combinatorial statements. <p> We now describe some of the subsequent results and the role of our tester in these results. The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in <ref> [BFL91, BFLS91] </ref> gives rise to good codes which also have nice local checkability property. A sequence of improvements [BFL91, BFLS91, FGLSS91] culminated in the work of [AS92] which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. <p> The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in [BFL91, BFLS91] gives rise to good codes which also have nice local checkability property. A sequence of improvements <ref> [BFL91, BFLS91, FGLSS91] </ref> culminated in the work of [AS92] which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. The highlight of the work of [AS92] is that the locality bounds are independent of the degree of the polynomial that they work with.
Reference: [BFLS91] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91]. <p> For the case of polynomials over Z p , our testers are very simple and do not even need to multiply elements of the field. Our testers are the first testers that directly attempt to test the total degree of a polynomial (as opposed to the testers of <ref> [BFLS91, FGLSS91, AS92] </ref>, all of which test that the degree in each variable is not too large). <p> The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations [FGLSS91, ALMSS92] and therefore a lot of attention has been paid to this problem <ref> [BFL91, BFLS91, FGLSS91, AS92] </ref>. However all these results focus on tests that are close variants of the test given in [BFL91]. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. <p> All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, [Sud92]). The robustness of 4 follows from the work of [BFL91] (see also <ref> [BFLS91, FGLSS91, AS92, Lun92] </ref>). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5. <p> The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of <ref> [BFLS91] </ref>. The particular choice of parameters made in the following definition is due to [BGLR93]. <p> This is described in the next section. 8 Conclusions There has been a spate of results about low-degree tests in the last few years. A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of <ref> [BFLS91, FGLSS91] </ref> obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of <ref> [BFL91, BFLS91] </ref>. Program checking The test of [BFL91][Lun92], in the program checking setting allows the self-tester to be convinced that the program is computing a multivariate polynomial 21 function of low degree in polynomial time. <p> We now describe some of the subsequent results and the role of our tester in these results. The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in <ref> [BFL91, BFLS91] </ref> gives rise to good codes which also have nice local checkability property. A sequence of improvements [BFL91, BFLS91, FGLSS91] culminated in the work of [AS92] which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. <p> The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in [BFL91, BFLS91] gives rise to good codes which also have nice local checkability property. A sequence of improvements <ref> [BFL91, BFLS91, FGLSS91] </ref> culminated in the work of [AS92] which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. The highlight of the work of [AS92] is that the locality bounds are independent of the degree of the polynomial that they work with.
Reference: [BGLR93] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year> <month> 23 </month>
Reference-contexts: We consider especially probabilistically checkable proofs over a large alphabet in which number of alphabets that a verifier is allowed to probe is a parameter. This concept is an important ingredient in the recursive construction of probabilistically checkable proofs <ref> [AS92, ALMSS92, BGLR93] </ref> and is also of independent interest in complexity theory [LS91, FL92a]. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. <p> The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. The particular choice of parameters made in the following definition is due to <ref> [BGLR93] </ref>.
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Program correctness checking : : : and the design of programs that check their work. </title> <booktitle> In Proceedings of the 21st Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: at Berkeley under the support of NSF PYI Grant CCR 8896202. 1 as a black box, are required to do something other than to actually compute the function, and should be much simpler and at least different from any program for the function f in the precise sense defined by <ref> [BK89] </ref>. It is straightforward to show that checkers, self-testers and self-correctors for functions are related in the following way: If f has a self-tester and a self-corrector, then it can be shown that f has a program result checker. <p> Conversely, if f has a checker, then it has a self-tester (though not necessarily a self-corrector). It is argued in <ref> [BK89] </ref> and [BLR90] that this provides an attractive alternative method for attacking the problem of program correctness. <p> In fact, some success towards this goal has been achieved. For example, in <ref> [BK89] </ref>, it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems [AHK, BK89, Rub90, Kan90, BFLS91, BF91]. <p> For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91]. <p> If the given function is a function of a single variable then the [BFL91][Lun92] tester is no simpler than a program evaluating the polynomial. Therefore it does not have the "little-oh" property defined by <ref> [BK89] </ref> nor is it different from the program evaluating the polynomial, in the sense defined by [BLR90], and does not give a self-tester or checker. Our test in contrast is different since it requires no multiplications to perform the test. Relationship with proof checking.
Reference: [BLR90] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <booktitle> In Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The study of program checkers [Blu88][BK89], self-testing programs <ref> [BLR90] </ref> and self-correcting programs [BLR90][Lip91] was introduced in order to allow one to use a program P to compute a function without trusting that P works correctly. <p> Conversely, if f has a checker, then it has a self-tester (though not necessarily a self-corrector). It is argued in [BK89] and <ref> [BLR90] </ref> that this provides an attractive alternative method for attacking the problem of program correctness. <p> be inferred from its value at randomly chosen inputs, then it has a self-corrector <ref> [BLR90] </ref>[Lip91]. This provides self-correctors for a surprising range of functions, including the class of linear functions (homomorphisms between groups) and polynomials. In the direction of characterizing functions that have self-testers, some success has been achieved in [BLR90]. They give a number of methods of constructing self-testers for functions, some of which we mention here: They observe that any checker for a function can be used to construct a self-tester for the function. <p> The main focus of this paper is to study and understand the functions which have self-testers, and to broaden the class of functions that are known to have self-testers. The linearity tester of <ref> [BLR90] </ref> is the starting point for this paper. A particularly interesting feature of this linearity tester is that it breaks the task of self-testing a function into the two tasks of (1) testing it for certain "structural properties" and (2) using the structural property to then identify the function precisely. <p> In this sense, the error-detectors we construct have the feature that they are highly efficient and can be used to get estimates on the distance of a received word from a valid codeword. This perspective can similarly be applied to the results of <ref> [BLR90] </ref> to get randomized error-detecting and correcting schemes for the Hadamard codes that probe the received word in only a constant number of bits to detect an error or find any bit of the codeword closest to the received word. In fact, it has been shown by M. <p> For example, the linearity test of <ref> [BLR90] </ref> may be viewed as trying to approximate the distance d (f; F linear ). To approximate this distance they define the quantity ffi (f; F linear ) Pr [f (x) + f (y) 6= f (x + y)] which is easy to approximate. <p> Moreover, all members of F satisfy P on all neighborhoods in N . To continue with the example of linear functions, the theorem of <ref> [BLR90] </ref> can be used to say that P over the neighborhood N is a ( 9 2 ( 2 9 ff)-robust characterization of linear functions for any constant ff. The exact constant * determining closeness is not very important for the family of multivari-ate polynomials. <p> This method has two problems: first, it relies on believing the other program to be correct, and secondly, since testing is often done at runtime <ref> [BLR90] </ref>, it negates the benefits of designing faster programs, since the computation time will be dominated by the computation time of the old program. As in [BLR90], our testers are of a nontraditional form and use the robust characterization of the function being tested: the tester is given a short specification <p> method has two problems: first, it relies on believing the other program to be correct, and secondly, since testing is often done at runtime <ref> [BLR90] </ref>, it negates the benefits of designing faster programs, since the computation time will be dominated by the computation time of the old program. As in [BLR90], our testers are of a nontraditional form and use the robust characterization of the function being tested: the tester is given a short specification of the function in the form of properties that the function must have, and verifies that these properties "usually" hold. <p> Therefore it does not have the "little-oh" property defined by [BK89] nor is it different from the program evaluating the polynomial, in the sense defined by <ref> [BLR90] </ref>, and does not give a self-tester or checker. Our test in contrast is different since it requires no multiplications to perform the test. Relationship with proof checking. The low-degree tester forms a crucial ingredient in the recent results on proof checking.
Reference: [Blu88] <author> M. Blum. </author> <title> Designing programs to check their work. </title> <type> Technical Report TR-88-009, </type> <institution> International Computer Science Institute, </institution> <year> 1988. </year>
Reference: [dW70] <editor> Van der Waerden. </editor> <booktitle> Algebra, </booktitle> <volume> volume 1. </volume> <publisher> Frederick Ungar Publishing Co., Inc., </publisher> <year> 1970. </year>
Reference-contexts: Standard interpolation techniques (see, for instance, <ref> [dW70] </ref>) imply that this is equivalent to computing coefficients ff 0 ; : : : ; ff d+1 , where the fff i g's depend only on the fx i g's, and verifying that P d+1 i=0 ff i f (x i ) = 0. <p> i p 1 p i = p 1 . 2 Lemma 8 For all x; h 2 Z m p , if ffi 1 2 (d+2) 2 , then P d+1 i=0 ff i g (x + i fl h) = 0 (and thus g is a degree d polynomial <ref> [dW70] </ref>).
Reference: [FGLSS91] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: For the case of polynomials over Z p , our testers are very simple and do not even need to multiply elements of the field. Our testers are the first testers that directly attempt to test the total degree of a polynomial (as opposed to the testers of <ref> [BFLS91, FGLSS91, AS92] </ref>, all of which test that the degree in each variable is not too large). <p> The task of low-degree testing forms a central ingredient in the proof of MIP = NEXPTIME due to [BFL91]. The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations <ref> [FGLSS91, ALMSS92] </ref> and therefore a lot of attention has been paid to this problem [BFL91, BFLS91, FGLSS91, AS92]. However all these results focus on tests that are close variants of the test given in [BFL91]. <p> The tester given here provides an alternate mechanism that works in their setting. The efficiency of low-degree testing also becomes very important to the ensuing results on hardness of approximations [FGLSS91, ALMSS92] and therefore a lot of attention has been paid to this problem <ref> [BFL91, BFLS91, FGLSS91, AS92] </ref>. However all these results focus on tests that are close variants of the test given in [BFL91]. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. <p> All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, [Sud92]). The robustness of 4 follows from the work of [BFL91] (see also <ref> [BFLS91, FGLSS91, AS92, Lun92] </ref>). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5. <p> This concept is an important ingredient in the recursive construction of probabilistically checkable proofs [AS92, ALMSS92, BGLR93] and is also of independent interest in complexity theory [LS91, FL92a]. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in <ref> [FGLSS91] </ref>. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. The particular choice of parameters made in the following definition is due to [BGLR93]. <p> This is described in the next section. 8 Conclusions There has been a spate of results about low-degree tests in the last few years. A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of <ref> [BFLS91, FGLSS91] </ref> obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> Our result from Section 4 gives a very simple proof of one of the relatively hard parts of the proof of MIP=NEXPTIME shown by [BFL91]. The hardness of the analysis of the tester of [BFL91] (and its simplifications, see for instance, <ref> [FGLSS91] </ref>) is in their need to rely on the isoperimetric properties of the m-dimensional grid. Our proof on the other hand does not seem to require any combinatorics, and is instead based on elementary algebraic/probabilistic techniques. <p> The contrast is described in terms of locally-testable codes. Locally testable codes The low-degree test described in [BFL91, BFLS91] gives rise to good codes which also have nice local checkability property. A sequence of improvements <ref> [BFL91, BFLS91, FGLSS91] </ref> culminated in the work of [AS92] which achieves asymptotically optimal bound for such codes by showing that they are (2; (1=m))-locally testable. The highlight of the work of [AS92] is that the locality bounds are independent of the degree of the polynomial that they work with.
Reference: [FHS94] <author> K. Friedl, Z. Hatsagi, and A. Shen. </author> <title> Low-degree tests. </title> <booktitle> In Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 57-64, </pages> <year> 1994. </year>
Reference-contexts: A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of <ref> [AS92, ALMSS92, FHS94, PS94, FS94] </ref>. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91].
Reference: [FL92a] <author> U. Feige and L. Lovasz. </author> <title> Two-prover one-round proof systems: Their power and their problems. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 733-744, </pages> <year> 1992. </year>
Reference-contexts: This concept is an important ingredient in the recursive construction of probabilistically checkable proofs [AS92, ALMSS92, BGLR93] and is also of independent interest in complexity theory <ref> [LS91, FL92a] </ref>. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. The particular choice of parameters made in the following definition is due to [BGLR93].
Reference: [FS94] <author> K. Friedl and M. Sudan. </author> <title> Improvements to total degree tests. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: Indeed, for the case of fields of prime order this can be improved to the optimal case jF j d + 2 and this has been shown recently in <ref> [FS94] </ref>. For arbitrary finite fields it turns out that jF j d + 2 is not a sufficient condition for this characterization to hold. A counterexample to this effect is also shown in [FS94]. 8 (b) Neighborhood Structure: The neighborhoods here are sets of the form N i; ^ fi f <p> improved to the optimal case jF j d + 2 and this has been shown recently in <ref> [FS94] </ref>. For arbitrary finite fields it turns out that jF j d + 2 is not a sufficient condition for this characterization to hold. A counterexample to this effect is also shown in [FS94]. 8 (b) Neighborhood Structure: The neighborhoods here are sets of the form N i; ^ fi f (fi 1 ; : : : ; fi i1 ; t; fi i ; : : : ; fi m1 )jt 2 F g, for every choice of ^ fi 2 F m1 <p> This theorem makes very minimal requirements on the field size required for its validity. The theorem is valid whenever Characterization 5 holds and Friedl and Sudan, <ref> [FS94] </ref>, have shown that this holds for p d+2 the smallest conceivable field size for which the test could be defined. We do not know of other testers that work with such a minimal requirement on the field size. <p> A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of <ref> [AS92, ALMSS92, FHS94, PS94, FS94] </ref>. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> The local testability of the Polynomial-Line codes has been further improved in two ways recently. [PS94] have shown that the codes are (2; ffi)-locally checkable over this works for linear sized fields as well, for some ffi &gt; 0. In a different direction <ref> [FS94] </ref> show that the Polynomial-Line codes are (2; ffi)-locally checkable for all ffi &lt; 1=8. 22 9 Acknowledgments We are very grateful to Avi Wigderson for suggesting that our tester in Section 4 can be made more efficient, as well as his technical help in proving the theorems of Section 5.
Reference: [GLRSW91] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: The program checker, self-tester and self-corrector may call the program fl This paper unifies and extends part of the results contained in Gemmell et al. <ref> [GLRSW91] </ref> and Rubinfeld and Sudan [RS92]. y Cornell University. email: ronitt@cs.cornell.edu. This work is supported by ONR Young Investigator grant N00014-93-1-0590 and the United States-Israel Binational Science Foundation grant 92-00226. <p> However all these results focus on tests that are close variants of the test given in [BFL91]. The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of <ref> [GLRSW91] </ref>. The efficiency of the tester shown here may also be found in [RS92]. It turns out that this tester is particularly well-suited to such multiple prover applications and provides a one round, constant prover proof that a function is a low degree polynomial over finite fields. <p> A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from <ref> [GLRSW91, RS92] </ref>), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> We are also very grateful to Sasha Shen for pointing out that the tester given in <ref> [GLRSW91] </ref> works for multivariate polynomials. In particular, Characterization 3 and its relevance to our test are due to him. We are grateful to Dick Lipton for illuminating conversations on the use of the testers presented here, and to Mike Luby, Shafi Goldwasser and Umesh Vazirani for technical suggestions.
Reference: [Kan90] <author> S. Kannan. </author> <title> Program Result Checking with Applications. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1990. </year>
Reference-contexts: For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91].
Reference: [Lip91] <author> R. Lipton. </author> <title> New directions in testing. </title> <journal> Distributed Computing and Cryptography, DIMACS Series in Discrete Math and Theoretical Computer Science, American Mathematical Society, </journal> <volume> 2 </volume> <pages> 191-202, </pages> <year> 1991. </year>
Reference: [LS91] <author> D. Lapidot and A. Shamir. </author> <title> Fully parallelized multi prover protocols for NEX-PTIME. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 13-18, </pages> <year> 1991. </year>
Reference-contexts: This concept is an important ingredient in the recursive construction of probabilistically checkable proofs [AS92, ALMSS92, BGLR93] and is also of independent interest in complexity theory <ref> [LS91, FL92a] </ref>. The original definition of probabilistically checkable proofs is due to [AS92] based on an implicit notion in [FGLSS91]. A very closely related notion that of holographic proofs - appears in the work of [BFLS91]. The particular choice of parameters made in the following definition is due to [BGLR93].
Reference: [Lun92] <author> C. Lund. </author> <title> The Power of Interaction. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, [Sud92]). The robustness of 4 follows from the work of [BFL91] (see also <ref> [BFLS91, FGLSS91, AS92, Lun92] </ref>). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5. <p> Better analysis of some portions of our proof yields even better statements about the Polynomial-Line Codes. This is described in the next section. 8 Conclusions There has been a spate of results about low-degree tests in the last few years. A brief listing includes the low-degree test of <ref> [BFL91, Lun92] </ref> which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results.
Reference: [Nao92] <author> M. Naor, </author> <month> April </month> <year> 1992. </year> <type> Personal Communication. 24 </type>
Reference-contexts: In fact, it has been shown by M. Naor <ref> [Nao92] </ref> that these results can be used to construct codes for which error-detection/correction can be performed by uniform quasi-polynomial sized circuits of constant depth. In Section 7 we define the notion of a "locally testable code" a notion that precisely describes the relationship between testing and error-correcting codes.
Reference: [PS94] <author> A. Polishchuk and D. Spielman. </author> <title> Nearly-linear size holographic proofs. </title> <booktitle> In Pro--ceedings of the 26th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 194-203. </pages>
Reference-contexts: A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from [GLRSW91, RS92]), and subsequent works of <ref> [AS92, ALMSS92, FHS94, PS94, FS94] </ref>. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91]. <p> By employing the technique of recursive proof checking, due to [AS92], on such proof systems [ALMSS92] go on to prove that NP PCP [log; O (1); O (1); (1)]. The local testability of the Polynomial-Line codes has been further improved in two ways recently. <ref> [PS94] </ref> have shown that the codes are (2; ffi)-locally checkable over this works for linear sized fields as well, for some ffi &gt; 0.
Reference: [RS92] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proceedings of the 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 23-43, </pages> <year> 1992. </year>
Reference-contexts: The program checker, self-tester and self-corrector may call the program fl This paper unifies and extends part of the results contained in Gemmell et al. [GLRSW91] and Rubinfeld and Sudan <ref> [RS92] </ref>. y Cornell University. email: ronitt@cs.cornell.edu. This work is supported by ONR Young Investigator grant N00014-93-1-0590 and the United States-Israel Binational Science Foundation grant 92-00226. <p> The low-degree test given here is fundamentally different from the ones mentioned above and originated from independent considerations in the work of [GLRSW91]. The efficiency of the tester shown here may also be found in <ref> [RS92] </ref>. It turns out that this tester is particularly well-suited to such multiple prover applications and provides a one round, constant prover proof that a function is a low degree polynomial over finite fields. <p> A brief listing includes the low-degree test of [BFL91, Lun92] which was the first test for multivariate polynomials, the results of [BFLS91, FGLSS91] obtained independently and concurrently with ours (from <ref> [GLRSW91, RS92] </ref>), and subsequent works of [AS92, ALMSS92, FHS94, PS94, FS94]. Here we summarize some of their achievements along with a comparison with our results. We start by distinguishing the merits of our tester from those of [BFL91, BFLS91].
Reference: [Rub90] <author> R. Rubinfeld. </author> <title> A Mathematical Theory of Self-Checking, Self-Testing and Self-Correcting Programs. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1990. </year>
Reference-contexts: For example, in [BK89], it is shown how to use techniques from the area of interactive proof systems in order to write checkers. Using these and other techniques, checkers (and hence self-testers) have been found for a variety of problems <ref> [AHK, BK89, Rub90, Kan90, BFLS91, BF91] </ref>. If a function is random self-reducible, i.e., the value of the function at any input can be inferred from its value at randomly chosen inputs, then it has a self-corrector [BLR90][Lip91].
Reference: [She91] <author> A. Shen. </author> <type> Personal Communication, </type> <month> May </month> <year> 1991. </year>
Reference: [Sud92] <author> M. Sudan. </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1992. </year>
Reference-contexts: It turns out that this tester is particularly well-suited to such multiple prover applications and provides a one round, constant prover proof that a function is a low degree polynomial over finite fields. This is observed in subsequent work of [ALMSS92] (see also <ref> [Sud92] </ref>) and follows by using an improved analysis for Lemma 11 from [AS92]. This turns out to play a crucial role in the NP = PCP (log n; O (1)) result of [ALMSS92], which in turn provides hardness results for a wide variety of approximation problems. <p> All characterizations above turn out to be robust. The robustness of Characterization 1 is straightforward and omitted here (see, for instance, <ref> [Sud92] </ref>). The robustness of 4 follows from the work of [BFL91] (see also [BFLS91, FGLSS91, AS92, Lun92]). Robustness of 2, 3, 5 and 6 are presented in Sections 4 and 5.
References-found: 28

