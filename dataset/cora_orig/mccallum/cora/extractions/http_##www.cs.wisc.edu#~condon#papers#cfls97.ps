URL: http://www.cs.wisc.edu/~condon/papers/cfls97.ps
Refering-URL: http://www.cs.wisc.edu/logs/1997/12.10.1997.html
Root-URL: 
Email: condon@cs.wisc.edu.  jf@research.att.com.  lund@research.att.com.  shor@research.att.com.  
Title: Random Debaters and the Hardness of Approximating Stochastic Functions  
Author: Anne Condon Joan Feigenbaum Carsten Lund Peter Shor 
Address: 1210 West Dayton Street, Madison, WI 57306 USA,  Room 2C473, 600 Mountain Avenue, Murray Hill, NJ 07974-0636 USA,  Room 2C324, 600 Mountain Avenue, Murray Hill, NJ 07974-0636 USA,  Room 2D149, 600 Mountain Avenue, Murray Hill, NJ 07974-0636 USA,  
Affiliation: University of Wisconsin, Computer Sciences Department,  AT&T Bell Laboratories,  AT&T Bell Laboratories,  AT&T Bell Laboratories,  
Note: Theorem: L has an RPCDS in which the verifier flips O(log n) coins and reads O(1) bits of the debate if and only if L is in PSPACE.  Supported in part by NSF grants CCR-9100886 and CCR-9257241.  
Date: May 9, 1995  
Abstract: A probabilistically checkable debate system (PCDS) for a language L consists of a probabilistic polynomial-time verifier V and a debate between Player 1, who claims that the input x is in L, and Player 0, who claims that the input x is not in L. It is known that there is a PCDS for L in which V flips O(log n) coins and reads O(1) bits of the debate if and only if L is in PSPACE ([Condon et al., Proc. 25th ACM Symposium on Theory of Computing, 1993, pp. 304-315]). In this paper, we restrict attention to RPCDS's, which are PCDS's in which Player 0 follows a very simple strategy: On each turn, Player 0 chooses uniformly at random from the set of legal moves. We prove the following result. This new characterization of PSPACE is used to show that certain stochastic PSPACE-hard functions are as hard to approximate closely as they are to compute exactly. Examples of such functions include optimization versions of Dynamic Graph Reliability, Stochastic Satis-fiability, Mah-Jongg, Stochastic Generalized Geography, and other "games against nature" of the type introduced in [Papadimitriou, J. Comput. System Sci., 31 (1985), pp. 288-301]. fl These results first appeared in our Technical Memorandum [11]. They were presented in preliminary form at the 9th Annual IEEE Conference on Structure in Complexity Theory, Amsterdam, The Netherlands, June 1994. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ajtai and M. Ben-Or, </author> <title> A Theorem on Probabilistic Constant Depth Circuits, </title> <booktitle> Proc. 16th Annual ACM Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1984, </year> <pages> pp. 471-474. </pages>
Reference-contexts: Finally, we strengthen our result by making several copies of this construction and repeating it in series and in parallel. To show this, we use a result of Ajtai and Ben-Or <ref> [1] </ref> (see Theorem 3.14 in [8]): For every probabilistic circuit C of size s that accepts a language L with error probability * &lt; 1=2, there is a probabilistic circuit C 0 of size s poly (N ) that 19 accepts L with error probability &lt; 2 N .
Reference: [2] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy, </author> <title> Proof Verification and Hardness of Approximation Problems, </title> <booktitle> Proc. 33rd Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1992, </year> <pages> pp. 14-23. </pages>
Reference-contexts: 1 Introduction Recently, there has been great progress in understanding the precision with which one can approximate solutions to NP-hard problems efficiently. Feige et al. [13], Arora et al. <ref> [2, 3] </ref> and others proved strong negative results for several fundamental problems such as Clique and Satisfiability. This progress has led to renewed study of approximation algorithms for PSPACE-hard problems. Not surprisingly, PSPACE-hard problems also display a wide variation in the precision with which they can be approximated efficiently. <p> In [10], we considered optimization versions of several other problems in PSPACE, including Quantified Satisfiability, Generalized Geography, and Finite Automata Intersection. Building on the techniques of <ref> [2, 3, 13] </ref>, we showed that it is in fact PSPACE-hard to approximate these problems closely (where "closely" depends on the problem). <p> Our new characterization of PSPACE, which is used in proving nonapproximability results for these problems, builds on techniques developed in our previous work on probabilistically checkable debate systems (PCDS's) [10], which in turn builds on techniques of Arora et al. <ref> [2] </ref>, Lund et al. [16] and Shamir [23]. In a PCDS for L, there are two computa-tionally powerful players, 1 and 0, and a probabilistic polynomial-time verifier V . Players 1 and 0 play a game in which they alternate writing strings on a debate tape . <p> A PCPS is simply a PCDS with just one player, Player 1, in which case the "debate" corresponds to a "proof." (See Arora et al. <ref> [2, 3] </ref> or Sudan [24] for an overview of PCPS's.) If the verifier is deterministic and reads all bits of the proof, the model is equivalent in power to a nondeterministic Turing machine, where the proof corresponds to the nondeterministic moves. Thus, by definition, NP = PCP (0; poly (n)). <p> Thus, by definition, NP = PCP (0; poly (n)). Arora et al. <ref> [2] </ref> showed that PCP (log n; 1) = NP. Their result shows that there is a dramatic trade-off between the number of random bits available to the verifier of such a proof and the number of bits of the proof that the verifier has to read. <p> The result of Arora et al. that NP = PCP (log n; 1) has been applied to prove that several NP-hard problems are hard to approximate closely. These problems include optimization versions of Satisfiability, Independent Set <ref> [2, 3] </ref>, Clique [13], and Colorability [17]. For example, the MAX SAT function maps a boolean formula in 3-conjunctive normal form to the maximum number of clauses of that formula that are simultaneously satisfied by some assignment to the variables. <p> To prove the (harder) direction that PSPACE RPCD (log n; 1), we build on several techniques of Lund et al. [16], Shamir [23], Arora et al. <ref> [3, 2] </ref> and Condon et al. [10]. We first describe these results, and in Lemma 2.3 we put them together to prove PSPACE RPCD (log n; 1). <p> Roughly, the idea is that in rounds 1 through N , player 1 0 plays as player 1 does in debate D, except that each move is encoded using a special encoding function, known as the low degree polynomial code <ref> [2] </ref>. The string written by 1 0 in round N + 1 contains a proof, R , for each random string R of V . The proof R shows that V outputs 1 given random string R and the decoded debate of rounds 1; : : : ; N . <p> The verifier V 0 chooses a random seed R and computes the indices i 1 ; i 2 ; : : : ; i q of rounds that V queries using the random seed R. Using a protocol of Arora et al. <ref> [2, 3] </ref>, V 0 need only examine a constant number of bits of each round i 1 ; i 2 ; : : : ; i q and a constant number of bits of round N + 1 in order to verify that V outputs 1 on random string R and <p> The correctness of this protocol follows from Arora et al. <ref> [2, 3] </ref>. For details, see [10]. The next lemma is implicit in the proof that IP = PSPACE [16, 23]. Lemma 2.2 Let L be a language in PSPACE and x = x 1 x 2 : : : x n be an input.
Reference: [3] <author> S. Arora and M. Safra, </author> <title> Probabilistic Checking of Proofs, </title> <booktitle> Proc. 33rd Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1992, </year> <pages> pp. 2-13. </pages>
Reference-contexts: 1 Introduction Recently, there has been great progress in understanding the precision with which one can approximate solutions to NP-hard problems efficiently. Feige et al. [13], Arora et al. <ref> [2, 3] </ref> and others proved strong negative results for several fundamental problems such as Clique and Satisfiability. This progress has led to renewed study of approximation algorithms for PSPACE-hard problems. Not surprisingly, PSPACE-hard problems also display a wide variation in the precision with which they can be approximated efficiently. <p> In [10], we considered optimization versions of several other problems in PSPACE, including Quantified Satisfiability, Generalized Geography, and Finite Automata Intersection. Building on the techniques of <ref> [2, 3, 13] </ref>, we showed that it is in fact PSPACE-hard to approximate these problems closely (where "closely" depends on the problem). <p> A PCPS is simply a PCDS with just one player, Player 1, in which case the "debate" corresponds to a "proof." (See Arora et al. <ref> [2, 3] </ref> or Sudan [24] for an overview of PCPS's.) If the verifier is deterministic and reads all bits of the proof, the model is equivalent in power to a nondeterministic Turing machine, where the proof corresponds to the nondeterministic moves. Thus, by definition, NP = PCP (0; poly (n)). <p> The result of Arora et al. that NP = PCP (log n; 1) has been applied to prove that several NP-hard problems are hard to approximate closely. These problems include optimization versions of Satisfiability, Independent Set <ref> [2, 3] </ref>, Clique [13], and Colorability [17]. For example, the MAX SAT function maps a boolean formula in 3-conjunctive normal form to the maximum number of clauses of that formula that are simultaneously satisfied by some assignment to the variables. <p> To prove the (harder) direction that PSPACE RPCD (log n; 1), we build on several techniques of Lund et al. [16], Shamir [23], Arora et al. <ref> [3, 2] </ref> and Condon et al. [10]. We first describe these results, and in Lemma 2.3 we put them together to prove PSPACE RPCD (log n; 1). <p> The verifier V 0 chooses a random seed R and computes the indices i 1 ; i 2 ; : : : ; i q of rounds that V queries using the random seed R. Using a protocol of Arora et al. <ref> [2, 3] </ref>, V 0 need only examine a constant number of bits of each round i 1 ; i 2 ; : : : ; i q and a constant number of bits of round N + 1 in order to verify that V outputs 1 on random string R and <p> The correctness of this protocol follows from Arora et al. <ref> [2, 3] </ref>. For details, see [10]. The next lemma is implicit in the proof that IP = PSPACE [16, 23]. Lemma 2.2 Let L be a language in PSPACE and x = x 1 x 2 : : : x n be an input.
Reference: [4] <author> L. Babai and S. Moran, </author> <title> Arthur-Merlin Games: A Randomized Proof System and a Hierarchy of Complexity Classes, </title> <journal> J. Comput. System Sci., </journal> <volume> 36 (1988), </volume> <pages> pp. 254-276. </pages>
Reference-contexts: We call such a debate system an RPCDS and denote by RPCD (r (n); q (n)) the class of languages recognized by RPCDS's in which the verifier flips O (r (n)) coins and reads O (q (n)) bits of . We note that an Arthur-Merlin game <ref> [4] </ref> is an RPCDS in which the verifier is deterministic and q (n) is an arbitrary polynomial; that is, V reads the entire debate between Arthur (Player 0) and Merlin (Player 1) before deciding whether the input is in the language.
Reference: [5] <author> M. Bellare, S. Goldwasser, C. Lund and A. Russell, </author> <title> Efficient Probabilistic Checkable Proofs and Applications to Approximation, </title> <booktitle> Proc. 25th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 286-293. </pages>
Reference-contexts: For example, the MAX SAT function maps a boolean formula in 3-conjunctive normal form to the maximum number of clauses of that formula that are simultaneously satisfied by some assignment to the variables. Bellare et al. <ref> [5] </ref> showed that there is no polynomial-time algorithm that can approximate MAX SAT within factor 112=113, unless NP = P. More recently, Bellare and Sudan [6] improved 112=113 to 64=65, but their assumption is weaker than NP = P.
Reference: [6] <author> M. Bellare and M. Sudan, </author> <title> Improved Non-approximability Results, </title> <booktitle> Proc. 26th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1994, </year> <pages> pp. 184-193. </pages>
Reference-contexts: Bellare et al. [5] showed that there is no polynomial-time algorithm that can approximate MAX SAT within factor 112=113, unless NP = P. More recently, Bellare and Sudan <ref> [6] </ref> improved 112=113 to 64=65, but their assumption is weaker than NP = P. Similarly, the result that PCD (log n; 1) = PSPACE yields nonapproximability results for optimization versions of PSPACE-hard problems, including Quantified Satisfiability, Generalized Geography and Finite Automata Intersection [10].
Reference: [7] <author> H. L. Bodlaender, </author> <title> On the Complexity of Some Coloring Games, </title> <booktitle> Intl. </booktitle> <institution> J. Foundations Comput. Sci., </institution> <month> 2 </month> <year> (1991), </year> <pages> pp. 133-147. </pages>
Reference-contexts: The next result thus follows from Theorem 4.2. Theorem 4.3 There is a constant c &gt; 0 such that approximating MIN DMP within ratio 2 n c is PSPACE-hard. The complexity of coloring games was studied by Bodlaender <ref> [7] </ref>, motivated by scheduling problems. An instance of a coloring game consists of a graph G = (V; E), an ownership function o that specifies which of two players, 0 and 1, owns each vertex, a linear ordering f on the vertices, and a finite set C of colors. <p> Theorem 4.4 There is a constant c &gt; 0 such that approximating MAX-PROB SCG within ratio 2 n c is PSPACE-hard. Proof: We describe a reduction from MAX-PROB SSAT to MAX-PROB SCG that adapts the original construction <ref> [7] </ref>. By Fact 4.1, we can restrict our attention to instances such that either MAX-PROB SSAT () = 1 or MAX-PROB SSAT () &lt; 1=2 n * , for some * &gt; 0. We construct an instance G = (V; E) of MAX-PROB SCG as follows.
Reference: [8] <author> R. B. Boppana and M. Sipser, </author> <title> The Complexity of Finite Functions, in Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, </title> <editor> J. van Leeuwen (ed.), </editor> <publisher> MIT Press/Elsevier, </publisher> <year> 1990, </year> <pages> pp. 757-800. </pages>
Reference-contexts: Finally, we strengthen our result by making several copies of this construction and repeating it in series and in parallel. To show this, we use a result of Ajtai and Ben-Or [1] (see Theorem 3.14 in <ref> [8] </ref>): For every probabilistic circuit C of size s that accepts a language L with error probability * &lt; 1=2, there is a probabilistic circuit C 0 of size s poly (N ) that 19 accepts L with error probability &lt; 2 N .
Reference: [9] <author> A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer, </author> <title> Alternation, </title> <journal> J. ACM, </journal> <volume> 28 (1981), </volume> <pages> pp. 114-133. </pages>
Reference-contexts: If L has a PCDS with error probability 1=3 in which V flips O (r (n)) coins and reads O (q (n)) bits of , we say that L 2 PCD (r (n); q (n)). The classical result of Chandra et al. <ref> [9] </ref> that PSPACE is equal to Alternating Polynomial Time can be restated as PCD (0; poly (n)) = PSPACE. In [10], we showed that PSPACE is also equal to PCD (log (n); 1). <p> In the next two paragraphs, we discuss these results and the relationships between the proofs. In [10], we developed the PCDS in order to extend the work of Arora et al. to PSPACE. The PCDS model is related to the alternating Turing machine model of Chandra et al. <ref> [9] </ref>, just as the PCP model is related to the nondeterministic Turing machine model. Chandra et al. showed that PSPACE is precisely the set of languages recognized by two-player, perfect information games, in which the referee is a deterministic polynomial-time machine that examines the entire game before deciding who wins.
Reference: [10] <author> A. Condon, J. Feigenbaum, C. Lund, and P. Shor, </author> <title> Probabilistically Checkable Debate Systems and Nonapproximability of PSPACE-Hard Functions, Chicago J. Theoretical Comp. Sci., to appear. Extended abstract, entitled Probabilistically Checkable Debate Systems and Approximation Algorithms for PSPACE-Hard Functions, </title> <booktitle> appears in Proc. 25th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 305-314. </pages>
Reference-contexts: In related work, Marathe et al. [19] applied results of Arora et al.[2] to show that these same problems have polynomial-time approximation schemes if and only if NP = P. In <ref> [10] </ref>, we considered optimization versions of several other problems in PSPACE, including Quantified Satisfiability, Generalized Geography, and Finite Automata Intersection. Building on the techniques of [2, 3, 13], we showed that it is in fact PSPACE-hard to approximate these problems closely (where "closely" depends on the problem). <p> Our new characterization of PSPACE, which is used in proving nonapproximability results for these problems, builds on techniques developed in our previous work on probabilistically checkable debate systems (PCDS's) <ref> [10] </ref>, which in turn builds on techniques of Arora et al. [2], Lund et al. [16] and Shamir [23]. In a PCDS for L, there are two computa-tionally powerful players, 1 and 0, and a probabilistic polynomial-time verifier V . <p> Suppose V flips O (r (n)) coins and reads O (q (n)) bits of . If, under the best strategies of Players 1 and 0, V 's decision is correct with high probability, then we say that L is in PCD (r (n); q (n)). We showed in <ref> [10] </ref> that PCD (log n; 1) = PSPACE. That is, any language in PSPACE can be recognized by a PCDS in which the verifier uses O (log n) coin flips and queries only a constant number of bits of the debate. <p> In the rest of this section, we first define precisely the PCDS and RPCDS models. We then describe previous work on related complexity classes. 1.1 Preliminaries In this section, we define both the PCDS model of <ref> [10] </ref> and the new RPDCS model. We conclude with some definitions relating to the approximability of PSPACE-hard functions. A probabilistically checkable debate system, or PCDS, consists of a verifier V and a debate format D. <p> In this case, we say that x is rejected by (D; V ). This definition allows "one-sided error," analogous to the type of errors that are allowed in the complexity class co-RP (see, for example, Johnson [15] for a definition). The main result of <ref> [10] </ref> also holds for a "zero-sided error" definition, with three possible outputs, 1, 0, and fl, for "player 1 won," "player 0 won," and "I don't know who won," respectively. <p> The classical result of Chandra et al. [9] that PSPACE is equal to Alternating Polynomial Time can be restated as PCD (0; poly (n)) = PSPACE. In <ref> [10] </ref>, we showed that PSPACE is also equal to PCD (log (n); 1). We now focus on PCDS's in which Player 0 follows a very simple strategy that of tossing coins. <p> By "approximating f within ratio *(n) is PSPACE-hard," we mean that, if g approximates f within ratio *(n), then g is PSPACE-hard. 1.2 Related Work The theory of probabilistically checkable debate systems developed here and in <ref> [10] </ref> plays the role for PSPACE that the theory of probabilistically checkable proof systems (PCPS's) plays for NP. <p> The techniques used to prove this result are used heavily in our results on PCDS's and RPCDS's. In the next two paragraphs, we discuss these results and the relationships between the proofs. In <ref> [10] </ref>, we developed the PCDS in order to extend the work of Arora et al. to PSPACE. The PCDS model is related to the alternating Turing machine model of Chandra et al. [9], just as the PCP model is related to the nondeterministic Turing machine model. <p> In current notation, the result of Chandra et al. is that PSPACE = PCD (0; poly (n)). In <ref> [10] </ref>, we showed that PCD (log n; 1) = PSPACE. Thus, we get the same trade-off between random bits and queries as was previously shown for proof systems. The proof that PSPACE PCD (log n; 1) is done in two parts. <p> The first shows that PSPACE is contained in the class of languages accepted by PCDS's in which the verifier reads only a constant number of rounds of Player 1 and a constant number of bits of Player 0. The second part, just as in <ref> [10] </ref>, shows how the constant number of rounds in this result can be replaced by a constant number of bits. All of these results on PCPS's, PCDS's and RPCDS's can be used in different ways to prove nonapproximability results for hard problems. <p> More recently, Bellare and Sudan [6] improved 112=113 to 64=65, but their assumption is weaker than NP = P. Similarly, the result that PCD (log n; 1) = PSPACE yields nonapproximability results for optimization versions of PSPACE-hard problems, including Quantified Satisfiability, Generalized Geography and Finite Automata Intersection <ref> [10] </ref>. For example, the optimization version of Quantified Satisfiability is defined as follows. Suppose that the variables of the formula are assigned values, in order of quantification, by two players 0 and 1. Players 0 and 1 assign values to the universally and existentially quantified variables, respectively. <p> If Player 1 can guarantee that k clauses of the formula will be satisfied, regardless of what Player 0 chooses, we say that k clauses of the formula are simultaneously satisfiable. The function MAX QSAT maps a quantified formula to its maximum number of simultaneously satisfiable clauses. In <ref> [10] </ref>, we show that approximating MAX QSAT within some constant factor c &lt; 1 is PSPACE-hard. The tools developed in [10] are useful in proving nonapproximability results for PSPACE-hard problems that can be cast as two-person games between two powerful players. <p> The function MAX QSAT maps a quantified formula to its maximum number of simultaneously satisfiable clauses. In <ref> [10] </ref>, we show that approximating MAX QSAT within some constant factor c &lt; 1 is PSPACE-hard. The tools developed in [10] are useful in proving nonapproximability results for PSPACE-hard problems that can be cast as two-person games between two powerful players. However, these tools do not seem to lead to similar proofs for the stochastic PSPACE-hard problems that are considered in this paper. <p> To prove the (harder) direction that PSPACE RPCD (log n; 1), we build on several techniques of Lund et al. [16], Shamir [23], Arora et al. [3, 2] and Condon et al. <ref> [10] </ref>. We first describe these results, and in Lemma 2.3 we put them together to prove PSPACE RPCD (log n; 1). <p> Then L is accepted by a RPCDS (D 0 ; V 0 ) in which the verifier uses O (log n) random bits, reads a constant number of bits of Player 1, and a constant number of bits of Player 0. Proof: (Sketch) We showed in <ref> [10, Theorem 3.2] </ref> that any language recognized by a PCDS in which V flips O (log n) coins and reads O (1) rounds of the debate is also recognized by a PCDS in which V flips O (log n) coins and reads O (1) bits of the debate. <p> The lemma follows by a straightforward modification to the proof of <ref> [10, Theorem 3.2] </ref>. Briefly, if D has N rounds on a given input, then D 0 has N + 1 rounds. Let the players of (D; V ) be 0 and 1 and the players of (D 0 ; V 0 ) be 0 0 and 1 0 . <p> The correctness of this protocol follows from Arora et al. [2, 3]. For details, see <ref> [10] </ref>. The next lemma is implicit in the proof that IP = PSPACE [16, 23]. Lemma 2.2 Let L be a language in PSPACE and x = x 1 x 2 : : : x n be an input. <p> The first player unable to move loses. The language GGEOG is the set of pairs (G; s) on which Player 1 has a winning strategy. In previous work <ref> [10] </ref>, we defined the function MAX GGEOG that maps a pair (G; s) to the largest integer k such that Player 1 can force the game to be played for k moves. (Note that Player 1's objective is to keep the game going as long as possible, whether or not Player
Reference: [11] <author> A. Condon, J. Feigenbaum, C. Lund, and P. Shor, </author> <title> Random Debaters and the Hardness of Approximating Stochastic Functions (Extended Abstract), </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <address> Murray Hill NJ, </address> <month> May </month> <year> 1993. </year>
Reference: [12] <author> S. Even and R. Tarjan, </author> <title> A Combinatorial Problem which is Complete in Polynomial Space, </title> <journal> J. ACM, </journal> <volume> 23 (1976), </volume> <pages> pp. 710-719. </pages>
Reference-contexts: Player 1's objective is to keep the game going as long as possible. MAX SNK is the expected length of the game under an optimal strategy of Player 1. * In the Generalized Hex game of Even and Tarjan <ref> [12] </ref>), the input is a graph with two distinguished nodes n 1 and n 2 . A move for Player 1 (0) consists of putting a white (black) marker on a vertex; the player is free to choose any unoccupied vertex except n 1 or n 2 .
Reference: [13] <author> U. Feige, S. Goldwasser, L. Lovasz, M. Safra, and M. Szegedy, </author> <title> Approximating Clique is Almost NP-Complete, </title> <booktitle> Proc. 32nd Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1991, </year> <pages> pp. 2-12. 34 </pages>
Reference-contexts: 1 Introduction Recently, there has been great progress in understanding the precision with which one can approximate solutions to NP-hard problems efficiently. Feige et al. <ref> [13] </ref>, Arora et al. [2, 3] and others proved strong negative results for several fundamental problems such as Clique and Satisfiability. This progress has led to renewed study of approximation algorithms for PSPACE-hard problems. <p> In [10], we considered optimization versions of several other problems in PSPACE, including Quantified Satisfiability, Generalized Geography, and Finite Automata Intersection. Building on the techniques of <ref> [2, 3, 13] </ref>, we showed that it is in fact PSPACE-hard to approximate these problems closely (where "closely" depends on the problem). <p> The result of Arora et al. that NP = PCP (log n; 1) has been applied to prove that several NP-hard problems are hard to approximate closely. These problems include optimization versions of Satisfiability, Independent Set [2, 3], Clique <ref> [13] </ref>, and Colorability [17]. For example, the MAX SAT function maps a boolean formula in 3-conjunctive normal form to the maximum number of clauses of that formula that are simultaneously satisfied by some assignment to the variables.
Reference: [14] <author> H. Hunt III, M. Marathe and R. Stearns, </author> <title> Generalized CNF Satisfiability Problems and Non-Efficient Approximability, </title> <booktitle> Proc. 9th Conference on Structure in Complexity Theory, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1994, </year> <pages> pp. 356-366. </pages>
Reference-contexts: Building on the techniques of [2, 3, 13], we showed that it is in fact PSPACE-hard to approximate these problems closely (where "closely" depends on the problem). Using direct reduction arguments, Hunt et al. <ref> [14] </ref> showed that some generalized quantified satisfiabil-ity problems (for example, satisfiability of quantified formulas in which "clauses" are not restricted to be disjunctions of literals) are PSPACE-hard to approximate. <p> Our new results on RPCDS's are used to obtain such proofs in Section 3. There has been other very recent work, both on approximation algorithms and on nonap-proximability results for PSPACE-hard problems. Using direct reductions from variations of the Quantified Satisfiability problem, Hunt et al. <ref> [14] </ref> and Marathe et al. [18] showed that several PSPACE-hard problems are hard to approximate, unless PSPACE = P. These include algebraic problems and graph problems on hierarchically defined graphs.
Reference: [15] <author> D. S. Johnson, </author> <title> A Catalog of Complexity Classes, in Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, </title> <editor> J. van Leeuwen (ed.), </editor> <publisher> The MIT Press/Elsevier, </publisher> <year> 1990, </year> <pages> pp. 67-162. </pages>
Reference-contexts: In this case, we say that x is rejected by (D; V ). This definition allows "one-sided error," analogous to the type of errors that are allowed in the complexity class co-RP (see, for example, Johnson <ref> [15] </ref> for a definition). The main result of [10] also holds for a "zero-sided error" definition, with three possible outputs, 1, 0, and fl, for "player 1 won," "player 0 won," and "I don't know who won," respectively.
Reference: [16] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan, </author> <title> Algebraic methods for interactive proof systems, </title> <journal> J. ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 859-868. </pages>
Reference-contexts: We also use the identity IP = PSPACE <ref> [16, 23] </ref> to derive nonapproximability results for other stochastic PSPACE-hard functions. Examples of the functions that yield to this technique include optimization versions of Dynamic Markov Process [21] and Stochastic Coloring, as well as a different optimization version of Stochastic Satisfiability. <p> Our new characterization of PSPACE, which is used in proving nonapproximability results for these problems, builds on techniques developed in our previous work on probabilistically checkable debate systems (PCDS's) [10], which in turn builds on techniques of Arora et al. [2], Lund et al. <ref> [16] </ref> and Shamir [23]. In a PCDS for L, there are two computa-tionally powerful players, 1 and 0, and a probabilistic polynomial-time verifier V . Players 1 and 0 play a game in which they alternate writing strings on a debate tape . <p> Thus, the class of languages accepted by Arthur-Merlin games is by definition RPCD (0; poly (n)) and is commonly denoted by IP. It is known that RPCD (0; poly (n)) = PSPACE <ref> [16, 23] </ref>. In this paper, we prove the following result. Theorem: RPCD (log n; 1) = PSPACE. This theorem shows that a verifier that tosses O (log n) coins does not have to read the entire debate between Arthur and Merlin. <p> The second part then shows how the constant number of rounds in this result can be replaced by a constant number of bits. This second part is proved by extending the work of Arora et al. on PCPS's. The result IP = PSPACE <ref> [16, 23] </ref> shows that Chandra et al.'s characterization of PSPACE is true even if one of the two players uses the unsophisticated strategy of simply selecting a move at random. That is, polynomial-time alternating Turing machines and polynomial-round Arthur-Merlin games accept the same class of languages. <p> To prove the (harder) direction that PSPACE RPCD (log n; 1), we build on several techniques of Lund et al. <ref> [16] </ref>, Shamir [23], Arora et al. [3, 2] and Condon et al. [10]. We first describe these results, and in Lemma 2.3 we put them together to prove PSPACE RPCD (log n; 1). <p> The correctness of this protocol follows from Arora et al. [2, 3]. For details, see [10]. The next lemma is implicit in the proof that IP = PSPACE <ref> [16, 23] </ref>. Lemma 2.2 Let L be a language in PSPACE and x = x 1 x 2 : : : x n be an input. <p> Finally, g m is a polynomial-time computable function, and the degree of all the poly nomials is bounded by d = poly (n). In <ref> [16, 23] </ref>, each g i is a polynomial that can be explicitly written as a formula of polynomial length in terms of sums and products but may result in a formula of exponential length when these sums and products are expanded. <p> Finally, we describe a technique, called the polynomial verification technique, that was proposed by Babai as a generalization of a technique first used by Lund et al. <ref> [16] </ref>. Roughly, this method "reduces" a set of questions of the form: "Is the value of multivariate polynomial g at point a equal to v?" to one such question. To describe this technique precisely, we need the following definitions. <p> Finally, the verifier checks that the g m -question written in the last round of the debate is good; by property (3) of Lemma 2.2, this can be done in polynomial time. If all three checks are passed, the verifier accepts, else the verifier rejects. For details, see <ref> [16, 23] </ref>. Unfortunately, this protocol requires that the verifier read all rounds of the debate system. <p> Combining this with the result that RPCD (0; poly (n)) = IP = PSPACE <ref> [16, 23] </ref> gives Theorem 2.4. 3 Nonapproximability Results based on RPCD (log n; 1) In this section, we prove that several PSPACE-hard problems are hard to approximate. The PSPACE-complete language SSAT, or "stochastic satisfiability," introduced by Papadim-itriou [21], plays an important role in the proofs in this section. <p> In this section, we prove nonapproximability results for different PSPACE-hard functions, based on the characterization IP = PSPACE obtained in <ref> [16, 22] </ref>. The first problem we consider here is also based on the language SSAT.
Reference: [17] <author> C. Lund and M. Yannakakis, </author> <title> On the Hardness of Approximating Minimization Problems, </title> <journal> J. ACM, </journal> <volume> 41 (1994), </volume> <pages> pp. 960-981. </pages>
Reference-contexts: The result of Arora et al. that NP = PCP (log n; 1) has been applied to prove that several NP-hard problems are hard to approximate closely. These problems include optimization versions of Satisfiability, Independent Set [2, 3], Clique [13], and Colorability <ref> [17] </ref>. For example, the MAX SAT function maps a boolean formula in 3-conjunctive normal form to the maximum number of clauses of that formula that are simultaneously satisfied by some assignment to the variables.
Reference: [18] <author> M. Marathe, H. Hunt III, and S. Ravi, </author> <title> The Complexity of Approximating PSPACE-Complete Problems for Hierarchical Specifications, </title> <booktitle> Proc. 20th International Colloquium On Automata, Languages and Programming, </booktitle> <editor> A. Lingas, R. Karlsson, and S. Carlsson (eds.), </editor> <booktitle> Lecture Notes in Comput. Sci., </booktitle> <volume> vol. </volume> <pages> 700, </pages> <address> Spinger, Berlin, </address> <year> 1993, </year> <pages> pp. 76-87. </pages>
Reference-contexts: One interesting class of results concern problems on hierarchically defined structures, such as graphs. Problems on these structures, and on a related class of periodic structures, arise in many VLSI and scheduling applications (see, for example, <ref> [18] </ref> for references to these and other applications). Because such representations can implicitly describe a structure of exponential size, using just polynomial space, the associated problems are often PSPACE-hard. <p> Orlin did not address whether in fact it might be PSPACE-hard to approximate this function. On the positive side, Marathe et al. <ref> [18] </ref> recently developed constant factor approximation algorithms for PSPACE-hard problems, including the Max Cut and Vertex Cover problems for certain restricted classes of hierarchically represented graphs. <p> There has been other very recent work, both on approximation algorithms and on nonap-proximability results for PSPACE-hard problems. Using direct reductions from variations of the Quantified Satisfiability problem, Hunt et al. [14] and Marathe et al. <ref> [18] </ref> showed that several PSPACE-hard problems are hard to approximate, unless PSPACE = P. These include algebraic problems and graph problems on hierarchically defined graphs.
Reference: [19] <author> M. Marathe, H. Hunt III, R. Stearns, and V. Radhakrishnan, </author> <title> Hierarchical Specifications and Polynomial-Time Approximation Schemes for PSPACE-Complete Problems, </title> <booktitle> Proc. 26th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1994, </year> <pages> pp. 468-477. </pages>
Reference-contexts: On the positive side, Marathe et al. [18] recently developed constant factor approximation algorithms for PSPACE-hard problems, including the Max Cut and Vertex Cover problems for certain restricted classes of hierarchically represented graphs. In related work, Marathe et al. <ref> [19] </ref> applied results of Arora et al.[2] to show that these same problems have polynomial-time approximation schemes if and only if NP = P. In [10], we considered optimization versions of several other problems in PSPACE, including Quantified Satisfiability, Generalized Geography, and Finite Automata Intersection. <p> Using direct reductions from variations of the Quantified Satisfiability problem, Hunt et al. [14] and Marathe et al. [18] showed that several PSPACE-hard problems are hard to approximate, unless PSPACE = P. These include algebraic problems and graph problems on hierarchically defined graphs. Marathe et al. <ref> [19] </ref> proved that several graph problems such as vertex cover and independent set, when restricted to planar, hierarchically defined graphs, are PSPACE-hard and yet do have polynomial-time approximation schemes. They also developed approximation algorithms for restricted optimization problems on periodically defined graphs.
Reference: [20] <author> J. Orlin, </author> <title> The complexity of Dynamic Languages and Dynamic Optimization Problems, </title> <booktitle> Proc. 13th Symposium on Theory of Computing, ACM, </booktitle> <address> New York, </address> <year> 1981, </year> <pages> pp. 218-227. </pages>
Reference-contexts: Because such representations can implicitly describe a structure of exponential size, using just polynomial space, the associated problems are often PSPACE-hard. As early as 1981, Orlin <ref> [20] </ref> claimed a negative result on approximating a PSPACE-hard periodic version of the Knapsack problem, namely that a fully polynomial approximation scheme exists for this problem only if NP = P. Orlin did not address whether in fact it might be PSPACE-hard to approximate this function. <p> They also developed approximation algorithms for restricted optimization problems on periodically defined graphs. Such problems were proved to be PSPACE-hard by Orlin <ref> [20] </ref>. The rest of this paper is organized as follows. Our main result that RPCD (log n; 1) = 6 PSPACE is proven in Section 2. In Section 3, we prove several nonapproximability results for stochastic functions, using this characterization of PSPACE.
Reference: [21] <author> C. Papadimitriou, </author> <title> Games Against Nature, </title> <journal> J. Comput. System Sci., </journal> <volume> 31 (1985), </volume> <pages> pp. 288-301. </pages>
Reference-contexts: An important class of PSPACE-hard problems not previously addressed in this literature is a class of stochastic problems that involve decision-making under uncertainty, as in the games against nature of Papadimitriou <ref> [21] </ref>. In this paper, we develop a new technique for showing that these stochastic PSPACE-hard problems are hard to approximate. Informally, these are problems in which the instances involve probabilities in some essential way. <p> The probabilities may describe failures of arcs in a digraph or moves of one of the players in a game. Examples of functions that we prove are hard to approximate include optimization versions of Stochastic Satisfiability <ref> [21] </ref>, Stochastic Generalized Geography, Dynamic Graph Reliability [21], and Mah-Jongg. We describe two of these problems in more detail below. Precise definitions of all of the functions of interest can be found in Section 3. <p> The probabilities may describe failures of arcs in a digraph or moves of one of the players in a game. Examples of functions that we prove are hard to approximate include optimization versions of Stochastic Satisfiability <ref> [21] </ref>, Stochastic Generalized Geography, Dynamic Graph Reliability [21], and Mah-Jongg. We describe two of these problems in more detail below. Precise definitions of all of the functions of interest can be found in Section 3. <p> We also use the identity IP = PSPACE [16, 23] to derive nonapproximability results for other stochastic PSPACE-hard functions. Examples of the functions that yield to this technique include optimization versions of Dynamic Markov Process <ref> [21] </ref> and Stochastic Coloring, as well as a different optimization version of Stochastic Satisfiability. We now give two examples that illustrate the kind of problems to which our new technique applies. <p> by Valiant [25]: Given a directed, acyclic graph G, source and sink vertices s and t, and a failure probability p (v; w) for each arc (v; w), what is the probability that there is a path from s to t consisting exclusively of arcs that have not failed? Papadimitriou <ref> [21] </ref> defines Dynamic Graph Reliability (DGR) as follows: The goal of a strategy is still to traverse the digraph from s to t. <p> The PSPACE-complete language SSAT, or "stochastic satisfiability," introduced by Papadim-itriou <ref> [21] </ref>, plays an important role in the proofs in this section. In Section 3.1, we define the language SSAT and, using our result that PSPACE = RPCD (log n; 1), we show that the corresponding optimization problem is hard to approximate. <p> by Valiant [25]: Given a directed, acyclic graph G, source and sink vertices s and t, and a failure probability p (v; w) for each arc (v; w), what is the probability that there is a path from s to t consisting exclusively of arcs that have not failed? Papadimitriou <ref> [21] </ref> defines Dynamic Graph Reliability (DGR) as follows: The goal of a strategy is still to traverse the digraph from s to t. <p> The value of MAX-PROB SSAT on a given instance is the probability that is satisfied if the existential player follows an optimal strategy. The language SSAT, as defined in <ref> [21] </ref>, consists of all instances for which MAX-PROB SSAT () &gt; 1=2. The reductions in this section are based on the following fact, which is a direct consequence of the proof that IP = PSPACE. <p> The next theorem is a direct consequence of Fact 4.1. Theorem 4.2 There is a constant c &gt; 0 such that approximating MAX-PROB SSAT within ratio 2 n c is PSPACE-hard. Papadimitriou <ref> [21] </ref> defines the language Dynamic Markov Process (DMP). An instance is a set S of states and an n fi n stochastic matrix P , where n = jSj. <p> A 30 natural optimization problem is MIN DMP, the function that maps (S; P; fD i g; c; fR d g) to the expected cost of an optimal strategy. Papadimitriou <ref> [21] </ref> proves that DMP is PSPACE-complete by providing a reduction from SSAT.
Reference: [22] <author> T. J. Schaefer, </author> <title> On the Complexity of Some Two-Person Perfect-Information Games, </title> <journal> J. Comput. System Sci., </journal> <volume> 16 (1978), </volume> <pages> pp. 185-225. </pages>
Reference-contexts: Generalized Geography, as defined by Schaefer <ref> [22] </ref>, is a game played on a directed graph G with a distinguished vertex s. <p> In this section, we prove nonapproximability results for different PSPACE-hard functions, based on the characterization IP = PSPACE obtained in <ref> [16, 22] </ref>. The first problem we consider here is also based on the language SSAT. <p> Examples include the following. * In the Node Kayles game of Schaefer <ref> [22] </ref>), the input is a graph. A move consists of putting a marker on an unoccupied vertex that is not adjacent to any occupied vertex. The first player unable to move loses.
Reference: [23] <author> A. Shamir, </author> <title> IP = PSPACE, </title> <journal> J. ACM, </journal> <volume> 39 (1992), </volume> <pages> pp. 869-877. </pages>
Reference-contexts: We also use the identity IP = PSPACE <ref> [16, 23] </ref> to derive nonapproximability results for other stochastic PSPACE-hard functions. Examples of the functions that yield to this technique include optimization versions of Dynamic Markov Process [21] and Stochastic Coloring, as well as a different optimization version of Stochastic Satisfiability. <p> Our new characterization of PSPACE, which is used in proving nonapproximability results for these problems, builds on techniques developed in our previous work on probabilistically checkable debate systems (PCDS's) [10], which in turn builds on techniques of Arora et al. [2], Lund et al. [16] and Shamir <ref> [23] </ref>. In a PCDS for L, there are two computa-tionally powerful players, 1 and 0, and a probabilistic polynomial-time verifier V . Players 1 and 0 play a game in which they alternate writing strings on a debate tape . <p> Thus, the class of languages accepted by Arthur-Merlin games is by definition RPCD (0; poly (n)) and is commonly denoted by IP. It is known that RPCD (0; poly (n)) = PSPACE <ref> [16, 23] </ref>. In this paper, we prove the following result. Theorem: RPCD (log n; 1) = PSPACE. This theorem shows that a verifier that tosses O (log n) coins does not have to read the entire debate between Arthur and Merlin. <p> The second part then shows how the constant number of rounds in this result can be replaced by a constant number of bits. This second part is proved by extending the work of Arora et al. on PCPS's. The result IP = PSPACE <ref> [16, 23] </ref> shows that Chandra et al.'s characterization of PSPACE is true even if one of the two players uses the unsophisticated strategy of simply selecting a move at random. That is, polynomial-time alternating Turing machines and polynomial-round Arthur-Merlin games accept the same class of languages. <p> To prove the (harder) direction that PSPACE RPCD (log n; 1), we build on several techniques of Lund et al. [16], Shamir <ref> [23] </ref>, Arora et al. [3, 2] and Condon et al. [10]. We first describe these results, and in Lemma 2.3 we put them together to prove PSPACE RPCD (log n; 1). <p> The correctness of this protocol follows from Arora et al. [2, 3]. For details, see [10]. The next lemma is implicit in the proof that IP = PSPACE <ref> [16, 23] </ref>. Lemma 2.2 Let L be a language in PSPACE and x = x 1 x 2 : : : x n be an input. <p> Finally, g m is a polynomial-time computable function, and the degree of all the poly nomials is bounded by d = poly (n). In <ref> [16, 23] </ref>, each g i is a polynomial that can be explicitly written as a formula of polynomial length in terms of sums and products but may result in a formula of exponential length when these sums and products are expanded. <p> Finally, the verifier checks that the g m -question written in the last round of the debate is good; by property (3) of Lemma 2.2, this can be done in polynomial time. If all three checks are passed, the verifier accepts, else the verifier rejects. For details, see <ref> [16, 23] </ref>. Unfortunately, this protocol requires that the verifier read all rounds of the debate system. <p> Combining this with the result that RPCD (0; poly (n)) = IP = PSPACE <ref> [16, 23] </ref> gives Theorem 2.4. 3 Nonapproximability Results based on RPCD (log n; 1) In this section, we prove that several PSPACE-hard problems are hard to approximate. The PSPACE-complete language SSAT, or "stochastic satisfiability," introduced by Papadim-itriou [21], plays an important role in the proofs in this section.
Reference: [24] <author> M. Sudan, </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems, </title> <type> PhD Thesis, </type> <institution> University of California, Computer Science Division, Berkeley CA, </institution> <year> 1992. </year>
Reference-contexts: A PCPS is simply a PCDS with just one player, Player 1, in which case the "debate" corresponds to a "proof." (See Arora et al. [2, 3] or Sudan <ref> [24] </ref> for an overview of PCPS's.) If the verifier is deterministic and reads all bits of the proof, the model is equivalent in power to a nondeterministic Turing machine, where the proof corresponds to the nondeterministic moves. Thus, by definition, NP = PCP (0; poly (n)).
Reference: [25] <author> L. Valiant, </author> <title> The Complexity of Enumeration and Reliability Problems, </title> <journal> SIAM J. Com-put., </journal> <volume> 8 (1979), </volume> <pages> pp. 410-421. 35 </pages>
Reference-contexts: We now give two examples that illustrate the kind of problems to which our new technique applies. The first is a variant of Graph Reliability, a #P -complete problem studied by Valiant <ref> [25] </ref>: Given a directed, acyclic graph G, source and sink vertices s and t, and a failure probability p (v; w) for each arc (v; w), what is the probability that there is a path from s to t consisting exclusively of arcs that have not failed? Papadimitriou [21] defines Dynamic <p> We note that the result of Theorem 3.2 could also be proved using a reduction from the MAX-PROB SSAT function, defined in the Section 4. 3.3 Dynamic Graph Reliability (DGR) Graph Reliability is a #P -complete problem studied by Valiant <ref> [25] </ref>: Given a directed, acyclic graph G, source and sink vertices s and t, and a failure probability p (v; w) for each arc (v; w), what is the probability that there is a path from s to t consisting exclusively of arcs that have not failed? Papadimitriou [21] defines Dynamic
References-found: 25

