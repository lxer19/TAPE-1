URL: http://www.cs.mu.oz.au/tr_db/mu_93_10.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: The Aditi deductive database system  
Author: Jayen Vaghani, Kotagiri Ramamohanarao, David B. Kemp, Zoltan Somogyi, Peter J. Stuckey, Tim S. Leask, James Harland 
Address: Parkville, 3052 Victoria, Australia  
Affiliation: Collaborative Information Technology Research Institute Department of Computer Science, University of Melbourne  
Abstract: Deductive databases generalize relational databases by providing support for recursive views and non-atomic data. Aditi is a deductive database system based on the client-server model: it is inherently multi-user and capable of exploiting parallelism on shared-memory multiprocessors. The back-end uses relational technology for efficiency in the management of disk based data and uses optimization algorithms especially developed for the bottom-up evaluation of logical queries involving recursion. The front-end interacts with the user in a logical language that has more expressive power than relational query languages. We present the structure of Aditi, discuss its components in some detail, and present performance figures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin, G. Port, K. Ramamohanarao, and K. Meenakshi. </author> <title> Efficient bottom-up computation of queries on stratified databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 295-345, </pages> <year> 1991. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [2] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3) </volume> <pages> 259-262, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: both relations; for in list, it will use the magic set optimization as well. (Actually, the diff flags can be omitted, as differential evaluation is the default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation <ref> [2] </ref> * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation [3, 4] * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long <p> The interface procedures call the procedure containing the iteration and select the data they need from it. The translation from HDS to LDS can take any one of several different paths. The default compilation approach is semi-naive or differential evaluation <ref> [2] </ref>, but naive evaluation, magic-set interpreter evaluation [21] and predicate semi-naive evaluation [22] are also available. This is also where the alternating fixpoint evaluation method [13] required for non-stratified programs will fit in. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [3] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Washington DC., </address> <year> 1986. </year>
Reference-contexts: can be omitted, as differential evaluation is the default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation <ref> [3, 4] </ref> * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation <ref> [3, 4] </ref>, supplementary magic set transformation [26], counting set transformation [3, 27], constraint propagation [11, 19], and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations. <p> The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation [26], counting set transformation <ref> [3, 27] </ref>, constraint propagation [11, 19], and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations.
Reference: [4] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: can be omitted, as differential evaluation is the default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation <ref> [3, 4] </ref> * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation <ref> [3, 4] </ref>, supplementary magic set transformation [26], counting set transformation [3, 27], constraint propagation [11, 19], and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations.
Reference: [5] <author> J. Harland, D. B. Kemp, T. S. Leask, K. Ramamohanarao, J. A. Shepherd, Z. Som-ogyi, P. J. Stuckey, and J. Vaghani. </author> <title> Aditi-Prolog language manual. </title> <type> Technical Report 92/27, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: When aggregation is part of an Aditi-Prolog program, it must respect stratification the same way as negation. For further details of the language, see the Aditi-Prolog language manual <ref> [5] </ref>. The Aditi-Prolog compiler is called "apc". Its interface is intentionally similar to the interface of other compilers on Unix systems, e.g. cc. <p> For more details on the Aditi/NU-Prolog interface, including the facilities for updating Aditi relations from NU-Prolog, see <ref> [5] </ref>. 3.5 The Aditi relational language RL is a simple procedural language whose primitive operations are those needed for database implementation. <p> Those who would like to learn more about Aditi should refer to the Aditi users's guide <ref> [5] </ref>, the Aditi-Prolog language manual [6], and the report describing the flights database from which the second set of tests in section 5 was drawn [8]. The Aditi system itself is available to interested researchers.
Reference: [6] <author> J. Harland, D. B. Kemp, T. S. Leask, K. Ramamohanarao, J. A. Shepherd, Z. Somogyi, P. J. Stuckey, and J. Vaghani. </author> <title> Aditi users' guide. </title> <type> Technical Report 92/26, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: The query shell's ability to record a history of previous 9 queries, and to recall a given previous query, possibly edit it and then execute it, derives from this source. For a full list of the capabilities of the query shell, see <ref> [6] </ref>. 3.2 The SQL query shell Aditi includes a prototype of a query shell that accepts SQL as input. This prototype is based on an SQL to NU-Prolog translator that was developed several years ago by Philip Dart at the University of Melbourne as an educational tool for our undergraduates. <p> Those who would like to learn more about Aditi should refer to the Aditi users's guide [5], the Aditi-Prolog language manual <ref> [6] </ref>, and the report describing the flights database from which the second set of tests in section 5 was drawn [8]. The Aditi system itself is available to interested researchers.
Reference: [7] <author> J. Harland and K. Ramamohanarao. </author> <title> Constraint propagation for linear recursive rules. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system. <p> Our projects for the future include: * Integrating our prototype compiler that generates code for non-stratified negation into the main Aditi system. * Implementing high-level optimizations such as constraint propagation [11] and the new transformation for linear predicates <ref> [7] </ref>. * Implementing low-level optimizations such as redundant code elimination. * Extending Aditi-Prolog by providing types and a sophisticated system of modes based on these types. * Using the mode system to allow the handling of partially-instantiated data structures; we already know how to do this without subsumption tests. * Adding
Reference: [8] <author> J. Harland and K. Ramamohanarao. </author> <title> Experiences with a flights database. </title> <type> Technical Report 92/28, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> November </month> <year> 1992. </year> <month> 35 </month>
Reference-contexts: We expect that the results will continue to improve in the future. Our other test program is based on the first realistic application of Aditi, which is a database containing data about flights around the world <ref> [8] </ref>. Since we were unable to get real data in sufficient quantity, the information in this database, although derived from schedules published by airlines, is mainly the product of our imagination. <p> Those who would like to learn more about Aditi should refer to the Aditi users's guide [5], the Aditi-Prolog language manual [6], and the report describing the flights database from which the second set of tests in section 5 was drawn <ref> [8] </ref>. The Aditi system itself is available to interested researchers. It has already been distributed to about a dozen sites around the world. 34 Acknowledgements Many people have contributed significantly to Aditi both by performing research and by developing software.
Reference: [9] <author> D. Kemp and P. Stuckey. </author> <title> Analysis based constraint query optimization. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [10] <author> D. Kemp, P. Stuckey, and D. Srivastava. </author> <title> Query restricted bottom-up evaluation of normal logic programs. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 288-302, </pages> <address> Washington DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> Aditi-Prolog programs may include disjunction and negation. Like most deductive databases, Aditi currently supports only stratified forms of negation. However, this may change in the future, since we have developed a practical algorithm for computing answers to queries even in the presence of unstratified negation <ref> [10, 13] </ref>. This algorithm works on a magic-transformed program where each predicate has two slightly different versions. At each iteration, the algorithm uses one set of versions to compute a set of definitely true facts, the other set to compute a set of possibly true facts. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [11] <author> D. B. Kemp, K. Ramamohanarao, I. Balbin, and K. Meenakshi. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proceedings of the First North American Conference on Logic Programming, </booktitle> <pages> pages 981-998, </pages> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation [26], counting set transformation [3, 27], constraint propagation <ref> [11, 19] </ref>, and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system. <p> Our projects for the future include: * Integrating our prototype compiler that generates code for non-stratified negation into the main Aditi system. * Implementing high-level optimizations such as constraint propagation <ref> [11] </ref> and the new transformation for linear predicates [7]. * Implementing low-level optimizations such as redundant code elimination. * Extending Aditi-Prolog by providing types and a sophisticated system of modes based on these types. * Using the mode system to allow the handling of partially-instantiated data structures; we already know how
Reference: [12] <author> D. B. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation [3, 4] * the supplementary magic set transformation [26] * the context transformations for linear rules <ref> [12] </ref> * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> This code declares a derived predicate called path that expects to be called with its first argument ground, and directs the compiler to apply the optimization method known as the context transformation <ref> [12] </ref>. The body of the predicate defines path to be the transitive closure of the edge relation, just as the trip predicate is a kind of transitive closure of the flight relation. <p> The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation [26], counting set transformation [3, 27], constraint propagation [11, 19], and context transformations for linear rules <ref> [12] </ref>. Currently the compiler performs the magic, supplementary magic, and context transformations. To help guide the implementation of these transformations the compiler uses the predicate call graph, a graph that has one node for each mode of each relation and whose edges represent caller-callee relationships. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [13] <author> D. B. Kemp, P. J. Stuckey, and D. Srivastava. </author> <title> Magic sets and bottom-up evaluation of well-founded models. </title> <booktitle> In Proceedings of the 1991 International Logic Programming Symposium, </booktitle> <pages> pages 337-351, </pages> <address> San Diego, California, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: From then on we have continuously enhanced the system, adding functionality and increasing performance. We also use Aditi as a research tool, as a platform on which to implement and evaluate new query evaluation algorithms and optimization techniques <ref> [1, 7, 9, 10, 11, 12, 13] </ref>. As of January 1993, interested researchers can obtain a beta-test copy of Aditi under a no-cost license. The distribution includes two text-based interfaces that accept Aditi-Prolog and SQL respectively, a graphical user interface, and a programming interface to NU-Prolog. <p> Aditi-Prolog programs may include disjunction and negation. Like most deductive databases, Aditi currently supports only stratified forms of negation. However, this may change in the future, since we have developed a practical algorithm for computing answers to queries even in the presence of unstratified negation <ref> [10, 13] </ref>. This algorithm works on a magic-transformed program where each predicate has two slightly different versions. At each iteration, the algorithm uses one set of versions to compute a set of definitely true facts, the other set to compute a set of possibly true facts. <p> The translation from HDS to LDS can take any one of several different paths. The default compilation approach is semi-naive or differential evaluation [2], but naive evaluation, magic-set interpreter evaluation [21] and predicate semi-naive evaluation [22] are also available. This is also where the alternating fixpoint evaluation method <ref> [13] </ref> required for non-stratified programs will fit in. The magic set interpreter computes magic sets for the called relations while it is performing joins in the calling rule body. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [14] <author> D. E. Knuth. </author> <title> Sorting and searching, </title> <booktitle> volume 3 of The Art of Computer Programming, chapter 5.4.1. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1973. </year>
Reference-contexts: Since no single join method works optimally in all situations, Aditi currently supports four join algorithms: sort/merge join, hash join, nested block join and indexed join. Sort/merge join, like other sort-based Aditi operations, uses the external merge-sort algorithm described in <ref> [14] </ref>. To make sure that the overhead of extracting sort keys from a tuple is paid only once, not every time the tuple appears in a comparison, our implementation uses prepended sort keys [16].
Reference: [15] <author> T. S. Leask, K. Ramamohanarao, and P. J. Stuckey. </author> <title> Exploiting parallelism in bottom-up computation in Aditi. </title> <booktitle> In Proceedings of the ILPS '91 Workshop on Deductive Databases, </booktitle> <pages> pages 72-81, </pages> <address> San Diego, California, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation [3, 4] * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation <ref> [15] </ref> * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> The DAP executes every RL operation in the context of a thread. Sequential RL code only ever has one thread: parallel code creates and destroys threads as necessary. We have developed two compilation schemes for managing thread activity <ref> [15] </ref>: one is based on the fork-join approach and the other on dataflow methods. The fork-join approach is very simple: whenever the compiler knows that two or more operations or operation sequences are independent, it creates a thread for each operation sequence.
Reference: [16] <author> J. Linderman. </author> <title> Theory and practice in the construction of a working sort routine. </title> <journal> Bell Laboratories Technical Journal, </journal> <volume> 63(8 (part </volume> 2)):1827-1843, October 1984. 
Reference-contexts: Sort/merge join, like other sort-based Aditi operations, uses the external merge-sort algorithm described in [14]. To make sure that the overhead of extracting sort keys from a tuple is paid only once, not every time the tuple appears in a comparison, our implementation uses prepended sort keys <ref> [16] </ref>. Since the schema format supports relations with prepended keys, our sort routine can leave the sort keys in place, and will if the calling procedure indicates it wishes to use them.
Reference: [17] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: a transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 94-162, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Thus we can create unindexed files, btree files, ssimc files and dsimc files in-core with no change to any of the indexing code. At present, Aditi has no transaction mechanism. We are currently modifying the code of the buffer caches to support the ARIES model of write-ahead logging <ref> [17] </ref>. We are also looking at higher level issues related to transactions, e.g. how best to resolve simultaneous updates. As recursive computations can take long periods of time, overlapping updates are more likely in deductive databases than in relational databases.
Reference: [18] <author> K. Morris, J. F. Naughton, Y. Saraiya, J. D. Ullman, and A. V. Gelder. </author> <title> YAWN! (yet another window on NAIL! IEEE Data Engineering, </title> <booktitle> 10(4) </booktitle> <pages> 28-43, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Eventually, of course, we intend to distill the results of these investigations into code that automatically selects the best set of optimizations for each predicate in the program (like the strategy module of <ref> [18] </ref>). Aditi-Prolog programs may include disjunction and negation. Like most deductive databases, Aditi currently supports only stratified forms of negation. However, this may change in the future, since we have developed a practical algorithm for computing answers to queries even in the presence of unstratified negation [10, 13].
Reference: [19] <author> I. S. Mumick, S. J. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic conditions. </title> <booktitle> In Proceedings of the Ninth Symposium on Principles of Database Systems, </booktitle> <pages> pages 314-330, </pages> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation [26], counting set transformation [3, 27], constraint propagation <ref> [11, 19] </ref>, and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations.
Reference: [20] <author> M. Nakayama, M. Kitsuregawa, and M. Takagi. </author> <title> Hash-partitioned join method using dynamic destaging strategy. </title> <booktitle> In Proceedings of the Fourteenth Conference on Very Large Data Bases, </booktitle> <pages> pages 468-477, </pages> <address> Los Angeles, </address> <year> 1988. </year>
Reference-contexts: We are working on schemes that would enable multiple RAPs to co-operate in sorting a single relation in parallel, and on parallel hash based join algorithms <ref> [20] </ref>. At the opposite end of the spectrum, there are some tasks that are too small for RAPs.
Reference: [21] <author> G. Port, I. Balbin, and K. Ramamohanarao. </author> <title> A new approach to supplementary magic optimisation. </title> <booktitle> In Proceedings of the First Far-East Workshop on Future Database Systems, </booktitle> <pages> pages 89-104, </pages> <address> Melbourne, Australia, </address> <month> April </month> <year> 1990. </year> <month> 36 </month>
Reference-contexts: as well. (Actually, the diff flags can be omitted, as differential evaluation is the default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter <ref> [21] </ref> * the magic set transformation [3, 4] * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> The interface procedures call the procedure containing the iteration and select the data they need from it. The translation from HDS to LDS can take any one of several different paths. The default compilation approach is semi-naive or differential evaluation [2], but naive evaluation, magic-set interpreter evaluation <ref> [21] </ref> and predicate semi-naive evaluation [22] are also available. This is also where the alternating fixpoint evaluation method [13] required for non-stratified programs will fit in. The magic set interpreter computes magic sets for the called relations while it is performing joins in the calling rule body.
Reference: [22] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 359-371, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: it will use the magic set optimization as well. (Actually, the diff flags can be omitted, as differential evaluation is the default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation <ref> [22] </ref> * evaluation by magic set interpreter [21] * the magic set transformation [3, 4] * the supplementary magic set transformation [26] * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. <p> The translation from HDS to LDS can take any one of several different paths. The default compilation approach is semi-naive or differential evaluation [2], but naive evaluation, magic-set interpreter evaluation [21] and predicate semi-naive evaluation <ref> [22] </ref> are also available. This is also where the alternating fixpoint evaluation method [13] required for non-stratified programs will fit in. The magic set interpreter computes magic sets for the called relations while it is performing joins in the calling rule body.
Reference: [23] <author> K. Ramamohanarao and J. Shepherd. </author> <title> A superimposed codeword indexing scheme for very large Prolog databases. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 569-576, </pages> <address> London, England, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: There is a fair amount of research on techniques for deriving the optimal values of these parameters. The best place to look for a fuller explanation and details is in <ref> [23] </ref> for ssimc and [24] for dsimc; these papers have the full details of the two storage structures as well. As we will show in section 4.4, Aditi's design allows other storage structures to be added later. <p> The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [24] <author> K. Ramamohanarao and J. Shepherd. </author> <title> Partial match retrieval for dynamic files using superimposed codeword indexing. </title> <editor> In E. Balagurusamy and B. Sushila, editors, </editor> <booktitle> Computer systems and applications: recent trends, </booktitle> <pages> pages 281-290. </pages> <publisher> McGraw-Hill, </publisher> <address> New Delhi, India, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: There is a fair amount of research on techniques for deriving the optimal values of these parameters. The best place to look for a fuller explanation and details is in [23] for ssimc and <ref> [24] </ref> for dsimc; these papers have the full details of the two storage structures as well. As we will show in section 4.4, Aditi's design allows other storage structures to be added later.
Reference: [25] <author> K. Ramamohanarao, J. Shepherd, I. Balbin, G. Port, L. Naish, J. Thom, J. Zobel, and P. </author> <title> Dart. The NU-Prolog deductive database system. </title> <editor> In P. Gray and R. Lucas, editors, </editor> <booktitle> Prolog and databases, </booktitle> <pages> pages 212-250. </pages> <publisher> Ellis Horwood, </publisher> <address> Chicester, England, </address> <year> 1988. </year>
Reference-contexts: The upper layers are derived mostly from research specific to deductive databases. Many aspects in both layers build on original research by members of the Aditi team <ref> [1, 2, 7, 9, 10, 11, 12, 13, 23, 25] </ref>. Much of this research in turn used Aditi as a testbed in which to try out and evaluate ideas. Aditi is a true database system.
Reference: [26] <author> D. Sacca and C. Zaniolo. </author> <title> Implementation of recursive queries for a data language based on pure horn logic. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 104-135, </pages> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: default.) The set of flags supported by the current version of Aditi allows users to request * naive evaluation * differential or semi-naive evaluation [2] * predicate semi-naive evaluation [22] * evaluation by magic set interpreter [21] * the magic set transformation [3, 4] * the supplementary magic set transformation <ref> [26] </ref> * the context transformations for linear rules [12] * parallel evaluation [15] * top-down tuple-at-a-time evaluation (see section 4.3) This is quite a long list. What's more, users may specify several flags for one predicate. <p> The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation <ref> [26] </ref>, counting set transformation [3, 27], constraint propagation [11, 19], and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations.
Reference: [27] <author> D. Sacca and C. Zaniolo. </author> <title> The generalized counting method for recursive logic queries. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 31-53, </pages> <address> Rome, Italy, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The HDS to HDS level is where the compiler implements the optimizations that are defined in terms of source-to-source transformations. The optimizations that fit here include 17 magic set transformation [3, 4], supplementary magic set transformation [26], counting set transformation <ref> [3, 27] </ref>, constraint propagation [11, 19], and context transformations for linear rules [12]. Currently the compiler performs the magic, supplementary magic, and context transformations.
Reference: [28] <author> J. A. Thom and J. A. Zobel. </author> <title> NU-Prolog reference manual, version 1.3. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1988. </year>
Reference-contexts: is exactly what the current compiler version produces for the four-line definition of path at the beginning of this section; the only modification we made for presentation was to add some white space. 3.6 The compiler The compiler that turns programs written in Aditi-Prolog into RL is written in NU-Prolog <ref> [28] </ref>. Unlike most compilers, it represents programs in not one but two intermediate languages, which we call HDS and LDS (for "high-level data structure" and "low-level data structure" respectively). HDS provides an easy-to-manipulate representation of Prolog rules while LDS provides an easy-to-manipulate representation of RL programs.
Reference: [29] <author> J. D. Ullman. </author> <title> Implementation of logical query languages for databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(3) </volume> <pages> 289-321, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Some of the tasks required for the latter are trivial, such as finding the scopes of all variables, while others can have great impact on the performance of the final code. The most important of these tasks is the selection of an appropriate sideways information-passing strategy or sip <ref> [29] </ref> for each rule in the input Aditi-Prolog program. To find a sip the compiler needs to know the valid modes of the relations appearing in the rules, and if they are base relations, it needs to know their indexing too.
Reference: [30] <author> J. Vaghani, , K. Ramamohanarao, D. B. Kemp, Z. Somogyi, and P. J. Stuckey. </author> <title> Design overview of the Aditi deductive database system. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 240-247, </pages> <month> April </month> <year> 1991. </year> <month> 37 </month>
Reference-contexts: However, as a rough indicator our current results represent speedups of ten to fifty times over the results presented in previous papers on Aditi <ref> [30] </ref>. These speedups come from improvements in the Aditi back-end and in the Aditi compiler, the main improvements being the use of indexes in joins, the use of btmerge to eliminate duplicates, and keeping temporary relations in main memory whenever possible.
References-found: 30

