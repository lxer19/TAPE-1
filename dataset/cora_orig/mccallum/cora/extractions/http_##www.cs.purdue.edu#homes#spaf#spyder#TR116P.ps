URL: http://www.cs.purdue.edu/homes/spaf/spyder/TR116P.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/spyder.html
Root-URL: http://www.cs.purdue.edu
Title: Heuristics for Automatic Localization of Software Faults  
Author: Hsin Pan Eugene H. Spafford 
Keyword: software testing, debugging, dynamic program slicing, fault localization.  
Note: July 29, 1992  
Address: Building  West Lafayette, IN 47907-1398  
Affiliation: Software Engineering Research Center 1398 Computer Sciences  Purdue University  
Pubnum: Technical Report SERC-TR-116-P  
Email: fpan, spafg@cs.purdue.edu  
Abstract: Developing effective debugging strategies to guarantee the reliability of software is important. By analyzing the debugging process used by experienced programmers, four distinct tasks are found to be consistently performed: (1) determining statements involved in program failures, (2) selecting suspicious statements that might contain faults, (3) making hypotheses about suspicious faults (variables and locations), and (4) restoring program state to a specific statement for verification. If all four tasks could be performed with direct assistance from a debugging tool, the debugging effort would become much easier. We have built a prototype debugging tool, Spyder, to assist users in conducting the first and last tasks. Spyder executes the first task by using dynamic program slicing and the fourth task by backward execution. This research focuses on the second task, reducing the search domain containing faults, referred to as fault localization. Several heuristics are presented here based on dynamic program slices and information obtained from testing. A family tree of the heuristics is constructed to study effective application of the heuristics. The relationships among the heuristics and the potential order of using them are also explored. A preliminary study was conducted to examine the effectiveness of the heuristics proposed. Results of our study show the promise of fault localization based on these heuristics as well as suggest criteria for precise application of the heuristics (e.g., the standard of selecting thresholds). A new debugging paradigm equipped with these heuristics is expected to reduce human interaction time significantly and aid in the debugging of complex software. fl This research was supported, in part, by a grant from the Software Engineering Research Center at Purdue University, a National Science Foundation Industry/University Cooperative Research Center (NSF Grant ECD-8913133), and by National Science Foundation Grant CCR-8910306. A condensed version of this paper appears as [33]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, R. A. DeMillo, and E. H. Spafford. </author> <title> Dynamic slicing in the presence of unconstrained pointers. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 60-73, </pages> <address> Victoria, British Columbia, Canada, </address> <month> October 8-10 </month> <year> 1991. </year>
Reference-contexts: Obviously, the debugging effort would become much easier if all four tasks could be performed with direct assistance from a debugging tool. We have built a prototype debugging tool, Spyder <ref> [1, 2, 4, 6] </ref>, to assist users in conducting the first and last tasks. <p> We have built a prototype debugging tool, Spyder [1, 2, 4, 6], to assist users in conducting the first and last tasks. Spyder performs the first task by using Dynamic Program Slicing <ref> [1, 3] </ref>, and can automatically find the dynamic slice of a program for any given variables, locations, and test cases in terms of data and control dependency analysis. <p> can restore the program state to a desired location by backtracking the program execution to that location and need not reexecute the program from the beginning. 1 The work described in this paper focuses on the second task to reduce the search domain containing faults 1 Readers are referred to <ref> [1, 3] </ref> and [2, 4] for more details on dynamic program slicing and backtracking, respectively. 2 referred to as fault localization. Several heuristics based on both dynamic program slices provided by Spyder and information obtained from testing are proposed. The rest of this paper is organized as follows. <p> Focus [28] is a debugging tool based on program dicing to find the likely location of a fault. Because static program slices contain many irrelevant statements that make fault localization inefficient, studying program slicing based on dynamic cases to get the exact execution path is warranted. Dynamic Program Slicing <ref> [1, 3, 6, 25] </ref> is a powerful facility for debugging and dependency analysis. Nevertheless, it has not been systematically applied to fault localization. In Agrawal's dissertation [6], he briefly alluded to the idea of combining dynamic program slices and data slices for fault localization.
Reference: [2] <author> H. Agrawal, R. A. DeMillo, and E. H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 21-26, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Obviously, the debugging effort would become much easier if all four tasks could be performed with direct assistance from a debugging tool. We have built a prototype debugging tool, Spyder <ref> [1, 2, 4, 6] </ref>, to assist users in conducting the first and last tasks. <p> program state to a desired location by backtracking the program execution to that location and need not reexecute the program from the beginning. 1 The work described in this paper focuses on the second task to reduce the search domain containing faults 1 Readers are referred to [1, 3] and <ref> [2, 4] </ref> for more details on dynamic program slicing and backtracking, respectively. 2 referred to as fault localization. Several heuristics based on both dynamic program slices provided by Spyder and information obtained from testing are proposed. The rest of this paper is organized as follows.
Reference: [3] <author> H. Agrawal and J. R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> (ACM SIGPLAN Notices, </journal> <volume> 25(6), </volume> <month> June </month> <year> 1990). </year>
Reference-contexts: We have built a prototype debugging tool, Spyder [1, 2, 4, 6], to assist users in conducting the first and last tasks. Spyder performs the first task by using Dynamic Program Slicing <ref> [1, 3] </ref>, and can automatically find the dynamic slice of a program for any given variables, locations, and test cases in terms of data and control dependency analysis. <p> can restore the program state to a desired location by backtracking the program execution to that location and need not reexecute the program from the beginning. 1 The work described in this paper focuses on the second task to reduce the search domain containing faults 1 Readers are referred to <ref> [1, 3] </ref> and [2, 4] for more details on dynamic program slicing and backtracking, respectively. 2 referred to as fault localization. Several heuristics based on both dynamic program slices provided by Spyder and information obtained from testing are proposed. The rest of this paper is organized as follows. <p> Focus [28] is a debugging tool based on program dicing to find the likely location of a fault. Because static program slices contain many irrelevant statements that make fault localization inefficient, studying program slicing based on dynamic cases to get the exact execution path is warranted. Dynamic Program Slicing <ref> [1, 3, 6, 25] </ref> is a powerful facility for debugging and dependency analysis. Nevertheless, it has not been systematically applied to fault localization. In Agrawal's dissertation [6], he briefly alluded to the idea of combining dynamic program slices and data slices for fault localization.
Reference: [4] <author> H. Agrawal and E. H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <booktitle> In Proceedings of the 6th Pacific Northwest Software Quality Conference, </booktitle> <pages> pages 283-299, </pages> <address> Portland, Oregon, </address> <month> September 19-20 </month> <year> 1988. </year>
Reference-contexts: Obviously, the debugging effort would become much easier if all four tasks could be performed with direct assistance from a debugging tool. We have built a prototype debugging tool, Spyder <ref> [1, 2, 4, 6] </ref>, to assist users in conducting the first and last tasks. <p> program state to a desired location by backtracking the program execution to that location and need not reexecute the program from the beginning. 1 The work described in this paper focuses on the second task to reduce the search domain containing faults 1 Readers are referred to [1, 3] and <ref> [2, 4] </ref> for more details on dynamic program slicing and backtracking, respectively. 2 referred to as fault localization. Several heuristics based on both dynamic program slices provided by Spyder and information obtained from testing are proposed. The rest of this paper is organized as follows.
Reference: [5] <author> H. Agrawal and E. H. Spafford. </author> <title> A bibliography on debugging and backtracking. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 14(2) </volume> <pages> 49-56, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Conventional debugging tools (e.g., ADB and DBX [15]) are command-driven and tend to be stand-alone. Many fault localization techniques used in current debugging tools (e.g., setting breakpoints) were developed in the 1960s and have changed little <ref> [5] </ref>. Users have to discover by themselves useful information for debugging. Two major steps involved in the debugging process are locating and correcting faults. Previous studies [30, 41] found that locating faults is the most difficult and important task in debugging.
Reference: [6] <author> Hiralal Agrawal. </author> <title> Towards Automatic Debugging of Computer Programs. </title> <type> PhD thesis, </type> <institution> Purdue University, West Lafayette, Indiana, </institution> <month> August </month> <year> 1991. </year> <note> (Also released as Technical Report SERC-TR-103-P, </note> <institution> Software Engineering Research Center, Purdue University, West Lafayette, Indiana, </institution> <month> September </month> <year> 1991). </year> <month> 18 </month>
Reference-contexts: Obviously, the debugging effort would become much easier if all four tasks could be performed with direct assistance from a debugging tool. We have built a prototype debugging tool, Spyder <ref> [1, 2, 4, 6] </ref>, to assist users in conducting the first and last tasks. <p> A dynamic slice is denoted as Dyn (P; v; l; t), where P is the target program, v is a given variable, l is the location of v, and t is a given test case <ref> [6] </ref>. Dyn (P; v; l; t) contains statements of P actually affecting the value of v at location l when P is executed against test case t. Execution paths of the program with given inputs are special cases of Dynamic Program Slicing. <p> For some types of faults (e.g., missing assignment), our heuristics cannot directly cover the faults in suggested domains. However, analyzing the statements highlighted by our heuristics (e.g., semantics of suspicious variables in the statements, the analysis approaches mentioned in <ref> [6] </ref>) can lead to the identification of the faults. For instance, the missing predicate statement in program naur3 can be located by analyzing the semantics of statements suggested by Heuristics in Table 4. <p> Focus [28] is a debugging tool based on program dicing to find the likely location of a fault. Because static program slices contain many irrelevant statements that make fault localization inefficient, studying program slicing based on dynamic cases to get the exact execution path is warranted. Dynamic Program Slicing <ref> [1, 3, 6, 25] </ref> is a powerful facility for debugging and dependency analysis. Nevertheless, it has not been systematically applied to fault localization. In Agrawal's dissertation [6], he briefly alluded to the idea of combining dynamic program slices and data slices for fault localization. <p> Dynamic Program Slicing [1, 3, 6, 25] is a powerful facility for debugging and dependency analysis. Nevertheless, it has not been systematically applied to fault localization. In Agrawal's dissertation <ref> [6] </ref>, he briefly alluded to the idea of combining dynamic program slices and data slices for fault localization. Our heuristics are based on dynamic slices that are collected by varying test cases, variables, and location of variables. Current testing and debugging tools are separate.
Reference: [7] <author> ANSI/IEEE. </author> <title> IEEE Standard Glossary of Software Enginnering Terminology. </title> <publisher> IEEE Std 729-1983. IEEE, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction In the software life cycle, more than 50% of the total cost may be expended in the testing and debugging phases to ensure the quality of the software [30, 35]. Developing effective and efficient testing and debugging strategies is thus important. In standards terminology <ref> [7] </ref> errors are defined as inappropriate actions committed by a programmer or designer. Faults or bugs are the manifestations and results of errors during the coding of a program.
Reference: [8] <author> R. S. Boyer, E. Elspas, and K. N. Levitt. </author> <title> SELECT a system for testing and debugging programs by symbolic execution. </title> <booktitle> In Proceedings of International Conference on Reliable Software, </booktitle> <pages> pages 234-245, </pages> <year> 1975. </year> <journal> (ACM SIGPLAN Notices, </journal> <volume> 10(6), </volume> <month> June </month> <year> 1990). </year>
Reference: [9] <author> Gordon H. Bradley. </author> <title> Algorithm and bound for the greatest common divisor of n integers. </title> <journal> Communications of the ACM, </journal> <volume> 13(7) </volume> <pages> 433-436, </pages> <month> July </month> <year> 1970. </year>
Reference: [10] <author> T. A. Budd. </author> <title> Mutation Analysis of Program Test Data. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <address> New Haven, Connecticut, </address> <year> 1980. </year>
Reference: [11] <author> Lori A. Clarke and Debra J. Richardson. </author> <title> The application of error-sensitive testing strategies to debugging. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 45-52, </pages> <address> Pacific Grove, California, </address> <month> March </month> <year> 1983. </year> <journal> (ACM Software Engineering Notes, 8(4), August 1983; ACM SIGPLAN Notices, </journal> <volume> 18(8), </volume> <month> August </month> <year> 1983). </year>
Reference-contexts: Even if they are presented in one tool, the two functions are not well integrated to benefit each other. Osterweil [32] tried to integrate testing, analysis, and debugging, but gave no solid conclusion about how to transform information between testing and debugging to benefit each other. Clark and Richardson <ref> [11] </ref> were the first to suggest that certain test strategies (based on the symbolic evaluation) and classified failure types could be used for debugging purposes. However, only one example is given to describe their idea, and no further research has been conducted.
Reference: [12] <author> James S. Collofello and Larry Cousins. </author> <title> Towards automatic software fault location through decision-to-decision path analysis. </title> <booktitle> In AFIPS Proceedings of 1987 National Computer Conference, </booktitle> <pages> pages 539-544, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Users are allowed to set their own threshold for different purposes. Our preliminary study discovers a better way to decide the threshold. The suggestion is discussed in Section 4.3. Heuristics and experiments according to relational (decision-to-decision) path analysis on execution paths were studied by Collofello and Cousins <ref> [12] </ref>. A few of their approaches are similar to ours, such as the concept behind Heuristic 13, the most useful one among theirs. <p> Korel and Laski proposed an algorithm based on hypothesis-and-test cycles and knowledge obtained from STAD to localize faults interactively [26]. However, STAD and PELAS only supported a subset of Pascal, and limited program errors are considered. Collofello and Cousins <ref> [12] </ref> proposed many heuristics to locate suspicious statement blocks after testing. A program is first partitioned into many decision-to-decision paths (DD-paths), which are straight-line codes existing between two consecutive predicates of the program.
Reference: [13] <author> R. A. DeMillo, R. J. Lipton, and F. G. Sayward. </author> <title> Hints on test data selection: Help for the practicing programmer. </title> <journal> Computer, </journal> <volume> 11(4) </volume> <pages> 34-43, </pages> <month> April </month> <year> 1978. </year>
Reference: [14] <author> Mireille Ducasse and Anna-Maria Emde. </author> <title> A review of automated debugging systems: Knowledge, strategies, and techniques. </title> <booktitle> In Proceedings of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 162-171, </pages> <address> Singapore, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: Knowledge about both the classified faults and the nature of program behavior is usually required in this approach. Many prototype debugging systems have been developed based on this approach since the early 1980s. <ref> [14, 38] </ref> However, knowledge about programs in the real world is complicated. These prototype systems can only handle restricted fault classes and very simple programs. Program slicing proposed by Weiser [43, 44] is another approach to debugging.
Reference: [15] <author> Kevin J. Dunlap. </author> <title> Debugging with DBX. In UNIX Programmers Manual, </title> <type> Supplementary Documents 1, </type> <institution> 4.3 Berkeley Software Distribution. Computer Science Division, University of California, Berkeley, California, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: Although testing and debugging are closely related, none of the existing debugging tools attempt to interface with testing tools. Conventional debugging tools (e.g., ADB and DBX <ref> [15] </ref>) are command-driven and tend to be stand-alone. Many fault localization techniques used in current debugging tools (e.g., setting breakpoints) were developed in the 1960s and have changed little [5]. Users have to discover by themselves useful information for debugging.
Reference: [16] <author> Phyllis G. Frankl and Stewart N. Weiss. </author> <title> An experimental comparison of the effectiveness of the all-uses and all-edges adequacy criteria. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <pages> pages 154-164, </pages> <address> Victoria, British Columbia, Canada, </address> <month> October 8-10 </month> <year> 1991. </year>
Reference: [17] <author> Peter Fritzson, Tibor Gyimothy, Mariam Kamkar, and Nahid Shahmehri. </author> <title> Generalized algorithmic debugging and testing. </title> <booktitle> In Proceedings of the ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 317-326, </pages> <address> Toronto, Canada, </address> <month> June 26-28 </month> <year> 1991. </year>
Reference-contexts: Renner [37] applied this approach to locating faults in programs written in Pascal. With this method, users can only point out procedures that contain bugs; other debugging tools are needed to debug the faulty procedures. The similar result is obtained in <ref> [17] </ref>. The knowledge-based approach attempts to automate the debugging process by using techniques of artificial intelligence and knowledge engineering. Knowledge about both the classified faults and the nature of program behavior is usually required in this approach.
Reference: [18] <author> M. Geller. </author> <title> Test data as an aid in proving program correctness. </title> <journal> Communications of the ACM, </journal> <volume> 21(5) </volume> <pages> 368-375, </pages> <month> May </month> <year> 1978. </year>
Reference: [19] <author> J. B. Goodenough and S. L. Gerhart. </author> <title> Towards a theory of test data selection. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):156-173, </volume> <month> June </month> <year> 1975. </year>
Reference: [20] <author> F. Gustavson. </author> <title> Remark on algorithm 408. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 4:295, </volume> <year> 1978. </year>
Reference: [21] <author> C. Hoare. </author> <title> Algorithm 65: FIND. </title> <journal> Communications of the ACM, </journal> <volume> 4(1):321, </volume> <month> April </month> <year> 1961. </year>
Reference: [22] <author> J. R. Horgan and S. </author> <title> London. Data flow coverage and the C language. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 87-97, </pages> <address> Victoria, British Columbia, Canada, </address> <month> October 8-10 </month> <year> 1991. </year>
Reference-contexts: The first column lists the number of executable statements, showing the size of a tested program. Columns 3 to 5 are obtained from a data flow coverage testing tool Atac (Automatic Test Analysis for C programs) <ref> [22] </ref>, developed at Bellcore. The following definitions are quoted from the man pages of Atac. Column blocks represents the number of code fragments not containing control flow branching.
Reference: [23] <author> Bogdan Korel. </author> <title> PELAS program error-locating assistant system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(9):1253-1260, </volume> <month> September </month> <year> 1988. </year> <month> 19 </month>
Reference-contexts: The debugging part of STAD will be invoked once a fault is detected during a testing session, and leads users to focus on the possible erroneous part of the program rather than locate the fault precisely. PELAS (Program Error-Locating Assistant System) <ref> [23] </ref> is an implementation of the debugging tool in STAD. Korel and Laski proposed an algorithm based on hypothesis-and-test cycles and knowledge obtained from STAD to localize faults interactively [26]. However, STAD and PELAS only supported a subset of Pascal, and limited program errors are considered.
Reference: [24] <author> Bogdan Korel and Janusz Laski. </author> <title> STAD a system for testing and debugging: User perspective. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Analysis, and Verification, </booktitle> <pages> pages 13-20, </pages> <address> Banff, Canada, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: However, only one example is given to describe their idea, and no further research has been conducted. STAD (System for Testing and Debugging) <ref> [24] </ref> is the first tool to successfully integrate debugging with testing. As mentioned above, its testing and debugging parts do not share much information except for implementation purposes (e.g., they share the results of data flow analysis).
Reference: [25] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic slicing of computer programs. </title> <journal> The Journal of Systems and Software, </journal> <volume> 13(3) </volume> <pages> 187-195, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Focus [28] is a debugging tool based on program dicing to find the likely location of a fault. Because static program slices contain many irrelevant statements that make fault localization inefficient, studying program slicing based on dynamic cases to get the exact execution path is warranted. Dynamic Program Slicing <ref> [1, 3, 6, 25] </ref> is a powerful facility for debugging and dependency analysis. Nevertheless, it has not been systematically applied to fault localization. In Agrawal's dissertation [6], he briefly alluded to the idea of combining dynamic program slices and data slices for fault localization.
Reference: [26] <author> Bogdan Korel and Janusz Laski. </author> <title> Algorithmic software fault localization. </title> <booktitle> In Proceedings of the Twenty-Fourth Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 246-252, </pages> <address> Hawaii, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: PELAS (Program Error-Locating Assistant System) [23] is an implementation of the debugging tool in STAD. Korel and Laski proposed an algorithm based on hypothesis-and-test cycles and knowledge obtained from STAD to localize faults interactively <ref> [26] </ref>. However, STAD and PELAS only supported a subset of Pascal, and limited program errors are considered. Collofello and Cousins [12] proposed many heuristics to locate suspicious statement blocks after testing.
Reference: [27] <author> James R. Lyle. </author> <title> Evaluating Variations on Program Slicing for Debugging. </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1984. </year>
Reference-contexts: Program slicing proposed by Weiser [43, 44] is another approach to debugging. This method decomposes a program by statically analyzing the data-flow and control-flow of the program referred to as static program slicing. Program dicing, proposed by Lyle and Weiser <ref> [27, 45] </ref>, attempts to collect debugging 16 information according to the correctness of suspicious variables involved in static program slices. Focus [28] is a debugging tool based on program dicing to find the likely location of a fault.
Reference: [28] <author> James R. Lyle and Mark Weiser. </author> <title> Automatic program bug location by program slicing. </title> <booktitle> In Proceedings of the 2nd International Conference on Computers and Applications, </booktitle> <pages> pages 877-883, </pages> <address> Beijing, PRC, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: This method decomposes a program by statically analyzing the data-flow and control-flow of the program referred to as static program slicing. Program dicing, proposed by Lyle and Weiser [27, 45], attempts to collect debugging 16 information according to the correctness of suspicious variables involved in static program slices. Focus <ref> [28] </ref> is a debugging tool based on program dicing to find the likely location of a fault. Because static program slices contain many irrelevant statements that make fault localization inefficient, studying program slicing based on dynamic cases to get the exact execution path is warranted.
Reference: [29] <author> J. M. McNamee. </author> <title> Algorithm 408: A sparse matrix package (part I) [f4]. </title> <journal> Communications of the ACM, </journal> <volume> 14(4) </volume> <pages> 265-273, </pages> <month> April </month> <year> 1971. </year>
Reference: [30] <author> Glenford J. Myers. </author> <title> The Art of Software Testing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction In the software life cycle, more than 50% of the total cost may be expended in the testing and debugging phases to ensure the quality of the software <ref> [30, 35] </ref>. Developing effective and efficient testing and debugging strategies is thus important. In standards terminology [7] errors are defined as inappropriate actions committed by a programmer or designer. Faults or bugs are the manifestations and results of errors during the coding of a program. <p> Many fault localization techniques used in current debugging tools (e.g., setting breakpoints) were developed in the 1960s and have changed little [5]. Users have to discover by themselves useful information for debugging. Two major steps involved in the debugging process are locating and correcting faults. Previous studies <ref> [30, 41] </ref> found that locating faults is the most difficult and important task in debugging. The focus of our work is to develop methods that automatically localize faults and thus enhance the debugging process as well as reduce human interaction time.
Reference: [31] <author> P. Naur. </author> <title> Programming by action clusters. </title> <journal> BIT, </journal> <volume> 9 </volume> <pages> 250-258, </pages> <year> 1969. </year>
Reference: [32] <author> Leon Osterweil. </author> <title> Integrating the testing, analysis, and debugging of programs. </title> <editor> In H. L. Hausen, editor, </editor> <booktitle> Software Validation, </booktitle> <pages> pages 73-102. </pages> <publisher> Elsevier Science Publishers B. V., North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: Our heuristics are based on dynamic slices that are collected by varying test cases, variables, and location of variables. Current testing and debugging tools are separate. Even if they are presented in one tool, the two functions are not well integrated to benefit each other. Osterweil <ref> [32] </ref> tried to integrate testing, analysis, and debugging, but gave no solid conclusion about how to transform information between testing and debugging to benefit each other.
Reference: [33] <author> H. Pan and E. H. Spafford. </author> <title> Toward automatic localization of software faults. </title> <booktitle> In Proceedings of the 10th Pacific Northwest Software Quality Conference, </booktitle> <address> Portland, Oregon, </address> <month> October 19-21 </month> <year> 1992. </year>
Reference: [34] <author> Hsin Pan. </author> <title> Debugging with dynamic instrumentation and test-based knowledge. </title> <type> Technical Report SERC-TR-105-P, </type> <institution> Software Engineering Research Center, Purdue University, West Lafayette, Indiana, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The focus of our work is to develop methods that automatically localize faults and thus enhance the debugging process as well as reduce human interaction time. The result of this study will support a new debugging paradigm proposed in <ref> [34] </ref>. <p> Then, heuristics are applied based on the dynamic slices and metrics obtained. At this moment, the effectiveness of heuristics for automatic fault localization under different program (P ) or location (l) parameters is not clear to us, but is the subject of ongoing research. <ref> [34] </ref> Notations and terminology used in our heuristics are listed in Appendix A. 2.2 Heuristics Several heuristics for fault localization based on dynamic slices are proposed here. Heuristics constructed using different test case parameters are similar to those constructed using different variable parameters. <p> Other approaches to fault localization based on test knowledge (e.g., error-revealing mutations derived from mutation-based testing <ref> [34] </ref>) and dynamic program slices are currently under development by the authors. These approaches further will help fault localization. 5 Related Work In this section, a brief survey of typical fault localization techniques is presented. <p> The tool to support this new debugging scenario should be integrated with a testing environment and can conduct program dependency analysis, monitor execution history for backtracking, and provide fault prediction strategies based on information obtained from failure analysis and fault classification. <ref> [34] </ref> In this paper, a set of heuristics is proposed to confine the search domain for bugs to a small region. The heuristics are based on dynamic program slices that are collected by varying test cases, variables, and location of variables.
Reference: [35] <author> Roger S. Pressman. </author> <title> Software Enginnering: A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc., </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction In the software life cycle, more than 50% of the total cost may be expended in the testing and debugging phases to ensure the quality of the software <ref> [30, 35] </ref>. Developing effective and efficient testing and debugging strategies is thus important. In standards terminology [7] errors are defined as inappropriate actions committed by a programmer or designer. Faults or bugs are the manifestations and results of errors during the coding of a program.
Reference: [36] <author> C. V. Ramamoorthy, S. F. Ho, and W. T. Chen. </author> <title> On the automated generation of program test data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(4):293-300, </volume> <month> December </month> <year> 1976. </year>
Reference: [37] <author> Scott Renner. </author> <title> Location of logical errors on Pascal programs with an appendix on implementation problems in Waterloo PROLOG/C. </title> <type> Technical Report UIUCDCS-F-82-896, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <month> April </month> <year> 1982. </year> <note> (Also with No. UIUC-ENG 82 1710.). </note>
Reference-contexts: Shapiro [39] proposed an interactive fault diagnosis algorithm, the Divide-and-Query algorithm, for debugging programs represented well by a computation tree (e.g., the logic programs written in Prolog). The computation tree (the target program) is recursively searched until bugs are located and fixed. Renner <ref> [37] </ref> applied this approach to locating faults in programs written in Pascal. With this method, users can only point out procedures that contain bugs; other debugging tools are needed to debug the faulty procedures. The similar result is obtained in [17].
Reference: [38] <author> Rudolph E. Seviora. </author> <title> Knowledge-based program debugging systems. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 20-32, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Knowledge about both the classified faults and the nature of program behavior is usually required in this approach. Many prototype debugging systems have been developed based on this approach since the early 1980s. <ref> [14, 38] </ref> However, knowledge about programs in the real world is complicated. These prototype systems can only handle restricted fault classes and very simple programs. Program slicing proposed by Weiser [43, 44] is another approach to debugging.
Reference: [39] <author> Ehud Y. Shapiro. </author> <title> Algorithmic Program Debugging. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1983. </year> <type> (PhD thesis, </type> <institution> Yale University, </institution> <address> New Haven, Connecticut, </address> <year> 1982). </year>
Reference-contexts: Traditional debugging techniques such as dumping memory, scattering print statements, setting break-points by users, and tracing program execution only provide utilities to examine a snapshot of program execution. Users have to use their own strategies to do fault localization. Shapiro <ref> [39] </ref> proposed an interactive fault diagnosis algorithm, the Divide-and-Query algorithm, for debugging programs represented well by a computation tree (e.g., the logic programs written in Prolog). The computation tree (the target program) is recursively searched until bugs are located and fixed.
Reference: [40] <author> Richard M. Stallman. </author> <title> GDB Manual, third edition, GDB version 3.4. Free Software Foundation, </title> <address> Cambridge, Massachusetts, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: The second and third tasks are currently performed by manually examining the code and program failures without the assistance of debugging tools. As to the fourth task, some debugging tools (e.g., DBX and GDB <ref> [40] </ref>) support facilities allowing users to set breakpoints, to reexecute the code, and to verify the values of variables. Obviously, the debugging effort would become much easier if all four tasks could be performed with direct assistance from a debugging tool.
Reference: [41] <author> Iris Vessey. </author> <title> Expertise in debugging computer programs: A process analysis. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 23(5) </volume> <pages> 459-494, </pages> <month> November </month> <year> 1985. </year> <month> 20 </month>
Reference-contexts: Many fault localization techniques used in current debugging tools (e.g., setting breakpoints) were developed in the 1960s and have changed little [5]. Users have to discover by themselves useful information for debugging. Two major steps involved in the debugging process are locating and correcting faults. Previous studies <ref> [30, 41] </ref> found that locating faults is the most difficult and important task in debugging. The focus of our work is to develop methods that automatically localize faults and thus enhance the debugging process as well as reduce human interaction time.
Reference: [42] <author> Chonchanok Viravan. </author> <title> Fault investigation and trial. </title> <type> Technical Report SERC-TR-104-P, </type> <institution> Software Engineering Research Center, Purdue University, West Lafayette, Indiana, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: After a reduced search domain for faults is presented by our proposed heuristics, further analysis is needed to identify whether faulty statements are in the highlighted suspicious region. Ongoing research will provide automated decision support to do verification. <ref> [42] </ref> 4 Results of A Preliminary Study A simple trial was conducted to examine the effectiveness of the heuristics proposed.
Reference: [43] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Many prototype debugging systems have been developed based on this approach since the early 1980s. [14, 38] However, knowledge about programs in the real world is complicated. These prototype systems can only handle restricted fault classes and very simple programs. Program slicing proposed by Weiser <ref> [43, 44] </ref> is another approach to debugging. This method decomposes a program by statically analyzing the data-flow and control-flow of the program referred to as static program slicing.
Reference: [44] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Many prototype debugging systems have been developed based on this approach since the early 1980s. [14, 38] However, knowledge about programs in the real world is complicated. These prototype systems can only handle restricted fault classes and very simple programs. Program slicing proposed by Weiser <ref> [43, 44] </ref> is another approach to debugging. This method decomposes a program by statically analyzing the data-flow and control-flow of the program referred to as static program slicing.
Reference: [45] <author> Mark Weiser and Jim Lyle. </author> <title> Experiments on slicing-based debugging aids. </title> <editor> In Elliot Soloway and Sitharama Iyengar, editors, </editor> <booktitle> Empirical Studies of Programmers, </booktitle> <pages> pages 187-197. </pages> <publisher> Ablex Publishing Corp., </publisher> <address> Norwood, New Jersey, </address> <year> 1986. </year> <title> (Presented at the First Workshop on Empirical Studies of Programmers, </title> <address> Washington DC, June 5-6 1986.). </address> <month> 21 </month>
Reference-contexts: Program slicing proposed by Weiser [43, 44] is another approach to debugging. This method decomposes a program by statically analyzing the data-flow and control-flow of the program referred to as static program slicing. Program dicing, proposed by Lyle and Weiser <ref> [27, 45] </ref>, attempts to collect debugging 16 information according to the correctness of suspicious variables involved in static program slices. Focus [28] is a debugging tool based on program dicing to find the likely location of a fault.
References-found: 45

