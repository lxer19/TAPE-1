URL: http://www.cs.columbia.edu/~kar/pubsk/spacetime.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  divesh@research.att.com  sudarsha@cse.iitb.ernet.in  
Title: Materialized View Maintenance and Integrity Constraint Checking: Trading Space for Time  
Author: Kenneth A. Ross Divesh Srivastava S. Sudarshan 
Date: June 1996, pp.447-458  
Note: ACM SIGMOD Conference,  
Address: Bombay  
Affiliation: Columbia University  AT&T Research  Indian Institute of Technology,  
Abstract: We investigate the problem of incremental maintenance of an SQL view in the face of database updates, and show that it is possible to reduce the total time cost of view maintenance by materializing (and maintaining) additional views. We formulate the problem of determining the optimal set of additional views to materialize as an optimization problem over the space of possible view sets (which includes the empty set). The optimization problem is harder than query optimization since it has to deal with multiple view sets, updates of multiple relations, and multiple ways of maintaining each view set for each updated relation. We develop a memoing solution for the problem; the solution can be implemented using the expression DAG representation used in rule-based optimizers such as Volcano. We demonstrate that global optimization cannot, in general, be achieved by locally optimizing each materialized subview, because common subexpressions between different materialized subviews can allow nonoptimal local plans to be combined into an optimal global plan. We identify conditions on materialized subviews in the expression DAG when local optimization is possible. Finally, we suggest heuristics that can be used to efficiently determine a useful set of additional views to materialize. Our results are particularly important for the efficient checking of assertions (complex integrity constraints) in the SQL-92 standard, since the incremental checking of such integrity constraints is known to be essentially equivalent to the view maintenance problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of Magic. </title> <journal> Journal of Logic Programming, </journal> 10(3&4):255-300, 1991. 
Reference-contexts: To our knowledge, ours is the first paper on the topic. The supplementary relations used in the bottom-up evaluation of recursive queries <ref> [1] </ref> can be viewed as additional materialized views that are maintained (during query evaluation) in order to efficiently maintain the view relations defining the original query. However, supplementary relations are introduced as part of a query rewriting step and do not take cost into consideration.
Reference: [2] <author> J. A. Blakeley, P.-A. Larson, and F. W. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: When the database relations Emp and Dept are updated, view maintenance of ProblemDept, even using incremental techniques (e.g., <ref> [2, 8, 12] </ref>), can be expensive. <p> Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself. <p> simplicity of presentation. 2 1 One can be generated from the other by using equivalence rules such as those proposed by Yan and Larson [24]. 449 2.2 Incremental Updating of Expression Trees Materialized views can be incrementally maintained when the underlying database relations are updated using the techniques of, e.g., <ref> [2, 8, 12] </ref>. <p> In this paper, we consider differentials that include inserted tuples, deleted tuples, and modified tuples. Our technique follows the approach of <ref> [2, 18] </ref>. To compute the on the result of an operation, queries may have to be set up on the inputs to the operation. <p> At each node, the update to the result is computed based on the updates to its inputs using the incremental techniques described in, e.g., <ref> [2, 18] </ref>. 3.4 Cost of Maintaining a Set of Views Consider the time cost of maintaining a set of views V for a given transaction type T i .
Reference: [3] <author> B. Blaustein. </author> <title> Enforcing database assertions: Techniques and applications. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1981. </year>
Reference-contexts: The A-TREAT model chooses (for a fixed discrimination network) what nodes to materialize using a selectivity based heuristic, 448 while [6] actually chooses a discrimination network and nodes to maintain, using "profitability" heuristics. Similar issues have been studied earlier in the context of maintaining integrity constraints <ref> [3, 17] </ref>. However, none of the above have explored how to choose the best set of materialized views (the best choice of discrimination network and the nodes to be maintained in it) in a truly cost-based manner; a cost-based choice is particularly important in a large database environment.
Reference: [4] <author> S. Ceri and J. Widom. </author> <title> Production rules for incremental view maintenance. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself.
Reference: [5] <author> S. Chaudhuri, R. Krishnamurthy, S. Potamianos, and K. Shim. </author> <title> Optimizing queries with materialized views. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: A related, but quite different, problem is to make use of available materialized views in order to efficiently evaluate a given query, and there has been considerable work in this area (e.g., <ref> [5, 9, 14] </ref>). 2 Background 2.1 Expression Trees and DAGs Our algorithms for determining what views to additionally materialize (and maintain) use expression trees and expression DAGs developed for performing cost-based query optimization (although the problem of query optimization is quite different from our problem). <p> This is a standard query optimization problem, and the optimization techniques of Chaudhuri et al. <ref> [5] </ref>, for example, can be easily adapted for this task. When propagating updates along an update track, many queries may need to be posed.
Reference: [6] <author> F. Fabret, M. Regnier, and E. Simon. </author> <title> An adaptive algorithm for incremental evaluation of production rules in databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: The A-TREAT model chooses (for a fixed discrimination network) what nodes to materialize using a selectivity based heuristic, 448 while <ref> [6] </ref> actually chooses a discrimination network and nodes to maintain, using "profitability" heuristics. Similar issues have been studied earlier in the context of maintaining integrity constraints [3, 17].
Reference: [7] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: We develop an exhaustive memoing algorithm to solve the optimization problem that works under any cost model; the algorithm can be implemented using the expression DAG representation used in rule-based optimizers such as Volcano <ref> [7] </ref> (Section 3). <p> Our techniques are independent of the actual set of operators; in our examples we consider operators from an extended relational algebra, that includes duplicate elimination and grouping/aggregation, in addition to the usual relational operators. Expression DAGs are used by rule-based optimizers such as Volcano <ref> [7, 15] </ref> to compactly represent the space of equivalent expression trees as a directed acyclic graph. An expression DAG is a bipartite directed acyclic graph with "equivalence" nodes and "operation" nodes. An equivalence node has edges to one or more operation nodes.
Reference: [8] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1995. </year>
Reference-contexts: When the database relations Emp and Dept are updated, view maintenance of ProblemDept, even using incremental techniques (e.g., <ref> [2, 8, 12] </ref>), can be expensive. <p> Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself. <p> simplicity of presentation. 2 1 One can be generated from the other by using equivalence rules such as those proposed by Yan and Larson [24]. 449 2.2 Incremental Updating of Expression Trees Materialized views can be incrementally maintained when the underlying database relations are updated using the techniques of, e.g., <ref> [2, 8, 12] </ref>. <p> Similar techniques apply for other operations, such as selection, projection, aggregation, duplicate elimination, union, intersection, difference, etc. The exact way to generate the queries and to compute the updates can be rather subtle; see for example <ref> [8, 10, 12] </ref>. This issue will be addressed in more detail in the full version of this paper. Consider now an expression tree. <p> The view sets chosen using our (non-heuristic) techniques are optimal under the update propagation model we have used. The model is a complete and powerful one, but there are other models for propagating updates based on defining update expressions, such as the one described in <ref> [8] </ref>. It would be interesting to consider how to find the optimal way to maintain a view (or set of views) under such a model. Another direction for future work is to use a more general abstraction of database relation updates than the insert/delete/modify abstraction used in this paper.
Reference: [9] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1995. </year>
Reference-contexts: A related, but quite different, problem is to make use of available materialized views in order to efficiently evaluate a given query, and there has been considerable work in this area (e.g., <ref> [5, 9, 14] </ref>). 2 Background 2.1 Expression Trees and DAGs Our algorithms for determining what views to additionally materialize (and maintain) use expression trees and expression DAGs developed for performing cost-based query optimization (although the problem of query optimization is quite different from our problem).
Reference: [10] <author> A. Gupta and I. S. Mumick. </author> <title> Maintenance of materialized views: Problems, techniques and applications. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1995. </year> <title> Special Issue on Materialized Views and Data Warehousing. </title>
Reference-contexts: For a recent survey of the view maintenance literature, see <ref> [10] </ref>. The problem of what additional views to materialize, in order to reduce the cost of view maintenance, has been studied in the context of rule-based systems based on the RETE, TREAT and A-TREAT models [23, 13]. <p> Similar techniques apply for other operations, such as selection, projection, aggregation, duplicate elimination, union, intersection, difference, etc. The exact way to generate the queries and to compute the updates can be rather subtle; see for example <ref> [8, 10, 12] </ref>. This issue will be addressed in more detail in the full version of this paper. Consider now an expression tree.
Reference: [11] <author> A. Gupta, I. S. Mumick, and K. Ross. </author> <title> Adapting materialized views after redefinitions. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself.
Reference: [12] <author> A. Gupta, I. S. Mumick, and V. S. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 157-166, </pages> <year> 1993. </year>
Reference-contexts: When the database relations Emp and Dept are updated, view maintenance of ProblemDept, even using incremental techniques (e.g., <ref> [2, 8, 12] </ref>), can be expensive. <p> Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself. <p> simplicity of presentation. 2 1 One can be generated from the other by using equivalence rules such as those proposed by Yan and Larson [24]. 449 2.2 Incremental Updating of Expression Trees Materialized views can be incrementally maintained when the underlying database relations are updated using the techniques of, e.g., <ref> [2, 8, 12] </ref>. <p> Similar techniques apply for other operations, such as selection, projection, aggregation, duplicate elimination, union, intersection, difference, etc. The exact way to generate the queries and to compute the updates can be rather subtle; see for example <ref> [8, 10, 12] </ref>. This issue will be addressed in more detail in the full version of this paper. Consider now an expression tree.
Reference: [13] <author> E. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: For a recent survey of the view maintenance literature, see [10]. The problem of what additional views to materialize, in order to reduce the cost of view maintenance, has been studied in the context of rule-based systems based on the RETE, TREAT and A-TREAT models <ref> [23, 13] </ref>. These models are based on discrimination networks for each rule (view); the RETE model materializes selection and join nodes in the network, while the TREAT model materializes only the selection nodes.
Reference: [14] <author> A. Y. Levy, A. O. Mendelzon, Y. Sagiv, and D. Srivas-tava. </author> <title> Answering queries using views. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: A related, but quite different, problem is to make use of available materialized views in order to efficiently evaluate a given query, and there has been considerable work in this area (e.g., <ref> [5, 9, 14] </ref>). 2 Background 2.1 Expression Trees and DAGs Our algorithms for determining what views to additionally materialize (and maintain) use expression trees and expression DAGs developed for performing cost-based query optimization (although the problem of query optimization is quite different from our problem).
Reference: [15] <author> W. J. McKenna. </author> <title> Efficient search in extensible database query optimization: The Volcano optimizer generator. </title> <type> PhD thesis, </type> <institution> University of Colorado, </institution> <year> 1993. </year>
Reference-contexts: Our techniques are independent of the actual set of operators; in our examples we consider operators from an extended relational algebra, that includes duplicate elimination and grouping/aggregation, in addition to the usual relational operators. Expression DAGs are used by rule-based optimizers such as Volcano <ref> [7, 15] </ref> to compactly represent the space of equivalent expression trees as a directed acyclic graph. An expression DAG is a bipartite directed acyclic graph with "equivalence" nodes and "operation" nodes. An equivalence node has edges to one or more operation nodes. <p> Details of how this step is carried out may be found in <ref> [15] </ref>; the intuition is as follows. The initial DAG is generated from the query expression tree by adding an equivalence node between each operation node and its parent, adding an equivalence node above the root of the expression tree, and replacing each relation by an equivalence node. <p> The cost of generation is greatly reduced when generating new expression trees using equivalence rules since the rules operate locally on the DAG representation. For details on how query optimization uses expression DAGs, see <ref> [15] </ref>. Example 2.1 Two expression trees for the view Prob-lemDept of Example 1.1 are given in Figure 1. 1 The expression DAG representation of those trees is given in and the remaining nodes are operation nodes.
Reference: [16] <author> J. Melton and A. R. Simon. </author> <title> Understanding the new SQL: A complete guide. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1993. </year>
Reference-contexts: This paper addresses the following question: Given a materialized view V , what additional views should be materialized (and maintained) for the optimal incremental maintenance of V ? The SQL-92 standard permits the specification of complex integrity constraints (called assertions) <ref> [16] </ref>. These integrity constraints have to be checked on updates to the underlying database relations; hence it is very important that they be checked efficiently. Integrity constraints can be modeled as materialized views whose results are required to be empty.
Reference: [17] <author> R. Paige. </author> <title> Applications of finite differencing to database integrity control and query/transaction optimization. </title> <booktitle> In Advances in Database Theory. </booktitle> <publisher> Plenum, </publisher> <year> 1984. </year>
Reference-contexts: The A-TREAT model chooses (for a fixed discrimination network) what nodes to materialize using a selectivity based heuristic, 448 while [6] actually chooses a discrimination network and nodes to maintain, using "profitability" heuristics. Similar issues have been studied earlier in the context of maintaining integrity constraints <ref> [3, 17] </ref>. However, none of the above have explored how to choose the best set of materialized views (the best choice of discrimination network and the nodes to be maintained in it) in a truly cost-based manner; a cost-based choice is particularly important in a large database environment.
Reference: [18] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <year> 1991. </year>
Reference-contexts: Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself. <p> In this paper, we consider differentials that include inserted tuples, deleted tuples, and modified tuples. Our technique follows the approach of <ref> [2, 18] </ref>. To compute the on the result of an operation, queries may have to be set up on the inputs to the operation. <p> At each node, the update to the result is computed based on the updates to its inputs using the incremental techniques described in, e.g., <ref> [2, 18] </ref>. 3.4 Cost of Maintaining a Set of Views Consider the time cost of maintaining a set of views V for a given transaction type T i .
Reference: [19] <author> A. Segev and W. Fang. </author> <title> Currency-based updates to distributed materialized views. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <pages> pages 512-520, </pages> <year> 1990. </year>
Reference-contexts: The maintenance of a collection of simple (Select-Project) views in a distributed system is discussed in [20], where a very simple form of multi-query optimization is used to screen updates that need to be sent to remote sites. The work is extended in <ref> [19] </ref>, which considers using the updates to one view to maintain other views, rather than using database relation updates; the applicability conditions presented are however very restricted.
Reference: [20] <author> A. Segev and J. Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: They may be introduced when they are not required for efficient view maintenance, or not be introduced even when they are useful for efficient view maintenance. The maintenance of a collection of simple (Select-Project) views in a distributed system is discussed in <ref> [20] </ref>, where a very simple form of multi-query optimization is used to screen updates that need to be sent to remote sites.
Reference: [21] <author> T. Sellis. </author> <title> Multiple query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: When propagating updates along an update track, many queries may need to be posed. This set of queries can have common subexpressions, and multi-query optimization techniques (see, e.g., <ref> [21] </ref>) can be used for optimizing the evaluation of the collection of queries. Shared work between the queries could lead to locally nonoptimal plans being globally optimal.
Reference: [22] <author> L. Vieille, P. Bayer, and V. Kuchenhoff. </author> <title> Integrity checking and materialized views handling by update propagation in the EKS-V1 system. </title> <type> Technical report, </type> <institution> CERMICS - Ecole Nationale Des Ponts et Chaussees, France, </institution> <month> June </month> <year> 1991. </year> <institution> Rapport de Recherche, CERMICS 91.1. </institution>
Reference-contexts: Finally, we discuss possible extensions to our techniques in Section 6. 1.2 Related Work View maintenance (and the closely related problem of integrity constraint checking) has been studied extensively in the literature (e.g., <ref> [2, 4, 8, 11, 12, 18, 22] </ref>) for various view definition languages, e.g., Select-Project-Join (or SPJ) views, views with multiset semantics, views with grouping/aggregation, and recursive views; for various types of updates, e.g., insertions, deletions, modifications, to the database relations; and for modifications to the view definition itself.
Reference: [23] <author> Y.-W. Wang and E. Hanson. </author> <title> A performance comparison of the Rete and TREAT algorithms for testing database rule conditions. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <year> 1992. </year>
Reference-contexts: For a recent survey of the view maintenance literature, see [10]. The problem of what additional views to materialize, in order to reduce the cost of view maintenance, has been studied in the context of rule-based systems based on the RETE, TREAT and A-TREAT models <ref> [23, 13] </ref>. These models are based on discrimination networks for each rule (view); the RETE model materializes selection and join nodes in the network, while the TREAT model materializes only the selection nodes.
Reference: [24] <author> W. P. Yan and P.-A. Larson. </author> <title> Performing group-by before join. </title> <booktitle> In Proceedings of the IEEE International Conference on Data Engineering, </booktitle> <pages> pages 89-100, </pages> <year> 1994. </year> <month> 458 </month>
Reference-contexts: In practice, an expression DAG would represent a much larger number of trees; we have used a small example for simplicity of presentation. 2 1 One can be generated from the other by using equivalence rules such as those proposed by Yan and Larson <ref> [24] </ref>. 449 2.2 Incremental Updating of Expression Trees Materialized views can be incrementally maintained when the underlying database relations are updated using the techniques of, e.g., [2, 8, 12].
References-found: 24

