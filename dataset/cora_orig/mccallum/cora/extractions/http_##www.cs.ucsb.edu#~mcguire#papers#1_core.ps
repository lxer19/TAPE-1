URL: http://www.cs.ucsb.edu/~mcguire/papers/1_core.ps
Refering-URL: http://www.cs.ucsb.edu/~mcguire/
Root-URL: http://www.cs.ucsb.edu
Title: A Decision Algorithm for Full Propositional Temporal Logic  
Author: Y. Kesten Z. Manna H. McGuire A. Pnueli 
Keyword: temporal logic, satisfiability checking, validity checking, model check ing, past and future operators, incremental tableau, automatic verification.  
Abstract: The paper presents an efficient algorithm for checking the satisfiability of a propositional linear time temporal logic formula, which may have past as well as future operators. This algorithm can be used to check validity of such formulas over all models as well as over computations of a finite-state program (model checking). Unlike previous theoretical presentations of a decision method for checking satisfi-ability or validity, whose first step is to construct the full set of all possible atoms of a tableau (satisfaction graph) and immediately pay the worst case exponential complexity price, the algorithm presented here builds the tableau incrementally. This means that the algorithm constructs only those atoms that are reachable from a possible initial atom, satisfying the formula to be checked. While incremental tableau construction for the future fragment of linear time temporal logic can be done in a single pass, the presence of past operators requires multiple passes that successively construct augmented versions of existing atoms, while still maintaining consistency and reachability. The proof of correctness of the algorithm is based on showing that any model of the considered formula is embedded as a path in the tableau at all the construction stages, and can be delineated when the construction terminates. The paper also describes an implementation of the algorithm with further attention to efficiency. This implementation is available as a support system for the book [8] under the name "temporal prover". It has been used to verify all the propositional temporal formulas and to model-check all the finite-state programs appearing in the book. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Ben-Ari, Z. Manna, and A. Pnueli. </author> <title> The temporal logic of branching time. </title> <journal> Acta Informatica, </journal> <volume> 20 </volume> <pages> 207-226, </pages> <year> 1983. </year>
Reference-contexts: Declarative tableaux are clearer and easier to understand and analyze. They are used to prove properties of the logic, such as upper bounds on the complexity of decision procedures [2], [11]. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation <ref> [1] </ref>, [10], [9]. The reason for this difference in efficiency is that the declarative construction starts by constructing all possible atoms, immediately realizing the worst case complexity which, as shown in [11], is exponential. The incremental construction, on the other hand, proceeds more conservatively, constructing only reachable atoms.
Reference: 2. <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: Declarative tableaux are clearer and easier to understand and analyze. They are used to prove properties of the logic, such as upper bounds on the complexity of decision procedures <ref> [2] </ref>, [11]. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation [1], [10], [9].
Reference: 3. <author> G. D. Gough and H. Barringer. </author> <title> A semantic driven temporal verification. </title> <booktitle> In Proceedings of ESOP'88, </booktitle> <year> 1988. </year>
Reference-contexts: The algorithms described in [10] and [9] are incremental but are restricted to the future fragment of the language. Other previous implementations of a decision procedure for the full language are presented in [4] and <ref> [3] </ref>, but very little algorithmic detail is provided. One can clearly use any satisfiability checking algorithm to check validity over all models, since a formula ' is valid iff : ' is unsatisfiable.
Reference: 4. <author> G. D. Gough. </author> <title> Decision procedures for temporal logic, </title> <type> Master's thesis, </type> <institution> University of Manchester, </institution> <address> England, </address> <year> 1984. </year>
Reference-contexts: The algorithms described in [10] and [9] are incremental but are restricted to the future fragment of the language. Other previous implementations of a decision procedure for the full language are presented in <ref> [4] </ref> and [3], but very little algorithmic detail is provided. One can clearly use any satisfiability checking algorithm to check validity over all models, since a formula ' is valid iff : ' is unsatisfiable.
Reference: 5. <author> J.A.W. Kamp. </author> <title> Tense Logic and the Theory of Order. </title> <type> PhD thesis, </type> <institution> UCLA, </institution> <year> 1968. </year>
Reference-contexts: 1 Introduction We consider the full language of linear time temporal logic, as defined by Kamp <ref> [5] </ref>.
Reference: 6. <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proc. 12th ACM Symp. Princ. of Prog. Lang., </booktitle> <pages> pages 97-107, </pages> <year> 1985. </year>
Reference-contexts: One can clearly use any satisfiability checking algorithm to check validity over all models, since a formula ' is valid iff : ' is unsatisfiable. As shown in <ref> [6] </ref> and [11], a satisfiability (validity) checking algorithm for linear time temporal logic can be used to check validity of a formula ' over all computations of a given finite-state program P (model checking ). <p> The entire algorithm: satisfy ( ' ) construct-initial ( ' ) correct-graph strongly-connected-components-analysis end satisfy. The procedure strongly-connected-components-analysis analyzes the graph by decomposing it into maximal strongly connected components and identifying those which are self-fulfilling <ref> [6] </ref>. A strongly connected component C is called self-fulfilling if every atom A 2 C has at least one successor, and for every formula p U q 2 A, there exists an atom B 2 C such that q 2 B.
Reference: 7. <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. </title> <booktitle> In Proc. Conf. Logics of Programs, volume 193 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 196-218. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This paper presents an implementation of an algorithm for deciding the satis-fiability of a propositional linear time temporal formula in the full language that includes both past and future operators, using incremental tableaux. For comparison, the decision procedure described in <ref> [7] </ref> is based on declarative tableaux and is, therefore, unsuitable for implementation. The algorithms described in [10] and [9] are incremental but are restricted to the future fragment of the language.
Reference: 8. <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The implementation reported here has been used to verify all the propositional formulas appearing in the book <ref> [8] </ref> and to model-check all the finite-state programs appearing there. The implementation is available to readers of the book as a support tool. Section 2 presents a high-level, simplified description of the algorithm. Section 3 provides additional details about our implementation, which is derived from the implementation reported in [12]. <p> discussion. 2 An Incremental Tableau Algorithm for PTL formulas In this section, we present a simplified description of an algorithm for checking the satisfiability of a temporal formula ' . 2.1 The Language PTL In what follows, we refer to the PTL language, with syntax and semantics as defined in <ref> [8] </ref>. For a simpler presentation of the algorithm, we consider only the following operators: Boolean operators: : , ^. Temporal operators: 2 Next, U Until,- Previous, S Since.
Reference: 9. <author> Z. Manna and P. Wolper. </author> <title> Synthesis of communicating processes from temporal logic specifications. </title> <journal> ACM Trans. Prog. Lang. Sys., </journal> <volume> 6 </volume> <pages> 68-93, </pages> <year> 1984. </year>
Reference-contexts: Declarative tableaux are clearer and easier to understand and analyze. They are used to prove properties of the logic, such as upper bounds on the complexity of decision procedures [2], [11]. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation [1], [10], <ref> [9] </ref>. The reason for this difference in efficiency is that the declarative construction starts by constructing all possible atoms, immediately realizing the worst case complexity which, as shown in [11], is exponential. The incremental construction, on the other hand, proceeds more conservatively, constructing only reachable atoms. <p> For comparison, the decision procedure described in [7] is based on declarative tableaux and is, therefore, unsuitable for implementation. The algorithms described in [10] and <ref> [9] </ref> are incremental but are restricted to the future fragment of the language. Other previous implementations of a decision procedure for the full language are presented in [4] and [3], but very little algorithmic detail is provided.
Reference: 10. <author> A. Pnueli and R. Sherman. </author> <title> Semantic tableau for temporal logic. </title> <type> Technical Report CS81 - 21, </type> <institution> The Weizmann Institute, </institution> <year> 1981. </year>
Reference-contexts: Declarative tableaux are clearer and easier to understand and analyze. They are used to prove properties of the logic, such as upper bounds on the complexity of decision procedures [2], [11]. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation [1], <ref> [10] </ref>, [9]. The reason for this difference in efficiency is that the declarative construction starts by constructing all possible atoms, immediately realizing the worst case complexity which, as shown in [11], is exponential. The incremental construction, on the other hand, proceeds more conservatively, constructing only reachable atoms. <p> For comparison, the decision procedure described in [7] is based on declarative tableaux and is, therefore, unsuitable for implementation. The algorithms described in <ref> [10] </ref> and [9] are incremental but are restricted to the future fragment of the language. Other previous implementations of a decision procedure for the full language are presented in [4] and [3], but very little algorithmic detail is provided.
Reference: 11. <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Declarative tableaux are clearer and easier to understand and analyze. They are used to prove properties of the logic, such as upper bounds on the complexity of decision procedures [2], <ref> [11] </ref>. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation [1], [10], [9]. The reason for this difference in efficiency is that the declarative construction starts by constructing all possible atoms, immediately realizing the worst case complexity which, as shown in [11], is exponential. <p> decision procedures [2], <ref> [11] </ref>. Incremental tableaux, on the other hand, are more efficient, and are obviously better for implementation [1], [10], [9]. The reason for this difference in efficiency is that the declarative construction starts by constructing all possible atoms, immediately realizing the worst case complexity which, as shown in [11], is exponential. The incremental construction, on the other hand, proceeds more conservatively, constructing only reachable atoms. As a result, in most cases, a much smaller number of atoms is ever explored. <p> One can clearly use any satisfiability checking algorithm to check validity over all models, since a formula ' is valid iff : ' is unsatisfiable. As shown in [6] and <ref> [11] </ref>, a satisfiability (validity) checking algorithm for linear time temporal logic can be used to check validity of a formula ' over all computations of a given finite-state program P (model checking ).
Reference: 12. <author> R. Sherman and A. Pnueli. </author> <title> Model checking for linear temporal logic: An efficient implementation. </title> <type> Technical report, </type> <institution> Information Science Institute, USC, </institution> <year> 1989. </year>
Reference-contexts: The implementation is available to readers of the book as a support tool. Section 2 presents a high-level, simplified description of the algorithm. Section 3 provides additional details about our implementation, which is derived from the implementation reported in <ref> [12] </ref>. The section lists several points in which the implementation improves upon the simplified description of the algorithm by being more general and more efficient than the simplified algorithm. Section 4 provides a proof of correctness for the algorithm.
References-found: 12

