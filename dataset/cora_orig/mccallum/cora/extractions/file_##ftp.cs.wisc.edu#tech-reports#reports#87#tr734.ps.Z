URL: file://ftp.cs.wisc.edu/tech-reports/reports/87/tr734.ps.Z
Refering-URL: http://www.cs.wisc.edu/exodus/exodus.papers.html
Root-URL: 
Title: A Data Model and Query Language for EXODUS  
Author: Michael J. Carey David J. DeWitt Scott L. Vandenberg 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract-found: 0
Intro-found: 1
Reference: [Andr87] <author> T. Andrews and C. Harris, </author> <title> "Combining Language and Database Advances in an Object-Oriented Development Environment," </title> <booktitle> Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie87] </ref>. In addition to sets and references, fixed and variable-length arrays are provided and are useful for modeling complex objects.
Reference: [Banc86] <author> F. Bancilhon and S. Khoshafian, </author> <title> "A Calculus for Complex Objects," </title> <booktitle> Proc. PODS Conf., </booktitle> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: The is operator is useful for comparing references, returning true if two references refer to the same object. Thus, is is a test for object equality rather than (recursive) value equality in the sense of <ref> [Banc86] </ref>. An isnot operator is also provided for convenience in testing that two references do not refer to the same object. As in GEM, these are the only comparison operators applicable to references.
Reference: [Bane87] <author> J. Banerjee et al., </author> <title> "Data Model Issues for Object-Oriented Applications," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION <ref> [Bane87] </ref>, Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> Figure 3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type [Rowe87], while TAXIS would simply disallow the conflict 5 [Nixo87]. EXTRA is closest to ORION <ref> [Bane87] </ref> in its handling of conflicts, except that we provide no automatic resolution. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie87] </ref>. In addition to sets and references, fixed and variable-length arrays are provided and are useful for modeling complex objects. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> EXTRA's ref notion was based on GEM reference attributes [Zani83], and own ref is closely related to weak entities in the E-R model [Chen76] and composite objects in ORION <ref> [Bane87] </ref>. EXTRA also goes beyond these systems in certain ways, however. In particular, to our knowledge, EXTRA's mix of own, ref, and own ref attributes yields a relatively unique mix of (structural) object- and value-orientation.
Reference: [Bato87] <author> D. Batory, </author> <title> "Principles of Database Management System Extensibility," </title> <journal> Database Eng., </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of type inheritance.
Reference: [Bloo87] <author> Bloom, T., and Zdonik, S., </author> <booktitle> "Issues in the Design of Object-Oriented Database Programming Languages," Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: In fact, the former kind of object-oriented DBMS almost seems like a step back to the days of navigational data manipulation languages, as it is not obvious how one will support ad-hoc queries (or optimize accesses effectively) for such systems <ref> [Bloo87, Ullm87] </ref>. Another direction in data model evolution, one which has spawned such efforts as [Codd79, Dada86, Sche86, Schw86, Rowe87], is to extend the relational model in some way. <p> This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications [Lohm83, Kemp87]. While this separation is common in programming languages, it is less common in the database world <ref> [Bloo87] </ref>. As an example, the commands in Figure 1 define a new schema type called Person, which is a tuple type.
Reference: [Care86] <author> M. Carey et al., </author> <title> "The Architecture of the EXODUS Extensible DBMS," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Systems, </booktitle> <address> Pacific Grove, CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: 1. INTRODUCTION When we began the EXODUS project <ref> [Care86, Care87] </ref> over two years ago, we purposely avoided centering the project around a new data model and query language. There were several reasons for this decision.
Reference: [Care87] <author> M. Carey and D. DeWitt, </author> <title> "An Overview of the EXODUS Project," </title> <journal> Database Eng., </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: 1. INTRODUCTION When we began the EXODUS project <ref> [Care86, Care87] </ref> over two years ago, we purposely avoided centering the project around a new data model and query language. There were several reasons for this decision.
Reference: [Cham75] <author> D. Chamberlin et al., </author> <title> "Views, Authorization, and Locking in a Relational Database System," </title> <booktitle> Proc. Nat'l. Computer Conf., </booktitle> <address> Anaheim, CA, </address> <year> 1975. </year>
Reference-contexts: This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 4.2.3. Achieving Data Abstraction We plan to provide an authorization mechanism along the lines of the System R <ref> [Cham75] </ref> and IDM [IDM500] protection systems. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries.
Reference: [Chen76] <author> P. Chen, </author> <title> "The Entity-Relationship Model Toward a Unified View of Data," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 1(1), </volume> <month> March </month> <year> 1976. </year>
Reference-contexts: EXTRA's ref notion was based on GEM reference attributes [Zani83], and own ref is closely related to weak entities in the E-R model <ref> [Chen76] </ref> and composite objects in ORION [Bane87]. EXTRA also goes beyond these systems in certain ways, however. In particular, to our knowledge, EXTRA's mix of own, ref, and own ref attributes yields a relatively unique mix of (structural) object- and value-orientation.
Reference: [Codd79] <author> E. Codd, </author> <title> "Extending the Relational Model to Capture More Meaning," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 4(4), </volume> <month> Dec. </month> <year> 1979. </year>
Reference-contexts: Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way.
Reference: [Cope84] <author> G. Copeland and D. Maier, </author> <title> "Making Smalltalk a Database System," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Boston, MA, </address> <year> 1984. </year>
Reference-contexts: results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM <ref> [Cope84] </ref>, and STDM's descendant, GemStone [Maie86]. <p> Thus, our earlier query involving children of second floor employees could have been written as: retrieve (C.name) from C in Employees.kids where Employees.dept.floor = 2 EXCESS also provides a path syntax in order to simplify the task of formulating queries over nested sets of objects <ref> [Ship81, Cope84] </ref>. As an example, the statement "range of C is Employees.kids" means that for each employee object in the Employees set, C will iterate over all the children of the employee. <p> Implicit joins were taken directly from GEM, and originated in DAPLEX. The EXCESS treatment of queries over nested sets is similar in flavor to that of NF 2 query languages, although the path syntax for handling deeply nested queries was influenced by DAPLEX and the early STDM paper <ref> [Cope84] </ref>. Our handling of range variables was heavily influenced by that of POSTGRES [Rowe87]. In addition, EXCESS goes beyond its predecessors in several respects. Our mix of object- and value-oriented semantics, again, is unique among query languages that we have examined.
Reference: [Dada86] <author> P. Dadam et al., </author> <title> "A DBMS Prototype to Support Extended NF 2 Relations: An Integrated View of Flat Tables and Hierarchies," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Washington, DC, </address> <year> 1986. </year>
Reference-contexts: Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes <ref> [Dada86, Sche86] </ref>. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of type inheritance. <p> EXTRA data model and the associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models <ref> [Dada86, Sche86] </ref>, DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> In addition, if an employee is deleted, so are his or her kids. This provides a capability very similar to that provided by NF 2 data models <ref> [Dada86, Sche86] </ref>. If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data <ref> [Dada86, Sche86] </ref>. <p> And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems <ref> [Dada86, Sche86] </ref>, and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX.
Reference: [Ditt86] <author> K. Dittrich, </author> <title> "Object-Oriented Database Systems: The Notion and the Issues," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Systems, </booktitle> <address> Pacific Grove, CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: A number of database researchers seem to believe that object-oriented database systems are the future [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86], and several flavors of object-oriented models have been identified <ref> [Ditt86] </ref>. However, there is little consensus as to what an object-oriented database system should be; such systems today range from object-oriented programming languages with persistence to full database systems based on data models that would have been called "semantic data models" two years ago. <p> One approach to dealing with complex objects (also known as "structural object-orientation" <ref> [Ditt86] </ref>) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data [Ship81, Mano86, Bato87].
Reference: [Fish87] <author> D. Fishman et al., </author> <title> "Iris: An Object-Oriented Database Management System," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> A function may return a result of any type, including a schema type, a set of some schema type, etc. Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX [Ship81] and IRIS <ref> [Fish87] </ref>. They can also be viewed as a simplified form of POSTGRES procedure attributes [Ston87a]; in particular, they are like parameterized procedure attributes. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS <ref> [Fish87] </ref>, and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined 28 procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. 6.
Reference: [Grae87] <author> G. Graefe and D. DeWitt, </author> <title> "The EXODUS Optimizer Generator," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: First, optimizer-specific information will not be specified via the EXCESS/EXTRA interface. Instead, it will be given in tabular form to a utility responsible for managing optimizer information. The EXCESS query optimizer, which will be constructed using the EXODUS optimizer generator <ref> [Grae87] </ref>, will do table lookup to determine method applicability for ADTs (so that ADTs can be easily added dynamically). <p> This is different than [Ston87b], where operators but not functions are optimized. Third, we will support the addition of both new access methods and new join methods (written by expert users, or "database implementors") to the DBMS through the rule-based optimization techniques detailed in <ref> [Grae87] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 10 The function/procedure distinction here is based on the existence or absence of a return value. We may relax our side-effect-free assumption for functions eventually, and it is a convention and not a constraint that the system will enforce. 23 4.2. <p> Finally, we will face type evolution issues at two levels for ADTs, and for EXTRA schema types. At the next level down, we need to design a query algebra upon which to construct a query optimizer using the EXODUS optimizer generator <ref> [Grae87] </ref>, and we need to carefully design the tables for linking ADTs to access methods and join methods.
Reference: [Horn87] <author> M. Hornick and S. Zdonik, </author> <title> "A Shared, Segmented Memory System for an Object-Oriented Database," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie87] </ref>. In addition to sets and references, fixed and variable-length arrays are provided and are useful for modeling complex objects.
Reference: [IDM500] <institution> IDM 500 Software Reference Manual, </institution> <note> version 1.4, </note> <institution> Britton-Lee Inc., Los Gatos, </institution> <address> CA. </address> <month> 30 </month>
Reference-contexts: EXCESS functions and procedures are inherited through the type lattice in a manner similar to inheritance for attributes, giving EXTRA an object-oriented flavor. The goal of these facilities is to provide support for derived data, for writing "stored commands" (as in the IDM-500 query facility <ref> [IDM500] </ref>), and for data abstraction of the kind described by Weber [Webe78]. 4.2.1. EXCESS Functions As illustrated in an example in Section 2.3, associating functions with schema types provides a mechanism for defining derived attributes. <p> This kind of procedure is similar in flavor to the stored commands of the IDM database machine <ref> [IDM500] </ref>. However, it is much more general, as we support the use of a where clause for binding procedure parameters and we invoke the procedure for all possible bindings (instead of just once, with constant parameters). <p> This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 4.2.3. Achieving Data Abstraction We plan to provide an authorization mechanism along the lines of the System R [Cham75] and IDM <ref> [IDM500] </ref> protection systems. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries. <p> For example, one could choose to grant access to a given schema type only via its EXCESS functions and procedures, effectively making the schema type an abstract data type in its own right. (In fact, IDM stored commands are recommended for regulating database activity in a similar way <ref> [IDM500] </ref>.) Features such as the modules of [Webe78] or the object semantics of an object-oriented data model can thus be captured via a single, more general mechanism. 4.3. <p> With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS [Fish87], and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined 28 procedures is rooted in the stored commands of the IDM database machine <ref> [IDM500] </ref>, as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. 6. SUMMARY AND FUTURE WORK In this paper we have presented the design of the EXTRA data model and the EXCESS query language.
Reference: [Kemp87] <author> A. Kemper and M. Wallrath, </author> <title> "An Analysis of Geometric Modeling in Database Systems," </title> <journal> ACM Comp. Surveys 19(1), </journal> <month> March </month> <year> 1987. </year>
Reference-contexts: This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications <ref> [Lohm83, Kemp87] </ref>. While this separation is common in programming languages, it is less common in the database world [Bloo87]. As an example, the commands in Figure 1 define a new schema type called Person, which is a tuple type.
Reference: [Khos86] <author> S. Khoshafian and G. Copeland, </author> <title> "Object Identity," </title> <booktitle> Proc. of the 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: We also intend to support keys, the specification of which will be associated with set instances. 7 value, not a first-class object; it lacks identity in the sense of <ref> [Khos86] </ref>. By default, all attributes are taken to be own attributes unless otherwise specified.
Reference: [Khos87] <author> S. Khoshafian and P. Valduriez, </author> <title> "Sharing, Persistence, and Object Orientation: A Database Perspective," </title> <publisher> DB-106-87, MCC, </publisher> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86].
Reference: [Kim87] <author> W. Kim et al., </author> <title> "Composite Object Support in an Object-Oriented Database System," </title> <booktitle> Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: There are also related cases where the components of an object need to be "full-fledged objects," but where the object should still be treated as a whole, as in ORION's composite objects <ref> [Kim87] </ref>. To support these different cases, EXTRA provides three different kinds of attribute value semantics: own attributes, ref attributes, and own ref attributes. <p> If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). As with composite objects in ORION <ref> [Kim87] </ref>, however, a Person instance in the kids set of one Employee instance cannot be in the kids set of another Employee instance simultaneously.
Reference: [Klau85] <author> A. Klausner and N. Goodman, </author> <title> "Multirelations Semantics and Languages," </title> <booktitle> Proc. 11th VLDB Conf., </booktitle> <address> Stockholm, Sweden, </address> <year> 1985. </year>
Reference-contexts: on attributes from one level of a complex object while partitioning on attributes from other hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 Using over in this way facilitates certain queries that would otherwise be difficult to express using QUEL unique aggregates or aggregates with SQL-like unique clauses, and it also renders such uniqueness clauses unnecessary <ref> [Klau85] </ref>. 7 Our scoping rules are similar to those of POSTQUEL [Rowe87, Ston87c]. 17 levels.
Reference: [Klug82] <author> A. Klug, </author> <title> "Equivalence of Relational Algebra and Relational Calculus Query Languages Having Aggregate Functions," </title> <journal> J. ACM 29(3), </journal> <month> July </month> <year> 1982. </year>
Reference: [Lecl87] <author> C. Lecluse et al., </author> <title> "O 2 , an Object-Oriented Data Model," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Chicago, IL, </address> <year> 1988. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 <ref> [Lecl87] </ref>, STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie87] </ref>. In addition to sets and references, fixed and variable-length arrays are provided and are useful for modeling complex objects. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction).
Reference: [Lohm83] <author> G. Lohman et al., </author> <title> "Remotely-Sensed Geophysical Databases: Experience and Implications for Generalized DBMS," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> San Jose, CA, </address> <year> 1983. </year>
Reference-contexts: This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications <ref> [Lohm83, Kemp87] </ref>. While this separation is common in programming languages, it is less common in the database world [Bloo87]. As an example, the commands in Figure 1 define a new schema type called Person, which is a tuple type.
Reference: [Maie86] <author> D. Maier et al., </author> <title> "Development of an Object-Oriented DBMS," </title> <booktitle> Proc. 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <year> 1986. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Lecl87, Horn87, Andr87, Bane87, Maie86] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone <ref> [Maie86] </ref>. <p> COMPARISON WITH OTHER WORK The EXTRA data model and EXCESS query language designs represent a synthesis and extension of ideas drawn from a number of other data models (both past and present). The data structuring facilities of the EXTRA data model are probably closest to those of GemStone <ref> [Maie86] </ref>, as GemStone provides both tuple and array constructors, and data is organized into user-maintained extents rather than system-maintained type extents.
Reference: [Mano86] <author> F. Manola and U. Dayal, "PDM: </author> <title> An Object-Oriented Data Model," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Sys., Asilomar, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of type inheritance.
Reference: [Mylo80] <editor> J. Mylopoulos et al., </editor> <title> "A Language Facility for Designing Database-Intensive Applications," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 5(2), </volume> <month> June </month> <year> 1980. </year>
Reference-contexts: EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction).
Reference: [Nixo87] <editor> B. Nixon et al., </editor> <title> "Implementation of a Compiler for a Semantic Data Model: Experiences with TAXIS," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> San Francisco, CA, </address> <year> 1987. </year>
Reference-contexts: Figure 3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type [Rowe87], while TAXIS would simply disallow the conflict 5 <ref> [Nixo87] </ref>. EXTRA is closest to ORION [Bane87] in its handling of conflicts, except that we provide no automatic resolution.
Reference: [Ong84] <author> J. Ong et al., </author> <title> "Implementation of Data Abstraction in the Relational Database System INGRES," </title> <booktitle> SIGMOD Record 14(1), </booktitle> <month> March </month> <year> 1984. </year>
Reference-contexts: Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax. <p> Comparing EXCESS to POSTQUEL in general, we feel that omitting procedures as instance-level field values leads to cleaner and more consistent query language semantics. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker <ref> [Ong84, Ston86] </ref> and the resulting extension facilities in POSTGRES [Ston87b]. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here.
Reference: [Rich87] <author> J. Richardson and M. Carey, </author> <title> "Programming Constructs for Database System Implementation in EXODUS," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: We distinguish between these two kinds of type extensions because of the different facilities that are provided for implementing them: ADTs are written in the E programming language <ref> [Rich87] </ref>, using the type system and general-purpose programming facilities provided by E. Schema types are created using the type system provided by the EXTRA data model and the higher-level but more restrictive programming facilities offered by the EXCESS query language. <p> E extends C++ with a number of features to aid programmers in database system programming, including "dbclasses" for persistent storage, class generators for implementing "generic" classes and functions, iterators for use as a control abstraction in writing set operations, and built-in class generators for typed files and variable-length arrays <ref> [Rich87] </ref>. Suppose that we wanted to add complex number as a new ADT. First, we would need to implement the ADT as a dbclass (much like a C++ class) in E. Figure 7 gives a slightly simplified E interface definition for the Complex dbclass. <p> In particular, one could introduce a "median" aggregate function for sets of integers, but not one that works for any totally ordered type [Ston87b]. The EXCESS approach to such extensions is based on features provided by the E programming language <ref> [Rich87] </ref>. E provides a facility for writing generic functions, and it supports the specification of constraints on the generic type (e.g., any type that has boolean "less_than" and "equals" member functions). E also provides a construct, called an iterator function, for returning sequences of values of a given type.
Reference: [Rowe87] <author> L. Rowe and M. Stonebraker, </author> <title> "The POSTGRES Data Model," </title> <booktitle> Proc. 13th VLDB Conf., </booktitle> <address> Brighton, Eng-land, </address> <year> 1987. </year>
Reference-contexts: Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> This paper presents the EXTRA data model and the associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES <ref> [Rowe87] </ref>, NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> Figure 3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type <ref> [Rowe87] </ref>, while TAXIS would simply disallow the conflict 5 [Nixo87]. EXTRA is closest to ORION [Bane87] in its handling of conflicts, except that we provide no automatic resolution. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> Lastly, associative query languages are important because they are amenable to query optimization techniques. In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES <ref> [Rowe87, Ston87b] </ref> as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86]. <p> For example: retrieve (Today) retrieve (StarEmployee.name, StarEmployee.salary) retrieve (TopTen [1].name, TopTen [1].salary) 3.2. Range Variables and Their Types EXCESS provides several different mechanisms for specifying the set of objects over which a variable is to range. Most are similar to the mechanisms of GEM [Zani83] and POSTQUEL <ref> [Rowe87] </ref>, but EXCESS also provides support for universal quantification (to simplify certain kinds of set queries). The simplest form of range statement has the traditional QUEL syntax, i.e., "range of &lt;Variable&gt; is &lt;Range_Specification&gt;". <p> on attributes from other hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 Using over in this way facilitates certain queries that would otherwise be difficult to express using QUEL unique aggregates or aggregates with SQL-like unique clauses, and it also renders such uniqueness clauses unnecessary [Klau85]. 7 Our scoping rules are similar to those of POSTQUEL <ref> [Rowe87, Ston87c] </ref>. 17 levels. <p> And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems [Dada86, Sche86], and POSTGRES <ref> [Rowe87] </ref>. Implicit joins were taken directly from GEM, and originated in DAPLEX. The EXCESS treatment of queries over nested sets is similar in flavor to that of NF 2 query languages, although the path syntax for handling deeply nested queries was influenced by DAPLEX and the early STDM paper [Cope84]. <p> Our handling of range variables was heavily influenced by that of POSTGRES <ref> [Rowe87] </ref>. In addition, EXCESS goes beyond its predecessors in several respects. Our mix of object- and value-oriented semantics, again, is unique among query languages that we have examined. Also, EXCESS provides a cleaner treatment of arrays than we have seen elsewhere.
Reference: [Scha86] <author> C. Schaffert et al., </author> <title> "An Introduction to Trellis/Owl," </title> <booktitle> Proc. 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl <ref> [Scha86] </ref>, O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86].
Reference: [Sche86] <author> H.-J. Schek and M. Scholl, </author> <title> "The Relational Model with Relation-Valued Attributes," </title> <journal> Information Sys. </journal> <volume> 11(2), </volume> <year> 1986. </year>
Reference-contexts: Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes <ref> [Dada86, Sche86] </ref>. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of type inheritance. <p> EXTRA data model and the associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models <ref> [Dada86, Sche86] </ref>, DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> In addition, if an employee is deleted, so are his or her kids. This provides a capability very similar to that provided by NF 2 data models <ref> [Dada86, Sche86] </ref>. If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data <ref> [Dada86, Sche86] </ref>. <p> And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems <ref> [Dada86, Sche86] </ref>, and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX.
Reference: [Schw86] <author> P. Schwarz et al., </author> <title> "Extensibility in the Starburst Database System," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Sys., </booktitle> <address> Pacific Grove, CA, </address> <year> 1986. </year>
Reference-contexts: Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way.
Reference: [Ship81] <author> D. Shipman, </author> <title> "The Functional Data Model and the Data Language DAPLEX," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 6(1), </volume> <month> March </month> <year> 1981. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of type inheritance. <p> and the associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX <ref> [Ship81] </ref>, ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> Thus, our earlier query involving children of second floor employees could have been written as: retrieve (C.name) from C in Employees.kids where Employees.dept.floor = 2 EXCESS also provides a path syntax in order to simplify the task of formulating queries over nested sets of objects <ref> [Ship81, Cope84] </ref>. As an example, the statement "range of C is Employees.kids" means that for each employee object in the Employees set, C will iterate over all the children of the employee. <p> A function may return a result of any type, including a schema type, a set of some schema type, etc. Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX <ref> [Ship81] </ref> and IRIS [Fish87]. They can also be viewed as a simplified form of POSTGRES procedure attributes [Ston87a]; in particular, they are like parameterized procedure attributes. <p> Neither GemStone nor Orion have support for own attributes (except perhaps in implementing their small atomic types). And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. The EXCESS query language is related to those of DAPLEX <ref> [Ship81] </ref>, GEM [Zani83], NF 2 systems [Dada86, Sche86], and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX <ref> [Ship81] </ref> and IRIS [Fish87], and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined 28 procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. 6.
Reference: [Ston76] <author> M. Stonebraker et al., </author> <title> "The Design and Implementation of INGRES," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 1(3), </volume> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: Lastly, associative query languages are important because they are amenable to query optimization techniques. In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL <ref> [Ston76] </ref>, we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86].
Reference: [Ston86] <author> M. Stonebraker, </author> <title> "Inclusion of New Types in Relational Database Systems," </title> <booktitle> Proc. 2nd Data Eng. Conf., </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Predefined base types include integers of various sizes, single and double-precision floating point numbers, booleans, character strings, and enumerations. EXTRA also supports the addition of new base types through an abstract data type (ADT) facility similar to those of <ref> [Ston86, Ston87b] </ref> like the Date type in Figure 1; ADT support will be covered in a later section. The type constructors of EXTRA include tuple (e.g., Person is a tuple type), fixed length arrays, variable length arrays, sets, and references. <p> Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax. <p> Finally, it is important that the query optimizer be given sufficient information to recognize the applicability of alternative access methods and join methods when optimizing queries involving ADTs. We will follow an approach similar to that outlined in <ref> [Ston86, Ston87b] </ref> for addressing this issue, with a few differences. First, optimizer-specific information will not be specified via the EXCESS/EXTRA interface. Instead, it will be given in tabular form to a utility responsible for managing optimizer information. <p> The EXCESS query optimizer, which will be constructed using the EXODUS optimizer generator [Grae87], will do table lookup to determine method applicability for ADTs (so that ADTs can be easily added dynamically). These tables will be similar to the access method templates of <ref> [Ston86] </ref>, but expression-level optimizer information (e.g., associativity, commutativity, complementary function pairs, etc.) will also be represented in tabular form at this level. Second, ADT functions and operators will be treated uniformly for query optimization purposes. This is different than [Ston87b], where operators but not functions are optimized. <p> Comparing EXCESS to POSTQUEL in general, we feel that omitting procedures as instance-level field values leads to cleaner and more consistent query language semantics. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker <ref> [Ong84, Ston86] </ref> and the resulting extension facilities in POSTGRES [Ston87b]. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here.
Reference: [Ston87a] <author> M. Stonebraker et al., </author> <title> "Extending a Database System with Procedures," </title> <journal> ACM Trans. Database Sys. </journal> <volume> 12(3), </volume> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type <ref> [Ston87a] </ref>. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. <p> Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX [Ship81] and IRIS [Fish87]. They can also be viewed as a simplified form of POSTGRES procedure attributes <ref> [Ston87a] </ref>; in particular, they are like parameterized procedure attributes. We do not support true procedure attributes, or "EXCESS as a data type," because procedure attributes are not needed for representing complex object structures in EXTRA as they are in POSTGRES. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS [Fish87], and also to the parameterized procedures of POSTGRES <ref> [Ston87a] </ref>. Our approach to user-defined 28 procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. 6.
Reference: [Ston87b] <author> M. Stonebraker et al., </author> <title> "Extendability in POSTGRES," </title> <journal> Database Eng., </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: Predefined base types include integers of various sizes, single and double-precision floating point numbers, booleans, character strings, and enumerations. EXTRA also supports the addition of new base types through an abstract data type (ADT) facility similar to those of <ref> [Ston86, Ston87b] </ref> like the Date type in Figure 1; ADT support will be covered in a later section. The type constructors of EXTRA include tuple (e.g., Person is a tuple type), fixed length arrays, variable length arrays, sets, and references. <p> Lastly, associative query languages are important because they are amenable to query optimization techniques. In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES <ref> [Rowe87, Ston87b] </ref> as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86]. <p> Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax. <p> Existing EXCESS operators can be overloaded, as illustrated here. In addition, it is possible to introduce new operators (any legal EXCESS identifier or sequence of punctuation characters may be used). For new operators, we require the precedence and associativity of the operator to be specified, much as in <ref> [Ston87b] </ref>. Prefix operators can also be defined, and the number of arguments that an operator can have is not restricted. However, functions with three or more arguments cannot be defined as infix operators, and functions that are overloaded 22 within a single dbclass may not be defined as operators. <p> Finally, it is important that the query optimizer be given sufficient information to recognize the applicability of alternative access methods and join methods when optimizing queries involving ADTs. We will follow an approach similar to that outlined in <ref> [Ston86, Ston87b] </ref> for addressing this issue, with a few differences. First, optimizer-specific information will not be specified via the EXCESS/EXTRA interface. Instead, it will be given in tabular form to a utility responsible for managing optimizer information. <p> Second, ADT functions and operators will be treated uniformly for query optimization purposes. This is different than <ref> [Ston87b] </ref>, where operators but not functions are optimized. <p> Support for this form of extension has been included in POSTGRES, but in a limited form. In particular, one could introduce a "median" aggregate function for sets of integers, but not one that works for any totally ordered type <ref> [Ston87b] </ref>. The EXCESS approach to such extensions is based on features provided by the E programming language [Rich87]. E provides a facility for writing generic functions, and it supports the specification of constraints on the generic type (e.g., any type that has boolean "less_than" and "equals" member functions). <p> Comparing EXCESS to POSTQUEL in general, we feel that omitting procedures as instance-level field values leads to cleaner and more consistent query language semantics. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker [Ong84, Ston86] and the resulting extension facilities in POSTGRES <ref> [Ston87b] </ref>. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here.
Reference: [Ston87c] <author> M. Stonebraker, </author> <type> personal communication, </type> <year> 1987. </year>
Reference-contexts: In addition, a full-function query language makes it possible for the same database system to be used for both business and engineering data, supporting queries such as those needed to compute design costs or to order parts for assembling a design object <ref> [Ston87c] </ref>. Lastly, associative query languages are important because they are amenable to query optimization techniques. In this section we present the design of the EXCESS query language. <p> on attributes from other hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 Using over in this way facilitates certain queries that would otherwise be difficult to express using QUEL unique aggregates or aggregates with SQL-like unique clauses, and it also renders such uniqueness clauses unnecessary [Klau85]. 7 Our scoping rules are similar to those of POSTQUEL <ref> [Rowe87, Ston87c] </ref>. 17 levels.
Reference: [Stro86] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: To add a new ADT, the person responsible for adding the type begins by writing (and debugging) the code for the type in the E programming language. E is an extension of C++ <ref> [Stro86] </ref> that has been designed and is currently being implemented as part of the EXODUS project. <p> This is similar to the distinction between virtual member functions and regular member functions in C++ <ref> [Stro86] </ref>. 4.2.3. Achieving Data Abstraction We plan to provide an authorization mechanism along the lines of the System R [Cham75] and IDM [IDM500] protection systems. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries.
Reference: [Ullm87] <author> J. Ullman, </author> <title> "Database Theory Past and Future," </title> <booktitle> Proc. PODS Conf., </booktitle> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year> <month> 31 </month>
Reference-contexts: In fact, the former kind of object-oriented DBMS almost seems like a step back to the days of navigational data manipulation languages, as it is not obvious how one will support ad-hoc queries (or optimize accesses effectively) for such systems <ref> [Bloo87, Ullm87] </ref>. Another direction in data model evolution, one which has spawned such efforts as [Codd79, Dada86, Sche86, Schw86, Rowe87], is to extend the relational model in some way.
Reference: [Webe78] <author> H. Weber, </author> <title> "A Software Engineering View of Database Systems," </title> <booktitle> Proc. 4th VLDB Conf., </booktitle> <year> 1978. </year>
Reference-contexts: The goal of these facilities is to provide support for derived data, for writing "stored commands" (as in the IDM-500 query facility [IDM500]), and for data abstraction of the kind described by Weber <ref> [Webe78] </ref>. 4.2.1. EXCESS Functions As illustrated in an example in Section 2.3, associating functions with schema types provides a mechanism for defining derived attributes. <p> to grant access to a given schema type only via its EXCESS functions and procedures, effectively making the schema type an abstract data type in its own right. (In fact, IDM stored commands are recommended for regulating database activity in a similar way [IDM500].) Features such as the modules of <ref> [Webe78] </ref> or the object semantics of an object-oriented data model can thus be captured via a single, more general mechanism. 4.3.
Reference: [Zani83] <author> C. Zaniolo, </author> <title> "The Database Language GEM," </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> San Jose, CA, </address> <year> 1983. </year>
Reference-contexts: This paper presents the EXTRA data model and the associated EXCESS query language, which are the results of our design effort. 1 Readers familiar with the data modeling literature will recognize the result as a synthesis and extension of ideas from other data models and systems, including GEM <ref> [Zani83] </ref>, POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Lecl87], STDM [Cope84], and STDM's descendant, GemStone [Maie86]. <p> These are like reference attributes in GEM <ref> [Zani83] </ref>, with each Student object containing (a reference to) its corresponding Department object. The 6 referenced department object is required to exist elsewhere in the database (or else the value of the reference must be null 2 ). <p> An own attribute is simply a hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 Space limitations prevent us from fully addressing the integrity implications of EXTRA, but referential integrity and null values will be handled in a manner similar to GEM <ref> [Zani83] </ref>. We also intend to support keys, the specification of which will be associated with set instances. 7 value, not a first-class object; it lacks identity in the sense of [Khos86]. By default, all attributes are taken to be own attributes unless otherwise specified. <p> Lastly, associative query languages are important because they are amenable to query optimization techniques. In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM <ref> [Zani83] </ref> and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86]. <p> For example: retrieve (Today) retrieve (StarEmployee.name, StarEmployee.salary) retrieve (TopTen [1].name, TopTen [1].salary) 3.2. Range Variables and Their Types EXCESS provides several different mechanisms for specifying the set of objects over which a variable is to range. Most are similar to the mechanisms of GEM <ref> [Zani83] </ref> and POSTQUEL [Rowe87], but EXCESS also provides support for universal quantification (to simplify certain kinds of set queries). The simplest form of range statement has the traditional QUEL syntax, i.e., "range of &lt;Variable&gt; is &lt;Range_Specification&gt;". <p> The data structuring facilities of the EXTRA data model are probably closest to those of GemStone [Maie86], as GemStone provides both tuple and array constructors, and data is organized into user-maintained extents rather than system-maintained type extents. EXTRA's ref notion was based on GEM reference attributes <ref> [Zani83] </ref>, and own ref is closely related to weak entities in the E-R model [Chen76] and composite objects in ORION [Bane87]. EXTRA also goes beyond these systems in certain ways, however. <p> And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. The EXCESS query language is related to those of DAPLEX [Ship81], GEM <ref> [Zani83] </ref>, NF 2 systems [Dada86, Sche86], and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX.
References-found: 45

