URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-95-10-3.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-95-10-3.html
Root-URL: http://www.cs.man.ac.uk
Title: Enhancing the Tractability of Rely/Guarantee Specifications in the Development of Interfering Operations  
Author: Pierre Collette and Cliff B. Jones 
Affiliation: Computer Science University of Manchester  
Pubnum: Technical Report UMCS-95-10-3  
Abstract-found: 0
Intro-found: 1
Reference: [AL93] <author> Martin Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [And91] <author> Gregory R. Andrews. </author> <title> Concurrent Programming | Principles and Practices. </title> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: Imposing atomicity for all assignment statements would require a lot of synchronisation overhead to implement them (see e.g. <ref> [And91] </ref>). Such overheads should only be incurred when required and specified by the designer (e.g. using atomic brackets). <p> Nevertheless, m can still be accessed (but not modified) by other operations (e.g. TEST), even between the two accesses to m in the Boolean expression. Thus, the assignment statements in Figure 2 are not assumed to be executed atomically. Critical sections are well known in concurrent programming (e.g. <ref> [And91] </ref>). The key issue is that such critical sections should not appear all of a sudden in the final code. They can be introduced during the design. This protect mechanism has been introduced (cf.
Reference: [Bic92] <author> Juan Bicarregui. </author> <title> Operation semantics with read and write frames. </title> <editor> In C.B. Jones, R.C. Shaw, and T. Denvir, editors, </editor> <booktitle> 5th Refinement Workshop, </booktitle> <pages> pages 260-278. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: How the latter is carried out is addressed in Section 6. 5.2 Enriched Mode Restrictions Write-mode restrictions on variables can be understood as commitments of the operation: no other variables can be modified. Read-mode can be interpreted in several ways <ref> [Bic92] </ref>; in this case study, all variables that can be accessed but not modified by the operation are required to appear with read-mode; non-mentioned variables cannot be accessed by the operation.
Reference: [BK85] <author> Howard Barringer and Ruud Kuiper. </author> <title> Hierarchical development of concurrent systems in a temporal logic framework. In S.D. </title> <editor> Brookes, A.W. Roscoe, and G. Winskel, editors, </editor> <booktitle> Seminar on Concurrency, volume 197 of Lecture Notes in Computer Science, </booktitle> <pages> pages 35-61. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [CM88] <author> K.Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: But this is already the case for data reification steps in the development of sequential operations in VDM [Jon90] or B. The methodological importance of invariants in concurrency is not new; detailed developments based on invariants can be found -for example- in <ref> [CM88, Gri93] </ref>. As mentioned in the introduction, theoretical aspects have been intentionally neglected in the current paper.
Reference: [Col94] <author> Pierre Collette. </author> <title> Composition of assumption-commitment specifications in a UNITY style. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 107-125, </pages> <year> 1994. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [GNL91] <author> Peter Gronning, Thomas Qvist Nielsen, and Hans Henrik Lovengreen. </author> <title> Refinement and composition of transition-based rely-guarantee specifications with auxiliary variables. </title> <editor> In K.V. Nori and C.E. Veni Madhavan, editors, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 472 of Lecture Notes in Computer Science, </booktitle> <pages> pages 332-348. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Concurrent execution of that operation not only further complicates the development but also raises expressiveness problems: it seems that the formulation of an adequate evolution invariant requires the use of history determined auxiliary variables. Use of auxiliary variables with rely/guarantee specifications is detailed in <ref> [GNL91, Sto91] </ref>. Auxiliary variables lead to clearer specifications than nested temporal operators, but inappropriate use can lead to cumbersome specifications too.
Reference: [Gri93] <author> Pascal Gribomont. </author> <title> Concurrency without toil: a systematic method for parallel program design. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 21 </volume> <pages> 1-56, </pages> <year> 1993. </year>
Reference-contexts: But this is already the case for data reification steps in the development of sequential operations in VDM [Jon90] or B. The methodological importance of invariants in concurrency is not new; detailed developments based on invariants can be found -for example- in <ref> [CM88, Gri93] </ref>. As mentioned in the introduction, theoretical aspects have been intentionally neglected in the current paper.
Reference: [Jon79] <author> Cliff B. Jones. </author> <title> Constructing a theory of data structure as an aid to program development. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 119-137, </pages> <year> 1979. </year>
Reference-contexts: It is recommended <ref> [Jon79] </ref> to use them to develop a `theory' of the data types involved.
Reference: [Jon81] <author> Cliff B. Jones. </author> <title> Development Methods for Computer Programs Including a Notion of Interference. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1981. </year>
Reference-contexts: A sequential operation can then be interpreted as a binary relation on the state space and specified with pre and post conditions; examples are given below but readers are assumed to be familiar with pre/post specifications in the style of VDM. In <ref> [Jon81] </ref>, rely and guarantee conditions are proposed as an extension to cope with the specification and development of concurrent operations, a situation that occurs when operations sharing state components have overlapping executions.
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development using VDM. </title> <booktitle> Prentice-Hall International, Second Edition, </booktitle> <year> 1990. </year> <month> 22 </month>
Reference-contexts: Explicit data invariants also bring insight to the problem. Data invariants are helpful in the development of sequential operations <ref> [Jon90] </ref> and remain so in the development of interfering operations. In the specification of sequential operations, data invariants can be considered as implicit pre and post conditions on all operations on the state space. <p> Therefore, local reasoning is not totally enforced because each operation is not developed independently down to code: a data reification step (with strengthening of the invariants) concerns all operations. But this is already the case for data reification steps in the development of sequential operations in VDM <ref> [Jon90] </ref> or B. The methodological importance of invariants in concurrency is not new; detailed developments based on invariants can be found -for example- in [CM88, Gri93]. As mentioned in the introduction, theoretical aspects have been intentionally neglected in the current paper.
Reference: [JT95] <author> Bengt Jonsson and Yih-Kuen Tsay. </author> <title> Assumption/guarantee specifications in linear time temporal logic. </title> <editor> In P.D. Mosses, M. Nielsen, and M.I. Schwartzbach, editors, TAPSOFT'95: </editor> <booktitle> Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, </booktitle> <pages> pages 262-276. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [KR93] <author> Andrew Kay and Joy N. Reed. </author> <title> A rely and guarantee method for timed CSP: a specification and design of a telephone exchange. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19 </volume> <pages> 625-639, </pages> <year> 1993. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour. <p> In particular, the specification style in this report does not work well with operations whose reactive behaviour is the most important feature; the use of other styles of rely/guarantee specifications for the development of a non-trivial reactive system is illustrated in <ref> [KR93] </ref>. Although rely and guarantee conditions favour local reasoning, this report empha-sises the role of the invariants (data invariant and evolution invariant), which by nature record global information.
Reference: [MC81] <author> Jayadev Misra and K.Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7 </volume> <pages> 417-426, </pages> <year> 1981. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [Mid93] <author> Cornelis Middelburg. </author> <title> Logic and Specification | Extending VDM-SL for Advanced Formal Specifications. </title> <publisher> Chapman and Hall, </publisher> <year> 1993. </year>
Reference-contexts: In fact, even the idea that properties of all computations can be attached to the definition of a state is not new. The state specification modules of <ref> [Mid93] </ref> include a dynamic constraint which is a temporal formula. Interestingly -in the detailed case study of [Mid93]- the temporal formula has precisely the form of an evolution invariant. 5 Writing Specifications Based on lessons learned from the case study, this section presents a few guidelines on writing specifications. <p> In fact, even the idea that properties of all computations can be attached to the definition of a state is not new. The state specification modules of <ref> [Mid93] </ref> include a dynamic constraint which is a temporal formula. Interestingly -in the detailed case study of [Mid93]- the temporal formula has precisely the form of an evolution invariant. 5 Writing Specifications Based on lessons learned from the case study, this section presents a few guidelines on writing specifications. To understand their impact, there is some incentive to present a `bad' specification of ROOT first.
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: operations are purposely postponed to Section 5 but impatient readers can always consult the appendix for an account of all specifications and development steps. 3 Visible Steps The question of granularity arises as soon as interference is discussed; a detailed introduction to this problem with examples can be found in <ref> [MP92] </ref>. In this context, the question amounts to what are the -labelled steps in a computation. This directly affects the interpretation of the guarantee condition of an operation (and of course the rely conditions of others). As discussed in next section, this also affects the interpretation of invariants. <p> These include the initial and the final values of its shared (non-local) variables (relevant for sequential composition) but must also encompass every public intermediate value of its shared variables. Each occurrence of a variable in the code of an operation can indeed be classified as either public or private <ref> [MP92] </ref>. An occurrence of a shared variable is private if the variable cannot be accessed by a concurrently executed operation, e.g. when it appears inside mutually exclusive code sections.
Reference: [MV90] <author> Caroll Morgan and Trevor Vickers. </author> <title> Types and invariants in the refinement calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14 </volume> <pages> 281-304, </pages> <year> 1990. </year>
Reference-contexts: Invariants should be considered as given and available for free use in writing and reasoning about specifications. The same philosophy is adopted in <ref> [MV90] </ref>: the use of invariants in the design should be separate from their ultimate verification. How the latter is carried out is addressed in Section 6. 5.2 Enriched Mode Restrictions Write-mode restrictions on variables can be understood as commitments of the operation: no other variables can be modified.
Reference: [PJ91] <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logic | a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5 </volume> <pages> 27-54, </pages> <year> 1991. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [Sta86] <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. In S.N. </title> <editor> Maheshwari, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
Reference: [Sto91] <author> Ketil Stolen. </author> <title> An attempt to reason about shared-state concurrency in the style of VDM. </title> <editor> In S. Prehn and W.J. Toetenel, editors, VDM'91: </editor> <booktitle> Formal Software Development Methods, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-342. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The necessary background about rely/guarantee specifications is recalled in this report detailed expositions (including sound and complete proof systems) can be found in <ref> [Sto91] </ref>. The new insights here come from an emphasis on methodological issues. Theoretical aspects of rely/guarantee specifications are intentionally omitted in favour of suggestions that improve their practicability in the development of concurrent operations. <p> Predicates that appear in the rely and guarantee conditions of all operations were already emphasised in <ref> [Sto91] </ref> (called there binary invariants). As explained in Section 5, there are advantages in moving them from the specifications of individual operations into the specification of the shared state. <p> The result variables of an operation are implicitly of mode prv wr. The use of ext and ptc mode restrictions was already advocated in <ref> [Sto91] </ref>; the novelty here is the explicit distinction between protected and private variables. Mode restrictions are well illustrated by the decomposition of F-EQUATE 1 in Figure 1 (Section 2) that introduces the specifications F-ROOT 1 and F-TEST-AND-CONNECT 1 . <p> Concurrent execution of that operation not only further complicates the development but also raises expressiveness problems: it seems that the formulation of an adequate evolution invariant requires the use of history determined auxiliary variables. Use of auxiliary variables with rely/guarantee specifications is detailed in <ref> [GNL91, Sto91] </ref>. Auxiliary variables lead to clearer specifications than nested temporal operators, but inappropriate use can lead to cumbersome specifications too.
Reference: [WD88] <author> Jim C.P. Woodcock and B. Dickinson. </author> <title> Using VDM with rely and guarantee conditions. </title> <editor> In R. Bloomfield, L. Marshall, and R. Jones, editors, </editor> <title> VDM '88: The Way Ahead, </title> <booktitle> volume 328 of Lecture Notes in Computer Science, </booktitle> <pages> pages 434-458. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The design of appropriate proof rules for data reification with rely/guarantee conditions is another theoretical aspect that deserves further work. Thanks to the evolution in 21 variant, the problem of the appearance of new rely conditions with data reification <ref> [WD88] </ref> does not occur in this case study but might appear in others.
Reference: [ZdBdR84] <author> Job Zwiers, Arie de Bruin, and Willem-Paul de Roever. </author> <title> A proof system for partial correctness of dynamic networks of processes. </title> <editor> In E. Clarke and D. Kozen, editors, </editor> <booktitle> Logics of Programs, volume 164 of Lecture Notes in Computer Science, </booktitle> <pages> pages 513-527. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <month> 23 </month>
Reference-contexts: Indeed, nothing reasonable can be expected from an operation whose environment modifies the state in an arbitrary way. The use of assumption/commitment specifications in the development of concurrent systems is not restricted to the formalism discussed in this report: other examples are <ref> [AL93, BK85, Col94, JT95, KR93, MC81, PJ91, Sta86, ZdBdR84] </ref>. Some of the methodological issues raised in this report hopefully spread across examples and formalisms but the case study is only representative of one specific class of shared-state operations. In general, operations have both an input/output behaviour and a reactive behaviour.
References-found: 22

