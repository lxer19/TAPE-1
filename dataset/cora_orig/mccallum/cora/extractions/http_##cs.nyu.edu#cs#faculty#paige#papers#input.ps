URL: http://cs.nyu.edu/cs/faculty/paige/papers/input.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Title: Efficient Translation of External Input in a Dynamically Typed Language  
Author: Robert Paige 
Keyword: Keyword Codes: F.3.2, I.1.1, I.1.2 Keywords: Semantics of Programming Languages; Expressions and Their Representation; Algorithms;  
Address: New York University, 251 Mercer St., New York, NY 10012  
Affiliation: Computer Science Department,  
Abstract: New algorithms are given to compile external data in string form into data structures for high level datatypes. Let I be a language of external constants formed from atomic constants and from set, multiset, and tuple constructors. We show how to read an input string C, decide whether it belongs to I, convert it to internal form, and build initial data structures storing the internal value of C in linear worst case time with respect to the number of symbols in C. The algorithm does not require hashing or address arithmetic, but relies only on list processing. A principal subproblem is to detect and remove duplicate elements from set-valued input. To solve this subproblem we extend the technique of multiset discrimination [2, 5] to detect all duplicate elements of a multiset, where these elements may themselves be tuples, multisets, or sets with arbitrary degree of nesting. To handle the case where the elements are multisets, we introduce a new technique called weak sorting, which sorts all of these multisets uniformly according to an arbitrary total order computed by the algorithm. The cost of computing this total order and of sorting all of the multisets is linear in the sum of the number of elements in each of the multisets. Our algorithms are based on a sequential pointer RAM model of computation [4, 7], which accesses and stores data using pointers but disallows address arithmetic (which precludes direct access into arrays). This improves on previous algorithms used to solve the related reading problem in SETL [3, 6]. Those algorithms used hashing even for deeply nested data to detect duplicate values. If we assume that hashing unit-space data takes unit expected time and linear worst case time, then for arbitrary data their algorithm would require linear expected time and quadratic worst case time in the number of symbols in C. Consider an external read operation read v that inputs external data into program variable v. Our framework for understanding what this operation means depends in part on ascribing to v a type t, which represents a set of abstract values val (t). This framework also includes two maps. The first map front_end t : ext (t) fi val (t) is a total, onto, many-to-one map from external representations ext (t) to their abstract values. The second map back_end t : val (t) fi imp (t) is a total one-to-many map from abstract values to their default implementations imp (t). The composition back_end t bfront_end t defines the semantics of reading external data into a variable of type t. We will only consider a limited type system with a single elementary type identifier that represents the set of finite nonempty strings over a fixed finite alphabet S. For any type t there are nonelementary types for finite sets set (t) (i.e., unordered collections of values of type t with no repeated values), finite multisets mset (t) (i.e., unordered collections of values hhhhhhhhhhhhhhh * This research was partially supported by Office of Naval Research Grant N00014-93-1-1036 and Air Force Office of Scientific Research Grant No. AFOSR-91-0308. Part of this research was done while visiting DIKU at the University of Copenhagen. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A., Sethi, R. and Ullman, J., </author> <title> Compilers, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The first stage does input recognition, and generates the abstract syntax tree (abbr. AST). Since the grammar generating the external data language ext (external ) can be easily made to be LL (1), we will implement front_end external using an LL (1) parser <ref> [1] </ref>. We consider an AST that reflects the type and nested structure of the input. Such an AST can be formed from the parse tree by rewriting to remove brackets and to label internal nodes by appropriate tags either set, mset, or tuple.
Reference: 2. <author> Cai, J. and Paige, R., </author> <title> ``Look Ma, No Hashing, And No Arrays Neither",'' </title> <booktitle> in ACM POPL, </booktitle> <pages> pp. 143 - 154, </pages> <month> Jan, </month> <year> 1991. </year>
Reference-contexts: This can be achieved by the list processing implementation of lexical scanning and parsing described in <ref> [2] </ref>. It will be convenient to refer to a node of the AST and its record implementation inter-changably. <p> Our tree-to-dag transformation is based on two algorithmic techniques. The first technique is a generalization of multiset discrimination (i.e. finding duplicate elements in a mul-tiset) described in <ref> [2, 5] </ref>. The extension rests on a surprisingly simple idea. If U is a set of arbitrary values and x and y are pointers to two such values, then equality of deref (x ) and deref (y ) can be decided in unit time by comparing x and y. <p> The solution involves a single linear time scan through the elements of Q. Multiset discrimination of tuples can be solved in much the same way that multiset discrimination of strings was solved in <ref> [2] </ref> (based on the earlier array-based method found in [5]) by repeated application of multiset discrimination of pointers. <p> Both child_pnters and sets y.back for each y -deref (z):zchild_pnters- need to be reinitialized after each of the preceding passes of multiset pointer discrimination. Based on proofs found in <ref> [2, 5] </ref>, we know that the preceding algorithm will dagify the nodes in R if the children of these nodes are already dagified. Analysis also follows from these sources. Let m be the total number of all children of nodes in R.
Reference: 3. <author> Dewar, R., Grand, A., Liu S. C., Schwartz, J. T., and Schonberg, E., </author> <title> ``Program by Refinement as Exemplified by the SETL Representation Sublanguage,'' </title> <journal> TOPLAS, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 27-49, </pages> <month> July, </month> <year> 1979. </year>
Reference: 4. <author> Knuth, D. E., </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol 1: </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference: 5. <author> Paige, R and Tarjan, R., </author> <title> ``Three Efficient Algorithms Based on Partition Refinement,'' </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 16, no. 6, </volume> <month> Dec., </month> <year> 1987. </year>
Reference-contexts: Our tree-to-dag transformation is based on two algorithmic techniques. The first technique is a generalization of multiset discrimination (i.e. finding duplicate elements in a mul-tiset) described in <ref> [2, 5] </ref>. The extension rests on a surprisingly simple idea. If U is a set of arbitrary values and x and y are pointers to two such values, then equality of deref (x ) and deref (y ) can be decided in unit time by comparing x and y. <p> The solution involves a single linear time scan through the elements of Q. Multiset discrimination of tuples can be solved in much the same way that multiset discrimination of strings was solved in [2] (based on the earlier array-based method found in <ref> [5] </ref>) by repeated application of multiset discrimination of pointers. <p> Both child_pnters and sets y.back for each y -deref (z):zchild_pnters- need to be reinitialized after each of the preceding passes of multiset pointer discrimination. Based on proofs found in <ref> [2, 5] </ref>, we know that the preceding algorithm will dagify the nodes in R if the children of these nodes are already dagified. Analysis also follows from these sources. Let m be the total number of all children of nodes in R.
Reference: 6. <author> Schwartz, J., Dewar, R., Dubinsky, D., and Schonberg, E., </author> <title> Programming with Sets: An introduction to SETL, </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: 7. <author> Tarjan, R., </author> <title> ``A Class Of Algorithms Which Require Nonlinear Time To Maintain Disjoint Sets,'' </title> <journal> J. Comput. Sys. Sci., </journal> <volume> vol. 18, </volume> <pages> pp. 110-127, </pages> <year> 1979. </year>
Reference: 8. <author> Tarjan, R., </author> <title> Data Structures and Network Algorithms, </title> <publisher> SIAM, </publisher> <year> 1984. </year> - -- 
Reference-contexts: Here, U can be stored in any data structure that supports pointer access to its elements. If U is an exogenous set <ref> [8] </ref> of pointers to arbitrary values, where each distinct pointer references a distinct value, then comparing pointers x and y decides equality of pointers deref (x ) and deref (y ), which in turn decides equality of values deref (deref (x )) and deref (deref (y )). - -- We give
References-found: 8

