URL: http://www.cs.washington.edu/homes/alon/site/files/edbt96.ps
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib6.html
Root-URL: 
Email: levy@research.att.com  mumick@research.att.com  
Phone: 2  
Title: Reasoning with Aggregation Constraints  
Author: Alon Y. Levy and Inderpal Singh Mumick 
Address: 600 Mountain Avenue Murray Hill, NJ 07974, USA.  600 Mountain Avenue Murray Hill, NJ 07974, USA.  
Affiliation: 1 AT&T Bell Laboratories  AT&T Bell Laboratories  
Abstract: Aggregation queries are becoming increasingly common as databases continue to grow and provide parallel execution engines to enable complex queries over larger and larger amounts of data. Consequently, optimization of aggregation queries is becoming very important. In this paper we present a framework for reasoning with constraints arising from the use of aggregations. The framework introduces a constraint language, three types of inference rules to derive constraints that must hold given a set of aggregations and constraints in the query, and a sound and tractable inference procedure. The constraint language and inference procedure can be used by any system that deals with aggregations be it constraint programming, databases, or global information systems. However, the prime application of aggregation reasoning is in database query optimizers to optimize SQL (or object-SQL) queries with grouping and aggregation. Our framework allows aggregation reasoning to be incorporated into an optimizer in a modular fashion, and we illustrate this through a detailed example.
Abstract-found: 1
Intro-found: 1
Reference: [BK95] <author> A. Brodsky and Y. Kornatzky. </author> <title> The lyric language: Querying constraint objects. </title> <booktitle> In Proceedings of ACM SIGMOD 1995 International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference-contexts: A crucial observation is that the functional terms over which we need to reason is linear in the size of the query. Beside query optimization, their are several other domains where reasoning with aggregation can be used logic programming, constraint programming, constraint databases <ref> [KKR90, BK95] </ref>, and global information systems [LSK95]. As future work, we would like to permit an aggregation function to be applied to more than one aggregated column, e.g. MAX (Y 1 + Y 2 ).
Reference: [CS94] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Including groupby in query optimization. </title> <booktitle> In Proceedings of VLDB-94, </booktitle> <pages> pages 354-366. </pages>
Reference-contexts: A different type of optimization involving aggregation was described by Chaudhuri and Shim <ref> [CS94] </ref> and Yan and Larson [YL95]. The main observation in that work is that often it is possible to perform a grouping operation before a join or selection operation in the same query block. Doing so may result in more efficient query plans.
Reference: [DJLS95] <author> Shaul Dar, H. V. Jagadish, Alon Y. Levy and Divesh Srivastava. </author> <title> Answering SQL Queries with Aggregation Using Materialized Views. </title> <booktitle> Working notes of the Post-ILPS95 Workshop on Constraints, Databases and Logic Programming. </booktitle>
Reference-contexts: The problem of optimizing queries with aggregation by exploiting materialized views is considered in <ref> [DJLS95, GHQ95] </ref>. 7 Conclusions We have developed a framework in which a system can do reasoning with aggregation constraints. We identified a constraint language that lets us reason with aggregation.
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 197-208, </pages> <address> Brighton, England, </address> <month> September 1-4 </month> <year> 1987. </year>
Reference-contexts: They do not give any rules to infer aggregation predicates between different types of aggregations or between views and relations. There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) <ref> [Kim82, GW87, Day87, Mur92] </ref>, with perhaps a magic-sets transformation to follow [MFPR90, MP94]. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95].
Reference: [GM93] <author> Goetz Graefe and William J. McKenna. </author> <title> The volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ninth IEEE International Conference on Data Engineering, </booktitle> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: involving functional terms and predi cates that are guaranteed to be true. 6 Related Work The types of inferences we describe in this paper can be incorporated into several existing query rewrite techniques (e.g., predicate pushdown [Ull89], predicate move-around [LMS94]) and into rule based query optimizers [PHH92] and optimizer generators <ref> [GM93] </ref> fairly easily and modularly. The predicate move-around algorithm [LMS94] provides a framework in which predicates are moved in a query graph, and we showed, in Section 5.2 how various aggregation inferences can be made within this framework.
Reference: [GW87] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of nested SQL queries revisited. </title> <booktitle> In Proceedings of ACM SIGMOD 1987 International Conference on Management of Data, </booktitle> <pages> pages 23-33, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: They do not give any rules to infer aggregation predicates between different types of aggregations or between views and relations. There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) <ref> [Kim82, GW87, Day87, Mur92] </ref>, with perhaps a magic-sets transformation to follow [MFPR90, MP94]. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95].
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan and D. Quass. </author> <title> Generalized Projections: A Powerful Approach to Aggregation. </title> <booktitle> In Proceedings of VLDB-95. </booktitle>
Reference-contexts: The constraint language and the reasoning framework in [RSSS94] was not expressive enough to represent the types of predicates needed for the query optimization shown in Sections 2 and 5. Gupta et al. <ref> [GHQ95] </ref> use a generalized projection operator to show that aggregation is similar to duplicate elimination in SQL, and that optimizations for the SQL distinct operator can be applied to aggregations. They do not give any rules to infer aggregation predicates between different types of aggregations or between views and relations. <p> The problem of optimizing queries with aggregation by exploiting materialized views is considered in <ref> [DJLS95, GHQ95] </ref>. 7 Conclusions We have developed a framework in which a system can do reasoning with aggregation constraints. We identified a constraint language that lets us reason with aggregation.
Reference: [Hel94] <author> Joseph M. Hellerstein. </author> <title> Practical predicate placement. </title> <booktitle> In Proceedings of SIGMOD-94. </booktitle>
Reference-contexts: Such a predicate would then be classified as an expensive predicate, and it may be better not to push it down from a view into the referenced relations <ref> [HS93, Hel94] </ref>. 4 Making Inferences with Aggregation Constraints Recall that the inference problem in our constraint language is to decide whether a constraint c is entailed by a conjunction (possibly empty) of constraints c 1 ^ : : : ^ c n .
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of ACM SIG MOD 1993 International Conference on Management of Data, pages 267--276, </booktitle> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference-contexts: Such a predicate would then be classified as an expensive predicate, and it may be better not to push it down from a view into the referenced relations <ref> [HS93, Hel94] </ref>. 4 Making Inferences with Aggregation Constraints Recall that the inference problem in our constraint language is to decide whether a constraint c is entailed by a conjunction (possibly empty) of constraints c 1 ^ : : : ^ c n .
Reference: [Kim82] <author> Won Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3), </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: They do not give any rules to infer aggregation predicates between different types of aggregations or between views and relations. There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) <ref> [Kim82, GW87, Day87, Mur92] </ref>, with perhaps a magic-sets transformation to follow [MFPR90, MP94]. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95].
Reference: [KKR90] <author> Paris C. Kanellakis, Gabriel M. Kuper, and Peter Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 299-313, </pages> <address> Nashville, TN, </address> <month> April 2-4 </month> <year> 1990. </year>
Reference-contexts: A crucial observation is that the functional terms over which we need to reason is linear in the size of the query. Beside query optimization, their are several other domains where reasoning with aggregation can be used logic programming, constraint programming, constraint databases <ref> [KKR90, BK95] </ref>, and global information systems [LSK95]. As future work, we would like to permit an aggregation function to be applied to more than one aggregated column, e.g. MAX (Y 1 + Y 2 ).
Reference: [LMS94] <author> Alon Levy, Inderpal Singh Mumick, and Yehoshua Sagiv. </author> <title> Query optimization by predicate movearound. </title> <booktitle> In Proceedings of VLDB-94, </booktitle> <pages> pages 96-107. </pages>
Reference-contexts: Predicate pushdown [Ull89] is a common and important optimization technique for pushing predicates down a query graph, into query blocks that are computed earlier during evaluation. Recently we described the predicate move-around algorithm <ref> [LMS94] </ref> that generalizes predicate pushdown. The key idea in predicate move-around is that the step of pushing predicates down the query graph should be preceded by a step in which predicates are pulled up the query graph. <p> While making such inferences for views not involving aggregation is a well understood problem (e.g., see [Ull89]), the problem of making such inferences in the presence of aggregation is a largely open problem that has been considered only in simple cases <ref> [LMS94, RSSS94] </ref>. As a result, these techniques are unable to push predicates effectively in queries involving aggregation. In this paper we present a general and principled approach to inferring predicates when views contain aggregation. <p> Note that even though we have pushed predicates into the definitions of the views, in this example they still need to be applied in the query block (there are cases (see <ref> [LMS94] </ref>) in which applying the predicates earlier in the evaluation guarantees that they do not need to be applied later on). <p> These three kinds of inference fit naturally into query optimizers, such as the Starburst optimizer [PHH92] or the predicate move-around algorithm <ref> [LMS94] </ref>. Relation-to-view inferences are made in the predicate pullup phase of predicate move-around, and view-to-relation inferences are made in the pushdown phase. The intra-relation inferences are made in both phases, while taking the deductive closure of the predicates in a node of the query graph. <p> As a basis for reasoning with aggregation constraints we need to define a constraint language in which we represent aggregation constraints and make inferences about them. Our language extends constraint languages used to reason about constraints that do not involve aggregation. In that case (e.g., as described in <ref> [Ull89, LS92, LMS94] </ref>), our constraints were of the form: (8 t 2 R) t:A 1 t:A 2 ; where R is some relation with attributes A 1 and A 2 , t is a tuple variable quantified over all the tuples in R, and is one of the operators f; &lt;; <p> To describe the use of aggregation reasoning in optimization, we will represent an SQL query using a query graph <ref> [MFPR90, PHH92, MP94, LMS94] </ref>. A query graph is a pictorial representation of the query. For example, the marketing query Q from Section 2 is represented by the query graph of Figure 1. The graph has Fig. 1. The query graph for the marketing query of Section 2. six nodes. <p> The exact place where the above inferences are made depends on the optimization framework within which the aggregation reasoning is incorporated. As an example, the predicate movearound <ref> [LMS94] </ref> technique works in four phases, and would make the following inferences in each: - (Initialization Phase): Initialize predicates into each box. Infer c1 c4, c8, and c11 c12. - (Pull-up phase): Infer predicates in each box and pull them up into the parent box. <p> Infer c9 c10, c13 c15. - (Cleanup phase): Remove predicates involving functional terms and predi cates that are guaranteed to be true. 6 Related Work The types of inferences we describe in this paper can be incorporated into several existing query rewrite techniques (e.g., predicate pushdown [Ull89], predicate move-around <ref> [LMS94] </ref>) and into rule based query optimizers [PHH92] and optimizer generators [GM93] fairly easily and modularly. The predicate move-around algorithm [LMS94] provides a framework in which predicates are moved in a query graph, and we showed, in Section 5.2 how various aggregation inferences can be made within this framework. <p> to be true. 6 Related Work The types of inferences we describe in this paper can be incorporated into several existing query rewrite techniques (e.g., predicate pushdown [Ull89], predicate move-around <ref> [LMS94] </ref>) and into rule based query optimizers [PHH92] and optimizer generators [GM93] fairly easily and modularly. The predicate move-around algorithm [LMS94] provides a framework in which predicates are moved in a query graph, and we showed, in Section 5.2 how various aggregation inferences can be made within this framework. Some simple versions of the inferences described in Sections 4.2 and 4.3 were mentioned in [LMS94] as a way of showing the <p> The predicate move-around algorithm <ref> [LMS94] </ref> provides a framework in which predicates are moved in a query graph, and we showed, in Section 5.2 how various aggregation inferences can be made within this framework. Some simple versions of the inferences described in Sections 4.2 and 4.3 were mentioned in [LMS94] as a way of showing the generality of the predicate move-around framework. Functional terms of a different type than the ones in this paper were also used in [LMS94] to reason with functional dependencies. <p> Some simple versions of the inferences described in Sections 4.2 and 4.3 were mentioned in <ref> [LMS94] </ref> as a way of showing the generality of the predicate move-around framework. Functional terms of a different type than the ones in this paper were also used in [LMS94] to reason with functional dependencies. Ross et al. [RSSS94] considered a subset of our problem, namely a subset of the intra-relation inferences, when different aggregation functions are performed on the same relation, attribute and grouping columns (Section 4.2).
Reference: [LS92] <author> Alon Levy and Yehoshua Sagiv. </author> <title> Constraints and redundancy in datalog. </title> <booktitle> In Proceedings of the Eleventh Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 67-80, </pages> <address> San Diego, CA, </address> <month> June 2-4 </month> <year> 1992. </year>
Reference-contexts: As a basis for reasoning with aggregation constraints we need to define a constraint language in which we represent aggregation constraints and make inferences about them. Our language extends constraint languages used to reason about constraints that do not involve aggregation. In that case (e.g., as described in <ref> [Ull89, LS92, LMS94] </ref>), our constraints were of the form: (8 t 2 R) t:A 1 t:A 2 ; where R is some relation with attributes A 1 and A 2 , t is a tuple variable quantified over all the tuples in R, and is one of the operators f; &lt;;
Reference: [LSK95] <author> Alon Y. Levy, Divesh Srivastava, and Thomas Kirk. </author> <title> Data model and query evaluation in global information systems. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 5(2), </volume> <month> September, </month> <year> 1995. </year>
Reference-contexts: Finally, we describe algorithms for performing the three kinds of inferences. Reasoning with aggregation constraints is important not only in query optimization, but also in logic programming, constraint programming, constraint databases, and global information systems <ref> [LSK95] </ref>. For example, in global information systems, the techniques for pushing constraints down a query graph are used in order to determine which of the many available external databases is relevant to a given query. <p> A crucial observation is that the functional terms over which we need to reason is linear in the size of the query. Beside query optimization, their are several other domains where reasoning with aggregation can be used logic programming, constraint programming, constraint databases [KKR90, BK95], and global information systems <ref> [LSK95] </ref>. As future work, we would like to permit an aggregation function to be applied to more than one aggregated column, e.g. MAX (Y 1 + Y 2 ).
Reference: [MFPR90] <author> Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Magic is relevant. </title> <booktitle> In Proceedings of ACM SIGMOD 1990 International Conference on Management of Data, </booktitle> <pages> pages 247-258, </pages> <address> At-lantic City, NJ, </address> <month> May 23-25 </month> <year> 1990. </year>
Reference-contexts: To describe the use of aggregation reasoning in optimization, we will represent an SQL query using a query graph <ref> [MFPR90, PHH92, MP94, LMS94] </ref>. A query graph is a pictorial representation of the query. For example, the marketing query Q from Section 2 is represented by the query graph of Figure 1. The graph has Fig. 1. The query graph for the marketing query of Section 2. six nodes. <p> There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) [Kim82, GW87, Day87, Mur92], with perhaps a magic-sets transformation to follow <ref> [MFPR90, MP94] </ref>. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95]. The main observation in that work is that often it is possible to perform a grouping operation before a join or selection operation in the same query block.
Reference: [MP94] <author> Inderpal Singh Mumick and Hamid Pirahesh. </author> <title> Implementation of magic in starburst. </title> <booktitle> In Proceedings of SIGMOD-94. </booktitle>
Reference-contexts: To describe the use of aggregation reasoning in optimization, we will represent an SQL query using a query graph <ref> [MFPR90, PHH92, MP94, LMS94] </ref>. A query graph is a pictorial representation of the query. For example, the marketing query Q from Section 2 is represented by the query graph of Figure 1. The graph has Fig. 1. The query graph for the marketing query of Section 2. six nodes. <p> There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) [Kim82, GW87, Day87, Mur92], with perhaps a magic-sets transformation to follow <ref> [MFPR90, MP94] </ref>. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95]. The main observation in that work is that often it is possible to perform a grouping operation before a join or selection operation in the same query block.
Reference: [MS95] <author> Inderpal Singh Mumick and Oded Shmueli. </author> <title> How expressive is stratified aggregation. </title> <note> To Appear in Annals of Mathematics and Artificial Intelligence, </note> <year> 1995. </year>
Reference-contexts: We have several more rules that are similar or a special case of the rules presented here. However, even with all these rules, the inference procedure is not complete. In fact, it follows from <ref> [vdM92, MS95] </ref> that the satisfiability problem for queries with aggregation is undecidable. Thus, there cannot exist a complete inference procedure for aggregation constraints.
Reference: [Mur92] <author> M. Muralikrishna. </author> <title> Improved unnesting algorithms for join aggregate SQL queries. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 91-102, </pages> <address> Vancouver, Canada, </address> <month> August 23-27 </month> <year> 1992. </year>
Reference-contexts: They do not give any rules to infer aggregation predicates between different types of aggregations or between views and relations. There has been a lot of work on optimizing queries with aggregation in correlated subqueries by way of decorrelation (converting the subqueries into views) <ref> [Kim82, GW87, Day87, Mur92] </ref>, with perhaps a magic-sets transformation to follow [MFPR90, MP94]. A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson [YL95].
Reference: [PHH92] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query rewrite optimization in Starburst. </title> <booktitle> In Proceedings of ACM SIG-MOD 1992 International Conference on Management of Data, </booktitle> <pages> pages 39-48, </pages> <address> San Diego, CA, </address> <month> June 2-5 </month> <year> 1992. </year>
Reference-contexts: These three kinds of inference fit naturally into query optimizers, such as the Starburst optimizer <ref> [PHH92] </ref> or the predicate move-around algorithm [LMS94]. Relation-to-view inferences are made in the predicate pullup phase of predicate move-around, and view-to-relation inferences are made in the pushdown phase. <p> To describe the use of aggregation reasoning in optimization, we will represent an SQL query using a query graph <ref> [MFPR90, PHH92, MP94, LMS94] </ref>. A query graph is a pictorial representation of the query. For example, the marketing query Q from Section 2 is represented by the query graph of Figure 1. The graph has Fig. 1. The query graph for the marketing query of Section 2. six nodes. <p> (Cleanup phase): Remove predicates involving functional terms and predi cates that are guaranteed to be true. 6 Related Work The types of inferences we describe in this paper can be incorporated into several existing query rewrite techniques (e.g., predicate pushdown [Ull89], predicate move-around [LMS94]) and into rule based query optimizers <ref> [PHH92] </ref> and optimizer generators [GM93] fairly easily and modularly. The predicate move-around algorithm [LMS94] provides a framework in which predicates are moved in a query graph, and we showed, in Section 5.2 how various aggregation inferences can be made within this framework.
Reference: [RSSS94] <author> Kenneth Ross, Divesh Srivastava, Peter Stuckey, and S. Sudarshan. </author> <title> Foundations of aggregation constraints. </title> <editor> In Alan Borning, editor, </editor> <booktitle> Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year> <note> LNCS 874. </note>
Reference-contexts: While making such inferences for views not involving aggregation is a well understood problem (e.g., see [Ull89]), the problem of making such inferences in the presence of aggregation is a largely open problem that has been considered only in simple cases <ref> [LMS94, RSSS94] </ref>. As a result, these techniques are unable to push predicates effectively in queries involving aggregation. In this paper we present a general and principled approach to inferring predicates when views contain aggregation. <p> In addition, we can deduce special relationships when the aggregated column is a member of the grouping list. Changing the Aggregation function: Ross et al. <ref> [RSSS94] </ref> present a complete set of rules for the case that only the aggregation function changes. For example, the following two rules hold: (L18): (8x)f fR; X;MAX;Y g (x) f fR; X;MIN;Y g (x). i.e., the maximum is greater than either the minimum or the average. <p> Functional terms of a different type than the ones in this paper were also used in [LMS94] to reason with functional dependencies. Ross et al. <ref> [RSSS94] </ref> considered a subset of our problem, namely a subset of the intra-relation inferences, when different aggregation functions are performed on the same relation, attribute and grouping columns (Section 4.2). <p> They considered view-to-relation inferences (Section 4.3), but only when there is a single aggregation function in a grouping operation. The constraint language and the reasoning framework in <ref> [RSSS94] </ref> was not expressive enough to represent the types of predicates needed for the query optimization shown in Sections 2 and 5. <p> MAX (Y 1 + Y 2 ). Though the general inference procedure on aggregation constraints is undecidable, it may be possible to identify fragments that are decidable, as done in <ref> [RSSS94] </ref> for the subcase considered there. Finally, this paper focussed mostly on the logic behind the inference rules. We plan to further explore the problem of controlling the application of the inference rules (as in Section 5).
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes 1 and 2. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: An important method of optimization is to rewrite the query so that predicates can be applied as early as possible. Predicate pushdown <ref> [Ull89] </ref> is a common and important optimization technique for pushing predicates down a query graph, into query blocks that are computed earlier during evaluation. Recently we described the predicate move-around algorithm [LMS94] that generalizes predicate pushdown. <p> While making such inferences for views not involving aggregation is a well understood problem (e.g., see <ref> [Ull89] </ref>), the problem of making such inferences in the presence of aggregation is a largely open problem that has been considered only in simple cases [LMS94, RSSS94]. As a result, these techniques are unable to push predicates effectively in queries involving aggregation. <p> As a basis for reasoning with aggregation constraints we need to define a constraint language in which we represent aggregation constraints and make inferences about them. Our language extends constraint languages used to reason about constraints that do not involve aggregation. In that case (e.g., as described in <ref> [Ull89, LS92, LMS94] </ref>), our constraints were of the form: (8 t 2 R) t:A 1 t:A 2 ; where R is some relation with attributes A 1 and A 2 , t is a tuple variable quantified over all the tuples in R, and is one of the operators f; &lt;; <p> Infer c9 c10, c13 c15. - (Cleanup phase): Remove predicates involving functional terms and predi cates that are guaranteed to be true. 6 Related Work The types of inferences we describe in this paper can be incorporated into several existing query rewrite techniques (e.g., predicate pushdown <ref> [Ull89] </ref>, predicate move-around [LMS94]) and into rule based query optimizers [PHH92] and optimizer generators [GM93] fairly easily and modularly.
Reference: [vdM92] <author> Ronald van der Meyden. </author> <title> The Complexity of Querying Indefinite Information: Defined Relations, Recursion, and Linear Order. </title> <type> PhD thesis, </type> <institution> Rutgers, The State University of New Jersey, </institution> <address> New Brunswick, NJ, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: We have several more rules that are similar or a special case of the rules presented here. However, even with all these rules, the inference procedure is not complete. In fact, it follows from <ref> [vdM92, MS95] </ref> that the satisfiability problem for queries with aggregation is undecidable. Thus, there cannot exist a complete inference procedure for aggregation constraints.
Reference: [YL95] <author> Weipeng P. Yan and Per -Ake Larson. </author> <title> Eager Aggregation and Lazy Aggregation. In Proceedings of VLDB-95. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: A different type of optimization involving aggregation was described by Chaudhuri and Shim [CS94] and Yan and Larson <ref> [YL95] </ref>. The main observation in that work is that often it is possible to perform a grouping operation before a join or selection operation in the same query block. Doing so may result in more efficient query plans.
References-found: 23

