URL: http://www.cs.unc.edu/~anderson/papers/podc96.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Real-Time Object Sharing with Minimal System Support (Extended Abstract)  
Author: Srikanth Ramamurthy, Mark Moir, and James H. Anderson 
Address: Chapel Hill  
Affiliation: Department of Computer Science, University of North Carolina at  
Abstract: We show that, for a large class of hard real-time systems, any object with consensus number P in Herlihy's wait-free hierarchy is universal for any number of tasks executing on P processors. These results exploit characteristics of priority-based schedulers common to most hard real-time systems. An important special case of this result is that, for hard real-time applications on uniprocessors, reads and writes are universal. Thus, Herlihy's hierarchy collapses for such applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and G. Taubenfeld, </author> <title> "Results about Fast Mutual Exclusion", </title> <booktitle> Proceedings of the 13th IEEE Real-Time Systems Symposium, </booktitle> <year> 1992, </year> <pages> pp. 12-21. </pages>
Reference-contexts: Thus, for P &gt; 2, primitives with unbounded consensus number are still required in practice. This requirement can be obviated by adopting a timing model that provides a bound on the execution time of any statement. This conclusion follows from work of Alur, Attiya, and Taubenfeld <ref> [1, 3] </ref>, who have shown that consensus objects (and hence any object) can be implemented in a wait-free manner using only reads and writes in such a model. However, as mentioned previously, most practical wait-free and lock-free object implementations are based on universal primitives, not consensus objects. <p> var Buf : array [ 1::2N 1 ] of 1::N ; Val : array [ 1::N ] of valtype; Rv : array [ 1::N ] of valtype [ ?; Pm : array [ 1::N ] of boolean; V : valtype initially (8k :: Buf [k] = 1) ^ V al <ref> [1] </ref> = initial value private var i : integer; w, maj : 1::N ; current : valtype; count : array [1::N ] of 0::2N 1 procedure Read () returns valtype 1 : Pm [ p ], count := false, (0; : : : ; 0); for i := 1 to 2N <p> The following definition states that the current value CV of the implemented shared variable is determined by the task identifier that is stored in a majority of the locations Buf <ref> [1] </ref> through Buf [2N 1]. (It can be shown that such a majority always exists and is unique.) CV j (Val [p] :: p is a majority in Buf ) procedure C&S (old, new) returns boolean 6 : Pm [ p ] := false; 7 : Rv [ p ], count <p> We now show that, by making certain timing assumptions, T&S and C&S can be efficiently implemented in such systems. While these results have been previously established in principle <ref> [1, 2, 3] </ref>, our implementations are significantly more efficient and are better suited to the requirements of real-time systems. Our delay-based implementation of T&S and Reset, 4 which is based on a delay-based mutual exclusion algorithm due to Fischer [9], is given in Figure 7.
Reference: [2] <author> R. Alur and G. Taubenfeld, </author> <title> "How to Share an Object: A Fast Timing-Based Solution", </title> <booktitle> Proceedings of the 5th IEEE Symposium on Parallel and Distributed Processing , 1993, </booktitle> <pages> pp. 470-477. </pages>
Reference-contexts: We have chosen to avoid such assumptions where possible for several reasons. First, accurately estimating time bounds for statements can be difficult. Sec 2 A wait-free mutual exclusion algorithm is presented in <ref> [2] </ref> that would also seemingly imply this result. However, this algorithm is susceptible to priority inversion in systems that are multiprogrammed, and only guarantees that each task "eventually" reaches its critical section. <p> We now show that, by making certain timing assumptions, T&S and C&S can be efficiently implemented in such systems. While these results have been previously established in principle <ref> [1, 2, 3] </ref>, our implementations are significantly more efficient and are better suited to the requirements of real-time systems. Our delay-based implementation of T&S and Reset, 4 which is based on a delay-based mutual exclusion algorithm due to Fischer [9], is given in Figure 7. <p> Our delay-based implementation of T&S and Reset, 4 which is based on a delay-based mutual exclusion algorithm due to Fischer [9], is given in Figure 7. A delay-based implementation of T&S and Reset has been presented previously by Alur and Taubenfeld <ref> [2] </ref>. <p> In other words, low time complexity in the absence of contention is of little benefit if time complexity under contention is high. The running time of the T&S and Reset implementation presented in <ref> [2] </ref> is bounded by 17, where is an upper bound on the time taken by any task to take a step. In comparison, the worst-case running time of our implementation is 5 (assuming each line in Figure 7 to be a step).
Reference: [3] <author> R. Alur, H. Attiya, and G. Taubenfeld, </author> <title> "Time-Adaptive Algorithms for Synchronization", </title> <booktitle> Proceedings of the 26th Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 800-809. </pages>
Reference-contexts: Thus, for P &gt; 2, primitives with unbounded consensus number are still required in practice. This requirement can be obviated by adopting a timing model that provides a bound on the execution time of any statement. This conclusion follows from work of Alur, Attiya, and Taubenfeld <ref> [1, 3] </ref>, who have shown that consensus objects (and hence any object) can be implemented in a wait-free manner using only reads and writes in such a model. However, as mentioned previously, most practical wait-free and lock-free object implementations are based on universal primitives, not consensus objects. <p> We now show that, by making certain timing assumptions, T&S and C&S can be efficiently implemented in such systems. While these results have been previously established in principle <ref> [1, 2, 3] </ref>, our implementations are significantly more efficient and are better suited to the requirements of real-time systems. Our delay-based implementation of T&S and Reset, 4 which is based on a delay-based mutual exclusion algorithm due to Fischer [9], is given in Figure 7.
Reference: [4] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Multi-Object Operations", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing , 1995, </booktitle> <pages> pp. 184-193. </pages>
Reference-contexts: We show that such primitives can be implemented efficiently on real-time uniprocessors by considering implementations of C&S; using C&S, LL/SC can be implemented in constant time <ref> [4] </ref>. We give two N -task implementations of C&S. The first uses only reads and writes, and has O (N ) space and time complexity. The second is based upon a memory-to-memory move instruction (Move) and has O (1) time complexity and O (N ) space complexity. <p> More practical wait-free and lock-free implementations are based on primitives such as C&S and LL/SC. To enable such implementations to be used in real-time uniprocessor systems, we present two implementations of Read and C&S. (LL/SC can be implemented using Read and C&S in constant time <ref> [4] </ref>.) These implementations use Read/Write and Move, respectively.
Reference: [5] <author> J. Anderson, S. Ramamurthy, and K. Jeffay, </author> <title> "Real-Time Computing with Lock-Free Shared Objects", </title> <booktitle> Proceedings of the 16th IEEE Real-Time Systems Symposium, </booktitle> <year> 1995, </year> <pages> pp. 28-37. </pages>
Reference-contexts: On uniprocessors, Anderson, Ramamurthy, and Jeffay have shown that such overhead can be avoided altogether by using lock-free object implementations, rather than wait-free ones <ref> [5] </ref>. On the surface, it is not immediately apparent that lock-free shared objects can be employed if tasks must adhere to strict timing constraints. <p> In particular, lock-free implementations permit concurrent operations to interfere with each other, and repeated interferences can cause a given operation to take an arbitrarily long time to complete. The main contribution of <ref> [5] </ref> is to show that such interferences can be bounded on uniprocessors by judicious scheduling.
Reference: [6] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: The fact that many published wait-free and lock-free object implementations are based on strong synchronization primitives is no accident. Herlihy has shown that such strong primitives are, in general, necessary for these implementations <ref> [6] </ref>. Herlihy's results are based upon a categorization of synchronization objects by "consensus number". An object has consensus number N if it can be used to solve N -process consensus, but not (N + 1)-process consensus, in a wait-free (or lock-free) manner. <p> The results mentioned above are obtained by showing how to solve wait-free consensus within our real-time task model. Although consensus protocols can be used directly to implement wait-free and lock-free objects <ref> [6, 8] </ref>, implementations of practical interest are usually based on universal primitives such as C&S or LL/SC. We show that such primitives can be implemented efficiently on real-time uniprocessors by considering implementations of C&S; using C&S, LL/SC can be implemented in constant time [4]. <p> Using consensus objects, any shared object can be implemented in a wait-free manner <ref> [6, 8] </ref>. However, such implementations usually entail high overhead. More practical wait-free and lock-free implementations are based on primitives such as C&S and LL/SC. <p> Thus, on most multiprocessing systems with three or more processors that do not provide universal primitives, Her-lihy's results about fully-asynchronous systems imply that general object constructions are not possible <ref> [6] </ref>. We now show that, by making certain timing assumptions, T&S and C&S can be efficiently implemented in such systems. While these results have been previously established in principle [1, 2, 3], our implementations are significantly more efficient and are better suited to the requirements of real-time systems.
Reference: [7] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky, </author> <title> "Fixed Priority Scheduling of Periodic Tasks with Varying Execution Priority", </title> <booktitle> Proceedings of the 12th IEEE Real-Time Systems Symposium, </booktitle> <year> 1991, </year> <pages> pp. 116-128. </pages>
Reference-contexts: Requirement (ii) also holds for variations of RM, DM, and EDF scheduling in which tasks are broken into phases that are allowed to have distinct priorities <ref> [7] </ref>. The only common scheduling policy that we know of that violates requirement (ii) is least-laxity-first (LLF) scheduling [12]. Under LLF scheduling, the priority of a task invocation can change during its execution. Observe that requirements (i) and (ii) expressly preclude the use of locking within a processor.
Reference: [8] <author> P. Jayanti and S. Toueg, </author> <title> "Some Results on the Impossibility, Universality, and Decidability of Consensus", </title> <booktitle> Proceedings of the 6th International Workshop on Distributed Algorithms, </booktitle> <publisher> Springer-Verlag, </publisher> <month> Nov. </month> <year> 1992, </year> <pages> pp. 69-84. </pages>
Reference-contexts: The results mentioned above are obtained by showing how to solve wait-free consensus within our real-time task model. Although consensus protocols can be used directly to implement wait-free and lock-free objects <ref> [6, 8] </ref>, implementations of practical interest are usually based on universal primitives such as C&S or LL/SC. We show that such primitives can be implemented efficiently on real-time uniprocessors by considering implementations of C&S; using C&S, LL/SC can be implemented in constant time [4]. <p> Using consensus objects, any shared object can be implemented in a wait-free manner <ref> [6, 8] </ref>. However, such implementations usually entail high overhead. More practical wait-free and lock-free implementations are based on primitives such as C&S and LL/SC. <p> Results of Jayanti and Toueg imply that, given universal consensus objects, C&S can be implemented with time complexity O (N 2 ) and space complexity O (N 3 ) <ref> [8] </ref>. Their construction uses O (N 3 ) consensus objects, and performs at most O (N ) consensus object accesses per operation. Thus, Theorem 4 and the results of [8] yield the following corollary. <p> universal consensus objects, C&S can be implemented with time complexity O (N 2 ) and space complexity O (N 3 ) <ref> [8] </ref>. Their construction uses O (N 3 ) consensus objects, and performs at most O (N ) consensus object accesses per operation. Thus, Theorem 4 and the results of [8] yield the following corollary.
Reference: [9] <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February, </month> <year> 1987, </year> <pages> pp. 1-11. </pages>
Reference-contexts: While these results have been previously established in principle [1, 2, 3], our implementations are significantly more efficient and are better suited to the requirements of real-time systems. Our delay-based implementation of T&S and Reset, 4 which is based on a delay-based mutual exclusion algorithm due to Fischer <ref> [9] </ref>, is given in Figure 7. A delay-based implementation of T&S and Reset has been presented previously by Alur and Taubenfeld [2].
Reference: [10] <author> J.Y.T. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks", </title> <journal> Performance Evaluation, </journal> <volume> Vol. 2, No. 4, </volume> <year> 1982, </year> <pages> pp. 237-250. </pages>
Reference-contexts: However, we do relax this assumption by allowing short nonpreemptable code fragments when considering object implementations for multiprocessors. Requirement (i) is fundamental to all priority-driven scheduling policies. Requirement (ii) holds for most common policies, including rate-monotonic (RM) [11], deadline-monotonic (DM) <ref> [10] </ref>, and earliest-deadline-first (EDF) [11] scheduling. Under RM and DM (a) operations in a asynchronous system. Operations may overlap arbitrarily. (b) Interleaved operations in a uniprocessor real-time system. Two operations overlap only if one is contained within the other. scheduling, task priorities are static, i.e., do not change over time.
Reference: [11] <author> C. Liu and J. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment", </title> <journal> Journal of the ACM , Vol. </journal> <volume> 30, No. 1, </volume> <month> Jan. </month> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference-contexts: However, we do relax this assumption by allowing short nonpreemptable code fragments when considering object implementations for multiprocessors. Requirement (i) is fundamental to all priority-driven scheduling policies. Requirement (ii) holds for most common policies, including rate-monotonic (RM) <ref> [11] </ref>, deadline-monotonic (DM) [10], and earliest-deadline-first (EDF) [11] scheduling. Under RM and DM (a) operations in a asynchronous system. Operations may overlap arbitrarily. (b) Interleaved operations in a uniprocessor real-time system. <p> However, we do relax this assumption by allowing short nonpreemptable code fragments when considering object implementations for multiprocessors. Requirement (i) is fundamental to all priority-driven scheduling policies. Requirement (ii) holds for most common policies, including rate-monotonic (RM) <ref> [11] </ref>, deadline-monotonic (DM) [10], and earliest-deadline-first (EDF) [11] scheduling. Under RM and DM (a) operations in a asynchronous system. Operations may overlap arbitrarily. (b) Interleaved operations in a uniprocessor real-time system. Two operations overlap only if one is contained within the other. scheduling, task priorities are static, i.e., do not change over time.
Reference: [12] <author> A. Mok, </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment , Ph.D. </title> <type> Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Requirement (ii) also holds for variations of RM, DM, and EDF scheduling in which tasks are broken into phases that are allowed to have distinct priorities [7]. The only common scheduling policy that we know of that violates requirement (ii) is least-laxity-first (LLF) scheduling <ref> [12] </ref>. Under LLF scheduling, the priority of a task invocation can change during its execution. Observe that requirements (i) and (ii) expressly preclude the use of locking within a processor.
Reference: [13] <author> Raghunathan Rajkumar, </author> <title> Synchronization In Real-Time Systems | A Priority Inheritance Approach, </title> <publisher> Kluwer Academic Publications, </publisher> <year> 1991. </year>
Reference-contexts: The main problem when using such protocols is that of priority inversion, i.e., the situation in which a given task waits for another task of lower priority to unlock an object. Mechanisms such as the priority ceiling protocol (PCP) <ref> [13, 14] </ref> are used to solve this problem. The PCP requires the kernel to dynamically adjust task priorities to ensure that a task fl Work supported, in part, by NSF contract CCR 9216421, and by a Young Investigator Award from the U.S. Army Research Office, grant number DAAH04-95-1-0323.
Reference: [14] <author> L. Sha, R. Rajkumar, and J. Lehoczky, </author> <title> "Priority Inheritance Protocols: An Approach to Real-Time System Synchronization", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 39, No. 9, </volume> <year> 1990, </year> <pages> pp. 1175-1185. </pages>
Reference-contexts: The main problem when using such protocols is that of priority inversion, i.e., the situation in which a given task waits for another task of lower priority to unlock an object. Mechanisms such as the priority ceiling protocol (PCP) <ref> [13, 14] </ref> are used to solve this problem. The PCP requires the kernel to dynamically adjust task priorities to ensure that a task fl Work supported, in part, by NSF contract CCR 9216421, and by a Young Investigator Award from the U.S. Army Research Office, grant number DAAH04-95-1-0323.
References-found: 14

