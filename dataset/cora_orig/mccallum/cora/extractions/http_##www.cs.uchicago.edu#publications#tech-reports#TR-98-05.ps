URL: http://www.cs.uchicago.edu/publications/tech-reports/TR-98-05.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: One-sided Versus Two-sided Randomness  
Author: Harry Buhrman Lance Fortnow 
Date: May 4, 1998  
Address: 1090 GB Amsterdam The Netherlands  1100 E. 58th St. Chicago, IL 60637  
Affiliation: CWI  University of Chicago Department of Computer Science  
Abstract: We demonstrate how to use Lautemann's proof that BPP is in p 2 to exhibit that BPP is in RP PromiseRP . Immediate consequences show that if PromiseRP is easy or if there exist quick hitting set generators then P = BPP. Our proof vastly simplifies the proofs of the later result due to Andreev, Clementi and Rolim and Andreev, Clementi, Rolim and Trevisan. Clementi, Rolim and Trevisan question whether the promise is necessary for the above results, i.e. whether BPP RP RP for instance. We give a relativized world where P = RP 6= BPP and thus the promise is indeed needed.
Abstract-found: 1
Intro-found: 1
Reference: [ACR98] <author> A. Andreev, A. Clementi, and J. </author> <title> Rolim. A new general derandomization method. </title> <journal> Journal of the ACM, </journal> <volume> 45(1) </volume> <pages> 179-213, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: 1 Introduction Andreev, Clementi and Rolim <ref> [ACR98] </ref> show how given access to a quick hitting set generator, one can approximate the size of easily describable sets. As an immediate consequence one gets that if quick hitting set generators exist then P = BPP. <p> With this observation, we show that Lautemann's proof puts BPP in the class RP PromiseRP [1] . Since quick hitting set generators derandomize PromiseRP problems, we get the existence of quick hitting set generators implies P = BPP. This greatly simplifies the proofs of Andreev, Clementi and Rolim <ref> [ACR98] </ref> and Andreev, Clementi, Rolim and Trevisan [ACRT97]. The difference between RP and PromiseRP is subtle but important. In the class RP we require the probabilistic Turing machine to either reject or accept with probability at least one-half fl Email: buhrman@cwi.nl. URL: http://www.cwi.nl/~buhrman. <p> Andreev, Clementi and Rolim <ref> [ACR98] </ref> show that for any ffi; ffi 0 &gt; 0, if ffi-quick hitting set generators exist than so do ffi 0 -quick hitting set generators. We will drop ffi in this case. We have many variations of probabilistic complexity classes. <p> The proof of Theorem 3.1 only uses the set A restricted to the inputs of the form hx; ri. Thus we can use PromiseBPP is easy instead of just P = BPP in Theorem 3.1 and Corollaries 3.2 and 3.3. Andreev, Clementi and Rolim <ref> [ACR98] </ref> prove the following stronger result to get Corollary 3.3. 4 Theorem 3.4 (Andreev-Clementi-Rolim) For any * &gt; 0, there is a polynomial-time algorithm that, given access to a quick hitting set generator, and given as input a circuit C returns a value D such that j Pr We should note
Reference: [ACRT97] <author> A. Andreev, A. Clementi, J. Rolim, and L. Trevisan. </author> <title> Weak random sources, hitting sets, and BPP simulations. </title> <booktitle> In Proceedings of the 38th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 264-272. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1997. </year> <month> 7 </month>
Reference-contexts: 1 Introduction Andreev, Clementi and Rolim [ACR98] show how given access to a quick hitting set generator, one can approximate the size of easily describable sets. As an immediate consequence one gets that if quick hitting set generators exist then P = BPP. Andreev, Clementi, Rolim and Tre-visan <ref> [ACRT97] </ref> simplify the proof and apply the result to simulating BPP with weak random sources. Much earlier, Lautemann [Lau83] gave a proof that BPP p 2 = NP NP , simplifying work of Gacs and Sipser [Sip83]. <p> Since quick hitting set generators derandomize PromiseRP problems, we get the existence of quick hitting set generators implies P = BPP. This greatly simplifies the proofs of Andreev, Clementi and Rolim [ACR98] and Andreev, Clementi, Rolim and Trevisan <ref> [ACRT97] </ref>. The difference between RP and PromiseRP is subtle but important. In the class RP we require the probabilistic Turing machine to either reject or accept with probability at least one-half fl Email: buhrman@cwi.nl. URL: http://www.cwi.nl/~buhrman.
Reference: [BI87] <author> M. Blum and R. Impagliazzo. </author> <title> Generic oracles and oracle classes. </title> <booktitle> In Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 118-126. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Next apply Lemma 4.7 and use QBF to compute M QBFA (x). The last possibility is that M QBFG happens to be an R machine but it is not categoric. This however can not happen since the genericity of G will diagonalize against such non-categoric machines. (See <ref> [BI87] </ref>) 2 Theorem 4.1 combined with Theorem 3.1 gives a relativized world where PromiseRP is not easy but P = RP. This corollary also follows from work of Impagliazzo and Naor [IN88]. Heller [Hel86] exhibits a relativized world where BPP = NEXP.
Reference: [CRT98] <author> A. Clementi, J. Rolim, and L. Trevisan. </author> <title> Recent advances towards proving P = BPP. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 64 </volume> <pages> 96-103, </pages> <month> February </month> <year> 1998. </year>
Reference-contexts: ERB4050PL93-0516. y Email: fortnow@cs.uchicago.edu. URL: http://www.cs.uchicago.edu/~fortnow. Supported in part by NSF grant CCR 92-53582. for all inputs. In PromiseRP we only need to solve instances where the machine rejects or accepts with probability at least one-half. A survey paper by Clementi, Rolim and Trevisan <ref> [CRT98] </ref> asks whether we can remove the promise in our result, i.e., whether BPP RP RP . We give a relativized counterexample to this conjecture by exhibiting and oracle A such that P A = RP A but P A 6= BPP A .
Reference: [FFKL93] <author> S. Fenner, L. Fortnow, S. Kurtz, and L. Li. </author> <title> An oracle builder's toolkit. </title> <booktitle> In Proceedings of the 8th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 120-131. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Define the following function tower (0) = 2, tower (n + 1) = 2 tower (n) , i.e. tower (n) is an exponential tower of n + 1 2's. We will use a special type of generic (see <ref> [FFKL93] </ref> for an overview) to prove the theorem. Definition 4.2 A BPP-generic oracle G is a type of generic oracle that is only defined at length n such that n = tower (m) for some m.
Reference: [Hel86] <author> H. Heller. </author> <title> On relativized exponential and probabilistic complexity classes. </title> <journal> Information and Computation, </journal> <volume> 71 </volume> <pages> 231-243, </pages> <year> 1986. </year>
Reference-contexts: This corollary also follows from work of Impagliazzo and Naor [IN88]. Heller <ref> [Hel86] </ref> exhibits a relativized world where BPP = NEXP. One might suspect that the techniques of Heller and those used in the proof of Theorem 4.1 may lead to an oracle A where P A = RP A and BPP A = NEXP A . We show this cannot happen.
Reference: [IN88] <author> R. Impagliazzo and M. Naor. </author> <title> Decision trees and downward closures. </title> <booktitle> In Proceedings of the 3rd IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 29-38. </pages> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Contrast this definition to Definition 2.3. In particular we have PromiseRP is easy implies P = RP. The converse is not so simply provable, relativizable counterexamples easily follow from known results on generic oracles <ref> [IN88] </ref>. The oracle we develop in Section 4 also gives a relativizable counterexample. <p> This however can not happen since the genericity of G will diagonalize against such non-categoric machines. (See [BI87]) 2 Theorem 4.1 combined with Theorem 3.1 gives a relativized world where PromiseRP is not easy but P = RP. This corollary also follows from work of Impagliazzo and Naor <ref> [IN88] </ref>. Heller [Hel86] exhibits a relativized world where BPP = NEXP. One might suspect that the techniques of Heller and those used in the proof of Theorem 4.1 may lead to an oracle A where P A = RP A and BPP A = NEXP A .
Reference: [Lau83] <author> C. Lautemann. </author> <title> BPP and the polynomial hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> 17(4) </volume> <pages> 215-217, </pages> <year> 1983. </year>
Reference-contexts: As an immediate consequence one gets that if quick hitting set generators exist then P = BPP. Andreev, Clementi, Rolim and Tre-visan [ACRT97] simplify the proof and apply the result to simulating BPP with weak random sources. Much earlier, Lautemann <ref> [Lau83] </ref> gave a proof that BPP p 2 = NP NP , simplifying work of Gacs and Sipser [Sip83]. Lautemann's proof uses two simple applications of the probabilistic method to get the existence results needed. <p> Fact 2.8 If there are quick hitting set generator then PromiseRP is easy. 3 One-sided promise gives BPP Theorem 3.1 BPP RP PromiseRP [1] Proof: We basically use the proof of Lautemann <ref> [Lau83] </ref> that BPP is in p 2 to prove Theo rem 3.1. Let L be a language in BPP and M a probabilistic polynomial-time Turing machine accepting L with an error of 2 n on inputs of length n.
Reference: [Nis91] <author> N. Nisan. </author> <title> CREW PRAMs and decision trees. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(6) </volume> <pages> 999-1007, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: We will also call these machines categorical. The idea is to show that if M is categorical then there is a polynomial time (relative to QBF) algorithm that computes for all x whether M (x) accepts or rejects. The core of this proof will be an argument from Nisan <ref> [Nis91] </ref>. The proof of Theorem 4.1 follows from Lemmas 4.5 and 4.7. <p> Moreover this strategy can be computed in polynomial time relative to QBF A. Proof We follow the lines of the proof of Nisan <ref> [Nis91] </ref>. Suppose M runs in time p (n). Call any B that fulfills the 1=6, 5=6 promise BPP 2 -promise. Fix A to be any BPP 2 -promise oracle. The deterministic strategy to determine M QBFA (x) works as follows.
Reference: [Sip83] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proceedings of the 15th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 330-335. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: Andreev, Clementi, Rolim and Tre-visan [ACRT97] simplify the proof and apply the result to simulating BPP with weak random sources. Much earlier, Lautemann [Lau83] gave a proof that BPP p 2 = NP NP , simplifying work of Gacs and Sipser <ref> [Sip83] </ref>. Lautemann's proof uses two simple applications of the probabilistic method to get the existence results needed. As often with the case of the probabilistic method, the proof actually shows that the overwhelming number of possibilities fulfill the needed requirements.
Reference: [Zac88] <author> S. Zachos. </author> <title> Probabilistic quantifiers and games. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 </volume> <pages> 433-451, </pages> <year> 1988. </year> <month> 8 </month>
Reference-contexts: We show this cannot happen. Theorem 4.8 In all relativized worlds, if P = RP and NP BPP then P = BPP. Proof Zachos <ref> [Zac88] </ref> shows that if NP BPP then NP = RP. We then have P = NP = p and thus P = BPP.
References-found: 11

