URL: http://www.cs.toronto.edu/~david/papers-iclp91.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: lumat@CSPUNI12.BITNET  
Title: Register Allocation in WAM  
Author: Ludek Matyska, Adriana Jergova, David Toman 
Address: 601 77 Brno, Czechoslovakia  
Affiliation: Institute of Computer Science Masaryk University  
Abstract: Paper presents a new register allocation strategy for WAM based compilation of Prolog. The proposed strategy is based on the computation of optimal order of the unification of individual head arguments. The unification of head arguments is interspersed with the execution of inline calls and with the preparation of arguments for the out-of-line call. Moreover, it is shown that the problem of register allocation in WAM is at least NP-Complete in general. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> At-Kaci, H.: </author> <title> The WAM: A (Real) Tutorial, </title> <type> Tech. report 5 , DEC, </type> <institution> Paris Research Laboratory, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Almost all current successful Prolog implementations on traditional computer architectures are based on the Warren Abstract Machine (WAM) architecture and its instruction set [14] (for a good introduction see, e.g., <ref> [1] </ref>).
Reference: [2] <author> Carlsson, M.: </author> <title> Freeze, Indexing, and Other Implementation Issues in the WAM, </title> <booktitle> Proc. 4th Int. Conf. Logic Programming, </booktitle> <address> pp.40-58, </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference [4, 6, 16] * clause indexing <ref> [2] </ref>, and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10].
Reference: [3] <author> Debray, S. K.: </author> <title> Register Allocation in a Prolog Machine, </title> <booktitle> Symposium on Logic Programming, pp.267-275, IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference [4, 6, 16] * clause indexing [2], and * register allocation <ref> [3, 8] </ref> Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10]. <p> Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation <ref> [3, 8, 9, 13, 17] </ref>. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17].
Reference: [4] <author> Debray, S. K. and Warren, D. S.: </author> <title> Automatic Mode Inference for Logic Programs, </title> <journal> J. Logic Programming, </journal> <volume> 5 </volume> <pages> 207-229, </pages> <year> 1988. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference <ref> [4, 6, 16] </ref> * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10].
Reference: [5] <author> Debray, S. K.: </author> <title> Unfold/Fold Transformations and Loop Optimization of Logic Programs, </title> <booktitle> Proc. ACM SIGPLAN'88, pp.297-307, ACM, </booktitle> <address> New York, </address> <booktitle> 1988 (SIGPLAN Not. </booktitle> <volume> 23, </volume> <pages> 7). </pages>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations <ref> [5] </ref>, global flow analysis [15]) * mode and type inference [4, 6, 16] * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still
Reference: [6] <author> Debray, S. K.: </author> <title> Static Inference of Modes and Data Dependencies in Logic Programs, </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 11 </volume> <pages> 418-450, </pages> <year> 1989. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference <ref> [4, 6, 16] </ref> * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10].
Reference: [7] <author> Even, S.: </author> <title> Graph Algorithms, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Mary-land, </address> <year> 1979, </year> <month> pp.223-224. </month>
Reference-contexts: The same applies to v 2 .) Using VRFG clause representation the version of register allocation prob-lem (in its above-introduced simplified version) will be shown to be equivalent to "the minimum feedback set (FVS) problem" with NP-Completeness of this proved in <ref> [7] </ref>. FVS presents a problem of finding the minimal number of vertices to be eliminated from a directed graph in order the remaining graph be acyclic (without any loop).
Reference: [8] <author> Janssens, G., Demoen, B. and Marten, A.: </author> <title> Improving the Register Allo--cation in WAM by Reordering Unification, </title> <booktitle> Proc. 5th Int. Conf. Symp. Logic Programming, </booktitle> <address> pp.1388-1402, </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference [4, 6, 16] * clause indexing [2], and * register allocation <ref> [3, 8] </ref> Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10]. <p> Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation <ref> [3, 8, 9, 13, 17] </ref>. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17]. <p> The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed <ref> [8, 9, 17] </ref>. Nevertheless, none of these methods is optimal in all cases. In the first part of the present paper the problem of register allocation in WAM is shown to be at least NP-Complete. <p> In the second part special subcases of the general problem are discussed, and for them the optimal register allocation strategy is presented. 2 Terminology and Basic Notions Notation of Janssens et al. <ref> [8] </ref> will be followed throughout this paper, i.e., variables begin in upper case, permanent variables are denoted Y i , and temporary variables (i.e., WAM registers) by R j . <p> Nevertheless, there are many interesting cases for which optimal computationally tractable strategies can be found. As was pointed out in <ref> [8] </ref>, the parameter passing in WAM-based Prolog implementations is side effect free, and the order in which the individual head arguments are to be processed may be adapted in order to minimize the number of register moves (i.e., the number of instructions generated by the compiler). <p> The search for the optimal moveregister instruction sequence is performed by a simple modification of the Release function from <ref> [8] </ref>. <p> Not only all known (for definition of known cf. <ref> [8] </ref>) arguments are processed in this way, but all unblocked (variable or compound) arguments are processed as well. The processing order also complies with suggestions from [9]. <p> optimal under any circumstances. 7 UnAPrep, for each non-void variable V , is the union of UnPrep (V ) with the set of all non-test inline calls using V . 5 Evaluation 5.1 Comparison with Previous Work We compare our method with the "adaptable unification order" of Janssens et al. <ref> [8] </ref> and strategy in [17], which are the best register allocation algorithms published so far. The "adaptable" method finds the optimal order for the treatment of variables as head arguments, but it may fail when compound term arguments are involved. <p> Our method uses extended Release function, and finds the same unification order for variables as arguments as the "adaptable" method. Moreover, the Block and Half block sets allow to find the optimal order even for a subset of compound terms as arguments. In <ref> [8] </ref>, clause head (f (T),g (T)) :- goal (a,T) is used as an example of incompleteness of their algorithm: "adaptable" strategy new strategy get structure f/1,R 1 get structure g/1,R 2 unify variable R 3 unify variable R 2 get structure g/1,R 2 get structure f/1,R 1 unify value R 3 <p> The method proposed is optimal only for a subclass of all possible cases, but this subclass is much larger than subclasses of the recently published methods <ref> [8, 9, 17] </ref>. Besides of the good news of obtaining a register allocation strategy superior to those published so far, the bad news is that any optimal method for register allocation in WAM must be at least NP-Complete.
Reference: [9] <author> Kurosawa, S. A. K. and Kiriyama, K.: </author> <title> A new Optimization Technique for a Prolog Compiler, </title> <publisher> IEEE COMPCON'86, </publisher> <address> San Francisco, CA, pp.241-245, </address> <publisher> Computer Society Press, </publisher> <address> Rockville, Maryland, </address> <year> 1986. </year>
Reference-contexts: Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation <ref> [3, 8, 9, 13, 17] </ref>. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17]. <p> The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed <ref> [8, 9, 17] </ref>. Nevertheless, none of these methods is optimal in all cases. In the first part of the present paper the problem of register allocation in WAM is shown to be at least NP-Complete. <p> Not only all known (for definition of known cf. [8]) arguments are processed in this way, but all unblocked (variable or compound) arguments are processed as well. The processing order also complies with suggestions from <ref> [9] </ref>. <p> The method proposed is optimal only for a subclass of all possible cases, but this subclass is much larger than subclasses of the recently published methods <ref> [8, 9, 17] </ref>. Besides of the good news of obtaining a register allocation strategy superior to those published so far, the bad news is that any optimal method for register allocation in WAM must be at least NP-Complete.
Reference: [10] <author> Lindholm, T. and O'Keefe, R. A.: </author> <title> Efficient Implementation of a Defensible Semantics for Dynamic Prolog Code, </title> <booktitle> Proc. 4th Int. Conf. Logic Programming, </booktitle> <address> pp.21-39, </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: [4, 6, 16] * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures <ref> [10] </ref>. Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation [3, 8, 9, 13, 17].
Reference: [11] <author> Matyska, L. and Toman, D.: </author> <title> Prolog and WAM A Case Study of an Implementation, </title> <booktitle> Proc. </booktitle> <address> LOP'88, pp.65-88, Ruprechtov, </address> <note> 1988 (Available also as the Tech. Report, ICS MU 1988). </note>
Reference-contexts: The proposed register allocation strategy is being implemented. An early prototype system written in Prolog is used for testing the performance improvements and possible new heuristics. The full implementation will replace the register allocation module of the MUB-Prolog WAM based compiler, de veloped at the University of Brno <ref> [11] </ref>. 6 Conclusion The unification strategy proposed is an almost optimal method for register allocation in the WAM. It is based on cutting clauses into chunks, computing the blocking numbers for individual registers, and unification order control relying on the blocking numbers computed.
Reference: [12] <author> Meier, M.: </author> <title> Compilation of Compound Terms in Prolog, </title> <booktitle> Proc. </booktitle> <address> NA-CLP'90, </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Also, as the general blocking problem has been shown to be at least NP-Complete, there is an open question of strong heuristics for the generation of optimal code in restricted cases. A new method for the compilation of compound terms in Prolog was recently proposed <ref> [12] </ref>. This method allows a depth first traversal of the compound term, instead of the breadth first traversal used in WAM (and also in our method).
Reference: [13] <author> Umrigar, Z. D.: </author> <title> Finding Advantageous Orders for Argument Unification for the Prolog WAM, </title> <booktitle> Proc. </booktitle> <address> NACLP'90, pp.80-96, </address> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1990. </year>
Reference-contexts: Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation <ref> [3, 8, 9, 13, 17] </ref>. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17].
Reference: [14] <author> Warren, D. H. D.: </author> <title> An Abstract Prolog Instruction Set, </title> <type> Tech. Report 309, </type> <institution> SRI International, AI Center, Palo Alto, </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction Almost all current successful Prolog implementations on traditional computer architectures are based on the Warren Abstract Machine (WAM) architecture and its instruction set <ref> [14] </ref> (for a good introduction see, e.g., [1]). <p> Several authors have suggested methods for optimal register allocation [3, 8, 9, 13, 17]. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM <ref> [14] </ref>, needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17]. Nevertheless, none of these methods is optimal in all cases.
Reference: [15] <author> Warren, R., Hermenegildo, M. and Debray, S. K.: </author> <title> On the Practicality of Global Flow Analysis of Logic Programs, </title> <booktitle> Proc. Int. Conf. Symp. on Logic Programming, </booktitle> <address> pp.684-699, Seattle, </address> <year> 1988. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis <ref> [15] </ref>) * mode and type inference [4, 6, 16] * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection
Reference: [16] <author> Xu, J. and Warren, D. S.: </author> <title> A Type Inference System for Prolog, </title> <booktitle> Proc. 5th Int. Conf. Symp. Logic Programming, </booktitle> <address> pp.604-619, </address> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1988. </year>
Reference-contexts: Many improvements to the WAM have been suggested and also the problem of efficient code generation was extensively studied from several perspectives: * program transformation (e.g., unfold/fold transformations [5], global flow analysis [15]) * mode and type inference <ref> [4, 6, 16] </ref> * clause indexing [2], and * register allocation [3, 8] Although current interest in compiler implementation is focused mostly on the analysis of global properties of Prolog programs, the generation of efficient code for individual clauses is still important, esp. in connection with dynamic (i.e., assertable/retractable) procedures [10].
Reference: [17] <author> Hu Ziang, Xiang Rong Ci: </author> <title> An Improved Register Allocation Algorithm for the WAM Model, </title> <booktitle> IEEE Proc. Tools for AI'90, </booktitle> <address> pp.651-657, </address> <year> 1990. </year>
Reference-contexts: Paper presents a new register allocation strategy for compilation of individual Prolog clauses. The main problem addressed is "which register should be used for which variable to minimize the number of instructions generated". Several authors have suggested methods for optimal register allocation <ref> [3, 8, 9, 13, 17] </ref>. The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed [8, 9, 17]. <p> The strict left to right order for the treatment of individual head arguments, implicitly present in the original WAM [14], needs not to be relied upon, and more efficient schemes with reordered unification were also proposed <ref> [8, 9, 17] </ref>. Nevertheless, none of these methods is optimal in all cases. In the first part of the present paper the problem of register allocation in WAM is shown to be at least NP-Complete. <p> 7 UnAPrep, for each non-void variable V , is the union of UnPrep (V ) with the set of all non-test inline calls using V . 5 Evaluation 5.1 Comparison with Previous Work We compare our method with the "adaptable unification order" of Janssens et al. [8] and strategy in <ref> [17] </ref>, which are the best register allocation algorithms published so far. The "adaptable" method finds the optimal order for the treatment of variables as head arguments, but it may fail when compound term arguments are involved. <p> Then Block (R 4 ) = 0, after its treat-ment Block (R 3 ) = 0, then Block (R 2 ) = 0, and so on until the transferred argument in R 1 may also be processed. Also when comparing to <ref> [17] </ref>, our approach gives better results. The code generated for clause head (f (X),Y,g (Y)) :- goal (a,X,b) is: strategy in [17] new strategy get structure f/1,R 1 get structure g/1,R 3 unify variable R 4 unify value R 2 get structure g/1,R 3 get structure f/1,R 1 unify value R <p> Also when comparing to <ref> [17] </ref>, our approach gives better results. The code generated for clause head (f (X),Y,g (Y)) :- goal (a,X,b) is: strategy in [17] new strategy get structure f/1,R 1 get structure g/1,R 3 unify variable R 4 unify value R 2 get structure g/1,R 3 get structure f/1,R 1 unify value R 2 unify variable R 2 moveregister R 4 ,R 2 put constant a,R 1 put constant a,R 1 put constant b,R <p> The method proposed is optimal only for a subclass of all possible cases, but this subclass is much larger than subclasses of the recently published methods <ref> [8, 9, 17] </ref>. Besides of the good news of obtaining a register allocation strategy superior to those published so far, the bad news is that any optimal method for register allocation in WAM must be at least NP-Complete.
References-found: 17

