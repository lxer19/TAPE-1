URL: http://www.cs.umr.edu/techreports/94-06.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: Formal Verification of Distributed Deadlock Detection Algorithm Using a Time-dependent Proof Technique  
Author: Pei-yu Li and Bruce McMillin 
Address: Rolla, Missouri 65401  
Affiliation: Department of Computer Science University of Missouri-Rolla  
Date: February 1994  
Pubnum: CSC-94-06  
Abstract: A large number of published distributed deadlock detection/resolution algorithms are found to be incorrect because they have used informal approaches to prove the correctness of their algorithms. In this paper, we present a formal approach for the correctness proof and give an example of the proof. In this proposed approach, a formal model of distributed deadlock is presented with a local-time deadlock specification for correctness verification. With the formal model, we have an insight into the definition of deadlock in local views which is used to show the existence of a real deadlock. A rigorous proof to show the equivalence of local-time and global-time deadlock specifications is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. K. Sinha and N. Natarajan, </author> <title> "A priority based distributed deadlock detection algorithm," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. SE-11, </volume> <pages> pp. 67-80, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: Deadlock detection/resolution is an important problem in a distributed system and much attention has been devoted to it in the past few years. Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof <ref> [1, 2, 3] </ref> or have given an informal proof by using intuitive operational arguments [4, 5, 6]. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. <p> Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect <ref> [4, 5, 1, 3] </ref>. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7].
Reference: [2] <author> M. Roesler, W. A. Burkhard, and K. B. Cooper, </author> <title> "Efficient deadlock resolution for lock-based concurrency control schemes," </title> <booktitle> in Proc. 8th Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pp. 224-233, </pages> <year> 1988. </year>
Reference-contexts: Deadlock detection/resolution is an important problem in a distributed system and much attention has been devoted to it in the past few years. Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof <ref> [1, 2, 3] </ref> or have given an informal proof by using intuitive operational arguments [4, 5, 6]. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3].
Reference: [3] <author> A. N. Choudhary, W. H. Kohler, J. A. Stankovic, and D. Towsley, </author> <title> "A modified priority based probe algorithm for distributed deadlock detection and resolution," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. SE-15, </volume> <pages> pp. 10-17, </pages> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Deadlock detection/resolution is an important problem in a distributed system and much attention has been devoted to it in the past few years. Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof <ref> [1, 2, 3] </ref> or have given an informal proof by using intuitive operational arguments [4, 5, 6]. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. <p> Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect <ref> [4, 5, 1, 3] </ref>. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7].
Reference: [4] <author> D. A. Menasce and R. R. Muntz, </author> <title> "Locking and deadlock detection in distributed data bases," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> vol. SE-5, </volume> <pages> pp. 195-202, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof [1, 2, 3] or have given an informal proof by using intuitive operational arguments <ref> [4, 5, 6] </ref>. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7]. <p> Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect <ref> [4, 5, 1, 3] </ref>. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7].
Reference: [5] <author> R. Obermarck, </author> <title> "Distributed deadlock detection algorithm," </title> <journal> ACM Trans. Database Syst., </journal> <volume> vol. 7, </volume> <pages> pp. 187-208, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof [1, 2, 3] or have given an informal proof by using intuitive operational arguments <ref> [4, 5, 6] </ref>. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7]. <p> Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect <ref> [4, 5, 1, 3] </ref>. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7].
Reference: [6] <author> K. Sugihara, T. Kikuno, N. Yoshida, and M. Ogata, </author> <title> "A distributed algorithm for deadlock detection and resolution," </title> <booktitle> in IEEE Reliability in Distributed Software and Database Systems, </booktitle> <pages> pp. 169-176, </pages> <year> 1984. </year>
Reference-contexts: Many distributed deadlock detection/resolution algorithms have been proposed, however, most of them either have not given a correctness proof [1, 2, 3] or have given an informal proof by using intuitive operational arguments <ref> [4, 5, 6] </ref>. Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms [7].
Reference: [7] <author> E. Knapp, </author> <title> "Deadlock detection in distributed databases," </title> <journal> ACM Comput. Surveys, </journal> <volume> vol. 19, </volume> <pages> pp. 303-328, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Intuitive operational arguments are prone to errors, and many of the published algorithms have been found to be incorrect [4, 5, 1, 3]. Only rigorous proofs, using as few operational arguments as possible, suffice to show the correctness of such algorithms <ref> [7] </ref>. In a distributed system with no global memory, deadlock cycles can form in innumerable ways, message delays are unpredictable, and deadlock is very sensitive to the timing of resource requests besides.
Reference: [8] <author> M. Singhal, </author> <title> "Deadlock detection in distributed systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 37-48, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: In a distributed system with no global memory, deadlock cycles can form in innumerable ways, message delays are unpredictable, and deadlock is very sensitive to the timing of resource requests besides. These attributes make a formal correctness proof of deadlock detection/resolution algorithms difficult to achieve <ref> [8] </ref>, thus, very few sophisticated formal methods for correctness proof exist. To formally show the correctness of distributed deadlock detection/resolution algorithms, time-dependent proof techniques are particularly necessary [8]. We present a formal distributed deadlock model with global and local clocks and develop the deadlock specification by using time-dependent predicates. <p> These attributes make a formal correctness proof of deadlock detection/resolution algorithms difficult to achieve <ref> [8] </ref>, thus, very few sophisticated formal methods for correctness proof exist. To formally show the correctness of distributed deadlock detection/resolution algorithms, time-dependent proof techniques are particularly necessary [8]. We present a formal distributed deadlock model with global and local clocks and develop the deadlock specification by using time-dependent predicates. With this model, we have an insight into the definition of deadlock in the local views.
Reference: [9] <author> Y. C. Tay and W. T. Loke, </author> <title> "A theory for deadlocks over resources." </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: With this model, we have an insight into the definition of deadlock in the local views. We also give a rigorous proof to show the equivalence of local-time and global-time specifications. In the only existing related work <ref> [9] </ref> we know of, several local-time deadlock specifications are developed to analyze the deadlock models used in different algorithms. In contrast, our local-time specification is used in the verification of the correctness of distributed deadlock detection/resolution algorithms.
Reference: [10] <author> P. Li and B. McMillin, </author> <title> "Formal model and specification of deadlock," </title> <type> Tech. Rep. </type> <institution> CSC-93-31, Dep. of Comput. Sci., Univ. of Missouri, Rolla, </institution> <year> 1993. </year>
Reference-contexts: The equivalence of local-time and global-time specifications will be proved in the next section. 2.3 Equivalence of global and local specifications Theorem 1 D L () D G . Proof: The detailed proof is presented in <ref> [10] </ref>. 4 3 A modified algorithm We modify the algorithm of [11] by omitting fault-tolerant parts and use the modified algorithm as an example for the correctness verification. This algorithm is an interesting variation of the standard probe-based algorithm, where probes are propagated in a backward direction.
Reference: [11] <author> P. Li and B. McMillin, </author> <title> "Fault-tolerant distributed deadlock detection/resolution," </title> <booktitle> in Proc. 17th Int. COMPSAC, </booktitle> <pages> pp. 224-230, </pages> <year> 1993. </year>
Reference-contexts: The equivalence of local-time and global-time specifications will be proved in the next section. 2.3 Equivalence of global and local specifications Theorem 1 D L () D G . Proof: The detailed proof is presented in [10]. 4 3 A modified algorithm We modify the algorithm of <ref> [11] </ref> by omitting fault-tolerant parts and use the modified algorithm as an example for the correctness verification. This algorithm is an interesting variation of the standard probe-based algorithm, where probes are propagated in a backward direction. <p> Upon receiving a resource request, the resource either grants the request or forwards the request to the resource holder. Besides, the resource forwards outstanding requests to the new resource holder when previous holder releases it. In the algorithm of <ref> [11] </ref>, concurrent processes communicate with each other via asynchronous message-passing, where the sender process continues while the message is being delivered and received. <p> A send command, i!M , represents sending a message M to process i. With the addition of buffer processes, a send statement send M to i and a receive statement receive M from i in process j of <ref> [11] </ref> are modeled respectively by N i !M and N j ?M in the algorithm. To let the receiver know of the message sender, it is assumed that each message M is accompanied with its sender information which can be extracted from the function sender (M ). <p> To let the receiver know of the message sender, it is assumed that each message M is accompanied with its sender information which can be extracted from the function sender (M ). Besides, the following assumptions were made in <ref> [11] </ref>: (1) No multiple deadlock victims concurrently exist in a deadlock cycle. (2) Spontaneous aborts of processes are not permitted. (3) A process holds acquired resources until its computation is done.
Reference: [12] <author> R. D. Schlichting and F. B. Schineider, </author> <title> "Using message passing for distributed programming: proof rules and disciplines," </title> <journal> ACM Trans. Programming Languages Syst., </journal> <volume> vol. 6, </volume> <pages> pp. 402-431, </pages> <month> July </month> <year> 1984. </year> <month> 22 </month>
Reference-contexts: To apply the proof obligations for a CSP to programs that involve asynchronous activity, we employ a buffer process N i for each process i 2 Q to simulate the 5 virtual circuit in <ref> [12] </ref>. A process j that wants to sends messages to process i will commu-nicate with N i , and process i will communicate with N i in order to receive messages from process j. <p> algorithm correctness To be correct, a deadlock detection/resolution algorithm must satisfy two properties: (1) Safety property: the algorithm detects deadlock only if there exists a deadlock. (2) Liveness property: the algorithm will detect every deadlock eventually. 4.1 Safety property To prove the safety property, a similar axiomatic proof technique to <ref> [12] </ref> is applied to the given algorithm. The proofs involve three steps: a sequential proof, a satisfaction proof, and a non-interference proof. Since our proof system is based on the history of communication, we introduce some variables that record partial communication history and use them as auxiliary variables.
Reference: [13] <author> S. Owicki and L. Lamport, </author> <title> "Proving liveness properties of concurrent programs," </title> <journal> ACM Trans. Programming Languages Syst., </journal> <volume> vol. 4, </volume> <pages> pp. 455-495, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: We use notation defined in <ref> [13] </ref> to express communication control flow. The immediate assertion at (Z) holds for all states where control in a process is at the beginning of statement Z, and after (Z) holds for states where control in a process is immediately after statement Z.
Reference: [14] <author> G. M. Levin and D. Gries, </author> <title> "A proof technique for communicating sequential processes," </title> <journal> Acta Informatica, </journal> <volume> vol. 15, </volume> <pages> pp. 281-302, </pages> <year> 1981. </year> <month> 23 </month>
Reference-contexts: S 1 S 2 states that if assertion S 1 ever becomes true, then assertion S 2 will be true at the same time or later. A send or receive guard becomes ready when its corresponding matching process is prepared to communicate <ref> [14] </ref>. The fair scheduling assumption is made, if a guard is ready, it must be executed in a finite, bounded amount of time.
References-found: 14

