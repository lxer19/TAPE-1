URL: ftp://ftp.csd.uu.se/pub/papers/reports/0106.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: with Theory Systems  
Author: Jonas Barklund Katrin Boberg Pierangelo Dell'Acqua Margus Veanes 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University Computing Science Department  
Note: Meta-programming  
Abstract: UPMAIL Technical Report No. 106 5 May, 1995 ISSN 1100-0686 Abstract A theory system is a collection of interdependent theories, some if which stand in a meta/object relationship, forming an arbitrary number of meta-levels. The main thesis of this chapter is that theory systems constitute a suitable formalism for constructing advanced applications in reasoning and software engineering. The Alloy language for defining theory systems is introduced, its syntax is defined and a collection of inference rules is presented. A number of problems suitable for theory systems are discussed, with program examples given in Alloy. Some current implementation issues and future extensions are discussed. This paper appears as a chapter in Meta-logics and Logic Programming, edited by K. Apt and F. Turini, and published by MIT Press in 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Attardi, G. and Simi, M., </author> <title> Building Proofs in Context, </title> <editor> in: F. Turini (ed.), </editor> <booktitle> Proc. META 94, </booktitle> <publisher> LNCS 883, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: There have recently appeared some proposals for systems for meta-reasoning with a similar philosophy as ours. Attardi & Simi <ref> [1] </ref> use what they call "relativized truth" but obtain a system quite similar to ours. One significant difference is that they choose to duplicate their inference system (a natural deduction system): the rules are present once for the object level and again for the meta-level.
Reference: [2] <author> Bacha, H., </author> <title> Meta-Level Programming: a Compiled Approach, </title> <editor> in: J.-L. Lassez (ed.), </editor> <booktitle> Proc. 4th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Bowen & Weinberg [6] and Bacha <ref> [2] </ref> have investigated compilation of partially known clauses in a context similar to ours. Sato [29] proposes an approach to meta-programming through a complete truth predicate tr in three valued logic.
Reference: [3] <author> Barklund, J., </author> <title> Metaprogramming in Logic, </title> <type> UPMAIL Technical Report 80, </type> <institution> Uppsala Univ., Computing Science Dept., </institution> <year> 1994, </year> <note> to be published in encyclopedia of computer science and technology, </note> <editor> marcel dekker, </editor> <address> new york. </address>
Reference-contexts: Proposing some future extensions, supporting technologies and some current implementation issues (Sects. 8-9). We end with some notes and conclusions. For a general introduction to meta-programming in logic programming, the reader is referred to the overviews by Barklund <ref> [3] </ref> and Hill & Gallagher [19]. 2 Artificial intelligence and software engineering The studies of artificial intelligence in general and expert systems in particular make it clear that truly useful problem solvers must be constructed in a quite different way than has been tried in the past.
Reference: [4] <author> Barklund, J., Boberg, K. and Dell'Acqua, P., </author> <title> A Basis for a Multilevel Metalogic Programming Language, </title> <editor> in: F. Turini (ed.), </editor> <booktitle> Proc. META 94, </booktitle> <publisher> LNCS 883, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: Denials are already formally present in the language and would then function as integrity constraints when given as part of a program [26]. 10 Notes and related work There have been a few changes in the definition of Alloy since our previous publication <ref> [4] </ref>. 1. Theory terms now include expressions on the form . 2. In addition to program clauses, Alloy now has goals and denials. 3. What used to be called a tagged program clause is now called a theo remhood statement and may contain any sentence. 25 4.
Reference: [5] <author> Bevemyr, J., </author> <title> The Luther WAM Emulator, </title> <type> UPMAIL Tech. Rep. 72, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1992. </year>
Reference-contexts: Such achievement of abductive reasoning through meta-reasoning is a topic that ought to be explored further using theory systems. 9 Implementation and language extensions In our implementation efforts, we are extending Luther <ref> [5] </ref>, an instance of Warren's abstract Prolog machine [32]. The idea is that the generalized SLD-resolution rule should be essentially as efficient as in Prolog, regardless of the number of "indirection" levels.
Reference: [6] <author> Bowen, K. A. and Weinberg, T., </author> <title> A Meta-Level Extension of Prolog, </title> <editor> in: J. Cohen and J. Conery (eds.), </editor> <booktitle> Proc. 1985 Symp. on Logic Programming, IEEE Comp. </booktitle> <publisher> Soc. Press, </publisher> <address> Washington, D.C., </address> <year> 1985. </year>
Reference-contexts: Our proposal for a meta-programming based software engineering methodology is related to the proposal by Kowalski about using meta-language for assembling programs [24] and the work by Brogi et al. about using theory operators for building programs, which is discussed in more detail in Sect. 6.3. Bowen & Weinberg <ref> [6] </ref> and Bacha [2] have investigated compilation of partially known clauses in a context similar to ours. Sato [29] proposes an approach to meta-programming through a complete truth predicate tr in three valued logic.
Reference: [7] <author> Bowen, K. A., </author> <title> Meta-Level Programming and Knowledge Representation, </title> <journal> New Generation Computing, </journal> <volume> 3 </volume> <month> 359-383 </month> <year> (1985). </year> <month> 28 </month>
Reference-contexts: We shall show how fragments of these applications can be programmed elegantly in Alloy. Our ambition is twofold. Firstly, we wish to convince the reader of the strength and versatility of meta-programming with theory systems, continuing and extending the work by Bowen & Kowal-ski [8], Sterling [31], Bowen <ref> [7] </ref>, Brogi & Turini [12] and others.
Reference: [8] <author> Bowen, K. A. and Kowalski, R. A., </author> <title> Amalgamating Language and Met--alanguage in Logic Programming, </title> <editor> in: K. L. Clark and S. A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: We shall show how fragments of these applications can be programmed elegantly in Alloy. Our ambition is twofold. Firstly, we wish to convince the reader of the strength and versatility of meta-programming with theory systems, continuing and extending the work by Bowen & Kowal-ski <ref> [8] </ref>, Sterling [31], Bowen [7], Brogi & Turini [12] and others. <p> Abductive reasoning can be carried out in many ways. One way is to add inference rules for abductive reasoning, obtaining new abductive proof procedures [21]. However, it is also possible to realize abductive reasoning through meta-level deduction, as suggested by Bowen & Kowalski <ref> [8] </ref>. Such achievement of abductive reasoning through meta-reasoning is a topic that ought to be explored further using theory systems. 9 Implementation and language extensions In our implementation efforts, we are extending Luther [5], an instance of Warren's abstract Prolog machine [32].
Reference: [9] <author> Brogi, A., Mancarella, P., Pedreschi, D. and Turini, F., </author> <title> Composition Operators for Logic Theories, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: with negation, then negative introspection is also easy: A ` p B ` not p B ` _ _p q q not p B ` _q q ^ p Names q 6.3 Program Composition Operators Brogi, Mancarella, Pedreschi and Turini have proposed an algebra of operators for composing logic programs <ref> [9] </ref>. The operators are P [ Q, P " Q, P fl and P / Q, for union, intersection, encapsulation and import of programs, respectively.
Reference: [10] <author> Brogi, A., </author> <title> Program Construction in Computational Logic, </title> <type> Ph.D. Thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year>
Reference-contexts: For example, consider a program in the algebra with three "basic" theories Rules, Public and Private <ref> [10] </ref>. In the Alloy program, the clauses of these theories should appear as theoremhood statements M Rules ` , M Public ` , and M Private ` , respectively.
Reference: [11] <author> Brogi, A. and Contiero, S., </author> <title> Godel as a Meta-Language for Composing Logic Programs, </title> <editor> in: F. Turini (ed.), </editor> <booktitle> Proc. META 94, </booktitle> <publisher> LNCS 883, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: ( _p; _q) ` _a _c 1 q p _p ` _a _c q ^ Partition (c; c 1 ; c 2 ) ^ p _q ` _c 2 ? q This straightforward program, which uses a ground representation, is no less elegant than the program by Brogi & Contiero <ref> [11] </ref> that uses a nonground representation. (We assume that the ternary predicate Partition has been defined to compute the partition of a conjunction into a pair of (possibly empty or unitary) conjunctions. For example, consider a program in the algebra with three "basic" theories Rules, Public and Private [10].
Reference: [12] <author> Brogi, A. and Turini, F., </author> <title> Metalogic for Knowledge Representation, </title> <editor> in: J. A. Allen, R. Fikes and E. Sandewall (eds.), </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. 2nd Intl. Conf., </booktitle> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, Calif., </address> <year> 1991. </year>
Reference-contexts: Our ambition is twofold. Firstly, we wish to convince the reader of the strength and versatility of meta-programming with theory systems, continuing and extending the work by Bowen & Kowal-ski [8], Sterling [31], Bowen [7], Brogi & Turini <ref> [12] </ref> and others.
Reference: [13] <author> Christiansen, H., </author> <title> Efficient and Complete Demo Predicates for Definite Clause Languages, </title> <type> Technical Report 51, </type> <institution> Dept. of Computer Science, Roskilde University, </institution> <year> 1994. </year>
Reference-contexts: Christiansen has proposed an amalgamated language in which there are two levels of reasoning <ref> [13] </ref>. The operational semantics of the language is based on instance predicates, relating names of formulas such that one is an instance of the other.
Reference: [14] <author> Clark, K. L., </author> <title> Negation as Failure, </title> <editor> in: H. Gallaire and J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Before normalizing the language of a program, we extend each of its theories with every axiom on the form p t q Names t, where t is a term. After normalizing, as described in Sect. 4.2, the usual Herbrand equality theory, as axiomatized by Clark <ref> [14] </ref>, can be used. (However, computation of the naming relation ought to be integrated with unification in order to delay computation of names of nonground terms.) As all correct normalizations will behave in the same way, with respect to equality of the normalized expressions, it would alternatively be conceivable to extend
Reference: [15] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Extending Horn Clause Theories by Reflection Principles, </title> <editor> in: C. MacNish, D. Pearce and L. M. Pereira (eds.), </editor> <booktitle> Logics in Artificial Intelligence, </booktitle> <publisher> LNAI 838, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: as "reflection principles" but for which 5 t 1 t 2 t 3 t 1 t 2 p t 2 ` p t 3 ` q q a better name is "reflection rules" or "linking rules" (cf. the discussions by Giunchiglia, Serafini & Simpson [18] and Costantini, Dell'Acqua & Lan-zarone <ref> [15] </ref>). However, in Sect. 4.3 we will present two reflection rules corresponding to the two implications of the theoremhood reflection principle. Fig. 2 depicts part of a theory system in which a theory t contains a theorem p u ` p v ` q q .
Reference: [16] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogic Programming Language, </title> <editor> in: G. Levi and M. Martelli (eds.), </editor> <booktitle> Proc. 6th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: There is an SLD-resolution style inference rule instead of an inference rule for program clauses. It should be obvious for the knowledgeable reader that the development of Alloy is very much inspired by work of Kowalski [25, 26], and by Reflective Prolog of Costantini & Lanzarone <ref> [16] </ref>. There have recently appeared some proposals for systems for meta-reasoning with a similar philosophy as ours. Attardi & Simi [1] use what they call "relativized truth" but obtain a system quite similar to ours.
Reference: [17] <author> Giunchiglia, F. and Cimatti, A., </author> <title> Introspective Metatheoretic Reasoning, </title> <editor> in: F. Turini (ed.), </editor> <booktitle> Proc. META 94, </booktitle> <publisher> LNCS 883, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: There is only one theory per meta-level but the communication between meta-levels is similar to that in Alloy. This seems to be the basis for the reasoning part of GETFOL, a system that is also capable of code introspection and revision <ref> [17] </ref>. Our proposal for a meta-programming based software engineering methodology is related to the proposal by Kowalski about using meta-language for assembling programs [24] and the work by Brogi et al. about using theory operators for building programs, which is discussed in more detail in Sect. 6.3.
Reference: [18] <author> Giunchiglia, F., Serafini, L. and Simpson, A., </author> <title> Hierarchical Meta-Logics: Intuitions, Proof Theory and Semantics, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: the inference rules sometimes referred to as "reflection principles" but for which 5 t 1 t 2 t 3 t 1 t 2 p t 2 ` p t 3 ` q q a better name is "reflection rules" or "linking rules" (cf. the discussions by Giunchiglia, Serafini & Simpson <ref> [18] </ref> and Costantini, Dell'Acqua & Lan-zarone [15]). However, in Sect. 4.3 we will present two reflection rules corresponding to the two implications of the theoremhood reflection principle. <p> Moreover, among their basic axioms for the meta-level, there is one which ensures positive introspection. We have preferred to have no such epistemic bias, except for saturation. Giunchiglia et al. <ref> [18] </ref> have defined a multilevel deduction system with distinct levels, called MK. There is only one theory per meta-level but the communication between meta-levels is similar to that in Alloy.
Reference: [19] <author> Hill, P. M. and Gallagher, J., </author> <title> Meta-Programming in Logic Programming, </title> <type> Technical Report 94.22, </type> <institution> School of Computer Studies, Univ. of 29 Leeds, </institution> <year> 1994, </year> <note> to be published in Handbook of Logic in Artificial Intel--ligence and Logic Programming, Vol. 5, </note> <institution> Oxford Science Publ., Oxford Univ. </institution> <note> Press. </note>
Reference-contexts: Proposing some future extensions, supporting technologies and some current implementation issues (Sects. 8-9). We end with some notes and conclusions. For a general introduction to meta-programming in logic programming, the reader is referred to the overviews by Barklund [3] and Hill & Gallagher <ref> [19] </ref>. 2 Artificial intelligence and software engineering The studies of artificial intelligence in general and expert systems in particular make it clear that truly useful problem solvers must be constructed in a quite different way than has been tried in the past. Among the problems with current approaches are: 1. <p> The operational semantics of the language is based on instance predicates, relating names of formulas such that one is an instance of the other. As was shown by Kowalski [25, 26] and further developed by Hill & Gallagher <ref> [19] </ref>, such instance predicates can be used with meta-variables replacing names of subexpressions in a way which turns out to be operationally similar to the way in which variables are represented using nonground representations. 11 Conclusion As can be seen from this article, Alloy is a language still under development.
Reference: [20] <author> Jiang, Y., </author> <title> Ambvivalent Logic as the Semantic Basis of Metalogic Programming, </title> <editor> in: P. Van Hentenryck (ed.), </editor> <booktitle> Logic Programming, Proc. 11th Intl. Conf, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: In that case conditions 5-7 are trivially satisfied. The only extra requirement, not part of a standard definition of a model of P , would be (9). In our approach we have not altered the notion of logical consequence, as was done for example by Jiang <ref> [20] </ref>, in order to handle meta-reasoning. Instead we introduce the notion of system structure, following closely the informal semantics, giving us a notion of semantics which is a modest extension of a first order semantics in the sense that the basic building blocks, theory structures, are still first order structures. <p> Furthermore, like naming in Alloy, 26 the structural coding makes it possible to decompound terms and formulas to their least parts and look, for example, at codes of functors. Jiang <ref> [20] </ref> proposes an ambivalent approach to meta-reasoning, by introducing a language called AL where syntactically no distinction is made between terms, formulas or functors.
Reference: [21] <author> Kakas, A. C. and Mancarella, P., </author> <title> Abductive Logic Programming, </title> <booktitle> in: Proc. NACLP90 Workshop on Non-Monotonic Reasoning and Logic Programming, </booktitle> <address> MCC, Austin, Texas, </address> <year> 1990. </year>
Reference-contexts: Abductive reasoning can be carried out in many ways. One way is to add inference rules for abductive reasoning, obtaining new abductive proof procedures <ref> [21] </ref>. However, it is also possible to realize abductive reasoning through meta-level deduction, as suggested by Bowen & Kowalski [8].
Reference: [22] <author> Konolige, K., </author> <title> A Deduction Model of Belief, </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1986. </year>
Reference-contexts: ); D (B; East ); D (C; South )])? Traffic ` p D (C; South ) ` Pass ([D (A; North); D (B; East ); D (C; South )])? q 6.2 Properties of Knowledge Some formalisms intended for knowledge representation, reasoning and meta-reasoning (such as Konolige's modal logic of knowledge <ref> [22] </ref>) build various properties of knowledge or belief into the formalism. Five well-known properties of this kind are (using the notation of Konolige, where bel (S) is the set of beliefs of an agent S, while [S] is the proposition that agent S believes ): Saturation (K).
Reference: [23] <author> Kowalski, R. A., </author> <title> Logic for Problem Solving, </title> <publisher> North Holland, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The rationale is simply that self-reference must be "sanctioned" from outside a theory. 8 Abduction Abduction is a form of reasoning with a purpose to determine hypotheses that explain an observation, typically in the context of knowledge assimilation <ref> [23, 26] </ref>. Abductive reasoning seems particularly interesting in combination with meta-reasoning. Suppose the beliefs of John are represented by 23 a theory Beliefs (John), which internally defines a theory system in which there is a theory Beliefs (Mary), representing John's beliefs about Mary's beliefs.
Reference: [24] <author> Kowalski, R. A., </author> <title> The Use of Metalanguage to Assemble Object Level Programs and Abstract Programs, </title> <type> Report, </type> <institution> Imperial College, </institution> <address> London, </address> <year> 1982. </year>
Reference-contexts: This seems to be the basis for the reasoning part of GETFOL, a system that is also capable of code introspection and revision [17]. Our proposal for a meta-programming based software engineering methodology is related to the proposal by Kowalski about using meta-language for assembling programs <ref> [24] </ref> and the work by Brogi et al. about using theory operators for building programs, which is discussed in more detail in Sect. 6.3. Bowen & Weinberg [6] and Bacha [2] have investigated compilation of partially known clauses in a context similar to ours.
Reference: [25] <author> Kowalski, R. A., </author> <title> Meta Matters, </title> <booktitle> Invited presentation at Second Workshop on Meta-Programming in Logic, </booktitle> <year> 1990. </year>
Reference-contexts: There is an SLD-resolution style inference rule instead of an inference rule for program clauses. It should be obvious for the knowledgeable reader that the development of Alloy is very much inspired by work of Kowalski <ref> [25, 26] </ref>, and by Reflective Prolog of Costantini & Lanzarone [16]. There have recently appeared some proposals for systems for meta-reasoning with a similar philosophy as ours. Attardi & Simi [1] use what they call "relativized truth" but obtain a system quite similar to ours. <p> Christiansen has proposed an amalgamated language in which there are two levels of reasoning [13]. The operational semantics of the language is based on instance predicates, relating names of formulas such that one is an instance of the other. As was shown by Kowalski <ref> [25, 26] </ref> and further developed by Hill & Gallagher [19], such instance predicates can be used with meta-variables replacing names of subexpressions in a way which turns out to be operationally similar to the way in which variables are represented using nonground representations. 11 Conclusion As can be seen from this
Reference: [26] <author> Kowalski, R. A., </author> <title> Problems and Promises of Computational Logic, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The rationale is simply that self-reference must be "sanctioned" from outside a theory. 8 Abduction Abduction is a form of reasoning with a purpose to determine hypotheses that explain an observation, typically in the context of knowledge assimilation <ref> [23, 26] </ref>. Abductive reasoning seems particularly interesting in combination with meta-reasoning. Suppose the beliefs of John are represented by 23 a theory Beliefs (John), which internally defines a theory system in which there is a theory Beliefs (Mary), representing John's beliefs about Mary's beliefs. <p> Denials are already formally present in the language and would then function as integrity constraints when given as part of a program <ref> [26] </ref>. 10 Notes and related work There have been a few changes in the definition of Alloy since our previous publication [4]. 1. Theory terms now include expressions on the form . 2. In addition to program clauses, Alloy now has goals and denials. 3. <p> There is an SLD-resolution style inference rule instead of an inference rule for program clauses. It should be obvious for the knowledgeable reader that the development of Alloy is very much inspired by work of Kowalski <ref> [25, 26] </ref>, and by Reflective Prolog of Costantini & Lanzarone [16]. There have recently appeared some proposals for systems for meta-reasoning with a similar philosophy as ours. Attardi & Simi [1] use what they call "relativized truth" but obtain a system quite similar to ours. <p> Christiansen has proposed an amalgamated language in which there are two levels of reasoning [13]. The operational semantics of the language is based on instance predicates, relating names of formulas such that one is an instance of the other. As was shown by Kowalski <ref> [25, 26] </ref> and further developed by Hill & Gallagher [19], such instance predicates can be used with meta-variables replacing names of subexpressions in a way which turns out to be operationally similar to the way in which variables are represented using nonground representations. 11 Conclusion As can be seen from this
Reference: [27] <author> McCarthy, J., </author> <title> Programs with Common Sense, </title> <editor> in: M. Minsky (ed.), </editor> <booktitle> Semantic Information Processing, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1968. </year>
Reference-contexts: This is the most difficult problem of these three. McCarthy defined a program having common sense as one that "automatically deduces for itself a sufficiently wide class of immediate consequences of anything it is told and what it already knows" <ref> [27] </ref>. The heuristics for exploring the interesting consequences of new information or finding the information necessary for solving a problem are naturally expressed as meta-knowledge. These heuristics might need to be revised over time, as they turn out to be more or less successful.
Reference: [28] <author> McCarthy, J., </author> <title> First Order Theories of Individual Concepts and Propositions, </title> <editor> in: B. Meltzer and D. Michie (eds.), </editor> <booktitle> Machine Intelligence 9, </booktitle> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1979. </year>
Reference-contexts: For example, we could write a program that simulates the reasoning of a collection of agents, representing the beliefs of each agent as a theory (if we employ the "sentential" view of beliefs, perhaps first used explicitly by McCarthy <ref> [28] </ref>). If the language prevents us from having more than one theory in our program, then these "internal" theories have to be represented in some other way, perhaps as data structures with the programmer writing an ad hoc interpreter to simulate inference.
Reference: [29] <author> Sato, T., </author> <title> Meta-Programming through a Truth Predicate, </title> <editor> in: K. Apt (ed.), </editor> <booktitle> Proc. Joint Intl. Conf. Symp. on Logic Programming 1992, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Bowen & Weinberg [6] and Bacha [2] have investigated compilation of partially known clauses in a context similar to ours. Sato <ref> [29] </ref> proposes an approach to meta-programming through a complete truth predicate tr in three valued logic. Sato's definition of tr is self referential, and gives in the general case an inconsistent definition of tr in two valued logic by being paradoxical.
Reference: [30] <author> Smorynski, C., </author> <title> The Incompleteness Theorems, </title> <editor> in: J. Barwise (ed.), </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: Both these principles are valid for every theory system. The traditional local reflection principle for a single theory T in mathematical logic <ref> [30] </ref> reads Pr T ( p q ) ) and states the correspondence between a provability statement and what is to be proved, namely that if the provability predicate holds for an encoding of a formula , then holds as well.
Reference: [31] <author> Sterling, L. S., </author> <title> Logical Levels of Problem Solving, </title> <journal> J. Logic Programming, </journal> <volume> 1 </volume> <month> 138-45 </month> <year> (1984). </year>
Reference-contexts: Low adaptability of problem solving methods. 3. Failure to capture "common sense" reasoning. 1 These problems are indeed very difficult but we believe that the marginal success so far is largely because the attempts at addressing them have been carried out mostly using single-level architectures (cf. Sterling <ref> [31] </ref>). By single-level architectures we mean systems without provisions for reasoning about any part of their own beliefs or procedures and for adapting themselves according to these observations. The three problems mentioned above could be approached as follows: 1. <p> We shall show how fragments of these applications can be programmed elegantly in Alloy. Our ambition is twofold. Firstly, we wish to convince the reader of the strength and versatility of meta-programming with theory systems, continuing and extending the work by Bowen & Kowal-ski [8], Sterling <ref> [31] </ref>, Bowen [7], Brogi & Turini [12] and others.
Reference: [32] <author> Warren, D. H. D., </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year> <month> 30 </month>
Reference-contexts: Such achievement of abductive reasoning through meta-reasoning is a topic that ought to be explored further using theory systems. 9 Implementation and language extensions In our implementation efforts, we are extending Luther [5], an instance of Warren's abstract Prolog machine <ref> [32] </ref>. The idea is that the generalized SLD-resolution rule should be essentially as efficient as in Prolog, regardless of the number of "indirection" levels.
References-found: 32

