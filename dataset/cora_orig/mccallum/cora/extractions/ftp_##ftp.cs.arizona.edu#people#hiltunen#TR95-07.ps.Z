URL: ftp://ftp.cs.arizona.edu/people/hiltunen/TR95-07.ps.Z
Refering-URL: http://www.cs.arizona.edu/cactus/public.html
Root-URL: http://www.cs.arizona.edu
Title: Understanding Membership  
Author: Matti A. Hiltunen Richard D. Schlichting 
Note: TR 95-07  
Abstract-found: 0
Intro-found: 1
Reference: [AD76] <author> P. Alsberg and J. Day. </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proceedings of the 2nd International Conference on Software Engineering, </booktitle> <pages> pages 562-570, </pages> <month> Oct </month> <year> 1976. </year> <month> 27 </month>
Reference-contexts: This is similar in intent to the way partitions are handled in some database systems, where techniques such as primary copy <ref> [AD76] </ref>, tokens [MW82], and voting [Tho79] are used to ensure that only one partition remains active. The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application.
Reference: [ADKM92a] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proceedings of the 6th International Workshop on Distributed Algorithms (Lecture Notes in Computer Science 647), </booktitle> <pages> pages 292-312, </pages> <address> Haifa, Israel, </address> <month> Nov </month> <year> 1992. </year>
Reference-contexts: Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul [MPS92], and Transis <ref> [ADKM92a, ADKM92b] </ref>, delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including [Cri91, AMMS + 93, RFJ93, SR93], set-based services.
Reference: [ADKM92b] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <booktitle> In Proceedings of the 22nd International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <address> Boston, </address> <month> Jul </month> <year> 1992. </year>
Reference-contexts: Finally, note that the concept of a graph of messages is very appealing as an implementation tool as well. For example, this technique is closely related to the causality graphs used in Psync [PBS89] and Transis <ref> [ADKM92b] </ref>, which capture the causal ordering relationship between messages. 4 3 Properties of Membership Services 3.1 Overview A membership service can be viewed as a protocol layer that generates messages indicating changes in membership and forwards them to higher levels. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul [MPS92], and Transis <ref> [ADKM92a, ADKM92b] </ref>, delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including [Cri91, AMMS + 93, RFJ93, SR93], set-based services.
Reference: [AMMS + 93] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Ciarfella. </author> <title> Fast message ordering and membership using a logical token-passing ring. </title> <booktitle> In Proceedings of the 13th International IEEE Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Section 5 uses the framework constructed in previous sections to characterize a number of existing membership services, including those is Consul [MPS93], ISIS [BJ87], Mars [KGR91], and Totem <ref> [AMMS + 93] </ref>. Finally, section 6 offers some concluding remarks. 2 Message Ordering Graphs The following notation is used in this and subsequent sections. <p> This is acceptable in cases where the actual membership of the destination group is not important, but stronger guarantees are useful in some cases. Extended virtual synchrony extends virtual synchrony by guaranteeing that all messages sent under the old membership are also delivered before the membership change message <ref> [AMMS + 93] </ref>. Extended virtual synchrony can be defined more formally as follows. <p> Figure 10 illustrates this property; the shaded circles represent messages that are sent before receiving the membership change message M (C). Extended virtual synchrony has been explored in a number of papers, especially <ref> [AMMS + 93] </ref> and [MAMSA94]. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> Although not guaranteed by the basic algorithm, agreement on successors and predecessors is easy to implement given the communication system and failure assumptions. 24 5.6 Totem The Totem message ordering and membership protocol is described in <ref> [AMMS + 93] </ref>. The protocol is based on a logical token passing scheme, where the token is used for total ordering of messages, reliable message transmission, flow control, and membership. All messages in Totem are totally ordered reliable multicasts.
Reference: [BG93] <author> K. Birman and B. Glade. </author> <title> Consistent failure reporting in reliable communication systems. </title> <type> Technical Report 93-1349, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: A special case of liveness is bounded liveness, where the failure or recovery is detected within a known bounded time. In an asynchronous system, a service can be either accurate or live, but not both <ref> [BG93] </ref>, whereas in synchronous systems both properties can be guaranteed at the same time. An example of an accurate service that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93].
Reference: [Bir85] <author> K. Birman. </author> <title> Replication and fault-tolerance in the ISIS system. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 79-86, </pages> <address> Orcas Island, WA, </address> <month> Dec </month> <year> 1985. </year>
Reference-contexts: On the other hand, if agreement is being enforced, other techniques must be used to ensure that the membership information of the recovering site is consistent with other sites. Possibilities here include replay of missed messages [MPS93] or explicit state transfer from another site <ref> [Bir85, BJ87] </ref>. Once a new state has been established by the membership layer, the appropriate recovery message R (C) is multicast and subsequently delivered to the application. <p> Note that this requires knowing a priori the maximum number of sites. Such a requirement is satisfied in systems that either start with a list of group members (e.g., [MPS93]), have a permanent list of possible sites that can participate (e.g., <ref> [Bir85] </ref>), or where the physical configuration implies that the identity of all sites is known and fixed (e.g., [KGR91]).
Reference: [BJ87] <author> K. Birman and T. Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> Feb </month> <year> 1987. </year>
Reference-contexts: The properties enforced by the protocols also vary, ranging from ones that offer very weak properties [RFJ93, GT92, Hil95] to others such as ISIS that guarantee strong properties [BSS91]. The tradeoff is the strength of the guarantee versus the execution cost. For example, the property called virtual synchrony <ref> [BJ87] </ref> guarantees that messages reflecting membership change events are delivered to the application by the membership layer at every site at precisely the same point in the message stream. Weaker properties provide less rigorous guarantees, but are correspondingly cheaper to implement. <p> A discussion of the way in which properties are related is found in section 4, along with a dependency graph that summarizes these relationships. Section 5 uses the framework constructed in previous sections to characterize a number of existing membership services, including those is Consul [MPS93], ISIS <ref> [BJ87] </ref>, Mars [KGR91], and Totem [AMMS + 93]. Finally, section 6 offers some concluding remarks. 2 Message Ordering Graphs The following notation is used in this and subsequent sections. <p> On the other hand, if agreement is being enforced, other techniques must be used to ensure that the membership information of the recovering site is consistent with other sites. Possibilities here include replay of missed messages [MPS93] or explicit state transfer from another site <ref> [Bir85, BJ87] </ref>. Once a new state has been established by the membership layer, the appropriate recovery message R (C) is multicast and subsequently delivered to the application. <p> The service also guarantees agreement on first and last messages, as well as agreement on successors. 22 5.3 ISIS The membership service of ISIS described in <ref> [BJ87] </ref> consists of a distributed site view management component and an ordered multicast primitive (GBCAST) that is used to multicast and order membership change messages to ensure virtual synchrony. Site failures are detected by sending Hello messages between sites.
Reference: [BS95] <author> N. T. Bhatti and R. D. Schlichting. </author> <title> A system for constructing configurable high-level protocols. </title> <booktitle> In Proceedings of SIGCOMM '95, </booktitle> <address> Cambridge, MA, </address> <month> Aug </month> <year> 1995. </year>
Reference-contexts: Such an approach can be realized by implementing each property as a separate software module and then combining the appropriate modules within a standard software infrastructure to produce a customized system <ref> [BS95, HS93] </ref>. This paper is organized as follows. Section 2 describes the details of message ordering graphs and other aspects of our computational model. Properties of membership services are then presented in section 3; these range from message ordering properties to properties related to handling partitions. <p> Inclusions, on the other hand, are used to express relationships between different variants addressing the same aspect of membership, such as different ways in message ordering can be performed. In a system such as <ref> [BS95] </ref> in which properties are implemented by separate software modules, dependencies dictate that a given module be included in any configuration if another that depends on it is also included, while inclusions indicate a choice of modules implementing variants of a property. <p> More advanced services provide agreement augmented with various ordering and other properties. The inherently large number of combinations represented by the graph means that it can serve as a useful tool for configuring custom membership services for systems such as <ref> [BS95] </ref> mentioned above. In this case, the designer first chooses properties to be guaranteed, and then takes the transitive closure of these nodes in the graph to determine the set of properties that must be included. <p> The current prototype runs on Mach-based DecStation 5000/240s and is based on extending the hierarchical model of the x-kernel [HP91] to support finer-grain composition <ref> [BS95] </ref>. Acknowledgements The comments from Laura Sabel and Keith Marzullo on an earlier version of the paper greatly improved the presentation.
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: The properties enforced by the protocols also vary, ranging from ones that offer very weak properties [RFJ93, GT92, Hil95] to others such as ISIS that guarantee strong properties <ref> [BSS91] </ref>. The tradeoff is the strength of the guarantee versus the execution cost. For example, the property called virtual synchrony [BJ87] guarantees that messages reflecting membership change events are delivered to the application by the membership layer at every site at precisely the same point in the message stream. <p> An example of an accurate service that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. However, most membership services for asynchronous systems have chosen to be live but not accurate, for example, ISIS <ref> [BSS91] </ref> and Consul [MPS93]. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions. <p> on predecessors property can also be defined. 3.4.5 Virtual Synchrony Virtual synchrony restricts the delivery order of application and membership change messages in such a way that it appears to the application as if events are occurring synchronously even though they are actually occurring on different sites at different times <ref> [BSS91] </ref>. Virtual synchrony is easy to explain in the ordering graph, as illustrated in Figure 9. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS <ref> [BSS91] </ref>, Consul [MPS92], and Transis [ADKM92a, ADKM92b], delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs.
Reference: [Cri91] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94]. <p> To deal with potentially inaccurate decisions, suspected sites that have in fact not failed are often isolated from the group and forced to fail and then recover before continuing execution. Examples of synchronous membership protocols that are both accurate and live are the protocols proposed in <ref> [Cri91] </ref>. Note, however, that a synchronous system is an abstraction that is maintained only as long as the the bounded delivery time assumption is not violated. As a result, if this assumption is violated, a detection algorithm that is intended to be live and accurate will lose its accuracy characteristics. <p> by guaranteeing that all sites share the same view of the membership or are knowingly in a transition state. 3.5.2 Timebound Synchrony Timebound synchrony is a property of membership services in synchronous systems in which every site delivers a given membership change message within some known interval of real time <ref> [KGR91, Cri91] </ref>. The property has the same general applicability as external synchrony, but reduces the synchronization overhead by shrinking the window during which the membership is not identical on all sites. <p> In this section, we describe properties that specify more precisely how these failure notification and join messages are generated and delivered. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. In this case, membership properties such as the ordering properties described above will be guaranteed only as long as no partitions occur. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> ISIS deals with partitions by allowing computation to continue in at most one partition, an approach supported by the augmented failure notification technique described in section 3.7.2. 5.4 Cristian's Synchronous Membership Protocols In <ref> [Cri91] </ref>, Cristian presents three group membership protocols built on the assumption that the underlying system provides synchronous reliable atomic broadcast primitives. The protocols handle faulty sites leaving the membership and fault-free or repaired processors joining. <p> Another protocol, the attendance list protocol, reduces message overhead in the absence of joins and failures by circulating an attendance list through all sites once per period instead of using Present messages. The protocols proposed by Cristian guarantee a number of properties. In the terminology of <ref> [Cri91] </ref>, these include the following: * Agreement on group membership: Any two sites in the same group have identical membership views. 23 * Reflexivity: A site that has joined the group belongs to the membership (excludes the trivial solution of an empty membership list). * Bounded join delay: The time for
Reference: [DMS94] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. An asynchronous membership protocol that tolerates partitions. </title> <type> Technical Report CS94-6, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <month> Mar </month> <year> 1994. </year>
Reference-contexts: The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application. To address this problem, some services allow computation to proceed in all partitions <ref> [DMS94, Hil95, MAMSA94, RFJ93] </ref>. A problem with this approach is that it requires the application to deal with the difficult problem of merging states that potentially diverged once the partitioned sites rejoin. Variants of these approaches are also possible depending on the specifics of the application.
Reference: [EL90] <author> P. D. Ezhilchelvan and R. Lemos. </author> <title> A robust group membership algorithm for distributed real-time system. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <pages> pages 173-179, </pages> <address> Lake Buena Vista, Florida, </address> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94].
Reference: [EL95] <author> K. Echtle and M. Leu. </author> <title> Fault-detecting network membership protocols for unknown topologies. </title> <editor> In F. Cristian, G. Le Lann, and T. Lunt, editors, </editor> <booktitle> Dependable Computing for Critical Applications 4, </booktitle> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1995. </year>
Reference: [GT92] <author> R. A. Golding and K. Taylor. </author> <title> Group membership in the epidemic style. </title> <type> Technical Report UCSC-CRL-92-13, </type> <institution> University of California, Santa Cruz, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The properties enforced by the protocols also vary, ranging from ones that offer very weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others such as ISIS that guarantee strong properties [BSS91]. The tradeoff is the strength of the guarantee versus the execution cost.
Reference: [Hil95] <author> M. A. Hiltunen. </author> <title> Membership and system diagnosis. </title> <booktitle> In Proceedings of the 14th IEEE Symposium on Reliable Distributed Systems, </booktitle> <address> Bad Neuenahr, Germany, </address> <month> Sept </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: The properties enforced by the protocols also vary, ranging from ones that offer very weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others such as ISIS that guarantee strong properties [BSS91]. The tradeoff is the strength of the guarantee versus the execution cost. <p> The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application. To address this problem, some services allow computation to proceed in all partitions <ref> [DMS94, Hil95, MAMSA94, RFJ93] </ref>. A problem with this approach is that it requires the application to deal with the difficult problem of merging states that potentially diverged once the partitioned sites rejoin. Variants of these approaches are also possible depending on the specifics of the application.
Reference: [Hil96] <author> M. A. Hiltunen. </author> <title> Configurable Distributed Fault-Tolerant Services. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: Inclusion is argued similarly. Examples of formal dependency arguments using expanded property definitions can be found in <ref> [Hil96] </ref>. It is also worth noting that, although dependency and inclusion are expressed in the same way formally, the two concepts are worth separating for practical reasons.
Reference: [HP91] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Research will also continue on a system that allows membership services to be implemented by configuring software modules realizing individual properties in a common software infrastructure [HS94]. The current prototype runs on Mach-based DecStation 5000/240s and is based on extending the hierarchical model of the x-kernel <ref> [HP91] </ref> to support finer-grain composition [BS95]. Acknowledgements The comments from Laura Sabel and Keith Marzullo on an earlier version of the paper greatly improved the presentation.
Reference: [HS93] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> An approach to constructing modular fault-tolerant protocols. </title> <booktitle> In Proceedings of the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 105-114, </pages> <address> Princeton, NJ, USA, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Such an approach can be realized by implementing each property as a separate software module and then combining the appropriate modules within a standard software infrastructure to produce a customized system <ref> [BS95, HS93] </ref>. This paper is organized as follows. Section 2 describes the details of message ordering graphs and other aspects of our computational model. Properties of membership services are then presented in section 3; these range from message ordering properties to properties related to handling partitions.
Reference: [HS94] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> A configurable membership service. </title> <type> Technical Report 94-37, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> Dec </month> <year> 1994. </year>
Reference-contexts: Future work will include identifying additional properties of membership and specifying them using the ordering graph approach. Research will also continue on a system that allows membership services to be implemented by configuring software modules realizing individual properties in a common software infrastructure <ref> [HS94] </ref>. The current prototype runs on Mach-based DecStation 5000/240s and is based on extending the hierarchical model of the x-kernel [HP91] to support finer-grain composition [BS95]. Acknowledgements The comments from Laura Sabel and Keith Marzullo on an earlier version of the paper greatly improved the presentation.
Reference: [HS95] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> Properties of membership services. </title> <booktitle> In Proceedings of the 2nd International Symposium on Autonomous Decentralized Systems, </booktitle> <pages> pages 200-207, </pages> <address> Phoenix, AZ, USA, </address> <month> Apr </month> <year> 1995. </year>
Reference-contexts: Given this view, the properties of a membership service can be defined in terms of what membership change messages it generates and when they are delivered to the application <ref> [HS95] </ref>. add application and membership change messages, respectively, to the ordering graph. Although we separate them here logically, in practice the communication and membership component are often tightly bound to one another, and dependencies exist between them.
Reference: [KG94] <author> H. Kopetz and G. Grunsteidl. </author> <title> TTP A protocol for fault-tolerant real-time systems. </title> <journal> Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94].
Reference: [KGR91] <author> H. Kopetz, G. Grunsteidl, and J. Reisinger. </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system. </title> <editor> In A. Avizienis and J.C. Laprie, editors, </editor> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 411-429. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1991. </year> <month> 28 </month>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94]. <p> A discussion of the way in which properties are related is found in section 4, along with a dependency graph that summarizes these relationships. Section 5 uses the framework constructed in previous sections to characterize a number of existing membership services, including those is Consul [MPS93], ISIS [BJ87], Mars <ref> [KGR91] </ref>, and Totem [AMMS + 93]. Finally, section 6 offers some concluding remarks. 2 Message Ordering Graphs The following notation is used in this and subsequent sections. <p> As a result, if this assumption is violated, a detection algorithm that is intended to be live and accurate will lose its accuracy characteristics. This scenario is acknowledged and handled, for example, in the design of Mars <ref> [KGR91] </ref>. Accuracy and liveness can be defined more formally in terms of ordering graphs. Let A and B be arbitrary sites and F (B i ) and R (B j ) be membership change messages indicating the failure (of incarnation i) and recovery (of incarnation j) of site B, respectively. <p> by guaranteeing that all sites share the same view of the membership or are knowingly in a transition state. 3.5.2 Timebound Synchrony Timebound synchrony is a property of membership services in synchronous systems in which every site delivers a given membership change message within some known interval of real time <ref> [KGR91, Cri91] </ref>. The property has the same general applicability as external synchrony, but reduces the synchronization overhead by shrinking the window during which the membership is not identical on all sites. <p> In this section, we describe properties that specify more precisely how these failure notification and join messages are generated and delivered. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. In this case, membership properties such as the ordering properties described above will be guaranteed only as long as no partitions occur. <p> Such a requirement is satisfied in systems that either start with a list of group members (e.g., [MPS93]), have a permanent list of possible sites that can participate (e.g., [Bir85]), or where the physical configuration implies that the identity of all sites is known and fixed (e.g., <ref> [KGR91] </ref>). A majority predicate of this type is easy to implement in the membership layer, assuming that the service guarantees agreement and total order, and has knowledge about the maximum size of the group. <p> Note that these protocols do not attempt to order membership changes with respect to application messages. 5.5 Mars The membership service in the Mars system is another example of a synchronous protocol <ref> [KGR91] </ref>. Mars builds on a physical ring architecture in which the network is accessed using a time division multiple access (TDMA) strategy based on common global time, i.e., access to the physical medium is divided into dedicated time slots that are allocated a priori to sites in a round-robin fashion.
Reference: [LE90] <author> R. Lemos and P. Ezhilchelvan. </author> <title> Agreement on the group membership in synchronous distributed systems. </title> <booktitle> In Proceedings of the 4th International Workshop on Distributed Algorithms, </booktitle> <address> Otranto, Italy, </address> <month> Sep </month> <year> 1990. </year>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94].
Reference: [MAMSA94] <author> L. Moser, Y. Amir, P. Melliar-Smith, and D. Agarwal. </author> <title> Extended virtual synchrony. </title> <booktitle> In Proceedings of the 14th IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 56-65, </pages> <address> Poznan, Poland, </address> <month> Jun </month> <year> 1994. </year>
Reference-contexts: Figure 10 illustrates this property; the shaded circles represent messages that are sent before receiving the membership change message M (C). Extended virtual synchrony has been explored in a number of papers, especially [AMMS + 93] and <ref> [MAMSA94] </ref>. <p> The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application. To address this problem, some services allow computation to proceed in all partitions <ref> [DMS94, Hil95, MAMSA94, RFJ93] </ref>. A problem with this approach is that it requires the application to deal with the difficult problem of merging states that potentially diverged once the partitioned sites rejoin. Variants of these approaches are also possible depending on the specifics of the application. <p> Of course, the difficult semantic problems associated with merging application states remain. 19 Our extended virtual synchrony with partitions property is derived from extended virtual synchrony as described in <ref> [MAMSA94] </ref>.
Reference: [MPS89] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Implementing replicated objects using Psync. </title> <booktitle> In Proceedings of the 8th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 42-52, </pages> <address> Seattle, Washington, </address> <month> Oct </month> <year> 1989. </year>
Reference-contexts: These services are then summarized in tabular form in section 5.8. 5.2 Consul The membership service of the Consul system [MPS92, MPS93] assumes asynchronous communication and sites that experience crash or performance failures. The service is built using Psync <ref> [PBS89, MPS89] </ref>, a multicast service that preserves the causal ordering of messages using a context graph abstraction. Psync guarantees reliable multicast communication, so that context graphs on various sites are identical except for transmission delays.
Reference: [MPS92] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <booktitle> Dependable Computing for Critical Applications 2, </booktitle> <pages> pages 309-331. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1992. </year>
Reference-contexts: Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site [RB91, RFJ93, SM94] to all functioning sites <ref> [MPS92] </ref>. In the following, single site suspicion is used to specify the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. In general, the use of voted decisions has not been explored widely in the context of membership services. <p> In this section, we describe properties that specify more precisely how these failure notification and join messages are generated and delivered. A number of different approaches are used in membership services to deal with partitions. One common approach is simply to assume they will not occur <ref> [Cri91, KGR91, MPS92] </ref>. This can be justified by increasing the connectivity of the network or by using other architectural assumptions. In this case, membership properties such as the ordering properties described above will be guaranteed only as long as no partitions occur. <p> Furthermore, membership services are not uniform in how they interact with the application. In our approach, a service signals membership changes by forwarding membership change messages to the application in the regular message stream. We call services that follow this approach, including ISIS [BSS91], Consul <ref> [MPS92] </ref>, and Transis [ADKM92a, ADKM92b], delta-based services since they deliver the changes (deltas) to the application. Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. <p> This section gives an overview of several existing membership services and characterizes their properties using the terminology defined in this paper. These services are then summarized in tabular form in section 5.8. 5.2 Consul The membership service of the Consul system <ref> [MPS92, MPS93] </ref> assumes asynchronous communication and sites that experience crash or performance failures. The service is built using Psync [PBS89, MPS89], a multicast service that preserves the causal ordering of messages using a context graph abstraction.
Reference: [MPS93] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed System Engineering, </journal> <volume> 1 </volume> <pages> 87-103, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: A discussion of the way in which properties are related is found in section 4, along with a dependency graph that summarizes these relationships. Section 5 uses the framework constructed in previous sections to characterize a number of existing membership services, including those is Consul <ref> [MPS93] </ref>, ISIS [BJ87], Mars [KGR91], and Totem [AMMS + 93]. Finally, section 6 offers some concluding remarks. 2 Message Ordering Graphs The following notation is used in this and subsequent sections. <p> An example of an accurate service that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery [OIOP93]. However, most membership services for asynchronous systems have chosen to be live but not accurate, for example, ISIS [BSS91] and Consul <ref> [MPS93] </ref>. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions. <p> Collective startup is generally easier to handle since sites are known a priori, and can have implementation advantages if the initial membership is also assumed to be the maximum set of sites that might be group members <ref> [MPS93] </ref>. Individual startup is more general, but also more complex. For example, this approach requires some known external mechanism for locating other sites, such as a well-known communication port or a shared name server. <p> On the other hand, if agreement is being enforced, other techniques must be used to ensure that the membership information of the recovering site is consistent with other sites. Possibilities here include replay of missed messages <ref> [MPS93] </ref> or explicit state transfer from another site [Bir85, BJ87]. Once a new state has been established by the membership layer, the appropriate recovery message R (C) is multicast and subsequently delivered to the application. <p> Note that this requires knowing a priori the maximum number of sites. Such a requirement is satisfied in systems that either start with a list of group members (e.g., <ref> [MPS93] </ref>), have a permanent list of possible sites that can participate (e.g., [Bir85]), or where the physical configuration implies that the identity of all sites is known and fixed (e.g., [KGR91]). <p> This section gives an overview of several existing membership services and characterizes their properties using the terminology defined in this paper. These services are then summarized in tabular form in section 5.8. 5.2 Consul The membership service of the Consul system <ref> [MPS92, MPS93] </ref> assumes asynchronous communication and sites that experience crash or performance failures. The service is built using Psync [PBS89, MPS89], a multicast service that preserves the causal ordering of messages using a context graph abstraction.
Reference: [MW82] <author> T. Minoura and G. Wiederhold. </author> <title> Resilient extended true-cope token scheme for a distributed database system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-8(3):173-189, </volume> <month> May </month> <year> 1982. </year>
Reference-contexts: This is similar in intent to the way partitions are handled in some database systems, where techniques such as primary copy [AD76], tokens <ref> [MW82] </ref>, and voting [Tho79] are used to ensure that only one partition remains active. The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application.
Reference: [OIOP93] <author> H. Orman, E. Menze III, S. O'Malley, and L. Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Proceedings of the 3rd Usenix Mach Conference, </booktitle> <pages> pages 75-88, </pages> <month> Apr </month> <year> 1993. </year>
Reference-contexts: An example of an accurate service that is not live is that of Mach, where the failed site notifies others about its own failure upon recovery <ref> [OIOP93] </ref>. However, most membership services for asynchronous systems have chosen to be live but not accurate, for example, ISIS [BSS91] and Consul [MPS93]. The lack of accuracy in such systems comes from the use of timeouts to suspect the failure of a site, a technique that may trigger false suspicions.
Reference: [PBS89] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> Aug </month> <year> 1989. </year>
Reference-contexts: Finally, note that the concept of a graph of messages is very appealing as an implementation tool as well. For example, this technique is closely related to the causality graphs used in Psync <ref> [PBS89] </ref> and Transis [ADKM92b], which capture the causal ordering relationship between messages. 4 3 Properties of Membership Services 3.1 Overview A membership service can be viewed as a protocol layer that generates messages indicating changes in membership and forwards them to higher levels. <p> ) ^ IsCut (succ B (M (C)); O B ) ^ succ A (M (C)) = succ B (M (C)) Among other things, this property is useful for determining message stability, where a message is stable at the sending site once it has been acknowledged by every other operational site <ref> [PBS89] </ref>. If m is an agreed successor of R (C), every site knows that m will have to be acknowledged by site C to be considered stable. <p> Perhaps the simplest solution is to deliver such messages only to sites that were in the partition in which they were sent. This strategy is, however, contrary to the semantics implemented 18 by systems such as Psync <ref> [PBS89] </ref>, which automatically propagates messages of this type to all sites for recovery purposes by virtue of its negative acknowledgment scheme for retransmitting lost messages. Extended virtual synchrony is an example of a stronger property that can be augmented to include partition handling messages. <p> These services are then summarized in tabular form in section 5.8. 5.2 Consul The membership service of the Consul system [MPS92, MPS93] assumes asynchronous communication and sites that experience crash or performance failures. The service is built using Psync <ref> [PBS89, MPS89] </ref>, a multicast service that preserves the causal ordering of messages using a context graph abstraction. Psync guarantees reliable multicast communication, so that context graphs on various sites are identical except for transmission delays.
Reference: [RB91] <author> A. Ricciardi and K. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-353, </pages> <address> Montreal, Quebec, Canada, </address> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Figure 2 illustrates the notation used for ordering graphs in the following sections. Note that ordering graphs are only one method for defining, describing, or illustrating properties of distributed systems. Another approach, used for example in <ref> [RB91] </ref>, is based on describing system behavior by process histories, where the history for process p is a sequence of events including send events, receive events, and internal events. A system run is a set of process histories, one for each process in the set of processes. <p> Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to specify the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> In this case, membership properties such as the ordering properties described above will be guaranteed only as long as no partitions occur. Another approach is to allow the possibility of partitions, but to simplify the problem by allowing execution of the application to proceed only in a single partition <ref> [RB91, SM94] </ref>. This is similar in intent to the way partitions are handled in some database systems, where techniques such as primary copy [AD76], tokens [MW82], and voting [Tho79] are used to ensure that only one partition remains active.
Reference: [Rei94] <author> M. Reiter. </author> <title> A secure group membership protocol. </title> <booktitle> In Proceedings of the 1994 IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 176-189, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Any option between these two extremes is referred to as a voted decision. In general, the use of voted decisions has not been explored widely in the context of membership services. One exception is <ref> [Rei94] </ref>, where voting is used to handle Byzantine failures. Note that detecting failure can be dealt with separately from detecting recovery. A typical solution in asynchronous systems is to have failure detection be live but not accurate, with recovery detection 6 being accurate but not live.
Reference: [RFJ93] <author> R. Rajkumar, S. Fakhouri, and F. Jahanian. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation. In Proceedings of the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, NJ, </address> <month> Oct </month> <year> 1993. </year>
Reference-contexts: The properties enforced by the protocols also vary, ranging from ones that offer very weak properties <ref> [RFJ93, GT92, Hil95] </ref> to others such as ISIS that guarantee strong properties [BSS91]. The tradeoff is the strength of the guarantee versus the execution cost. <p> Also, in contrast to process histories, ordering graphs model more closely the execution of the system and allow the expression of all legal orderings of message receptions in one graph instead of stating them as properties of linear histories. Numerous other methods are also possible. For example, in <ref> [RFJ93] </ref> membership properties are stated in terms of membership runs, which are defined as sequences of global membership states consisting of each site's view of the global membership. Transitions from one global membership state to the next occur whenever a site changes its view of the global membership. <p> Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to specify the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> This property, although implemented by certain weak protocols such as <ref> [RFJ93] </ref>, is insufficient for implementing message ordering properties. <p> change properties extends ordering by adding bounds on when such changes must be applied. 3.5.1 External Synchrony External synchrony guarantees that if a site delivers a given membership change message, all other sites have either already delivered the message or are in a transition state in which delivery is imminent <ref> [RFJ93] </ref>. Having this property ensures that sites move into a new membership state with some degree of coordination, and that all sites have consistent membership information, modulo sites undergoing a transition. <p> The idea is, in fact, related to the concept of barrier synchronization in parallel programs, in which execution at all sites must reach the barrieri.e., move into the transition statebefore any site can proceedi.e., make the membership change. Following <ref> [RFJ93] </ref>, we denote this transition state as state 0. Since underlying layers interact with the application only through messages, any protocol implementing external synchrony requires an extra message to generate a transition into state 0. <p> The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application. To address this problem, some services allow computation to proceed in all partitions <ref> [DMS94, Hil95, MAMSA94, RFJ93] </ref>. A problem with this approach is that it requires the application to deal with the difficult problem of merging states that potentially diverged once the partitioned sites rejoin. Variants of these approaches are also possible depending on the specifics of the application. <p> Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> It also guarantees FIFO ordering of membership messages, extended virtual synchrony, and extended virtual synchrony with partitions. 5.7 Weak, Strong, and Hybrid Membership Protocols A family of three membership protocols labeled as weak, strong, and hybrid is described in <ref> [RFJ93] </ref>. All three deal only with ordering membership views and establishing agreement between views on different sites, with no attempt made to order membership changes with respect to application messages.
Reference: [Sch90] <author> F. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: This is especially true for applications that can be viewed as replicated state machines that change their state when they receive application messages and membership changes <ref> [Sch90] </ref>. 10 Note that, although virtual synchrony is closely related to agreement on successors and predecessors, it is not identical to combining these two properties. This follows because the combination does not require that every message be in one set or the other, whereas virtual synchrony does.
Reference: [SM94] <author> L. Sabel and K. Marzullo. </author> <title> Simulating fail-stop in asynchronous distributed systems. </title> <booktitle> In Proceedings of the 13th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 138-147, </pages> <publisher> Dana Point, </publisher> <address> CA, USA, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Thus, different levels of confidence can be defined by specifying how many sites must agree that a suspected change has occurred before a change indication is forwarded to the application. The possibilities range from a single site <ref> [RB91, RFJ93, SM94] </ref> to all functioning sites [MPS92]. In the following, single site suspicion is used to specify the former and consensus the latter. Any option between these two extremes is referred to as a voted decision. <p> In this case, membership properties such as the ordering properties described above will be guaranteed only as long as no partitions occur. Another approach is to allow the possibility of partitions, but to simplify the problem by allowing execution of the application to proceed only in a single partition <ref> [RB91, SM94] </ref>. This is similar in intent to the way partitions are handled in some database systems, where techniques such as primary copy [AD76], tokens [MW82], and voting [Tho79] are used to ensure that only one partition remains active.
Reference: [SR93] <author> A. Schiper and A. Ricciardi. </author> <title> Virtually-synchronous communication based on a weak failure suspector. </title> <booktitle> In Proceedings of the 23rd International Conference on Fault-Tolerant Computing, </booktitle> <pages> pages 534-543, </pages> <month> Jun </month> <year> 1993. </year>
Reference-contexts: Another approach is for the service to deliver the entire current membership set whenever a (possible) membership change occurs. We call services that follow this approach, including <ref> [Cri91, AMMS + 93, RFJ93, SR93] </ref>, set-based services. Although properties for the two types of services are typically stated differently, mappings between them can usually be constructed in a straightforward manner. <p> The way in which properties relate to one another was illustrated using dependency graphs. As noted in section 5, existing membership services can be characterized in terms of these properties. With the exception of <ref> [SR93] </ref>, however, membership papers concentrate on describing the properties of a particular algorithm or system, rather than providing a more global view. [SR93] gives a decomposition of membership services into three components: Failure Suspector, Multicast Component, and View Component. <p> As noted in section 5, existing membership services can be characterized in terms of these properties. With the exception of <ref> [SR93] </ref>, however, membership papers concentrate on describing the properties of a particular algorithm or system, rather than providing a more global view. [SR93] gives a decomposition of membership services into three components: Failure Suspector, Multicast Component, and View Component. The Failure Suspector is responsible for detecting membership changes and propagating changes that it has detected to other Failure Suspectors. In our framework, this corresponds to change detection properties.
Reference: [Tho79] <author> R. H. Thomas. </author> <title> A majority consensus approach to concurrency control for multiple copy databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(2) </volume> <pages> 180-209, </pages> <month> Jun </month> <year> 1979. </year>
Reference-contexts: This is similar in intent to the way partitions are handled in some database systems, where techniques such as primary copy [AD76], tokens [MW82], and voting <ref> [Tho79] </ref> are used to ensure that only one partition remains active. The drawback of this approach, of course, is that it halts the application's execution in the rest of the system, thereby potentially affecting the progress or availability of the application.
Reference: [vSCA94] <author> P. van der Stok, M. Claessen, and D. Alstein. </author> <title> A hierarchical membership protocol for synchronous distributed systems. </title> <editor> In K. Echtle, D. Hammer, and D. Powell, editors, </editor> <booktitle> Proceedings of the 1st European Dependable Computing Conference (Lecture Notes in Computer Science 852), </booktitle> <pages> pages 599-616, </pages> <address> Berlin, Germany, </address> <month> Oct </month> <year> 1994. </year> <month> 29 </month>
Reference-contexts: Membership services, and membership protocols that implement these services, have been studied extensively, both for synchronous systems where bounds are placed on network transmission time <ref> [Cri91, KGR91, KG94, EL90, LE90, vSCA94] </ref>, and for asynchronous system where no such assumption is made [DMS94, EL95, AMMS + 93, MPS93, RB91, SR93, ADKM92a, GT92, RFJ93, Bir85, SM94].
References-found: 38

