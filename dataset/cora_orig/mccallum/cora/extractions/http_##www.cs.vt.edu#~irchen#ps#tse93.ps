URL: http://www.cs.vt.edu/~irchen/ps/tse93.ps
Refering-URL: http://www.cs.vt.edu/~irchen/
Root-URL: http://www.cs.vt.edu
Title: Modeling and Analysis of Concurrent Maintenance Policies for Data Structures Using Pointers  
Author: Ing-Ray Chen and Sayed A. Banawan 
Abstract: We present a state reduction method that effectively reduces a two-dimensional Markov model to a one-dimensional Markov model for the performance analysis of a class of concurrent data structure maintenance policies. The reduced model allows the derivation of a closed form expression for the average service time per operation and facilitates the identification of priority allocation functions under which (a) the system is stable and (b) the service time per operation is minimized. The applicability of the model is exemplified with a binary tree data structure and the conditions under which concurrent maintenance strategies are better than a conventional incremental maintenance strategy are determined. Index Terms | Client-server computational models, Markov models, state reduction, data structures concurrent maintenance policies, performance evaluation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bahaa-El-Din, W.H., Bastani, F.B., and Teng, J.-E., </author> <title> "Performance analysis of periodic and concurrent data structure maintenance strategies for network servers," </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 15, No. 12, </volume> <month> Dec. </month> <year> 1989, </year> <pages> pp. 1526-1536. </pages>
Reference-contexts: Consequently, an implicit assumption in their study is that the maintenance cost of the background process can always be charged to clients as part of their service times. Moreover, the issue of selecting the priorities of the foreground and background processes were not explored in [2]. In <ref> [1] </ref>, Bahaa-El-Din et al. use an M/G/1 queuing system to model a pure preemptive concurrent maintenance policy in which the background process is invoked only when the foreground process is idle. <p> Hence, the preemptive concurrent policy investigated can only be considered as a variation of the periodic maintenance policy <ref> [1] </ref> . Several aspects distinguish this paper from previous work. <p> In general, i is a function of the degradation level; however, if the priority levels of the foreground and background processes are predetermined, it can be a constant. For example, the pure preemptive policy discussed in <ref> [1] </ref> is a special case of the priority-based policy in which i = 1 for all i since the background process can only upgrade the data structure during periods in which the foreground process is idle and has to release the CPU to the foreground process whenever a request arrives. 5
Reference: [2] <author> Bastani, F.B., Chen, I.R., and Hilal, W., </author> <title> "A model for the stability analysis of maintenance strategies for linear list," </title> <journal> The Computer Journal, </journal> <volume> Vol. 34, No.1, </volume> <month> Feb. </month> <year> 1991, </year> <pages> pp. 80-87. </pages>
Reference-contexts: This assumption may not hold in general because of the variability in service time as a result of different levels of degradation. Bastani et al. <ref> [2] </ref> also use a fluid approximation model to study the stability behavior of a linear list data structure under concurrent maintenance. <p> Consequently, an implicit assumption in their study is that the maintenance cost of the background process can always be charged to clients as part of their service times. Moreover, the issue of selecting the priorities of the foreground and background processes were not explored in <ref> [2] </ref>. In [1], Bahaa-El-Din et al. use an M/G/1 queuing system to model a pure preemptive concurrent maintenance policy in which the background process is invoked only when the foreground process is idle. <p> Hence, the preemptive concurrent policy investigated can only be considered as a variation of the periodic maintenance policy [1] . Several aspects distinguish this paper from previous work. First, unlike <ref> [2] </ref>, we do not make the assumption that the system is always under a heavy traffic condition, rather we keep track of both the state of the foreground process's queue and the level of degradation in the data structure as they change over time using a two-dimensional Markov model. <p> Second, our model addresses the issue of priority allocation, that is, how the priority should be assigned to the foreground and background processes as a function of the arrival rate to stabilize the system and maximize the average service rate. We note that the stability condition under high traffic <ref> [2] </ref> is only a special case of the general solution presented here. We also note that determining the optimal priority is conceptually similar to determining the optimal checkpoint interval as a function of system load in a transaction database system that was addressed in [7, 8].
Reference: [3] <author> Ben-Ari, M., </author> <title> "Algorithms for on-the-fly garbage collection," </title> <journal> ACM Trans. Prog. Langs. and Sys., </journal> <volume> Vol. 6, No.3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 334-344. </pages>
Reference-contexts: It was implemented in the file server of the Cambridge Ring Network [15] which uses a concurrent garbage collector. Two important issues need to be addressed in designing such systems. The first issue is a framework for systematically developing the programs they use <ref> [6, 3, 14] </ref>. The second important issue is evaluating their performance which is the subject of this paper. Hickey and Cohen [9] use a fluid approximation model to evaluate the performance of concurrent garbage collection algorithms assuming that the service time per operation is constant.
Reference: [4] <author> Bernstein, P.A., Hadzilacos, V., and Goodman, N., </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: in a database system that maintains data items (e.g., bank accounts) in a disk-resident data structure (e.g., a binary or B-tree) with goals of minimizing the response time of access operations to the data items and ensuring recoverability of the database systems in the face of system or media failures <ref> [4] </ref>. Here, the clients are operations which are served serially by the data manager. The implementation details of the data structure used by the data manager server are hidden from the clients.
Reference: [5] <author> Chesnaia, A., Gelenbe, E., and Mitrani, I., </author> <title> "On the modeling of parallel access of shared data," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 16, </volume> <month> March </month> <year> 1983, </year> <pages> pp. 196-202. </pages>
Reference: [6] <author> Dijkstra, </author> <title> E.W., </title> <editor> et al., </editor> <title> "On-the-fly garbage collection: An exercise in cooperation", </title> <journal> Comm. ACM, </journal> <volume> Vol. 21, No. 11, </volume> <month> Nov. </month> <year> 1978, </year> <pages> pp. 966-975. </pages>
Reference-contexts: Systems whose performance deteriorates as additional requests are served are said to be "degradable" [14]. Their response time improves when they are upgraded. The approach with foreground/background processes was originally suggested by Dijkstra et al. <ref> [6] </ref> in the specific context of garbage collection. It was implemented in the file server of the Cambridge Ring Network [15] which uses a concurrent garbage collector. Two important issues need to be addressed in designing such systems. <p> It was implemented in the file server of the Cambridge Ring Network [15] which uses a concurrent garbage collector. Two important issues need to be addressed in designing such systems. The first issue is a framework for systematically developing the programs they use <ref> [6, 3, 14] </ref>. The second important issue is evaluating their performance which is the subject of this paper. Hickey and Cohen [9] use a fluid approximation model to evaluate the performance of concurrent garbage collection algorithms assuming that the service time per operation is constant.
Reference: [7] <author> Gelenbe, E., </author> <title> "On the optimal checkpoint interval," </title> <journal> Journal of ACM, </journal> <volume> Vol. 26, No. 2, </volume> <month> April </month> <year> 1979, </year> <pages> pp. 259-270. </pages>
Reference-contexts: We also note that determining the optimal priority is conceptually similar to determining the optimal checkpoint interval as a function of system load in a transaction database system that was addressed in <ref> [7, 8] </ref>. Lastly, our results are obtained via a state reduction technique that effectively reduces a two-dimensional, namely, population and degradation level, Markov model to a one-dimensional (i.e., degradation level only) model that can be solved analytically.
Reference: [8] <author> Gelenbe, E. and Hernandez, M., </author> <title> "Optimal checkpoints with age dependent failures", </title> <journal> Acta Informatica, </journal> <volume> 27, </volume> <year> 1990, </year> <pages> pp. 519-531. 23 </pages>
Reference-contexts: We also note that determining the optimal priority is conceptually similar to determining the optimal checkpoint interval as a function of system load in a transaction database system that was addressed in <ref> [7, 8] </ref>. Lastly, our results are obtained via a state reduction technique that effectively reduces a two-dimensional, namely, population and degradation level, Markov model to a one-dimensional (i.e., degradation level only) model that can be solved analytically.
Reference: [9] <author> Hickey, T., and Cohen, J., </author> <title> "Performance analysis of on-the-fly garbage collection," </title> <journal> Comm. ACM, </journal> <volume> Vol. 27, No. 11, </volume> <month> Nov. </month> <year> 1984, </year> <pages> pp. 1143-1154. </pages>
Reference-contexts: Two important issues need to be addressed in designing such systems. The first issue is a framework for systematically developing the programs they use [6, 3, 14]. The second important issue is evaluating their performance which is the subject of this paper. Hickey and Cohen <ref> [9] </ref> use a fluid approximation model to evaluate the performance of concurrent garbage collection algorithms assuming that the service time per operation is constant. This assumption may not hold in general because of the variability in service time as a result of different levels of degradation.
Reference: [10] <author> Leung, </author> <title> C.H.C., "Dynamic storage fragmentation and file deterioration," </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 12, No. 12, </volume> <month> Dec. </month> <year> 1986, </year> <pages> pp. 436-441. </pages>
Reference-contexts: For example, removing a deleted node from a binary tree requires reorganizing the tree structure if the deleted node has two non-empty subtrees. If the data structure is disk-resident, then file reorganization (e.g., compaction <ref> [10] </ref>) may also be required to reduce the disk access time per operation. The foreground process leaves these time-consuming tasks to the background process. 4 3. Both the foreground process and the background process run on the same processor.
Reference: [11] <author> Kleinrock, L., </author> <title> Queueing Systems, Vol. 1: Theory, </title> <publisher> John Wiley and Sons, </publisher> <year> 1975. </year>
Reference-contexts: All birth rates are equal to , and all death rates are equal to q i i . In other words, it can be treated as an M/M/1 queuing system. Therefore, i can be computed from the utilization of an M/M/1 queuing system <ref> [11] </ref> with a constant arrival rate and a constant service rate q i i . 8 Thus, for all degradation level i, we have i= &gt; &lt; 1 otherwise (1) where i is the CPU relative priority of the foreground process at degradation level i and 0 = 1.
Reference: [12] <author> Lazowska, E.D., Zahorjan, J., Graham, G.S., and Sevcik, K.C., </author> <title> Quantitative System Performance: Computer System Analysis Using Queueing Network Models., </title> <publisher> Prentice Hall, </publisher> <year> 1984. </year>
Reference-contexts: For a small enough q value (e.g., &lt; 0:25) such that the degradation level changes slowly compared to the change in queue length, the system can reach a local equilibrium <ref> [12] </ref> with respect to its queue length at each degradation level i, thus it behaves like an M/M/1 queue with service rate q i i and arrival rate .
Reference: [13] <author> Maruyama, U., and Smith, S., </author> <title> "Optimal reorganization of distributed space disk files" Comm. </title> <journal> ACM, </journal> <volume> Vol. 19, No. 11, </volume> <month> Nov. </month> <year> 1976, </year> <pages> pp. 245-247. </pages>
Reference: [14] <author> Moitra, A., Iyengar, S.S. Bastani, F.B., and Yen, </author> <title> I.L., "Multilevel data structures: models and performance," </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 14, No. 6, </volume> <month> June </month> <year> 1988, </year> <pages> pp. 858-867. </pages>
Reference-contexts: As more and more requests are served, the performance of the foreground process deteriorates and the background process must perform an "upgrade" to the data structure. Systems whose performance deteriorates as additional requests are served are said to be "degradable" <ref> [14] </ref>. Their response time improves when they are upgraded. The approach with foreground/background processes was originally suggested by Dijkstra et al. [6] in the specific context of garbage collection. It was implemented in the file server of the Cambridge Ring Network [15] which uses a concurrent garbage collector. <p> It was implemented in the file server of the Cambridge Ring Network [15] which uses a concurrent garbage collector. Two important issues need to be addressed in designing such systems. The first issue is a framework for systematically developing the programs they use <ref> [6, 3, 14] </ref>. The second important issue is evaluating their performance which is the subject of this paper. Hickey and Cohen [9] use a fluid approximation model to evaluate the performance of concurrent garbage collection algorithms assuming that the service time per operation is constant.
Reference: [15] <author> Needham, R.M., and Herbert, A.J., </author> <title> The Cambridge Distributed Computing System, </title> <publisher> Addison-Wesley, </publisher> <year> 1982. </year>
Reference-contexts: Their response time improves when they are upgraded. The approach with foreground/background processes was originally suggested by Dijkstra et al. [6] in the specific context of garbage collection. It was implemented in the file server of the Cambridge Ring Network <ref> [15] </ref> which uses a concurrent garbage collector. Two important issues need to be addressed in designing such systems. The first issue is a framework for systematically developing the programs they use [6, 3, 14]. The second important issue is evaluating their performance which is the subject of this paper.
Reference: [16] <author> Sahner, R.A., and Trivedi, </author> <title> K.S., "A hierarchical, combinatorial-Markov method of solving complex reliability models," </title> <booktitle> Proc. 1986 Fall Joint Computer Conference, AFIPS, </booktitle> <address> New York, </address> <pages> pp. 817-825. </pages>
Reference-contexts: State reduction is achieved by coalescing all the states with the same degradation level into a single state. We develop this technique because traditional techniques for reducing the state space of finite Markov chains such as state merging [18] and hierarchical modeling <ref> [16] </ref> cannot be applied to our two-dimensional Markov model that has 3 an infinite number of states. Alternatively, the two-dimensional model may be solved numerically, but this approach requires truncating the state space in addition to being laborious. The rest of the paper is organized as follows.
Reference: [17] <author> Sauer, C.H., and Chandy, K.M., </author> <title> Computer System Performance Modeling, </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: PRI b (i) : the priority level of the background process at degradation level i i : the CPU relative priority of the foreground process at degradation level i. i : the CPU relative priority of the background process at degradation level i. 3 The Model We use global balance <ref> [17] </ref> to solve the underlying Markov model that describes the server's behavior under concurrent maintenance policies at the steady state.
Reference: [18] <author> Shooman, </author> <title> M.L., and Laemmel, A.E., "Simplification of Markov models by state merging," </title> <booktitle> Proc. 1987 Annual Reliability and Maintainability Symposium, IEEE, </booktitle> <address> New York, </address> <pages> pp. 159-164. </pages>
Reference-contexts: State reduction is achieved by coalescing all the states with the same degradation level into a single state. We develop this technique because traditional techniques for reducing the state space of finite Markov chains such as state merging <ref> [18] </ref> and hierarchical modeling [16] cannot be applied to our two-dimensional Markov model that has 3 an infinite number of states. Alternatively, the two-dimensional model may be solved numerically, but this approach requires truncating the state space in addition to being laborious.
Reference: [19] <author> Tenenbaum, A.M., and Augenstein, M.J., </author> <title> Data Structure Using Pascal, </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year> <month> 24 </month>
Reference-contexts: Then it reorganizes the tree rooted at p before it unlocks those nodes. After the reorganization, the space occupied by the deleted node n is added to the Avail record list. The reorganization of the subtree rooted at a deleted node's parent follows a standard deletion algorithm <ref> [19] </ref>: if the node to be deleted has no children, it is removed without further adjustment to the tree; if the node to be deleted has only one child, its single child can be moved up to take its place; and if the node to be deleted has two subtrees, its
References-found: 19

