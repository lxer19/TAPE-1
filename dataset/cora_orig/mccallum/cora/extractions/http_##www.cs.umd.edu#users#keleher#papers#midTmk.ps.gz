URL: http://www.cs.umd.edu/users/keleher/papers/midTmk.ps.gz
Refering-URL: http://www.cs.umd.edu/users/keleher/syllabus.818.html
Root-URL: 
Title: A Comparison of Entry Consistency and Lazy Release Consistency Implementations Removed for blind review  
Abstract: This paper compares three different implementations of distributed shared memory on networks of workstations: (i) an entry-consistent DSM using software dirty bits (EC-sdb), (ii) an entry-consistent DSM using diffing (EC-diff), and (iii) a lazy release-consistent DSM using diffing (LRC-diff). For (i) we use an algorithm similar to the one used in Midway, and for (iii) we use the TreadMarks system. We have developed a new algorithm for (ii) that gives better results than previously published approaches. The comparison uses four applications - SOR, Quicksort, M-Water, and Cholesky and the experimental platform is a 100Mbps ATM network of DecStation machines running Ultrix. We find that EC-diff performs better than EC-sdb for SOR (19% in running time on 8 processors), Quicksort (57%), and Cholesky (27%), and slightly worse for M-Water (11%). Comparing EC-diff and LRC-diff, we find that EC-diff performs better for SOR (5%), Quicksort (11%), and Cholesky (34%), but worse for M-Water (30%). Comparing EC-sdb to LRC, the 8-processor Cholesky run is the only one for which EC-sdb performs better than LRC. We discuss how these results are affected by the particular implementation we use for the two models, and how performance could be improved by different ways of coding the applications for the two models.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adve and M. Hill. </author> <title> Weak ordering: A new definition. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Every time a process executes a release or an acquire, a new interval begins and the interval index is incremented. Intervals of different processes are partially ordered <ref> [1] </ref>: (i) intervals on a single processor are totally ordered by program order, and (ii) an interval on processor p precedes an interval on processor q if the interval of q begins with the acquire corresponding to the release that concluded the interval of p.
Reference: [2] <author> A. Agarwal, B.-H. Lim, D. Kranz, and J. Kubiatowicz. </author> <month> APRIL: </month> <title> A processor architecture for multiprocessing. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 104-114, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]). Our work also builds on the large body of previous work in software DSM (e.g., [14]) and hardware DSM (e.g., <ref> [2, 10] </ref>). 7 Conclusions This paper presents two related results. First, it compares two different implementations of entry consistency, one using software dirty bits and one using diffing.
Reference: [3] <author> B.N. Bershad and M.J. Zekauskas. Midway: </author> <title> Shared memory parallel programming with entry consistency for distributed memory multiprocessors. </title> <type> Technical Report CMU-CS-91-170, </type> <institution> Carnegie-Mellon University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Discussion of release consistency and its performance in software DSM systems can be found in a number of papers [6, 11, 8, 12, 7]. Similar discussions of entry consistency can be found in <ref> [3, 4, 16] </ref>. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]).
Reference: [4] <author> B.N. Bershad, M.J. Zekauskas, </author> <title> and W.A. </title> <booktitle> Sawdon. The Midway distributed shared memory system. In Proceedings of the '93 CompCon Conference, </booktitle> <pages> pages 528-537, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: To combat these problems, software DSM implementations have turned to relaxed memory models and various techniques for dealing with false sharing. In this paper we study and compare two implementations of relaxed memory models | lazy release consistency (LRC) [11] and entry consistency (EC) <ref> [4] </ref> | and two techniques for dealing with sharing at a granularity smaller than a virtual memory page - diffing [6] and software dirty bits [16]. LRC requires, roughly speaking, that the programmer use system-provided synchronization primitives. Synchronization primitives are divided into releases and acquires. <p> This discussion is limited to those aspects that are new or that are specifically of interest to this comparison. For further information we refer the reader to earlier papers <ref> [4, 11, 12, 16] </ref>. 2.1 Entry Consistency (EC) Entry consistency (EC) is a relaxed memory model. Processes synchronize via system-supplied primitives. Synchronization primitives include read-write locks with the familiar single-writer, multiple-reader semantics, and barriers. The programmer associates shared data with a synchronization object that protects access to that shared data. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers [6, 11, 8, 12, 7]. Similar discussions of entry consistency can be found in <ref> [3, 4, 16] </ref>. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]).
Reference: [5] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related information in distributed shared memory systems. </title> <note> To appear in ACM Transactions on Computer Systems. </note>
Reference-contexts: To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., <ref> [5, 9, 17] </ref>). Our work also builds on the large body of previous work in software DSM (e.g., [14]) and hardware DSM (e.g., [2, 10]). 7 Conclusions This paper presents two related results.
Reference: [6] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <month> October </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: In this paper we study and compare two implementations of relaxed memory models | lazy release consistency (LRC) [11] and entry consistency (EC) [4] | and two techniques for dealing with sharing at a granularity smaller than a virtual memory page - diffing <ref> [6] </ref> and software dirty bits [16]. LRC requires, roughly speaking, that the programmer use system-provided synchronization primitives. Synchronization primitives are divided into releases and acquires. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers <ref> [6, 11, 8, 12, 7] </ref>. Similar discussions of entry consistency can be found in [3, 4, 16]. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency.
Reference: [7] <author> A.L. Cox, S. Dwarkadas, P. Keleher, H. Lu, R. Rajamony, and W. Zwaenepoel. </author> <title> Software versus hardware shared-memory implementation: A case study. </title> <booktitle> In Proceedings of the 21th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 106-117, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Discussion of release consistency and its performance in software DSM systems can be found in a number of papers <ref> [6, 11, 8, 12, 7] </ref>. Similar discussions of entry consistency can be found in [3, 4, 16]. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency.
Reference: [8] <author> S. Dwarkadas, P. Keleher, A.L. Cox, and W. Zwaenepoel. </author> <title> Evaluation of release consistent software distributed shared memory on emerging network technology. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 244-255, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A write notice is an indication that a page has been modified in a particular interval, but it does not contain the actual modifications. The timing of the actual data movement depends on whether an invalidate, or an update protocol is used (see <ref> [8] </ref>). We currently use an invalidate protocol: the arrival of a write notice for a page causes the processor to invalidate its copy of that page. A subsequent access to that page causes an access miss, at which time the modifications are propagated to the local copy. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers <ref> [6, 11, 8, 12, 7] </ref>. Similar discussions of entry consistency can be found in [3, 4, 16]. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency.
Reference: [9] <author> K. Gharachorloo, A. Gupta, and J. Hennessy. </author> <title> Performance evaluations of memory consistency models for shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 4th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., <ref> [5, 9, 17] </ref>). Our work also builds on the large body of previous work in software DSM (e.g., [14]) and hardware DSM (e.g., [2, 10]). 7 Conclusions This paper presents two related results.
Reference: [10] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: With the EC-sdb method, the timestamp on each data item guarantees that each data item that has been modified is sent exactly once for each lock transfer. 2.4 Lazy Release Consistency (LRC) Release consistency (RC) <ref> [10] </ref> is similar to entry consistency in that it is a relaxed memory model that relies on synchronization to drive movement of updates to shared data between processors. Unlike entry consistency, however, there is no notion of association between synchronization objects and data. <p> Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]). Our work also builds on the large body of previous work in software DSM (e.g., [14]) and hardware DSM (e.g., <ref> [2, 10] </ref>). 7 Conclusions This paper presents two related results. First, it compares two different implementations of entry consistency, one using software dirty bits and one using diffing.
Reference: [11] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Conventional software DSM implementations suffer from high communication overhead. To combat these problems, software DSM implementations have turned to relaxed memory models and various techniques for dealing with false sharing. In this paper we study and compare two implementations of relaxed memory models | lazy release consistency (LRC) <ref> [11] </ref> and entry consistency (EC) [4] | and two techniques for dealing with sharing at a granularity smaller than a virtual memory page - diffing [6] and software dirty bits [16]. LRC requires, roughly speaking, that the programmer use system-provided synchronization primitives. Synchronization primitives are divided into releases and acquires. <p> This discussion is limited to those aspects that are new or that are specifically of interest to this comparison. For further information we refer the reader to earlier papers <ref> [4, 11, 12, 16] </ref>. 2.1 Entry Consistency (EC) Entry consistency (EC) is a relaxed memory model. Processes synchronize via system-supplied primitives. Synchronization primitives include read-write locks with the familiar single-writer, multiple-reader semantics, and barriers. The programmer associates shared data with a synchronization object that protects access to that shared data. <p> The implementation of release consistency used in this paper provides exclusive locks and barriers, but does not support read-write locks. It uses a lazy algorithm for implementing release consistency <ref> [11] </ref>. The propagation of consistency information is postponed until the time of the acquire. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers <ref> [6, 11, 8, 12, 7] </ref>. Similar discussions of entry consistency can be found in [3, 4, 16]. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency.
Reference: [12] <author> P. Keleher, S. Dwarkadas, A. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> In Proceedings of the 1994 Winter Usenix Conference, </booktitle> <pages> pages 115-131, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: In order to minimize such problems, we are using the EC programs used by the Midway system in the recent Midway paper [16] and the LRC programs used by the TreadMarks system discussed in their paper <ref> [12] </ref>. Other than the extra synchronization and the association of data with synchronization for EC, these programs are identical. Furthermore, 2 we use the TreadMarks implementation for LRC. For EC, we user an implementation similar to Midway and an alternative implementation. <p> This discussion is limited to those aspects that are new or that are specifically of interest to this comparison. For further information we refer the reader to earlier papers <ref> [4, 11, 12, 16] </ref>. 2.1 Entry Consistency (EC) Entry consistency (EC) is a relaxed memory model. Processes synchronize via system-supplied primitives. Synchronization primitives include read-write locks with the familiar single-writer, multiple-reader semantics, and barriers. The programmer associates shared data with a synchronization object that protects access to that shared data. <p> Unless otherwise noted, the performance numbers describe 8-processor executions on the ATM LAN using the low-level adaptation layer protocol AAL3/4. 3.2 Applications We used four programs in this study: Red-Black SOR, Quicksort, M-Water, and Cholesky. These same programs were used in earlier studies of Midway [16] and TreadMarks <ref> [12] </ref>. Red-Black Successive Over-Relaxation (SOR) is used to solve partial differential equations. The program determines the steady state values in a system where the boundary elements are kept constant. A matrix of 1000 fi 1000 floating-point values represents the system in which the four edges are kept constant. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers <ref> [6, 11, 8, 12, 7] </ref>. Similar discussions of entry consistency can be found in [3, 4, 16]. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency.
Reference: [13] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: On a release, the implementation scans the dirty bits of the shared data associated with the synchronization object. Zero bits are set to the current timestamp. This timestamp is a Lamport clock <ref> [13] </ref> maintained by the processor. It is sent on each outgoing message. On each receipt of a message, the timestamp of the receiving processor is set to the maximum of the processor's current timestamp and the timestamp in the message.
Reference: [14] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]). Our work also builds on the large body of previous work in software DSM (e.g., <ref> [14] </ref>) and hardware DSM (e.g., [2, 10]). 7 Conclusions This paper presents two related results. First, it compares two different implementations of entry consistency, one using software dirty bits and one using diffing.
Reference: [15] <author> J.P. Singh, W.-D. Weber, and A. Gupta. </author> <title> SPLASH: Stanford parallel applications for shared-memory. </title> <type> Technical Report CSL-TR-91-469, </type> <institution> Stanford University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Furthermore, to provide a fair comparison between software dirty bits and diffing, we initialized all internal elements to nonzero values in such a way that they change on every iteration. Water, from the SPLASH suite <ref> [15] </ref>, is a molecular dynamics simulation that exhibits medium-grained sharing. The original Water program obtains a lock on the record representing a molecule each time it updates the contents of the record.
Reference: [16] <author> Mathew J. Zekauskas, Wayne A. Sawdon, and Brian N. Bershad. </author> <title> Software write detection for distributed shared memory. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 87-100, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In this paper we study and compare two implementations of relaxed memory models | lazy release consistency (LRC) [11] and entry consistency (EC) [4] | and two techniques for dealing with sharing at a granularity smaller than a virtual memory page - diffing [6] and software dirty bits <ref> [16] </ref>. LRC requires, roughly speaking, that the programmer use system-provided synchronization primitives. Synchronization primitives are divided into releases and acquires. <p> In contrast, with software dirty bits, the compiler emits extra instructions that set these bits when the corresponding shared data objects are changed. In principle, software dirty bits can be used both with EC and LRC. In practice, they appear more suitable for EC. Zekauskas et al. <ref> [16] </ref> suggest an implementation of LRC using software dirty bits for Midway, but their implementation appears costly if all of memory is to be kept release-consistent. Therefore, we only consider LRC implementations using diffing. <p> The applications used in the comparison are SOR, Quicksort, M-Water and Cholesky. We find that EC-diff performs better than EC-sdb for SOR (19% on 8 processors), Quicksort (57%), and Cholesky (27%), and slightly worse for M-Water (11%). Superficially, these results may seem to contradict with those presented in <ref> [16] </ref>. Our implementation of EC-diff, however, uses a different strategy from the one presented in that paper, explaining the difference in results. Comparing EC-diff and LRC-diff, we find that EC-diff performs better for SOR (5%), Quicksort (11%), and Cholesky (34%), but worse for M-Water (30%). <p> In order to minimize such problems, we are using the EC programs used by the Midway system in the recent Midway paper <ref> [16] </ref> and the LRC programs used by the TreadMarks system discussed in their paper [12]. Other than the extra synchronization and the association of data with synchronization for EC, these programs are identical. Furthermore, 2 we use the TreadMarks implementation for LRC. <p> This discussion is limited to those aspects that are new or that are specifically of interest to this comparison. For further information we refer the reader to earlier papers <ref> [4, 11, 12, 16] </ref>. 2.1 Entry Consistency (EC) Entry consistency (EC) is a relaxed memory model. Processes synchronize via system-supplied primitives. Synchronization primitives include read-write locks with the familiar single-writer, multiple-reader semantics, and barriers. The programmer associates shared data with a synchronization object that protects access to that shared data. <p> In order to do so, EC records updates to shared data (write detection) and forwards these updates to the acquiring processor (write collection). 2.2 Entry Consistency Using Software Dirty Bits (EC-Sdb) 2.2.1 Write Detection The EC-sdb implementation of EC uses software dirty bits as suggested in the Midway papers <ref> [16] </ref>. The software dirty bit scheme works by setting a dirty bit on every write to shared memory. Although always referred to as a dirty bit, each dirty bit actually takes up a word of memory, for reasons explained below. Data is allocated in terms of fixed-size regions. <p> In summary, our implementation of EC-sdb is very similar to the one used in Midway <ref> [16] </ref>. <p> For small objects, we make a copy of the object as soon as a write lock is requested on the object. For large objects, we make a virtual copy using copy-on-write techniques as suggested in the Midway paper <ref> [16] </ref>. When the write lock is acquired, we write-protect the pages corresponding to the object using the virtual memory hardware. When a page is written, we make a physical copy, and unprotect the page in user space. <p> Unless otherwise noted, the performance numbers describe 8-processor executions on the ATM LAN using the low-level adaptation layer protocol AAL3/4. 3.2 Applications We used four programs in this study: Red-Black SOR, Quicksort, M-Water, and Cholesky. These same programs were used in earlier studies of Midway <ref> [16] </ref> and TreadMarks [12]. Red-Black Successive Over-Relaxation (SOR) is used to solve partial differential equations. The program determines the steady state values in a system where the boundary elements are kept constant. <p> At the end of the iteration, it then acquires a lock on each molecule that it needs to update and applies the accumulated updates at once. This modification was also done in <ref> [16] </ref>. The EC version of this program binds the data for each molecule to the lock that protects access to it. We present results for a 343-molecule system that was run for 5 timesteps. Quicksort is also a program that exhibits medium-grained sharing. <p> The versions in this paper are fully statically scheduled. 4 Performance 4.1 Results Tables 1 to 4 present running times for EC-sdb, EC-diff, and LRC-diff, for all four applications. The running times in these tables should not be compared directly to similar results in the Midway paper <ref> [16] </ref>, because of differences in processor speed (40Mhz vs. 25Mhz) and differences in communication speed and page fault overhead due to different operating systems (Ultrix vs. Mach 3.0). 4.2 Discussion With SOR, EC-diff performs better than EC-sdb. The overhead of the dirty bit algorithm exceeds the overhead of diffing. <p> Typically, only some sub-array has changed, and the diffing mechanism will only move those elements that have changed. This result is consistent with the results obtained by Zekauskas et al. <ref> [16] </ref>. EC-diff performs slightly better than LRC. Because of false sharing, LRC updates all the modified elements in a page, while EC will only update the sub-array associated with the lock. Cholesky's performance is very poor for all implementations. <p> The diffing based methods take advantage of this, while the software dirty bits approach cannot. With the elements initialized to zero, and the entire matrix declared as shared, EC-sdb becomes progressively worse (see Figure 6). 6 Related Work The paper by Zekauskas et al. <ref> [16] </ref> studies the difference between a software dirty bit implementation of EC and a VM-based implementation. Their conclusion was that the software dirty bit implementation is superior, for all but Quicksort. We come to a different conclusion: the diffing approach is better for all but M-Water. <p> Discussion of release consistency and its performance in software DSM systems can be found in a number of papers [6, 11, 8, 12, 7]. Similar discussions of entry consistency can be found in <ref> [3, 4, 16] </ref>. To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., [5, 9, 17]).
Reference: [17] <author> R.N. Zucker and J.-L. Baer. </author> <title> A performance study of memory consistency models. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2-12, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: To the best of our knowledge, our work is the first to compare performance of a number of applications under release and entry consistency. Various papers have discussed the performance differences between sequential consistency and relaxed memory consistency models (see e.g., <ref> [5, 9, 17] </ref>). Our work also builds on the large body of previous work in software DSM (e.g., [14]) and hardware DSM (e.g., [2, 10]). 7 Conclusions This paper presents two related results.
References-found: 17

