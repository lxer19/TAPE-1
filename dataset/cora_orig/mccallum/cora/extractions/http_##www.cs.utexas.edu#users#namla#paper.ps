URL: http://www.cs.utexas.edu/users/namla/paper.ps
Refering-URL: http://www.cs.utexas.edu/users/namla/
Root-URL: http://www.cs.utexas.edu
Title: Regular Timing Diagrams  
Author: Nina Amla E. Allen Emerson 
Address: Austin TX 78712 U.S.A  
Affiliation: Department of Computer Sciences University of Texas,  
Abstract: This paper defines a class of timing diagrams called Regular Timing Diagrams (RTDs). We give a formal syntax and semantics for four different types of RTDs, namely synchronous RTDs (ambiguous and unambiguous) and asynchronous RTDs (ambiguous and unambiguous). We present two algorithms that translate any RTD into !-regular expressions, the first one is a monolithic algorithm and the second is a compositional algorithm. Both algorithms can be used in conjunction with existing verification tools to verify that circuits satisfy the timing behavior represented as RTDs. We provide an example of how our algorithms can be used, by verifying that a master-slave memory system satisfies its regular timing diagrams.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Antoine and B. Le Goff. </author> <title> Timing diagrams for writing and checking logical and behavioral properties of integrated systems. </title> <booktitle> In Correct Hardware Design Methodologies, </booktitle> <pages> pages 441-453. </pages> <publisher> Elsevier Sciences Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Grass et al. [9] give timing diagrams a formal semantics in the T-LOTOS model and are able to then generate VHDL code to be used in test generation. They do address ambiguity but their aim is test generation as opposed to verification. Antoine and Le Goff <ref> [1] </ref> give the syntax and semantics of synchronous timing diagrams and translate then into path properties of a state graph and propose to verify these properties over the Kripke structure. This work considers only synchronous timing diagrams and does not address ambiguity. <p> Sequential dependencies may only occur within a clock cycle (i.e. ((A; p i ); (B; p j ); [l; u]) 2 SD iff p i and p j occur in the same clock cycle and [l; u] is either <ref> [1; 1] </ref> or u l &lt; t). Henceforth, we consider only well-formed RTDs. 2.5 Iterative Semantics As mentioned in the introduction, we define two types of iterative semantics for ambiguous RTDs: strong iterative semantics and weak iterative semantics.
Reference: [2] <author> Robert Brayton, G. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. Ranjan, S. Sarwary, T. Shiple, G. Swamy, and T. Villa. </author> <title> Vis. </title> <booktitle> In FMCAD, </booktitle> <year> 1996. </year>
Reference-contexts: We use language containment to show that the language of the system is contained in the language of each of the resulting !-regular expressions. We also show that our algorithms can be used as a front end to the verification tool V IS <ref> [2] </ref>, by using the language emptiness feature of VIS to verify that a master-slave memory system satisfies its RTDs. Several researchers have investigated timing diagrams and their use in automated verification.
Reference: [3] <author> E. M. Clarke and E. Allen Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Worshop on Logics of Programs, </booktitle> <volume> volume 131, </volume> <pages> pages 52-71. </pages> <publisher> Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The timing diagram model proposed in [7] can express non-regular properties. She provides a decision procedure that determines regular containment. i.e. whether a regular language is contained in an unambiguous timing diagram language. [7] provides an algorithm that translates a certain class of timing diagrams into CTL <ref> [3] </ref>. Our approach is inspired by Fisler's framework but there are syntactic and semantic differences. One key difference is that her algorithm translates a subset of unambiguous timing diagrams under the invariant semantics into CTL but our algorithm is defined over both ambiguous and unambiguous diagrams and is interpreted iteratively.
Reference: [4] <author> Werner Damm, Bernhard Josko, and Rainer Schlor. </author> <title> Specification and verification of vhdl-based system-level hardware designs. </title> <editor> In Egon Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 331-409. </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Our algorithm works on ambiguous and unambiguous RTDs and is more efficient. Damm, Josko and Schlor <ref> [4] </ref> [10] give a rigorous formal syntax and semantics for Symbolic Timing Diagrams (STD). They compile STD into a linear-time first-order temporal logic, and use this to verify VHDL-based designs. <p> They can be used to specify properties of both synchronous and asynchronous timing diagrams. The main difference lies in the fact that their framework has an invariant semantics. It is possible to model check the first order temporal logic presented in <ref> [4] </ref> and TPTL formulae but it is fairly complicated and quite inefficient. Grass et al. [9] give timing diagrams a formal semantics in the T-LOTOS model and are able to then generate VHDL code to be used in test generation. <p> We chose the V IS verification system. V IS uses language emptiness to show language containment since L M , L " M = . We consider the master-slave architecture <ref> [4] </ref> in figure 6. In this system, the master either issues a read or write instruction by asserting the read or write line and the slaves respond by accessing memory and servicing the request.
Reference: [5] <author> Konard Feyerabend and Bernhard Josko. </author> <title> A visual formalism for real time requirement specifications. </title> <booktitle> In 4th International AMAST Workshop on Real-time systems and Concurrent and Distributed Software, </booktitle> <pages> pages 156-168. </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Our algorithm works on ambiguous and unambiguous RTDs and is more efficient. Damm, Josko and Schlor [4] [10] give a rigorous formal syntax and semantics for Symbolic Timing Diagrams (STD). They compile STD into a linear-time first-order temporal logic, and use this to verify VHDL-based designs. Feyerabend and Josko <ref> [5] </ref> [6] extend STD's into RTSTD's (Real-time Symbolic Timing Diagrams) and provide a translation into a timed propositional logic (TPTL). Both of these research efforts work on infinite languages and do indeed consider ambiguity. They can be used to specify properties of both synchronous and asynchronous timing diagrams.
Reference: [6] <author> Konrad Feyerabend. </author> <title> Real-time symbolic timing diagrams. </title> <type> Technical report, </type> <institution> Department of Computer Science, Oldenburg University, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Damm, Josko and Schlor [4] [10] give a rigorous formal syntax and semantics for Symbolic Timing Diagrams (STD). They compile STD into a linear-time first-order temporal logic, and use this to verify VHDL-based designs. Feyerabend and Josko [5] <ref> [6] </ref> extend STD's into RTSTD's (Real-time Symbolic Timing Diagrams) and provide a translation into a timed propositional logic (TPTL). Both of these research efforts work on infinite languages and do indeed consider ambiguity. They can be used to specify properties of both synchronous and asynchronous timing diagrams.
Reference: [7] <author> Kathi Fisler. </author> <title> A Unified Approach to Hardware Verification Through a Heterogeneous Logic of Design Diagrams. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indiana University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: A synchronous timing diagram has one or more clocks with fixed periods while asynchronous timing diagrams have no clock. An important question that arises in defining the semantics of timing diagrams is "How does an infinite computation satisfy a timing diagram ?" Fisler <ref> [7] </ref> addresses this question by defining two kinds of semantics: invariant semantics and iterative semantics. A timing diagram that is satisfied invariantly has to be satisfied at every state in the infinite computation. <p> However, an infinite computation satisfies a timing diagram under the iterative semantics if the computation can be viewed as an infinite concatenation of finite, disjoint sub-computations, that each satisfy the timing diagram. Another issue arising in practice that is formalized in <ref> [7] </ref> is the notion of temporal ambiguity with respect to timing diagrams. An unambiguous timing diagram specifies a total ordering of the events in the diagram. <p> Several researchers have investigated timing diagrams and their use in automated verification. Fisler <ref> [7] </ref> [8] gives a very careful analysis of timing diagram languages and finds that these languages occur at all levels of the Chomsky hierarchy. The timing diagram model proposed in [7] can express non-regular properties. <p> Several researchers have investigated timing diagrams and their use in automated verification. Fisler <ref> [7] </ref> [8] gives a very careful analysis of timing diagram languages and finds that these languages occur at all levels of the Chomsky hierarchy. The timing diagram model proposed in [7] can express non-regular properties. She provides a decision procedure that determines regular containment. i.e. whether a regular language is contained in an unambiguous timing diagram language. [7] provides an algorithm that translates a certain class of timing diagrams into CTL [3]. <p> The timing diagram model proposed in <ref> [7] </ref> can express non-regular properties. She provides a decision procedure that determines regular containment. i.e. whether a regular language is contained in an unambiguous timing diagram language. [7] provides an algorithm that translates a certain class of timing diagrams into CTL [3]. Our approach is inspired by Fisler's framework but there are syntactic and semantic differences.
Reference: [8] <author> Kathi Fisler. </author> <title> Containment of regular languages in non-regular timing diagrams languages is decidable. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 156-168. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Several researchers have investigated timing diagrams and their use in automated verification. Fisler [7] <ref> [8] </ref> gives a very careful analysis of timing diagram languages and finds that these languages occur at all levels of the Chomsky hierarchy. The timing diagram model proposed in [7] can express non-regular properties. <p> One key difference is that her algorithm translates a subset of unambiguous timing diagrams under the invariant semantics into CTL but our algorithm is defined over both ambiguous and unambiguous diagrams and is interpreted iteratively. The regular containment procedure <ref> [8] </ref> considers (regular and non-regular) unambiguous timing diagrams under an iterative semantics but has a complexity 1 The algorithm under the weak iterative semantics, generates !-regular expressions that correspond to deterministic Buchi automata, thereby avoiding the exponential blowup when complementing non-deterministic Buchi automata. 2 They correspond to deterministic Buchi automata. 2
Reference: [9] <author> Werner Grass, Christian Grobe, Stefan Lenk, Wolf-Deiter Tiedemann, Carlos D. Kloos, Andres Marin, and Tomas Robles. </author> <title> Transformation of timing diagram specifications into vhdl code. </title> <booktitle> In Proceedings of the Conference on Hardware Description Languages, </booktitle> <pages> pages 659-668, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: The main difference lies in the fact that their framework has an invariant semantics. It is possible to model check the first order temporal logic presented in [4] and TPTL formulae but it is fairly complicated and quite inefficient. Grass et al. <ref> [9] </ref> give timing diagrams a formal semantics in the T-LOTOS model and are able to then generate VHDL code to be used in test generation. They do address ambiguity but their aim is test generation as opposed to verification.
Reference: [10] <author> Rainer Schlor. </author> <title> A prover for vhdl-based hardware design. </title> <booktitle> In Conference on Hardware Description Languages, </booktitle> <month> August </month> <year> 1995. </year> <month> 15 </month>
Reference-contexts: Our algorithm works on ambiguous and unambiguous RTDs and is more efficient. Damm, Josko and Schlor [4] <ref> [10] </ref> give a rigorous formal syntax and semantics for Symbolic Timing Diagrams (STD). They compile STD into a linear-time first-order temporal logic, and use this to verify VHDL-based designs.
References-found: 10

