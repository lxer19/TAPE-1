URL: http://www.cs.cornell.edu/Info/People/hayden/thesis.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/hayden/hayden.html
Root-URL: http://www.cs.brown.edu/
Title: THE ENSEMBLE SYSTEM  
Author: Mark Garland Hayden 
Degree: A Dissertation Presented to the Faculty of the Graduate School  in Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy by  
Date: January 1998  
Affiliation: of Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [AWWV96] <author> J. Armstrong, M. Williams, C. Wikstrom, and R. Virding. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: One result of these differences was that Ensemble was able to achieve better performance than the implementation of Horus written in C, whereas the Fox TCP implementation is slower than implementations of TCP in C. Other related work has been done with Erlang <ref> [AWWV96, Hau94] </ref>. Er-lang, a product of Ericsson, is a functional language designed to support distributed telephone switching software. A number of impressive telecommunications products have been built using Erlang and they have found many of same advantages of using functional languages for distributed communication that we have.
Reference: [Bas97] <author> Anindya Basu. </author> <title> A Language-based Approach to Protocol Construction. </title> <type> PhD thesis, </type> <institution> Cornell University, Cornell University, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: Merging of both approaches would have the potential benefit of extending our techniques to settings beyond communication protocols and at the same time increasing the ability to reason about the correctness of their optimizations and expanding the class of traces they can optimize. <ref> [Bas97] </ref> (carried out subsequent to the work reported on here) adopted the layering architecture described in Chapter 2 and applied similar optimizations using a compiler, designed for optimizing layered communication protocols.
Reference: [BBVvE95] <author> Anindya Basu, Vineet Buch, Werner Vogels, and Thorsten von Eicken. U-Net: </author> <title> A user-level network interface for parallel and distributed computing. </title> <booktitle> In Proc. of the Fifteenth ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 40-53, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: These could be further optimized by rewriting this infrastructure in C. There are no delayed operations in the unoptimized protocol stack. 44 The time line for one round-trip of the C protocol is depicted in Figure 3.4. Two Sparcstation 20s are communicating over an ATM network using U-net <ref> [BBVvE95] </ref> which has one-way latencies of 35s. At 0s, process A receives a message from process B off the network. 26s later the application has received the message and the next message is sent on the network.
Reference: [BHLM94] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. </author> <title> Signatures for a network protocol stack: A systems application for Standard ML. </title> <booktitle> In Proc. of the ACM Conf. on Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: We then conclude with a summary of our lessons and a list of features which we feel are missing from ML. 48 4.1 Related work Related work has been done in the Fox project <ref> [BHLM94] </ref> which demonstrated the use of ML for systems programming. They developed a complete TCP protocol stack in ML 1 that interfaces very closely with the network. However, Fox and Ensemble differ significantly. <p> Two techniques were used to achieve this. The first was a phased approach where closures are created when protocol stacks are initialized, but not during their normal execution. This technique is similar to one described in <ref> [BHLM94] </ref>. The second way was to use higher-order 2 Ensemble does not use Ocaml's object oriented features 50 iterators for data structures such as list and array iterators. These are effi-cient because inlining of the iterator can eliminate closure allocation 3 .
Reference: [BJ87] <author> Kenneth P. Birman and Thomas A. Joseph. </author> <title> Exploiting virtual synchrony in distributed systems. </title> <booktitle> In Proc. of the Eleventh ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: The protocols measured here implement FIFO virtual synchrony <ref> [vRBM96, BJ87] </ref> and consist of 10 or more protocol layers. In particular, the application has at least 10 layers below it. All the performance measurements are made on groups with 2 members, where the properties are roughly equivalent to those of TCP.
Reference: [BvR94] <author> Kenneth P. Birman and Robbert van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: Group communication is a well-accepted approach to providing tools for building reliable distributed systems. Early group communication toolkits such as V [CZ85] demonstrated that process groups and group communication can be highly efficient and scalable. The ISIS <ref> [BvR94] </ref> system demonstrated the usefulness of group communication in settings such as stock exchanges, a major air traffic control system, VLSI fabrication process planning software, and other significant, critical applications. In applications such as these, group communication is used to coordinate distributed actions such as updates to replicated state. <p> The other 4 bytes are a sequence number (for instance). There is not much room for improvement. This 8 byte header can be compared with those in similar communication protocols, such as TCP (40 bytes, 20 bytes for TCP with header compression) 1 , ISIS <ref> [BvR94] </ref> (over 80 bytes), and Horus [vRBM96] (over 50 bytes). Two related problems arise when additional header formats are introduced to protocol stacks that expect only a single format.
Reference: [C + 86] <author> Robert L. Constable et al. </author> <title> Implementing Mathematics in the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: The major contribution of this chapter is to demonstrate how the layering architecture from Chapter 2 and the optimizations from Chapter 3 mesh to enable the optimizations to be carried out in a formal fashion. For these optimizations, we use the Nuprl theorem prover <ref> [C + 86, Jac94, Kre97, Con96] </ref>. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof.
Reference: [CHTCB95] <author> Tushar Deepak Chandra, Vassos Hadzilacos, Sam Toueg, and Bernadette Charron-Bost. </author> <title> On the impossibility of group mem 102 bership. </title> <type> Technical Report TR95-1548, </type> <institution> Cornell University, </institution> <month> Oc--tober </month> <year> 1995. </year>
Reference-contexts: Communication protocols are notoriously difficult to get right. Even the core group membership protocols provided by ISIS (now more than 10 years old) are still not fully understood and developing specifications and verifying such protocols is currently an active area of research <ref> [CHTCB95, FLS97] </ref>. Introducing composable layers makes the system more complex by greatly increasing the number of configurations. It should also be noted that in the background of this drive for flexibility, there is the even more powerful demand for high-performance.
Reference: [CJRS89] <author> David Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <pages> pages 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The compiler was applied to modified versions of the Ensemble protocols and the Active Messages protocol suite [TVEB95], demonstrating significant performance improvements over the unoptimized protocols. Other work from which we have adopted ideas includes work on optimizing TCP protocols. <ref> [CJRS89] </ref> demonstrated a number of techniques for optimizing TCP through determination of the important code paths in TCP, along with descriptions of methods to optimize those code paths.
Reference: [CKB84] <author> Robert L. Constable, T. Knoblock, and J. L. Bates. </author> <title> Writing programs that construct proofs. </title> <journal> J. Automated Reasoning, </journal> <volume> 1(3) </volume> <pages> 285-326, </pages> <year> 1984. </year>
Reference-contexts: For these optimizations, we use the Nuprl theorem prover [C + 86, Jac94, Kre97, Con96]. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof. However, the user can apply tactics <ref> [GMW79, CKB84] </ref> which are programs that encode various proof techniques, thereby automating those techniques. Nuprl's underlying semantics are based on a very expressive type theory. The Nuprl term language is similar to the subset of ML we use to implement protocol layers.
Reference: [Con96] <author> Robert L. Constable. </author> <title> The Structure of Nuprl's Type Theory in Logic and Computation. </title> <booktitle> NATO ASI Series. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The major contribution of this chapter is to demonstrate how the layering architecture from Chapter 2 and the optimizations from Chapter 3 mesh to enable the optimizations to be carried out in a formal fashion. For these optimizations, we use the Nuprl theorem prover <ref> [C + 86, Jac94, Kre97, Con96] </ref>. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof.
Reference: [CT90] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proc. of the 1990 ACM Symp. on Communications Architectures & Protocols, </booktitle> <pages> pages 200-208, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This also demonstrated the use of small connection identifiers to compress headers from messages and the use of message packing to achieve higher throughput. A more detailed comparison is presented below in Section 3.5.1. A somewhat orthogonal set of optimization techniques is called Integrated Layer Processing <ref> [PHOA93, CT90] </ref> (ILP). In general, the term ILP encompasses optimizations on multiple protocol layers, thus the optimizations we describe are a form of ILP. However, ILP techniques tend to focus on integrating data manipulations across protocol layers, whereas our optimizations focus on optimizing control operations and message header compression.
Reference: [CZ85] <author> David Cheriton and Willy Zwaenepoel. </author> <title> Distributed process groups in the V kernel. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(2) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: It typically provides op 1 erations for processes to join and leave groups, and to communicate within a group. Group communication is a well-accepted approach to providing tools for building reliable distributed systems. Early group communication toolkits such as V <ref> [CZ85] </ref> demonstrated that process groups and group communication can be highly efficient and scalable. The ISIS [BvR94] system demonstrated the usefulness of group communication in settings such as stock exchanges, a major air traffic control system, VLSI fabrication process planning software, and other significant, critical applications. <p> The purpose of this chapter is to familiarize the reader with a layering architecture in order to provide context for the remainder of the thesis. Our design builds upon prior work concerned with introducing group communications systems into the OS (the V system) <ref> [CZ85] </ref>, structuring point-to-point protocols for modularity [Rit84, PHOA93], and doing so for group communication systems systems with strong properties [vRBM96]. We were heavily influenced by the Horus work, and indeed Ensemble was "born" as an attempt to build a reference implementation of Horus.
Reference: [FLS97] <author> Alan Fekete, Nancy Lynch, and Alex Shvartsman. </author> <title> Specifying and using a partitionable group communication service. </title> <booktitle> In Proc. of the Sixteenth ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 53-62, </pages> <address> Santa Barbara, CA, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: Communication protocols are notoriously difficult to get right. Even the core group membership protocols provided by ISIS (now more than 10 years old) are still not fully understood and developing specifications and verifying such protocols is currently an active area of research <ref> [CHTCB95, FLS97] </ref>. Introducing composable layers makes the system more complex by greatly increasing the number of configurations. It should also be noted that in the background of this drive for flexibility, there is the even more powerful demand for high-performance.
Reference: [GMW79] <author> Michael Gordon, Robin Milner, and Christoph Wadsworth. </author> <title> Ed-inburgh LCF: a mechanized logic of computation, </title> <booktitle> volume 73 of Lecture Notes on Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: For these optimizations, we use the Nuprl theorem prover [C + 86, Jac94, Kre97, Con96]. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof. However, the user can apply tactics <ref> [GMW79, CKB84] </ref> which are programs that encode various proof techniques, thereby automating those techniques. Nuprl's underlying semantics are based on a very expressive type theory. The Nuprl term language is similar to the subset of ML we use to implement protocol layers.
Reference: [Har96] <author> The Harlequin Group, </author> <title> Cambridge. The MLWorks User Guide, </title> <month> November </month> <year> 1996. </year>
Reference-contexts: While predicting the operations that cause memory allocation is usually easy in Ocaml programs, it is much more difficult to get a good picture of the overall memory allocation patterns in programs. Other systems, such as Harlequin's Standard ML environment <ref> [Har96] </ref>, provide support for profiling memory usage, so this kind of support is certainly possible. 52 4.2.6 Summary Our experience with Ocaml has been generally positive.
Reference: [Hau94] <author> Bogumil Hausman. </author> <title> Turbo Erlang: Approaching the speed of C. </title> <editor> In Evan Tick and Giancarlo Succi, editors, </editor> <booktitle> Implementations of Logic Programming Systems, </booktitle> <pages> pages 119-135. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year> <month> 103 </month>
Reference-contexts: One result of these differences was that Ensemble was able to achieve better performance than the implementation of Horus written in C, whereas the Fox TCP implementation is slower than implementations of TCP in C. Other related work has been done with Erlang <ref> [AWWV96, Hau94] </ref>. Er-lang, a product of Ericsson, is a functional language designed to support distributed telephone switching software. A number of impressive telecommunications products have been built using Erlang and they have found many of same advantages of using functional languages for distributed communication that we have.
Reference: [Hay92] <author> Barry Hayes. </author> <title> Finalization in the garbage collector interface. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, </booktitle> <volume> volume 637, </volume> <pages> pages 277-298. </pages> <publisher> Springer Verlag LNCS, </publisher> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: This slows execution somewhat, but prevents memory errors. The opposite problem, memory leakage, can occur if reference counts are occasionally not decremented to zero, causing segments to never be released. We addressed this problem by using weak pointers <ref> [Hay92] </ref> to detect when the reference count object (which wraps the segment) has no further references. When this happens, the problem is signaled to the user and the segment is recovered to prevent a memory leak (see Figure 4.5). Both ISIS and Horus had similar problems.
Reference: [Jac90] <author> Van Jacobson. </author> <title> Compressing TCP/IP headers for low-speed serial links. </title> <type> RFC 1144, </type> <institution> Network Working Group, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: These headers are compressed by our approach when they appear in the common path. * Non-constant headers include all other headers, such as sequence numbers or headers used in negotiating reconfigurations. These are not compressed. Protocol headers are compressed by using connection identifiers <ref> [vR96, Kay95, Jac90] </ref>. Connection identifiers are tuples containing addressing headers which do not change very often. These tuples are hashed into 32-bit values which are then used with hash tables to route messages to protocol stacks.
Reference: [Jac94] <author> Paul B. Jackson. </author> <title> The Nuprl Proof Development System, Version 4.1 Reference and User's Guide. </title> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The major contribution of this chapter is to demonstrate how the layering architecture from Chapter 2 and the optimizations from Chapter 3 mesh to enable the optimizations to be carried out in a formal fashion. For these optimizations, we use the Nuprl theorem prover <ref> [C + 86, Jac94, Kre97, Con96] </ref>. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof.
Reference: [Kar97] <author> David A. Karr. </author> <title> Specification, Composition, and Automated Verification of Layered Communication Protocols. </title> <type> PhD thesis, </type> <institution> Cor-nell University, Cornell University, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Second, it allows Ensemble to support on-the-fly protocol switching, where the new configuration actually uses a different protocol stack or set of parameters from the previous configuration. 5 This is implemented through an ad hoc algorithm, though <ref> [Kar97] </ref> shows techniques for formalizing such an algorithm. 22 2.1.10 Application The last component is the application. Supporting applications is of course the point of the architecture.
Reference: [Kay95] <author> Jonathan Kay. </author> <title> Path IDS: A Mechanism for Reducing Network Software Latency. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: However, the approach presented there focussed on a single protocol architecture and did not address issues involved with generalizing the techniques to optimize a wide range of protocols. PathIDs <ref> [Kay95] </ref> are another technique for improving the processing of messages by incorporating a field into message headers that causes normal case messages to be rapidly dispatched to hand-optimized code for handling those cases. This work does not address the issues involved in generating the optimized handlers. <p> These headers are compressed by our approach when they appear in the common path. * Non-constant headers include all other headers, such as sequence numbers or headers used in negotiating reconfigurations. These are not compressed. Protocol headers are compressed by using connection identifiers <ref> [vR96, Kay95, Jac90] </ref>. Connection identifiers are tuples containing addressing headers which do not change very often. These tuples are hashed into 32-bit values which are then used with hash tables to route messages to protocol stacks.
Reference: [Kre97] <author> Christoph Kreitz. </author> <title> Formal reasoning about communication systems I: Embedding ML into type theory. </title> <type> Technical Report TR97-1637, </type> <institution> Cornell University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The major contribution of this chapter is to demonstrate how the layering architecture from Chapter 2 and the optimizations from Chapter 3 mesh to enable the optimizations to be carried out in a formal fashion. For these optimizations, we use the Nuprl theorem prover <ref> [C + 86, Jac94, Kre97, Con96] </ref>. Nuprl is an interactive theorem prover with support for automation. Proofs typically require human interaction with the theorem prover to direct the method of proof. <p> Clearly, there remains a good deal of work left in the implementation of these optimizations, although we believe there are no major technical barriers. 5.1 Functional layers We begin by showing how to transform imperative protocol layers into purely functional layers. This step is described in detail in <ref> [Kre97] </ref>. The transformation to functional protocol layers is important in the later optimizations because the absence of imperative operations facilitates formal reasoning in Nuprl. We begin with protocol layers having the structure described in Section 2.1.8, and the resulting protocol layers use a subset of ML that is purely functional.
Reference: [Kru93] <author> Clifford Dale Krumvieda. </author> <title> Distributed ML: Abstractions for Efficient and Fault-Tolerant Programming. </title> <type> PhD thesis, </type> <institution> Cornell University, Cornell University, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Other systems have aimed at similar objectives, but we believe Ensemble is the first to simultaneously pursue this mixture of objectives. For example, Distributed ML <ref> [Kru93] </ref> (DML) is a group communication system built in ML. The work on DML and Horus was done in parallel at Cornell.
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Objective Caml system release 1.05. </title> <institution> INRIA, France, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: The approach with Erlang was to design a new language with support for distribution, whereas our approach has been to build libraries in an existing language. 4.2 Ob jective Caml We use the Objective Caml (Ocaml) system <ref> [Ler97] </ref> which implements its own sub-dialect of the CAML [WL93] dialect of ML.
Reference: [Mac93] <author> David MacQueen. </author> <title> Reflections on Standard ML. </title> <editor> In Peter E. Lauer, editor, </editor> <booktitle> Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <volume> volume 693, </volume> <pages> pages 32-46. </pages> <publisher> Springer Verlag LNCS, </publisher> <year> 1993. </year>
Reference-contexts: Thus the creation of closures only appears outside common execution paths or in ways that can be easily optimized. 4.2.3 Memory management Ocaml supports garbage collected memory management. Although some ML implementations are perceived to require large amounts of memory <ref> [Mac93] </ref>, the Ocaml system is known for its efficient use of memory and this has not been a problem for us. Ocaml uses a generational garbage collector with a stop-and-copy minor heap and an incremental mark-and-sweep major heap. Our experiences with the garbage collector have been positive, with two exceptions.
Reference: [Maf95] <author> Silvano Maffeis. </author> <title> Adding group communication and fault-tolerance to CORBA. </title> <booktitle> In Proc. of the 1995 USENIX Conference on Object-Oriented Technologies, </booktitle> <address> Monterey, CA, </address> <month> June </month> <year> 1995. </year> <booktitle> USENIX. </booktitle> <pages> 104 </pages>
Reference-contexts: As described above in Section 4.2, Ocaml provides adequate support for interfacing with C. In addition to C, C++, Tcl/Tk, and CORBA <ref> [Maf95] </ref>, which are supported by Horus, Ensemble also supports Smalltalk, Ada, and (of course) ML. 4.3.3 Supported platforms Both Ensemble and Horus seek to be largely platform-independent. Horus is supported on a variety of UNIX platforms and a smattering of other operating systems such as Chorus and Mach. <p> Ensemble has considerably more demonstration programs than Horus. The bulk of the C code listed for Ensemble is for C/C++ interfaces, associated testing code, and an interface to the Electra CORBA-based replicated object system <ref> [Maf95] </ref>. No C code is actually needed to run Ensemble because the Ocaml UNIX library provides stubs for all needed system calls. However, Ensemble comes with its own set of UNIX stubs that can optionally be used to improve performance.
Reference: [MOR + 96] <author> Keith Marzullo, Michael Ogg, Aleta Ricciardi, Alessandro Amoroso, F. Andrew Calkins, and Eric Rothfus. NILE: </author> <title> Wide-area computing for high energy physics. </title> <booktitle> In Proc. of the of the 7th European SIGOPS Workshop, </booktitle> <address> Connemara, Ireland, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: There are a number of early users. These include the Ensemble CD Jukebox (a distributed audio server developed with Jason Hickey), BBN AquA, Configured Energy Systems (a software provider for utility companies), and the NILE project <ref> [MOR + 96] </ref>. 6 Chapter 2 Ensemble Architecture Before proceeding to the body of the thesis, we first present a description of aspects of the Ensemble architecture relevant to the later discussion.
Reference: [MP96] <author> David Mosberger and Larry Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proc. of the of the 1996Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 153-168, </pages> <address> Seattle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: The only exceptions to this are security protocols which encrypt/decrypt the message or calculate cryptographic checksums. The optimizations we present focus on aspects of protocol execution that are compatible with these other approaches and we believe they could be combined in one system. The Scout project <ref> [MP96, MPBO96] </ref> has explored optimization techniques revolving around paths, which are a similar construct to the traces described here. The two approaches differ in a number of ways, however. The Scout goals involve optimizing paths all the way from the network to other IO devices, such as disks and displays.
Reference: [MPBO96] <author> David Mosberger, Larry L. Peterson, Patrick G. Bridges, and Sean O'Malley. </author> <title> Analysis of techniques to improve protocol processing latency. </title> <booktitle> In Proc. of the 1996 ACM Symp. on Communications Architectures & Protocols, </booktitle> <pages> pages 73-84, </pages> <address> Stanford, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: The only exceptions to this are security protocols which encrypt/decrypt the message or calculate cryptographic checksums. The optimizations we present focus on aspects of protocol execution that are compatible with these other approaches and we believe they could be combined in one system. The Scout project <ref> [MP96, MPBO96] </ref> has explored optimization techniques revolving around paths, which are a similar construct to the traces described here. The two approaches differ in a number of ways, however. The Scout goals involve optimizing paths all the way from the network to other IO devices, such as disks and displays.
Reference: [PHOA93] <author> Larry L. Peterson, Norm Hutchinson, Sean O'Malley, and Mark Abbott. </author> <title> RPC in the x-Kernel: Evaluating new design techniques. </title> <booktitle> In Proc. of the Fourteenth ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The ability to provide a large (and extensible) range of properties to applications requires additional flexibility from group communication systems. Systems such as the x-Kernel <ref> [PHOA93] </ref> and Horus [vRBM96] were designed to add such flexibility through modular architectures whereby sets of micro-protocols (or layers) can be composed into high-level protocols. This allows applications to select the exact set of protocols that meet their needs. <p> The purpose of this chapter is to familiarize the reader with a layering architecture in order to provide context for the remainder of the thesis. Our design builds upon prior work concerned with introducing group communications systems into the OS (the V system) [CZ85], structuring point-to-point protocols for modularity <ref> [Rit84, PHOA93] </ref>, and doing so for group communication systems systems with strong properties [vRBM96]. We were heavily influenced by the Horus work, and indeed Ensemble was "born" as an attempt to build a reference implementation of Horus. <p> Our approach to header formats takes a somewhat non-standard view of how to format messages. In contrast with many other systems <ref> [PHOA93, Pos81] </ref>, the formats of headers for individual layers are not defined at the byte level. In addition, the headers of a stack of protocol layers is generally not the concatenation of the headers of the individual layers. <p> This also demonstrated the use of small connection identifiers to compress headers from messages and the use of message packing to achieve higher throughput. A more detailed comparison is presented below in Section 3.5.1. A somewhat orthogonal set of optimization techniques is called Integrated Layer Processing <ref> [PHOA93, CT90] </ref> (ILP). In general, the term ILP encompasses optimizations on multiple protocol layers, thus the optimizations we describe are a form of ILP. However, ILP techniques tend to focus on integrating data manipulations across protocol layers, whereas our optimizations focus on optimizing control operations and message header compression.
Reference: [Pos81] <author> Jon Postel. </author> <title> Transmission Control Protocol. </title> <type> RFC 793, </type> <month> Septem-ber </month> <year> 1981. </year>
Reference-contexts: Our approach to header formats takes a somewhat non-standard view of how to format messages. In contrast with many other systems <ref> [PHOA93, Pos81] </ref>, the formats of headers for individual layers are not defined at the byte level. In addition, the headers of a stack of protocol layers is generally not the concatenation of the headers of the individual layers.
Reference: [Rep91] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proc. of the ACM SIGPLANN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The work on DML and Horus was done in parallel at Cornell. DML can be viewed largely as an attempt to re-implement the ISIS toolkit in ML, making use of improved support for abstraction and threading provided by the Concurrent ML programming language <ref> [Rep91] </ref>. However, the DML implementation never reached maturity. It also lacked the facilities for protocol composition that Horus supported, did not support switching protocols on-the-fly (as Ensemble does), nor did it provide very good performance. The x-Kernel is a modular communication system designed primarily to support point-to-point protocols.
Reference: [Rit84] <author> Dennis M. Ritchie. </author> <title> A stream input-output system. </title> <journal> Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <year> 1984. </year>
Reference-contexts: The purpose of this chapter is to familiarize the reader with a layering architecture in order to provide context for the remainder of the thesis. Our design builds upon prior work concerned with introducing group communications systems into the OS (the V system) [CZ85], structuring point-to-point protocols for modularity <ref> [Rit84, PHOA93] </ref>, and doing so for group communication systems systems with strong properties [vRBM96]. We were heavily influenced by the Horus work, and indeed Ensemble was "born" as an attempt to build a reference implementation of Horus. <p> We compare it here with the Horus [vRBM96] and STREAMS <ref> [Rit84] </ref> architectures. * The application appears as part of one of the layers instead of at the top of the stack. This allows it to appear lower in the protocol stack, which improves performance.
Reference: [TMC + 96] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. of the 1996 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1996. </year> <month> 105 </month>
Reference-contexts: Catenation is done by catenating arrays of iovecs. Thus, neither subset nor catenation copy the contents. Some recent work has focused on introducing support in ML for low-level data structures such as untagged word arrays <ref> [TMC + 96] </ref>. Such support is justified in part by the claim that it is needed in order to do real low-level systems work in ML.
Reference: [TVEB95] <author> Anindya Basu Thorsten Von Eicken, Veena Avula and Vineet Buch. </author> <title> Low-latency communication over atm networks using active messages. </title> <type> Technical Report TR94-1456, </type> <institution> Cornell University, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: The compiler was applied to modified versions of the Ensemble protocols and the Active Messages protocol suite <ref> [TVEB95] </ref>, demonstrating significant performance improvements over the unoptimized protocols.
Reference: [vR96] <author> Robbert van Renesse. </author> <title> Masking the overhead of protocol layering. </title> <booktitle> In Proc. of the 1996 ACM Symp. on Communications Architectures & Protocols, </booktitle> <address> Stanford, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Other approaches have been used to improve the performance of layered communication protocols. Work done in our research group on this problem has been described in <ref> [vR96] </ref>. In that work, protocols are optimized through the use of pre- and post-processing to move computation overhead out of the common path. Through this approach, the latency is greatly reduced, though the computation is not. <p> These headers are compressed by our approach when they appear in the common path. * Non-constant headers include all other headers, such as sequence numbers or headers used in negotiating reconfigurations. These are not compressed. Protocol headers are compressed by using connection identifiers <ref> [vR96, Kay95, Jac90] </ref>. Connection identifiers are tuples containing addressing headers which do not change very often. These tuples are hashed into 32-bit values which are then used with hash tables to route messages to protocol stacks. <p> The reformatting function needs to be stored with compressed messages, but this cost is offset by the decreased size of messages being buffered. 3.4.3 Delayed processing The final class of optimizations improves the latency of the trace handlers without decreasing the amount of computation. The approach in <ref> [vR96] </ref> relies heavily on this class of optimization, whereas in our work this optimizations is made in addition to others that are more significant in our case. <p> There are some background computations that grow in cost with the size of the group, but these do not occur in code paths measured above. 3.5.1 Comparison with Horus Protocol Accelerator The Protocol Accelerator <ref> [vR96] </ref> achieves code-latencies of 50s for protocol stacks of 5 layers (on a similar platform). The total time required for pre-and post-processing one message send and one message receive operation is approximately 170s, with a header overhead of 16 bytes.
Reference: [vRBM96] <author> Robbert van Renesse, Kenneth P. Birman, and Silvano Maffeis. Horus: </author> <title> A flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The ability to provide a large (and extensible) range of properties to applications requires additional flexibility from group communication systems. Systems such as the x-Kernel [PHOA93] and Horus <ref> [vRBM96] </ref> were designed to add such flexibility through modular architectures whereby sets of micro-protocols (or layers) can be composed into high-level protocols. This allows applications to select the exact set of protocols that meet their needs. <p> Our design builds upon prior work concerned with introducing group communications systems into the OS (the V system) [CZ85], structuring point-to-point protocols for modularity [Rit84, PHOA93], and doing so for group communication systems systems with strong properties <ref> [vRBM96] </ref>. We were heavily influenced by the Horus work, and indeed Ensemble was "born" as an attempt to build a reference implementation of Horus. Performance was so good that our research group moved over entirely to use the Ensemble substrate. This chapter proceeds as follows. <p> We compare it here with the Horus <ref> [vRBM96] </ref> and STREAMS [Rit84] architectures. * The application appears as part of one of the layers instead of at the top of the stack. This allows it to appear lower in the protocol stack, which improves performance. <p> Because a message often has to pass through many (10 or more) protocol layers, the overhead of these boundaries is often more than the actual computation being done. Different systems have reported overheads for crossing layers of up to 50s <ref> [vRBM96] </ref> (on a Sparcstation 10). In Ensemble, this cost is as low as 5s (also on a Sparcstation 10). <p> There is not much room for improvement. This 8 byte header can be compared with those in similar communication protocols, such as TCP (40 bytes, 20 bytes for TCP with header compression) 1 , ISIS [BvR94] (over 80 bytes), and Horus <ref> [vRBM96] </ref> (over 50 bytes). Two related problems arise when additional header formats are introduced to protocol stacks that expect only a single format. <p> The protocols measured here implement FIFO virtual synchrony <ref> [vRBM96, BJ87] </ref> and consist of 10 or more protocol layers. In particular, the application has at least 10 layers below it. All the performance measurements are made on groups with 2 members, where the properties are roughly equivalent to those of TCP.
Reference: [WJNB95] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic storage allocation: A survey and critical review. </title> <booktitle> In Proc. of the International Workshop on Memory Management, </booktitle> <address> Kinross, Scotland, UK, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: However, this causes a copy for each message, and external fragmentation (unused space outside of objects) is still a problem because the Ocaml garbage collector (as with many non-copying collectors) does a poor job of managing large blocks of varying sizes <ref> [WJNB95] </ref>. 4.5.2 Using large message buffers Both sorts of fragmentation are avoided in Ensemble by using very large strings for allocating iovecs. These strings are called segments and are typically 256K bytes long. Segments are managed by msgbufs, which consist of a current segment and offset.
Reference: [WL93] <author> Pierre Weis and Xavier Leroy. </author> <title> Le Language Caml. </title> <address> InterEditions, Paris, </address> <year> 1993. </year>
Reference-contexts: The approach with Erlang was to design a new language with support for distribution, whereas our approach has been to build libraries in an existing language. 4.2 Ob jective Caml We use the Objective Caml (Ocaml) system [Ler97] which implements its own sub-dialect of the CAML <ref> [WL93] </ref> dialect of ML. Although this chapter is intended to be general, it is important to distinguish between the ML 1 Fox uses Standard ML of NJ, whereas the implementation of ML we use is Objective Caml 49 family of programming languages and the particular implementation that we use.
Reference: [X.287] <author> CCITT Recommendation X.208. </author> <title> Specification of Abstract Syntax Notation One (ASN.1), </title> <booktitle> 1987. </booktitle> <pages> 106 </pages>
Reference-contexts: Marshallers typically transparently handle incompatibilities in byte ordering and word size. There are numerous standard marshalling formats such as XDR and ASN.1 <ref> [X.287] </ref>. Ensemble uses the general-purpose marshaller in Ocaml, although it can easily support other marshallers. By representing headers as regular ML data structures, protocols can leverage the same powerful language features, such as pattern matching and type checking, that are used for other data structures.
References-found: 41

