URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR321-ap-relational-properties-of-domains.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Title: Relational Properties of Domains  
Author: Andrew M. Pitts 
Address: Cambridge, England  
Affiliation: Cambridge University Computer Laboratory,  
Abstract: New tools are presented for reasoning about properties of recursively defined domains. We work within a general, category-theoretic framework for various notions of `relation' on domains and for actions of domain constructors on relations. Freyd's analysis of recursive types in terms of a property of mixed initiality/finality is transferred to a corresponding property of invariant relations. The existence of invariant relations is proved under completeness assumptions about the notion of relation. We show how this leads to simpler proofs of the computational adequacy of denotational semantics for functional programming languages with user-declared datatypes. We show how the ini-tiality/finality property of invariant relations can be specialized to yield an induction principle for admissible subsets of recursively defined domains, generalizing the principle of structural induction for inductively defined sets. We also show how the initiality/finality property gives rise to the co-induction principle studied by the author (in Cambridge Univ. Computer Laboratory Tech. Rept. No. 252), by which equalities between elements of recursively defined domains may be proved via an appropriate notion of `bisimulation'. fl Cambridge University Computer Laboratory Technical Report No. 321, December 1993 y Research supported by UK SERC grant GR/G53279 and EC ESPRIT Basic Research project CLICS-II. Email: ap@cl.cam.ac.uk. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abadi, M., Cardelli, L., and Curien, P.-L. </author> <year> (1993), </year> <title> Formal parametric poly-morphism, </title> <booktitle> Theoretical Computer Science 121, </booktitle> <pages> 9-58. </pages>
Reference-contexts: The utility of considering actions of type constructors on relations is perhaps best known from the body of work beginning with (Reynolds, 1983) on relational properties of parametric polymorphism: see <ref> (Abadi, Cardelli and Curien, 1993) </ref> and (Plotkin and Abadi, 1993) and the references therein. It is well known that inductive and co-inductive types can be encoded in the Girard-Reynolds polymorphic lambda calculus. Hence they inherit relational properties from those of 8-types. <p> The utility of considering actions of type constructors on relations is perhaps best known from the body of work beginning with (Reynolds, 1983) on relational properties of parametric polymorphism: see (Abadi, Cardelli and Curien, 1993) and <ref> (Plotkin and Abadi, 1993) </ref> and the references therein. It is well known that inductive and co-inductive types can be encoded in the Girard-Reynolds polymorphic lambda calculus. Hence they inherit relational properties from those of 8-types.
Reference: <author> Abramsky, S. </author> <year> (1990), </year> <title> The lazy lambda calculus, </title> <booktitle> in "Research Topics in Functional Programming" (Turner, </booktitle> <address> D., </address> <publisher> Ed.), </publisher> <pages> pp. 65-116, </pages> <publisher> Addison-Wesley, Inc. </publisher>
Reference-contexts: Example 2.6 Let D be rec ff:(ff ! ff) ? , the canonical domain model of the lazy lambda calculus studied in <ref> (Abramsky, 1990) </ref> and (Abramsky and Ong, 1993). Thus D is the minimal invariant of the locally continuous functor (() !(+)) ? : Cpo ? fi Cpo ? ! Cpo ? and comes equipped with an isomorphism i : (D ! D) ? ~ = D. <p> So we have the stated induction rule for rec ff:(ff). fl Example 5.8 (Lazy Lambda Calculus) Let (ff) = (ff ! ff) ? . In this case D = rec ff:(ff) is the canonical domain model of the lazy lambda calculus studied in <ref> (Abramsky, 1990) </ref> and (Abramsky and Ong, 1993).
Reference: <author> Abramsky, S. </author> <year> (1991), </year> <title> A domain equation for bisimulation, </title> <booktitle> Information and Computation 92, </booktitle> <pages> 161-218. </pages>
Reference-contexts: satisfy a weaker version of condition (ii) of that definition, with S 0 =v E and g the projection half of an embedding-projection pair; and as loc. cit. shows, this is sufficient to establish the co-induction result, which includes Abramsky's `internal full abstraction' theorem for his domain model of SCCS <ref> (Abramsky, 1991, Proposition 3.11) </ref> as an instance.
Reference: <author> Abramsky, S., and Ong, C.-H. L. </author> <year> (1993), </year> <title> Full abstraction in the lazy lambda calculus, </title> <journal> Inform. and Computation 105, </journal> <pages> 159-267. </pages>
Reference-contexts: Example 2.6 Let D be rec ff:(ff ! ff) ? , the canonical domain model of the lazy lambda calculus studied in (Abramsky, 1990) and <ref> (Abramsky and Ong, 1993) </ref>. Thus D is the minimal invariant of the locally continuous functor (() !(+)) ? : Cpo ? fi Cpo ? ! Cpo ? and comes equipped with an isomorphism i : (D ! D) ? ~ = D. <p> So we have the stated induction rule for rec ff:(ff). fl Example 5.8 (Lazy Lambda Calculus) Let (ff) = (ff ! ff) ? . In this case D = rec ff:(ff) is the canonical domain model of the lazy lambda calculus studied in (Abramsky, 1990) and <ref> (Abramsky and Ong, 1993) </ref>. In this case, for each R 2 P (D), (R) is the subset of (D ! D) ? containing ? and all elements of the form f where f 2 (D ! D) satisfies that f (d) 2 R for all d 2 D.
Reference: <author> Barendregt, H. </author> <year> (1984), </year> <title> "The Lambda Calculus. Its Syntax and Semantics" (revised edition), </title> <publisher> North-Holland, Amsterdam. </publisher>
Reference-contexts: The argu-ment is due to Plotkin (private communication) and should be compared with the proofs of similar results in <ref> (Barendregt, 1984, Exercise 18.4.20) </ref> and (Winskel, 1993, Sect. 13.10.2). Example 2.6 Let D be rec ff:(ff ! ff) ? , the canonical domain model of the lazy lambda calculus studied in (Abramsky, 1990) and (Abramsky and Ong, 1993).
Reference: <author> Crole, R. L., and Pitts, A. M. </author> <year> (1992), </year> <title> New foundations for fixpoint computations: </title> <journal> FIX-hyperdoctrines and the FIX-logic, Inform. and Computation 98, </journal> <pages> 171-210. </pages>
Reference: <author> Fiore, M. P. </author> <year> (1993), </year> <title> A coinduction principle for recursive datatypes based on bisimulation, </title> <booktitle> in "Proc. 8th Annual Symposium on Logic in Computer Science, Montreal", </booktitle> <pages> pp. 110-119, </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington. </address> <note> 35 Freyd, </note> <author> P. J. </author> <year> (1991), </year> <title> Algebraically complete categories, </title> <booktitle> in "Proc. 1990 Como Cat--egory Theory Conference", Lec. Notes in Math., </booktitle> <volume> Vol. 1488 (A. </volume> <editor> Carboni, et al, </editor> <booktitle> Eds), </booktitle> <pages> pp. 95-104, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: We refer the reader to (Pitts, 1992) for further discussion and applications of this co-inductive characterization of the partial order on recursively defined cppos. (See also <ref> (Fiore, 1993) </ref> and (Rutten, 1993); and (Paulson, 1993) for related applications.) The existence of a simulation (i.e. a relation satisfying (36)) containing two elements of a recursively defined cppo establishes that the order relation holds between them.
Reference: <author> Freyd, P. J. </author> <year> (1992), </year> <title> Remarks on algebraically compact categories, </title> <booktitle> in "Applications of Categories in Computer Science" (Fourman, </booktitle> <editor> M. P., Johnstone, P. T., and Pitts, A. M., </editor> <booktitle> Eds), </booktitle> <pages> pp. 95-106, </pages> <booktitle> L.M.S. Lecture Note Series 177, </booktitle> <publisher> Cam-bridge University Press. </publisher>
Reference: <author> Freyd, P. J., and Scedrov, A. </author> <year> (1990), </year> <title> "Categories, </title> <publisher> Allegories", North-Holland, Amsterdam. </publisher>
Reference-contexts: Similarly, the notion of composition of (binary) relations is fundamental to much work on categories of relations (see <ref> (Freyd and Scedrov, 1990) </ref> for example), but plays little role here because it is not preserved by the functors we need to consider. Here are some examples of relational structures on the category Cpo ? of cppos and strict continuous functions that will be relevant to this paper.
Reference: <author> Gordon, M. G. C., Milner, R., and Wadsworth, C. P. </author> <year> (1979), </year> <title> "Edinburgh LCF", </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 78, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The structure for relations we use is based on that used by O'Hearn and Tennent (1993) in their work on applying relational parametricity to the study of local-variable declarations. To it we add a treatment of the crucial property of relations that in LCF <ref> (Gordon, Milner and Wadsworth, 1979) </ref> is called admissibility (meaning `admitting induction').
Reference: <author> Gunter, C. A. </author> <year> (1992), </year> <title> "Semantics of Programming Languages. Structures and Techniques", </title> <publisher> MIT Press. </publisher>
Reference-contexts: The rule for recursive function declarations is: ; f: 0 !; x 0 : 0 ` e: ` e 0 : 0 ` letrec fx 0 = e: in fe 0 : We omit the other type assignment rules. (See <ref> (Gunter, 1992, Tables 2.1, 3.1 and 4.1) </ref> for example.) Let Expr denote the collection of closed expressions of type , i.e. the expressions e for which the typing assertion ; ` e: holds. Let Can denote the subset of Expr consisting of the expressions in canonical form.
Reference: <author> Gunter, C. A., and Scott, D. S. </author> <year> (1990), </year> <title> Semantic domains, </title> <booktitle> in "Handbook of Theoretical Computer Science" (Leeuwen, </booktitle> <editor> J. van, </editor> <publisher> Ed.), </publisher> <pages> pp. 634-674, </pages> <publisher> Elsevier Science Publishers B.V, Amsterdam. </publisher>
Reference-contexts: set-theoretic construction in terms of Scott's notion of `information system' (Scott, 1982; Winskel and Larsen, 1984), which has the advantage of yielding solutions up to equality rather than just up to isomorphism; and there is the related approach using least fixed points of continuous operators on universal domains, described in <ref> (Gunter and Scott, 1990) </ref>. These various constructions serve not only to prove the existence of some solution to a domain equation, but in fact produce a solution that is minimal, in a sense which we review in this section. The minimality property is important for at least two reasons. <p> a strict continuous function between cppos, and d : D ! D and e : E ! E are continuous functions satisfying e ffi f = f ffi d, then fix (e) = f ffi fix (d). 8 The property can be established via a simple fixed point induction: see <ref> (Gunter and Scott, 1990, Theorem 2.3) </ref>. Turning to the proof of the theorem, consider the function : (A ( D) fi (D ( B) ! (A ( D) fi (D ( B) given by (h; k) = (iF (k; h)f; gF (h; k)i 1 ).
Reference: <author> Hudak, P., Peyton Jones, S., and Wadler, P. </author> <year> (1991), </year> <title> Report on the programming language Haskell: version 1.1, </title> <type> Technical Report, </type> <institution> Yale Univ. and Glasgow Univ. </institution>
Reference-contexts: 1 Introduction A characteristic feature of higher-order functional languages such as Standard ML (Milner, Tofte and Harper, 1990) or Haskell <ref> (Hudak, Peyton Jones, and Wadler, 1991) </ref> is the facilities they provide for `user-declared' recursive datatypes.
Reference: <author> Jensen, F. V. </author> <year> (1981), </year> <title> Inductive inference in reflexive domains, </title> <institution> Edinburgh Univ. Dept. </institution> <note> Computer Science Report No. CSR 86-81. </note>
Reference: <author> Lawvere, F. W. </author> <year> (1970), </year> <title> Equality in hyperdoctrines and the comprehension schema as an adjoint functor, in "Applications of Categorical Algebra" (Heller, </title> <editor> A., </editor> <publisher> Ed.), </publisher> <pages> pp. 1-14, </pages> <publisher> Amer. Math. Soc., </publisher> <address> Providence RI. </address>
Reference-contexts: Making this the fundamental notion contrasts with the usual axiomatic approach to predicates in categorical logic where, beginning with Law-vere's work on `hyperdoctrines' <ref> (Lawvere, 1970) </ref>, the notion of the inverse image of a predicate along a map is fundamental. There are close connections between the two notions (see Remark 3.15).
Reference: <author> Lehmann, D. J., and Smyth, M. B. </author> <year> (1981), </year> <title> Algebraic specification of datatypes: a synthetic approach, </title> <journal> Math. Systems Theory 14, </journal> <pages> 97-139. </pages>
Reference: <author> Mac Lane, S. </author> <year> (1971), </year> <title> "Categories for the Working Mathematician", </title> <publisher> Springer-Verlag, </publisher> <address> New York. </address>
Reference-contexts: Remark 3.4 Although we have defined admissibility in terms of the concrete structure of cppos, the definition can in fact be phrased purely in terms of the monoidal closed structure h1 ? ; ; (i on the category Cpo ? . (See <ref> (MacLane, 1971, Chapter VII) </ref> for an introduction to this categorical notion.) Here 1 ? is the lift of a one-element set: it is a unit for the smash product operation on cppos.
Reference: <author> Meyer, A. R., and Cosmodakis, S. S. </author> <year> (1988), </year> <title> Semantical paradigms: </title> <booktitle> notes for an invited lecture, in "Proc. 3rd Annual Symposium on Logic in Computer Science, </booktitle> <publisher> Edinburgh", </publisher> <pages> pp. 236-253, </pages> <publisher> IEEE Computer Society Press, Washing-ton. </publisher>
Reference-contexts: For particular choices of the notion of relation, these invariant relations lie at the heart of some proofs of correspondence between denotational and operational semantics (as in (Plotkin, 1985), or <ref> (Meyer and Cosmodakis,1988, Appendix) </ref>, for example), or between two denotational semantics (as in (Reynolds, 1974) for example). <p> Secondly, such minimal solutions are needed to ensure denotational semantics of programming language expressions are computationally adequate (in the technical sense described in the survey <ref> (Meyer and Cosmodakis, 1988) </ref>) for their operational behaviour. We give a concrete example of this in Sect. 4. In order to express a minimality condition on solutions of (3), one needs some notion of comparison between cppos that is preserved by the action of the constructor .
Reference: <author> Milne, R. E. </author> <year> (1973), </year> <title> "The formal semantics of computer languages and their implementations", </title> <type> Ph.D. Thesis, </type> <institution> Cambridge University. </institution>
Reference: <author> Milner, R., Tofte, M., and Harper, R. </author> <year> (1990), </year> <title> "The Definition of Standard ML", </title> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction A characteristic feature of higher-order functional languages such as Standard ML <ref> (Milner, Tofte and Harper, 1990) </ref> or Haskell (Hudak, Peyton Jones, and Wadler, 1991) is the facilities they provide for `user-declared' recursive datatypes. <p> We will illustrate this method of proving computational adequacy using a programming language equivalent to a small, but non-trivial fragment of Standard ML <ref> (Milner, Tofte and Harper, 1990) </ref> containing a single recursive datatype declaration declaration: datatype ty = In 1 of 1 j j In n of n : (9) The types 1 ; : : : ; n are built up from the ground types unit (one-element type), bool (booleans), int (integers), and <p> the programming language can be given via a type-indexed family of evaluation relations e + c (e 2 Expr ; c 2 Can ) : These relations are inductively defined by the rules in Table 1, which follow the dynamic semantics of the corresponding Standard ML expressions, as specified in <ref> (Milner, Tofte and Harper, 1990) </ref>.
Reference: <author> O'Hearn, P. W., and Tennent, R. D. </author> <year> (1993), </year> <title> Relational Parametricity and Local Variables, </title> <booktitle> in "Conf. Record 20th Symp. on Principles of Programming Languages, Charleston", </booktitle> <pages> pp. 171-184, </pages> <publisher> ACM, </publisher> <address> New York. </address>
Reference: <author> Paulson, L. C. </author> <title> (1993) Co-induction and co-recursion in higher-order logic, </title> <institution> Cam-bridge Univ. Computer Laboratory Tech. Rept. </institution> <note> No. 304. </note>
Reference-contexts: We refer the reader to (Pitts, 1992) for further discussion and applications of this co-inductive characterization of the partial order on recursively defined cppos. (See also (Fiore, 1993) and (Rutten, 1993); and <ref> (Paulson, 1993) </ref> for related applications.) The existence of a simulation (i.e. a relation satisfying (36)) containing two elements of a recursively defined cppo establishes that the order relation holds between them.
Reference: <author> Pitts, A. M. </author> <year> (1992), </year> <title> A co-induction principle for recursively defined domains, </title> <institution> Cambridge Univ. Computer Laboratory Tech. Rept. </institution> <note> No. 252. To appear in Theoretical Computer Science. 36 Pitts, </note> <author> A. M. </author> <year> (1993), </year> <title> Relational properties of recursively defined domains, </title> <booktitle> in "Proc. 8th Annual Symp. on Logic in Computer Science, Montreal", </booktitle> <pages> pp. 86-97, </pages> <publisher> IEEE Computer Soc. Press, </publisher> <address> Washington. </address>
Reference-contexts: Traditionally one considers only certain kinds of relation on domains|ones that are sufficiently complete, or `admissible'. This is appropriate for various inductive properties of domains; but as <ref> (Pitts, 1992) </ref> shows, one needs to go beyond this to arbitrary set-theoretic relations in order to capture fully the co-inductive properties of recursively defined domains. In fact we need remarkably few properties of a general notion of `relation' in order to establish our main results. <p> We show that the induction property can yield a non-trivial proof principle even for problematic recursively defined domains, such as those that model untyped lambda calculus: see Example 5.8. The co-induction principle (Theorem 5.12) is the one which the author established in <ref> (Pitts, 1992) </ref>. It takes the form of an extensionality property: two elements d; d 0 of a recursively defined domain satisfy d v d 0 (respectively d = d 0 ) if and only 3 if there is a `simulation' (respectively a `bisimulation') relating them. <p> In contrast to the induction principle, the co-induction principle deals with arbitrary relations rather than just admissible ones. The proof of it that we give here as a corollary of the general theory developed in Sect. 3 is simpler than that given in <ref> (Pitts, 1992) </ref>. However, the method of loc. cit. can deal with recursively defined domains involving powerdomain constructors, whereas there are difficulties with defining the action on relations of such constructors needed for the theory developed here: see Remark 5.14. <p> In many cases condition (ii) of the definition holds without the admissibility restriction on S 0 j . One example where it is needed occurs when we derive the co-induction principle introduced in <ref> (Pitts, 1992) </ref> by making use of actions of the familiar domain constructors on binary relations on cppos. <p> Then in Sect. 5 we will see that the property of given in the above corollary gives rise to various reasoning principles for recursively defined domains, including a general form of induction for admissible properties and the co-induction principle introduced in <ref> (Pitts, 1992) </ref>. Remark 3.11 Proposition 3.9 can be viewed as a result about Freyd's notion of `free algebra' (cf. Remark 2.5). First note that each relational structure R on Cpo ? gives rise to a new (cpo enriched) category Cpo ? fRg of cppos equipped with admissible R-relations. <p> prove d v d 0 it suffices to show (d; d 0 ) 2 R for some subset R D fi D satisfying: 8 (x; x 0 ) 2 R:(i 1 (x); i 1 (x 0 )) 2 (R) : (36) The co-induction principle for recursively defined cpos established in <ref> (Pitts, 1992) </ref> can be deduced from Corollary 5.13 by restricting attention to cppo constructors (ff) just involving the constructions () ? , , , and (() ((+)) ? . <p> As shown in loc. cit., binary relations satisfying (36) give a uniform notion of `simulation' (for the cppo-constructors considered), which includes for example (one-sided) applicative bisimulation, used by Abramsky (1990) in connection with the lazy lambda calculus. We refer the reader to <ref> (Pitts, 1992) </ref> for further discussion and applications of this co-inductive characterization of the partial order on recursively defined cppos. (See also (Fiore, 1993) and (Rutten, 1993); and (Paulson, 1993) for related applications.) The existence of a simulation (i.e. a relation satisfying (36)) containing two elements of a recursively defined cppo establishes <p> Nevertheless, it can be useful to consider formulations of co-induction principles like Theorem 5.12 which relax the conditions imposed on the functor F . For example, <ref> (Pitts, 1992, Sect. 5) </ref> extends Corollary 5.13 to domain constructors (ff) involving the Plotkin powerdomain, P " (Plotkin, 1976). <p> If G has such a property, it does not seem automatic that rec X:G (; +; X ; X + ) will have it. Nevertheless the co-induction result of Corollary 5.13 does extend to the case of recursively defined constructors, as is indicated briefly in <ref> (Pitts, 1992, Remark 4.2) </ref>. We leave consideration of a similarly extended induction principle to another occasion. Concluding remarks As far as this paper is concerned, expressions like `rec X:G (; +; X ; X + )' are an informal notation for certain locally continuous functors.
Reference: <author> Pitts, A. M. </author> <year> (1993a), </year> <title> Computational adequacy via `mixed' inductive definitions, </title> <booktitle> in "Proc. 9th Conf. on the Math. Foundations of Programming Language Semantics, </booktitle> <address> New Orleans", </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> to appear. </note>
Reference-contexts: This is considered briefly in Sect. 6. Rather than deducing adequacy results from 23 a general theory of relational properties, one can also apply the key techniques in our proof on an ad hoc basis. <ref> (Pitts, 1993a) </ref> illustrates this direct approach with respect to a simple language based upon the untyped lambda calculus with arithmetic operations. 5 Induction and co-induction principles Many kinds of relational structure on Cpo ? possess distinguished `identity' relations.
Reference: <author> Plotkin, G. D. </author> <year> (1973), </year> <title> Lambda definability and logical relations, </title> <institution> Memorandum SAI-RM-4, Univ. Edinburgh School of Artificial Intelligence. </institution>
Reference: <author> Plotkin, G. D. </author> <year> (1976), </year> <title> A powerdomain construction, </title> <journal> SIAM J. Comput. </journal> <volume> 5, </volume> <pages> 452-487. </pages>
Reference-contexts: Nevertheless, it can be useful to consider formulations of co-induction principles like Theorem 5.12 which relax the conditions imposed on the functor F . For example, (Pitts, 1992, Sect. 5) extends Corollary 5.13 to domain constructors (ff) involving the Plotkin powerdomain, P " <ref> (Plotkin, 1976) </ref>. In this case the proof is not quite a corollary of Theorem 5.12, because the operation R 2 S (D) 7! P " (R) given there does not obviously satisfy the requirements of Definition 3.6 to be an admissible action.
Reference: <author> Plotkin, G. D. </author> <year> (1977), </year> <title> LCF considered as a programming language, </title> <booktitle> Theoretical Computer Science 5, </booktitle> <pages> 223-255. </pages>
Reference: <author> Plotkin, G. D. </author> <year> (1985), </year> <title> "Lectures on Predomains and Partial Functions". Notes for a course at CSLI, </title> <publisher> Stanford University. </publisher>
Reference-contexts: For particular choices of the notion of relation, these invariant relations lie at the heart of some proofs of correspondence between denotational and operational semantics (as in <ref> (Plotkin, 1985) </ref>, or (Meyer and Cosmodakis,1988, Appendix), for example), or between two denotational semantics (as in (Reynolds, 1974) for example). <p> So it only remains to prove (15). Adapting the method in <ref> (Plotkin, 1985) </ref>, this can be done by constructing a type-indexed family of `formal approximation' relations C [[]] # fi Can with the following properties: 8c 2 Can (fd j d C cg is chain-complete) (16) d C unit () , d = 0 (17) d C bool false , d = <p> theorem generalizes easily to the case of functors G with more than one extra parameter, i.e. of the form (Cpo op op Using it, the method developed in Sect. 4 for proving computational adequacy can be applied to functional languages involving recursive types with parameters, such as the metalanguage in <ref> (Plotkin, 1985) </ref>. <p> Concluding remarks As far as this paper is concerned, expressions like `rec X:G (; +; X ; X + )' are an informal notation for certain locally continuous functors. However, it would be interesting to extend the work in <ref> (Plotkin, 1985) </ref> to a metalanguage for recursive types whose syntax enforces the separation of positive and negative occurrences, whilst somehow still allowing diagonalization back to the `usual' language of recursive types; together with a logic formalizing the various relational properties of (parameterized recursive) domains we have established here.
Reference: <author> Plotkin, G. D., and Abadi, M. </author> <year> (1993), </year> <title> A logic for parametric polymorphism, </title> <booktitle> in "Proceedings of the Conference on Typed Lambda Calculus and its Applications, Utrecht", Lecture Notes in Computer Science Vol. </booktitle> <volume> 664, </volume> <pages> pp. 361-375, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The utility of considering actions of type constructors on relations is perhaps best known from the body of work beginning with (Reynolds, 1983) on relational properties of parametric polymorphism: see (Abadi, Cardelli and Curien, 1993) and <ref> (Plotkin and Abadi, 1993) </ref> and the references therein. It is well known that inductive and co-inductive types can be encoded in the Girard-Reynolds polymorphic lambda calculus. Hence they inherit relational properties from those of 8-types.
Reference: <author> Reynolds, J. C. </author> <year> (1974), </year> <title> On the relation between direct and continuation semantics, </title> <booktitle> in "2nd Int. Colloq. on Automata, Languages and Programming" (Loeckx, </booktitle> <editor> J., Ed.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 14, </volume> <pages> pp. 141-156, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: For particular choices of the notion of relation, these invariant relations lie at the heart of some proofs of correspondence between denotational and operational semantics (as in (Plotkin, 1985), or (Meyer and Cosmodakis,1988, Appendix), for example), or between two denotational semantics (as in <ref> (Reynolds, 1974) </ref> for example). <p> Then the desired relation can be constructed as an intersection of countably many relations defined by induction on n at the same time as the D n are defined; see <ref> (Reynolds, 1974) </ref>. A second method, essentially due to Martin-Lof, applies only to Scott domains (precluding the use of constructors like the Plotkin powerdomain) since it makes use of their presentation in terms of `information systems' (Scott, 1982).
Reference: <author> Reynolds, J. C. </author> <year> (1983), </year> <title> Types, abstraction and parametric polymorphism, in "Information Processing 83" (Mason, </title> <editor> R. E. A., </editor> <publisher> Ed.), </publisher> <pages> pp. 513-523, </pages> <publisher> Elsevier Science Publishers B.V., Amsterdam. </publisher>
Reference-contexts: However, identity relations will play a key role in formulating the induction and coinduction principles considered in Sect. 5. For all these applications we only need to consider `unary' relational structures, whereas O'Hearn and Tennent need binary ones in order to use Reynolds' notion of relational parametricity <ref> (Reynolds, 1983) </ref>. <p> The utility of considering actions of type constructors on relations is perhaps best known from the body of work beginning with <ref> (Reynolds, 1983) </ref> on relational properties of parametric polymorphism: see (Abadi, Cardelli and Curien, 1993) and (Plotkin and Abadi, 1993) and the references therein. It is well known that inductive and co-inductive types can be encoded in the Girard-Reynolds polymorphic lambda calculus. Hence they inherit relational properties from those of 8-types.
Reference: <author> Rutten, J. J. M. M. </author> <year> (1993), </year> <title> A structural co-induction theorem, </title> <type> Report CS-R9346, </type> <institution> CWI, </institution> <address> Amsterdam. </address> <booktitle> To appear in "Proc. 9th Conf. on the Math. Foundations of Programming Language Semantics, </booktitle> <address> New Orleans", </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: We refer the reader to (Pitts, 1992) for further discussion and applications of this co-inductive characterization of the partial order on recursively defined cppos. (See also (Fiore, 1993) and <ref> (Rutten, 1993) </ref>; and (Paulson, 1993) for related applications.) The existence of a simulation (i.e. a relation satisfying (36)) containing two elements of a recursively defined cppo establishes that the order relation holds between them.
Reference: <author> Scott, D. S. </author> <year> (1982), </year> <title> Domains for denotational semantics, </title> <booktitle> in "Proc. 9th Inter-nat. Coll. on Automata, Languages and Programming" (Nielsen, </booktitle> <editor> M., and Schmidt, E. M., Eds), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 140, </volume> <pages> pp 577-613, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: A second method, essentially due to Martin-Lof, applies only to Scott domains (precluding the use of constructors like the Plotkin powerdomain) since it makes use of their presentation in terms of `information systems' <ref> (Scott, 1982) </ref>. This method hinges upon the fact that each fd j d (C ) ? eg is in fact a Scott-closed subset of [[]].
Reference: <author> Smyth, M. B., and Plotkin, G. D. </author> <year> (1982), </year> <title> The category-theoretic solution of recursive domain equations, </title> <journal> SIAM J. Computing 11, </journal> <pages> 761-783. </pages>
Reference-contexts: The seminal work of Scott, Plotkin and several others shows that such solutions 5 always exist: there is the category-theoretic construction in terms of the colimit of a chain of embedding-projection pairs which was Scott's original method and whose full ramifications are presented in <ref> (Smyth and Plotkin, 1982) </ref>; there is the set-theoretic construction in terms of Scott's notion of `information system' (Scott, 1982; Winskel and Larsen, 1984), which has the advantage of yielding solutions up to equality rather than just up to isomorphism; and there is the related approach using least fixed points of continuous <p> Whilst it is true that all the ingredients of the proofs of Theorems 2.3 and 2.4 have been present for some time|they can certainly be found in <ref> (Smyth and Plotkin, 1982) </ref>|Freyd has abstracted from them what appears to be a very powerful property.
Reference: <author> Thompson, S. </author> <year> (1989), </year> <title> A logic for Miranda, </title> <booktitle> Formal Aspects of Computing 1, </booktitle> <pages> 339-365. </pages>
Reference-contexts: This is too restrictive since it cuts out `lazy' datatypes (containing partial and potentially infinite values), which are an important functional programming tool and unavoidable by design in non-strict languages such as Haskell. Whilst properties of lazy datatypes have been considered on a case-by-case basis (see <ref> (Thompson, 1989) </ref>, for example), there are remarkably few reasoning principles in the literature that apply uniformly to all recursive datatypes including ones whose definitions contain negative occurrences of the declared type.
Reference: <author> Wadsworth, C. P. </author> <year> (1976), </year> <title> The relation between computational and denotational properties for Scott's D 1 models of the lambda-calculus, </title> <journal> SIAM J. Comput. </journal> <volume> 5, </volume> <pages> 488-521. </pages>
Reference: <author> Winskel, G. </author> <year> (1993), </year> <title> "The Formal Semantics of Programming Languages. An Introduction", </title> <publisher> MIT Press. 37 Winskel, </publisher> <editor> G., and Larsen, K. G. </editor> <year> (1984), </year> <title> Using information systems to solve re-cursive domain equations effectively, in "Semantics of Data Types" (Kahn, </title> <editor> G., et al, Eds), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 173, </volume> <pages> pp. 109-130, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address> <month> 38 </month>
Reference-contexts: The argu-ment is due to Plotkin (private communication) and should be compared with the proofs of similar results in (Barendregt, 1984, Exercise 18.4.20) and <ref> (Winskel, 1993, Sect. 13.10.2) </ref>. Example 2.6 Let D be rec ff:(ff ! ff) ? , the canonical domain model of the lazy lambda calculus studied in (Abramsky, 1990) and (Abramsky and Ong, 1993). <p> The clauses of the definition of [[]] are all quite standard and we omit them. (See <ref> (Winskel, 1993, Sect. 13.3) </ref> for example.) We aim to show that this denotational semantics is adequate for establishing that two expressions have the same observable behaviour under evaluation in all program contexts. We will use a notion of observation based upon the form of a canonical expression of arbitrary type. <p> Information systems provide a formal language for compact elements of (recursively defined) Scott domains, and a (C ) ? e (a compact) can be defined by a well-founded induction on the size of (a formal representation of) a; see <ref> (Winskel, 1993, Sect. 13.4) </ref>. Here we show that the existence of relations C satisfying (16)-(22) follows directly from Theorem 3.16 by choosing a suitable relational structure R on Cpo ? and defining admissible actions of the appropriate domain constructors.
References-found: 37

