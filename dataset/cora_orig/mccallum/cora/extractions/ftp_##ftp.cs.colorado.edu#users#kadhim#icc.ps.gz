URL: ftp://ftp.cs.colorado.edu/users/kadhim/icc.ps.gz
Refering-URL: http://www.cs.colorado.edu/~kadhim/papers.html
Root-URL: http://www.cs.colorado.edu
Email: fBasim.Kadhim,William.Waiteg@Colorado.EDU  
Title: Maptool Supporting Modular Syntax Development  
Author: Basim M. Kadhim and William M. Waite 
Keyword: Abstract syntax, concrete syntax, modularity, parsing gram mar, syntax development, syntax mapping, tree construction  
Address: Boulder, CO 80309-0425, USA  
Affiliation: University of Colorado,  
Abstract: In building textual translators, implementors often distinguish between a concrete syntax and an abstract syntax. The concrete syntax describes the phrase structure of the input language and the abstract syntax describes a tree structure that can be used as the basis for performing semantic computations. Having two grammars imposes the requirement that there exist a mapping from the concrete syntax to the abstract syntax. The research presented in this paper led to a tool, called Maptool, that is designed to simplify the development of the two grammars. Maptool supports a modular approach to syntax development that mirrors the modularity found in semantic computations. This is done by allowing users to specify each of the syntaxes only partially as long as the sum of the fragments allows deduction of the complete syntaxes. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho and Stephen C. Johnson. </author> <title> Optimal code generation for expression trees. </title> <journal> Journal of the ACM, </journal> <volume> 23(3) </volume> <pages> 488-501, </pages> <month> July </month> <year> 1976. </year>
Reference-contexts: An interesting part of the Maptool implementation is its use of OIL, an operator identification library available in the Eli system. Operator identification is a well understood process, first discussed by Aho and Johnson in 1976 <ref> [1, 10] </ref>. The signatures of abstract productions can quite easily be cast as operators, chain rules are represented by coercions, and the signature of the concrete syntax rules are analogous to expressions whose operators must be determined.
Reference: 2. <author> Ali Bahrami. </author> <title> CAGT an automated approach to abstract and parsing grammars. </title> <type> Master's thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Colorado, Boulder, CO, </institution> <year> 1986. </year>
Reference-contexts: This technique was first implemented in the Eli system by a tool called CAGT <ref> [2] </ref>. The research in this paper will also discuss a technique for dealing with cases in which the abstract syntax needs to distinguish, based on context, between constructs that have identical phrase structure.
Reference: 3. <author> Robert A. Ballance, Jacob Butcher, and Susan L. Graham. </author> <title> Grammatical abstraction and incremental syntax analysis in a language-based editor. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 185-198. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Together, the two grammars provide the foundation for verifying the syntactic and semantic correctness of a program in the language. The desirability of distinguishing between a concrete and abstract syntax is discussed in <ref> [3, 4] </ref>. A concrete syntax can be input to a parser generator, which will then produce a parser for the language. <p> This does not allow the grouping of symbols into symbolic equivalence classes. The work of Ballance et. al. <ref> [3] </ref> on grammatical abstraction is also closely related to the work presented here. Grammatical abstraction, however, does not allow the abstract syntax to distinguish between constructs with identical phrase structure.
Reference: 4. <author> Franklin L. DeRemer. </author> <title> Compiler Construction; An Advanced Course, </title> <booktitle> chapter 2.E., </booktitle> <pages> pages 121-145. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, Heidelberg, Berlin, </address> <note> second edition, </note> <year> 1976. </year>
Reference-contexts: Together, the two grammars provide the foundation for verifying the syntactic and semantic correctness of a program in the language. The desirability of distinguishing between a concrete and abstract syntax is discussed in <ref> [3, 4] </ref>. A concrete syntax can be input to a parser generator, which will then produce a parser for the language. <p> Explicit Rule Mapping There are times when symbolic equivalence classes and implicit rule mapping do not provide enough flexibility. For example, DeRe-mer recognized the desire for standardization of certain language constructs <ref> [4] </ref>. The example he gives involves "let expressions" and "where expressions." "Let expressions" have the form LetExpr ! 'let' Definitions 'in' Expr, while "where expressions" have the form W hereExpr ! Expr 'where' Definitions. The syntax is different, but the semantics of the two kinds of expressions are identical.
Reference: 5. <author> Franklin L. DeRemer. </author> <title> Compiler Construction; An Advanced Course, </title> <booktitle> chapter 2.A., </booktitle> <pages> pages 37-56. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, Heidelberg, Berlin, </address> <note> second edition, </note> <year> 1976. </year>
Reference-contexts: The research in this paper will also discuss a technique for dealing with cases in which the abstract syntax needs to distinguish, based on context, between constructs that have identical phrase structure. Some of the mappings described in this paper bear strong resemblance to Transduction Grammars <ref> [5] </ref>, however Transduction Grammars require that the same nonterminals be used in the original and the transformed versions of rules. This does not allow the grouping of symbols into symbolic equivalence classes. <p> The tree construction is based on a scheme in which constructed subtrees are placed on a stack and used when concrete syntax rules are reduced to construct new subtrees to place on the stack. This is very much like the scheme used for tree transduction grammars <ref> [5] </ref>. Variadic Nodes Languages are replete with lists of things, such as lists of declarations or lists of statements. While parsing grammars require the introduction of recursive rules to describe such lists, it is convenient to view such a list as a single flat context when describing the semantics.
Reference: 6. <author> Robert W. Gray, Vincent P. Heuring, Steve P. Levi, Anthony M. Sloane, and William M. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Section 4 shows how the concrete and abstract syntaxes are made complete. The paper concludes with some notes about the implementation of Maptool and its use in the Eli Compiler Construction System <ref> [6] </ref>. 2 Related Work Rosenkrantz and Hunt [11] use the notion of symbolic equivalence to join several abstract symbols into a single concrete symbol in order to find a concrete grammar that falls into a parsable class (such as LL (1) or LR (1)). <p> Decl ! T ype Identifier AssignStmt ! Identif ier 0 = 0 Expression Fig. 3. Concrete Syntax for Identifier Definitions and Uses Symbolically distinguishing between these two different uses of Identifier may simplify semantic computations. Systems (like Eli <ref> [6] </ref>) where computations can be provided for occurrences of symbols in the abstract syntax tree benefit by not having to distinguish between occurrences of the same symbol in different contexts. This technique is used heavily in developing modular and reusable attribute grammars as demonstrated in [7].
Reference: 7. <author> U. Kastens and W. M. Waite. </author> <title> Modularity and reusability in attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 31 </volume> <pages> 601-627, </pages> <year> 1994. </year>
Reference-contexts: Including such rules in the abstract syntax also unnecessarily increases the size of the tree. Consequently, it is desirable to allow for differences between the syntaxes by supporting a set of mappings. Semantic computations can most often be divided into several different modules <ref> [7] </ref>. Name analysis, type analysis, and output generation are examples of common semantic computations that can be thought of as individual modules and can in many cases be implemented in isolation from one another. Each of these modules typically only specifies computations for some of the nodes in the tree. <p> Systems (like Eli [6]) where computations can be provided for occurrences of symbols in the abstract syntax tree benefit by not having to distinguish between occurrences of the same symbol in different contexts. This technique is used heavily in developing modular and reusable attribute grammars as demonstrated in <ref> [7] </ref>. The abstract syntax fragment that distinguishes between identifier uses and definitions is shown in Fig. 4. The figure shows that two new symbols, IdDef and IdU se, are introduced to represent definitions and uses, respectively. <p> Maptool has been a component of the Eli system for over a year and has been successful in supporting the development of modular specifications in concert with the support for modularity afforded by the LIGA evaluator <ref> [7] </ref>. 6 Acknowledgments We would like to thank the members of the Eli team, with special thanks to Dr. Uwe Kastens, for their numerous contributions to this research. This work was partially supported by the US Army Research Office under grant DAAL03-92-G-0158.
Reference: 8. <author> Uwe Kastens. LIGA: </author> <title> A language independent generator for attribute evaluators. </title> <type> Technical Report Reihe Informatik 63, </type> <institution> Universitat-GH Paderborn, Fachbereich Mathematik-Informatik, </institution> <year> 1989. </year>
Reference-contexts: Given these inputs, Maptool yields a complete concrete syntax annotated with reduction actions that build the appropriate abstract syntax tree using the tree construction module exported by the LIGA attribute grammar evaluator <ref> [8] </ref>. It also produces a complete abstract syntax in notation usable as input to LIGA. An interesting part of the Maptool implementation is its use of OIL, an operator identification library available in the Eli system.
Reference: 9. <author> Anton Nijholt. </author> <title> Context-Free Grammars: Covers, Normal Forms, and Parsing, </title> <booktitle> volume 93 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1980. </year>
Reference-contexts: This work is consistent with other research in the area of grammatical covers <ref> [9] </ref>. It is our experience, however, that the notion of symbolic equivalence is more useful in the opposite direction: several concrete symbols form an equivalence class that is represented by a single symbol in the abstract syntax.
Reference: 10. <author> Guido Persch, Georg Winterstein, Manfred Dausmann, </author> <title> and Sophia Drossopoulou. Overloading in preliminary Ada. </title> <journal> SIGPLAN Notices, </journal> <volume> 15(11) </volume> <pages> 47-56, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: An interesting part of the Maptool implementation is its use of OIL, an operator identification library available in the Eli system. Operator identification is a well understood process, first discussed by Aho and Johnson in 1976 <ref> [1, 10] </ref>. The signatures of abstract productions can quite easily be cast as operators, chain rules are represented by coercions, and the signature of the concrete syntax rules are analogous to expressions whose operators must be determined.
Reference: 11. <author> D. J. Rosenkrantz and H. B. Hunt. </author> <title> Efficient algorithms for automatic construction and compactification of parsing grammars. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 543-566, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Section 4 shows how the concrete and abstract syntaxes are made complete. The paper concludes with some notes about the implementation of Maptool and its use in the Eli Compiler Construction System [6]. 2 Related Work Rosenkrantz and Hunt <ref> [11] </ref> use the notion of symbolic equivalence to join several abstract symbols into a single concrete symbol in order to find a concrete grammar that falls into a parsable class (such as LL (1) or LR (1)).
Reference: 12. <author> William M. Waite and Gerhard Goos. </author> <title> Compiler Construction. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin, Heidelberg, Tokyo, </address> <year> 1984. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: In order for the concrete syntax to be usable by a parser generator, it must be unambiguous and typically must have either the LL (1) or LALR (1) property (depending on the parser generator being used) <ref> [12] </ref>. An abstract syntax describes the structure of trees over which computations are to be performed. While symbols and rules are included in a concrete syntax to handle things like operator precedence and associativity, these distinctions are unimportant in describing semantic computations.
References-found: 12

