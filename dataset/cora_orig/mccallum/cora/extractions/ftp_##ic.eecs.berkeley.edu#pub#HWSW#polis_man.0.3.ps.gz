URL: ftp://ic.eecs.berkeley.edu/pub/HWSW/polis_man.0.3.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/hsc/abstract.html
Root-URL: http://www.cs.berkeley.edu
Title: Polis A design environment for control-dominated embedded systems version 0.3 User's Manual  
Author: Felice Balarin Massimiliano Chiodo Daniel Engels Paolo Giusto Wilsin Gosti Harry Hsieh Attila Jurecska Marcello Lajolo Luciano Lavagno Claudio Passerone Roberto Passerone Claudio Sansoe Marco Sgroi Ellen Sentovich Kei Suzuki Bassam Tabbara Reinhard von Hanxleden Sherman Yee Alberto Sangiovanni-Vincentelli 
Address: Telecomunicazioni, Torino, I  
Affiliation: University of California, Berkeley, CA Cadence Berkeley Labs of Cadence Design Systems Inc., Berkeley, CA Magneti Marelli, Torino and Pavia, I Politecnico di Torino, Torino, I Hitachi Ltd., Tokyo, JP Daimler Benz GMBH, Berlin, DE Centro Studi e Laboratori di  
Note: The following organizations have contributed to the development of the software included in this distribution:  
Date: December 18, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Hence, the s-graph is a reduced form of the control-flow graphs that are used in compiler technology (see, e.g., <ref> [1] </ref>). As such, it is amenable to the standard set of optimizations that are done by compilers, plus some specific ones. An s-graph is a directed acyclic graph (DAG), containing the following types of vertices: BEGIN, END, TEST, and ASSIGN.
Reference: [2] <author> F. Balarin, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Formal verification of embedded systems based on CFSM networks. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <year> 1996. </year>
Reference-contexts: Polis can generate a synchronous Finite State Machine network representation of the asynchronous CFSM network. The translation process creates the input and output FSM buffers which are necessary to implement the CFSM non-zero unbounded delay. For details of this translation process, see <ref> [2] </ref>. The FSM representation is written in BLIF-MV. The syntactic rules and semantic interpretation of BLIF-MV can be found in [7]. This generated BLIF-MV file can then be subsequently used by a public domain verification system from the University of California at Berkeley, called Verification Interacting with Synthesis (VIS). <p> For a complete description the reader is referred to [11] and <ref> [2] </ref>. 14.3.1 Transition Relation Each row of the transition table corresponds to one or more elements in the transition relation in an obvious way. The symbol "-" is used to denote a don't care value.
Reference: [3] <author> F. Balarin, E. Sentovich, M. Chiodo, P. Giusto, H. Hsieh, B. Tabbara, A. Jurecska, L. Lavagno, C. Passerone, K. Suzuki, and A. Sangiovanni-Vincentelli. </author> <title> Hardware-Software Co-design of Embedded Systems The POLIS approach. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference-contexts: It does not cover in detail, however, the supported specification languages ([14]), nor the underlying computational models ([10]), nor the implemented analysis and synthesis algorithms ([12, 13, 2]). The most recent summary of the overall Polis methodology and algorithms is presented in <ref> [3] </ref>. The document is organized into sections. We recommend reading all of them even if you are not planning to use some features, because information about some commands is interspersed along the way. The Section 2 contains a quick description of Polis through two simple introductory examples. <p> BRA Defines the execution time for an unconditional branch (see also <ref> [3] </ref> for a dis cussion of adjustements of branching costs). 3.
Reference: [4] <author> Felice Balarin and Khurram Sajid. </author> <title> Simplifying data operations for formal verification. </title> <booktitle> In Proc-cedings of the XIII IFIP WG 10.5 Conference on Computer Hardware Description Languages and Their Applications, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: In this mode, the user provides a file specifying abstractions of some variables in the network. These abstraction are then propagated and abstract models of nodes in the network are created whenever possible (including possibly abstract models of arithmetic nodes). The details of the process are described in <ref> [4] </ref>.
Reference: [5] <author> G. Berry, P. Couronne, and G. Gonthier. </author> <title> The synchronous approach to reactive and real-time systems. </title> <journal> IEEE Proceedings, </journal> <volume> 79, </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: CFSMs are not meant to be used by designers as a specification language. The FSM semantics of each CFSM ensures that a wealth of graphical and textual languages can be used to specify their individual behaviors, like: * reactive synchronous languages, such as StateCharts [16], Esterel <ref> [5] </ref>, Lustre and Signal [18], * the so-called "synthesizable subsets" of hardware description languages such as VHDL and Verilog, * system specification languages with an FSM semantics, such as SDL [24] (limited to a single SDL process per CFSM). 6 User-defined functions can be either described in a simple, implementation-independent tabular <p> likely 5000) transitions in which signal msec has an event, and then yields control to the emit statement, which emits the corresponding signal. 8 The abort : : : when x command was formerly written as do : : : watching x in Esterel. 14 Esterel is a synchronous language <ref> [5, 18] </ref>. This means that computation takes (at least conceptually) zero time. Time elapses only when control reaches a halt or await statement. <p> The main steps are as follows: 1. High Level Language Translation Designers write their specifications using some high level language that must have an Extended Finite State Machine semantics. Examples of such languages are Esterel <ref> [5] </ref> (used for most of the examples in this manual, Section 5.1), StateCharts [16], and the synthesizable subsets of of Verilog or VHDL. Esterel source files are characterized by an extension .strl.
Reference: [6] <author> R. Brayton, A. Sangiovanni-Vincentelli, A. Aziz, S. Cheng, S. Edwards, S. Khatri, Y. Kuki-moto, S. Qadeer, R. Ranjan, T. Shiple, G. Swamy, T. Villa, G. Hachtel, F. Somenzi, A. Pardo, and S. Sarwary. </author> <title> VIS: A System for Verification and Synthesis. </title> <booktitle> In Proc. of the 8th International Conference on Computer Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [7] <author> R.K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R.P. Kurshan, S. Malik, A.L. Sangiovanni-Vincentelli, E.M. Sentovich, T. Shiple, and H.Y. Wang. </author> <title> BLIF-MV:an interchange format for design verification and synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> U.C. Berkeley, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: The translation process creates the input and output FSM buffers which are necessary to implement the CFSM non-zero unbounded delay. For details of this translation process, see [2]. The FSM representation is written in BLIF-MV. The syntactic rules and semantic interpretation of BLIF-MV can be found in <ref> [7] </ref>. This generated BLIF-MV file can then be subsequently used by a public domain verification system from the University of California at Berkeley, called Verification Interacting with Synthesis (VIS). <p> Please, send any bug reports or comments to polis-bugs@ic.eecs.berkeley.edu. 100 14 The SHIFT intermediate language Software-Hardware Intermediate FormaT (SHIFT) is a representation format for describing Code-sign Finite State Machine (CFSM) specification in forms of files. SHIFT is mainly an extension of BLIF-MV <ref> [7] </ref>, which is a multi-value version of the Berkeley Logic Interchange Format (BLIF).
Reference: [8] <author> J. Buck, S. Ha, E.A. Lee, and D.G. Masserschmitt. Ptolemy: </author> <title> a framework for simulating and prototyping heterogeneous systems. </title> <journal> Interntional Journal of Computer Simulation, special issue on Simulation Software Development, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Moreover, it does not require an accurate model of the target processor, and hence can be used to choose one without the need to purchase a cycle-accurate model from a vendor. For co-simulation purposes, Polis is used to generate the C code, but the Ptolemy system (see <ref> [8] </ref>) provides the simulator engine and the graphical interface. Co-simulation in the Polis environment is based on the discrete event (DE) computation model, because it closely matches the CFSM execution semantics. Each event occurring in the system (the design and its environment) is tagged by a time of occurrence.
Reference: [9] <author> J. T. Buck. </author> <title> Scheduling Dynamic Dataflow Graphs with Bounded Memory Using the Token Flow Model. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year> <note> UCB/ERL Memo M93/69. </note>
Reference-contexts: specify this behavior is as follows: 21 The Esterel tick signal cannot be used for this purpose, unfortunately, because it is removed by the Esterel compiler from the input signal list. 22 The implicit buffers are of size one, rather than of infinite size as in real data flow networks <ref> [9] </ref>. 49 module adder: input a: integer, b: integer; output c:integer; loop [await a || await b]; emit c (?a + ?b); end. See also Section 10.1 for a different mechanism (especially useful for data flow-oriented specifications) to implement this behavior at the software synthesis/RTOS level.
Reference: [10] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> A formal specification model for hardware/software codesign. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <year> 1993. </year>
Reference: [11] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> A formal specification model for hardware/software codesign. </title> <type> Technical Report UCB/ERL M93/48, </type> <institution> U.C. Berkeley, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: For a complete description the reader is referred to <ref> [11] </ref> and [2]. 14.3.1 Transition Relation Each row of the transition table corresponds to one or more elements in the transition relation in an obvious way. The symbol "-" is used to denote a don't care value.
Reference: [12] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Hardware/software codesign of embedded systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 26-36, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Note that the overall modeling philosophy implied by the Polis system is somewhat peculiar, with both advantages and disadvantages with respect to other digital and embedded system design methods. In particular, the CFSM model that is at the basis of Polis <ref> [12] </ref> is designed so as to put the least constraint on the implementation, while still maintaining a reasonable control over the performance and behavior of the implementation, as well as over the synthesis process.
Reference: [13] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Synthesis of software programs from CFSM specifications. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year> <month> 109 </month>
Reference-contexts: By default, this information is printed on the standard error. 76 9 Software synthesis This section describes how the software generation and the timing and code size estimation commands work. It does not explain the underlying algorithms (the interested reader is referred to <ref> [13] </ref> and [26] for more details). Some of the relevant commands have been introduced already, namely in Section 6.1. Here we describe only the new commands, and some more specific options dealing with software optimization. <p> This command can use several algorithms for this estimation, as selected by the -s and -c options. The former uses an internal data structure called s-graph (see <ref> [13] </ref>) that is very close to the final C code for estimation, and requires build sg (and hence read shift, set impl, and partition) to be executed first.
Reference: [14] <author> CISI Ingenierie, Agence Provence Est, </author> <title> Les Cardoulines B1 06560 Valbonne, France. Esterel V-3, Language Reference Manual, </title> <year> 1988. </year>
Reference: [15] <author> J. B. Dennis. </author> <title> First version data flow procedure language. </title> <type> Technical Report MAC TM61, </type> <institution> Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1975. </year>
Reference: [16] <author> D. Drusinski and D. Har'el. </author> <title> Using statecharts for hardware description and synthesis. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 8(7), </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: CFSMs are not meant to be used by designers as a specification language. The FSM semantics of each CFSM ensures that a wealth of graphical and textual languages can be used to specify their individual behaviors, like: * reactive synchronous languages, such as StateCharts <ref> [16] </ref>, Esterel [5], Lustre and Signal [18], * the so-called "synthesizable subsets" of hardware description languages such as VHDL and Verilog, * system specification languages with an FSM semantics, such as SDL [24] (limited to a single SDL process per CFSM). 6 User-defined functions can be either described in a simple, <p> The main steps are as follows: 1. High Level Language Translation Designers write their specifications using some high level language that must have an Extended Finite State Machine semantics. Examples of such languages are Esterel [5] (used for most of the examples in this manual, Section 5.1), StateCharts <ref> [16] </ref>, and the synthesizable subsets of of Verilog or VHDL. Esterel source files are characterized by an extension .strl.
Reference: [17] <author> W.A. Halang and A.D. Stoyenko. </author> <title> Constructing predictable real time systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Hence the choice of scheduling algorithm must carefully consider the real-time characteristics of the system at hand. Polis provides both conservative analysis techniques (based on classical real-time theory results, summarized e.g. in <ref> [17] </ref>) and the estimated timing simulation technique described above, in order to choose the scheduling policy for a given system. The Real-Time Operating System synthesis command in Polis is called gen os. Its purpose is three-fold: 1.
Reference: [18] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: The FSM semantics of each CFSM ensures that a wealth of graphical and textual languages can be used to specify their individual behaviors, like: * reactive synchronous languages, such as StateCharts [16], Esterel [5], Lustre and Signal <ref> [18] </ref>, * the so-called "synthesizable subsets" of hardware description languages such as VHDL and Verilog, * system specification languages with an FSM semantics, such as SDL [24] (limited to a single SDL process per CFSM). 6 User-defined functions can be either described in a simple, implementation-independent tabular format in SHIFT, thus <p> likely 5000) transitions in which signal msec has an event, and then yields control to the emit statement, which emits the corresponding signal. 8 The abort : : : when x command was formerly written as do : : : watching x in Esterel. 14 Esterel is a synchronous language <ref> [5, 18] </ref>. This means that computation takes (at least conceptually) zero time. Time elapses only when control reaches a halt or await statement.
Reference: [19] <author> G. Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <booktitle> In Proceedings of IFIP Congress, </booktitle> <month> August </month> <year> 1974. </year>
Reference: [20] <author> E. A. Lee and D. G. Messerschmitt. </author> <title> Static scheduling of synchronous data flow graphs for digital signal processing. </title> <journal> IEEE Transactions on Computers, </journal> <month> January </month> <year> 1987. </year>
Reference-contexts: This is the case, for example, for data-flow-oriented systems, in which tasks (data flow actors) become enabled because of the arrival of input events, which generally arrive in regular (sampled) streams <ref> [20] </ref>. On the other hand, if the time of enabling (readiness) of tasks is unpredictable, as is the case for the control-dominated targeted by Polis, such a scheme may be too inefficient.
Reference: [21] <author> C. Liu and J.W Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 44-61, </pages> <month> January </month> <year> 1973. </year>
Reference: [22] <author> C.L. Liu and James W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1):46 - 61, </volume> <month> January </month> <year> 1973. </year>
Reference-contexts: An application-specific OS, consisting of a scheduler and I/O drivers, is generated for each partitioned design. Currently POLIS allows the designer to choose from a set of classical scheduling algorithms (e.g. Rate-Monotonic and Deadline-Monotonic, <ref> [22] </ref>). Interfaces between different implementation domains (hardware-software) are automatically synthesized by Polis as part of the RTOS and hardware synthesis tasks. These interfaces come in the form of cooperating circuits and software procedures (I/O drivers) embedded in the synthesized implementation. 6.
Reference: [23] <editor> J. Rowson. Hardware/software co-simulation. </editor> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 439-440, </pages> <year> 1994. </year>
Reference-contexts: The purpose of high-level co-simulation is to provide the designer with a flexible environment in which architectural trade-offs can be explored. Precise validation of the final implementation should be done with a much more accurate model (e.g. a cycle-accurate processor model and a hardware simulator <ref> [23] </ref>). Both the simulation testbench and the formal properties used to validate the specification should be chosen with these considerations in mind. In particular, any attempt to compare specification and implementation, based on exact timing data has little chance of success (except perhaps in the case of a fully-hardware implementation).
Reference: [24] <author> R. Saracco, J.R.W. Smith, and R. Reed. </author> <title> Telecommunications systems engineering using SDL. </title> <publisher> North-Holland - Elsevier, </publisher> <year> 1989. </year>
Reference-contexts: textual languages can be used to specify their individual behaviors, like: * reactive synchronous languages, such as StateCharts [16], Esterel [5], Lustre and Signal [18], * the so-called "synthesizable subsets" of hardware description languages such as VHDL and Verilog, * system specification languages with an FSM semantics, such as SDL <ref> [24] </ref> (limited to a single SDL process per CFSM). 6 User-defined functions can be either described in a simple, implementation-independent tabular format in SHIFT, thus retaining full automatic analysis and synthesis capabilities, or in an implementation-dependent host language, such as C or Verilog. 11 The interconnection between the CFSMs, on the
Reference: [25] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: For rapid prototyping purposes, Polis provides a path to implementation using XILINX FPGAs, by producing the output netlist in the XNF format. Other output logic netlist formats include BLIF, Verilog and VHDL (the latter two use a very simple technology-independent basic gate library). See the documentation of SIS <ref> [25] </ref> for more information about logic optimization, technology mapping and library description formats. <p> Hardware Synthesis A CFSM sub-network chosen for hardware implementation is directly mapped, as described in Section 11, into an abstract hardware description format. This format can be BLIF (files with extension .blif, <ref> [25] </ref>), VHDL (files with extension .vhd) or XNF (files with extension .xnf, for implementation on Field Programmable Gate Arrays), as described in Section 11. 7. <p> The cost of hardware CFSMs can be estimated by executing the net to blif command on a selected set of modules (unrestricted hardware synthesis may take an excessive amount of time, on modules with many complex arithmetic operators). Then the logic synthesis commands (see Section 11 and <ref> [25] </ref>) can be used to optimize and estimate the cost of the logic. The current partition can be defined by using the implem instance parameter in Ptolemy (Section 6.1), saving the netlist, translating it to SHIFT and reading it inside polis. <p> If a single FPGA is not enough, the kl part command can be used to split the Boolean network into multiple networks, each of which can be implemented as a separate FPGA. The commands to implement the network as an FPGA are described more in detail in <ref> [25] </ref> and in the Polis help pages. We recommend to have a look at the pre-defined scripts for the XILINX 4000 and XILINX 3000 architectures first. Polis also supports technology mapping to ACTEL FPGAs, using the act map command.
Reference: [26] <author> K. Suzuki and A. Sangiovanni-Vincentelli. </author> <title> Efficient software performance estimation models for hardware/software codesign. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: By default, this information is printed on the standard error. 76 9 Software synthesis This section describes how the software generation and the timing and code size estimation commands work. It does not explain the underlying algorithms (the interested reader is referred to [13] and <ref> [26] </ref> for more details). Some of the relevant commands have been introduced already, namely in Section 6.1. Here we describe only the new commands, and some more specific options dealing with software optimization.
References-found: 26

