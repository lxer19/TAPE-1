URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1283/CS-TR-95-1283.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1283/
Root-URL: http://www.cs.wisc.edu
Title: Demand Interprocedural Dataflow Analysis a polynomial worst-case cost for both a single demand and a
Author: Susan Horwitz, Thomas Reps, and Mooly Sagiv 
Keyword: General Terms: Algorithms, Experimentation, Theory  
Note: g It has  made, or  
Affiliation: University of Wisconsin  
Abstract: An exhaustive dataflow-analysis algorithm associates with each point in a program a set of dataflow facts that are guaranteed to hold whenever that point is reached during program execution. By contrast, a demand dataflow-analysis algorithm determines whether a single given dataflow fact holds at a single given point. This paper presents a new demand algorithm for interprocedural dataflow analysis. The algorithm has four important properties: g Experimental results show that in many situations (e.g., when only a small number of demands are CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques; D.3.4 [Programming Languages]: Processors compilers, optimization; E.1 [Data Structures] graphs; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems computations on discrete structures; G.2.2 [Discrete Mathematics]: Graph Theory graph algorithms Additional Key Words and Phrases: demand dataflow analysis, distributive dataflow framework, graph reachability, interprocedural dataflow analysis, interprocedurally realizable path, interprocedurally valid path, meet-over-all-valid-paths solution hhhhhhhhhhhhhhhhhhhhhhhhhhhhh On leave from IBM Scientific Center, Haifa, Israel. This work was supported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science Foundation under grants CCR-8958530 and CCR-9100424, by the Defense Advanced Research Projects Agency under ARPA Order No. 8856 (monitored by the Office of Naval Research under contract N00014-92-J-1937), by the Air Force Office of Scientific Research under grant AFOSR-91-0308, and by a grant from Xerox Corporate Research. Part of this work was done while the authors were visiting the University of Copenhagen. A preliminary version of this paper appeared in SIGSOFT 95: Proceedings of the Third ACM SIGSOFT Symposium on Foundations of Software Engineering (Washington DC, October 10-13, 1995) [15] Authors' address: Computer Sciences Department; Univ. of Wisconsin; 1210 West Dayton Street; Madison, WI 53706; USA. Electronic mail: -horwitz, reps, sagiv-@cs.wisc.edu. g It provides precise (meet-over-all-interprocedurally-valid-paths) solutions to a large class of problems.
Abstract-found: 1
Intro-found: 1
Reference: 1. , <institution> SPEC Component CPU Integer Release 2/1992, </institution> <month> (CINT92), </month> <title> Standard Performance Evaluation Corporation (SPEC), </title> <address> Fairfax, VA (1992). </address>
Reference-contexts: global node set, initially -n, 0 | n N * - /* This set is preserved across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin <ref> [1] </ref> en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h <p> calls several auxiliary subprograms: function Callers (p) returns the set of call nodes that hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare G # = (N # , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin <ref> [1] </ref> while EdgeWorkList do [2] Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList [3] if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n [5] case n a return-site <p> The study used 44 C programssome standard UNIX utilities and some programs from the SPEC integer benchmark suite <ref> [1] </ref>.
Reference: 2. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data flow analysis: Part II. Demand analysis, </title> <note> Acta Informatica 10(3) pp. </note> <month> 265-272 (October </month> <year> 1978). </year>
Reference-contexts: n N * - /* This set is preserved across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h <ref> [2] </ref> if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not <p> function Callers (p) returns the set of call nodes that hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare G # = (N # , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do <ref> [2] </ref> Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList [3] if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n [5] case n a return-site node : [6] let <p> bold arrow represents the path edge whose source is a 0 node, and the dotted bold arrow represents the new path edge that is inserted into PathEdge and the worklist. exit , dstart , &lt;n, 0 &gt; &lt; &gt; Furthermore, when a path edge is taken off the worklist (line <ref> [2] </ref>) it is processed only if it is itself of the form start p , 0 fi exit p , d, or if that path edge has not yet been discovered. <p> Relation to Previous Work Until very recently, work on demand-driven dataflow analysis only considered the intraprocedural case (cf. <ref> [2] </ref>) and work on interprocedural dataflow analysis only considered the exhaustive case (cf. [25,7,6,17]).
Reference: 3. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, </title> <booktitle> in Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <address> (Cambridge, MA), </address> <month> (March </month> <year> 1986). </year>
Reference-contexts: set is preserved across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then <ref> [3] </ref> return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node <p> # , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList <ref> [3] </ref> if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n [5] case n a return-site node : [6] let c be the call node that corresponds to n, and q be the procedure called at
Reference: 4. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conference Record of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Antonio, TX, </address> <month> January 29-31, </month> <year> 1979), </year> <month> (January </month> <year> 1979). </year>
Reference-contexts: across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) <ref> [4] </ref> else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from <p> */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList [3] if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then <ref> [4] </ref> switch n [5] case n a return-site node : [6] let c be the call node that corresponds to n, and q be the procedure called at c [7] for each d 2 such that exit q , d 2 fi n, d 1 E # do Propagate (exit q
Reference: 5. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <address> (San Diego, CA, </address> <month> March </month> <year> 1987), </year> <month> (March </month> <year> 1987). </year>
Reference-contexts: */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else <ref> [5] </ref> UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] <p> (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList [3] if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n <ref> [5] </ref> case n a return-site node : [6] let c be the call node that corresponds to n, and q be the procedure called at c [7] for each d 2 such that exit q , d 2 fi n, d 1 E # do Propagate (exit q , d 2
Reference: 6. <author> Callahan, D., Cooper, K.D., Kennedy, K., and Torczon, L., </author> <title> Interprocedural constant propagation, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices 21(7) pp. </journal> <month> 152-161 (July </month> <year> 1986). </year>
Reference-contexts: node set, initially empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) <ref> [6] </ref> return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d <p> do [2] Select and remove an edge n, d 1 fi exit p , d from EdgeWorkList [3] if (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n [5] case n a return-site node : <ref> [6] </ref> let c be the call node that corresponds to n, and q be the procedure called at c [7] for each d 2 such that exit q , d 2 fi n, d 1 E # do Propagate (exit q , d 2 fi exit q , d 2 ,
Reference: 7. <author> Callahan, D., </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference-contexts: empty /* This set is preserved across calls */ function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare en: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) <ref> [7] </ref> fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] <p> (n, d 1 is start p , 0) or (start p , 0 fi exit p , d / PathEdge) then [4] switch n [5] case n a return-site node : [6] let c be the call node that corresponds to n, and q be the procedure called at c <ref> [7] </ref> for each d 2 such that exit q , d 2 fi n, d 1 E # do Propagate (exit q , d 2 fi exit q , d 2 , EdgeWorkList) od [8] for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) <p> be uninitialized at node n9? is made), the following steps are performed (all line numbers refer to lines in Figure 3): - 13 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh o o p &lt; &gt; &gt; &lt; q exit , d exit , d exit , d o o p &lt; &gt; p 2 Line <ref> [7] </ref> Line [8] r, d o o p 1 p &lt; &gt; 4 3 c, d exit , d &gt; o o p &lt; &lt; &gt; 3 &lt; n, d &gt; p &lt; &gt; exit , d exit , d c, d Line [16] Line [17] m, d o p p
Reference: 8. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIG-PLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year> <month> - 29 </month> - 
Reference-contexts: exploded supergraph node begin [1] en = BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin <ref> [8] </ref> push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case <p> be the call node that corresponds to n, and q be the procedure called at c [7] for each d 2 such that exit q , d 2 fi n, d 1 E # do Propagate (exit q , d 2 fi exit q , d 2 , EdgeWorkList) od <ref> [8] </ref> for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let [10] end case [11] case n the start node of procedure p : [12] for each c Callers (p) <p> at node n9? is made), the following steps are performed (all line numbers refer to lines in Figure 3): - 13 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh o o p &lt; &gt; &gt; &lt; q exit , d exit , d exit , d o o p &lt; &gt; p 2 Line [7] Line <ref> [8] </ref> r, d o o p 1 p &lt; &gt; 4 3 c, d exit , d &gt; o o p &lt; &lt; &gt; 3 &lt; n, d &gt; p &lt; &gt; exit , d exit , d c, d Line [16] Line [17] m, d o p p exit , <p> BackwardDFS is called with node n9, g. 2, Node n9, g is pushed onto NodeStack at line <ref> [8] </ref>, and then popped off (into n, d) at line [10]. 3. Node n9, g is inserted into VisitedNodes at line [14]. The default case of the switch (line [29]) is taken, and node n8, g is pushed onto NodeStack. - 14 - 4.
Reference: 9. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> January 11-13, </month> <year> 1989), </year> <month> (January </month> <year> 1989). </year>
Reference-contexts: BackwardDFS (n h h [2] if en = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack <ref> [9] </ref> while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] <p> n, d 1 E # do Propagate (exit q , d 2 fi exit q , d 2 , EdgeWorkList) od [8] for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od <ref> [9] </ref> end let [10] end case [11] case n the start node of procedure p : [12] for each c Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d
Reference: 10. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven program analysis, </title> <type> Technical Report TR-93-15, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA (October 1993). </address>
Reference-contexts: = Failure then [3] return (false) [4] else [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do <ref> [10] </ref> pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that <p> E # do Propagate (exit q , d 2 fi exit q , d 2 , EdgeWorkList) od [8] for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let <ref> [10] </ref> end case [11] case n the start node of procedure p : [12] for each c Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, <p> BackwardDFS is called with node n9, g. 2, Node n9, g is pushed onto NodeStack at line [8], and then popped off (into n, d) at line <ref> [10] </ref>. 3. Node n9, g is inserted into VisitedNodes at line [14]. The default case of the switch (line [29]) is taken, and node n8, g is pushed onto NodeStack. - 14 - 4. <p> Thus, these improvements to the algorithm are most significant for problems with a high ratio of yes answers. A different approach to obtaining demand versions of dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa, first for intraprocedural problems <ref> [10] </ref> and subsequently for interpro-cedural problems [11]. In their approach, for each demand of the form Is fact d in the solution set at flowgraph node x?, a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: 11. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven computation of interprocedural data flow, </title> <booktitle> in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Fran-cisco, CA, </address> <month> January 23-25, </month> <year> 1995), </year> <month> (January </month> <year> 1995). </year>
Reference-contexts: [5] UpdateReachableNodes (en) [6] return (true) [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack <ref> [11] </ref> if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the <p> Propagate (exit q , d 2 fi exit q , d 2 , EdgeWorkList) od [8] for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let [10] end case <ref> [11] </ref> case n the start node of procedure p : [12] for each c Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, d 1 E <p> Thus, these improvements to the algorithm are most significant for problems with a high ratio of yes answers. A different approach to obtaining demand versions of dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa, first for intraprocedural problems [10] and subsequently for interpro-cedural problems <ref> [11] </ref>. In their approach, for each demand of the form Is fact d in the solution set at flowgraph node x?, a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: 12. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables [13], copy-constant propagation <ref> [12, pp. 660] </ref>, and possibly-uninitialized variables. The IFDS framework was defined in [23], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> [7] fi function BackwardDFS (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then <ref> [12] </ref> return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList <p> Before the first call on IsMemberOfSolution is performed, ReachableNodes is initialized to - n, 0 for all supergraph nodes n. As soon as function BackwardDFS encounters a node n, d that is in ReachableNodes, the backward depth-first search is terminated, and node n, d is returned (line <ref> [12] </ref>). (The fact that n, d is reachable via a realizable path from start main , 0 together with the fact that BackwardDFS only visits nodes from which there is a realizable path to the demand node n h h , means that there is a realizable path from start main <p> d 2 , EdgeWorkList) od [8] for each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let [10] end case [11] case n the start node of procedure p : <ref> [12] </ref> for each c Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3
Reference: 13. <author> Giegerich, R., Moncke, U., and Wilhelm, R., </author> <title> Invariance of approximative semantics with respect to program transformations., pp. </title> <booktitle> 1-10 in Informatik-Fachberichte 50, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin Heidelberg New York (1981). </address>
Reference-contexts: We call this class of problems the interpro-cedural, finite, distributive, subset problems, or IFDS problems, for short. The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables <ref> [13] </ref>, copy-constant propagation [12, pp. 660], and possibly-uninitialized variables. The IFDS framework was defined in [23], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> (n h h ) returns exploded supergraph node or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) <ref> [13] </ref> else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each <p> each d 2 such that c, d 2 fi n, d 1 (E # SummaryEdge) do Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let [10] end case [11] case n the start node of procedure p : [12] for each c Callers (p) do <ref> [13] </ref> let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3 E # do [15] if c, d <p> a path from n to the end of the program on which x is used in a truly-live context before being defined, where a truly-live context means: in a predicate, or in a call to a library routine, or in an expression whose value is assigned to a truly-live variable <ref> [13] </ref>. Because it is non-locally-separable, the truly-live variables problem is in some sense a harder problem than the live-variables problem, and its results are more accurate (every truly-live variable is also live, but not vice versa).
Reference: 14. <author> Horwitz, S. and Teitelbaum, T., </author> <title> Generating editing environments based on relations and attributes, </title> <journal> ACM Transactions on Programming Languages and Systems 8(4) pp. </journal> <month> 577-608 (October </month> <year> 1986). </year>
Reference-contexts: or Failure declare EdgeWorkList: edge set; NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then <ref> [14] </ref> insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi <p> During an invocation of IsMemberOfSolution, nodes visited for the first time are added to this set (line <ref> [14] </ref>); those determined to be reachable from start main , 0 by a realizable path are transferred from this set to the ReachableNodes set by procedure UpdateReachableNodes (lines [39] and [40]). <p> Propagate (c, d 2 fi exit p , d, EdgeWorkList) od [9] end let [10] end case [11] case n the start node of procedure p : [12] for each c Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c <ref> [14] </ref> for each d 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3 E # do [15] if c, d 4 fi r, d 3 / SummaryEdge then [16] Insert c, d 4 fi r, d <p> BackwardDFS is called with node n9, g. 2, Node n9, g is pushed onto NodeStack at line [8], and then popped off (into n, d) at line [10]. 3. Node n9, g is inserted into VisitedNodes at line <ref> [14] </ref>. The default case of the switch (line [29]) is taken, and node n8, g is pushed onto NodeStack. - 14 - 4.
Reference: 15. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <booktitle> in Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> (October </month> <year> 1995). </year>
Reference-contexts: This paper presents a new caching demand algorithm for interprocedural dataflow analysis. The new algorithm, which is an improved version of the one reported in <ref> [15] </ref>, has four important properties: g It provides precise (meet-over-all-interprocedurally-valid-paths) solutions to a large class of problems. g It has a polynomial worst-case cost for both a single demand and a sequence of all possible demands. g It has the same-worst-case-cost property with respect to the exhaustive algorithm given in [23], <p> NodeStack: node stack begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes <ref> [15] </ref> switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate <p> Callers (p) do [13] let q be c's procedure, and r be the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3 E # do <ref> [15] </ref> if c, d 4 fi r, d 3 / SummaryEdge then [16] Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 <p> Subsequent tests for hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 A previous version of the Demand-Tabulation Algorithm that was presented in <ref> [15] </ref> did not employ either of these strategies for early cut-off. - 28 - membership of this edge in PathEdge allow BackwardTabulateSLRPs to avoid processing more path edges with target exit p , d.
Reference: 16. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Boston, MA, </address> <month> October 1-3, </month> <year> 1973), </year> <month> (October </month> <year> 1973). </year>
Reference-contexts: These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem <ref> [16] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataflow-analysis problem. In Kildall's framework, an instance of a dataflow-analysis problem consists of a bounded lower semi-lattice (the dataflow information) with meet operator cddc , a flowgraph (representing the program), and an assignment of dataflow functions to the edges of the flowgraph. <p> begin [8] push n h h onto NodeStack [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n <ref> [16] </ref> case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate (exit p , <p> the return-site node that corresponds to c [14] for each d 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3 E # do [15] if c, d 4 fi r, d 3 / SummaryEdge then <ref> [16] </ref> Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] <p> o p &lt; &gt; p 2 Line [7] Line [8] r, d o o p 1 p &lt; &gt; 4 3 c, d exit , d &gt; o o p &lt; &lt; &gt; 3 &lt; n, d &gt; p &lt; &gt; exit , d exit , d c, d Line <ref> [16] </ref> Line [17] m, d o p p exit , d &gt; 1 2 # # # edge corresponding to a control-flow-graph edge edge corresponding to a call-to-return-site edge or edge in SummaryEdge edge corresponding to a call-to-start or exit-to-return-site edge edge in PathEdge (possibly new) edge in PathEdge (possibly new) <p> Node n9, g is inserted into VisitedNodes at line [14]. The default case of the switch (line [29]) is taken, and node n8, g is pushed onto NodeStack. - 14 - 4. Node n8, g is popped from NodeStack; n8 is a return-site node, so the case on line <ref> [16] </ref> is selected, and BackwardTabulateSLRPs is called for the first time. This causes summary edge n7, g fi n8, g to be inserted into SummaryEdge (and causes several other edges to be inserted into PathEdge). 5. Node n7, g is pushed onto NodeStack at line [21]. 6.
Reference: 17. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler,Springer-Verlag, </editor> <address> New York, NY (1992). </address>
Reference-contexts: That definition is summarized below. The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis [25], with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters <ref> [17] </ref>. These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem [16] to the meet-over-all-valid-paths solution of an interprocedural dataflow-analysis problem. <p> [9] while NodeStack is not empty do [10] pop a node n, d from NodeStack [11] if n, d ReachableNodes then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : <ref> [17] </ref> let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od <p> 3 , d 4 such that c, d 4 fi n, d 1 E # and exit p , d fi r, d 3 E # do [15] if c, d 4 fi r, d 3 / SummaryEdge then [16] Insert c, d 4 fi r, d 3 into SummaryEdge <ref> [17] </ref> for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] default : [24] for each m, d 2 such that m, <p> &lt; &gt; p 2 Line [7] Line [8] r, d o o p 1 p &lt; &gt; 4 3 c, d exit , d &gt; o o p &lt; &lt; &gt; 3 &lt; n, d &gt; p &lt; &gt; exit , d exit , d c, d Line [16] Line <ref> [17] </ref> m, d o p p exit , d &gt; 1 2 # # # edge corresponding to a control-flow-graph edge edge corresponding to a call-to-return-site edge or edge in SummaryEdge edge corresponding to a call-to-start or exit-to-return-site edge edge in PathEdge (possibly new) edge in PathEdge (possibly new) edge in
Reference: 18. <author> Linton, M.A., </author> <title> Implementing relational views of programs, pp. </title> <booktitle> 132-140 in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pitts-burgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <month> (April </month> <year> 1984). </year>
Reference-contexts: then [12] return (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c <ref> [18] </ref> EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d <p> 4 fi r, d 3 / SummaryEdge then [16] Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od <ref> [18] </ref> fi [20] end let [22] end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch [27] fi end procedure Propagate
Reference: 19. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Research Center, Palo Alto, </institution> <note> CA (January 1980). </note>
Reference-contexts: (n, d) [13] else if n, d / VisitedNodes then [14] insert n, d into VisitedNodes [15] switch n [16] case n is a return-site node : [17] let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := <ref> [19] </ref> for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do
Reference: 20. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> Technical Report 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, </institution> <address> Denmark (April 1994). </address>
Reference-contexts: that d 2 is only in the output set resulting from an application of f if d 1 is in the input set; (iii) is included for technical reasons so that the relational composition of the representation relations of functions f and g corresponds to the functional composition g f <ref> [20] </ref>. <p> In <ref> [20] </ref> we have shown that dataflow fact d holds at supergraph node n iff there is a realizable path in G # from node start main , 0 (which represents the fact that no dataflow facts hold at the start of procedure main) to node n, d. Example. <p> let c be the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od <ref> [20] </ref> BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let [23] end case [24] case n is the start node of procedure p : [25] for each c Callers <p> An interesting aspect of BackwardDFS is how it ensures that only nodes from which there is a realizable path to demand node n h h are visited. This is accomplished by the call to BackwardTabulateSLRPs at - 11 - line <ref> [20] </ref>, which occurs when the node n, d popped from the stack corresponds to a return-site node (i.e., n is a return-site node in G * ). <p> r, d 3 / SummaryEdge then [16] Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi <ref> [20] </ref> end let [22] end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch [27] fi end procedure Propagate (n, d <p> The table in Figure 6 summarizes how the Demand-Tabulation Algorithm behaves for six different classes of problems. In each case, the time given is the worst-case time for a single demand. The details of the analysis of the running time of the Demand-Tabulation Algorithm can be found in <ref> [20] </ref>. The most efficient exhaustive algorithm known for the class of IFDS problems is the one given in [23].
Reference: 21. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, in Applications of Logic Databases, </title> <editor> ed. R. </editor> <publisher> Ramakrishnan,Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address>
Reference-contexts: the call node that corresponds to n, and let p be the procedure called at c [18] EdgeWorkList := [19] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) <ref> [21] </ref> for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let [23] end case [24] case n is the start node of procedure p : [25] for each c Callers (p) do [26] <p> Summary edges are recorded in the (global) set named SummaryEdge. After calling BackwardTabulateSLRPs, BackwardDFS can continue its backward traversal across the newly discovered summary edges (line <ref> [21] </ref>). <p> This causes summary edge n7, g fi n8, g to be inserted into SummaryEdge (and causes several other edges to be inserted into PathEdge). 5. Node n7, g is pushed onto NodeStack at line <ref> [21] </ref>. 6. Node n7, g is popped from NodeStack; the default case is taken, and node n6, g is pushed onto NodeStack. 7. Node n6, g is popped from NodeStack; the default case is taken, but there are no edges that satisfy the for-loop condition (line [30]). 8.
Reference: 22. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, pp. </title> <booktitle> 389-403 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edinburgh, Scotland, </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson,Springer-Verlag, </editor> <address> New York, NY (1994). </address>
Reference-contexts: p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od <ref> [22] </ref> end let [23] end case [24] case n is the start node of procedure p : [25] for each c Callers (p) do [26] for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od [27] od <p> / SummaryEdge then [16] Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let <ref> [22] </ref> end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch [27] fi end procedure Propagate (n, d 1 fi exit
Reference: 23. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Precise interprocedural dataflow analysis via graph reachability, </title> <booktitle> in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> January 23-25, </month> <year> 1995), </year> <month> (January </month> <year> 1995). </year>
Reference-contexts: [15], has four important properties: g It provides precise (meet-over-all-interprocedurally-valid-paths) solutions to a large class of problems. g It has a polynomial worst-case cost for both a single demand and a sequence of all possible demands. g It has the same-worst-case-cost property with respect to the exhaustive algorithm given in <ref> [23] </ref>, which is currently the best exhaustive algorithm for the class of dataflow-analysis problems that can be han dled precisely by our demand algorithm. g Experimental results show that in many situations (e.g., when only a small number of demands are made, or when most demands are answered yes) the demand <p> The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables [13], copy-constant propagation [12, pp. 660], and possibly-uninitialized variables. The IFDS framework was defined in <ref> [23] </ref>, where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> The key insight behind this explosion is that a distributive function in 2 D fi 2 D can be represented using a graph with 2 (D + 1) nodes <ref> [23] </ref>; this graph is called the function's representation relation. <p> fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let <ref> [23] </ref> end case [24] case n is the start node of procedure p : [25] for each c Callers (p) do [26] for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od [27] od [28] end case <p> [16] Insert c, d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case <ref> [23] </ref> default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch [27] fi end procedure Propagate (n, d 1 fi exit p , d: <p> here rely on the fact that it is always possible to construct G # so the maximum outdegree of a non-0 node in a call to-start edge's representation relation, and the maximum indegree of a non-0 node in an exit-to-return-site edge's representation relation are both 1. (See the Appendix of <ref> [23] </ref> for a more complete discussion of this issue.) The implementation reported in Section 4 constructs G # so that these properties hold. The table in Figure 6 summarizes how the Demand-Tabulation Algorithm behaves for six different classes of problems. <p> In each case, the time given is the worst-case time for a single demand. The details of the analysis of the running time of the Demand-Tabulation Algorithm can be found in [20]. The most efficient exhaustive algorithm known for the class of IFDS problems is the one given in <ref> [23] </ref>. Its worst-case running times are almost identical to the times given above; the only difference is that for an intraprocedural, locally separable problem, the bound for the exhaustive algorithm is O (ED), while the bound for the Demand-Tabulation Algorithm is O (E). <p> In practice, however, we have found that the Demand-Tabulation Algorithm (applied to a single demand) is much faster than the exhaustive algorithm (see Figure 8). 3.2. The Same-Worst-Case-Cost Property We have designed the Demand-Tabulation Algorithm so that it has the same-worst-case-cost property with respect to the exhaustive algorithm of <ref> [23] </ref>. In particular, a call to IsMemberOfSolution can re-use the sets ReachableNodes, VisitedNodes, PathEdge, and SummaryEdge, whose values are preserved across calls. <p> additional work, and the information accumulated in ReachableNodes and Visi-tedNodes prevents BackwardDFS and UpdateReachableNodes from performing additional work.) In general, this is bounded by O (E D 3 ), which is the same amount of work that could be performed in the worst case by the exhaustive algorithm given in <ref> [23] </ref>. Thus, the Demand-Tabulation Algorithm has the same-worst-case-cost property with respect to the exhaustive algorithm. While this is an important property, it does not, of course, mean that the Demand-Tabulation Algorithm will always outperform the exhaustive algorithm. <p> Experimental Results 4.1. Background to the Experiments We have carried out two experiments to compare the performance of the Demand-Tabulation Algorithm to that of the exhaustive algorithm of <ref> [23] </ref>, and two further experiments to study the trade-off between the benefit and overhead of the caching performed by the Demand-Tabulation Algorithm. <p> true as soon as it visits a node of the form n, 0, reinitializes the set VisitedNodes to after each invocation of IsMem-berOfSolution, does not maintain the set ReachableNodes, but does preserve the sets PathEdge and Sum maryEdge across calls to IsMemberOfSolution), 1 and (3) the exhaustive algorithm reported in <ref> [23] </ref>. The three algorithms described above were implemented in C and used with a front end that analyzes a C program and generates the corresponding exploded supergraph for five dataflow-analysis problems: Possibly-Uninitialized Variables This is the problem that we have used as our running example.
Reference: 24. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference-contexts: E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let [23] end case <ref> [24] </ref> case n is the start node of procedure p : [25] for each c Callers (p) do [26] for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od [27] od [28] end case [29] default : <p> d 4 fi r, d 3 into SummaryEdge [17] for each d 2 such that r, d 3 fi exit q , d 2 PathEdge do Propagate (c, d 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] default : <ref> [24] </ref> for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch [27] fi end procedure Propagate (n, d 1 fi exit p , d: edge, EdgeWorkList: edge <p> o p p exit , d &gt; 1 2 # # # edge corresponding to a control-flow-graph edge edge corresponding to a call-to-return-site edge or edge in SummaryEdge edge corresponding to a call-to-start or exit-to-return-site edge edge in PathEdge (possibly new) edge in PathEdge (possibly new) edge in SummaryEdge Line <ref> [24] </ref> Key hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh summary edges. 1. BackwardDFS is called with node n9, g. 2, Node n9, g is pushed onto NodeStack at line [8], and then popped off (into n, d) at line [10]. 3. Node n9, g is inserted into VisitedNodes at line [14].
Reference: 25. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: The IFDS framework was defined in [23], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis <ref> [25] </ref>, with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters [17]. <p> , d, EdgeWorkList) od [20] BackwardTabulateSLRPs (EdgeWorkList) [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let [23] end case [24] case n is the start node of procedure p : <ref> [25] </ref> for each c Callers (p) do [26] for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od [27] od [28] end case [29] default : [30] for each m, d such that m, d fi n, <p> 4 fi exit q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od <ref> [25] </ref> end case [26] end switch [27] fi end procedure Propagate (n, d 1 fi exit p , d: edge, EdgeWorkList: edge set) begin [29] if d 1 is 0 then [30] n := start p [31] fi [32] if n, d 1 fi exit p , d / PathEdge then
Reference: 26. <author> Ullman, J.D., </author> <title> Principles of Database and Knowledge-Base Systems, Volume II: The New Technologies, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD (1989). </address>
Reference-contexts: [21] for each d such that c, d fi n, d (E # SummaryEdge) and c, d / VisitedNodes do push c, d onto NodeStack od [22] end let [23] end case [24] case n is the start node of procedure p : [25] for each c Callers (p) do <ref> [26] </ref> for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od [27] od [28] end case [29] default : [30] for each m, d such that m, d fi n, d E # and m, d / <p> q , d 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case <ref> [26] </ref> end switch [27] fi end procedure Propagate (n, d 1 fi exit p , d: edge, EdgeWorkList: edge set) begin [29] if d 1 is 0 then [30] n := start p [31] fi [32] if n, d 1 fi exit p , d / PathEdge then [33] Insert n,
Reference: 27. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: od [22] end let [23] end case [24] case n is the start node of procedure p : [25] for each c Callers (p) do [26] for each d such that c, d fi n, d E # and c, d / VisitedNodes do push c, d onto NodeStack od <ref> [27] </ref> od [28] end case [29] default : [30] for each m, d such that m, d fi n, d E # and m, d / VisitedNodes do push m, d onto NodeStack od [31] end case [32] end switch [33] fi [35] return (Failure) end procedure UpdateReachableNodes (n 0 , <p> 2 , EdgeWorkList) od [18] fi [20] end let [22] end case [23] default : [24] for each m, d 2 such that m, d 2 fi n, d 1 E # do Propagate (m, d 2 fi exit p , d, EdgeWorkList) od [25] end case [26] end switch <ref> [27] </ref> fi end procedure Propagate (n, d 1 fi exit p , d: edge, EdgeWorkList: edge set) begin [29] if d 1 is 0 then [30] n := start p [31] fi [32] if n, d 1 fi exit p , d / PathEdge then [33] Insert n, d 1 fi
References-found: 27

