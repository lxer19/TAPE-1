URL: http://www.cs.pitt.edu/~moir/Papers/rtdbbook.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: LOCK-FREE TRANSACTIONS FOR REAL-TIME SYSTEMS  
Abstract: We show that previous algorithmic and scheduling work concerning the use of lock-free objects in hard real-time systems can be extended to support real-time transactions on memory-resident data. Using our approach, transactions are not susceptible to priority inversion or deadlock, do not require complicated mechanisms for rolling back aborted transactions, and can be implemented as library routines that require no special kernel support. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Multi-Object Operations", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing , August 1995, </booktitle> <pages> pp. 184-193. </pages>
Reference-contexts: Fin = ? then 2: if Prp = ? then 3: Prp := val 4: if Fin = ? then 5: v := Prp; fi 7: return Fin Ramamurthy, Moir, and Anderson present two implementations of an object that supports CAS. (LL/SC can be implemented using CAS in constant time <ref> [1] </ref>.) These implementations, which are summarized in the following theorems, use read/write and memory-to-memory Move instructions, respectively. Although Move is rare in multiprocessors, it is widely available on uniprocessors. <p> We assume that transactions are invoked by a collec 10 Chapter 1 tion of prioritized tasks executing on the same processor. Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations <ref> [1, 2] </ref>. The implementation is based on a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy [3]. 3.1 Transaction Routines Our transaction implementation consists of three procedures, Read , Write, and Trans, which are depicted in Figure 5. <p> These routines are called by the programmer's transaction code in order to read or write an element of the MEM array. Thus, instead of writing "MEM <ref> [1] </ref> := MEM [10]", the programmer would write "Write (1; Read (10))". Figure 6 depicts an example transaction, which updates the temperature display of a boiler. This transaction would be executed by calling Trans (update display). <p> Unfortunately, MWCAS is exceedingly difficult to 16 Chapter 1 implement efficiently in truly asynchronous systems <ref> [1, 7, 11, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. <p> Unfortunately, MWCAS is exceedingly difficult to 16 Chapter 1 implement efficiently in truly asynchronous systems [1, 7, 11, 22]. The most efficient known wait-free implementation <ref> [1] </ref> requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. Fortunately, as shown by Anderson and Ramamurthy in [3], a W -word MWCAS can be implemented on a real-time uniprocessor in only O (W ) time. <p> that perform lock-free transactions, we now present results from preliminary simulation experiments Lock-Free Transactions for Real-Time Systems 19 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) (f) old/new values 12/5, 22/10, and 8/17, respectively. "cv (w)" indicates the "current value" of word w.
Reference: [2] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Large Objects", </title> <booktitle> Proceedings of the Ninth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 972, </booktitle> <publisher> Springer-Verlag, </publisher> <month> Septem-ber </month> <year> 1995, </year> <pages> pp. 168-182. </pages>
Reference-contexts: We assume that transactions are invoked by a collec 10 Chapter 1 tion of prioritized tasks executing on the same processor. Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations <ref> [1, 2] </ref>. The implementation is based on a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy [3]. 3.1 Transaction Routines Our transaction implementation consists of three procedures, Read , Write, and Trans, which are depicted in Figure 5. <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2
Reference: [3] <author> J. Anderson and S. Ramamurthy, </author> <title> "A Framework for Implementing Objects and Scheduling Tasks in Lock-Free Real-Time Systems", </title> <booktitle> to be presented at the 17th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1996. </year> <note> Available at the URL "http://www.cs.unc.edu/~anderson/papers.html". </note>
Reference-contexts: For cases in which large variations in loop costs exist, Anderson and Ramamurthy have shown that linear programming can be applied to obtain a much better estimate of the cost associated with failed loop tries <ref> [3] </ref>. In this approach, the total cost of failed loop tries in t i and higher-priority tasks over an interval I is first expressed as a linear expression involving a set of variables. <p> Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations [1, 2]. The implementation is based on a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy <ref> [3] </ref>. 3.1 Transaction Routines Our transaction implementation consists of three procedures, Read , Write, and Trans, which are depicted in Figure 5. These procedures support the "illusion" of a contiguous shared array MEM of memory words. <p> The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. Fortunately, as shown by Anderson and Ramamurthy in <ref> [3] </ref>, a W -word MWCAS can be implemented on a real-time uniprocessor in only O (W ) time. In the remainder of this subsection, we present a brief overview of Anderson and Ramamurthy's implementation. The code for implementing MWCAS and Read is shown in Figure 8. <p> Note that the current value of each word matches the desired old value. Inset (b) shows the variables after the first phase of m has completed, assuming no interferences by higher-priority tasks. The current value of each word is unchanged. Also, Status <ref> [3] </ref> has been updated to indicate that the lower-priority task t 3 has been interfered with. Note that changing Status [4] from 0 to 2 in inset (b) would have the effect of atomically changing the current value of each word to the desired new value. <p> Inset (d) shows relevant variables at the termination of m, assuming that an interference occurs by task t 9 (which must be a higher-priority task) on word z (see inset (f)). Status [4] is now 1, indicating the failure of t 4 's operation. Status <ref> [3] </ref> is still 1, indicating that t 3 's operation has also failed. <p> that perform lock-free transactions, we now present results from preliminary simulation experiments Lock-Free Transactions for Real-Time Systems 19 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> we now present results from preliminary simulation experiments Lock-Free Transactions for Real-Time Systems 19 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; <p> 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) <p> true 4 cv (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: <p> 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) (f) old/new values 12/5, 22/10, and 8/17, respectively. "cv (w)" indicates the "current value" of word w. <p> 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status <ref> [3] </ref>: 1 Status [4]: 1 (d) (f) old/new values 12/5, 22/10, and 8/17, respectively. "cv (w)" indicates the "current value" of word w.
Reference: [4] <author> J. Anderson, S. Ramamurthy, and K. </author> <title> Jeffay "Real-Time Computing with Lock-Free Shared Objects", </title> <booktitle> Proceedings of the 16th IEEE Real-Time Systems Symposium, </booktitle> <year> 1995, </year> <pages> pp. 28-37. </pages>
Reference-contexts: In particular, repeated interferences can cause a given operation to take an arbitrarily long time to complete. Fortunately, such interferences can be bounded by scheduling tasks appropriately <ref> [4] </ref>. As explained in the next section, the key to scheduling such tasks is to allow enough spare processor time to accommodate the failed object updates that can occur over any interval. <p> Nonetheless, Anderson et al. have shown that if tasks on a uniprocessor are scheduled appropriately, then such loops are indeed bounded <ref> [4] </ref>. We now explain why such bounds exist. For the sake of explanation, let us call an iteration of a retry loop a successful update if it successfully completes, and a failed update otherwise. <p> Using this information, it is possible to determine a bound on the number of failed updates in that interval. A task set is schedulable if there is enough free processor time to accommodate the failed updates that can occur over any interval. Lock-Free Transactions for Real-Time Systems 5 In <ref> [4] </ref>, scheduling conditions are established for the deadline-monotonic (DM) [15] and earliest-deadline-first (EDF) [16] priority assignments. In order to state these conditions, we must first define some notation. Each condition applies to a collection of N periodic tasks ft 1 ; : : : ; t N g. <p> Inset (b) shows the variables after the first phase of m has completed, assuming no interferences by higher-priority tasks. The current value of each word is unchanged. Also, Status [3] has been updated to indicate that the lower-priority task t 3 has been interfered with. Note that changing Status <ref> [4] </ref> from 0 to 2 in inset (b) would have the effect of atomically changing the current value of each word to the desired new value. Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks (see inset (e)). <p> Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks (see inset (e)). All valid fields are now true, so the value of Status <ref> [4] </ref> is no longer relevant. Inset (d) shows relevant variables at the termination of m, assuming that an interference occurs by task t 9 (which must be a higher-priority task) on word z (see inset (f)). Status [4] is now 1, indicating the failure of t 4 's operation. <p> All valid fields are now true, so the value of Status <ref> [4] </ref> is no longer relevant. Inset (d) shows relevant variables at the termination of m, assuming that an interference occurs by task t 9 (which must be a higher-priority task) on word z (see inset (f)). Status [4] is now 1, indicating the failure of t 4 's operation. Status [3] is still 1, indicating that t 3 's operation has also failed. <p> (z) = 8 Save [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save <ref> [4; 0] </ref>: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 <p> count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 <p> [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) (f) old/new values 12/5, 22/10, and <p> 0 true 4 cv (z) = 17 Status <ref> [4] </ref>: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) (f) old/new values 12/5, 22/10, and 8/17, respectively. "cv (w)" indicates the "current value" of word w. <p> The predicted BCU when lock-based objects were used is given by "blocking predicted". Predicted BCU for this case was obtained using the PCP scheduling condition given in [19]. BCU figures predicted by the linear-programming-based scheduling conditions discussed above and the conditions given in <ref> [4] </ref> are given by "lockfree predicted new" and "lock-free predicted old", respectively.
Reference: [5] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings, </author> <title> "Hard Real-Time Scheduling: The Deadline Monotonic Approach", </title> <booktitle> Proceedings of the 8th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <year> 1992, </year> <pages> pp. 127-132. </pages>
Reference-contexts: In comparing the above condition to the DM condition for independent tasks given in <ref> [5] </ref>, we see that the above condition essentially requires that the computation time of each task be "dilated" by the time it takes for one lock-free loop iteration.
Reference: [6] <author> T. Baker, </author> <title> "Stack-Based Scheduling of Real-Time Processes", </title> <journal> Journal of Real-Time Systems, </journal> <volume> Vol. 3, No. 1, </volume> <month> March </month> <year> 1991, </year> <pages> pp. 67-99. </pages>
Reference-contexts: Lock-based objects were implemented using the priority ceiling protocol (PCP). The PCP implementation that was used is based on the stack resource policy <ref> [6] </ref>, which minimizes context switching costs associated with object sharing. Lock-free objects were implemented using our lock-free transaction code, with queue operations optimized so that no copying is done. Executions times for skew heaps were obtained assuming a ten-node priority queue.
Reference: [7] <author> G. Barnes, </author> <title> "A Method for Implementing Lock-Free Shared Data Structures", </title> <booktitle> Proceedings of the fifth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1993, </year> <pages> pp. 261-270. </pages>
Reference-contexts: Unfortunately, MWCAS is exceedingly difficult to 16 Chapter 1 implement efficiently in truly asynchronous systems <ref> [1, 7, 11, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks.
Reference: [8] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: The fact that many lock-free object implementations are based on such primitives is no accident. Herlihy has shown that strong primitives are, in general, necessary for these implementations <ref> [8] </ref>. Herlihy's results are based upon a categorization of objects by "consensus number". An object has consensus number N if it can be used to solve N -process consensus, but not (N + 1)-process consensus, in a wait-free manner. <p> An object has consensus number N if it can be used to solve N -process consensus, but not (N + 1)-process consensus, in a wait-free manner. Wait-freedom is a strong form of lock-freedom that precludes all waiting dependencies among tasks, including unbounded retry loops <ref> [8] </ref>. <p> Theorem 3: Consensus can be implemented with constant time and space using reads and writes in a hard real-time uniprocessor system. 2 Given an implementation of consensus objects, any shared object can be implemented in a lock-free manner <ref> [8] </ref>. However, such implementations usually entail high overhead. More practical lock-free implementations are based on universal primitives such as CAS and load-linked/store-conditional (LL/SC) [9].
Reference: [9] <author> M. Herlihy, </author> <title> "A Methodology for Implementing Highly Concurrent Data Objects", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 5, </volume> <year> 1993, </year> <pages> pp. 745-770. </pages>
Reference-contexts: However, such implementations usually entail high overhead. More practical lock-free implementations are based on universal primitives such as CAS and load-linked/store-conditional (LL/SC) <ref> [9] </ref>.
Reference: [10] <author> J. Huang, J. Stankovic, K. Ramamritham, and D. Towsley, </author> <title> "Experimental Evaluation of Real-Time Optimistic Concurrency Control Schemes", </title> <booktitle> Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <year> 1991, </year> <pages> pp. 35-46. </pages> <note> 24 Chapter 1 </note>
Reference-contexts: Priority inversion is a problem even for systems that employ optimistic techniques, because in such systems, certain phases of a transaction (e.g., the validation phase or write phase) must be executed as critical sections <ref> [10, 14] </ref>. Priority inversion is often dealt with through the use of priority inheritance or priority ceiling protocols [21]. These protocols dynamically adjust transaction priorities to ensure that a transaction within a critical section executes at a priority that is sufficiently high to bound the duration of any priority inversion. <p> These routines are called by the programmer's transaction code in order to read or write an element of the MEM array. Thus, instead of writing "MEM [1] := MEM <ref> [10] </ref>", the programmer would write "Write (1; Read (10))". Figure 6 depicts an example transaction, which updates the temperature display of a boiler. This transaction would be executed by calling Trans (update display).
Reference: [11] <author> A. Israeli and L. Rappoport, </author> <title> "Disjoint-Access-Parallel Implementations of Strong Shared Memory Primitives", </title> <booktitle> Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 151-160. </pages>
Reference-contexts: Unfortunately, MWCAS is exceedingly difficult to 16 Chapter 1 implement efficiently in truly asynchronous systems <ref> [1, 7, 11, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks.
Reference: [12] <author> J. Harista, M. Carey, and M. Livny, </author> <title> "On Being Optimistic about Real-Time Constraints", </title> <booktitle> Proceedings of the Ninth SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: In this chapter, we show that previous work on lock-free objects can be extended to apply to lock-free transactions on memory-resident databases. Compared to conventional optimistic schemes, our lock-free transaction implementation is probably most similar to optimistic concurrency control with broadcast commit <ref> [12] </ref>. The main difference between our implementation and conventional schemes is that we use a strong synchronization primitive at the user level to validate and commit transactions. The strong primitive used in our implementation is a multi-word CAS (MWCAS).
Reference: [13] <author> K. Jeffay, D.L. Stone, and F.D. Smith, </author> <title> "Kernel Support for Live Digital Audio and Video", </title> <journal> Computer Communications, </journal> <volume> Vol. 15, No. 6, </volume> <month> July/August </month> <year> 1992, </year> <pages> pp. 388-395. </pages>
Reference-contexts: peek operation in addition to enqueue and de-queue; peek returns the value of the element at the head of the queue. 20 Chapter 1 Execution times for these operations were determined by implementing queues and skew heaps on a 66 MHz, Intel 80486-DX2 PC running the YARTOS real-time operating system <ref> [13] </ref>. Lock-based objects were implemented using the priority ceiling protocol (PCP). The PCP implementation that was used is based on the stack resource policy [6], which minimizes context switching costs associated with object sharing.
Reference: [14] <author> H. Kung and J. Robinson, </author> <title> "On Optimistic Methods for Concurrency Control", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 6, No. 2, </volume> <year> 1981, </year> <pages> pp. 213-226. </pages>
Reference-contexts: Priority inversion is a problem even for systems that employ optimistic techniques, because in such systems, certain phases of a transaction (e.g., the validation phase or write phase) must be executed as critical sections <ref> [10, 14] </ref>. Priority inversion is often dealt with through the use of priority inheritance or priority ceiling protocols [21]. These protocols dynamically adjust transaction priorities to ensure that a transaction within a critical section executes at a priority that is sufficiently high to bound the duration of any priority inversion.
Reference: [15] <author> J. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks", </title> <journal> Performance Evaluation, </journal> <volume> Vol. 2, No. 4, </volume> <year> 1982, </year> <pages> pp. 237-250. </pages>
Reference-contexts: A task set is schedulable if there is enough free processor time to accommodate the failed updates that can occur over any interval. Lock-Free Transactions for Real-Time Systems 5 In [4], scheduling conditions are established for the deadline-monotonic (DM) <ref> [15] </ref> and earliest-deadline-first (EDF) [16] priority assignments. In order to state these conditions, we must first define some notation. Each condition applies to a collection of N periodic tasks ft 1 ; : : : ; t N g.
Reference: [16] <author> C. Liu and J. Layland, </author> <title> "Scheduling Algorithms for multiprogramming in a Hard Real-Time Environment", </title> <journal> Journal of the ACM , Vol. </journal> <volume> 30, No. 1, </volume> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference-contexts: A task set is schedulable if there is enough free processor time to accommodate the failed updates that can occur over any interval. Lock-Free Transactions for Real-Time Systems 5 In [4], scheduling conditions are established for the deadline-monotonic (DM) [15] and earliest-deadline-first (EDF) <ref> [16] </ref> priority assignments. In order to state these conditions, we must first define some notation. Each condition applies to a collection of N periodic tasks ft 1 ; : : : ; t N g. <p> As in the case of DM scheduling, this condition extends the corresponding condition for independent tasks <ref> [16] </ref> by requiring that the computation time of each task be dilated by the cost of one lock-free loop iteration. The results presented above suggest a general strategy for determining the schedulability of tasks that share lock-free objects. <p> Assumption (i) is common to all priority-driven scheduling policies. Assumption (ii) holds for most common policies, including rate-monotonic (RM) <ref> [16] </ref>, 8 Chapter 1 running from left to right. Each level corresponds to operations by a different task. (a) Interleaved operations in an asynchronous multiprocessor system. Operations may overlap arbitrarily. (b) Interleaved operations in a uniprocessor real-time system. Two operations overlap only if one is contained within the other.
Reference: [17] <author> V. Lortz, </author> <title> An Object-Oriented Real-Time Database System for Multiprocessors, </title> <type> Ph.D. Thesis, </type> <institution> Computer Science Department, University of Michi-gan, </institution> <year> 1994. </year>
Reference-contexts: However, with such schemes, overhead associated aborting and restarting partially completed transactions is a key issue. In many systems, conflict resolution schemes are implemented in a client/server fashion. Although a client/server approach is attractive from a software engineering standpoint, such an arrangement can result in significant interprocess communication overhead <ref> [17] </ref>. 1 2 Chapter 1 Most existing conflict resolution schemes for real-time database systems are susceptible to priority inversion; a priority inversion occurs when a given transaction is blocked by another transaction of lower priority.
Reference: [18] <author> A. Mok, </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment, </title> <type> Ph.D. Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Operations may overlap arbitrarily. (b) Interleaved operations in a uniprocessor real-time system. Two operations overlap only if one is contained within the other. DM, and EDF scheduling. The only common scheduling policy that we know of that violates assumption (ii) is least-laxity-first (LLF) scheduling <ref> [18] </ref>. The collapse of Herlihy's hierarchy for hard real-time uniprocessor systems is established in [20] by giving a wait-free (and hence lock-free) algorithm that solves the consensus problem in such systems using only reads and writes. This algorithm is shown in Figure 4.
Reference: [19] <author> R. Rajkumar, </author> <title> Synchronization in Real-Time Systems: A Priority Inheritance Approach, </title> <publisher> Kluwer Academic Publications, </publisher> <year> 1991. </year>
Reference-contexts: The predicted BCU when lock-based objects were used is given by "blocking predicted". Predicted BCU for this case was obtained using the PCP scheduling condition given in <ref> [19] </ref>. BCU figures predicted by the linear-programming-based scheduling conditions discussed above and the conditions given in [4] are given by "lockfree predicted new" and "lock-free predicted old", respectively.
Reference: [20] <author> S. Ramamurthy, M. Moir, and J. Anderson, </author> <title> "Real-Time Object Sharing with Minimal System Support", </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing , May 1996, </booktitle> <pages> pp. 233-242. </pages>
Reference-contexts: Herlihy's consensus-number hierarchy is shown in Figure 2. Although Herlihy's hierarchy is of fundamental importance for truly asynchronous systems, Ramamurthy, Moir, and Anderson recently showed that, for uniprocessor-based real-time systems, Herlihy's hierarchy collapses, i.e., reads and writes can be used to implement any lock-free object <ref> [20] </ref>. The basis for this result is the realization that certain task interleavings cannot occur within real-time systems. <p> Requiring an object implementation to correctly deal with this interleaving is therefore pointless, because it cannot arise in practice. The distinction between traditional asynchronous systems, to which Herlihy's work is directed, and hard real-time systems is illustrated in Figure 3. The results of <ref> [20] </ref> are based upon an execution model like that depicted in (i) task t i may preempt task t j only if t i has higher priority than t j ; (ii) a task's priority can change over time, but not during any object access. <p> Two operations overlap only if one is contained within the other. DM, and EDF scheduling. The only common scheduling policy that we know of that violates assumption (ii) is least-laxity-first (LLF) scheduling [18]. The collapse of Herlihy's hierarchy for hard real-time uniprocessor systems is established in <ref> [20] </ref> by giving a wait-free (and hence lock-free) algorithm that solves the consensus problem in such systems using only reads and writes. This algorithm is shown in Figure 4. In this algorithm, each task chooses a decision value by invoking the procedure decide.
Reference: [21] <author> L. Sha, R. Rajkumar, S. Son, and C. Chang, </author> <title> "A Real-Time Locking Protocol", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 7, </volume> <year> 1991, </year> <pages> pp. 793-800. </pages>
Reference-contexts: Priority inversion is often dealt with through the use of priority inheritance or priority ceiling protocols <ref> [21] </ref>. These protocols dynamically adjust transaction priorities to ensure that a transaction within a critical section executes at a priority that is sufficiently high to bound the duration of any priority inversion.
Reference: [22] <author> N. Shavit and D. Touitou, </author> <title> "Software Transactional Memory", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995, </year> <pages> pp. 204-213. </pages>
Reference-contexts: Unfortunately, MWCAS is exceedingly difficult to 16 Chapter 1 implement efficiently in truly asynchronous systems <ref> [1, 7, 11, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks.
References-found: 22

