URL: http://www.cs.wustl.edu/cs/techreports/1992/wucs-92-31.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Separating Structure from Function in the Specification and Design of Distributed Systems  
Author: Kenneth J. Goldman 
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Date: September 1992  
Pubnum: WUCS-92-31  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Ahuja, N. Carriero, and D. Gelernter. </author> <title> Linda and friends. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 26-34, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Several programming languages have been constructed that embrace the approach of separate computation and coordination languages. For example, Linda <ref> [1] </ref> is a coordination language that allows multiple processes, possibly written in different computation languages, to communicate through a shared tuple space. Linda provides the constructs in and out that allow processes to remove and insert elements of a shared tuple space in order to communicate and coordinate their activities.
Reference: [2] <author> Hagit Attiya and Nancy Lynch. </author> <title> Time bounds for real-time process control in the presence of timing uncertainty. </title> <booktitle> In Proceedings of the 10th Real Time Systems Symposium, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [3] <author> Hagit Attiya and Nancy Lynch. </author> <title> Using mappings to prove timing properties. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [4] <author> Hagit Attiya and Jennifer L. Welch. </author> <title> Sequential consistency versus linearizability. </title> <type> Technical Report 694, </type> <institution> Technion, Department of Computer Science, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [5] <author> M.J. Bach. </author> <title> The Design of the UNIX Operating System. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: For example, UNIX processes may, at run-time, create other processes, allocate shared variables, and create sockets for message-passing communication <ref> [5] </ref>. More recently, some languages have begun to provide constructs for creating multiple processes and communicating among them. Examples include the task construct in ADA [38] and the coenter construct in Argus [30].
Reference: [6] <author> Mario R. Barbacci, Dennis L. Doubleday, and Charles B. Weinstock. </author> <title> Application-level programming. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 458-465, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Each process is expressed in a computation language that is largely independent of the configuration language, except that it provides port declarations that comprise its connection interface for use by Darwin. Durra <ref> [6] </ref> provides, within a single language, separate mechanisms for describing computation modules, input and output ports, and channel connections between ports for large-grained distributed computation. Similarly, Hermes [45], provides a facility whereby values may be passed across ports that are connected from one module to another.
Reference: [7] <author> Joel F. Bartlett. Scheme-&gt;C, </author> <title> a portable Scheme-to-C compiler. </title> <type> Technical Report WRL Research Report 89/1, </type> <institution> Digital Western Research Laboratory, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: In order to make some of the simulator's utility functions available to the Spectrum compiler, we have translated those utilities into C with a Scheme-to-C compiler <ref> [7] </ref>. Currently, configurations are specified directly in Scheme, but work on graphical configuration and visualization capabilities is underway. Following sufficient experimentation with this second prototype and completion of the graphical configuration and visualization tools, we plan to make a version of Spectrum available for general distribution.
Reference: [8] <author> Luc Bouge and Nissim Francez. </author> <title> A compositional approach to superimposition. </title> <booktitle> In Proceedings of the 15th Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 240-249, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: For more details on the shared memory extensions, see [13]. 2.5 Superposition Superposition, an asymmetric relationship that allows one system component to observe the state of another, appears in a number of models for distributed systems. Bouge and Francez <ref> [8] </ref> argue in favor of the use of superposition as a language construct by describing a number of important applications for its use, and they offer a compositional approach to superposition with a syntactic representation in CSP.
Reference: [9] <author> E.J. Cameron, D.M. Cohen, B. Gopinath, W.M. Keese II, L. Ness, P. Uppaluru, and J.R. Vollaro. </author> <title> The ic* model of parallel computation and programming environment. </title> <journal> Bell Communications Research, </journal> <month> October </month> <year> 1987. </year>
Reference-contexts: However, an additional construct, called the MAINTAIN clause, is provided for updating the state state components after every action of an automaton. The MAINTAIN clause is somewhat similar to the ALWAYS construct of UNITY [10] and the MAINTAIN construct of IC* <ref> [9] </ref>, except that their constructs are more powerful in that they denote constraints on the state.
Reference: [10] <author> K. Mani Chandy and Jayadev Misra. </author> <title> A Foundation of Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts [18, 19], UNITY <ref> [10] </ref>, and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools. <p> Bouge and Francez [8] argue in favor of the use of superposition as a language construct by describing a number of important applications for its use, and they offer a compositional approach to superposition with a syntactic representation in CSP. In the UNITY model, defined by Chandy and Misra <ref> [10] </ref>, a program consists of a set of statements that access a global shared memory. At each step in the execution, a statement is selected and executed, possibly updating the memory. <p> However, an additional construct, called the MAINTAIN clause, is provided for updating the state state components after every action of an automaton. The MAINTAIN clause is somewhat similar to the ALWAYS construct of UNITY <ref> [10] </ref> and the MAINTAIN construct of IC* [9], except that their constructs are more powerful in that they denote constraints on the state.
Reference: [11] <author> Alan Fekete, Nancy Lynch, and Liuba Shrira. </author> <title> A modular proof of correctness for a network synchronizer. </title> <booktitle> In The 2nd International Workshop on Distributed Algorithms, </booktitle> <month> July </month> <year> 1987. </year> <title> Am-sterdam, </title> <booktitle> The Netherlands. </booktitle> <pages> 45 </pages>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [12] <author> David Gelernter and Nicholas Carriero. </author> <title> Coordination languages and their significance. </title> <journal> Com--munications of the ACM, </journal> <volume> 35(2) </volume> <pages> 97-107, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Gelernter 2 and Carriero have identified a class of languages called coordination languages, which they describe as the "glue" that binds together the various computational components of a system <ref> [12] </ref>. They argue that a complete programming language should consist of two pieces: a computation language (for defining the functional components) and coordination language (to bind them together), and they claim that the orthogonality and generality provided by this approach would be a major benefit to software engineering. <p> This is followed, in Section 6, by a general discussion of the benefits of the kind of separation we have achieved. We also say a few words about the current implementation and suggest some possible directions for future work. Gel-ernter and Carrier <ref> [12] </ref> remark that "it would be nice to have a theoretical foundation for general coordination." We conclude, in Section 7, with a discussion of how our work may help to provide such a foundation. 2 Background In this section, we describe the I/O automaton model of Lynch and Tuttle [32, 33], <p> In Gelernter and Carriero's terms <ref> [12] </ref>, the programming language may be considered the "computation language" and the configuration mechanism the "coordination language." The Spectrum programming language is used to express I/O automaton types, the building blocks of I/O automaton systems.
Reference: [13] <author> Kenneth Goldman and Nancy Lynch. </author> <title> Modelling shared state in a shared action model. </title> <booktitle> In Proceedings of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model [32, 33], plus extensions of that model to support atomic shared memory <ref> [13] </ref>, superposition [15], dynamic process creation [29], and time [35]. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> The following brief introduction to the I/O automaton model includes a review of the basic model, as well as a discussion of techniques for modeling shared memory, superposition, dynamic process creation, and time. The details of the model and these techniques may be found elsewhere <ref> [33, 13, 15, 29, 35] </ref>. 2.1 I/O Automata An I/O automaton is essentially a nondeterministic (possibly infinite-state) automaton with an action labeling each transition. An automaton's actions are classified as either `input', `output', or `internal'. <p> schedule of a fair execution of A, and we denote the set of fair schedules of A by fairscheds (A). 2.4 Shared Memory The I/O automaton model has been extended to allow modeling of shared memory systems, as well as systems that have both shared memory and shared action communication <ref> [13] </ref>. One benefit of providing both communication mechanisms in the same model is more flexibility in system design. <p> This discussion should be sufficient to understand the foundation of Spectrum's shared variable semantics. For more details on the shared memory extensions, see <ref> [13] </ref>. 2.5 Superposition Superposition, an asymmetric relationship that allows one system component to observe the state of another, appears in a number of models for distributed systems. <p> The second goal implies that the formal model must have sufficient expressive power. In fact, since the initial implementation of Spectrum [14], we have redesigned the system and added several features to the original I/O automaton model, including shared memory <ref> [13] </ref> and superposition [15], as well as incorporated into the design of Spectrum extensions to the model developed by others for dynamic process creation [29] and time [35].
Reference: [14] <author> Kenneth J. Goldman. </author> <title> Distributed algorithm simulation using Input/Output Automata. </title> <type> Technical Report MIT/LCS/TR-490, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> July </month> <year> 1990. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: By remaining faithful to a formal model, we also benefit from a well-defined semantics on which to base the language and implementation. The second goal implies that the formal model must have sufficient expressive power. In fact, since the initial implementation of Spectrum <ref> [14] </ref>, we have redesigned the system and added several features to the original I/O automaton model, including shared memory [13] and superposition [15], as well as incorporated into the design of Spectrum extensions to the model developed by others for dynamic process creation [29] and time [35]. <p> So far, we do not have enough experience to say whether this approach will also be beneficial to "seasoned" algorithm designers, although we expect that it will. The first prototype implementation of Spectrum, without shared memory, superposition and 40 dynamic process creation, was completed in 1990 <ref> [14] </ref>. This prototype was written in C [25] and provided graphical mechanisms for constructing configurations and visualizing executions. A second prototype, with an improved language syntax and support for shared memory, superposition, and dynamic process creation, has been completed recently.
Reference: [15] <author> Kenneth J. Goldman. </author> <title> A compositional model for layered distributed systems. </title> <booktitle> In Proceedings of the 2nd International Conference on Concurrency Theory, </booktitle> <volume> LNCS 527, </volume> <pages> pages 220-234. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model [32, 33], plus extensions of that model to support atomic shared memory [13], superposition <ref> [15] </ref>, dynamic process creation [29], and time [35]. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> The following brief introduction to the I/O automaton model includes a review of the basic model, as well as a discussion of techniques for modeling shared memory, superposition, dynamic process creation, and time. The details of the model and these techniques may be found elsewhere <ref> [33, 13, 15, 29, 35] </ref>. 2.1 I/O Automata An I/O automaton is essentially a nondeterministic (possibly infinite-state) automaton with an action labeling each transition. An automaton's actions are classified as either `input', `output', or `internal'. <p> In order to preserve the properties of the underlying program, the additional statements must not write to the original variables, although they may read them. The I/O automaton model has been extended previously to support superposition <ref> [15] </ref>. We summarize the definitions here. When one module is superposed on another, we want to prevent the higher level module from interfering with the lower level one. That is, we want the higher level module to observe (but not modify) the state of the underlying module. <p> The second goal implies that the formal model must have sufficient expressive power. In fact, since the initial implementation of Spectrum [14], we have redesigned the system and added several features to the original I/O automaton model, including shared memory [13] and superposition <ref> [15] </ref>, as well as incorporated into the design of Spectrum extensions to the model developed by others for dynamic process creation [29] and time [35]. <p> This is handled with a relaxation operator that forces an automaton to be unconstrained for a particular set of variables <ref> [15] </ref>. We are investigating the use of a relaxation operator in the Spectrum configuration mechanism, but currently we require that the higher level automaton in a superposition be an instance of a base type, and not a composition.
Reference: [16] <author> Kenneth J. Goldman. </author> <title> Highly concurrent logically synchronous multicast. </title> <journal> Distributed Computing, </journal> <volume> 6(4) </volume> <pages> 189-207, </pages> <year> 1991. </year> <booktitle> Earlier version in proceedings of the 3rd International Workshop on Distributed Algorithms, </booktitle> <address> Nice, France, </address> <note> Sprinter-Verlag LNCS 392. </note>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [17] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtul-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> April </month> <year> 1990. </year>
Reference-contexts: Examples include CSP [22], CCS [36], Statecharts [18, 19], UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools. For example, the Occam system [39] provides an implementation of a subset of CSP, the Statemate system <ref> [17] </ref> provides a simulation tool for systems described with Statecharts, and a programming language has been developed for the Swarm model as well. Another example is the COSPAN system based on its own s/r (selection/resolution) model [20].
Reference: [18] <author> David Harel. </author> <title> On visual formalisms. </title> <type> Technical Report CMU-CS-87-126, </type> <institution> Carnegie Mellon Computer Science Department, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts <ref> [18, 19] </ref>, UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools.
Reference: [19] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts <ref> [18, 19] </ref>, UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools.
Reference: [20] <author> Z. Har'El and R.P. Kurshan. </author> <title> Cospan user's guide. </title> <institution> AT&T Bell Laboratories, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: Another example is the COSPAN system based on its own s/r (selection/resolution) model <ref> [20] </ref>. However, these tools, and the models they support, typically provide little separation of structure and function. For example, parallel Occam processes are created using a PAR construct. <p> The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin [26, 34, 28] and DEVS [48] the channel construct in Occam [39], and the import and export of variables in COSPAN <ref> [20] </ref>, except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
Reference: [21] <author> Maurice Herlihy. </author> <title> Impossibility and universality results for wait-free synchronization. </title> <booktitle> In Proceedings of the 7th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 276-290, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [22] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP <ref> [22] </ref>, CCS [36], Statecharts [18, 19], UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools. <p> In fact, the I/O automaton model is differs significantly from CCS [36] and CSP <ref> [22] </ref> precisely in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to Jonsson's I/O-systems [24].
Reference: [23] <author> Stephen C. Johnson. </author> <title> Language development tools on the unix system. </title> <journal> Computer, </journal> <volume> 13 </volume> <pages> 15-21, </pages> <month> August </month> <year> 1980. </year>
Reference-contexts: A second prototype, with an improved language syntax and support for shared memory, superposition, and dynamic process creation, has been completed recently. The language parser for the second prototype is written in C (using yacc <ref> [23] </ref>) and produces a Scheme [46] file that is provided as input to the new Spectrum simulator, written in Scheme. In order to make some of the simulator's utility functions available to the Spectrum compiler, we have translated those utilities into C with a Scheme-to-C compiler [7].
Reference: [24] <author> Bengt Jonsson. </author> <title> A model and proof system for asynchronous networks. </title> <booktitle> In Proceedings of the 4th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1985. </year>
Reference-contexts: In that sense, I/O automata are similar to Jonsson's I/O-systems <ref> [24] </ref>. Furthermore, the shared action semantics of the model lends itself to a separation of structure and function. Since automata share actions by name, the structure of the shared action communication can be entirely specified in terms of the signatures.
Reference: [25] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: The first prototype implementation of Spectrum, without shared memory, superposition and 40 dynamic process creation, was completed in 1990 [14]. This prototype was written in C <ref> [25] </ref> and provided graphical mechanisms for constructing configurations and visualizing executions. A second prototype, with an improved language syntax and support for shared memory, superposition, and dynamic process creation, has been completed recently.
Reference: [26] <author> Jeff Kramer and Jeff Magee. </author> <title> The evolving philosophers problem. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(11) </volume> <pages> 1293-1306, </pages> <month> November </month> <year> 1990. </year> <month> 46 </month>
Reference-contexts: A more typical approach to coordination languages, and the approach we adopt here, is to provide separate mechanisms for establishing explicit relationships among program modules. For example, Darwin <ref> [26, 34, 28] </ref>, a generalization of Conic [27, 28], is a configuration language that allows one to manage message-passing connections between the ports of various processes in a dynamic system. <p> To support this, Spectrum provides an abstraction mechanism called a port. The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin <ref> [26, 34, 28] </ref> and DEVS [48] the channel construct in Occam [39], and the import and export of variables in COSPAN [20], except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
Reference: [27] <author> Jeff Kramer, Jeff Magee, and Anthony Finkelstein. </author> <title> A constructive approach to the design of distributed systems. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 580-587, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: A more typical approach to coordination languages, and the approach we adopt here, is to provide separate mechanisms for establishing explicit relationships among program modules. For example, Darwin [26, 34, 28], a generalization of Conic <ref> [27, 28] </ref>, is a configuration language that allows one to manage message-passing connections between the ports of various processes in a dynamic system.
Reference: [28] <author> Jeff Kramer, Jeff Magee, and Morris Sloman. </author> <title> Configuring distributed systems. </title> <booktitle> In Proceedings of the 5th ACM SIGOPS European Workshop, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: A more typical approach to coordination languages, and the approach we adopt here, is to provide separate mechanisms for establishing explicit relationships among program modules. For example, Darwin <ref> [26, 34, 28] </ref>, a generalization of Conic [27, 28], is a configuration language that allows one to manage message-passing connections between the ports of various processes in a dynamic system. <p> A more typical approach to coordination languages, and the approach we adopt here, is to provide separate mechanisms for establishing explicit relationships among program modules. For example, Darwin [26, 34, 28], a generalization of Conic <ref> [27, 28] </ref>, is a configuration language that allows one to manage message-passing connections between the ports of various processes in a dynamic system. <p> To support this, Spectrum provides an abstraction mechanism called a port. The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin <ref> [26, 34, 28] </ref> and DEVS [48] the channel construct in Occam [39], and the import and export of variables in COSPAN [20], except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
Reference: [29] <author> John Leo. </author> <title> Dynamic process creation in a static model. M.S. </title> <type> Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model [32, 33], plus extensions of that model to support atomic shared memory [13], superposition [15], dynamic process creation <ref> [29] </ref>, and time [35]. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> The following brief introduction to the I/O automaton model includes a review of the basic model, as well as a discussion of techniques for modeling shared memory, superposition, dynamic process creation, and time. The details of the model and these techniques may be found elsewhere <ref> [33, 13, 15, 29, 35] </ref>. 2.1 I/O Automata An I/O automaton is essentially a nondeterministic (possibly infinite-state) automaton with an action labeling each transition. An automaton's actions are classified as either `input', `output', or `internal'. <p> We adopt the definitions for modelling dynamic process creation in the I/O automaton model presented by Leo <ref> [29] </ref>. Under these definitions, an I/O automaton system in which automata are created and destroyed can be modeled as an I/O automaton system in which the set of all automata that could potentially be created during any execution of the system are in existence at the beginning. <p> fact, since the initial implementation of Spectrum [14], we have redesigned the system and added several features to the original I/O automaton model, including shared memory [13] and superposition [15], as well as incorporated into the design of Spectrum extensions to the model developed by others for dynamic process creation <ref> [29] </ref> and time [35]. The third goal, of course, implies that language features such as static type checking and a rich collection of built-in data types are needed in order to ensure that users spend their effort on experimenting with algorithms rather than finding obscure program errors.
Reference: [30] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust, distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: More recently, some languages have begun to provide constructs for creating multiple processes and communicating among them. Examples include the task construct in ADA [38] and the coenter construct in Argus <ref> [30] </ref>. Still, the structure of the system is not defined as a separate unit, but is defined as the result of the activities of the processes in the system.
Reference: [31] <author> Nancy Lynch, Michael Merritt, William Weihl, and Alan Fekete. </author> <title> Atomic Transactions. </title> <booktitle> In progress. </booktitle>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems. <p> This logical relationship would be captured naturally in the configuration in a way that would result in the necessary seed being on the fringe. For example, in a nested transaction system, such as those described in <ref> [31] </ref>, transactions are created dynamically in a tree structure that unfolds from the root; transactions create sub-transactions that are their immediate children, as opposed to transactions that are several levels below them in the nesting structure.
Reference: [32] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: In this paper, we present the Spectrum Simulation System, a new distributed system specification and design tool that separates the notion of structure and function. As a formal foundation of our work, we use the I/O automaton model of Lynch and Tuttle <ref> [32, 33] </ref>. <p> Thus, one may specify not only communication channels, but also logical relationships among the components. The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model <ref> [32, 33] </ref>, plus extensions of that model to support atomic shared memory [13], superposition [15], dynamic process creation [29], and time [35]. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> Carrier [12] remark that "it would be nice to have a theoretical foundation for general coordination." We conclude, in Section 7, with a discussion of how our work may help to provide such a foundation. 2 Background In this section, we describe the I/O automaton model of Lynch and Tuttle <ref> [32, 33] </ref>, the formal foundation of our work. There are several important reasons for basing a distributed algorithm development tool on a formal model.
Reference: [33] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to Input/Output Automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3), </volume> <year> 1989. </year>
Reference-contexts: In this paper, we present the Spectrum Simulation System, a new distributed system specification and design tool that separates the notion of structure and function. As a formal foundation of our work, we use the I/O automaton model of Lynch and Tuttle <ref> [32, 33] </ref>. <p> Thus, one may specify not only communication channels, but also logical relationships among the components. The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model <ref> [32, 33] </ref>, plus extensions of that model to support atomic shared memory [13], superposition [15], dynamic process creation [29], and time [35]. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> Carrier [12] remark that "it would be nice to have a theoretical foundation for general coordination." We conclude, in Section 7, with a discussion of how our work may help to provide such a foundation. 2 Background In this section, we describe the I/O automaton model of Lynch and Tuttle <ref> [32, 33] </ref>, the formal foundation of our work. There are several important reasons for basing a distributed algorithm development tool on a formal model. <p> The following brief introduction to the I/O automaton model includes a review of the basic model, as well as a discussion of techniques for modeling shared memory, superposition, dynamic process creation, and time. The details of the model and these techniques may be found elsewhere <ref> [33, 13, 15, 29, 35] </ref>. 2.1 I/O Automata An I/O automaton is essentially a nondeterministic (possibly infinite-state) automaton with an action labeling each transition. An automaton's actions are classified as either `input', `output', or `internal'. <p> A formal definition and a proof that a composition preserves a property if each of the component automata preserves the property are given elsewhere <ref> [33] </ref>. 3 Design Goals The main subject of this paper is the Spectrum Simulation System, a new research tool for the design and study of distributed algorithms. In this section, we discuss the design goals and their 12 implications, and then provide a brief overview of the design. <p> In the literature, the transition relations of I/O automata typically have been described using variations on the "precondition/effect" notation of Lynch and Tuttle <ref> [33] </ref> based on Dijkstra's guarded commands.
Reference: [34] <author> Jeff Magee, Naranker Dulay, and Jeff Kramer. </author> <title> Structuring parallel and distributed programs. </title> <booktitle> In Proceedings of the International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 102-117, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: A more typical approach to coordination languages, and the approach we adopt here, is to provide separate mechanisms for establishing explicit relationships among program modules. For example, Darwin <ref> [26, 34, 28] </ref>, a generalization of Conic [27, 28], is a configuration language that allows one to manage message-passing connections between the ports of various processes in a dynamic system. <p> To support this, Spectrum provides an abstraction mechanism called a port. The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin <ref> [26, 34, 28] </ref> and DEVS [48] the channel construct in Occam [39], and the import and export of variables in COSPAN [20], except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
Reference: [35] <author> Michael Merritt, Francesmary Modugno, and Mark R. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In Proceedings of the 2nd International Conference on Concurrency Theory, </booktitle> <volume> LNCS 527, </volume> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The remainder of this paper is organized as follows. In Section 2, we review the formal foundations for this work. This includes the I/O automaton model [32, 33], plus extensions of that model to support atomic shared memory [13], superposition [15], dynamic process creation [29], and time <ref> [35] </ref>. Then, in Section 3, we present an overview of the Spectrum Simulation System. <p> The following brief introduction to the I/O automaton model includes a review of the basic model, as well as a discussion of techniques for modeling shared memory, superposition, dynamic process creation, and time. The details of the model and these techniques may be found elsewhere <ref> [33, 13, 15, 29, 35] </ref>. 2.1 I/O Automata An I/O automaton is essentially a nondeterministic (possibly infinite-state) automaton with an action labeling each transition. An automaton's actions are classified as either `input', `output', or `internal'. <p> Because the eventuality properties that may be proven using the original I/O automaton model are not always enough, Merritt, Modugno and Tuttle have defined time-constrained automata, an extension of the I/O automaton model to support reasoning about time <ref> [35] </ref>. We summarize these extensions here. Interested readers are referred to their paper for details and a discussion of related work. <p> initial implementation of Spectrum [14], we have redesigned the system and added several features to the original I/O automaton model, including shared memory [13] and superposition [15], as well as incorporated into the design of Spectrum extensions to the model developed by others for dynamic process creation [29] and time <ref> [35] </ref>. The third goal, of course, implies that language features such as static type checking and a rich collection of built-in data types are needed in order to ensure that users spend their effort on experimenting with algorithms rather than finding obscure program errors.
Reference: [36] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS <ref> [36] </ref>, Statecharts [18, 19], UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools. <p> In fact, the I/O automaton model is differs significantly from CCS <ref> [36] </ref> and CSP [22] precisely in that input and output actions in the I/O automaton model are distinguished, and an I/O automaton cannot block an input action from occurring. In that sense, I/O automata are similar to Jonsson's I/O-systems [24].
Reference: [37] <author> Manfred Nagl. </author> <title> Set theoretic approaches to graph grammars. </title> <booktitle> In Proceedings of the 3rd International Conference on Graph-Grammars and their Application to Computer Science, </booktitle> <volume> LNCS 291, </volume> <pages> pages 41-54. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: However, just as we commonly provide a formal syntax for a textual programming language in the form of a grammar, it probably would be useful to have a formal description of our pictorial syntax. We have not yet 24 attempted this, but graph grammars <ref> [37, 44] </ref> appear to be a promising approach. In our pictorial syntax, we represent the vertices of the configuration graph as icons and the directed edges of the graph as lines with arrow heads indicating direction. The shape of a vertex indicates its type.
Reference: [38] <author> U.S. </author> <title> Department of Defense. Ada programming language. </title> <type> Technical Report ANSI/MIL-STD-1815A-1983, </type> <institution> United States Department of Defense, </institution> <year> 1983. </year>
Reference-contexts: For example, UNIX processes may, at run-time, create other processes, allocate shared variables, and create sockets for message-passing communication [5]. More recently, some languages have begun to provide constructs for creating multiple processes and communicating among them. Examples include the task construct in ADA <ref> [38] </ref> and the coenter construct in Argus [30]. Still, the structure of the system is not defined as a separate unit, but is defined as the result of the activities of the processes in the system.
Reference: [39] <author> Dick Pountain. </author> <title> A Tutorial Introduction to Occam Programming. INMOS, </title> <publisher> Limited, </publisher> <month> March </month> <year> 1986. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts [18, 19], UNITY [10], and Swarm [42, 43]. Some of these models have accompanying programming languages or simulation tools. For example, the Occam system <ref> [39] </ref> provides an implementation of a subset of CSP, the Statemate system [17] provides a simulation tool for systems described with Statecharts, and a programming language has been developed for the Swarm model as well. Another example is the COSPAN system based on its own s/r (selection/resolution) model [20]. <p> To support this, Spectrum provides an abstraction mechanism called a port. The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin [26, 34, 28] and DEVS [48] the channel construct in Occam <ref> [39] </ref>, and the import and export of variables in COSPAN [20], except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
Reference: [40] <author> James M. Purtilo and Christine R. Hofmeister. </author> <title> Dynamic reconfiguration of distributed programs. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 560-571, </pages> <month> May </month> <year> 1991. </year> <month> 47 </month>
Reference-contexts: Durra [6] provides, within a single language, separate mechanisms for describing computation modules, input and output ports, and channel connections between ports for large-grained distributed computation. Similarly, Hermes [45], provides a facility whereby values may be passed across ports that are connected from one module to another. Polylith <ref> [40, 41] </ref> provides module interconnection constructs for creating bindings among modules in a distributed system. Darwin and Polylith associate a predefined semantics with their connections. In Darwin, it is a message-passing semantics. In Polylith, it can be a remote procedure call or a message-passing semantics.
Reference: [41] <author> James M. Purtilo and Pankaj Jalote. </author> <title> An environment for prototyping distributed applications. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 588-594, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Durra [6] provides, within a single language, separate mechanisms for describing computation modules, input and output ports, and channel connections between ports for large-grained distributed computation. Similarly, Hermes [45], provides a facility whereby values may be passed across ports that are connected from one module to another. Polylith <ref> [40, 41] </ref> provides module interconnection constructs for creating bindings among modules in a distributed system. Darwin and Polylith associate a predefined semantics with their connections. In Darwin, it is a message-passing semantics. In Polylith, it can be a remote procedure call or a message-passing semantics.
Reference: [42] <author> Gruia-Catalin Roman and H. Conrad Cunningham. </author> <title> A shared dataspace model of concurrency: Language and programming implications. </title> <type> Technical Report WUCS-88-33, </type> <institution> Department of Computer Science, Washington University in St. Louis, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts [18, 19], UNITY [10], and Swarm <ref> [42, 43] </ref>. Some of these models have accompanying programming languages or simulation tools.
Reference: [43] <author> Gruia-Catalin Roman, Michael E. Ehlers, H. Conrad Cunningham, and R. Howard Lykins. </author> <title> Toward comprehensive specification of distributed systems. </title> <booktitle> In In Proceedings of the 7th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 282-289, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: A number of formal models have been developed for the study of concurrent systems. Examples include CSP [22], CCS [36], Statecharts [18, 19], UNITY [10], and Swarm <ref> [42, 43] </ref>. Some of these models have accompanying programming languages or simulation tools.
Reference: [44] <author> G. Rozenberg. </author> <title> An introduction to the NLC way of rewriting graphs. </title> <booktitle> In Proceedings of the 3rd International Conference on Graph-Grammars and their Application to Computer Science, </booktitle> <volume> LNCS 291, </volume> <pages> pages 55-66. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: However, just as we commonly provide a formal syntax for a textual programming language in the form of a grammar, it probably would be useful to have a formal description of our pictorial syntax. We have not yet 24 attempted this, but graph grammars <ref> [37, 44] </ref> appear to be a promising approach. In our pictorial syntax, we represent the vertices of the configuration graph as icons and the directed edges of the graph as lines with arrow heads indicating direction. The shape of a vertex indicates its type.
Reference: [45] <author> R.E. Strom, D.F. Bacon, A.P. Goldberg, A. Lowry, D.M. Yellin, and S. Yemini. </author> <title> Hermes: A Language for Distributed Computing. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Durra [6] provides, within a single language, separate mechanisms for describing computation modules, input and output ports, and channel connections between ports for large-grained distributed computation. Similarly, Hermes <ref> [45] </ref>, provides a facility whereby values may be passed across ports that are connected from one module to another. Polylith [40, 41] provides module interconnection constructs for creating bindings among modules in a distributed system. Darwin and Polylith associate a predefined semantics with their connections.
Reference: [46] <author> Gerald Jay Sussman and Jr. Guy Lewis Steele. </author> <title> Scheme: an interpreter for extended lambda calculus. </title> <type> Technical Report Memo 349, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> December </month> <year> 1975. </year>
Reference-contexts: A second prototype, with an improved language syntax and support for shared memory, superposition, and dynamic process creation, has been completed recently. The language parser for the second prototype is written in C (using yacc [23]) and produces a Scheme <ref> [46] </ref> file that is provided as input to the new Spectrum simulator, written in Scheme. In order to make some of the simulator's utility functions available to the Spectrum compiler, we have translated those utilities into C with a Scheme-to-C compiler [7].
Reference: [47] <author> Jennifer Welch, Leslie Lamport, and Nancy Lynch. </author> <title> A lattice-structured proof of a minimum spanning tree algorithm. </title> <booktitle> In Proceedings of the 7th ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 28-43, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: These features, discussed in Section 2, include composition, superposition, atomic shared memory, dynamic process creation, and time-constrained automata. Finally, we have chosen the I/O automaton model because it has been used successfully for describing a wide variety of nontrivial distributed algorithms (for examples, see 4 <ref> [2, 3, 4, 11, 16, 21, 31, 47] </ref>), providing evidence that the model could be quite useful to designers of practical systems.
Reference: [48] <author> Bernard P. Zeigler. </author> <title> Hierarchical, modular discrete-event modelling in an object-oriented environment. </title> <journal> Simulation, </journal> <volume> 49(5) </volume> <pages> 219-230, </pages> <year> 1987. </year> <month> 48 </month>
Reference-contexts: To support this, Spectrum provides an abstraction mechanism called a port. The idea of establishing connections with ports appears similar in flavor to mechanisms that have been provided in other systems, such as the port mechanisms in Darwin [26, 34, 28] and DEVS <ref> [48] </ref> the channel construct in Occam [39], and the import and export of variables in COSPAN [20], except that Spectrum ports have no predefined semantics. That is, Darwin, DEVS Occam, and COSPAN each have a particular communication semantics associated with their connection mechanism.
References-found: 48

