URL: ftp://ftp.cs.washington.edu/tr/1993/09/UW-CSE-93-09-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: 1 The Interaction Between Static Typing and Frameworks  
Author: Gail C. Murphy and David Notkin 
Abstract: Technical Report 93-09-02 Department of Computer Science and Engineering, FR-35 University of Washington Seattle WA, USA 98195 -gmurphy,notkin-@cs.washington.edu Abstract Frameworks capture the commonalities in design and implementation between a family of related applications and are typically expressed in an object-oriented language. Software engineers use frameworks to reduce the cost of building complex applications. This paper characterizes the operations of instantiation, refinement and extension used to build applications from frameworks and explores how these operations are supported by static typing policies of common object-oriented languages. We found that both conservative contravariant and covariant static typing policies were effective in supporting the operations of framework instantiation and framework extension. However, both policies were ineffective at supporting the operation of framework refinement. Although it does not support the refinement operation itself, covariance is sufficiently expressive to support the in-stantiation of a properly refined framework. This result illustrates how programming languages can at times complicate rather than simplify the engineering of software.
Abstract-found: 1
Intro-found: 1
Reference: [AAG93] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Using Style to Understand Descriptions of Software Architecture. </title> <booktitle> In Proceedings of the ACM SIGSOFT 93 Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Software Architecture: Research into software architecture [Sha90] focuses on developing more formal descriptions of the structure of a software system. This involves the use of existing formal notations [AG92] and the development of new notations and languages for describing the components and interactions between components of a software system <ref> [AAG93] </ref>. In this way, research into software architecture is similar to framework research. Frameworks differ significantly from software architecture in their simultaneous reuse of both design and implementation. In contrast, software architecture research focuses on specification rather than design and implementation.
Reference: [AG92] <author> Robert Allen and David Garlan. </author> <title> A Formal Approach to Software Architectures. </title> <booktitle> In Algorithms, Software, Architecture. Information Processing 92. IFIP 12th World Computer Congress., </booktitle> <pages> pages 134141, </pages> <note> September 1992. </note> <author> [BCM + 93] Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and Decidable Type Checking in an Object-Oriented Language. </title> <booktitle> In Proceedings of the OOPSLA 93 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: A framework thus provide reuse at a finer granularity than the transformation-based approach and may be reused in multiple different ways. Software Architecture: Research into software architecture [Sha90] focuses on developing more formal descriptions of the structure of a software system. This involves the use of existing formal notations <ref> [AG92] </ref> and the development of new notations and languages for describing the components and interactions between components of a software system [AAG93]. In this way, research into software architecture is similar to framework research. Frameworks differ significantly from software architecture in their simultaneous reuse of both design and implementation.
Reference: [BE93] <author> Andreas Birrer and Thomas Eggenschwiler. </author> <title> Frameworks in the Financial Engineering Domain: An Experience Report. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> Proceedings of the ECOOP 93 European Conference on Object-oriented Programming, </booktitle> <volume> LNCS 707, </volume> <pages> pages 2135, </pages> <address> Kaiserslautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews [LVC89], ET++ [WGM88] and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager <ref> [BE93] </ref>). Since frameworks provide partial designs and implementations, software engineers must define application-specific code to instantiate a framework into an application. A common problem is that many errors made during instantiation appear as run-time errors during application execution rather than when the instantiation operation is applied.
Reference: [Bro92] <author> Marc H. Brown. Zeus: </author> <title> A System for Algorithm Animation and Multi-View Editing. </title> <type> Technical Report SRC-075, </type> <institution> DEC Systems Research Center (SRC), </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: His approach focuses on easing the use of frameworks by leveraging the design. Brown developed the Zume tool to ease the use of an algorithm animation and multi-view editing framework called Zeus <ref> [Bro92] </ref>. Browns approach, in contrast to Hollands, is to generate a refined framework and instantiate an application based on an existing framework implementation.
Reference: [CCOM89] <author> Peter Canning, William Cook, Walter Olthoff, and John C. Mitchell. </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Proceedings of the Fourth International Conference on Functional Programming, Languages and Computer Architecture, </booktitle> <pages> pages 273280. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year> <note> [CDJ + 89] Luca Cardelli, </note> <author> Jim Donahue, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> The Modula-3 Type System. </title> <booktitle> In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages, pages 202212, </booktitle> <address> New York, NY, USA, </address> <month> January </month> <year> 1989. </year> <note> ACM, ACM. </note>
Reference-contexts: As with the separation of the class and type hierarchies, then, the introduction of parameterization is orthogonal to the static typing policy. Current research into typing policies for object-oriented languages focuses on the expression of recursively-defined types in the form of F-bounded polymorphism <ref> [CCOM89] </ref>, [BCM+93], on alternatives to the use of procedural abstraction for treating encapsulation, such as Pierce and Turners work on object encapsulation through existential types [PT93], and on new definitions of the subtype relationship [LW93].
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is Not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125 135. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Although the separation of these hierarchies is important to distinguish between specification reuse (subtypes) and implementation reuse (subclasses) <ref> [CHC90] </ref>, it does not impact the framework refinement problem. This is because the separation of the hierarchies is an orthogonal issue to the selection of a static typing policy. Similarly, whether an object-oriented language is class or prototype based [Lie86] does not appear to effect the typing policy.
Reference: [Che76] <author> P. P.-S. Chen. </author> <title> The Entity-Relationship Model - Toward a Unified View of Data. </title> <journal> ACM Transactions on Database Systems, </journal> <month> March </month> <year> 1976. </year>
Reference-contexts: Structural relationships specify the number of instances of a framework class and the interconnections between instances that must exist at run-time. The structural relationships are those that might commonly be represented on an entity-relationship diagram <ref> [Che76] </ref>. Some aspects of structural relationships, like the interconnections, may be realized in the framework implementation as messages. Other aspects, like the number of instances and the cardinality of the interconnections, cannot be explicitly represented within the implementation.
Reference: [CI92] <author> Roy H. Campbell and Nayeem Islam. </author> <title> A Technique for Documenting the Framework of an Object-Oriented System. </title> <booktitle> In Second International Workshop on Object-Orientation in Operating Systems, </booktitle> <pages> pages 288300, </pages> <address> Paris, France, October 1992. </address> <publisher> IEEE Computer Society Press. </publisher> - <pages> 16 </pages> - 
Reference-contexts: It is unsatisfying in the sense that it relies on informal information that is at times inconsistent, at times missing, and must, at times be inferred. Stylized approaches, like Patterns [Joh92], Contracts [HHG90] and multiple view documentation <ref> [CI92] </ref>, address the limitations of an example-based approach by providing specialized documentation formats, languages and notations respectively to more precisely describe the design and use of a framework. Stylized approaches are limited by their distance from the implementation, making it difficult to automate enforcement of framework usage constraints.
Reference: [CIM92] <author> Roy H. Campbell, Nayeem Islam, and Peter Madany. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> Computing Systems, </booktitle> <address> 5(3):217257, </address> <year> 1992. </year>
Reference-contexts: Frameworks are found in many application domains. Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews [LVC89], ET++ [WGM88] and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices <ref> [CIM92] </ref>), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager [BE93]). Since frameworks provide partial designs and implementations, software engineers must define application-specific code to instantiate a framework into an application.
Reference: [Coo89] <author> William Cook. </author> <title> A Proposal for Making Eiffel Type-safe. </title> <editor> In S. Cook, editor, </editor> <booktitle> Proceedings of the ECOOP 89 European Conference on Object-oriented Programming, </booktitle> <pages> pages 5770, </pages> <address> Nottingham, July 1989. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: The two typing policies differ in how the types of formal arguments to methods found in both a type and its subtype are related <ref> [Coo89] </ref>.
Reference: [Deu89] <author> L. Peter Deutsch. </author> <title> Design Reuse and Frameworks in the Smalltalk-80 System, </title> <booktitle> volume II of Frontier Series, chapter A.3, </booktitle> <pages> pages 5771. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Frameworks <ref> [Deu89, JF88, NGT92] </ref> are one of several approaches to reducing the cost of building complex applications by exploiting commonalities between related applications. Several properties distinguish frameworks from the other approaches. <p> Section 4 compares frameworks to these and other approaches to easing application development. Frameworks are found in many application domains. Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC <ref> [Deu89] </ref>, InterViews [LVC89], ET++ [WGM88] and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager [BE93]).
Reference: [FM89] <author> Patrick J. Ferrel and Robert F. Meyer. </author> <title> Vamp: The Aldus Application Framework. </title> <booktitle> In Proceedings of the OOPSLA 89 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 185190, </pages> <month> October </month> <year> 1989. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 24, number 10. </volume>
Reference-contexts: Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews [LVC89], ET++ [WGM88] and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP <ref> [FM89] </ref>) and financial management (ET++SwapsManager [BE93]). Since frameworks provide partial designs and implementations, software engineers must define application-specific code to instantiate a framework into an application.
Reference: [GLN92] <author> D. Garlan, Cai Linxi, </author> <title> and R.L. Nord. A Transformational Approach to Generating Application-Specific Environments. </title> <booktitle> In Proceedings of the Fifth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 6877, </pages> <month> December </month> <year> 1992. </year> <booktitle> Published as SIGSOFT Software Engineering Notes, </booktitle> <volume> Volume 17, Number 5. </volume>
Reference-contexts: This is, in part, because application generators are more specific to their domain than a framework. It is also not generally possible to compose application generators to build a system. Transformation-based Application-Specific Environments: Garlan et al. have proposed a transformation-based technique to automate the generation of application-specific environments <ref> [GLN92] </ref>. Transformations may be applied semi-automatically with the ASCENT tool to tailor a general purpose programming environment to a particular application domain.
Reference: [HHG90] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying Behavioral Compositions in Object-Oriented Systems. </title> <booktitle> In Proceedings of the OOPSLA/ECOOP 90 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169180, </pages> <month> October </month> <year> 1990. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 25, number 10. </volume>
Reference-contexts: It is unsatisfying in the sense that it relies on informal information that is at times inconsistent, at times missing, and must, at times be inferred. Stylized approaches, like Patterns [Joh92], Contracts <ref> [HHG90] </ref> and multiple view documentation [CI92], address the limitations of an example-based approach by providing specialized documentation formats, languages and notations respectively to more precisely describe the design and use of a framework.
Reference: [Hol92] <author> Ian M. Holland. </author> <title> Specifying Reusable Components Using Contracts. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings of the ECOOP 92 European Conference on Object-oriented Programming, </booktitle> <volume> LNCS 615, </volume> <pages> pages 287308, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Tools: Existing tool approaches to easing the use of a framework focus on the generation of refined frameworks and instantiated applications. Holland describes an environment for assisting the generation and integration of the framework classes based on an extension of the Contracts language <ref> [Hol92] </ref>. His approach focuses on easing the use of frameworks by leveraging the design. Brown developed the Zume tool to ease the use of an algorithm animation and multi-view editing framework called Zeus [Bro92].
Reference: [JF88] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing Reusable Classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2):2235, </volume> <month> June/July </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Frameworks <ref> [Deu89, JF88, NGT92] </ref> are one of several approaches to reducing the cost of building complex applications by exploiting commonalities between related applications. Several properties distinguish frameworks from the other approaches.
Reference: [Joh92] <author> Ralph E. Johnson. </author> <title> Documenting Frameworks using Patterns. </title> <booktitle> In Proceedings of the OOPSLA 92 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 6376, </pages> <month> October </month> <year> 1992. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 27, number 10. </volume>
Reference-contexts: It is unsatisfying in the sense that it relies on informal information that is at times inconsistent, at times missing, and must, at times be inferred. Stylized approaches, like Patterns <ref> [Joh92] </ref>, Contracts [HHG90] and multiple view documentation [CI92], address the limitations of an example-based approach by providing specialized documentation formats, languages and notations respectively to more precisely describe the design and use of a framework.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems. </title> <booktitle> In Proceedings of the OOPSLA 86 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 214223, </pages> <month> November </month> <year> 1986. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 21, number 11. </volume>
Reference-contexts: This is because the separation of the hierarchies is an orthogonal issue to the selection of a static typing policy. Similarly, whether an object-oriented language is class or prototype based <ref> [Lie86] </ref> does not appear to effect the typing policy. Separation of the class and type hierarchies, however, can enhance the safe substitutability of a refined framework for a source framework within a conservative contravariant type policy.
Reference: [LVC89] <author> Mark A. Linton, John M. Vlissides, and Paul R. Calder. </author> <title> Composing User Interfaces with InterViews. </title> <journal> Computer, </journal> <volume> 22(2), </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Section 4 compares frameworks to these and other approaches to easing application development. Frameworks are found in many application domains. Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews <ref> [LVC89] </ref>, ET++ [WGM88] and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager [BE93]).
Reference: [LW93] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A New Definition of the Subtype Relation. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> Proceedings of the ECOOP 93 European Conference on Object-oriented Programming, </booktitle> <volume> LNCS 707, </volume> <pages> pages 118141, </pages> <address> Kaiserslautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: for object-oriented languages focuses on the expression of recursively-defined types in the form of F-bounded polymorphism [CCOM89], [BCM+93], on alternatives to the use of procedural abstraction for treating encapsulation, such as Pierce and Turners work on object encapsulation through existential types [PT93], and on new definitions of the subtype relationship <ref> [LW93] </ref>. To support the operation of framework refinement, we need a typing system that will provide us even more.
Reference: [MDR93] <author> Scott Meyers, Carolyn K. Duby, and Steven P. Reiss. </author> <title> Constraining the Structure and Style of Object-Oriented Programs. </title> <type> Technical Report CS-93-12, </type> <institution> Brown University, </institution> <address> Box 1910 Providence, RI 02912, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: We believe that static typing policies will be most effective in conjunction with tools; particularly since support for current object-oriented languages is needed. For instance, the CCEL language and tools <ref> [MDR93] </ref> that permit software engineers to express constraints on the design and implementation of applications may provide a basis for enforcing the stylistic use of dynamic typing within a conservative contravariant typing policy. Additional tools would be necessary to determine and maintain substitutability given this approach.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: To study whether static typing helps with frameworks in practice, we took a basic framework the heart of the model-view part of the well-known Smalltalk-80 Model-View-Controller (MVC) and considered straightforward designs and realizations using two common typing policies, covariance (as realized in Eiffel <ref> [Mey88] </ref>), and conservative contravariance (as realized in Modula-3 [CDJ+89]).
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Modula-3, for example, uses a conservative contravariant typing policy [CDJ+89]. The Eiffel language uses a covariant type policy. To address type safety problems in earlier versions of the language, an extra level of checking, called system validity checking, has been designed for Eiffel Version 3 <ref> [Mey92] </ref>. System validity checking identifies potential compromises to type safety by considering, at compile-time, the set of types each expression within the system may potentially assume at run-time. This is accomplished through the determination of dynamic type sets for all expressions within the implementation.
Reference: [NGT92] <author> Oscar Nierstrasz, Simon Gibbs, and Dennis Tsichritzis. </author> <title> Component-Oriented Software Development. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Frameworks <ref> [Deu89, JF88, NGT92] </ref> are one of several approaches to reducing the cost of building complex applications by exploiting commonalities between related applications. Several properties distinguish frameworks from the other approaches.
Reference: [Par79] <author> David L. Parnas. </author> <title> Designing Software for Ease of Extension and Contraction. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(2), </volume> <month> March </month> <year> 1979. </year> <month> - 17 </month> - 
Reference-contexts: Frameworks differ significantly from software architecture in their simultaneous reuse of both design and implementation. In contrast, software architecture research focuses on specification rather than design and implementation. Software Extension and Contraction: Parnas describes various techniques for supporting the extension and contraction of software <ref> [Par79] </ref>. An understanding of how to extend and contract software permits a change in focus from the building of a single program to the building of a family of related programs.
Reference: [PT93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple Type-Theoretic Foundations for Object-Oriented Programming. </title> <journal> Journal of Functional Programming, </journal> <month> April </month> <year> 1993. </year>
Reference-contexts: Current research into typing policies for object-oriented languages focuses on the expression of recursively-defined types in the form of F-bounded polymorphism [CCOM89], [BCM+93], on alternatives to the use of procedural abstraction for treating encapsulation, such as Pierce and Turners work on object encapsulation through existential types <ref> [PT93] </ref>, and on new definitions of the subtype relationship [LW93]. To support the operation of framework refinement, we need a typing system that will provide us even more.
Reference: [SB90] <author> M. Spenke and A. </author> <title> Backer. GINA An Application Framework Based on a Language Binding for OSF/MOTIF and Common Lisp. </title> <booktitle> In Proceedings of the European X Window System Conference, </booktitle> <pages> pages 4653, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Section 4 compares frameworks to these and other approaches to easing application development. Frameworks are found in many application domains. Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews [LVC89], ET++ [WGM88] and Gina <ref> [SB90] </ref> are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager [BE93]). Since frameworks provide partial designs and implementations, software engineers must define application-specific code to instantiate a framework into an application.
Reference: [Sha90] <author> Mary Shaw. </author> <title> Toward higher-level abstractions for software systems. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 5:119128, </volume> <year> 1990. </year>
Reference-contexts: 1 Introduction Frameworks [Deu89, JF88, NGT92] are one of several approaches to reducing the cost of building complex applications by exploiting commonalities between related applications. Several properties distinguish frameworks from the other approaches. First, in contrast to software architectures <ref> [Sha90] </ref>, which primarily focus on the common aspects of the specification of the members of a family, frameworks capture key aspects of the design and implementation of the members. <p> When a framework is reused in this manner, both the design and implementation are reused. A framework thus provide reuse at a finer granularity than the transformation-based approach and may be reused in multiple different ways. Software Architecture: Research into software architecture <ref> [Sha90] </ref> focuses on developing more formal descriptions of the structure of a software system. This involves the use of existing formal notations [AG92] and the development of new notations and languages for describing the components and interactions between components of a software system [AAG93].
Reference: [VL90] <author> J.M. Vlissides and M.A. Linton. Unidraw: </author> <title> A Framework for Building Domain-Specific Graphical Editors. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3):237268, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: The result is that at run-time, the subtype is no longer substitutable for the type. This is not just a by-product of the designs we implemented in Modula-3, but is also seen in other frameworks expressed in statically typed languages. For example, the C++ Unidraw framework <ref> [VL90] </ref> that refines the InterViews framework also uses type casting. For supporting framework operations, covariance is the most attractive static typing policy found in common object-oriented languages. The system validity checking rules defined for Eiffel regain a portion of the substitutability compromised by the covariant type policy.
Reference: [WGM88] <author> Andr Weinand, Erich Gamma, and Rudolph Marty. </author> <title> ET++ An Object-Oriented Application Framework in C++. </title> <booktitle> In Proceedings of the OOPSLA 88 Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 4657, </pages> <month> November </month> <year> 1988. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 23, number 11. </volume>
Reference-contexts: Section 4 compares frameworks to these and other approaches to easing application development. Frameworks are found in many application domains. Most commonly, frameworks have been used to ease the development of graphical applications. For example, MVC [Deu89], InterViews [LVC89], ET++ <ref> [WGM88] </ref> and Gina [SB90] are all user interface frameworks. Frameworks are also found in domains such as operating systems (Choices [CIM92]), document preparation (VAMP [FM89]) and financial management (ET++SwapsManager [BE93]). Since frameworks provide partial designs and implementations, software engineers must define application-specific code to instantiate a framework into an application.
Reference: [WZ88] <author> Peter Wegner and Stanley B. Zdonik. </author> <title> Inheritance as an Incremental Modification Mechanism or What Like Is and Isnt Like. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> Proceedings of the ECOOP 88 European Conference on Object-oriented Programming, </booktitle> <volume> LNCS 322, </volume> <pages> pages 5577, </pages> <address> Oslo, </address> <month> August </month> <year> 1988. </year> <title> Springer Verlag. The Interaction Between Static Typing and Frameworks Gail C. </title> <note> Murphy and David Notkin Technical Report 93-09-02 October 13, </note> <year> 1993 </year>
Reference-contexts: The two typing policies differ in how the types of formal arguments to methods found in both a type and its subtype are related [Coo89]. Consider a type Person and a subtype Retiree (of Person) with a common method, setAge (this example is based on <ref> [WZ88] </ref>): type Person subtype Retiree of Person setAge (Integer (0..120)) setAge (Integer (0..120)) In a conservative contravariant typing policy, the type of a formal argument for a method found in both the subtype and the type must be the same as the type of the argument specified for the method in
References-found: 31

