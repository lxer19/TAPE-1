URL: http://http.cs.berkeley.edu/~zhendong/ps/fossacs98.ps
Refering-URL: http://http.cs.berkeley.edu/~zhendong/links/papers.html
Root-URL: 
Title: Deciding Properties for Message Sequence Charts  
Author: Anca Muscholl Doron Peled Zhendong Su 
Abstract: Message sequence charts (MSC) are commonly used in designing communication systems. They allow describing the communication skeleton of a system and can be used for finding design errors. First, a specification formalism that is based on MSC graphs, combining finite message sequence charts, is presented. We present then an automatic validation algorithm for systems described using the message sequence charts notation. The validation problem is tightly related to a natural language-theoretic problem over semi-traces (a generalization of Mazurkiewicz traces, which represent partially ordered executions). We show that a similar and natural decision problem is undecidable.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, G. Holzmann, and D. Peled. </author> <title> An analyzer for message sequence charts. </title> <booktitle> Software Concepts and Tools, </booktitle> <volume> 17(2) </volume> <pages> 70-77, </pages> <year> 1996. </year>
Reference-contexts: For example, one can use MSCs to search for missing features or incorrect behaviors. It is possible to detect mistakes in the design, e.g., the existence of race conditions <ref> [1] </ref> or non-local choice [2]. Another task that is often done using MSCs is providing `feature transparence', namely upgrading a communication system in a way that all the previous services are guaranteed to be supported. In recent years MSCs have gained popularity and interest. <p> In recent years MSCs have gained popularity and interest. An international committee (ITU-Z 120 [7]) has been working on developping standards for MSCs. Some tools for displaying MSCs and performing simple checks were developed <ref> [1, 8] </ref>. We model systems of MSCs, allowing a (possibly infinite) family of (finite or infinite) executions. Each execution consists of a finite or infinite set of send and receive events, together with a partial (causal) order between them. <p> Work is in progress to add the proposed validation framework to a toolset that was developed for manipulating MSCs <ref> [1] </ref>. This paper concludes with several open problems and suggested work. 2 Charts and MSC graphs In this section, we introduce message sequence charts (MSC) and MSC graphs, as well as the matching problem. <p> Message sequence graphs (MSC graphs, sometimes called high-level MSCs [7]), are used to compose MSCs to larger systems. Equivalently, one can compose MSCs using rational operations, i.e. union, concatenation and iteration. MSC graphs are finite directed graphs where each node of the graph is associated with a finite MSC <ref> [1] </ref>. Definition 2.6 (MSC graph) An MSC graph N is a quadruple hS; t; s 0 ; ci where hS; t; s 0 i is a finite directed graph with states set S, transition relation t S fi S and starting state s 0 2 S.
Reference: [2] <author> H. Ben-Abdallah and S. Leue. </author> <title> Syntactic detection of process divergence and non-local choice in message sequence charts. </title> <editor> In E. Brinksma, editor, </editor> <booktitle> Proceedings of theTools and Algorithms for the Construction and Analysis of Systems, Third International Workshop, TACAS'97, number 1217 in Lecture Notes in Computer Science, </booktitle> <pages> pages 259-274, </pages> <address> Enschede, The Netherlands, 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: For example, one can use MSCs to search for missing features or incorrect behaviors. It is possible to detect mistakes in the design, e.g., the existence of race conditions [1] or non-local choice <ref> [2] </ref>. Another task that is often done using MSCs is providing `feature transparence', namely upgrading a communication system in a way that all the previous services are guaranteed to be supported. In recent years MSCs have gained popularity and interest.
Reference: [3] <author> J. Berstel. </author> <title> Transductions and context-free languages. </title> <publisher> Teubner Studienbucher, Stuttgart, </publisher> <year> 1979. </year>
Reference-contexts: For the trace monoid given by the rules ab = ba, cd = dc it is known that one cannot decide for given regular languages L 1 ; L 2 fa; b; c; dg fl whether [L 1 ] " [L 2 ] is empty <ref> [3] </ref>, where [L] = [ u2L [u] denotes the closure of L under fl Proposition 5.2 Let M; N be two MSC graphs. <p> Moreover, these total orders are completely independent. Viewed as a mapping from M (; SI) to tr (M), h is injective. This, together with <ref> [3] </ref>, concludes our proof. 2 Let us comment our results in the context of semi-trace languages.
Reference: [4] <author> M. Clerbout and M. Latteux. </author> <title> Partial commutations and faithful rational transduc-tions. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 241-254, </pages> <year> 1984. </year>
Reference-contexts: The complexity of related problems has been studied for pomset languages [6]. In contrast, in [6] only finite pomset languages are studied (however, over a richer structure). The matching problem can also be represented as a decision problem for semi-traces <ref> [4] </ref>. A semi-trace is a set of words that is obtained from some word by means of (not necessarily symmetric) rewriting rules. These rules allow commuting pairs of adjacent letters. A semi-trace language is a set of words closed under these given rewriting rules.
Reference: [5] <editor> V. Diekert and G. Rozenberg, editors. </editor> <title> The Book of Traces. </title> <publisher> World Scientific, </publisher> <address> Singa-pore, </address> <year> 1995. </year>
Reference-contexts: In general, the visual order provides more ordering than intended by the designer. Therefore we associate with every chart a causal structure providing the intended ordering. Causal structures are related to pomsets [11], event structures [9], and traces <ref> [5] </ref>. A causal structure is obtained from an MSC by means of a given semantics. <p> Semi-traces are objects known from the algebraic study of concurrency (for a survey on semi-traces see Chapter 12 in <ref> [5] </ref>). Formally, assume that P = fP 1 ; : : : ; P m g is the set of processes. <p> We show this by induction on the length of t M . For lack of space, the details are left to the full version of the paper. 2 Traces <ref> [5] </ref> result from in symmetric rewriting rules, i.e. both SI and SD are symmetric relations.
Reference: [6] <author> J. Feigenbaum, J. Kahn, and C. Lund. </author> <title> Complexity results for pomset languages. </title> <journal> SIAM Journal Disc. Math., </journal> <volume> 6(3) </volume> <pages> 432-442, </pages> <year> 1993. </year>
Reference-contexts: In the special case of matching two single MSCs we provide a deterministic polynomial time algorithm, improving the result of [8], see Section 3. The complexity of related problems has been studied for pomset languages <ref> [6] </ref>. In contrast, in [6] only finite pomset languages are studied (however, over a richer structure). The matching problem can also be represented as a decision problem for semi-traces [4]. <p> In the special case of matching two single MSCs we provide a deterministic polynomial time algorithm, improving the result of [8], see Section 3. The complexity of related problems has been studied for pomset languages <ref> [6] </ref>. In contrast, in [6] only finite pomset languages are studied (however, over a richer structure). The matching problem can also be represented as a decision problem for semi-traces [4]. A semi-trace is a set of words that is obtained from some word by means of (not necessarily symmetric) rewriting rules.
Reference: [7] <author> ITU-T Recommendation Z.120, </author> <title> Message Sequence Chart (MSC), </title> <month> March </month> <year> 1993. </year>
Reference-contexts: Another task that is often done using MSCs is providing `feature transparence', namely upgrading a communication system in a way that all the previous services are guaranteed to be supported. In recent years MSCs have gained popularity and interest. An international committee (ITU-Z 120 <ref> [7] </ref>) has been working on developping standards for MSCs. Some tools for displaying MSCs and performing simple checks were developed [1, 8]. We model systems of MSCs, allowing a (possibly infinite) family of (finite or infinite) executions. <p> The concatenation of an infinite sequence M 1 ; M 2 ; : : : is defined in an analogous way. Message sequence graphs (MSC graphs, sometimes called high-level MSCs <ref> [7] </ref>), are used to compose MSCs to larger systems. Equivalently, one can compose MSCs using rational operations, i.e. union, concatenation and iteration. MSC graphs are finite directed graphs where each node of the graph is associated with a finite MSC [1].
Reference: [8] <author> V. Levin and D. Peled. </author> <title> Verification of message sequence charts via template matching. </title> <booktitle> In TAPSOFT (FASE)'97, Theory and Practice of Software Development, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 652-666, </pages> <address> Lille, France, 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: In recent years MSCs have gained popularity and interest. An international committee (ITU-Z 120 [7]) has been working on developping standards for MSCs. Some tools for displaying MSCs and performing simple checks were developed <ref> [1, 8] </ref>. We model systems of MSCs, allowing a (possibly infinite) family of (finite or infinite) executions. Each execution consists of a finite or infinite set of send and receive events, together with a partial (causal) order between them. <p> For the last two problems we provide algorithms and we show them to be NP-complete, see Section 4. In the special case of matching two single MSCs we provide a deterministic polynomial time algorithm, improving the result of <ref> [8] </ref>, see Section 3. The complexity of related problems has been studied for pomset languages [6]. In contrast, in [6] only finite pomset languages are studied (however, over a richer structure). The matching problem can also be represented as a decision problem for semi-traces [4]. <p> As a first result, we show that we can check whether a template can be embedded into a single MSC in polynomial time. (Recall that we assume that the fifo semantics is used.) This algorithm refines the result of <ref> [8] </ref>, where a PSPACE algorithm was exhibited without specifying the semantics. The present matching algorithm is based on the simple observation that it suffices to match a suitable minimal send event and the corresponding receive event with the first occurrence of a message pair of the same type.
Reference: [9] <author> M. Nielsen, G. Plotkin, and G. Winskel. </author> <title> Petri nets, event structures and domains, part 1. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 85-108, </pages> <year> 1981. </year>
Reference-contexts: In general, the visual order provides more ordering than intended by the designer. Therefore we associate with every chart a causal structure providing the intended ordering. Causal structures are related to pomsets [11], event structures <ref> [9] </ref>, and traces [5]. A causal structure is obtained from an MSC by means of a given semantics.
Reference: [10] <author> J.-E. Pin. </author> <title> Syntactic semigroups. </title> <editor> In G. Rozenberg and A. Salomaa, editors, </editor> <booktitle> Handbook of Formal Languages, </booktitle> <volume> volume 1, </volume> <pages> pages 679-738. </pages> <publisher> Springer, </publisher> <address> Berlin-Heidelberg-New York, </address> <year> 1997. </year>
Reference-contexts: that U tt fl is a very simple regular language, a finite union of languages of the form fl a 1 fl a 2 fl a k fl for some letters a i 2 . (This family of languages corresponds exactly to level `1=2' in the concatenation hierarchy of Straubing-Therien <ref> [10] </ref>).
Reference: [11] <author> V. R. Pratt. </author> <title> Modelling concurrency with partial orders. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 15(1) </volume> <pages> 33-71, </pages> <year> 1986. </year> <month> 15 </month>
Reference-contexts: This imposes a total order among all events of P , for every process P . In general, the visual order provides more ordering than intended by the designer. Therefore we associate with every chart a causal structure providing the intended ordering. Causal structures are related to pomsets <ref> [11] </ref>, event structures [9], and traces [5]. A causal structure is obtained from an MSC by means of a given semantics.
References-found: 11

