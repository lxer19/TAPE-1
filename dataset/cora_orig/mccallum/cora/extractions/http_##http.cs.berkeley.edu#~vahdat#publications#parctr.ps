URL: http://http.cs.berkeley.edu/~vahdat/publications/parctr.ps
Refering-URL: http://http.cs.berkeley.edu/~vahdat/Research/research.html
Root-URL: http://www.cs.berkeley.edu
Title: The Design of a Metaobject Protocol Controlling Behavior of a Scheme Interpreter  
Author: Amin Vahdat 
Date: March 10, 1993  
Abstract-found: 0
Intro-found: 1
Reference: [ASS85] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: Thus, the types of metaobjects provided by the protocol would determine the kind of control the programmer has over the language semantics. We chose our metaobjects to correspond to the three separate, but inter-dependent constructs described for the scheme interpreter in <ref> [ASS85] </ref>. First, there must be a representation of the program to be interpreted. Second, the interpreter must maintain an internal state to determine the context under which a statement is to be evaluated.
Reference: [Cli91] <institution> The revised 4 report on the algorithmic language Scheme, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: However, these same ideas can be used to give the user control over the actual semantics of the programming language. In order to experiment with the utility of this kind of ability, we have designed a metaobject protocol for an interpreter 1 with the base semantics of Scheme <ref> [Cli91] </ref>. Through the MOP, we provide a protocolization of the essential structure of a language implementation designed in a way to expose those aspects of the interpreter's behavior which we would like the user to access and control.
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Recent work strongly suggests people prefer to work with systems which are open, that is, which allow their user to tailor system behavior according to their individual needs. This notion of open behavior has recently been shown to be applicable to programming languages in <ref> [KdRB91, Rod91] </ref> through the use of metaobject protocols. Efforts in this area have been largely focused on increasing the performance of compilers. However, these same ideas can be used to give the user control over the actual semantics of the programming language.
Reference: [KL92] <author> Gregor Kiczales and John Lamping. </author> <title> Issues in the design and documentation of class libraries. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <year> 1992. </year> <note> To Appear. </note>
Reference-contexts: above), if force is called with a thunk, then the thunk's expression is evaluated recursively until a non-thunk is returned. 4.3 Ploy's Generic Functions As demonstrated by the above examples, Ploy's generic functions logically partition the task of evaluation by dividing into layers which carry out progressively more specific duties <ref> [KL92] </ref>. The layering of the protocol was largely driven by the desire to provide the most convenient access points for all of the semantic extensions which we implemented, rather than being tailored for ease of use with any single example.
Reference: [Rod91] <author> Luis H. Rodriguez Jr. </author> <title> Coarse-grained parallelism using metaobject protocols. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1991. </year> <month> 23 </month>
Reference-contexts: 1 Introduction Recent work strongly suggests people prefer to work with systems which are open, that is, which allow their user to tailor system behavior according to their individual needs. This notion of open behavior has recently been shown to be applicable to programming languages in <ref> [KdRB91, Rod91] </ref> through the use of metaobject protocols. Efforts in this area have been largely focused on increasing the performance of compilers. However, these same ideas can be used to give the user control over the actual semantics of the programming language. <p> im plement the desired changes. 2 Thus, the metaobject protocol designer's role in this scenario is to provide logical and clean access points for a wide variety of possible semantic extensions (an interface for the language designer). 4 Derivation of Ploy's Protocol Ploy's basic structure closely resembles that of Anibus <ref> [Rod91] </ref>. User programs are parsed into a program graph reflecting their logical structure. Nodes within the program graph are metaobjects. Evaluation of these metaobjects is done through methods which specialize on one or metaobjects. Users can specialize the behavior of the language through marks on the program source.
References-found: 5

