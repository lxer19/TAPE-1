URL: http://www.cs.wustl.edu/~schmidt/Reactor1-93.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/cs544/
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: The Reactor An Object-Oriented Wrapper for Event-Driven Port Monitoring and Service Demultiplexing (Part 1 of 2)  
Author: Douglas C. Schmidt 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Web: http://www.cs.wustl.edu/schmidt/  
Abstract: An earlier version of this paper appeared in the February 1993 issue of the C++ Report. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Systems Programming with C++ Wrappers: Encapsulating Interprocess Communication Services with Object-Oriented Interfaces, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> September/October </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This is part one of the third article in a series that describes techniques for encapsulating existing operating system (OS) interprocess communication (IPC) services within object-oriented (OO) C++ wrappers. The first article explains the main principles and motivations for OO wrappers <ref> [1] </ref>, which simplify the development of correct, concise, portable, and efficient applications. The second article describes an OO wrapper called IPC SAP [2] that encapsulates the BSD socket and System V TLI system call Application Programmatic Interfaces (APIs).
Reference: [2] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: The first article explains the main principles and motivations for OO wrappers [1], which simplify the development of correct, concise, portable, and efficient applications. The second article describes an OO wrapper called IPC SAP <ref> [2] </ref> that encapsulates the BSD socket and System V TLI system call Application Programmatic Interfaces (APIs). IPC SAP enables application programs to access local and remote IPC protocol families such as TCP/IP via a type-secure, object-oriented interface. <p> The Reactor also shields developers from many error-prone details in the existing event demultiplexing APIs and improves application portability between different OS variants. The Reactor is somewhat different than the IPC SAP class wrapper described in <ref> [2] </ref>. IPC SAP added a relatively thin OO veneer to the BSD socket and System V TLI APIs. <p> In particular, each section presents a skeletal server logging daemon implemented with the alternative being discussed. To save space and increase clarity, the examples utilize the OO IPC SAP socket-wrapper library described in a previous C++ Report article <ref> [2] </ref>. The handle logging record function shown in Figure 2 is also invoked by all the example server daemons. <p> Since applications built upon the Reactor framework do not access select or poll directly, it is not possible to accidentally misuse these underlying system calls. Moreover, the Reactor may be used in conjunction with the strongly-typed local and remote communication services provided by the IPC SAP wrapper library <ref> [2] </ref>. This further reduces the likelyhood for type errors to arise at run-time. * Low-Level Interfaces: The select interface is rather low-level, requiring programmers to manipulate up to three different descriptor set bit-masks. Moreover, these bit-masks are passed to the select call using value/result parameter semantics.
Reference: [3] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: The complete design and implementation of the distributed logging facility is described in <ref> [3] </ref>. <p> An instance of this class is then constructed and registered with the Reactor. After registration, the server initiates an event-loop that automatically dispatches the Logging Acceptor::handle input member function when connection requests arrive. A subsequent article <ref> [3] </ref> describes the design and implementation of the Logging Acceptor and Logging Handler classes and other components used to implement the Reactor in greater detail. Non-Portable Interfaces: Although event demultiplexing is not part of the POSIX standard, System V Release 4, BSD UNIX, and WINSOCK all support the select API.
Reference: [4] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Engle-wood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The newly created slave process performs blocking I/O on a single descriptor in the logging handler subroutine, which receives all logging records sent from its associated client. When the 4 Concurrent servers are described in detail in <ref> [4] </ref>. 4 // Handle all logging records from a particular // client (run in each slave process). static void logging_handler (ACE_HANDLE handle) - // Perform a "blocking" receive and process // client logging records until client shuts down // the connection. for (ssize_t n; (n = handle_logging_record (handle)) &gt; 0; )
Reference: [5] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol III: Client Server Programming and Applications. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1992. </year> <month> 10 </month>
Reference-contexts: In particular, this approach improves the response times of servers that are either (1) I/O bound (e.g., complicated relational database queries) or (2) involve simultaneous, longer-duration client services that require a variable amount of time to execute (e.g., file transfer or remote login) <ref> [5] </ref>. Another advantage is that overall server performance may be improved in an application-transparent manner, if the underlying operating system supports multiple processing elements effectively. 3.3 A Multi-Threaded Solution The third approach utilizes a multi-threaded approach.
Reference: [6] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shiv--alingiah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithread-ing the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Another advantage is that overall server performance may be improved in an application-transparent manner, if the underlying operating system supports multiple processing elements effectively. 3.3 A Multi-Threaded Solution The third approach utilizes a multi-threaded approach. The example illustrated in Figure 9 uses the SunOS 5.x threads library <ref> [6] </ref> to implement a multi-threaded concurrent server. Other thread libraries (such as POSIX and Windows NT threads) offer an equivalent solution. In the example code, a new thread a spawned by the ACE Thread::spawn routine to handle each client connection.
Reference: [7] <author> A. D. Birrell, </author> <title> An Introduction to Programming with Threads, </title> <type> Tech. Rep. </type> <institution> SRC-035, Digital Equipment Corporation, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: A detached thread in SunOS 5.x never re-synchronizes nor re-joins with the main thread of control when it exits. Moreover, compared with a process, it may be more efficient to create, execute, and terminate a thread, due to a reduction in context switching overhead <ref> [7] </ref>. In addition, sharing of global data objects is also often more convenient since no special operations must be performed to obtain shared memory. Traditional operating systems (such as older versions of UNIX and Windows) do not provide adequate support for threads.
Reference: [8] <author> W. R. Stevens, </author> <title> Advanced Programming in the UNIX Environment. </title> <address> Reading, Massachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Both these calls support I/O-based and timer-based event demultiplex-ing. The syntax and semantics of both select and poll are described in greater detail in <ref> [8] </ref>. Despite their different APIs, select and poll share many common features. For example, they both wait for various input, output, and exception 5 events to occur on a set of I/O descriptors, and return an integer value indicating how many events occurred.
References-found: 8

