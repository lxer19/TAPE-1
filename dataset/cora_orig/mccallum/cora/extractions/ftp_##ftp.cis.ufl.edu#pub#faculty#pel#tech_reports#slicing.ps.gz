URL: ftp://ftp.cis.ufl.edu/pub/faculty/pel/tech_reports/slicing.ps.gz
Refering-URL: http://www.cis.ufl.edu/~pel/Ghinsu/gghinsu.html
Root-URL: http://www.cis.ufl.edu
Title: System Dependence Graphs Based on Parse Trees and their Use in Software Maintenance 1  
Author: Panos E. Livadas Stephen Croll 
Keyword: Categories and Subject Descriptors: D.1.0 [Programming Techniques]:General; F.2.0 [Analysis of Algorithms]:General; D.3.3 [Programming Languages]: Language Constructs control structures. procedures, functions, and subroutines; D.3.4 [Programming Languages]: Processors compilers, optimization I.3.5. Additional Key Words and Phrases: Algorithms, control dependence, data dependence, program debugging, program dependence graph, program slicing.  
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: The concept of static program slicing was first introduced by Weiser. Ottenstein et al. indicated that an intraprocedural slice can be found in linear time by traversing a suitable graph representation of the program referred to as the program dependence graph (PDG). Horwitz et al. introduced algorithms to construct interprocedural slices by extending the program dependence graph to a supergraph of the PDG referred to as the system dependence graph (SDG). This extension captures the calling context of procedures. In this paper, the SDG is further extended so that it handles a grammar with additional constructs; algorithms are introduced that permit one to build the SDG so that it is based on a parse tree instead of statements; a new method is described to calculate the transitive dependences and therefore build the SDG. In addition, we demonstrate how the parse tree-based SDG can be used to provide us with ``smaller'' and therefore more precise slices; and, we show how slices of variables that are used in a statement can be obtained. Finally, the versatility of the SDG as an internal program representation is illustrated by briefly presenting a tool that we have developed that permits slicing, dicing, and ripple analyzing in addition to other software engineering activities to be performed on programs written in a subset of ANSI C. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, and J.R. Horgan. </author> <title> ``Dynamic Program Slicing'', </title> <type> Technical Report SERC-TR-56-P, </type> <institution> Software Engineering Research Center, Computer Science Dept., Purdue University. </institution>
Reference-contexts: The execution of statements [6] and [7] is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - <ref> [1] </ref>. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> Declaration edges can be considered to be a special kind of data flow edge. The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement <ref> [1] </ref> and statements [4] and [6] and between statement [2] and statements [3] and [7]. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - <ref> [ 1] </ref>. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ <p> In particular, we will show via an example that slices could usually be larger than necessary; and, then we present our method. Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. <ref> [1] </ref>. i = 0; [1]. i = 0; [3]. sum = sum + Alpha (&i); [3]. Alpha (&i); [4]. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> In particular, we will show via an example that slices could usually be larger than necessary; and, then we present our method. Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. <ref> [1] </ref>. i = 0; [1]. i = 0; [3]. sum = sum + Alpha (&i); [3]. Alpha (&i); [4]. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> We will now give an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. <ref> [ 1] </ref>. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - <p> The called procedure always returns to the correct address in the calling procedure. This completely eliminates the use of linkage grammar and the construction of the subordinate characteristic graphs making our algorithm more efficient. Agrawal <ref> [1] </ref> has provided algorithms for intraprocedural dynamic slicing. The Ghinsu tool, however, uses the concept of static slicing.
Reference: [2] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> ``The Design and Analysis of Computer Algorithms'', </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: The execution of statements [6] and [7] is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; <ref> [2] </ref> int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement [1] and statements [4] and [6] and between statement <ref> [2] </ref> and statements [3] and [7]. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) <ref> [ 2] </ref>. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. <p> Alpha () Entry sum=sum+ Actual-Out Actual-In b = suma = i &i &i If we slice this program via the algorithm presented earlier on the statement based system dependence graph of Figure 7 at the statement a = i, we will obtain the set of statements -[1], <ref> [2] </ref> , [3], [4]-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. <p> Consequently, all other statements of the program that belong in the slice of statement [3] (relative to variable sum) will unnecessarily be included in the slice of a 10 ! Notice that this inaccuracy would have been propagated upwards further if statement <ref> [2] </ref> was of the form sum=u+v;. This shortcoming is a direct result of the fact that when the node corresponding to statement [3] is encountered during slicing all flow edges are followed backwards. <p> Consider the parse tree based SDG counterpart of the statement based SDG of Figure 8 and which corresponds to the code ________________ 10 Notwithstanding the fact that all reaching definitions of the variable sum are killed at statement <ref> [2] </ref> of this example. - 13 - fragment of Table 3 (i). Alpha () Entry sumb a sum sumsum 0 0 + &i&i ii Call-Site Actual-OutActual-In Instead of slicing at statement a = i, we now slice at the assignment of a at that statement. <p> We will now give an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) <ref> [ 2] </ref>. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9].
Reference: [3] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> ``Compilers: Principles, Techniques and Tools'', </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: The above relationship can be denoted by using the following notation: v 1 fi v 2 For the factorial program (Table 1), one can see that statement [6] is data flow dependent on statements <ref> [3] </ref>, [4], [7], and itself. Declaration edges: These edges indicate the dependences that exist between the declaration and the definition of variables in a program. <p> The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement [1] and statements [4] and [6] and between statement [2] and statements <ref> [3] </ref> and [7]. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> Then, according to the program dependence graph of Figure 1 and in view of the remark above, the graph is traversed backwards starting at node [7]; and, the nodes that we encounter are ``accumulated''. It is easy to visualize that V (G P /[ 7 ] ) = -[2], <ref> [3] </ref>, [5], [7]-. 3. System Dependence Graph Our discussion now moves to slicing on a program which consists of a collection of one or more procedures and their associated parameters. To address this problem, the program dependence graph is extended to what is called a system dependence graph (SDG)[10]. <p> Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. [1]. i = 0; [1]. i = 0; <ref> [3] </ref>. sum = sum + Alpha (&i); [3]. Alpha (&i); [4]. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. [1]. i = 0; [1]. i = 0; <ref> [3] </ref>. sum = sum + Alpha (&i); [3]. Alpha (&i); [4]. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> Alpha () Entry sum=sum+ Actual-Out Actual-In b = suma = i &i &i If we slice this program via the algorithm presented earlier on the statement based system dependence graph of Figure 7 at the statement a = i, we will obtain the set of statements -[1], [2] , <ref> [3] </ref>, [4]-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. Consequently, all other statements of the program that belong in the slice of statement [3] (relative to variable sum) will unnecessarily be included in <p> earlier on the statement based system dependence graph of Figure 7 at the statement a = i, we will obtain the set of statements -[1], [2] , <ref> [3] </ref>, [4]-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. Consequently, all other statements of the program that belong in the slice of statement [3] (relative to variable sum) will unnecessarily be included in the slice of a 10 ! Notice that this inaccuracy would have been propagated upwards further if statement [2] was of the form <p> will obtain the set of statements -[1], [2] , <ref> [3] </ref>, [4]-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. Consequently, all other statements of the program that belong in the slice of statement [3] (relative to variable sum) will unnecessarily be included in the slice of a 10 ! Notice that this inaccuracy would have been propagated upwards further if statement [2] was of the form sum=u+v;. This shortcoming is a direct result of the fact that when the node corresponding to statement [3] <p> <ref> [3] </ref> (relative to variable sum) will unnecessarily be included in the slice of a 10 ! Notice that this inaccuracy would have been propagated upwards further if statement [2] was of the form sum=u+v;. This shortcoming is a direct result of the fact that when the node corresponding to statement [3] is encountered during slicing all flow edges are followed backwards. We are avoiding this inaccuracy and consequently obtain more precise and therefore ``smaller'' slices by modifying the system dependence graph. So far, the nodes of the SDG are ``resolved'' at the statement level. <p> or calculate the corresponding subordinate graphs for the determination of the transitive dependences; actual_out nodes that are deemed N-nodes ________________ 11 We should note that the mapping from the source file to our parse tree based SDG that is described in section 10 permits us to display the entire statement <ref> [3] </ref> to the user as a member of the slice. 12 In the case of aliasing phenomena each aliasing pattern is assumed to give rise to a distinct function. - 14 - are identified as such during the SDG construction and dependence calculation that makes calculation of the GMOD and GREF
Reference: [4] <author> L. Badger, and M. Weiser. </author> <title> ``Minimizing Communications for Synchronizing Parallel Dataflow Programs'', </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <publisher> Penn State University Press, </publisher> <address> PA. </address>
Reference-contexts: Because slices can execute independently, they may be suitable for parallel execution on multiprocessors without synchronization or shared memory ([22] <ref> [4] </ref>). Only ``splicing'' programs will be needed to ``fit'' the output together to duplicate the behavior of the original (un-sliced) program. These splicers work in real time and incur only communications overhead. Since ``common'' computation code is duplicated in each slice, total CPU cycles among processors are wasted. <p> This is not a drawback however, because other processors could not proceed until some other processor produced needed intermediate results. The time to receive the results of the program execution is not delayed ([22] <ref> [4] </ref>). If a large program computes the value of a variable x and the code associated with this function is needed in another application, then one may slice on this variable and use the extracted program in their application. Therefore, program slicing aids one in code reusability. <p> The execution of statements [6] and [7] is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; <ref> [4] </ref>. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> The above relationship can be denoted by using the following notation: v 1 fi v 2 For the factorial program (Table 1), one can see that statement [6] is data flow dependent on statements [3], <ref> [4] </ref>, [7], and itself. Declaration edges: These edges indicate the dependences that exist between the declaration and the definition of variables in a program. <p> Declaration edges can be considered to be a special kind of data flow edge. The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement [1] and statements <ref> [4] </ref> and [6] and between statement [2] and statements [3] and [7]. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - <ref> [ 4] </ref>. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. <p> Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. [1]. i = 0; [1]. i = 0; [3]. sum = sum + Alpha (&i); [3]. Alpha (&i); <ref> [4] </ref>. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> Consider the code fragment presented in Table 3 (i) and its corresponding partial system dependence graph that is illustrated in Figure 7. [1]. i = 0; [1]. i = 0; [3]. sum = sum + Alpha (&i); [3]. Alpha (&i); <ref> [4] </ref>. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. <p> Alpha (&i); <ref> [4] </ref>. a = i; [4]. a = i; (i) (ii) Table 3. The code fragment of a program (i) and its slice (ii) at statement [4]. The function of the procedure Alpha (whose code is not shown) is to increment the pass-by-reference parameter and to return the new value of the parameter (as the return value of the pro cedure). <p> Alpha () Entry sum=sum+ Actual-Out Actual-In b = suma = i &i &i If we slice this program via the algorithm presented earlier on the statement based system dependence graph of Figure 7 at the statement a = i, we will obtain the set of statements -[1], [2] , [3], <ref> [4] </ref>-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. <p> = suma = i &i &i If we slice this program via the algorithm presented earlier on the statement based system dependence graph of Figure 7 at the statement a = i, we will obtain the set of statements -[1], [2] , [3], <ref> [4] </ref>-. Clearly, the variable a at line [4] does not depend on the variable sum in any way. Nevertheless, the entire statement [3] will be captured. <p> of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - <ref> [ 4] </ref>. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4.
Reference: [5] <author> Banning, J.P. </author> <title> ``An Efficient Way to Find the Side Effects of Procedure Calls and the Aliases of Variables''. </title> <booktitle> In Conference Record of the Sixth ACM Symposium on Principles of Programming Languages (San Antonio, Tex., </booktitle> <address> Jan. 29-31,1979). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: As an example, consider the program fragment used to calculate the factorial of the number 4 shown in Table 1. The execution of statements [6] and [7] is dependent on the control predicate at statement <ref> [5] </ref>. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; <p> The execution of statements [6] and [7] is dependent on the control predicate at statement <ref> [5] </ref>. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> The execution of statements [6] and [7] is dependent on the control predicate at statement <ref> [5] </ref>. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> It is easy to visualize that V (G P /[ 7 ] ) = -[2], [3], <ref> [5] </ref>, [7]-. 3. System Dependence Graph Our discussion now moves to slicing on a program which consists of a collection of one or more procedures and their associated parameters. To address this problem, the program dependence graph is extended to what is called a system dependence graph (SDG)[10]. <p> In this case, the presence of its actual_out node could adversely affect the precision of an interprocedural slice. A method is described in [10] to detect such a phenomena that is based on the calculation of the GMOD and GREF sets (via the method proposed in <ref> [5] </ref>) for each procedure F k . We have determined that calculating these sets is not necessary under our method since all information required for that determination is contained in the procedure's dependence graph. <p> in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - <ref> [ 5] </ref>. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program.
Reference: [6] <author> D. Callahan. </author> <title> ``The Program Summary Graph and Flow-sensitive Interprocedural Data Flow Analysis'', </title> <booktitle> In Proceedings of the SIGPLAN 1988 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta Georgia, </address> <month> June 22-24, </month> <year> 1988. </year>
Reference-contexts: As an example, consider the program fragment used to calculate the factorial of the number 4 shown in Table 1. The execution of statements <ref> [6] </ref> and [7] is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) <p> As an example, consider the program fragment used to calculate the factorial of the number 4 shown in Table 1. The execution of statements <ref> [6] </ref> and [7] is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> According to the definition of control dependence, we can conclude that statements <ref> [6] </ref> and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> The above relationship can be denoted by using the following notation: v 1 fi v 2 For the factorial program (Table 1), one can see that statement <ref> [6] </ref> is data flow dependent on statements [3], [4], [7], and itself. Declaration edges: These edges indicate the dependences that exist between the declaration and the definition of variables in a program. <p> Declaration edges can be considered to be a special kind of data flow edge. The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement [1] and statements [4] and <ref> [6] </ref> and between statement [2] and statements [3] and [7]. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - <ref> [ 6] </ref>. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. <p> for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; <ref> [ 6] </ref>. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program.
Reference: [7] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> ``The Program Dependence Graph and its Use in Optimization'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1987. </year>
Reference-contexts: As an example, consider the program fragment used to calculate the factorial of the number 4 shown in Table 1. The execution of statements [6] and <ref> [7] </ref> is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. <p> The execution of statements [6] and <ref> [7] </ref> is dependent on the control predicate at statement [5]. According to the definition of control dependence, we can conclude that statements [6] and [7] are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. <p> According to the definition of control dependence, we can conclude that statements [6] and <ref> [7] </ref> are control dependent on statement [5]. main () - [1]. int fact; [2] int n; [4]. fact = 1; [5]. while (n != 0) - [6]. fact = fact * n; [7]. n = n-1; - Table 1. A sample program. Data flow edge: If data propagate from v 1 to v 2 , then we say that v 2 is data flow dependent on v 1 ; and, a data dependence edge exists 8 . <p> The above relationship can be denoted by using the following notation: v 1 fi v 2 For the factorial program (Table 1), one can see that statement [6] is data flow dependent on statements [3], [4], <ref> [7] </ref>, and itself. Declaration edges: These edges indicate the dependences that exist between the declaration and the definition of variables in a program. <p> The above relationship can be identified by using the following notation: v 1 fi v 2 For the factorial program in Table 1, declaration edges exist between statement [1] and statements [4] and [6] and between statement [2] and statements [3] and <ref> [7] </ref>. The above discussions are summarized in Figure 1 where the program dependence graph is shown which corresponds to the factorial program of Table 1. <p> As an example, recall the factorial program of Table 1; and, assume that our goal is to find the slice at statement <ref> [7] </ref> relative to the variable n. Then, according to the program dependence graph of Figure 1 and in view of the remark above, the graph is traversed backwards starting at node [7]; and, the nodes that we encounter are ``accumulated''. <p> recall the factorial program of Table 1; and, assume that our goal is to find the slice at statement <ref> [7] </ref> relative to the variable n. Then, according to the program dependence graph of Figure 1 and in view of the remark above, the graph is traversed backwards starting at node [7]; and, the nodes that we encounter are ``accumulated''. It is easy to visualize that V (G P /[ 7 ] ) = -[2], [3], [5], [7]-. 3. <p> according to the program dependence graph of Figure 1 and in view of the remark above, the graph is traversed backwards starting at node <ref> [7] </ref>; and, the nodes that we encounter are ``accumulated''. It is easy to visualize that V (G P /[ 7 ] ) = -[2], [3], [5], [7]-. 3. System Dependence Graph Our discussion now moves to slicing on a program which consists of a collection of one or more procedures and their associated parameters. To address this problem, the program dependence graph is extended to what is called a system dependence graph (SDG)[10]. <p> In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; <ref> [ 7] </ref>. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. <p> 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - <ref> [ 7] </ref>. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program. We begin by first building a parse tree representation with the edges corresponding to control flow edges. <p> Methods for more precise interprocedural slicing have been developed by Horwitz [8] where parameters are passed by value-result. This is an extension of the program dependence graph presented in <ref> [7] </ref>. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependence edges.
Reference: [8] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <booktitle> in Proceedings of the 15th ACM Symposium of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <address> N. York. </address>
Reference-contexts: Furthermore, the concepts of slicing have been used in integrating program variants <ref> [8] </ref>. But as was pointed out in [17], the internal program representation (IPR) chosen plays a critical role in the software development environment. An IPR is one in which a number of software engineering tasks can be performed such as those mentioned earlier. <p> variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - <ref> [ 8] </ref>. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. <p> (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; <ref> [ 8] </ref>. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program. We begin by first building a parse tree representation with the edges corresponding to control flow edges. <p> The first procedure to be encountered is main; therefore, we descend into it and begin to solve it. In general, each statement is processed in a top-down, left-to-right fashion with the contents of the looping statements being processed twice. Upon encountering the call to procedure CalcSum at statement <ref> [8] </ref>, calculation of the dependences of main yields the two data dependencies ( (i = 0 ) fi dd (while (i &lt; 10 ) ) ) and ( (i = 0 ) fi dd as illustrated in Figure 9 13 . <p> As far as we know, no other operational slicers have been built. In addition, Weiser's method does not produce an optimum slice across procedure calls because it cannot keep track of the calling context of a called procedure. Methods for more precise interprocedural slicing have been developed by Horwitz <ref> [8] </ref> where parameters are passed by value-result. This is an extension of the program dependence graph presented in [7]. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependence edges.
Reference: [9] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1989. </year> <month> - 24 </month> - 
Reference-contexts: [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; <ref> [ 9] </ref>. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. <p> *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); <ref> [ 9] </ref>. - [11]. sum = sum; Table 4. An example program. We begin by first building a parse tree representation with the edges corresponding to control flow edges. The first procedure to be encountered is main; therefore, we descend into it and begin to solve it.
Reference: [10] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> ``Interprocedural Slicing Using Dependence Graphs'', </title> <journal> ACM TOPLAS, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Weiser's slicers were based on a flow-graph representation of programs. Ottenstein et al. [17] showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program that they refer to as the program dependence graph (PDG). Horwitz et al. <ref> [10] </ref> have introduced algorithms to construct interprocedural slices by extending the program dependence graph to a supergraph of the PDG which is referred to as the system dependence graph (SDG). This extension also captures the calling context of the procedures, which was lacking in the method proposed by Weiser. <p> We have implemented tools such as a slicer, a dicer, and a ripple analyzer that utilize this SDG. In addition, we are exploring using this SDG in some of the software engineering activities discussed above. To accomplish this task, we had to ``expand'' the language described in <ref> [10] </ref>, modify the SDG, and modify the algorithms presented. In particular, the SDG described in [10] models a language that consists of a single (main) program and supports scalar variables, assignment statements, conditional statements, and while loops. <p> In addition, we are exploring using this SDG in some of the software engineering activities discussed above. To accomplish this task, we had to ``expand'' the language described in <ref> [10] </ref>, modify the SDG, and modify the algorithms presented. In particular, the SDG described in [10] models a language that consists of a single (main) program and supports scalar variables, assignment statements, conditional statements, and while loops. Additionally, this language consists of a collection of procedures where parameters are passed by value-result, there exist no variable declarations, and procedures that end with return statements. <p> This allows slicing to be more precise than if the "resolution" of the SDG was only at the statement level. In section 6 we present a new method to build the SDG that differs from the one suggested in <ref> [10] </ref>. Specifically, our method eliminates the need for computing the GMOD and GREF sets of each procedure in the system as well as the construction of a linkage grammar and its corresponding subordinate characteristic graphs of the linkage grammar's nonterminals. As described by [10], a linkage grammar consisting of one nonterminal <p> that differs from the one suggested in <ref> [10] </ref>. Specifically, our method eliminates the need for computing the GMOD and GREF sets of each procedure in the system as well as the construction of a linkage grammar and its corresponding subordinate characteristic graphs of the linkage grammar's nonterminals. As described by [10], a linkage grammar consisting of one nonterminal and one production must be constructed for each procedure. The attributes in the linkage grammar correspond to the parameters in the procedures. This attribute grammar is the input to an algorithm that is a slight modification of the algorithm described in [12]. <p> The definition of a static slice that will be employed in the sequence is the same as the one given in <ref> [10] </ref> which is less general than the one proposed by Weiser but which does capture the ``spirit'' of the slice. <p> Edges represent several kinds of dependences among the nodes which can be distinguished by the label attached to them. Specifically, three dependences are distinguished 7 control dependence, data flow dependence, and declaration dependence, the first two types of which are those suggested in <ref> [10] </ref> and [17]; each is briefly discussed below. Control dependence edge: Let v 1 and v 2 be two nodes of G P . <p> We will defer discussion of this edge to the next section. 8 In <ref> [10] </ref>, a distinction is made between loop-carried and loop-independent dependence edges. This dis - 5 - on v 1 , then the value computed by program P will be different if the positions of statements v 1 and v 2 are reversed. <p> a_out l, j F k is isomorphic to f _out l F k Finally, by definition all such nodes are control dependent on the entry node; in symbols: " j "k "v ( f _in i f _out l ) fi (en F k cd ________________ 9 Note that in <ref> [10] </ref>, the number of actual-out nodes is equal to the number of actual-in parameters to facili tate the calling mechanism. - 7 - 3.2. The edges At this point, we present additional types of edges that enable us to build the system dependence graph. <p> int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; <ref> [10] </ref>. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. <p> In this case, the presence of its actual_out node could adversely affect the precision of an interprocedural slice. A method is described in <ref> [10] </ref> to detect such a phenomena that is based on the calculation of the GMOD and GREF sets (via the method proposed in [5]) for each procedure F k . <p> Slicing Inaccuracies Due to System Dependency Graph Representation In this section, we will describe a new method that yields ``smaller'' slices than those contributed by the method proposed in <ref> [10] </ref>. In particular, we will show via an example that slices could usually be larger than necessary; and, then we present our method. <p> We will say that the procedure has been summarized, if and only if, all summary dependences have been calculated. On the other hand, determination of the summary information of F k requires that the procedure has been solved. The method that is proposed in <ref> [10] </ref> for the calculation of the transitive dependences distinguishes between grammars that do not support recursion and those that do. In the former case, the solution proposed is via the use of a separate copy of a procedure dependence graph for each call-site. <p> We note here that the possible number of alias configurations for a procedure with n passed by reference parameters is 2 n - n. 8. The Interprocedural Slicing Algorithm The interprocedural slicing algorithm is based on the algorithm suggested in <ref> [10] </ref>. Modification are necessary given the additional constructs introduced in the grammar. The algorithm finds the slice relative to a node s 0 of a program G P in two phases. <p> Then the slice is given by i = 1 m slice at s 0 m 9. Dependency Calculation of Unknown Procedures As stated in <ref> [10] </ref>, one of the advantages of using the SDG is that slicing can be done even if the body of a procedure is unknown, e.g., library procedures or not-yet-written procedures. <p> Our method treats these as a single type of edge -- the data flow edge -- which simplifies the construction of the program dependence graph. Our method of calculating interprocedural dependences does not use linkage grammar as used in Horwitz's algorithm <ref> [10] </ref>. Our algorithm is conceptually much simpler. The linkage grammar utilized by Horwitz includes one nonterminal and one production for each procedure in the system.
Reference: [11] <author> J.C. Hwang, M.W. Du, C.R. Chou. </author> <title> ``Finding Program Slices for Recursive Procedures'', </title> <booktitle> In Proceedings of the IEEE COMPSAC 88, IEEE Computer Society, </booktitle> <year> 1988. </year>
Reference-contexts: Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () <ref> [11] </ref>. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; <p> An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements <ref> [11] </ref>, [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - <ref> [11] </ref>. sum = sum; Table 4. An example program. We begin by first building a parse tree representation with the edges corresponding to control flow edges. The first procedure to be encountered is main; therefore, we descend into it and begin to solve it. <p> In contrast, a static slice is independent of test data. A dynamic slice can be considered to be a subset of a static slice. A technique for handling slices for recursive procedures has been suggested by Hwang <ref> [11] </ref> which constructs a sequence of slices of the system - where each slice of the sequence essentially permits only one additional level of recursion - until a fixed point is reached. Moreover, this algorithm solves only self-recursive procedures and has no mechanism for handling mutually recursive procedures. 12.
Reference: [12] <author> Kastens, U. </author> <title> ``Ordered Attribute Grammars''. </title> <journal> Acta Inf. </journal> <volume> 13,3, </volume> <year> 1980. </year>
Reference-contexts: The attributes in the linkage grammar correspond to the parameters in the procedures. This attribute grammar is the input to an algorithm that is a slight modification of the algorithm described in <ref> [12] </ref>. The algorithm requires the construction of an auxiliary graph which expresses the dependences among the attributes of a production's nonterminal occurrences. Presently, we have implemented the algorithms that are proposed here as part of our Ghinsu tool. <p> Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - <ref> [12] </ref>. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2.
Reference: [13] <author> B.W. Kernigham, and D. M. Ritchie. </author> <title> ``The C Programming (ANSI C) Language'', </title> <booktitle> 2nd. </booktitle> <address> Edition, </address> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs,NJ. </address>
Reference-contexts: An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], <ref> [13] </ref>, [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> We will now give an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () <ref> [13] </ref>. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i
Reference: [14] <author> H.K.N. Leung, and H.K. Reghbati. </author> <title> ``Comments on Program Slicing'', </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. se-13 no. 12, </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: Consider the program presented in Table 2 and consisting of the functions main and func. Statement [18] in Table 2 will be executed, if and only if, the return statement at line [16] is not executed. Therefore, statement [18] is control dependent on statement <ref> [14] </ref> (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ <p> [18] is control dependent on statement <ref> [14] </ref> (the return statement's control predicate). In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. <p> An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], <ref> [14] </ref>, [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement <ref> [14] </ref>. The above discussion suggests that two new types of edges are needed to properly handle return statements. The return-control edge is an intraprocedural edge and the return-link is an interprocedural edge. Both are described below. <p> now give an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - <ref> [14] </ref>. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum
Reference: [15] <author> J.R. Lyle, and M. Weiser. </author> <title> ``Experiments in Slicing-based Debugging Aids'', </title> <editor> In Elliot Solo-way and Sitharama Iyengar, editors, </editor> <title> Empirical Studies of Programmers, </title> <publisher> Ablex Publishing Corporation, </publisher> <address> Norwood, New Jersey, </address> <year> 1986. </year>
Reference-contexts: Statement [18] in Table 2 will be executed, if and only if, the return statement at line [16] is not executed. Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). In addition, the definition of variable c at line <ref> [15] </ref> cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. <p> An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement <ref> [15] </ref> must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement <ref> [15] </ref> must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement [14]. <p> Since the procedure CalcSum has not been summarized, we begin to solve it. Solution of CalcSum is suspended immediately after the formal-in node corresponding to s is encountered, due to the call to Inc at statement <ref> [15] </ref>. At this point, Inc has not been summarized; therefore, we descend into it and begin to solve it. Since Inc is a terminal procedure (terminal in the sense that it makes no further calls), it is solved.
Reference: [16] <author> J.R. Lyle, and M. Weiser. </author> <title> ``Automatic Program Bug Location by Program Slicing'', </title> <booktitle> In Proccedings of the 2nd International Conference on Computers and Applications, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: In addition, if at the statement in question, the value of another variable, w, is computed correctly, then we may employ a method that was suggested in <ref> [16] </ref> and is referred to as dicing: the bug is likely to be associated with one or more statements in a set referred to as the Fault Prone Statement Set (FPSS). <p> Consider the program presented in Table 2 and consisting of the functions main and func. Statement [18] in Table 2 will be executed, if and only if, the return statement at line <ref> [16] </ref> is not executed. Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). <p> In addition, the definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; <ref> [16] </ref>. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. <p> An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], <ref> [16] </ref>- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making <p> Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], <ref> [16] </ref>- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement [14]. The above discussion suggests that two new types of edges are needed to properly handle return statements. <p> The above relationship can be defined as follows: rc fi (v s fi v rn ) A return-control edge can be considered to be a special kind of control dependence edge. As an example, notice that if the return statement at <ref> [16] </ref> is executed, then neither statement [18] or [19] will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> As an example, notice that if the return statement at <ref> [16] </ref> is executed, then neither statement [18] or [19] will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> Specifically, "v rn G F k " j (v rn fi cs j ) In the program of Table 2 there are two return-link edges incident to the call-site node corresponding to the function func and incident from the nodes corresponding to the return statements <ref> [16] </ref> and [19], respectively. <p> our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; <ref> [16] </ref>. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program. <p> Ripple Analyzer: A ripple analyzer can be thought of as a ``forward'' slicer. It finds all the statements that are dependent upon any given statement. This can be used to visualize the statements that will be affected by a change made at a given statement. Dicer: Dicing proposed in <ref> [16] </ref> is used in conjunction with the slicer to implement a kind of automatic bug location. This powerful heuristic can further reduce the amount of code upon which the programmer must concentrate. <p> (an incorrectly computed) a variable at a particular statement, there exists another variable that is computed correctly, then the dicing heuristic may be employed: the bug is likely to be associated with the slice on the incorrectly computed variable minus those associated with the slice on the correctly computed variable <ref> [16] </ref>. Dicing can be used iteratively to locate a program bug. Graphical Interface. After the Ghinsu tool has been invoked, the user may invoke any of the tool's modules as follows. First she/he should open the file that contains the desired program via the open button.
Reference: [17] <author> K.J. Ottenstein, and L.M. Ottenstein. </author> <title> ``The Program Dependence Graph in a Software Development Environment'', </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> Pa., </address> <month> April 23-25, </month> <year> 1984). </year> <journal> ACM SIGPLAN Notices 19,5, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: Ripple analysis is used to identify the statements that will be affected when a change is to be made at a given statement. To word it differently, ripple analysis is ``forward'' slicing. Weiser's slicers were based on a flow-graph representation of programs. Ottenstein et al. <ref> [17] </ref> showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program that they refer to as the program dependence graph (PDG). <p> Furthermore, the concepts of slicing have been used in integrating program variants [8]. But as was pointed out in <ref> [17] </ref>, the internal program representation (IPR) chosen plays a critical role in the software development environment. An IPR is one in which a number of software engineering tasks can be performed such as those mentioned earlier. <p> Edges represent several kinds of dependences among the nodes which can be distinguished by the label attached to them. Specifically, three dependences are distinguished 7 control dependence, data flow dependence, and declaration dependence, the first two types of which are those suggested in [10] and <ref> [17] </ref>; each is briefly discussed below. Control dependence edge: Let v 1 and v 2 be two nodes of G P . <p> Having defined the program dependence graph, we are now in a position to define the slice of a program with respect to a variable in a statement for a single-procedure program such as defined in <ref> [17] </ref>. Specifically, if G P is a program dependence graph and s 0 is a node in G P , then the ________________ tinction is not made here. <p> definition of variable c at line [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; <ref> [17] </ref>. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. <p> the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; <ref> [17] </ref>. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program.
Reference: [18] <author> T. Reps, and W. Yang. </author> <title> ``The Semantics of Program Slicing'', </title> <institution> TR-777, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Consider the program presented in Table 2 and consisting of the functions main and func. Statement <ref> [18] </ref> in Table 2 will be executed, if and only if, the return statement at line [16] is not executed. Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). <p> Consider the program presented in Table 2 and consisting of the functions main and func. Statement <ref> [18] </ref> in Table 2 will be executed, if and only if, the return statement at line [16] is not executed. Therefore, statement [18] is control dependent on statement [14] (the return statement's control predicate). <p> [15] cannot reach - 8 - [ 1]. int main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); <ref> [18] </ref>. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and <p> - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); <ref> [18] </ref>. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); <ref> [18] </ref>. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. <p> An example program. statement <ref> [18] </ref> because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] <p> An example program. statement <ref> [18] </ref> because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement [14]. <p> statement <ref> [18] </ref> because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement [14]. <p> <ref> [18] </ref>. Statement [15] must not be included in the slice. If control reaches statement [18], statement [15] cannot affect statement [18]. We include statement [16] in the slice as an aid to the user; the intent is to point out that the return statement is directly responsible for making statement [18] control dependent on statement [14]. The above discussion suggests that two new types of edges are needed to properly handle return statements. The return-control edge is an intraprocedural edge and the return-link is an interprocedural edge. Both are described below. <p> The above relationship can be defined as follows: rc fi (v s fi v rn ) A return-control edge can be considered to be a special kind of control dependence edge. As an example, notice that if the return statement at [16] is executed, then neither statement <ref> [18] </ref> or [19] will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> As an example, notice that if the return statement at [16] is executed, then neither statement <ref> [18] </ref> or [19] will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - <ref> [18] </ref>. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program. We begin by first building a parse tree representation with the edges corresponding to control flow edges.
Reference: [19] <author> T. Reps, and T. Bricker. </author> <title> ``Illustrating Interference in Interfering Versions of Programs'', </title> <institution> TR-827, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: main () [11]. int func (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; <ref> [19] </ref>. return a; [10]. - [20]. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. <p> The above relationship can be defined as follows: rc fi (v s fi v rn ) A return-control edge can be considered to be a special kind of control dependence edge. As an example, notice that if the return statement at [16] is executed, then neither statement [18] or <ref> [19] </ref> will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> As an example, notice that if the return statement at [16] is executed, then neither statement [18] or <ref> [19] </ref> will be executed. Hence, we have a return-control edge connecting statement [16] with both statements [18] and [19]. A return-link edge connects a return node to the corresponding function call-site. <p> Specifically, "v rn G F k " j (v rn fi cs j ) In the program of Table 2 there are two return-link edges incident to the call-site node corresponding to the function func and incident from the nodes corresponding to the return statements [16] and <ref> [19] </ref>, respectively. <p> We will now give an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) <ref> [19] </ref>. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum
Reference: [20] <author> M. Weiser. </author> <title> ``Program Slicing'', </title> <booktitle> In Proceedings of the Fifth International Conference on Software Engineering, </booktitle> <address> San Diego, CA, </address> <month> March </month> <year> 1981. </year>
Reference-contexts: (int a, int b, int c) [ 2]. - [12]. - [ 4]. int x; [14]. if (c == 4) - [ 6]. x=4; [16]. return c; [ 7]. y=6; [17]. - [ 8]. sum=func (x,y,4); [18]. a = a + c; [ 9]. sum=sum+1; [19]. return a; [10]. - <ref> [20] </ref>. - Table 2. An example program. statement [18] because, the return statement kills all reaching definitions in its path. Moreover, observe that the intraprocedural slice at statement [18] should contain statements [11], [13], [14], [16]- and [18]. Statement [15] must not be included in the slice. <p> an example of how we built our System Dependence Graph by considering the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - <ref> [20] </ref>. - [ 4]. int i; [16]. s = s + 9; [22]. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum;
Reference: [21] <author> M. Weiser. </author> <title> ``Programmers Use Slices When Debugging'', </title> <note> CACM July 1982. </note>
Reference-contexts: 1. Introduction Weiser in <ref> [21] </ref> gave the following definition. Let P be a program, let p be a statement in P, and let V be a subset of the variables of P. <p> debugging is a process where programmers try to better understand code in order to find and eliminate bugs, and since programmers do abstract slices when debugging, it is logical that a tool which would automatically create program slices would be useful not only in debugging but also in code understanding <ref> [21] </ref>. Slicing provides a meaningful way to decompose a large program into smaller, independent components. In addition to debugging and code understanding, program slices can also aid in a number of software engineering activities, some of which are briefly discussed below.
Reference: [22] <author> M. Weiser. </author> <title> ``Program Slicing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> July </month> <year> 1984. </year>
Reference-contexts: the program in Table 4 and following the general algorithm for calculating interprocedural dependences presented in Table 5. [ 1]. void main () [13]. int CalcSum (int s) [19]. void Inc (int *x) [ 2]. - [14]. - [20]. - [ 4]. int i; [16]. s = s + 9; <ref> [22] </ref>. - [ 5]. i = 0; [17]. return s; [ 6]. while (i &lt; 10) - [18]. - [ 7]. i = i + 1; [ 8]. sum = CalcSum (sum); [ 9]. - [11]. sum = sum; Table 4. An example program. <p> The results of the action are reflected on the display by traversing the SDG and highlighting the source corresponding to the nodes that are marked (e.g., in the slice). Again this mapping is accomplished by a simple line/column comparison. 11. Related Work Weiser <ref> [22] </ref> has built slicers for FORTRAN and an abstract data language called Simple-D. His slices were based on flow-graph representation of programs. As far as we know, no other operational slicers have been built.
Reference: [23] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> ``Detecting Program Components With Equivalent Behaviors'', </title> <institution> TR-840, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1989. </year>
References-found: 23

