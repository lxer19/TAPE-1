URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-26.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: fosorio,bharatg@cs.buffalo.edu  
Phone: Telephone: (716) 645-3194  
Title: Subset Assertions and Negation-As-Failure  
Author: Mauricio Osorio Bharat Jayaraman 
Keyword: Subset Assertions, Transitive Closures, Memoization, Negation-As-Failure, Stratified Semantics, Well-Founded Semantics  
Address: Buffalo, NY 14260  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: Subset assertions provide a declarative and natural means for expressing solutions to many problems involving sets. This paper is motivated by the use of subset assertions for formulating transitive closures and solving containment constraints in applications of graph traversal and program analysis. In these applications, circular containment constraints may arise, for which we propose an operational strategy based upon memoization and reexecution of function calls. We provide formal declarative and operational semantics for this class of subset assertions. One of the main technical results of this paper is a succinct translation of subset assertions into normal program clauses [L87] such that the stratified semantics of the resulting normal programs coincides with the declarative semantics of subset assertions. This translation is interesting because the operational semantics of subset assertions appears to be very different from that of normal programs|due to the setof-like capability and the need of reexecution for subset assertions, both of which are absent in normal program clauses. (However this translation is not an acceptable implementation of subset assertions due to its inefficiency.) We also discuss the connection between our proposed declarative semantics and recent approaches such as stable and well-founded semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [ABW88] <author> Apt,K., Blair, H., and Walker, A. </author> <title> "Toward a theory of declarative knowledge," </title> <booktitle> Proc. of the Workshop on Foundations of Deductive Database and Logic Programming (1988) p. </booktitle> <pages> 89-148. </pages>
Reference-contexts: a program P , we define ext (P ) := S f2 head (P ) ext (f ) Definition: Given P , we define extension (P ) := P [ ext (P ). 4.2 Stratified Semantics We assume that the reader is familiar with the definition of the Stratified Semantics <ref> [ABW88] </ref> (abbreviated here as SS). We assume that the SS has been extended to deal with our set constructor.
Reference: [AU77] <author> A. Aho and J.D. Ullman, </author> <title> "Principles of Compiler Design," </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: For a more realistic example, consider the formulation of the reaching definitions in a program flow graph, which is computed by a compiler during its optimization phase <ref> [AU77] </ref>: closure in, out, allout out (B) in (B) - kill (B) out (B) gen (B) in (B) allout (pred (B)) allout (fP n g) out (P) where kill (B), gen (B), and pred (B) are predefined set-valued functions specifying the relevant information for a given program flow graph and basic
Reference: [BN*87] <author> C. Beeri, S. Naqvi, et al, </author> <title> "Sets and Negation in a Logic Database Language (LDL1)," </title> <booktitle> Proc. 6th ACM PODS, </booktitle> <pages> pp. 21-37, </pages> <year> 1987. </year>
Reference-contexts: This suggests that an extension of the well founded semantics to allow function definitions should agree with our intended model. 6. Related Work and Further Extensions A variety of approaches to sets have been proposed for logic programming languages <ref> [JP87, BN*87, CW92, DOPR91, J92, K90] </ref>. The goal of this paper was not to resolve the relative merits of various approaches; rather, our goal was to clarify the connections between subset assertions and semantics of negation, especially stratified semantics and well-founded semantics. <p> In this paper we discuss a paradigm of functional programming where memo tables are needed for semantic reasons. In comparison with logic programming languages supporting sets, especially LDL <ref> [BN*87] </ref>, an interesting aspect of our work is that our proposed construct is amenable to a simple least model semantics, by taking intersection of sets, as defined by u. Furthermore, we have a more liberal definition of stratification.
Reference: [CW92] <author> W. Chen and D.S. Warren, </author> <title> "An Intensional Logic for (Multi-Arity) Set Abstraction," </title> <booktitle> Proc. 8th ICLP, </booktitle> <pages> pp. 97-110, </pages> <address> Paris, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: This suggests that an extension of the well founded semantics to allow function definitions should agree with our intended model. 6. Related Work and Further Extensions A variety of approaches to sets have been proposed for logic programming languages <ref> [JP87, BN*87, CW92, DOPR91, J92, K90] </ref>. The goal of this paper was not to resolve the relative merits of various approaches; rather, our goal was to clarify the connections between subset assertions and semantics of negation, especially stratified semantics and well-founded semantics.
Reference: [DOPR91] <author> Dovier, A., Omodeo, E. G., Pontelli, E., and Rossi, G. "flogg: </author> <title> A Logic Programming Language with Finite Sets," </title> <booktitle> Proc. 8th ICLP, </booktitle> <pages> pp. 111-124, </pages> <address> Paris, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: This suggests that an extension of the well founded semantics to allow function definitions should agree with our intended model. 6. Related Work and Further Extensions A variety of approaches to sets have been proposed for logic programming languages <ref> [JP87, BN*87, CW92, DOPR91, J92, K90] </ref>. The goal of this paper was not to resolve the relative merits of various approaches; rather, our goal was to clarify the connections between subset assertions and semantics of negation, especially stratified semantics and well-founded semantics. <p> Furthermore, we have a more liberal definition of stratification. These in turn are due to the fact that our language is essentially a functional language. Further comparisons with LDL are in the paper [JP89]. Our set constructors resemble those of <ref> [DOPR91] </ref>, but can be traced back to those in [JP87, JP89]. Quantifiers over sets are discussed in [K90, DOPR91], a feature that is not explicitly found in our language. <p> These in turn are due to the fact that our language is essentially a functional language. Further comparisons with LDL are in the paper [JP89]. Our set constructors resemble those of [DOPR91], but can be traced back to those in [JP87, JP89]. Quantifiers over sets are discussed in <ref> [K90, DOPR91] </ref>, a feature that is not explicitly found in our language. Finally, our translation of subset assertions into normal program clauses [L87] in fact suggests a way of providing the semantics of the setof construct in logic programming languages.
Reference: [FWW76] <author> D. Friedman, D. Wise, and M. Wand, </author> <title> "Recursive Programming Through Table Look-up," </title> <booktitle> Proc. Symp. on Symbolic and Algebraic Computation, </booktitle> <pages> pp. 85-89, </pages> <year> 1976. </year>
Reference-contexts: This idea was first put forward in [M68], by Michie, who called such functions memo functions. This idea was later elaborated in <ref> [FWW76, KS81, H85] </ref>. In all these cases, memo tables are proposed in order to gain performance improvements; the semantics of the underlying language is unaffected by memoization. In this paper we discuss a paradigm of functional programming where memo tables are needed for semantic reasons.
Reference: [GL88] <author> M. Gelfond and V. Lifschitz, </author> <title> "The Stable Model Semantics for Logic Programming," </title> <booktitle> Proc. 5th ICLP, </booktitle> <pages> pp. 1070-1080, </pages> <address> Seattle, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The other major technical result of this paper is a soundness proof for our proposed operational strategy. Finally, we also discuss the connections between the semantics of subset assertions and recent approaches, such as stable models and well-founded models <ref> [GL88, VRS91] </ref>. <p> We denote this extended program by extension (P ). Note that, in this case, extension (P ) is a non-stratified normal program and that the Stable Model Semantics <ref> [GL88] </ref> as well as the Well Founded Semantics [VRS91] define our intended model. Unfortunately, the above extension fails to capture our intended model if we add even the assertion edge (3) f2g to our program P . <p> Observe that now our intended model M for extension (P ) is not a stable set since reach = (1; f1; 2g) is not in the minimal Herbrand model of the Gelfond-Lifschitz Transformation of P with respect to M <ref> [GL88] </ref>. Moreover extension (P ) has no well founded total model. Essentially the problem arises due to the loop introduced into the graph by the definition of the predicate edge .
Reference: [H85] <author> R.J.M. Hughes, </author> <title> "Lazy Memo Functions," </title> <booktitle> Proc. Second FPCA, </booktitle> <address> Nancy, </address> <month> Sept. </month> <year> 1985, </year> <pages> pp. 129-146. </pages>
Reference-contexts: This idea was first put forward in [M68], by Michie, who called such functions memo functions. This idea was later elaborated in <ref> [FWW76, KS81, H85] </ref>. In all these cases, memo tables are proposed in order to gain performance improvements; the semantics of the underlying language is unaffected by memoization. In this paper we discuss a paradigm of functional programming where memo tables are needed for semantic reasons.
Reference: [H92] <author> Heintze, N., </author> <title> "Practical Aspects of Set Based Analysis," </title> <booktitle> Proc. JICSLP 92, </booktitle> <pages> pp. 735-749, </pages> <address> Wash-ington DC, </address> <year> 1992. </year>
Reference: [J91] <author> B. Jayaraman, </author> <title> "the SuRE Programming Framework," </title> <institution> Dept. of Computer Science TR 91-011, SUNY-Buffalo, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: We note that our proposed language described in this paper is essentially a functional language, although its extension to accomodate logic programming features are discussed in <ref> [JP89, J91] </ref>. The traditional need for memo tables in implementations of functional languages has been to avoid unnecessary computation, by detecting when a function call with identical arguments has been earlier computed. This idea was first put forward in [M68], by Michie, who called such functions memo functions.
Reference: [J92] <author> B. Jayaraman, </author> <title> "Implementation of Subset-Equational Programs," </title> <journal> JLP, </journal> <volume> 11(4) </volume> <pages> 299-324. </pages>
Reference-contexts: This basic paradigm of subset assertions offers a declarative and succinct means of formulating many set-valued functions, and has been explicated in <ref> [JP89, J92] </ref>. The motivation for this paper stems from certain natural uses of subset assertions in applications such as graph theory, program analysis, etc. In these applications, one is interested in finding the smallest set that satisfies certain containment constraints. Such problems can be modelled quite directly using subset assertions. <p> The function distr expects a set of lists as its second argument; its result is a set whose elements are constructed by "consing" its first argument to each list in the set denoted by the second argument. The reader is referred to <ref> [JP89, J92] </ref> for more examples. 2.2 Memoization One of the more interesting uses of subset assertions is in defining transitive closures. This use reveals the need for an operational semantics with memoization [M63, W92]. <p> This suggests that an extension of the well founded semantics to allow function definitions should agree with our intended model. 6. Related Work and Further Extensions A variety of approaches to sets have been proposed for logic programming languages <ref> [JP87, BN*87, CW92, DOPR91, J92, K90] </ref>. The goal of this paper was not to resolve the relative merits of various approaches; rather, our goal was to clarify the connections between subset assertions and semantics of negation, especially stratified semantics and well-founded semantics.
Reference: [JP87] <author> Jayaraman, B. and Plaisted, D. A., </author> <booktitle> Proc. Third Intl. FPCA, </booktitle> <address> Portland, OR, </address> <month> September </month> <year> 1987, </year> <pages> pp. 194-210, </pages> <publisher> Springer-Verlag. </publisher> <pages> 13 </pages>
Reference-contexts: This suggests that an extension of the well founded semantics to allow function definitions should agree with our intended model. 6. Related Work and Further Extensions A variety of approaches to sets have been proposed for logic programming languages <ref> [JP87, BN*87, CW92, DOPR91, J92, K90] </ref>. The goal of this paper was not to resolve the relative merits of various approaches; rather, our goal was to clarify the connections between subset assertions and semantics of negation, especially stratified semantics and well-founded semantics. <p> Furthermore, we have a more liberal definition of stratification. These in turn are due to the fact that our language is essentially a functional language. Further comparisons with LDL are in the paper [JP89]. Our set constructors resemble those of [DOPR91], but can be traced back to those in <ref> [JP87, JP89] </ref>. Quantifiers over sets are discussed in [K90, DOPR91], a feature that is not explicitly found in our language. Finally, our translation of subset assertions into normal program clauses [L87] in fact suggests a way of providing the semantics of the setof construct in logic programming languages.
References-found: 12

