URL: http://www.cs.rice.edu/CS/PLT/packages/zodiac/zodiac.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/packages/zodiac/
Root-URL: 
Title: Zodiac: A Framework for Building Interactive Programming Tools  
Author: Shriram Krishnamurthi 
Keyword: Interactive programming environments, program transformation.  
Note: Draft Version  Please do not distribute! Summary  
Address: Houston, TX 77005-1892, USA  
Affiliation: Dept. of Computer Science Rice University  
Email: shriram@cs.rice.edu  
Date: March 8, 1996  
Abstract: Programming environments should provide information in terms of the source program. For instance, when a run-time error occurs, the environment should notify the programmer by pointing to the location of the error in the program source. Environments should also be able to incorporate additional tools for analyzing programs and monitoring their execution, and offer interaction facilities to these tools. This paper describes Zodiac, which supports the development of interactive programming environments. Zodiac consists of a modular front-end to Scheme, including a scanner, reader, parser and macro expander, that records the source location of tokens; routines for communicating between Scheme and a variety of user-interface tools such as editors; and generic user interfaces in those tools. Thus, it abstracts over the components of interactive visual programming environments. We outline the construction of two environment components using Zodiac: a debugger that traps run-time errors and informs the user of the source location of their occurrence, and a profiler that provides statistical information on the time spent executing various parts of the program. We are in the process of building additional interfaces and tools for our Scheme environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Appel, A., Duba, B., and MacQueen, D. </author> <title> Profiling in the presence of optimization and garbage collection. </title> <institution> CS-TR-197-88, Princeton University, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: Since Emacs is extensible, it is in principle feasible to build interactive tools based on it. However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers <ref> [1, 13] </ref>, binding environment browsers [2, 10, 4] and evaluation steppers [12, 17]. <p> The entire system was implemented in one day by a single programmer. In contrast, a previous by-hand implementation took several weeks to write, was less robust and provided less functionality. 4.2 Execution Profiler This section presents the construction of a rudimentary execution profiler similar to the system described in <ref> [1] </ref>. It illustrates the use of back-pointers. The profiler stores frequency and duration information in the back-pointer, which the interface extracts upon request from the user and presents in a suitable manner. The value stored in the back-pointer is a pair, consisting of the call-count and the interrupt-count. <p> The Zodiac-based applications described above also perform efficiently. Preliminary experiments indicate that the overhead introduced by the debugger is considerably lower than the figures reported for PSD [9]. Similarly, the profiler performs comparably to the system implemented for SML <ref> [1] </ref>. In addition, several sources of potential improvement have been identified in the implementation of Zodiac and of the applications. 7 Conclusions In summary, Zodiac is a modular, composable, efficient tool for building interactive programming applications.
Reference: [2] <author> Cadence Research Systems. </author> <title> Chez Scheme Reference Manual. </title> <institution> Bloomington, Indiana, </institution> <year> 1994. </year> <month> 11 </month>
Reference-contexts: However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers [1, 13], binding environment browsers <ref> [2, 10, 4] </ref> and evaluation steppers [12, 17]. <p> For instance, the user of an execution profiler might wish to determine how frequently 1 The actual syntax accepted is that of Chez Scheme <ref> [2] </ref>.
Reference: [3] <editor> Clinger, W., and Rees, J. (eds). </editor> <title> The revised 4 report on the algorithmic language Scheme. </title> <booktitle> ACM Lisp Pointers 4, </booktitle> <month> 3 (July </month> <year> 1991). </year>
Reference-contexts: The first carries banner lines, prompts and other text sent to Scheme's output port. The application uses the second to communicate with the interface. Zodiac currently uses fifos (or "named pipes"), since these require the least extension to Scheme <ref> [3] </ref>, and do not require polling. 2 Since the interface is treated as an abstract entity, Zodiac provides routines for Scheme to mar-shall the arguments sent by the application into a message, and for the interface tool to destructure these messages.
Reference: [4] <author> Eisenberg, M. Bochser: </author> <title> an integrated Scheme programming system. </title> <type> Technical Report 349, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> October </month> <year> 1985. </year>
Reference-contexts: However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers [1, 13], binding environment browsers <ref> [2, 10, 4] </ref> and evaluation steppers [12, 17].
Reference: [5] <author> Flanagan, C., Flatt, M., Shriram, K., Weirich, S., and Felleisen, M. </author> <title> Catching Bugs in the Web of Program Invariants. </title> <note> To appear in PLDI '96. </note>
Reference-contexts: In general, interpreting the output might require knowledge of the innards of the tool. Hence, the output can be hard to understand and use. In recognition of these problems, visual programming environments have become increasingly common. For example, in MrSpidey <ref> [5] </ref>, the programmer selects expressions using a visual interface and the environment displays the set of run-time values that expression can assume. To produce such systems, it is necessary to map internal representations to their corresponding source locations, and to provide appropriate facilities for communicating with the user. <p> Zodiac provides the expander and parser as separate procedures since some tools might require only one procedure and not the other, such as a compiler front-end that already has a fixed abstract syntax, or an analysis tool that parses and converts the program into a special form <ref> [5] </ref>. After any of these phases from the reader onward, the application may invoke a procedure that strips the annotated expression of all its source location information, and converts it into a regular S-expression. <p> Its front-end components have been integrated into the MzScheme compiler [6]. It has also been combined with an implementation of set-based program analysis to construct a powerful static program debugging and optimization tool <ref> [5] </ref>. In addition, Zodiac provides a framework for combining programming tools. For instance, the debugger and profiler both generate abstract syntax, which is also the language they process. Hence, the output from one can be fed to the other.
Reference: [6] <author> Flatt, M. MrEd: </author> <title> An engine for portable graphical user interfaces. </title> <institution> CS-TR-96-258, Rice University, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The application and the interface need to exchange commands and data. Zodiac simplifies the former and handles the latter. It provides routines for communicating with any interface tool that meets certain desiderata, and it provides user interfaces in tools such as Emacs [16] and MrEd <ref> [6] </ref>. 3.3.1 Interface Protocol Zodiac allows the interface and Scheme to execute in separate processes. For simplicity, this description will assume that the interface tool started the Scheme session with the application. The basic model of communication is shown in Figure 4. <p> Some system-dependent scaffolding is required to install a timer interrupt. Profiling information can be obtained using find-box-for. 4.3 Other Tools Zodiac has been used in other systems. Its front-end components have been integrated into the MzScheme compiler <ref> [6] </ref>. It has also been combined with an implementation of set-based program analysis to construct a powerful static program debugging and optimization tool [5]. In addition, Zodiac provides a framework for combining programming tools. <p> We are in the process of building a number of additional tools using Zodiac. These include transparent programming environments and modular programming systems. In addition, support is being added for fully-graphical user interfaces built with MrEd <ref> [6] </ref>. Programming environments for all languages can benefit from tools like Zodiac. By abstracting over interactive tools, Zodiac enables the user of an environment to conveniently build new tools and incorporate them into the existing arsenal.
Reference: [7] <institution> Free Software Foundation. </institution> <month> xscheme. </month> <title> Software distributed with GNU Emacs [16]. </title>
Reference-contexts: Section 5 describes some technical issues in the design of Zodiac. Section 6 discusses performance, and the final section mentions possible directions for future work. 2 Related Work Programming environments for advanced languages are typically based on an editor such as Emacs [16]. For instance, the xscheme <ref> [7] </ref> and cmuscheme [14] packages provide the ability to run Scheme in a sub-process, evaluate the contents of a buffer, interrupt execution, and so forth. Since Emacs is extensible, it is in principle feasible to build interactive tools based on it.
Reference: [8] <author> Dybvig, K., Hieb, R., and Bruggeman, C. </author> <title> Syntactic abstraction in Scheme. </title> <booktitle> Lisp and Symbolic Computation 5, </booktitle> <month> 4 (December </month> <year> 1993), </year> <pages> pp. 295-326. </pages>
Reference-contexts: As Figure 2 indicates, the output from the reader is similar to that of Scheme's read, except annotated with the delimiting locations. Scheme requires an interleaving of macro-expansion and parsing. The expander in Zodiac implements the syntax-case macro system <ref> [8] </ref> and maintains source information across expansion. The parser converts expressions into abstract syntax, which categorizes them as applications, abstractions, and so forth. The format of the resulting records is defined in Figure 3. The E's are expressions and lp's the delimiting locations. <p> in speed to that of Scheme implementations such as Scheme 48 [10]. (The scanner is not directly comparable, since it is not provided as a separate procedure by other implementations.) The parser and macro-expander take time linear in the size of the program or of the terms introduced during expansion <ref> [8] </ref>. The Zodiac-based applications described above also perform efficiently. Preliminary experiments indicate that the overhead introduced by the debugger is considerably lower than the figures reported for PSD [9]. Similarly, the profiler performs comparably to the system implemented for SML [1].
Reference: [9] <author> Kellomaki, P. </author> <title> Psd a portable Scheme debugger. </title> <note> To appear in ACM Lisp Pointers. </note>
Reference-contexts: Since Emacs is extensible, it is in principle feasible to build interactive tools based on it. However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers <ref> [9] </ref>, profilers [1, 13], binding environment browsers [2, 10, 4] and evaluation steppers [12, 17]. <p> The Zodiac-based applications described above also perform efficiently. Preliminary experiments indicate that the overhead introduced by the debugger is considerably lower than the figures reported for PSD <ref> [9] </ref>. Similarly, the profiler performs comparably to the system implemented for SML [1]. In addition, several sources of potential improvement have been identified in the implementation of Zodiac and of the applications. 7 Conclusions In summary, Zodiac is a modular, composable, efficient tool for building interactive programming applications.
Reference: [10] <author> Kelsey, R., and Rees, J. </author> <title> A tractable Scheme implementation. </title> <booktitle> Lisp and Symbolic Computation 5, 4 (1994), </booktitle> <pages> pp. 315-335. </pages>
Reference-contexts: However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers [1, 13], binding environment browsers <ref> [2, 10, 4] </ref> and evaluation steppers [12, 17]. <p> These expressions can then be transformed by annotation routines. 6 Performance The components of Zodiac are efficient in practice. The reader is comparable in speed to that of Scheme implementations such as Scheme 48 <ref> [10] </ref>. (The scanner is not directly comparable, since it is not provided as a separate procedure by other implementations.) The parser and macro-expander take time linear in the size of the program or of the terms introduced during expansion [8]. The Zodiac-based applications described above also perform efficiently.
Reference: [11] <author> Kishon, A., Hudak, P. and Consel, C. </author> <title> Monitoring semantics: a formal framework for specifying, implementing and reasoning about execution monitors. </title> <booktitle> In Proceedings of the ACM SIG-PLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> pp. 338-352. </pages>
Reference-contexts: This makes them hard to customize, extend or compose. In contrast, Zodiac provides a framework in which these components are kept distinct and thus are more easily modifiable. The framework for specifying monitoring semantics <ref> [11] </ref> is similar in spirit to Zodiac.
Reference: [12] <author> Lieberman, H. </author> <title> Steps toward better debugging tools for Lisp. </title> <booktitle> In Proceedings of the 1984 ACM Conference on Lisp and Functional Programming (August 1984), </booktitle> <pages> pp. 247-255. </pages>
Reference-contexts: However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers [1, 13], binding environment browsers [2, 10, 4] and evaluation steppers <ref> [12, 17] </ref>.
Reference: [13] <author> Sansom, P., and Peyton Jones, S. </author> <title> Time and space profiling for non-strict, higher-order functional languages. </title> <booktitle> In Conference Record of the 22nd ACM Symposium on the Principles of Programming Languages (January 1995), </booktitle> <pages> pp. 355-366. </pages>
Reference-contexts: Since Emacs is extensible, it is in principle feasible to build interactive tools based on it. However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers <ref> [1, 13] </ref>, binding environment browsers [2, 10, 4] and evaluation steppers [12, 17].
Reference: [14] <author> Shivers, O. cmuscheme. </author> <title> Software distributed with GNU Emacs [16]. </title>
Reference-contexts: Section 6 discusses performance, and the final section mentions possible directions for future work. 2 Related Work Programming environments for advanced languages are typically based on an editor such as Emacs [16]. For instance, the xscheme [7] and cmuscheme <ref> [14] </ref> packages provide the ability to run Scheme in a sub-process, evaluate the contents of a buffer, interrupt execution, and so forth. Since Emacs is extensible, it is in principle feasible to build interactive tools based on it.
Reference: [15] <author> Shriram, K. </author> <title> Aries Reference Manual. </title> <type> Unpublished manuscript. </type>
Reference-contexts: The following section demonstrates the construction of Aries <ref> [15] </ref>, an environment that traps on these errors and reports their occurrence and source location to the programmer.
Reference: [16] <author> Stallman, R. </author> <title> GNU Emacs Manual. Free Software Foundation, </title> <address> Cambridge, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: Section 5 describes some technical issues in the design of Zodiac. Section 6 discusses performance, and the final section mentions possible directions for future work. 2 Related Work Programming environments for advanced languages are typically based on an editor such as Emacs <ref> [16] </ref>. For instance, the xscheme [7] and cmuscheme [14] packages provide the ability to run Scheme in a sub-process, evaluate the contents of a buffer, interrupt execution, and so forth. Since Emacs is extensible, it is in principle feasible to build interactive tools based on it. <p> The application and the interface need to exchange commands and data. Zodiac simplifies the former and handles the latter. It provides routines for communicating with any interface tool that meets certain desiderata, and it provides user interfaces in tools such as Emacs <ref> [16] </ref> and MrEd [6]. 3.3.1 Interface Protocol Zodiac allows the interface and Scheme to execute in separate processes. For simplicity, this description will assume that the interface tool started the Scheme session with the application. The basic model of communication is shown in Figure 4.
Reference: [17] <author> Touretzky, D., and Lee, P. </author> <title> Visualizing evaluation in applicative languages. </title> <journal> Communications of the ACM 35, </journal> <month> 10 (October </month> <year> 1992). </year>
Reference-contexts: However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers [18], error trackers [9], profilers [1, 13], binding environment browsers [2, 10, 4] and evaluation steppers <ref> [12, 17] </ref>.
Reference: [18] <author> Wright, A. K. and Cartwright, R. </author> <title> A practical soft type system for Scheme. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming (June 1994), </booktitle> <pages> pp. 260-262. 12 </pages>
Reference-contexts: Since Emacs is extensible, it is in principle feasible to build interactive tools based on it. However, none of the commonly available Emacs modes suitably abstract over visual environments. Several packages facilitate program analysis, debugging and optimization. Examples include type interferencers <ref> [18] </ref>, error trackers [9], profilers [1, 13], binding environment browsers [2, 10, 4] and evaluation steppers [12, 17].
References-found: 18

