URL: ftp://ftp.eecs.umich.edu/groups/gasm/flea.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Email: E-mail: frix,grlg@cs.rug.nl  
Title: A Formalisation of Evolving Algebras  
Author: Rix Groenboom Gerard Renardel de Lavalette 
Address: P.O. Box 800, 9700 AV Groningen the Netherlands  
Affiliation: Department of Computing Science University of Groningen  
Abstract: Evolving Algebras is a specification formalism developed by Y. Gurevich. It is applied in a number of cases, e.g. to define the semantics of programming languages and protocols. This paper presents a formal definition of Evolving Algebras with a clear separation between syntax and semantics, leading (among other things) to an elaboration of the join operator. The relation with the formal specification language COLD is stressed. 
Abstract-found: 1
Intro-found: 1
Reference: [BHA93] <author> J. Balder, F. van Harmelen, and M. Aben. </author> <title> A KADS/(ml)2 model of a scheduling tasks. </title> <editor> In J. Treur and T. Wetter, editors, </editor> <title> Formal Specification of Complex Reasoning Systems. </title> <publisher> Ellis Horwood, </publisher> <year> 1993. </year>
Reference-contexts: FLEA is extended to FLEA 2 , for which a preliminary axiomatization is presented. Several axioms were borrowed from MLCM. In recent work, we use the same paradigm to give a formal semantics to the KADS-language KARL [LFA93] and ML 2 <ref> [BHA93] </ref>. These two language are designed for the definition of knowledge-based systems, which are developed using the KADS-models of expertise. For the inference steps, these languages have a dynamic notion of inference that can be modelled with MLCM.
Reference: [Bor94a] <author> E. Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Pisa, </institution> <year> 1994. </year> <note> Available via ftp: apollo.di.unipi.it (131.114.4.36), directory: pub/Papers/boerger. </note>
Reference-contexts: Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam [GM90]. Other applications involve the specification of the communication protocol Kermit [Hug94] and various grammar formalisms [JM94]. For more references see <ref> [Bor94a] </ref>. The essential idea behind it is as follows. An EA is a collection of similar algebras (i.e. with the same signature) which act as states; modification through application of rules is modeled by state transition. So the rules correspond with relations on the state space.
Reference: [Bor94b] <author> E. Borger. </author> <title> Logic programming: The evolving algebra approach. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations, Amsterdam, 1994. </address> <publisher> Elsevier. </publisher>
Reference-contexts: 1 Introduction Evolving Algebras (EA), introduced by Gurevich in [Gur88], is a flexible formalism used for the specification of dynamic processes in computer science and linguistics. Examples are the definition of a semantics for the programming languages Prolog <ref> [Bor94b] </ref> (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam [GM90]. Other applications involve the specification of the communication protocol Kermit [Hug94] and various grammar formalisms [JM94]. For more references see [Bor94a]. The essential idea behind it is as follows.
Reference: [BR92] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <type> Technical Report TR - 14/92, </type> <institution> Department of Computer Science, University of Pisa, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Evolving Algebras (EA), introduced by Gurevich in [Gur88], is a flexible formalism used for the specification of dynamic processes in computer science and linguistics. Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine <ref> [BR92] </ref>), and Occam [GM90]. Other applications involve the specification of the communication protocol Kermit [Hug94] and various grammar formalisms [JM94]. For more references see [Bor94a]. The essential idea behind it is as follows.
Reference: [FJ94] <author> L.M.G. Feijs and H.B.M. Jonkers. </author> <title> Formal Specification and Design. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 35. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: An EA is a collection of similar algebras (i.e. with the same signature) which act as states; modification through application of rules is modeled by state transition. So the rules correspond with relations on the state space. Similar ideas are present in the specification language COLD <ref> [FJ94] </ref>. For axiomatic reasoning about EA formalizations, we need to study the specification formalisms. We adopt a modal logic view, by defining a possible world semantics and then introduce a modal operator in the language. <p> The main ideas for the language originate from Hans Jonkers, the textbook <ref> [FJ94] </ref> give a good introduction to COLD-K (the kernel language of COLD). The formal definition of COLD-K and its semantics have been given in 1987 in [FJKRdL87]. The semantics is based on the many-sorted partial infinitary logic MPL ! , see [KRdL89].
Reference: [FJKRdL87] <author> L.M.G. Feijs, H.B.M. Jonkers, C.P.J. Koymans, and G.R. Renar-del de Lavalette. </author> <title> Formal definition of the design language COLD-K (preliminary version). </title> <type> Technical report, </type> <institution> ESPRIT document METEOR/t7/PRLE/7, </institution> <month> April </month> <year> 1987. </year> <note> Final version: </note> <month> August </month> <year> 1989. </year>
Reference-contexts: The main ideas for the language originate from Hans Jonkers, the textbook [FJ94] give a good introduction to COLD-K (the kernel language of COLD). The formal definition of COLD-K and its semantics have been given in 1987 in <ref> [FJKRdL87] </ref>. The semantics is based on the many-sorted partial infinitary logic MPL ! , see [KRdL89]. This static part of COLD-K is studied in [RdL94]. In COLD, a class is a sort of abstract machine with states and nondeterministic procedures.
Reference: [GM90] <author> Y. Gurevich and L. Moss. </author> <title> Algebraic operational semantics and occam. </title> <editor> In E. Borger, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Proceedings CSL '89, </booktitle> <pages> pages 176 - 192. </pages> <publisher> Springer Verlag, LNCS 440, </publisher> <year> 1990. </year>
Reference-contexts: Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam <ref> [GM90] </ref>. Other applications involve the specification of the communication protocol Kermit [Hug94] and various grammar formalisms [JM94]. For more references see [Bor94a]. The essential idea behind it is as follows.
Reference: [Gol82] <author> R. </author> <title> Goldblatt. </title> <booktitle> Axiomatising the logic of computer science. </booktitle> <publisher> LNCS 130. Springer Verlag, </publisher> <year> 1982. </year> <month> 12 </month>
Reference-contexts: MLCM is an abbreviation of Modal Logic of Creation and Modification. The logic is developed for reasoning over states transitions within the specification language COLD. MLCM is a modal logic in the tradition of Dynamic Logic as proposed by Goldblatt <ref> [Gol82] </ref> and Harel [Har84]. In the traditional setting of dynamic logic, states are represented with (logical) variables. To modify a state the assignment of 4 variables is changed. This conflicts with the evaluation of the quantifiers, that also modify the assignment of a variable.
Reference: [GR92] <author> P. Glavan and D. Rosenzweig. </author> <title> Communicating evolving algebra. </title> <editor> In E. Borger et al., editor, </editor> <booktitle> Computer Science Logic, </booktitle> <pages> pages 182-215. </pages> <publisher> Springer Verlag, LNCS 702, </publisher> <year> 1992. </year>
Reference-contexts: Given this formal description, we introduce the model extension FLEA 2 and take a closer look at the proof rules for FLEA by comparison with MLCM. 2 Survey of of EA Several papers present EA in a more or less formal style, see for example <ref> [GR92] </ref> and [Gur93]. However, a formal definition with clear separation between syntax and semantics is (to our knowledge) not available yet. An operational definition, viz. an interpreter for EA, can be found in [Kap93] and [Hug93].
Reference: [GRdL94] <author> R. Groenboom and G.R. Renardel de Lavalette. </author> <title> Reasoning about dynamic features in specification languages. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg (eds.), editors, </editor> <booktitle> Workshop in Semantics of Specification Languages, </booktitle> <pages> pages 340 - 355. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: For axiomatic reasoning about EA formalizations, we need to study the specification formalisms. We adopt a modal logic view, by defining a possible world semantics and then introduce a modal operator in the language. In order to reason more abstractly about COLD, we have studied the multimodal logic MLCM <ref> [GRdL94] </ref>, a variant of Dynamic Logic [Har84]. In this paper we will adopt a similar approach for EA. In the style of MLCM, we develop a Formal Language for EA (FLEA). Later we 1 2 introduce the modal extension of FLEA and relate it to MLCM. <p> x ! (t ' y $ [f (s) := t]f (x) ' y) FM4 8x [f (s) := t]A $ [f (s) := t](8xA) x not free in s, t Here ! (definedness ) and ' (weak equality) are defined by: t! = def (t = t) We refer to <ref> [GRdL94] </ref> for the full definition of syntax, semantics, axiomatization and (partial) completeness proof of MLCM. 4 FLEA: a Formal Language for EA Section 2 contains the basic ingredients of SEA. We now introduce FLEA, a formal language for EA and define its semantics.
Reference: [Gur88] <author> Y. Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical computer science, </booktitle> <pages> pages 1 - 57. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Evolving Algebras (EA), introduced by Gurevich in <ref> [Gur88] </ref>, is a flexible formalism used for the specification of dynamic processes in computer science and linguistics. Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam [GM90].
Reference: [Gur93] <author> Y. Gurevich. </author> <title> Evolving algebras. a tutorial introduction. </title> <editor> In G. Rozen-berg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292. </pages> <publisher> World Scientific, </publisher> <year> 1993. </year> <journal> Revised reprint of Bulletin of EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: Given this formal description, we introduce the model extension FLEA 2 and take a closer look at the proof rules for FLEA by comparison with MLCM. 2 Survey of of EA Several papers present EA in a more or less formal style, see for example [GR92] and <ref> [Gur93] </ref>. However, a formal definition with clear separation between syntax and semantics is (to our knowledge) not available yet. An operational definition, viz. an interpreter for EA, can be found in [Kap93] and [Hug93].
Reference: [Gur94] <author> Y. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: However, a formal definition with clear separation between syntax and semantics is (to our knowledge) not available yet. An operational definition, viz. an interpreter for EA, can be found in [Kap93] and [Hug93]. The most recent and rigorous definition of EA is the Lipari Guide by Gurevich <ref> [Gur94] </ref>; that paper will serve as starting point for our discussion. [Gur94] mentions several types of EA. The simplest is the sequential evolving algebra (SEA). Extensions include the introduction of nondeterminism, first order guards and a choice operator. <p> An operational definition, viz. an interpreter for EA, can be found in [Kap93] and [Hug93]. The most recent and rigorous definition of EA is the Lipari Guide by Gurevich <ref> [Gur94] </ref>; that paper will serve as starting point for our discussion. [Gur94] mentions several types of EA. The simplest is the sequential evolving algebra (SEA). Extensions include the introduction of nondeterminism, first order guards and a choice operator. Furthermore SEA is generalized to a parallel and a distributed version of EA. We will now give an informal introduction of SEA. <p> We now introduce FLEA, a formal language for EA and define its semantics. For the syntax we take the core of what 5 we need to describe all the constructs of SEA and most of its extensions. Below we indicate how the constructs mentioned in <ref> [Gur94] </ref> can be rendered in FLEA. 4.1 Syntax Parameters for FLEA are the following collections: SF the set of static function names SU the set of static universes DF the set of dynamic functions names DU the set of dynamic universes VAR the set of individual variables satisfying (j j is <p> Formulas are intended to be terms with a boolean value. 4.2 Translating EA into FLEA We present some EA constructs from <ref> [Gur94] </ref> in a table, with their translation in FLEA: 6 EA FLEA if g 1 then r 1 if g 1 then r 1 ; elseif g 2 then r 2 if :g 1 ^ g 2 then r 2 ; else r 3 if :g 1 ^ :g 2 then
Reference: [Har84] <author> D. Harel. </author> <title> Dynamic logic. </title> <editor> In D. Gabbay and F. Gunthner, editors, </editor> <booktitle> Handbook of Philosophical Logic, </booktitle> <volume> Vol. II, </volume> <pages> pages 497 - 604. </pages> <publisher> Reidel Publishing Company, </publisher> <year> 1984. </year>
Reference-contexts: We adopt a modal logic view, by defining a possible world semantics and then introduce a modal operator in the language. In order to reason more abstractly about COLD, we have studied the multimodal logic MLCM [GRdL94], a variant of Dynamic Logic <ref> [Har84] </ref>. In this paper we will adopt a similar approach for EA. In the style of MLCM, we develop a Formal Language for EA (FLEA). Later we 1 2 introduce the modal extension of FLEA and relate it to MLCM. <p> MLCM is an abbreviation of Modal Logic of Creation and Modification. The logic is developed for reasoning over states transitions within the specification language COLD. MLCM is a modal logic in the tradition of Dynamic Logic as proposed by Goldblatt [Gol82] and Harel <ref> [Har84] </ref>. In the traditional setting of dynamic logic, states are represented with (logical) variables. To modify a state the assignment of 4 variables is changed. This conflicts with the evaluation of the quantifiers, that also modify the assignment of a variable. <p> As in dynamic logic (e.g. QDL in <ref> [Har84] </ref>) we have the program constructors test (A?), sequential composition (P ; Q), nondeterministic choice (P [ Q), and repetition (P fl ).
Reference: [Hug93] <author> J. Huggins. </author> <title> Evolving algebra interpreter. </title> <type> Technical report, </type> <institution> University of Michican, </institution> <year> 1993. </year>
Reference-contexts: However, a formal definition with clear separation between syntax and semantics is (to our knowledge) not available yet. An operational definition, viz. an interpreter for EA, can be found in [Kap93] and <ref> [Hug93] </ref>. The most recent and rigorous definition of EA is the Lipari Guide by Gurevich [Gur94]; that paper will serve as starting point for our discussion. [Gur94] mentions several types of EA. The simplest is the sequential evolving algebra (SEA).
Reference: [Hug94] <author> J. Huggins. </author> <title> Kermit: Specification and verification. In E.B. Borger, editor, Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam [GM90]. Other applications involve the specification of the communication protocol Kermit <ref> [Hug94] </ref> and various grammar formalisms [JM94]. For more references see [Bor94a]. The essential idea behind it is as follows. An EA is a collection of similar algebras (i.e. with the same signature) which act as states; modification through application of rules is modeled by state transition.
Reference: [JM94] <author> D. E. Johnson and L. S. Moss. </author> <title> Grammar formalisms viewed as evolving algebras. </title> <journal> Linguistics and Philosophy, </journal> <volume> (17):537 - 560, </volume> <year> 1994. </year>
Reference-contexts: Examples are the definition of a semantics for the programming languages Prolog [Bor94b] (resulting in a formal description of the Warren Abstract Machine [BR92]), and Occam [GM90]. Other applications involve the specification of the communication protocol Kermit [Hug94] and various grammar formalisms <ref> [JM94] </ref>. For more references see [Bor94a]. The essential idea behind it is as follows. An EA is a collection of similar algebras (i.e. with the same signature) which act as states; modification through application of rules is modeled by state transition.
Reference: [Kap93] <author> A. M. Kappel. </author> <title> Executable Specifications based on Dynamic Algebras. of the paper. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming and Automated Reasoning, </booktitle> <pages> pages 229-240. </pages> <publisher> Springer Verlag, LNAI 698, </publisher> <year> 1993. </year>
Reference-contexts: However, a formal definition with clear separation between syntax and semantics is (to our knowledge) not available yet. An operational definition, viz. an interpreter for EA, can be found in <ref> [Kap93] </ref> and [Hug93]. The most recent and rigorous definition of EA is the Lipari Guide by Gurevich [Gur94]; that paper will serve as starting point for our discussion. [Gur94] mentions several types of EA. The simplest is the sequential evolving algebra (SEA).
Reference: [KRdL89] <author> C.P.J. Koymans and G.R. Renardel de Lavalette. </author> <title> The logic MPL ! . In M. </title> <editor> Wirsing and J.A. Bergstra, editors, </editor> <booktitle> Algebraic Methods: Theory, tools and application, </booktitle> <pages> pages 247-282. </pages> <publisher> Springer Verlag, LNCS 394, </publisher> <year> 1989. </year>
Reference-contexts: The formal definition of COLD-K and its semantics have been given in 1987 in [FJKRdL87]. The semantics is based on the many-sorted partial infinitary logic MPL ! , see <ref> [KRdL89] </ref>. This static part of COLD-K is studied in [RdL94]. In COLD, a class is a sort of abstract machine with states and nondeterministic procedures. A state is associated with an algebra, containing sorts, predicates and functions.
Reference: [LFA93] <author> D. Landes, D. Fensel, and J Angele. </author> <title> Formalizing and operationalizing a design task with KARL. </title> <editor> In J. Treur and T. Wetter, editors, </editor> <title> Formal Specification of Complex Reasoning Systems. </title> <publisher> Ellis Horwood, </publisher> <year> 1993. </year>
Reference-contexts: Especially the formalization of the join operator required additional machinery. FLEA is extended to FLEA 2 , for which a preliminary axiomatization is presented. Several axioms were borrowed from MLCM. In recent work, we use the same paradigm to give a formal semantics to the KADS-language KARL <ref> [LFA93] </ref> and ML 2 [BHA93]. These two language are designed for the definition of knowledge-based systems, which are developed using the KADS-models of expertise. For the inference steps, these languages have a dynamic notion of inference that can be modelled with MLCM.
Reference: [RdL94] <author> G.R. Renardel de Lavalette. </author> <title> The static part of the design language COLD-K. </title> <editor> In J.F. Groote D.J. Andrews and C.A. Middelburg (eds.), editors, </editor> <booktitle> Workshop in Semantics of Specification Languages, </booktitle> <pages> pages 51 - 82. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The formal definition of COLD-K and its semantics have been given in 1987 in [FJKRdL87]. The semantics is based on the many-sorted partial infinitary logic MPL ! , see [KRdL89]. This static part of COLD-K is studied in <ref> [RdL94] </ref>. In COLD, a class is a sort of abstract machine with states and nondeterministic procedures. A state is associated with an algebra, containing sorts, predicates and functions.
References-found: 21

