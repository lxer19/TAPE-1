URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/KRDB94/vossen-long.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Title: Formalization of OODB Models  
Author: Gottfried Vossen 
Address: Grevenerstrae 91, 48159 Munster  
Affiliation: Institut fur Wirtschaftsinformatik, Universitat Munster  
Abstract-found: 0
Intro-found: 1
Reference: [ 1 ] <author> S. Abiteboul, </author> <title> P.C. Kanellakis: </title> <booktitle> The Two Facets of Object-Oriented Data Models; IEEE Data Engineering Bulletin 14 (2) 1991, </booktitle> <pages> 3-7 </pages>
Reference-contexts: of the message as its first component), (iii) P is a (finite) set of methods or programs, (iv) messg : C ! 2 M is a mapping s.t. for each c 2 C and for each m 2 messg (c) there exists a signature s 2 sign (m) satisfying s <ref> [1] </ref> = c, (v) impl: f (m; c) j m 2 messg (c)g ! P is a partial function. In combining structural and behavioral schemas, we finally obtain an objectbase schema of the form S = (C; (T; type; isa;); (M; P; isa; messg; impl)). <p> To investigate such issues, our general notion of schema is made precise in various ways. For example, [ 15 ] fixes a simple imperative language for implementing methods as retrieval programs, contrasts them with update programs and shows undecidability results for the latter. <ref> [ 1; 2 ] </ref> as well as [ 11 ] introduce distinct notions of a method schema to study behavioral issues of OODBS; for example, [ 2 ] investigates implications of the covariance condition using the formalism of program schemas, while [ 11 ] looks at tractability guarantees corresponding to those
Reference: [ 2 ] <author> S. Abiteboul, P.C. Kanellakis, E. Waller: </author> <title> Method Schemas; Proc. </title> <booktitle> 9th ACM Symposium on Principles of Database Systems 1990, </booktitle> <pages> 16-27 </pages>
Reference-contexts: To investigate such issues, our general notion of schema is made precise in various ways. For example, [ 15 ] fixes a simple imperative language for implementing methods as retrieval programs, contrasts them with update programs and shows undecidability results for the latter. <ref> [ 1; 2 ] </ref> as well as [ 11 ] introduce distinct notions of a method schema to study behavioral issues of OODBS; for example, [ 2 ] investigates implications of the covariance condition using the formalism of program schemas, while [ 11 ] looks at tractability guarantees corresponding to those <p> 15 ] fixes a simple imperative language for implementing methods as retrieval programs, contrasts them with update programs and shows undecidability results for the latter. [ 1; 2 ] as well as [ 11 ] introduce distinct notions of a method schema to study behavioral issues of OODBS; for example, <ref> [ 2 ] </ref> investigates implications of the covariance condition using the formalism of program schemas, while [ 11 ] looks at tractability guarantees corresponding to those known for relational query languages.
Reference: [ 3 ] <author> P.M.G. Apers et al.: </author> <title> Inheritance in an Object-Oriented Data Model; Memoranda Informatica 90-77, </title> <institution> University of Twente 1990 </institution>
Reference-contexts: additional array constructor to describe matrices), an explicit inclusion of distinct types of relationships between classes and their objects (in particular various forms of composition, see [ 18 ] ), integrity constraints which represent semantic information on the set of valid databases instances (a proposal in that direction appears in <ref> [ 3; 4 ] </ref> , where object constraints, class constraints, and database constraints are distinguished). For another example, the ODMG-93 proposal for a standardized model [ 10 ] contains explicit keys, (binary) relationships, and inverse attributes.
Reference: [ 4 ] <author> H. Balsters et al.: </author> <title> Sets and Constraints in an Object-Oriented Data Model; Memoranda In-formatica 90-75, </title> <institution> University of Twente 1990 </institution>
Reference-contexts: additional array constructor to describe matrices), an explicit inclusion of distinct types of relationships between classes and their objects (in particular various forms of composition, see [ 18 ] ), integrity constraints which represent semantic information on the set of valid databases instances (a proposal in that direction appears in <ref> [ 3; 4 ] </ref> , where object constraints, class constraints, and database constraints are distinguished). For another example, the ODMG-93 proposal for a standardized model [ 10 ] contains explicit keys, (binary) relationships, and inverse attributes.
Reference: [ 5 ] <editor> F. Bancilhon, C. Delobel, P. Kanellakis (eds.): </editor> <title> Building an Object-Oriented Database System | The Story of O 2 . Morgan-Kaufmann 1992 </title>
Reference-contexts: 1 Introduction Object-oriented data models represent a current endpoint in the evolution of data models [ 23 ] . Their formalization has been attempted in a variety of papers, including <ref> [ 5; 6; 19 ] </ref> . This short paper indicates what we consider the common intersection of these (and other) approaches; we list the relevant features and components, and give an idea of how to formalize the notion of an object-oriented database schema.
Reference: [ 6 ] <author> C. Beeri: </author> <title> A Formal Approach to Object-Oriented Databases; Data & Knowledge Engineering 5, </title> <booktitle> 1990, </booktitle> <pages> 353-382 </pages>
Reference-contexts: 1 Introduction Object-oriented data models represent a current endpoint in the evolution of data models [ 23 ] . Their formalization has been attempted in a variety of papers, including <ref> [ 5; 6; 19 ] </ref> . This short paper indicates what we consider the common intersection of these (and other) approaches; we list the relevant features and components, and give an idea of how to formalize the notion of an object-oriented database schema.
Reference: [ 7 ] <editor> E. Bertino et al.: </editor> <title> An Object-Oriented Data Model for Distributed Office Applications; Proc. </title> <booktitle> ACM Conference on Office Information Systems 1990, </booktitle> <pages> 216-226 </pages>
Reference-contexts: additional features, like attributes as functions [ 22; 29 ] , a distinction of class attributes from instance attributes (the latter are shared by all objects associated with a class, while the former represent, for example, aggregate information like an average salary only relevant to the class as a whole) <ref> [ 7 ] </ref> , a unique root of the class hierarchy from which every class inherits [ 20 ] , a distinction between private and public attributes [ 12 ] , a different set of constructors (like one with an additional array constructor to describe matrices), an explicit inclusion of distinct
Reference: [ 8 ] <editor> E. Bertino, L. Martino: </editor> <booktitle> Object-oriented Database Management Systems: Concepts and Issues; IEEE Computer 24 (4) 1991, </booktitle> <pages> 33-47 </pages>
Reference-contexts: This short paper indicates what we consider the common intersection of these (and other) approaches; we list the relevant features and components, and give an idea of how to formalize the notion of an object-oriented database schema. An object-oriented data model has to capture a variety of requirements <ref> [ 8; 27 ] </ref> , which differ considerably from those that traditional data models have to meet. However, many system developers seem not to care about formal models as a solid foundation of their system, but simply design a "data definition language" in which the relevant features can be coded.
Reference: [ 9 ] <author> E. Bertino, L. Martino: </author> <title> Object-Oriented Database Systems; Addison-Wesley 1993 </title>
Reference-contexts: Condition (i) just says that subclasses inherit the behavior of their superclasses. Condition (ii) says that message-name overloading is done with compatible signatures, and is called the covariance condition in <ref> [ 20; 9 ] </ref> . The covariance condition is a significant difference from what is used at a corresponding point in programming languages, and which is known as the contravariance condition; for a detailed explanation, see [ 9 ] . <p> The covariance condition is a significant difference from what is used at a corresponding point in programming languages, and which is known as the contravariance condition; for a detailed explanation, see <ref> [ 9 ] </ref> . Finally, Condition (iii) states that for each message associated with a class, its implementation must at least be available in some superclass. It is interesting to note that various natural conditions can be imposed on the programs that are used as implementations of messages.
Reference: [ 10 ] <author> R.G.G. Cattell (ed.): </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufmann 1994 </publisher>
Reference-contexts: For another example, the ODMG-93 proposal for a standardized model <ref> [ 10 ] </ref> contains explicit keys, (binary) relationships, and inverse attributes. None of these features appear in our model, the reason being that these are not specific to object-orientation. The second important aspect of an object-oriented database is that it is intended to capture behavior, besides structure. <p> Although there is not a single uniform such model, the foundations on which such models have to be built seem understood, and even standardization efforts have recently been launched <ref> [ 10 ] </ref> . On the other hand, a number of interesting research issues still deserve further investigation. In particular, formal models as they are currently available seem hardly suited for the nonstandard applications which initiated the consideration of object-orientation in the context of databases.
Reference: [ 11 ] <author> K. Denninghoff, V. Vianu: </author> <title> The Power of Methods with Parallel Semantics; UCSD Technical Report No. </title> <institution> CS91-184, University of California, </institution> <address> San Diego, </address> <booktitle> February 1991; extended abstract in Proc. 17th Int. Conference on Very Large Data Bases 1991, </booktitle> <pages> 221-232 </pages>
Reference-contexts: For example, [ 15 ] fixes a simple imperative language for implementing methods as retrieval programs, contrasts them with update programs and shows undecidability results for the latter. [ 1; 2 ] as well as <ref> [ 11 ] </ref> introduce distinct notions of a method schema to study behavioral issues of OODBS; for example, [ 2 ] investigates implications of the covariance condition using the formalism of program schemas, while [ 11 ] looks at tractability guarantees corresponding to those known for relational query languages. <p> update programs and shows undecidability results for the latter. [ 1; 2 ] as well as <ref> [ 11 ] </ref> introduce distinct notions of a method schema to study behavioral issues of OODBS; for example, [ 2 ] investigates implications of the covariance condition using the formalism of program schemas, while [ 11 ] looks at tractability guarantees corresponding to those known for relational query languages. Also, it is pretty straightforward to define an object algebra for a model like the one sketched in the previous section; see, for example, the papers in [ 13 ] .
Reference: [ 12 ] <editor> O. Deux et al.: </editor> <booktitle> The Story of O 2 ; IEEE Transactions on Knowledge and Data Engineering 2, </booktitle> <year> 1990, </year> <pages> 91-108 </pages>
Reference-contexts: with a class, while the former represent, for example, aggregate information like an average salary only relevant to the class as a whole) [ 7 ] , a unique root of the class hierarchy from which every class inherits [ 20 ] , a distinction between private and public attributes <ref> [ 12 ] </ref> , a different set of constructors (like one with an additional array constructor to describe matrices), an explicit inclusion of distinct types of relationships between classes and their objects (in particular various forms of composition, see [ 18 ] ), integrity constraints which represent semantic information on the
Reference: [ 13 ] <author> J.C. Freytag, D. Maier, G. Vossen: </author> <title> Query Processing for Advanced Database Systems; Morgan-Kaufmann 1994 </title>
Reference-contexts: Also, it is pretty straightforward to define an object algebra for a model like the one sketched in the previous section; see, for example, the papers in <ref> [ 13 ] </ref> . That carries over to issues like query optimization, implementation of operations, and query processing. A survey of other recent investigations that have similar bases or origins can be found in [ 28 ] .
Reference: [ 14 ] <author> M. Gro-Hardt, G. </author> <title> Vossen: </title> <booktitle> Towards Classless Object Models for Engineering Design Applications; Proc. 4th International Conference on Database and Expert Systems Applications (DEXA) 1993, </booktitle> <address> Prag, </address> <publisher> Springer LNCS 720, </publisher> <pages> 36-47 </pages>
Reference-contexts: The investigation of classless models in the context of object-oriented databases has only recently been proposed in [ 26 ] , and a concrete model is reported in <ref> [ 14 ] </ref> . 4 Conclusions In this short paper we have tried to give a rough personal account of recent work on formal models for object-oriented databases.
Reference: [ 15 ] <author> R. Hull, K. Tanaka, M. Yoshikawa: </author> <title> Behavior Analysis of Object-Oriented Databases: Method Structure, Execution Trees, </title> <booktitle> and Reach-ability; Proc. 3rd FODO Conference, </booktitle> <publisher> Springer LNCS 367, </publisher> <year> 1989, </year> <pages> 372-388 </pages>
Reference-contexts: To investigate such issues, our general notion of schema is made precise in various ways. For example, <ref> [ 15 ] </ref> fixes a simple imperative language for implementing methods as retrieval programs, contrasts them with update programs and shows undecidability results for the latter. [ 1; 2 ] as well as [ 11 ] introduce distinct notions of a method schema to study behavioral issues of OODBS; for example,
Reference: [ 16 ] <author> T. Imielinski et al.: </author> <title> Incomplete Objects | A Data Model for Design and Planning Applications; Proc. </title> <booktitle> ACM SIGMOD International Conference on Management of Data 1991, </booktitle> <pages> 288-297 </pages>
Reference-contexts: We mention that one issue or the other from this list is sometimes reflected already in existing models, but never as a basic design target. Alternative approaches, which takes these issues into consideration right from the start, appear, for example, in <ref> [ 21; 24; 16 ] </ref> . A possible general concept for the solution of these problems seems the exploitation of prototype languages, which suggest to model applications without a classification that partitions the world into entity sets.
Reference: [ 17 ] <author> A. Kemper et al.: GOM: </author> <title> A Strongly Typed Persistent Object Model with Polymorphism; Proc. German GI Conference on "Datenbanken fur Buro, Technik und Wissenschaft" (BTW) 1991, </title> <publisher> Springer Informatik-Fachbericht 270, </publisher> <pages> 198-217 </pages>
Reference-contexts: This definition resembles what can be found in a variety of models proposed in the literature, including <ref> [ 17; 19; 20; 25 ] </ref> and others. Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved.
Reference: [ 18 ] <author> W. Kim: </author> <title> Introduction to Object-Oriented Databases; MIT Press 1990 </title>
Reference-contexts: [ 20 ] , a distinction between private and public attributes [ 12 ] , a different set of constructors (like one with an additional array constructor to describe matrices), an explicit inclusion of distinct types of relationships between classes and their objects (in particular various forms of composition, see <ref> [ 18 ] </ref> ), integrity constraints which represent semantic information on the set of valid databases instances (a proposal in that direction appears in [ 3; 4 ] , where object constraints, class constraints, and database constraints are distinguished).
Reference: [ 19 ] <author> C. Lecluse et al.: </author> <title> O 2 , an Object-Oriented Data Model; Proc. </title> <booktitle> ACM SIGMOD International Conference on Management of Data 1988, </booktitle> <pages> 424-433 </pages>
Reference-contexts: 1 Introduction Object-oriented data models represent a current endpoint in the evolution of data models [ 23 ] . Their formalization has been attempted in a variety of papers, including <ref> [ 5; 6; 19 ] </ref> . This short paper indicates what we consider the common intersection of these (and other) approaches; we list the relevant features and components, and give an idea of how to formalize the notion of an object-oriented database schema. <p> This definition resembles what can be found in a variety of models proposed in the literature, including <ref> [ 17; 19; 20; 25 ] </ref> and others. Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved.
Reference: [ 20 ] <author> C. Lecluse, P. Richard: </author> <booktitle> Foundations of the O 2 Database System; IEEE Data Engineering Bulletin 14 (2) 1991, </booktitle> <pages> 28-32 </pages>
Reference-contexts: This definition resembles what can be found in a variety of models proposed in the literature, including <ref> [ 17; 19; 20; 25 ] </ref> and others. Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved. <p> from instance attributes (the latter are shared by all objects associated with a class, while the former represent, for example, aggregate information like an average salary only relevant to the class as a whole) [ 7 ] , a unique root of the class hierarchy from which every class inherits <ref> [ 20 ] </ref> , a distinction between private and public attributes [ 12 ] , a different set of constructors (like one with an additional array constructor to describe matrices), an explicit inclusion of distinct types of relationships between classes and their objects (in particular various forms of composition, see [ <p> Condition (i) just says that subclasses inherit the behavior of their superclasses. Condition (ii) says that message-name overloading is done with compatible signatures, and is called the covariance condition in <ref> [ 20; 9 ] </ref> . The covariance condition is a significant difference from what is used at a corresponding point in programming languages, and which is known as the contravariance condition; for a detailed explanation, see [ 9 ] . <p> It is interesting to note that various natural conditions can be imposed on the programs that are used as implementations of messages. We now sketch one of them, which is based on the view that programs are functions on domains <ref> [ 20 ] </ref> .
Reference: [ 21 ] <author> J. Richardson, P. Schwarz: </author> <title> Aspects: Extending Objects to Support Multiple, Independent Roles; Proc. </title> <booktitle> ACM SIGMOD International Conference on Management of Data 1991, </booktitle> <pages> 298-307 </pages>
Reference-contexts: For example, a person may be a student, an employee, and a club member simultaneously. So far the only way to represent this in an object-oriented database is by multiple inheritance, but this might not be appropriate since it can result in a combinatorial explosion of sparsely populated classes <ref> [ 21 ] </ref> . 3. Objects can be in various stages of development. For example, in a design environment it is usually necessary to maintain incomplete designs, i.e., objects whose types get completed in the course of time. 4. Classes may contain "too few" instances. <p> We mention that one issue or the other from this list is sometimes reflected already in existing models, but never as a basic design target. Alternative approaches, which takes these issues into consideration right from the start, appear, for example, in <ref> [ 21; 24; 16 ] </ref> . A possible general concept for the solution of these problems seems the exploitation of prototype languages, which suggest to model applications without a classification that partitions the world into entity sets.
Reference: [ 22 ] <author> M.H. Scholl, H.J. Schek: </author> <title> A Relational Object Model; Proc. </title> <booktitle> 3rd International Conference on Database Theory 1990, </booktitle> <publisher> Springer LNCS 470, </publisher> <pages> 89-105 </pages>
Reference-contexts: Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved. Also, implementations typically add a number of additional features, like attributes as functions <ref> [ 22; 29 ] </ref> , a distinction of class attributes from instance attributes (the latter are shared by all objects associated with a class, while the former represent, for example, aggregate information like an average salary only relevant to the class as a whole) [ 7 ] , a unique root
Reference: [ 23 ] <author> H.J. Schek, M.H. Scholl: </author> <title> Evolution of Data Models; Proc. Database Systems of the 90s, November 1990, </title> <publisher> Springer LNCS 466, </publisher> <pages> 135-153 </pages>
Reference-contexts: 1 Introduction Object-oriented data models represent a current endpoint in the evolution of data models <ref> [ 23 ] </ref> . Their formalization has been attempted in a variety of papers, including [ 5; 6; 19 ] .
Reference: [ 24 ] <author> E. </author> <title> Sciore: </title> <journal> Object Specialization; ACM Transactions on Information Systems 7, </journal> <year> 1989, </year> <pages> 103-122 </pages>
Reference-contexts: We mention that one issue or the other from this list is sometimes reflected already in existing models, but never as a basic design target. Alternative approaches, which takes these issues into consideration right from the start, appear, for example, in <ref> [ 21; 24; 16 ] </ref> . A possible general concept for the solution of these problems seems the exploitation of prototype languages, which suggest to model applications without a classification that partitions the world into entity sets.
Reference: [ 25 ] <author> D.D. Straube, </author> <title> M.T. Ozsu: Queries and Query Processing in Object-Oriented Database Systems; ACM Transactions on Information Systems 8, </title> <booktitle> 1990, </booktitle> <pages> 387-430 </pages>
Reference-contexts: This definition resembles what can be found in a variety of models proposed in the literature, including <ref> [ 17; 19; 20; 25 ] </ref> and others. Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved.
Reference: [ 26 ] <author> J.D. Ullman: </author> <title> A Comparison of Deductive and Object-Oriented Database Systems; Proc. </title> <booktitle> 2nd DOOD Conference, </booktitle> <publisher> Springer LNCS 566, </publisher> <year> 1991, </year> <pages> 263-277 </pages>
Reference-contexts: Classes may contain "too few" instances. For example, consider a database in which all persons living in a large country are represented. In this context, so many combinations of meaningful properties have to be distinguished that it might become necessary to introduce artificial name constructions for classes, like unmarried-nonstudent-autoOwner-renter-taxpayer <ref> [ 26 ] </ref> , and each such class has only very few instances. More generally, the name space available for classes might not be sufficient. 5. Objects and their classes might come into existence in reverse order. <p> The investigation of classless models in the context of object-oriented databases has only recently been proposed in <ref> [ 26 ] </ref> , and a concrete model is reported in [ 14 ] . 4 Conclusions In this short paper we have tried to give a rough personal account of recent work on formal models for object-oriented databases.
Reference: [ 27 ] <author> G. Vossen: Datenmodelle, </author> <title> Datenbanksprachen und Datenbankmanagement-Systeme; 2. </title> <publisher> Au-flage, Addison-Wesley 1994 </publisher>
Reference-contexts: This short paper indicates what we consider the common intersection of these (and other) approaches; we list the relevant features and components, and give an idea of how to formalize the notion of an object-oriented database schema. An object-oriented data model has to capture a variety of requirements <ref> [ 8; 27 ] </ref> , which differ considerably from those that traditional data models have to meet. However, many system developers seem not to care about formal models as a solid foundation of their system, but simply design a "data definition language" in which the relevant features can be coded.
Reference: [ 28 ] <author> G. Vossen: </author> <title> Database Theory: </title> <type> An Introduction; Technical Report, </type> <institution> University of Munster, </institution> <month> June </month> <year> 1994 </year>
Reference-contexts: That carries over to issues like query optimization, implementation of operations, and query processing. A survey of other recent investigations that have similar bases or origins can be found in <ref> [ 28 ] </ref> .
Reference: [ 29 ] <editor> K. Wilkinson et al.: </editor> <booktitle> The Iris Architecture and Implementation; IEEE Transactions on Knowledge and Data Engineering 2, </booktitle> <year> 1990, </year> <pages> 63-75 </pages>
Reference-contexts: Notice that it still leaves several aspects open, like single vs. multiple inheritance; if the latter is desired, a condition needs to be added stating how to conflicts should be resolved. Also, implementations typically add a number of additional features, like attributes as functions <ref> [ 22; 29 ] </ref> , a distinction of class attributes from instance attributes (the latter are shared by all objects associated with a class, while the former represent, for example, aggregate information like an average salary only relevant to the class as a whole) [ 7 ] , a unique root
References-found: 29

