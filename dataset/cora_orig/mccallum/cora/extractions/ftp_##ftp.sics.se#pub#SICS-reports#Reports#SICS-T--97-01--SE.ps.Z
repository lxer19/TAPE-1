URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-T--97-01--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: Generating Efficient Simulators from a Specification Language  
Author: -- Fredrik Larsson Ericsson Utvecklings AB Peter Magnusson, Bengt Werner Examiner: Johan Bevemyr 
Keyword: Instruction Set Simulator, Interpreter, Specification Language, Instruction Set Architecture, SPARC, Automatic Code Generation.  
Note: This work has been carried out at Swedish  and has been sponsored by  Supervisors:  
Address: Box 311, S-751 05 Uppsala, Sweden  Box 1263, S-164 28 Kista, Sweden  1505, S-125 25 Alvsjo, Sweden  
Affiliation: Computing Science Department Uppsala University  Institute of Computer Science  Box  
Abstract: SICS Technical Report T97:01 ISSN 1100-3154 Uppsala Master's Theses in Computer Science 105 Examensarbete DV3 1997-01-29 ISSN 1100-1836 Abstract A simulator is a powerful tool for hardware as well as software development. However, implementing an efficient simulator by hand is a very labour intensive and error-prone task. This paper describes a tool for automatic generation of efficient instruction set architecture (ISA) simulators. A specification file describing the ISA is used as input to the tool. Besides a simulator, the tool also generates an assembler and a disassembler for the architecture. We present a method where statistics is used to identify frequently used instructions. Special versions of these instructions are then created by the tool in order to speed up the simulator. With this technique we have generated a SPARC V8 simulator which is more efficient than our hand-coded and hand-optimized one. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. </author> <month> Bedichek </month> <year> 1990. </year> <title> Some Efficient Hardware Simulation Techniques. </title> <booktitle> In USENIX - Winter, </booktitle> <pages> pp 53-63. </pages>
Reference-contexts: Again, if a simulator exists for a new architecture which has not yet been built it is still possible to write software for it. Development of hardware and software can be done in parallel or in any order. The simulator g88 <ref> [1] </ref>, for example, was used to debug a UNIX-kernel before hardware was available. A third and perhaps most common reason for developing a simulator is that it makes it possible for one machine to run applications from another environment. A common word for this kind of simulator is emulator . <p> We present the performance of a generated simulator in section 7, related work in section 8, future work in section 9 and our conclusions in the last section. 5 2 Simulation Techniques From previous work we are familiar with how to construct efficient simulators <ref> [1, 8, 9, 10, 11] </ref>. This knowledge we of course want to make use of when we design a simulator generation tool.
Reference: [2] <institution> Blittersoft 1996. </institution> <note> PCx Software PC Emulation. http://blittersoft.wildnet.co.uk/ </note>
Reference-contexts: A third and perhaps most common reason for developing a simulator is that it makes it possible for one machine to run applications from another environment. A common word for this kind of simulator is emulator . The PCx Software Emulator <ref> [2] </ref> for the Amiga Computer which emulates a Pentium Pro is an example. 1.2 Levels of Abstraction A simulator can simulate a processor at different levels of abstraction, from the analog transistor level to the instruction set architecture level as seen by an assembly-language programmer. 3 A list of different levels <p> The following two macros shows the extraction of the SPARC V8 rd (A) and simm13 (B) fields. /* ..AAAAA. ........ ...BBBBB BBBBBBBB */ #define EXTRACT_NATIVE_rd (rd, code) " - " rd = ((code [0] &gt;> 1) & 0x1f); " - #define EXTRACT_NATIVE_simm13 (simm13, code) " - " simm13 = (code <ref> [2] </ref> &gt;> 0) & 0x1f); " simm13 = (simm13 &lt;< 8) | ((code [3] &gt;> 0) & 0xff); " simm13 = sign_extend_int32 (simm13, 13); " - The first macro has to shift the first opcode-byte one bit to the right and then mask off the most significant bits in order to
Reference: [3] <author> M. Rosenblum, S. Herrod, E. Witchell, A. </author> <month> Gupta </month> <year> 1996. </year> <title> Complete Computer System Simulation: the SimOS Approach. </title> <booktitle> In IEEE Parallel and Distributed Technology. </booktitle>
Reference-contexts: It is even possible to switch level during simulation for example if more accurate information is needed from certain parts of a program while other parts are not so interesting besides keeping a correct abstract state. Such a technique has been used in SimOS <ref> [3] </ref> and is discussed in more details in [4]. 1.3 The Aim of This Thesis Implementing a simulator by hand could be a very labour-intensive and error-prone task. <p> and simm13 (B) fields. /* ..AAAAA. ........ ...BBBBB BBBBBBBB */ #define EXTRACT_NATIVE_rd (rd, code) " - " rd = ((code [0] &gt;> 1) & 0x1f); " - #define EXTRACT_NATIVE_simm13 (simm13, code) " - " simm13 = (code [2] &gt;> 0) & 0x1f); " simm13 = (simm13 &lt;< 8) | ((code <ref> [3] </ref> &gt;> 0) & 0xff); " simm13 = sign_extend_int32 (simm13, 13); " - The first macro has to shift the first opcode-byte one bit to the right and then mask off the most significant bits in order to extract the rd-field.
Reference: [4] <author> B. Werner, P. </author> <title> Magnusson 1997. A Hybrid Simulation Approach Enabling Performance Characterization of Large Software Systems. </title> <booktitle> Proceedings of MASCOTS'97, </booktitle> <pages> pp 73-80. </pages>
Reference-contexts: Such a technique has been used in SimOS [3] and is discussed in more details in <ref> [4] </ref>. 1.3 The Aim of This Thesis Implementing a simulator by hand could be a very labour-intensive and error-prone task.
Reference: [5] <author> R. Lipsett, E. Marschner, M. </author> <month> Shaded </month> <year> 1986. </year> <title> VHDL The Language. </title> <booktitle> IEEE Design and Test of Computers (April), </booktitle> <pages> pages 28-41. </pages>
Reference-contexts: Such tools already exists today but most of them are focused on abstraction levels below the ISA-level (see section 1.2) and are thus more suitable for hardware verification than for making instruction set simulators. An example of a Hardware Definition Language (HDL) is the VHDL <ref> [5] </ref>.
Reference: [6] <author> T. A. </author> <title> Cook 1993. Instruction Set Architecture Specification. </title> <type> Ph.D. </type> <institution> thesis from North Carolina State University. </institution>
Reference-contexts: Pentium Pro is an example. 1.2 Levels of Abstraction A simulator can simulate a processor at different levels of abstraction, from the analog transistor level to the instruction set architecture level as seen by an assembly-language programmer. 3 A list of different levels which could be identified is presented here <ref> [6] </ref>: * Instruction Set Architecture Level. The level of the instruction set architecture (ISA) is the highest level of abstraction where only the result of each instruction is seen and not the mechanism behind it (an assembly language programmer's view). <p> An example of a Hardware Definition Language (HDL) is the VHDL [5]. For the ISA-level there does exists a tool <ref> [6, 7] </ref> but its solution for generating simulators writing the specification of an ISA in an functional like language and then executing that specification when simulating is not efficient enough for all needs. 4 Thus, the aim of this thesis was to construct a tool that could from a ISA-specification generate <p> There exists a few but their main approach has not been focused on how to generate an efficient simulator which was the main goal with this thesis work. Tood A. Cook and Ed Harcourt <ref> [6, 7] </ref> has developed a functional programming language, Lisas, which is used as a specification language for an instruction set architecture. The language contains constructs for describing instruction formats, declaring memory sizes with word lengths and simple register files.
Reference: [7] <author> T. A. Cook, E. </author> <title> Harcourt 1994. A Functional Specification Language for Instruction Set Architectures. </title>
Reference-contexts: An example of a Hardware Definition Language (HDL) is the VHDL [5]. For the ISA-level there does exists a tool <ref> [6, 7] </ref> but its solution for generating simulators writing the specification of an ISA in an functional like language and then executing that specification when simulating is not efficient enough for all needs. 4 Thus, the aim of this thesis was to construct a tool that could from a ISA-specification generate <p> There exists a few but their main approach has not been focused on how to generate an efficient simulator which was the main goal with this thesis work. Tood A. Cook and Ed Harcourt <ref> [6, 7] </ref> has developed a functional programming language, Lisas, which is used as a specification language for an instruction set architecture. The language contains constructs for describing instruction formats, declaring memory sizes with word lengths and simple register files.
Reference: [8] <author> J. R. </author> <title> Bell 1973. Threaded Code. </title> <journal> In Communications of the ACM, </journal> <volume> Vol 16, No 6 (June), </volume> <pages> pp 370-372. </pages>
Reference-contexts: We present the performance of a generated simulator in section 7, related work in section 8, future work in section 9 and our conclusions in the last section. 5 2 Simulation Techniques From previous work we are familiar with how to construct efficient simulators <ref> [1, 8, 9, 10, 11] </ref>. This knowledge we of course want to make use of when we design a simulator generation tool. <p> We can for example pre-calculate certain transformations which otherwise must be performed at run-time. With intermediate format we mean both what service routines there are (the mapping) and how their parameters are stored. 2.2 Threaded Code With the technique explained above threaded code <ref> [8] </ref> can be used to make the simulator even more efficient. With threaded code no loop structure is used to make the interpretation. Instead, all necessary loop code is rolled out at the end of each service routine.
Reference: [9] <author> P. </author> <title> Magnusson 1993. Partial Translation. </title> <type> SICS Technical Report T93:05. </type>
Reference-contexts: We present the performance of a generated simulator in section 7, related work in section 8, future work in section 9 and our conclusions in the last section. 5 2 Simulation Techniques From previous work we are familiar with how to construct efficient simulators <ref> [1, 8, 9, 10, 11] </ref>. This knowledge we of course want to make use of when we design a simulator generation tool.
Reference: [10] <author> P. </author> <title> Magnusson 1993. Simulation of Parallel Hardware. </title> <note> In MASCOTS (January). </note>
Reference-contexts: We present the performance of a generated simulator in section 7, related work in section 8, future work in section 9 and our conclusions in the last section. 5 2 Simulation Techniques From previous work we are familiar with how to construct efficient simulators <ref> [1, 8, 9, 10, 11] </ref>. This knowledge we of course want to make use of when we design a simulator generation tool.
Reference: [11] <author> P. Magnusson, D. </author> <title> Samuelsson 1994. A Compact Intermediate Format for SimICS. </title> <note> SICS Research Report R94:17. </note>
Reference-contexts: We present the performance of a generated simulator in section 7, related work in section 8, future work in section 9 and our conclusions in the last section. 5 2 Simulation Techniques From previous work we are familiar with how to construct efficient simulators <ref> [1, 8, 9, 10, 11] </ref>. This knowledge we of course want to make use of when we design a simulator generation tool.
Reference: [12] <author> D. </author> <title> Samuelsson 1994. System Level Interpretation of the SPARC V8 Instruction Set Architecture. </title> <note> SICS Research Report R94:23. </note>
Reference-contexts: We must for example know that a branch instruction is a branch instruction in order to test it properly. So, generation of test suites was not considered during the time of the thesis work. A SPARC V8 suite developed earlier was used to verify correctness <ref> [12] </ref>. 3.3 Implementation The SGT, called SimGen, was implemented in C-code for maximum performance. Handling large amounts of statistics require a fast tool. However, the development time could have been shorter if we had used a language with better support for symbols and dynamic data-types. <p> However some smart transformations can be used to speed up register accesses but these are not explained here. See <ref> [12] </ref>. 10 It then of course needs to shift the field at run-time reproducing the zero-bits. <p> Instead, we can just add a proper offset to the physical address. If the decoder detects an on-page branch a service routine implementing the more efficient target calculation is used. For more information of this see <ref> [12] </ref>. 4.5 Discussion Our main goal was to be able to generate a simulator from our specification language that should be as fast as or preferably faster than a hand-coded and hand-optimized simulator.
Reference: [13] <author> P. Magnusson. </author> <note> SimICS Homepage. http://www.sics.se/simics/ </note>
Reference-contexts: This seemed to be a lot of work and not achievable within a six months thesis work. Therefore we had to focus on something at first. Since we already had a simulator, SimICS <ref> [13] </ref>, which could run SPARC V8 [14] code, it was natural for us to use it as a basis and try to replace parts of it with generated ones. <p> This means that we do not need to store them in the intermediate format. What remains are the parameter fields which holds register numbers, intermediate values, branch offsets etc. This information we of course want to store in an efficient way. From previous work <ref> [13] </ref> we know that it is better to pack all parameters in one machine word than using one for each parameter. This has to do with slow memory loads.
Reference: [14] <author> The SPARC V8 Reference Manual, </author> <year> 1992 </year>
Reference-contexts: This seemed to be a lot of work and not achievable within a six months thesis work. Therefore we had to focus on something at first. Since we already had a simulator, SimICS [13], which could run SPARC V8 <ref> [14] </ref> code, it was natural for us to use it as a basis and try to replace parts of it with generated ones. <p> intermediate form declaration in the specification the intermediate width of the field, number of zero-bits and the transformation. 13 In the SPARC specification the bits are numbered the other way around, e.g. 31 to 25 instead of 0 - 6, as this is also used in the SPARC architecture manual <ref> [14] </ref>. 24 After all field declarations a list of service routine definitions follows. Each service routine has in turn a list of instructions that share this service routine. In the figure the service routine called add i 0 only contains the instruction add i 0 (same name).
Reference: [15] <author> T. A. </author> <month> Diep </month> <year> 1995. </year> <title> A Visualization-based Microarchitecture Workbench. </title> <type> Ph.D. </type> <institution> thesis from Carnegie Mellon University. </institution>
Reference-contexts: We have not seen any measurments of how efficient this approach is and if it is possible to compile this language to efficient code. The specification language lacks syntax description for the instructions. Another tool is the Visualization-based Microarchitecture Workbench (VMW) by Trung A. Diep <ref> [15] </ref>. It uses templates to specify how instructions are coded and which fields to use as parameters. The templates contains hexa-decimal mask values which is used to identify different fields. An API (Applications Programming Interface) is defined for C++ which is used to help the programmer implement the simulator.
Reference: [16] <author> N. Ramsey, M. F. </author> <title> Fernandez 1996. New Jersey Machine-Code Toolkit Reference Manual Version 0.4 </title>
Reference-contexts: A nice feature of the tool is that it has a graphical user interface for controlling the simulator. We have not found any performance measurment of an implemented simulater using the VMW. Some people have addressed subsets of the problem, such as the New Jersey Machine-Code Toolkit <ref> [16] </ref> (NJMCTK). The NJMCTK is used for helping programmers writing applications which process machine code, i.e. assemblers, disassemblers and debuggers. The user can specify how instructions are coded in a description language and then the tool is able to generate code for an instruction encoder as well as a decoder.
Reference: [17] <author> J. D. </author> <title> Wick 1975. Automatic Generation of Assemblers. </title> <type> Ph.D. </type> <institution> thesis from Yale University. </institution> <month> 51 </month>
Reference-contexts: However, we have borrowed some ideas and terminology from the NJMCTK. Another work that could be mentioned here is Automatic Generation of Assemblers by John D. Wick <ref> [17] </ref>. 42 10 Conclusion We now have a tool which will be very helpful during the development of efficient simulators. The specification language provides a compact but expressive way to describe different instruction set architectures and our experience so for indicate significantly shorter development times with much less errors.
References-found: 17

