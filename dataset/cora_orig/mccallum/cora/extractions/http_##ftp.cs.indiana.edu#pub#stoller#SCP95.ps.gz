URL: http://ftp.cs.indiana.edu/pub/stoller/SCP95.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Title: Verifying Programs that use Causally-ordered Message-passing  
Author: Scott D. Stoller Fred B. Schneider 
Note: This author is supported by an IBM Graduate Fellowship. This author is supported in part by the Office of Naval Research under contract N00014-91-J-1219, the National Science Foundation under Grant CCR-9003440, DARPA/NSF Grant No. CCR-9014363, NASA/DARPA grant NAG-2-893, and AFOSR grant F49620-94-1-0198. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not reflect the views of these agencies.  
Date: April 26, 1995  
Address: Ithaca, New York 14853  
Affiliation: Department of Computer Science Cornell University  
Abstract: We give an operational model of causally-ordered message-passing primitives. Based on this model, we formulate a Hoare-style proof system for causally-ordered delivery. To illustrate the use of this proof system and to demonstrate the feasibility of applying invariant-based verification techniques to algorithms that depend on causally-ordered delivery, we verify an asynchronous variant of the distributed termination detection algorithm of Dijkstra, Feijen, and van Gasteren. 
Abstract-found: 1
Intro-found: 1
Reference: [A + 77] <author> Allen L. Ambler et al. </author> <title> Gypsy: A language for specification and implementation of verifiable programs. </title> <booktitle> Proceedings of an ACM conference on language design for reliable software, in ACM SIGPLAN Notices, </booktitle> <volume> 12(3) </volume> <pages> 1-10, </pages> <month> March </month> <year> 1977. </year>
Reference-contexts: Second, proofs of some programs (such as the example in Section 4) involve reasoning about communications history. That history is available in oe i and ae i but is not available in O i . The use of special variables for recording communications history was first proposed for Gypsy <ref> [A + 77] </ref>. Causally-ordered delivery restricts when a message can be received. This is achieved in our translation by defining a well-founded partial order OE on timestamps. Our definition of OE is based on the theory of [Lam78].
Reference: [Apt86] <author> Krzysztof R. Apt. </author> <title> Correctness proofs of distributed termination algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 388-405, </pages> <year> 1986. </year>
Reference-contexts: Thus, in either case, tc = tokval (data (m i )). Comparison to Related Work This distributed termination detection algorithm was first presented in [DFvG83] for systems that use synchronous communication. Apt <ref> [Apt86] </ref> formalized the partial-correctness argument of [DFvG83] and proved some additional properties of the algorithm. Verjus then attempted to give another proof of partial-correctness [Ver87], but his argument was flawed [vGT90]. This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed.
Reference: [Bir93] <author> Kenneth P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12), </volume> <month> December </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: With FIFO ordering, this guarantee applies only to messages having the same sender; with causal ordering, this guarantee applies to messages sent by any process. Additional motivation for and examples of the use of causally-ordered delivery can be found in <ref> [Bir93] </ref>. This paper gives a proof system for causally-ordered delivery. Our proof system is similar in style to the satisfaction-based logics for synchronous message-passing in [LG81], for ordinary asynchronous message-passing in [SS84], and for flush channels in [CKA93]. We assume familiarity with the terminology of that literature.
Reference: [BSS91] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: Causally-ordered delivery is formalized in terms of ! as follows <ref> [BSS91] </ref>. 3 Let send (m) and receive (m) respectively denote the send event and receive event for a message m. <p> After receiving m 1;2 , process 2 sends a 3 To be consistent with the definition in [Lam78], clause (2) of the definition of ! on page 278 of <ref> [BSS91] </ref> should be 8m : send (m) ! deliver (m). Here, deliver denotes the event referred to in our paper as receive. 4 FIFO delivery can also be formalized in terms of !.
Reference: [CBMT92] <author> Bernadette Charron-Bost, Friedemann Mattern, and Gerard Tel. </author> <title> Synchronous and asynchronous communication in distributed computations. </title> <type> Technical Report LITP 92-77, </type> <institution> Institut Blaise Pascal, University of Paris 7, </institution> <year> 1992. </year>
Reference-contexts: Our proof assumes causally-ordered delivery, which implies our predicate J bas ; J bas is similar to but slightly stronger than property P of [RH90]. Another operational (albeit more formal) proof, by Charron-Bost et al., appears in <ref> [CBMT92] </ref>. It shows correctness of this termination detection algorithm for systems that communicate using causally-ordered message-passing. The proofs there differ considerably from the invariant-based analysis of the synchronous case in [DFvG83].
Reference: [CKA93] <author> Tracy Camp, Phil Kearns, and Mohan Ahuja. </author> <title> Proof rules for flush channels. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(4) </volume> <pages> 366-378, </pages> <year> 1993. </year>
Reference-contexts: This paper gives a proof system for causally-ordered delivery. Our proof system is similar in style to the satisfaction-based logics for synchronous message-passing in [LG81], for ordinary asynchronous message-passing in [SS84], and for flush channels in <ref> [CKA93] </ref>. We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. <p> We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. This distinguishes causally-ordered delivery from the types of message passing for which axiomatic semantics have already been given (e.g., <ref> [GCKW79, LG81, SS84, CKA93] </ref>). Our work demonstrates that substantially new methods are not required when message-delivery semantics depends on global information. <p> Our proof system for causally-ordered message-passing is similar, except step (2) is merged with step (1). (Such a merging is also possible for other satisfaction-based proof systems that handle asynchronous communication primitives, like the logics of [SS84] and <ref> [CKA93] </ref>.) The remainder of the paper is organized as follows. Section 2 defines causally-ordered message-passing. Our proof system is the subject of Section 3. In Section 4, we use the proof system to verify an asynchronous variant of the distributed termination detection algorithm of Dijkstra, Feijen, and van Gasteren [DFvG83]. <p> It can be removed by generalizing the definition of interference freedom. We have opted for the simpler theory here, because control predicates are orthogonal to the subject of this paper, namely, modeling causally-ordered delivery. 9 Note that, in contrast to the logics for asynchronous communication in [SS84] and <ref> [CKA93] </ref>, our parallel composition rule does not have a "satisfaction" obligation. This is not an artifact of causally-ordered message-passing; the logics of [SS84] and [CKA93] could be similarly formulated. 4 Example: Distributed Termination Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm of [DFvG83]. <p> are orthogonal to the subject of this paper, namely, modeling causally-ordered delivery. 9 Note that, in contrast to the logics for asynchronous communication in [SS84] and <ref> [CKA93] </ref>, our parallel composition rule does not have a "satisfaction" obligation. This is not an artifact of causally-ordered message-passing; the logics of [SS84] and [CKA93] could be similarly formulated. 4 Example: Distributed Termination Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm of [DFvG83]. Validity of this proof outline shows that the algorithm correctly detects quiescence in systems of processes that communicate using causally-ordered message-passing.
Reference: [DFvG83] <author> E. W. Dijkstra, W. H. J. Feijen, and A. J. M. van Gasteren. </author> <title> Derivation of a termination detection algorithm for distributed computations. </title> <journal> Information Processing Letters, </journal> <volume> 16 </volume> <pages> 217-219, </pages> <year> 1983. </year>
Reference-contexts: Section 2 defines causally-ordered message-passing. Our proof system is the subject of Section 3. In Section 4, we use the proof system to verify an asynchronous variant of the distributed termination detection algorithm of Dijkstra, Feijen, and van Gasteren <ref> [DFvG83] </ref>. Section 5 contains some conclusions. 2 2 A Model of Causally-ordered Message-passing We give an operational semantics for causally-ordered message-passing primitives by translating programs containing these primitives into a generic concurrent programming language that has shared variables. The shared variables represent the state of the network. <p> This is not an artifact of causally-ordered message-passing; the logics of [SS84] and [CKA93] could be similarly formulated. 4 Example: Distributed Termination Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm of <ref> [DFvG83] </ref>. Validity of this proof outline shows that the algorithm correctly detects quiescence in systems of processes that communicate using causally-ordered message-passing. Our proof outline is based on the correctness argument given in [DFvG83], modified for causally-ordered delivery instead of the synchronous communication assumed there. <p> Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm of <ref> [DFvG83] </ref>. Validity of this proof outline shows that the algorithm correctly detects quiescence in systems of processes that communicate using causally-ordered message-passing. Our proof outline is based on the correctness argument given in [DFvG83], modified for causally-ordered delivery instead of the synchronous communication assumed there. The algorithm is intended for use in systems where processes behave as follows. At each instant, a process is either active or quiescent, where the only action possible by a quiescent process is receipt of a message. <p> A process i is quiescent iff each guard g ij is false. This is formalized by: _ g ij ) In the algorithm of <ref> [DFvG83] </ref>, a token circulates among the processes. This introduces a new kind of message, which we call a token message. To distinguish it from the messages in the original computation, hereafter called basic messages, we use a predicate istok (data (m)) that holds exactly when m is a token message. <p> Thus, in either case, tc = tokval (data (m i )). Comparison to Related Work This distributed termination detection algorithm was first presented in <ref> [DFvG83] </ref> for systems that use synchronous communication. Apt [Apt86] formalized the partial-correctness argument of [DFvG83] and proved some additional properties of the algorithm. Verjus then attempted to give another proof of partial-correctness [Ver87], but his argument was flawed [vGT90]. <p> Thus, in either case, tc = tokval (data (m i )). Comparison to Related Work This distributed termination detection algorithm was first presented in <ref> [DFvG83] </ref> for systems that use synchronous communication. Apt [Apt86] formalized the partial-correctness argument of [DFvG83] and proved some additional properties of the algorithm. Verjus then attempted to give another proof of partial-correctness [Ver87], but his argument was flawed [vGT90]. This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed. <p> Another operational (albeit more formal) proof, by Charron-Bost et al., appears in [CBMT92]. It shows correctness of this termination detection algorithm for systems that communicate using causally-ordered message-passing. The proofs there differ considerably from the invariant-based analysis of the synchronous case in <ref> [DFvG83] </ref>. In fact, Charron-Bost et al. claim that correctness 20 proofs for all algorithms that use causally-ordered delivery "must consider the execution as a whole, rather than concentrate on assertions that remain invariant in each global state" ([CBMT92], p. 34).
Reference: [Fid88] <author> C. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <booktitle> In Proceedings of the 11th Australian Computer Science Conference, </booktitle> <pages> pages 56-66, </pages> <year> 1988. </year>
Reference-contexts: One way to achieve (1) is to use vector clocks <ref> [Fid88, Mat89] </ref>.
Reference: [GCKW79] <author> D. Good, R. Cohen, and J. Keeton-Williams. </author> <title> Principles of proving concurrent programs in gypsy. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 42-52. </pages> <publisher> ACM Press, </publisher> <year> 1979. </year>
Reference-contexts: We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. This distinguishes causally-ordered delivery from the types of message passing for which axiomatic semantics have already been given (e.g., <ref> [GCKW79, LG81, SS84, CKA93] </ref>). Our work demonstrates that substantially new methods are not required when message-delivery semantics depends on global information.
Reference: [Gri76] <author> David Gries. </author> <title> An illustration of current ideas on the derivation of correctness proofs and correct programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2 </volume> <pages> 238-244, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: See [Mat89] for an explanation of why these rules ensure that (1) holds. We now give our translation of send and receive statements into statements that read and write shared variables oe i and ae i . The following notation is used to describe the multiple-assignment <ref> [Gri76] </ref> of e 1 to x 1 , e 2 to x 2 , : : : , and e n to x n : B B B B x 1 . . . 1 C C C A 0 B B B @ e 2 e n C C C <p> Given the above translation of send e to i into a multiple-assignment statement, we use the multiple-assignment axiom <ref> [Gri76] </ref> to obtain an axiom for the send statement. The notation e [x 1 := 7 e 1 ; : : : ; x n := e n ] denotes the simultaneous substitution of each term e i for the corresponding variable x i in a term e.
Reference: [Gri90] <author> E. </author> <title> Pascal Gribomont. From synchronous to asynchronous communication. </title> <editor> In C. Rat-tray, editor, </editor> <title> Specification and Verification of Concurrent Systems: </title> <booktitle> Proceedings of a 1988 BCS-FACS Workshop, volume 1 of FACS Workshop Series. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The fact that a correctness proof for causally-ordered delivery can be based closely on the analysis of a synchronous version is a significant benefit of the approach discussed in this paper. We support a two-step approach to verifying algorithms that use asynchronous message-passing <ref> [Gri90] </ref>: 1. Verify a synchronous version of the algorithm (presumably a simpler task). 2. Modify the algorithm and the proof to obtain a correctness proof for the asynchronous version of the algorithm.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-580, </pages> <year> 1969. </year>
Reference-contexts: (m 0 )[j] = vt j [j] + 1 &gt; vt j [j] ts (m)[j], where the equality follows from the translation of send statements, the strict inequality follows from standard arithmetic, and the nonstrict inequality follows from (6). 3 Axioms for Send and Receive We now present Hoare-style axioms <ref> [Hoa69] </ref> for the send and receive statements described above. Given the above translation of send e to i into a multiple-assignment statement, we use the multiple-assignment axiom [Gri76] to obtain an axiom for the send statement.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: Causally-ordered delivery restricts when a message can be received. This is achieved in our translation by defining a well-founded partial order OE on timestamps. Our definition of OE is based on the theory of <ref> [Lam78] </ref>. A system execution is represented as a tuple of sequences of events; each sequence corresponds to the execution of a single process. An event is a send event, a receive event, or an internal (i.e., non-communication) event. <p> Process 1 sends a message m 1;3 (say, an update to a database record) to process 3 and then sends a message m 1;2 to process 2 (informing it of the update). After receiving m 1;2 , process 2 sends a 3 To be consistent with the definition in <ref> [Lam78] </ref>, clause (2) of the definition of ! on page 278 of [BSS91] should be 8m : send (m) ! deliver (m). Here, deliver denotes the event referred to in our paper as receive. 4 FIFO delivery can also be formalized in terms of !.
Reference: [Lam80] <author> Leslie Lamport. </author> <title> The `Hoare logic' of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 14 </volume> <pages> 21-37, </pages> <year> 1980. </year>
Reference-contexts: Thus, the system is quiescent iff the following predicate Q holds. Q = (8i : q i ^ (8j : O i;j = ;)) Code for the detection algorithm appears in Figure 2. Angle brackets indicate that the enclosed statement is executed atomically <ref> [Lam80] </ref>. 7 Our goal is to prove that Q holds when process 0 reaches the statement in RELAY 0 preceded by the comment "quiescent". Thus, we must construct a proof outline in which the precondition of that statement implies Q.
Reference: [LG81] <author> Gary Marc Levin and David Gries. </author> <title> A proof technique for communicating sequential processes. </title> <journal> Acta Informatica, </journal> <volume> 15 </volume> <pages> 281-302, </pages> <year> 1981. </year>
Reference-contexts: Additional motivation for and examples of the use of causally-ordered delivery can be found in [Bir93]. This paper gives a proof system for causally-ordered delivery. Our proof system is similar in style to the satisfaction-based logics for synchronous message-passing in <ref> [LG81] </ref>, for ordinary asynchronous message-passing in [SS84], and for flush channels in [CKA93]. We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. <p> We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. This distinguishes causally-ordered delivery from the types of message passing for which axiomatic semantics have already been given (e.g., <ref> [GCKW79, LG81, SS84, CKA93] </ref>). Our work demonstrates that substantially new methods are not required when message-delivery semantics depends on global information.
Reference: [Mat89] <author> Friedemann Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Corsnard, editor, </editor> <booktitle> Proceedings of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 120-131. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: One way to achieve (1) is to use vector clocks <ref> [Fid88, Mat89] </ref>. <p> Receive Update Rule: When a process i receives a message m, it updates vt i by executing vt i := max (vt i ; ts (m)); where max (vt ; vt 0 ) is the component-wise maximum of the vectors vt and vt 0 . See <ref> [Mat89] </ref> for an explanation of why these rules ensure that (1) holds. We now give our translation of send and receive statements into statements that read and write shared variables oe i and ae i .
Reference: [OG76] <author> Susan Owicki and David Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: Using axiom (3) for choose, the usual rules for assignment and sequential composition, and the inference rule for await statements <ref> [OG76] </ref> Await Rule: fP ^ Bg S fQg fP g await B then S fQg (8) we can show that fP g receive x fQg is valid iff the following Predicate Logic formula is valid: P ^ m i 2 minset (oe i ae i ) ) Q [x := data <p> A proof outline characterizes the behavior of a process assuming that no other process invalidates assertions in that proof outline. The proof outlines for processes that execute concurrently are combined to obtain a proof outline for the entire system by showing interference freedom <ref> [OG76] </ref>| that no process invalidates assertions in the proof outline of another process.
Reference: [RH90] <author> Michel Raynal and Jean-Michel Helary. </author> <title> Synchronization and Control of Distributed Systems and Programs. </title> <publisher> Wiley, </publisher> <year> 1990. </year>
Reference-contexts: This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed. The first correctness argument applicable to this algorithm in an asynchronous setting is (to the best of our knowledge) an operational argument due to Raynal and Helary <ref> [RH90] </ref>. Proposition 3.8.1 in [RH90] establishes partial correctness assuming that the message-delivery order satisfies a property P . Our proof assumes causally-ordered delivery, which implies our predicate J bas ; J bas is similar to but slightly stronger than property P of [RH90]. <p> This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed. The first correctness argument applicable to this algorithm in an asynchronous setting is (to the best of our knowledge) an operational argument due to Raynal and Helary <ref> [RH90] </ref>. Proposition 3.8.1 in [RH90] establishes partial correctness assuming that the message-delivery order satisfies a property P . Our proof assumes causally-ordered delivery, which implies our predicate J bas ; J bas is similar to but slightly stronger than property P of [RH90]. <p> an operational argument due to Raynal and Helary <ref> [RH90] </ref>. Proposition 3.8.1 in [RH90] establishes partial correctness assuming that the message-delivery order satisfies a property P . Our proof assumes causally-ordered delivery, which implies our predicate J bas ; J bas is similar to but slightly stronger than property P of [RH90]. Another operational (albeit more formal) proof, by Charron-Bost et al., appears in [CBMT92]. It shows correctness of this termination detection algorithm for systems that communicate using causally-ordered message-passing. The proofs there differ considerably from the invariant-based analysis of the synchronous case in [DFvG83].
Reference: [SS84] <author> Richard D. Schlichting and Fred B. Schneider. </author> <title> Using message passing for distributed programming: proof rules and disciplines. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(3) </volume> <pages> 402-431, </pages> <year> 1984. </year>
Reference-contexts: Additional motivation for and examples of the use of causally-ordered delivery can be found in [Bir93]. This paper gives a proof system for causally-ordered delivery. Our proof system is similar in style to the satisfaction-based logics for synchronous message-passing in [LG81], for ordinary asynchronous message-passing in <ref> [SS84] </ref>, and for flush channels in [CKA93]. We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. <p> We assume familiarity with the terminology of that literature. Reasoning about message-passing primitives for causally-ordered delivery involves a global property, the system-wide causality relation, which defines what messages are deliverable. This distinguishes causally-ordered delivery from the types of message passing for which axiomatic semantics have already been given (e.g., <ref> [GCKW79, LG81, SS84, CKA93] </ref>). Our work demonstrates that substantially new methods are not required when message-delivery semantics depends on global information. <p> Our proof system for causally-ordered message-passing is similar, except step (2) is merged with step (1). (Such a merging is also possible for other satisfaction-based proof systems that handle asynchronous communication primitives, like the logics of <ref> [SS84] </ref> and [CKA93].) The remainder of the paper is organized as follows. Section 2 defines causally-ordered message-passing. Our proof system is the subject of Section 3. <p> It can be removed by generalizing the definition of interference freedom. We have opted for the simpler theory here, because control predicates are orthogonal to the subject of this paper, namely, modeling causally-ordered delivery. 9 Note that, in contrast to the logics for asynchronous communication in <ref> [SS84] </ref> and [CKA93], our parallel composition rule does not have a "satisfaction" obligation. This is not an artifact of causally-ordered message-passing; the logics of [SS84] and [CKA93] could be similarly formulated. 4 Example: Distributed Termination Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm <p> control predicates are orthogonal to the subject of this paper, namely, modeling causally-ordered delivery. 9 Note that, in contrast to the logics for asynchronous communication in <ref> [SS84] </ref> and [CKA93], our parallel composition rule does not have a "satisfaction" obligation. This is not an artifact of causally-ordered message-passing; the logics of [SS84] and [CKA93] could be similarly formulated. 4 Example: Distributed Termination Detection To illustrate our proof rules, we give a proof outline for the termination detection algorithm of [DFvG83]. Validity of this proof outline shows that the algorithm correctly detects quiescence in systems of processes that communicate using causally-ordered message-passing.
Reference: [vGT90] <author> A. J. M. van Gasteren and G. Tel. </author> <title> Comments on "On the proof of a distributed algorithm": Always-true is not invariant. </title> <journal> Information Processing Letters, </journal> <volume> 35 </volume> <pages> 277-279, </pages> <year> 1990. </year>
Reference-contexts: Apt [Apt86] formalized the partial-correctness argument of [DFvG83] and proved some additional properties of the algorithm. Verjus then attempted to give another proof of partial-correctness [Ver87], but his argument was flawed <ref> [vGT90] </ref>. This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed. The first correctness argument applicable to this algorithm in an asynchronous setting is (to the best of our knowledge) an operational argument due to Raynal and Helary [RH90].
Reference: [vR93] <author> Robbert van Renesse. </author> <title> Causal controversy at le Mont St.-Michel. </title> <journal> Operating Systems Review, </journal> <volume> 27(2) </volume> <pages> 44-53, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Causally-ordered delivery can be understood as a generalization of FIFO ordering <ref> [vR93] </ref>. In both, a message is delivered only after all messages on which it may depend. With FIFO ordering, this guarantee applies only to messages having the same sender; with causal ordering, this guarantee applies to messages sent by any process.
Reference: [Ver87] <author> Pierre Verjus. </author> <title> On the proof of a distributed algorithm. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 145-147, </pages> <year> 1987. </year>
Reference-contexts: Comparison to Related Work This distributed termination detection algorithm was first presented in [DFvG83] for systems that use synchronous communication. Apt [Apt86] formalized the partial-correctness argument of [DFvG83] and proved some additional properties of the algorithm. Verjus then attempted to give another proof of partial-correctness <ref> [Ver87] </ref>, but his argument was flawed [vGT90]. This suggests that showing correctness of this algorithm is non-trivial, even if synchronous communication is being assumed.
References-found: 22

