URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR366.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: A Reflective System is as Extensible as its Internal Representations: An Illustration  
Author: John Wiseman Simmons II Daniel P. Friedman 
Date: October 21, 1992  
Affiliation: Indiana University Computer Science Department  
Pubnum: Technical Report #366  
Abstract: Reflective systems are intended to be open enough to allow the user to extend and modify them easily. In this paper we show that the openness and extensibility of a reflective system depends to a great degree on the choice of its underlying representations. Giving the language the necessary expressive power requires forethought in the design stage of the kinds of extensions the user might wish to make. We illustrate this conclusion by considering what features a reflective language should have in order to implement quasi-static binding. Since quasi-static binding involves modification of the environment, it is a natural candidate for reflective implementation. We show that the ease, and even possibility, of the implementation depends on the representation choices of the underlying reflective system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Clinger, W., and Rees, J., </editor> <title> "Revised 4 report on the algorithmic language Scheme," </title> <booktitle> Lisp Pointers 4 :3, </booktitle> <pages> pp. 1-55, </pages> <year> 1991. </year> <note> Also available as a technical report from Indiana University, </note> <institution> MIT, and the University of Oregon. </institution>
Reference-contexts: Section 5 gives the details of the implementation representing quasi-static abstractions as user-defined applicable objects. Section 6 describes related work and presents the conclusion. 2 Quasi-static abstractions In a lexically scoped language such as Scheme <ref> [1, 5] </ref>, all non-global variables obtain their bindings from the enclosing lexical scope. There is no way to export a binding from one scope to another. To allow such sharing, we can declare certain variables to be quasi-static within a scope.
Reference: [2] <author> Danvy, O., and Malmkjr, K. </author> <title> Aspects of computational reflection in a programming language. </title> <note> Extended abstract (1988). </note>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown [6, 14], and Blond <ref> [2, 3, 11, 12] </ref>, allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [3] <author> Danvy, O., and Malmkjr, K. </author> <title> Intensions and Extensions in a Reflective Tower. </title> <booktitle> ACM Conference on Lisp and Functional Programming (1988) 327-341. [4] des Rivieres, </booktitle> <editor> J., and Smith, B. </editor> <booktitle> The Implementation of Procedurally Reflective Languages. Proceedings of the Symposium on Lisp and Functional Programming, ACM (August 1984) 331-347. </booktitle>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown [6, 14], and Blond <ref> [2, 3, 11, 12] </ref>, allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [5] <author> Dybvig, K. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall (1987). </publisher>
Reference-contexts: Section 5 gives the details of the implementation representing quasi-static abstractions as user-defined applicable objects. Section 6 describes related work and presents the conclusion. 2 Quasi-static abstractions In a lexically scoped language such as Scheme <ref> [1, 5] </ref>, all non-global variables obtain their bindings from the enclosing lexical scope. There is no way to export a binding from one scope to another. To allow such sharing, we can declare certain variables to be quasi-static within a scope.
Reference: [6] <author> Friedman, D., and Wand, M. </author> <title> Reification: reflection without metaphysics. </title> <booktitle> Proceedings of the Symposium on Lisp and Functional Programming ACM (August 1984) 348-355. </booktitle>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown <ref> [6, 14] </ref>, and Blond [2, 3, 11, 12], allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [7] <author> Jagannathan, S. </author> <title> Environment-based reflection. </title> <type> Technical Report 91-001-3-0050-1, </type> <institution> NEC Research Institute. Princeton, </institution> <note> NJ (January 1991). </note>
Reference-contexts: Concatenating the new binding at the bottom maintains static scoping. Placing it at the top, as in <ref> [7] </ref>, would lead to dynamic binding. In this representation, the quasi-static declaration becomes expensive, while the resolve operation is cheap. The search in the environment for a quasi-static variable is now done when it is declared quasi-static rather than when it is subsequently resolved.
Reference: [8] <author> Simmons, J., Jefferson, S., and Friedman, D. </author> <title> Language Extension via First-class Interpreters. </title> <note> Indiana University Computer Science Department Technical Report #362. REFERENCES 17 </note>
Reference: [9] <author> Lee, S., and Friedman, D. </author> <title> Quasi-static abstractions: a device for connecting variables across multiple lexical scopes. </title> <booktitle> To appear in the twentieth annual ACM Symposium on the Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: While powerful, this facility limits the extensibility of the language. For example, reifiers cannot modify variable lookup, closure creation, or procedure application|the basic features of the language. In this paper we investigate the use of a reflective system to implement quasi-static binding <ref> [9] </ref>, which uses quasi-static abstractions to allow the sharing of bindings between multiple lexical scopes. Quasi-static abstractions are closures in which certain variables are quasi-static, having no binding in the lexical scope. Quasi-static variables can later be resolved with bindings from other lexical scopes, thus allowing shared bindings.
Reference: [10] <editor> Maes, Pattie. </editor> <title> Computational reflection. </title> <type> Technical Report 87 2, </type> <institution> Artificial Intelligence Laboratory, Vrije Universiteit Brussel. </institution>
Reference: [11] <author> Malmkjr, K. </author> <title> On some semantic issues in the reflective tower. </title> <booktitle> Fifth Conference on Mathematical Foundations of Programming Semantics. Springer-Verlag, Lecture Notes in Computer Science 442 (1990). </booktitle>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown [6, 14], and Blond <ref> [2, 3, 11, 12] </ref>, allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [12] <author> Malmkjr, K. </author> <title> A Blond Primer. </title> <note> DIKU Research Report 88/21 (September 12, </note> <year> 1988). </year>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown [6, 14], and Blond <ref> [2, 3, 11, 12] </ref>, allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [13] <author> Smith, B. </author> <title> Reflection and semantics in a procedural language. </title> <month> MIT/LCS/TR-272 </month> <year> (1982). </year>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp <ref> [13, 4] </ref>, Brown [6, 14], and Blond [2, 3, 11, 12], allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
Reference: [14] <author> Wand, M., and Friedman, D. </author> <title> The mystery of the tower revealed: A non-reflective description of the reflective tower. </title> <booktitle> Lisp and Symbolic Computation 1, </booktitle> <month> 1 (June </month> <year> 1988) </year> <month> 11-38. </month>
Reference-contexts: 1 Introduction Reflective systems allow the user to extend the system at run time. The standard procedurally reflective languages, such as 3-Lisp [13, 4], Brown <ref> [6, 14] </ref>, and Blond [2, 3, 11, 12], allow the user to add new special forms to the language by writing reifying procedures, or reifiers, to be run at the level of the interpreter. While powerful, this facility limits the extensibility of the language.
References-found: 13

