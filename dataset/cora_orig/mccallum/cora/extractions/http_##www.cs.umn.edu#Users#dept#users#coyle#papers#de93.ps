URL: http://www.cs.umn.edu/Users/dept/users/coyle/papers/de93.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/coyle/papers/
Root-URL: http://www.cs.umn.edu
Title: Path Computation Algorithms for Advanced Traveller Information System (ATIS).  
Author: Shashi Shekhar, Ashim Kohli, and Mark Coyle 
Keyword: Key Words: Advanced applications, performance studies, databases.  
Address: Minneapolis, MN 55455.  
Affiliation: Computer Science Department, University of Minnesota,  
Note: Address:  
Email: email: [shekhar akohli coyle]@cs.umn.edu  
Phone: Phone: (612) 624-8307, 625-4002 Fax: (612) 625-0572  
Abstract: Path planning has been approached by graph-theoretic algorithms for all pair (transitive closure) and single-source (partial transitive) path computation in databases. These algorithms compute many more paths beyond the single pair path that is of interest to ATIS, and hence may not be satisfactory for ATIS due to the dynamic nature of edge costs (travel-time). We explore specialized algorithms for single-pair path computation which are designed to reduce irrelevant computation and to quickly discover the shortest paths. Our cost models and performance studies show that single pair algorithms can outperform traditional algorithms in many situations. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. H. Rillings and R. J. Betsold, </author> <title> Advanced Driver Information Systems, </title> <journal> Trans. on Vehicular Technology 40(1)IEEE, </journal> <month> (February </month> <year> 1991). </year>
Reference-contexts: 1. Introduction 1.1. Route Computations in Advanced Traveller Information Systems Advanced Traveller Information Systems (ATIS) assist travellers with planning, perception, analysis and decision making to improve the convenience, safety and efficiency of travel <ref> [1] </ref>. ATIS is one facet of the Intelligent Highway Vehicle System (IVHS), which is currently being developed to improve the safety and efficiency of automobile travel. Route planning is an essential component of ATIS.
Reference: 2. <author> G. F. King and T. M. Mast, </author> <title> Excess Travel: Causes, Extent and Consequences, Transport. Res. </title> <type> Rec., 1111, </type> <institution> TRB, Nat. Res. Council, </institution> <year> (1987). </year>
Reference-contexts: It aids travellers in choosing the optimal path to their destinations in terms of travel distance, travel time and other criteria. Estimates made by government agencies show that approximately 6% of all driving time in the U.S. is due to an incorrect choice of routes <ref> [2] </ref>. An effective navigation system with static route selection, coupled with real-time traffic information, is crucial to eliminating unnecessary travel time. Reducing vehicles' exposure to congestion also reduces their exposure to accidents, reduces pollution, and allows efficient calculation of routes to new destinations.
Reference: 3. <author> J. Eder, </author> <title> Extending SQL with General Transitive Closure and Extreme Value Selections, </title> <journal> Trans. on Knowledge and Data Engineering 2(4)IEEE, (1990.). </journal>
Reference: 4. <author> M. Mannino and L. D. Shapiro, </author> <title> Extensions to Query Languages for Graph Traversal Problems, </title> <journal> Trans. on Knowledge and Data Eng. </journal> <volume> 2(3)IEEE, </volume> <month> (Sept. </month> <year> 1990). </year>
Reference: 5. <author> R. Agrawal, </author> <title> Alpha: An Extension of Relational Algebra to Express a Class of Recursive Queries, </title> <journal> Trans. on Software Eng. </journal> <volume> 14(7)IEEE, </volume> <month> (July </month> <year> 1988). </year>
Reference: 6. <author> H. Lu, K. Mikkilineni, and J. P. Richardson, </author> <title> Design and Evaluation of Algorithms to Compute the Transtive Closure of a Database Relation, </title> <booktitle> Proc. Intl. Conf. on Data Eng., IEEE, </booktitle> <year> (1987). </year>
Reference-contexts: For example, partial transitive closure computation [22] and transitive closures [8] have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. <ref> [6, 10, 12, 13] </ref>. This study was based on implementing algorithms in Fortran, Quel* and Ingres. The database-based implementation outperformed main memory implementation for large graphs with more than 100 nodes.
Reference: 7. <author> J. Han, G. Qadah, and C. Chaou, </author> <title> Processing and Evaluation of Transitive Closure Queries, </title> <booktitle> Conf. on Extending Database Technology, </booktitle> <address> EDBT, </address> <year> (1988). </year>
Reference: 8. <author> H. V. Jagadish, R. Agrawal, and L. Ness, </author> <title> A Study of Transitive Closure As a Recursion Mechanism, </title> <booktitle> Proc. Conf. on Management of Data, ACM, </booktitle> <year> (1987). </year>
Reference-contexts: Traditional research in database query languages [3-5], transitive closure [6-17], and recursive query processing [18-21] has approached single-pair path computation as a special case of more general problems. For example, partial transitive closure computation [22] and transitive closures <ref> [8] </ref> have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. [6, 10, 12, 13]. This study was based on implementing algorithms in Fortran, Quel* and Ingres.
Reference: 9. <author> H. Jagadish, </author> <title> A Compressed Transitive Closure Technique for Effective Fixed-Point Query Processing, </title> <booktitle> Proc. Intl. Conf. on Expert Database Systems, </booktitle> <publisher> Benjamin Cummings, </publisher> <year> (1989). </year>
Reference: 10. <author> Shaul Dar and H. V. Jagadish, </author> <title> A Spanning Tree Transitive Closure Algorithm, </title> <booktitle> Proc. Intl. Conf. on Data Eng., IEEE, </booktitle> <year> (1992). </year>
Reference-contexts: For example, partial transitive closure computation [22] and transitive closures [8] have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. <ref> [6, 10, 12, 13] </ref>. This study was based on implementing algorithms in Fortran, Quel* and Ingres. The database-based implementation outperformed main memory implementation for large graphs with more than 100 nodes.
Reference: 11. <author> R. Agrawal, A. Borgida, and H. V. jagadish, </author> <title> Efficient Management of Transitive Relationships in Large Data Bases, </title> <booktitle> Proc. Conf. on Management of Data, ACM SIGMOD, </booktitle> <year> (1989). </year>
Reference: 12. <author> R. Agrawal and H. V. jagadish, </author> <title> Hybrid Transitive Closure Algorithms, </title> <booktitle> Proc. Int. Conf. Very Large Data Bases, VLDB, </booktitle> <year> (1990). </year>
Reference-contexts: For example, partial transitive closure computation [22] and transitive closures [8] have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. <ref> [6, 10, 12, 13] </ref>. This study was based on implementing algorithms in Fortran, Quel* and Ingres. The database-based implementation outperformed main memory implementation for large graphs with more than 100 nodes.
Reference: 13. <author> Y. Ioannidis, </author> <title> On the Computation of the Transitive Closure of Relational Operators, </title> <booktitle> Proc. Intl. Conf. on Very Large Data Bases, VLDB, </booktitle> <year> (1987). </year>
Reference-contexts: For example, partial transitive closure computation [22] and transitive closures [8] have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. <ref> [6, 10, 12, 13] </ref>. This study was based on implementing algorithms in Fortran, Quel* and Ingres. The database-based implementation outperformed main memory implementation for large graphs with more than 100 nodes. <p> This model eliminates backtracking from estimator-based A* (version 3), creating the best case for that version. We have chosen problem instances of grid graphs and parameters, such as graph sizes and path length, based on the literature <ref> [13, 24] </ref>. The parameter choice of path length is motivated by our application. Other parameters including edge-cost models are exploratory, under the hypothesis that these will impact the performance of estimator-based path computation algorithms significantly. 5.1.1.
Reference: 14. <author> P. Valduriez and S. Khoshafian, </author> <title> Transitive Closure of Transitively Closed Relations, </title> <booktitle> Proc. Itl. Conf. on Expert Database Systems, </booktitle> <publisher> Benjamin Cummings, </publisher> <year> (1989). </year>
Reference: 15. <author> I. F. Cruz and T. S. </author> <title> Novell, Aggregate Closure: An Extension of Transitive Closure, </title> <booktitle> Intl. Conf. on Data Engineering, IEEE, </booktitle> <year> (1989). </year>
Reference: 16. <author> Y. E. Ioannidis and R. Ramakrishnan, </author> <title> An Efficient Transitive Closure Algorithm, </title> <booktitle> Intl. Conf. on Very Large Data Bases, VLDB, </booktitle> <year> (1988). </year>
Reference: 17. <author> B. Jiang, </author> <title> A Suitable Algorithm for Computing Partial Transitive Closures in Databases, </title> <booktitle> Intl. Conf. on Data Engineering, IEEE, </booktitle> <year> (1990). </year>
Reference: 18. <author> F. Banchillon and R. Ramakrishnan, </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies, </title> <booktitle> Conf. on Management of Data, ACM SIGMOD, </booktitle> <year> (1986). </year>
Reference: 19. <author> F. Banchillon, </author> <title> Naive Evaluation of Recursively Defined Relations, On Knowledge Base Management Systems Integrating Database and AI Systems, </title> <publisher> Springer Verlag (Ed. Brodie, </publisher> <address> Mylopo-lous), </address> <year> (1985). </year>
Reference: 20. <author> P. Valduriez and H. Boral, </author> <title> Evaluation of Recursive Queries Using Join Indices, </title> <booktitle> Intl. Conf. Expert Database Systems, </booktitle> <year> (1986). </year>
Reference: 21. <author> Y. Kusumi, S. Nishio, and T. Hasegawa, </author> <title> File Access Level Optimization Using page Access Graph on Recursive Query Evaluation, </title> <booktitle> Proc. Conf. on Extending Database Technology, </booktitle> <address> EDTB, </address> <year> (1988). </year>
Reference: 22. <author> B. Jiang, </author> <title> I/O Efficiency of Shortest Path Algorithms: An Analysis, </title> <booktitle> Proc. Intl. Conf. on Data Eng., IEEE, </booktitle> <year> (1992). </year>
Reference-contexts: Traditional research in database query languages [3-5], transitive closure [6-17], and recursive query processing [18-21] has approached single-pair path computation as a special case of more general problems. For example, partial transitive closure computation <ref> [22] </ref> and transitive closures [8] have been used for single-pair path computations. Previous evaluation of the transitive closure algorithms examined the iterative, logarithmic, Warren's, Depth first search (DFS), hybrid, and spanning-tree-based algorithms. [6, 10, 12, 13]. This study was based on implementing algorithms in Fortran, Quel* and Ingres. <p> It cannot reduce its work for paths with few edges, because its execution time is not sensitive to path length. 3.2. Dijkstra's Algorithm Dijkstra's algorithm has been influential in path computation research <ref> [22] </ref>, but it has not been used a great deal because of its relatively poor CPU-cost. However, it provides competent worst-case I/O cost for partial transitive closure and single-pair path-computation problem [22]. <p> Dijkstra's Algorithm Dijkstra's algorithm has been influential in path computation research <ref> [22] </ref>, but it has not been used a great deal because of its relatively poor CPU-cost. However, it provides competent worst-case I/O cost for partial transitive closure and single-pair path-computation problem [22]. <p> The proof for this lemma is provided in <ref> [22] </ref>. We note that the procedure terminates after the iteration which selects destination node d as the best node in the frontier-Set.
Reference: 23. <author> T. H. Cormen, C. E. Leiserson, and R. Rivest, </author> <title> Single source shortest paths (Ch#25), Introduction to Algorithms, </title> <publisher> The MIT Press, </publisher> <year> (1990). </year>
Reference-contexts: An optimal path from node u to node v is the path with smallest cost. 3. Single Pair Algorithms 3.1. Iterative Algorithm This is one of the oldest algorithms for transitive closure, all-pair path computation, and graph traversal <ref> [23] </ref>, and is also known as the breadth-first search algorithm. The iterative algorithm can be described by the psuedo-code shown in Figure 1. Lemma 1: Procedure Iterative (N,E,s,d) finds the shortest path between nodes s and d, if the edge costs C (u,v) are non-negative.
Reference: 24. <author> R Kung, E. Hanson, Y. Ioannidis, T. Sellis, L. Shapiro, and M. Stonebraker, </author> <title> Heuristic Search in Data Base Systems, </title> <booktitle> Proc. Expert Database Systems, </booktitle> <publisher> Benjamin Cummings Publications, </publisher> <year> (1986). </year>
Reference-contexts: Best First A* Algorithms Best-first search has been a framework for heuristics which speed up algorithms by using semantic information about a domain. It has been explored in database contexts for single-pair path computation <ref> [24] </ref>. A* is a special case of best-first search algorithms. It uses an estimator function f (u,d) to estimate the cost of the shortest path between node u and d. A* has been quite influential due to its optimality properties [25]. <p> We chose three node pairs for path computation: diagonally opposite nodes, linearly opposite nodes and a random-node pair. Two-dimensional grid graphs are typical of the navigation problems in an unstructured environment. These have been used in prior studies of single-pair path computation <ref> [24] </ref>. The choice of a synthetic graph also simplifies interpretation of results. Candidate Algorithms: We chose three algorithms: Iterative, Dijkstra's, and A* (version 3). Variable Parameters: The parameters for the first set of experiments included graph size, path length, and edge cost models. <p> This model eliminates backtracking from estimator-based A* (version 3), creating the best case for that version. We have chosen problem instances of grid graphs and parameters, such as graph sizes and path length, based on the literature <ref> [13, 24] </ref>. The parameter choice of path length is motivated by our application. Other parameters including edge-cost models are exploratory, under the hypothesis that these will impact the performance of estimator-based path computation algorithms significantly. 5.1.1. <p> Selection of the best node in the frontierSet could be implemented by a scan. It has been argued that the latter implementation is cost effective, due to the smaller overhead of index maintenance <ref> [24] </ref>. We use the QUEL [24] command REPLACE instead of APPEND and DELETE in implementing all the algorithms in section 3. Estimator functions are used to select the best node on the frontierSet to be explored in current iteration. <p> Selection of the best node in the frontierSet could be implemented by a scan. It has been argued that the latter implementation is cost effective, due to the smaller overhead of index maintenance <ref> [24] </ref>. We use the QUEL [24] command REPLACE instead of APPEND and DELETE in implementing all the algorithms in section 3. Estimator functions are used to select the best node on the frontierSet to be explored in current iteration. <p> As the graph size increases, the performance of A* version 1 becomes worse than version 2. This is attributed to the fact that APPEND and DELETE operations cost more than the REPLACE operation in Ingres <ref> [24] </ref>. Another reason for this difference in performance is that the A* version 2 updates the cost and flag of a neighboring node only if the original cost of that neighbor is greater than the cost of traveling through the "current" node.
Reference: 25. <author> R. Detcher and J. Pearl, </author> <title> Generalized best-first strategies and the optimality of A*, </title> <institution> UCLA-ENG-8219, University of California, </institution> <address> Los Angeles </address> (). 
Reference-contexts: A* is a special case of best-first search algorithms. It uses an estimator function f (u,d) to estimate the cost of the shortest path between node u and d. A* has been quite influential due to its optimality properties <ref> [25] </ref>. The basic steps of these algorithms are described in figure 3.
Reference: 26. <author> D. Galperin, </author> <title> On the optimality of A*, </title> <journal> Artificial Intelligence 8(1) pp. </journal> <month> 69-76 </month> <year> (1977). </year>
Reference-contexts: The proof for Lemma 3 is provided in <ref> [26] </ref>. We note that the procedure terminates after the iteration which selects destination node d as the best node in the frontierSet. The procedures can terminate quickly if the shortest path from s to d has fewer edges. <p> Estimator functions are used to select the best node on the frontierSet to be explored in current iteration. A perfect estimator function helps the algorithm to discover the shortest path by exploring the minimum number of nodes in the graph <ref> [26] </ref>. We examine two estimator functions: euclidean distance and manhattan distance. Consider two nodes located at coordinates (x1, y1) and (x2, y2) respectively. The euclidean distance between the nodes is defined to be ddddddddddddddd ((x1-x2) 2 + (y1-y2) 2 ).
References-found: 26

