URL: http://pertsserver.cs.uiuc.edu/papers/TiLS94a.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: by  
Author: Too-Seng Tia Jane W.-S. Liu Mallikarjun Shankar 
Keyword: Aperiodic Request Scheduling  
Date: July 1994  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Note: in Fixed-Priority Preemptive Systems  
Abstract: REPORT NO. UIUCDCS-R-94-1859 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment," </title> <journal> in J. Assoc. Comput. Mach., </journal> <volume> vol. 20(1), </volume> <pages> pp. 46-61, </pages> <year> 1973. </year>
Reference-contexts: Fixed-priority preemptive scheduling of periodic tasks, such as rate-monotonic or deadline-monotonic approach, has gained popularity in recent years as it provides a sound theoretical basis for designing predictable real-time systems <ref> [1, 2] </ref>. Several algorithms have been proposed to integrate the scheduling of aperiodic requests within such a framework. These algorithms can be classified into the following two categories: 1. Bandwidth preserving server algorithms, include the priority-exchange server [3], deferrable server [4] and sporadic server [5].
Reference: [2] <author> J. Lehoczhy, L. Sha, and Y. Ding, </author> <title> "The Rate Monotonic Scheduling Algorithm Exact Characterization and Average Case Behavior," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 166-171, </pages> <year> 1989. </year>
Reference-contexts: Fixed-priority preemptive scheduling of periodic tasks, such as rate-monotonic or deadline-monotonic approach, has gained popularity in recent years as it provides a sound theoretical basis for designing predictable real-time systems <ref> [1, 2] </ref>. Several algorithms have been proposed to integrate the scheduling of aperiodic requests within such a framework. These algorithms can be classified into the following two categories: 1. Bandwidth preserving server algorithms, include the priority-exchange server [3], deferrable server [4] and sporadic server [5].
Reference: [3] <author> B. Sprunt, J. P. Lehoczky, and L. Sha, </author> <title> "Exploiting Unused Periodic Time for Aperiodic Service Using the Extended Priority Exchange Algorithm," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 251-258, </pages> <year> 1988. </year>
Reference-contexts: Several algorithms have been proposed to integrate the scheduling of aperiodic requests within such a framework. These algorithms can be classified into the following two categories: 1. Bandwidth preserving server algorithms, include the priority-exchange server <ref> [3] </ref>, deferrable server [4] and sporadic server [5]. A server is a periodic task with an execution capacity. The capacity, which is set as large as possible without affecting the schedulability of the periodic tasks, is used to execute aperiodic requests.
Reference: [4] <author> J. P. Lehoczky, L. Sha, and J. K. Strosnider, </author> <title> "Enhanced Aperiodic Scheduling in Hard-Real-Time Environments," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 261-270, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Several algorithms have been proposed to integrate the scheduling of aperiodic requests within such a framework. These algorithms can be classified into the following two categories: 1. Bandwidth preserving server algorithms, include the priority-exchange server [3], deferrable server <ref> [4] </ref> and sporadic server [5]. A server is a periodic task with an execution capacity. The capacity, which is set as large as possible without affecting the schedulability of the periodic tasks, is used to execute aperiodic requests.
Reference: [5] <author> B. Sprunt, L. Sha, and J. P. Lehoczky, </author> <title> "Aperiodic Task Scheduling for Hard Real-Time Systems," </title> <journal> The Journal of Real-Time Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 27-60, </pages> <year> 1989. </year>
Reference-contexts: Several algorithms have been proposed to integrate the scheduling of aperiodic requests within such a framework. These algorithms can be classified into the following two categories: 1. Bandwidth preserving server algorithms, include the priority-exchange server [3], deferrable server [4] and sporadic server <ref> [5] </ref>. A server is a periodic task with an execution capacity. The capacity, which is set as large as possible without affecting the schedulability of the periodic tasks, is used to execute aperiodic requests. <p> L, Algorithm G is also optimal in that it minimizes the completion time of the current backlog of work in the aperiodic service queue. 2 6 Performance Evaluation We conducted extensive simulations to compare the performance of our algorithms against three other aperiodic scheduling algorithms, namely background processing, sporadic server <ref> [5] </ref> and the greedy slack stealing algorithms [6, 8]. The sporadic server algorithm is chosen as its performance is good compared with the other bandwidth-preserving server algorithms. The simulations are conducted over ten set of periodic tasks: four synthetic and six actual real-time applications.
Reference: [6] <author> J. P. Lehoczky and S. Ramos-Thuel, </author> <title> "An Optimal Algorithm for Scheduling Soft-Aperiodic Tasks in Fixed-Priority Preemptive Systems," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 110-123, </pages> <year> 1992. </year>
Reference-contexts: Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. <p> Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. However, we will show that this assumption is not valid. <p> We will show in the next section that even a clairvoyant (i.e. one with a priori 3 knowledge of future aperiodic requests) algorithm cannot be strongly optimal. Hence, contrary to the claims in <ref> [6, 8] </ref> that their algorithms are optimal among algorithms using the first-in-first-out queueing discipline, their algorithms are not optimal. <p> A locally optimal algorithm is a valid algorithm which, among all valid algorithms, yields the minimal response time for the aperiodic request at the head of the aperiodic service queue. As in <ref> [6, 8] </ref>, we assume that overhead for context switching, task scheduling and delay in preemption are negligibly small compared with processing times of the tasks. Requests in periodic tasks are ready at the start of their periods and do not suspend themselves or synchronize with other tasks. <p> Hence, without a priori knowledge of the aperiodic requests' arrival, an on-line algorithm will not know whether to schedule each aperiodic request as soon as possible so as to minimize the average response time. 2 Theorem 1 invalidates the claim of optimality of the algorithms in <ref> [6, 8] </ref>. We now show that these algorithms may not give the minimal response time for a single aperiodic request. To do so, we consider again the periodic tasks in Figure 1 and suppose that an aperiodic request J 1 arrives at time 2. <p> On the other hand, if 1 &lt; t J 1 2, then schedule B is better. This example shows that to minimize the response time of an aperiodic request, its processing time has to be taken into consideration. For this example, the algorithms in <ref> [6, 8] </ref> would have produced schedule A. J 1 's response time would not be minimal if its processing time lies within the range (1; 2]. We will show in Section 5 how our proposed algorithm can correctly schedule J 1 . <p> J 1 's response time would not be minimal if its processing time lies within the range (1; 2]. We will show in Section 5 how our proposed algorithm can correctly schedule J 1 . The main flaw in the proofs of the algorithms' optimality in <ref> [6, 8] </ref> lies in the assumption that given any two time instants t 1 and t 2 , their algorithms are able to determine the exact upper bound on the amount of time available for executing aperiodic requests in the interval [t 1 ; t 2 ]. <p> For the above example, their algorithms would have determined 8 at time 2 that the largest amount of slack time possible in time interval <ref> [0; 6] </ref> is 1. <p> Two methods of computing the slack function, which gives the amount of slack available within an interval [t 1 ; t 2 ], have been proposed; the static method in <ref> [6] </ref> and the dynamic method in [8]. Either of these methods can be used in our algorithms to determine the amount of slack. <p> Either of these methods can be used in our algorithms to determine the amount of slack. The major difference between our algorithms and the algorithms in <ref> [6, 8] </ref> is that in [6, 8], the value of the slack function is viewed as the maximum amount of slack, and a ready aperiodic request J m is scheduled at the highest priority whenever there is slack, i.e., the value of the slack function is not zero. <p> Either of these methods can be used in our algorithms to determine the amount of slack. The major difference between our algorithms and the algorithms in <ref> [6, 8] </ref> is that in [6, 8], the value of the slack function is viewed as the maximum amount of slack, and a ready aperiodic request J m is scheduled at the highest priority whenever there is slack, i.e., the value of the slack function is not zero. <p> Hereafter, we will refer to the algorithms in <ref> [6, 8] </ref> as the greedy slack stealing algorithms. In our algorithms, this value is not viewed as the maximum amount of available slack, and it is used to determine the priority of the aperiodic request relative to the periodic requests. <p> The priority of the aperiodic request at the head of the aperiodic service queue is not necessarily the highest even when there is slack. We will elaborate on this point in the next section when we describe our algorithms. Existing Methods According to the static method proposed in <ref> [6] </ref>, the amount of slack available before the deadline of all periodic requests over the hyperperiod is precomputed and stored in a table. During run-time, these values are used to compute the actual amount of slack time available. The values are updated at the completion of each periodic request. <p> The amount of computation needed to compute the current available slack from the table is O (n), where n is the number of periodic tasks. The amount of computation needed to update the table after the completion of each periodic request is O (n) as given in <ref> [6] </ref>. <p> Our Static Method We now present the static method that our algorithms use to compute and update the available slack. This method generally resembles the method in <ref> [6] </ref>. One reason for describing our method is that in our method, the slack function is defined using the effective deadlines of the periodic requests. This definition enables us to simplify some of the proofs involving the slack function and the description of how the slack function is computed. <p> By updating C i , we need only perform O (1) computation after the completion of a periodic request. In contrast, the method given in <ref> [6] </ref> updates a quantity similar to L i at each periodic request's completion, and hence it takes O (n) for each update. <p> This is a major difference between our method for determining the amount of available slack and that given in <ref> [6] </ref>. In [6], the function A fl (t c ; t), which gives the same value as S fl (t c ; t), is taken to be the maximum amount of time available to execute aperiodic requests during [t c ; t]. <p> This is a major difference between our method for determining the amount of available slack and that given in <ref> [6] </ref>. In [6], the function A fl (t c ; t), which gives the same value as S fl (t c ; t), is taken to be the maximum amount of time available to execute aperiodic requests during [t c ; t]. We will show later that this is not the case. <p> For clarity, the periodic requests are not shown in the schedule. Schedules (a) and (b) are generated by assigning highest priority to the aperiodic requests whenever there is slack as it is done in <ref> [6, 8] </ref>. Schedule (a) uses FIFO queueing discipline and the average response time of the three aperiodic requests is 13.67. Schedule (b) uses SRPT queueing discipline and gives an average response time of 9.67 for the three aperiodic requests. <p> that it minimizes the completion time of the current backlog of work in the aperiodic service queue. 2 6 Performance Evaluation We conducted extensive simulations to compare the performance of our algorithms against three other aperiodic scheduling algorithms, namely background processing, sporadic server [5] and the greedy slack stealing algorithms <ref> [6, 8] </ref>. The sporadic server algorithm is chosen as its performance is good compared with the other bandwidth-preserving server algorithms. The simulations are conducted over ten set of periodic tasks: four synthetic and six actual real-time applications. <p> In Table 1, the periodic utilization is the total utilization of all the periodic tasks. The breakdown utilization is the maximum utilization beyond which the periodic tasks become unschedulable. The set TS1 is the same as that given in Figure 1. The set TS2 is taken from <ref> [6] </ref>. Task sets TS3 and TS4 are generated such that the period ratio, i.e. the ratio between the longest period and the shortest period among the tasks, is equal to 2. <p> As mentioned earlier, the methods used in <ref> [6, 8] </ref> to compute the slack function can also be used by our algorithms. Consequently, the extensions mentioned in [6, 8], namely to reclaim unused periodic execution time and to handle periodic tasks with release jitter, synchronization requirements due to resource sharing and arbitrary deadlines, can also be applied to our <p> As mentioned earlier, the methods used in <ref> [6, 8] </ref> to compute the slack function can also be used by our algorithms. Consequently, the extensions mentioned in [6, 8], namely to reclaim unused periodic execution time and to handle periodic tasks with release jitter, synchronization requirements due to resource sharing and arbitrary deadlines, can also be applied to our algorithms.
Reference: [7] <author> S. Ramos-Thuel and J. P. Lehoczky, </author> <title> "On-Line Scheduling of Hard Deadline Aperiodic Tasks in Fixed-Priority Systems," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 160-171, </pages> <year> 1993. </year>
Reference-contexts: Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. <p> Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. However, we will show that this assumption is not valid.
Reference: [8] <author> R. I. Davis, K. W. Tindell, and A. Burns, </author> <title> "Scheduling Slack Time in Fixed-Priority Preemptive Systems," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 222-231, </pages> <year> 1993. </year>
Reference-contexts: Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. <p> Several slack stealing algorithms have been proposed <ref> [6, 7, 8] </ref>. 1 All the previous slack stealing algorithms [6, 7, 8] assume that while there is slack available, scheduling the soft aperiodic requests at the highest priority level minimizes their response times. These algorithms were shown to be optimal when this assumption is valid. However, we will show that this assumption is not valid. <p> We will show in the next section that even a clairvoyant (i.e. one with a priori 3 knowledge of future aperiodic requests) algorithm cannot be strongly optimal. Hence, contrary to the claims in <ref> [6, 8] </ref> that their algorithms are optimal among algorithms using the first-in-first-out queueing discipline, their algorithms are not optimal. <p> A locally optimal algorithm is a valid algorithm which, among all valid algorithms, yields the minimal response time for the aperiodic request at the head of the aperiodic service queue. As in <ref> [6, 8] </ref>, we assume that overhead for context switching, task scheduling and delay in preemption are negligibly small compared with processing times of the tasks. Requests in periodic tasks are ready at the start of their periods and do not suspend themselves or synchronize with other tasks. <p> Hence, without a priori knowledge of the aperiodic requests' arrival, an on-line algorithm will not know whether to schedule each aperiodic request as soon as possible so as to minimize the average response time. 2 Theorem 1 invalidates the claim of optimality of the algorithms in <ref> [6, 8] </ref>. We now show that these algorithms may not give the minimal response time for a single aperiodic request. To do so, we consider again the periodic tasks in Figure 1 and suppose that an aperiodic request J 1 arrives at time 2. <p> On the other hand, if 1 &lt; t J 1 2, then schedule B is better. This example shows that to minimize the response time of an aperiodic request, its processing time has to be taken into consideration. For this example, the algorithms in <ref> [6, 8] </ref> would have produced schedule A. J 1 's response time would not be minimal if its processing time lies within the range (1; 2]. We will show in Section 5 how our proposed algorithm can correctly schedule J 1 . <p> J 1 's response time would not be minimal if its processing time lies within the range (1; 2]. We will show in Section 5 how our proposed algorithm can correctly schedule J 1 . The main flaw in the proofs of the algorithms' optimality in <ref> [6, 8] </ref> lies in the assumption that given any two time instants t 1 and t 2 , their algorithms are able to determine the exact upper bound on the amount of time available for executing aperiodic requests in the interval [t 1 ; t 2 ]. <p> Two methods of computing the slack function, which gives the amount of slack available within an interval [t 1 ; t 2 ], have been proposed; the static method in [6] and the dynamic method in <ref> [8] </ref>. Either of these methods can be used in our algorithms to determine the amount of slack. <p> Either of these methods can be used in our algorithms to determine the amount of slack. The major difference between our algorithms and the algorithms in <ref> [6, 8] </ref> is that in [6, 8], the value of the slack function is viewed as the maximum amount of slack, and a ready aperiodic request J m is scheduled at the highest priority whenever there is slack, i.e., the value of the slack function is not zero. <p> Either of these methods can be used in our algorithms to determine the amount of slack. The major difference between our algorithms and the algorithms in <ref> [6, 8] </ref> is that in [6, 8], the value of the slack function is viewed as the maximum amount of slack, and a ready aperiodic request J m is scheduled at the highest priority whenever there is slack, i.e., the value of the slack function is not zero. <p> Hereafter, we will refer to the algorithms in <ref> [6, 8] </ref> as the greedy slack stealing algorithms. In our algorithms, this value is not viewed as the maximum amount of available slack, and it is used to determine the priority of the aperiodic request relative to the periodic requests. <p> The amount of computation needed to update the table after the completion of each periodic request is O (n) as given in [6]. However, we will show later that this update can be reduced to O (1). 9 According to the dynamic method proposed in <ref> [8] </ref>, whenever there is an aperiodic request to be scheduled, the algorithm invokes the slack function which computes the amount of slack available for the current request of each periodic task. <p> We note that using a simple method of mapping out the schedule until the current request of every periodic task has completed, the slack can be computed in O (n 2 + l P 1 n). Comparing worst-case performance, this method is more efficient than the method proposed in <ref> [8] </ref>. The actual relative performance of the two dynamic methods, however, depends on the characteristics of the periodic tasks. One advantage of the dynamic method over the static method is that the dynamic method is able to handle periodic tasks with release jitters or synchronization requirements. <p> For clarity, the periodic requests are not shown in the schedule. Schedules (a) and (b) are generated by assigning highest priority to the aperiodic requests whenever there is slack as it is done in <ref> [6, 8] </ref>. Schedule (a) uses FIFO queueing discipline and the average response time of the three aperiodic requests is 13.67. Schedule (b) uses SRPT queueing discipline and gives an average response time of 9.67 for the three aperiodic requests. <p> that it minimizes the completion time of the current backlog of work in the aperiodic service queue. 2 6 Performance Evaluation We conducted extensive simulations to compare the performance of our algorithms against three other aperiodic scheduling algorithms, namely background processing, sporadic server [5] and the greedy slack stealing algorithms <ref> [6, 8] </ref>. The sporadic server algorithm is chosen as its performance is good compared with the other bandwidth-preserving server algorithms. The simulations are conducted over ten set of periodic tasks: four synthetic and six actual real-time applications. <p> As mentioned earlier, the methods used in <ref> [6, 8] </ref> to compute the slack function can also be used by our algorithms. Consequently, the extensions mentioned in [6, 8], namely to reclaim unused periodic execution time and to handle periodic tasks with release jitter, synchronization requirements due to resource sharing and arbitrary deadlines, can also be applied to our <p> As mentioned earlier, the methods used in <ref> [6, 8] </ref> to compute the slack function can also be used by our algorithms. Consequently, the extensions mentioned in [6, 8], namely to reclaim unused periodic execution time and to handle periodic tasks with release jitter, synchronization requirements due to resource sharing and arbitrary deadlines, can also be applied to our algorithms. <p> Hence, the practicality of our algorithms depends on the periodic task sets. Using the static method of computing slack function may incur a substantial amount of memory space overhead, while using the dynamic method 34 of computing slack function may be computationally expensive. An approximation scheme is mentioned in <ref> [8] </ref>. The aim of an approximation algorithm is to provide near optimal performance while reducing the amount of overheads required. We plan to explore this area as well.
Reference: [9] <author> K. Fowler, </author> <title> "Inertial Navigation System Simulator: Top-Level Design," </title> <type> Tech. Rep. </type> <institution> CMU/SEI-89-TR-38, Software Engineering Institute, Carnegie Mellon University, </institution> <year> 1989. </year> <month> 35 </month>
Reference-contexts: The set TS2 is taken from [6]. Task sets TS3 and TS4 are generated such that the period ratio, i.e. the ratio between the longest period and the shortest period among the tasks, is equal to 2. Task sets TS5 to TS10 are obtained from an inertial navigation system <ref> [9] </ref>, an avionics system [10], a multimedia system [11], a signal processing system [12], a submarine sonar system [13] and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics.
Reference: [10] <author> D. Locke, D. Vogel, and T. J. Mesler, </author> <title> "Building a Predictable Avionics Platform in Ada: A Case Study," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 181-189, </pages> <year> 1991. </year>
Reference-contexts: Task sets TS3 and TS4 are generated such that the period ratio, i.e. the ratio between the longest period and the shortest period among the tasks, is equal to 2. Task sets TS5 to TS10 are obtained from an inertial navigation system [9], an avionics system <ref> [10] </ref>, a multimedia system [11], a signal processing system [12], a submarine sonar system [13] and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics.
Reference: [11] <author> S. Sathaye, D. Katcher, and J. Strosnider, </author> <title> "Fixed Priority Scheduling with Limited Priority Levels," </title> <type> Tech. Rep. </type> <institution> CMU-CDS-92-7, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Task sets TS5 to TS10 are obtained from an inertial navigation system [9], an avionics system [10], a multimedia system <ref> [11] </ref>, a signal processing system [12], a submarine sonar system [13] and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics.
Reference: [12] <author> R. L. Sedlmeyer and D. J. Thuente, </author> <title> "The Application of the Rate-Monotonic Algorithm to Signal Processing Systems," in Extended Abstracts for the Current System Development Sessions, </title> <booktitle> Proceedings of Real-Time Systems Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: Task sets TS5 to TS10 are obtained from an inertial navigation system [9], an avionics system [10], a multimedia system [11], a signal processing system <ref> [12] </ref>, a submarine sonar system [13] and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics. Some of these task sets have been modified from the original specifications.
Reference: [13] <author> J. J. Molini, S. K. Maimon, and P. H. Watson, </author> <title> "Real-Time System Scenarios," </title> <booktitle> in Proceedings of the Real-Time System Symposium, </booktitle> <pages> pp. 241-225, </pages> <year> 1990. </year> <month> 36 </month>
Reference-contexts: Task sets TS5 to TS10 are obtained from an inertial navigation system [9], an avionics system [10], a multimedia system [11], a signal processing system [12], a submarine sonar system <ref> [13] </ref> and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics. Some of these task sets have been modified from the original specifications. <p> Task sets TS5 to TS10 are obtained from an inertial navigation system [9], an avionics system [10], a multimedia system [11], a signal processing system [12], a submarine sonar system <ref> [13] </ref> and a surface ship radar system [13], respectively. These task sets are chosen so as to measure the performance of the algorithms under a wide variety of task characteristics. Some of these task sets have been modified from the original specifications. These modifications are done so that the periods and execution times are integers.
References-found: 13

