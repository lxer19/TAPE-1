URL: ftp://ftp.research.microsoft.com/users/rusa/cc96.ps
Refering-URL: http://www.research.microsoft.com/analysts/
Root-URL: http://www.research.microsoft.com
Title: Points-to Analysis by Type Inference of Programs with Structures and Unions  
Author: Bjarne Steensgaard 
Keyword: interprocedural program analysis, points-to analysis, C programs, nonstandard types, constraint solving.  
Affiliation: Microsoft Research  
Abstract: We present an interprocedural flow-insensitive points-to analysis algorithm based on monomorphic type inference. The source language model the important features of C including pointers, pointer arithmetic, pointers to functions, structured objects, and unions. The algorithm is based on a non-standard type system where types represent nodes and edges in a storage shape graph. This work is an extension of previous work on performing points-to analysis of C programs in almost linear time. This work makes three new contributions. The first is an extension of a type system for describing storage shape graphs to include objects with internal structure. The second is a constraint system that can deal with arbitrary use of pointers and which incorporates a two-tier domain of pointer offsets to improve the results of the analysis. The third is an efficient inference algorithm for the constraint system, leading to an algorithm that has close to linear time and space performance in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [Ame89] <institution> American National Standards Institute, Inc. Programming language | C, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages like C <ref> [Ame89, KR88] </ref> are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]). <p> The control structures of the language are irrelevant. 2 The Source Language We describe the points-to analysis for a pointer language with structures and unions that captures the important properties of the C programming language <ref> [Ame89, KR88] </ref>. Since the analysis is flow insensitive, the control structures of the language are irrelevant. An important feature of the language is that any memory object may be accessed as a unit or as a structured object. <p> There are operations from which operand pointer values cannot be reconstituted from the result (e.g., comparisons: &lt;, 6=, etc.). For such 2 This is true for most implementations of C even though subtraction of pointers to different objects is implementation dependent according to the ANSI C specification <ref> [Ame89] </ref>. operations, the result is not required to be described by the same type as any input pointer value. We treat all primitive operations identically. The typing rule for dynamic allocation states that some pointer value is being assigned.
Reference: [And94] <author> Lars Ole Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Both algorithms are potentially more accurate than our algorithm, as their analysis results permit a location representative to have pointers to multiple other location representatives. Andersen defined a flow-insensitive, context-sensitive 4 points-to analysis in terms of constraints and constraint solving <ref> [And94] </ref>. The values being constrained are sets of abstract locations, the analysis being more conventional than the analysis presented in the present paper.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. Compilers|Principles, </author> <title> Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Functions are constant values described by the fun (: : : )!(: : : )S fl expression form 1 . The f i variables are formal parameters (sometimes called in parameters), and the r i variables are return values (sometimes called out parameters). Function calls have call-by-value semantics <ref> [ASU86] </ref>. Both formal and return parameter variables may appear in left- and right-hand-side position in statements in the function body. We assume that programs are as well-behaved as (mostly) portable C programs.
Reference: [BCCH95] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive inter--procedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing, volume 892 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> Extended version published as Research Report RC 19546, </note> <institution> IBM T.J. Watson Research Center, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Their algorithm was only developed for a language with pair structures (like cons cells in Lisp). Their algorithm has worse time and space complexity than our algorithm. Burke, et al., describes an improvement of the algorithm <ref> [BCCH95] </ref>. The improved algorithm does not deal with pointers into structured objects and has worse time and space complexity than our algorithm. Both algorithms are potentially more accurate than our algorithm, as their analysis results permit a location representative to have pointers to multiple other location representatives. <p> A context-insensitive version of Andersen's algorithm would compute results very similar to those of <ref> [BCCH95] </ref> but is likely to be faster since it is based on constraint solving rather than data flow analysis. O'Callahan and Jackson convert C programs to ML programs and use ML type inference to compute the equivalent of points-to results [OJ95].
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Henglein used type inference to perform a binding time analysis in almost linear time [Hen91]. His types represent binding time values. Our points-to analysis algorithms have been inspired by Henglein's type inference algorithm. Choi, et al., developed a flow-insensitive points-to analysis based on data flow methods <ref> [CBC93] </ref>. Their algorithm was only developed for a language with pair structures (like cons cells in Lisp). Their algorithm has worse time and space complexity than our algorithm. Burke, et al., describes an improvement of the algorithm [BCCH95].
Reference: [CR91] <editor> William Clinger and Jonathan Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme, </title> <month> November </month> <year> 1991. </year>
Reference-contexts: The implementation is performed in the Scheme programming language <ref> [CR91] </ref>. The implementation uses a weaker typing rule for primitive operations returning boolean values (thus leading to better results). It also uses predetermined transfer functions for calls of library functions, effectively making the type inference algorithm be polymorphic (context-sensitive) for all direct calls of library functions.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Points-to analysis results serve no purpose in themselves, but they are a prerequisite for most other analyses and transformations for imperative programs (e.g., computing use-def relations, permitted code motion, and detection of use of uninitialized variables). <p> The extended algorithm does not have the almost linear time complexity of the original algorithms, but it is exhibiting close to linear time complexity in practice (Sect. 5.3 discusses complexity). The algorithm is based on type inference over a domain of types that can model a storage shape graph <ref> [CWZ90] </ref>. The inferred types describe the use of memory locations. The declarations of locations are irrelevant. The algorithm computes a valid typing even when memory locations are used in inconsistent ways, in contrast to ML type inference which will fail to compute a typing in that case. <p> Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. <p> Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., [CWZ90, EGH94, WL95, Ruf95]. Both the algorithm by Chase, et al., <ref> [CWZ90] </ref> and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. The algorithm by Emami, et al., [EGH94] has a exponential time complexity (in theory and in practice), as it performs a virtual unfolding of all non-recursive calls.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In SIGPLAN'94: Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June 20-24 </month> <year> 1994. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Points-to analysis results serve no purpose in themselves, but they are a prerequisite for most other analyses and transformations for imperative programs (e.g., computing use-def relations, permitted code motion, and detection of use of uninitialized variables). <p> Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. <p> There exist many interprocedural flow-sensitive data flow analyses, e.g., [CWZ90, EGH94, WL95, Ruf95]. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. The algorithm by Emami, et al., <ref> [EGH94] </ref> has a exponential time complexity (in theory and in practice), as it performs a virtual unfolding of all non-recursive calls.
Reference: [Hen91] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 448-472, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, his implementation is not meant to deal correctly with unions. His analysis is performed during parsing of the program. Henglein used type inference to perform a binding time analysis in almost linear time <ref> [Hen91] </ref>. His types represent binding time values. Our points-to analysis algorithms have been inspired by Henglein's type inference algorithm. Choi, et al., developed a flow-insensitive points-to analysis based on data flow methods [CBC93]. Their algorithm was only developed for a language with pair structures (like cons cells in Lisp).
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages like C <ref> [Ame89, KR88] </ref> are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]). <p> The control structures of the language are irrelevant. 2 The Source Language We describe the points-to analysis for a pointer language with structures and unions that captures the important properties of the C programming language <ref> [Ame89, KR88] </ref>. Since the analysis is flow insensitive, the control structures of the language are irrelevant. An important feature of the language is that any memory object may be accessed as a unit or as a structured object.
Reference: [Lan95] <author> William Landi. </author> <title> Almost linear time points-to analyses. </title> <type> Personal communication at POPL'95, </type> <month> January </month> <year> 1995. </year>
Reference-contexts: William Landi independently arrived at the earliest of these algorithms <ref> [Lan95] </ref>. Barbara Ryder and Sean Zhang have independently developed an similar algorithm that distinguishes components of structured objects [Zha95]. They use a type system without a ? element, substituting the v operator by the = operator, thus not being as precise as our algorithm.
Reference: [LR92] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages like C [Ame89, KR88] are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., <ref> [LR92, LRZ93] </ref>). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]).
Reference: [LRZ93] <author> William A. Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages like C [Ame89, KR88] are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., <ref> [LR92, LRZ93] </ref>). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]).
Reference: [Mor95] <author> David Morgenthaler. </author> <note> Poster presentation at PLDI'95, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: They use a type system without a ? element, substituting the v operator by the = operator, thus not being as precise as our algorithm. David Morgenthaler extended our earliest algorithm to distinguish components of structured objects <ref> [Mor95] </ref>. His algorithm also uses a type system without a ? element and does not incorporate pointer offsets in the constraint system. Furthermore, his implementation is not meant to deal correctly with unions. His analysis is performed during parsing of the program.
Reference: [OJ95] <author> Robert O'Callahan and Daniel Jackson. </author> <title> Detecting shared representations using type inference. </title> <type> Technical Report CMU-CS-95-202, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: O'Callahan and Jackson convert C programs to ML programs and use ML type inference to compute the equivalent of points-to results <ref> [OJ95] </ref>. Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., [CWZ90, EGH94, WL95, Ruf95].
Reference: [Ruf95] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Points-to analysis results serve no purpose in themselves, but they are a prerequisite for most other analyses and transformations for imperative programs (e.g., computing use-def relations, permitted code motion, and detection of use of uninitialized variables). <p> Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. <p> There exist many interprocedural flow-sensitive data flow analyses, e.g., [CWZ90, EGH94, WL95, Ruf95]. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm <ref> [Ruf95] </ref> are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. The algorithm by Emami, et al., [EGH94] has a exponential time complexity (in theory and in practice), as it performs a virtual unfolding of all non-recursive calls.
Reference: [Ste95] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <type> Technical Report MSR-TR-95-08, </type> <institution> Microsoft Research, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Type t 7 represents both structured variables in the program. The third type component, t 10 , of t 7 represents structure elements s1.c, s2.f and s2.g. We extend our previous work on flow-insensitive interprocedural points-to analysis of C programs by type inference methods <ref> [Ste96, Ste95] </ref> by enabling the algorithm to distinguish between components of structured objects, thereby increasing the precision of the analysis in the presence of structures and unions in the program to be analyzed. <p> and process time on a 150MHz Indigo2 running Chez Scheme) and number of extra distinguishable structure components relative to our previous algorithm [Ste96]. 7 Related Work The algorithm presented in this paper is an extension of two almost-linear points-to analysis algorithms that did not distinguish between components of structured objects <ref> [Ste96, Ste95] </ref>. William Landi independently arrived at the earliest of these algorithms [Lan95]. Barbara Ryder and Sean Zhang have independently developed an similar algorithm that distinguishes components of structured objects [Zha95]. <p> This work is part of an effort to construct very efficient points-to analysis algorithms for large programs. We have found type inference methods a very useful tool for doing so. The algorithms presented in this paper and in previous papers <ref> [Ste96, Ste95] </ref> are based on monomorphic type inference methods. We have also investigated extending the algorithm of [Ste96] to use polymorphic type inference methods. We have yet to combine the extensions to generate an context-sensitive (polymorphic) points-to algorithm that can distinguish between elements of structured objects.
Reference: [Ste96] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings 23rd SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Type t 7 represents both structured variables in the program. The third type component, t 10 , of t 7 represents structure elements s1.c, s2.f and s2.g. We extend our previous work on flow-insensitive interprocedural points-to analysis of C programs by type inference methods <ref> [Ste96, Ste95] </ref> by enabling the algorithm to distinguish between components of structured objects, thereby increasing the precision of the analysis in the presence of structures and unions in the program to be analyzed. <p> We could have used equality (=) instead of v ordering. The primary reason for not doing so is discussed in <ref> [Ste96] </ref>. Of particular importance to the type system used in the present paper is that use of v rather than = permits non-pointer content of components of struct mappings when a value in a struct location is assigned to an object location. <p> O (Sff (S; S)) time complexity, where ff is the inverse Ackerman's function [Tar83]. The ff (S; S) component of the time complexity is due to the use of fast union/find data structures. This complexity result is equal to that of our previous algorithm <ref> [Ste96] </ref>. Constraints involving struct types may require processing all the element types in addition to any joins being performed. If all structures have R or fewer elements, the algorithm has an O (S) space and O (RSff (S; S)) time complexity. <p> The programs are a subset of the programs in William Landi's test suite, Todd Austin's test suite, the SPEC92 benchmarks, and LambdaMOO (version 1.7.1) from Xerox PARC. These programs are the same we presented results for in our previous paper <ref> [Ste96] </ref>. We have also included information on analysis of a Microsoft tool of 75,000 lines of C code. The first column indicates running time for our implementation of the algorithm. The time is the result of a single measurement. The time includes initial setup and type inference. <p> The first column indicates running time for our implementation of the algorithm. The time is the result of a single measurement. The time includes initial setup and type inference. The runtime measurements are not directly comparable with the runtime measurements presented in <ref> [Ste96] </ref> as the old implementation was able to use a trick to reduce the number of initial type variables by 50%. The second column indicates the number of extra distinguishable elements of structured objects compared with our previous algorithm [Ste96]. <p> measurements are not directly comparable with the runtime measurements presented in <ref> [Ste96] </ref> as the old implementation was able to use a trick to reduce the number of initial type variables by 50%. The second column indicates the number of extra distinguishable elements of structured objects compared with our previous algorithm [Ste96]. An object with two distinguishable elements will thus contribute a count of one to this number. These numbers are very significant as they in most cases represent separation of distinguishable elements in central data structures. <p> spec:espresso 30.0/22.2s 121 spec:li 8.96/6.47s 41 spec:sc 10.8/8.08s 12 spec:alvinn 0.28/0.27s 0 spec:ear 2.40/2.12s 6 LambdaMOO 25.3/19.5s 147 MS tool 95.4/58.7s 1747 Table 1: Running time (wall time and process time on a 150MHz Indigo2 running Chez Scheme) and number of extra distinguishable structure components relative to our previous algorithm <ref> [Ste96] </ref>. 7 Related Work The algorithm presented in this paper is an extension of two almost-linear points-to analysis algorithms that did not distinguish between components of structured objects [Ste96, Ste95]. William Landi independently arrived at the earliest of these algorithms [Lan95]. <p> and process time on a 150MHz Indigo2 running Chez Scheme) and number of extra distinguishable structure components relative to our previous algorithm [Ste96]. 7 Related Work The algorithm presented in this paper is an extension of two almost-linear points-to analysis algorithms that did not distinguish between components of structured objects <ref> [Ste96, Ste95] </ref>. William Landi independently arrived at the earliest of these algorithms [Lan95]. Barbara Ryder and Sean Zhang have independently developed an similar algorithm that distinguishes components of structured objects [Zha95]. <p> This work is part of an effort to construct very efficient points-to analysis algorithms for large programs. We have found type inference methods a very useful tool for doing so. The algorithms presented in this paper and in previous papers <ref> [Ste96, Ste95] </ref> are based on monomorphic type inference methods. We have also investigated extending the algorithm of [Ste96] to use polymorphic type inference methods. We have yet to combine the extensions to generate an context-sensitive (polymorphic) points-to algorithm that can distinguish between elements of structured objects. <p> We have found type inference methods a very useful tool for doing so. The algorithms presented in this paper and in previous papers [Ste96, Ste95] are based on monomorphic type inference methods. We have also investigated extending the algorithm of <ref> [Ste96] </ref> to use polymorphic type inference methods. We have yet to combine the extensions to generate an context-sensitive (polymorphic) points-to algorithm that can distinguish between elements of structured objects.
Reference: [Tar83] <author> Robert E. Tarjan. </author> <title> Data structures and network flow algorithms. </title> <booktitle> In Regional Conference Series in Applied Mathematics, </booktitle> <volume> volume CMBS 44. </volume> <publisher> SIAM, </publisher> <year> 1983. </year>
Reference-contexts: O (Sff (S; S)) time complexity, where ff is the inverse Ackerman's function <ref> [Tar83] </ref>. The ff (S; S) component of the time complexity is due to the use of fast union/find data structures. This complexity result is equal to that of our previous algorithm [Ste96]. Constraints involving struct types may require processing all the element types in addition to any joins being performed.
Reference: [WCES94] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Proceedings 21st SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-310, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: with program size, the growth is controlled by the tendency of programmers to group structure elements in substructures when the number of elements grows large. 6 Experience We have implemented a slightly improved version of the above algorithm in our prototype programming system based on the Value Dependence Graph (VDG) <ref> [WCES94] </ref>. The implementation is performed in the Scheme programming language [CR91]. The implementation uses a weaker typing rule for primitive operations returning boolean values (thus leading to better results).
Reference: [WL95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Points-to analysis results serve no purpose in themselves, but they are a prerequisite for most other analyses and transformations for imperative programs (e.g., computing use-def relations, permitted code motion, and detection of use of uninitialized variables). <p> Not all C programs can be converted to ML by their techniques, and even then their algorithm may compute unsafe results due to type casts in the source program. There exist many interprocedural flow-sensitive data flow analyses, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. Both the algorithm by Chase, et al., [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive. <p> The two other algorithms are context-sensitive. The algorithm by Emami, et al., [EGH94] has a exponential time complexity (in theory and in practice), as it performs a virtual unfolding of all non-recursive calls. The algorithm by Wilson and Lam <ref> [WL95] </ref> also has exponential time complexity but is likely to exhibit polynomial time complexity in practice as it uses partial transfer functions to summarize the behavior of already analyzed functions and procedures. 8 Conclusion and Future Work We have presented a flow-insensitive, interprocedural, context-insensitive points-to analysis based on type inference methods.
Reference: [Zha95] <author> Sean Zhang. </author> <note> Poster presentation at PLDI'95, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: William Landi independently arrived at the earliest of these algorithms [Lan95]. Barbara Ryder and Sean Zhang have independently developed an similar algorithm that distinguishes components of structured objects <ref> [Zha95] </ref>. They use a type system without a ? element, substituting the v operator by the = operator, thus not being as precise as our algorithm. David Morgenthaler extended our earliest algorithm to distinguish components of structured objects [Mor95].
References-found: 22

