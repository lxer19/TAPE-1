URL: http://www.cs.toronto.edu/~vassos/research/publications/CHTCB96/paper.ps.gz
Refering-URL: http://www.cs.toronto.edu/~vassos/research/list-of-publications.html
Root-URL: 
Title: On the Impossibility of Group Membership  
Author: Tushar Deepak Chandra Vassos Hadzilacos Sam Toueg Bernadette Charron-Bost 
Abstract: We prove that the primary-partition group membership problem cannot be solved in asynchronous systems with crash failures, even if one allows the removal or killing of non-faulty processes that are erroneously suspected to have crashed. 
Abstract-found: 1
Intro-found: 1
Reference: [ACBMT95] <author> Emmanuelle Anceaume, Bernadette Charron-Bost, Pascale Minet, and Sam Toueg. </author> <title> On the formal specification of group membership services. </title> <type> Technical Report 95-1534, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, New York 14853, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Yet, despite the wide interest that it has attracted and the numerous publications on this subject, the group membership problem for asynchronous systems is far from being understood: In particular, there is no agreed definition for this problem, and some of the most referenced formal definitions are unsatisfactory <ref> [ACBMT95] </ref>. Despite their differences, all versions of the group membership problem require some form of process agreement in systems with failures. Another well-known problem requiring agreement in spite of failures is Consensus. <p> Some implementations of primary-partition group membership do not satisfy this liveness re quirement: They have runs that "block" forever, or remove or kill all processes. 2 It is not clear, however, what liveness property (if any) such implementations do satisfy <ref> [ACBMT95] </ref>. 2 For example, in the implementation of S-GMP [RB91, Ric93] it is possible for all processes to kill themselves before any new view is installed. <p> However, they run into another fundamental problem: their specification must be strong enough to rule out useless group membership protocols, and yet it should be weak enough to remain solvable. The design of such a specification is still a subject of active research <ref> [ACBMT95, BDM95, DMS96] </ref>. Acknowledgements We are grateful to Lorenzo Alvisi and Prasad Jayanti for their insightful comments on an earlier version of this paper. We also thank Roy Fried-man, Gerard LeLann, Pascale Minet, and Robbert van Renessee for their helpful suggestions.
Reference: [ADKM92] <author> Yair Amir, Danny Dolev, Shlomo Kramer, and Dalia Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proceedings of the 6th International Workshop on Distributed Algorithms (WDAG - 6), (LCNS, </booktitle> <volume> 647), </volume> <pages> pages 292-312, </pages> <month> Novem-ber </month> <year> 1992. </year>
Reference-contexts: These differences appear to make group membership weaker than Consensus, and in fact the first one has been widely cited as a reason why group membership is solvable in asynchronous systems while Consensus is not <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>. <p> It is important to note that this impossibility result applies to group membership services that are allowed to remove from the group, and even kill, an arbitrary number of non-faulty processes that did not wish to be removed. Thus, contrary to a widespread view <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>, the removal or killing of processes that are suspected to have crashed does not contribute to the solvability of the primary-partition group membership problem.
Reference: [BDGB94] <author> Ozalp Babaoglu, Renzo Davoli, Luigi-Alberto Giachini, and Mary Gray Baker. RELACS: </author> <title> a communications infrastructure for constructing reliable applications in large-scale distributed systems. BROADCAST Project deliverable report, 1994. </title> <institution> Department of Computing Science, University of Newcastle upon Tyne, UK. </institution>
Reference-contexts: One of the reasons why WGM is weak is that it makes no attempt to "track" failures: In contrast to most existing group membership services whose goal is to maintain a set of processes that are deemed to be operational (e.g., <ref> [RB91, JFR93, BDGB94, DMS94, MSMA94] </ref>), WGM does not link the membership of the group with actual or suspected crashes. <p> So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [BDM95] <author> Ozalp Babaoglu, Renzo Davoli, and Alberto Montresor. </author> <title> Failure detectors, group membership and view-synchronous communication in parti-tionable asynchronous systems (preliminary version). </title> <type> Technical Report UBLCS-95-18, </type> <institution> Department of Computer Science, University of Bologna, Bologna, Italy, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: However, they run into another fundamental problem: their specification must be strong enough to rule out useless group membership protocols, and yet it should be weak enough to remain solvable. The design of such a specification is still a subject of active research <ref> [ACBMT95, BDM95, DMS96] </ref>. Acknowledgements We are grateful to Lorenzo Alvisi and Prasad Jayanti for their insightful comments on an earlier version of this paper. We also thank Roy Fried-man, Gerard LeLann, Pascale Minet, and Robbert van Renessee for their helpful suggestions.
Reference: [Ben83] <author> Michael Ben-Or. </author> <title> Another advantage of free choice: Completely asynchronous agreement protocols. </title> <booktitle> In Proceedings of the Second ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 27-30, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: After Fischer, Lynch and Paterson proved the impossibility of Consensus, researchers looked for ways to "circumvent" this negative result. First among these were the randomized algorithm of Ben-Or <ref> [Ben83] </ref>, the probabilistic algorithm of Bracha and Toueg [BT83], and the algorithm by Rabin that assumes a shared sequence of random bits [Rab83]. <p> In fact, we conjecture that it is possible to provide a realistic primary-partition group membership service, with precise liveness guarantees, if one uses randomization (as in <ref> [Ben83, Rab83] </ref>), or makes well-defined probability assumptions on the behavior of the environment (as in [BT83]), or uses failure detectors with well-defined properties (as in [CT91]). 3 In contrast to primary-partition group membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views
Reference: [BJ87] <author> Kenneth P. Birman and Thomas A. Joseph. </author> <title> Exploiting virtual synchrony in distributed systems. </title> <booktitle> In Proceedings of the 11th Annual Symposium Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: When the definitions need to be adjusted to the new context (WGM instead of Consensus) we explain the necessary modifications. 1 Most group membership services have such requirements. For example, the Virtual Synchrony property of ISIS requires the total ordering of multicasts with respect to view changes <ref> [BJ87] </ref>. Each process is modelled as an automaton. The internal state of each process p contains, among other things, an input register x p and an output register y p .
Reference: [BS94] <author> Ozalp Babaoglu and Andre Schiper. </author> <title> On group communication in large scale distributed systems. </title> <booktitle> In Proceedings of the ACM SIGOPS Euro-pean Workshop, </booktitle> <address> Dagstuhl, Germany, </address> <month> September </month> <year> 1994. </year>
Reference: [BT83] <author> Gabriel Bracha and Sam Toueg. </author> <title> Resilient consensus protocols. </title> <booktitle> In Proceedings of the Second ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 12-26, </pages> <month> August </month> <year> 1983. </year> <note> An extended and revised version appeared as "Asynchronous consensus and broadcast protocols" in the Journal of the ACM, 32(4) 824-840, Octo-ber 1985. </note>
Reference-contexts: After Fischer, Lynch and Paterson proved the impossibility of Consensus, researchers looked for ways to "circumvent" this negative result. First among these were the randomized algorithm of Ben-Or [Ben83], the probabilistic algorithm of Bracha and Toueg <ref> [BT83] </ref>, and the algorithm by Rabin that assumes a shared sequence of random bits [Rab83]. <p> In fact, we conjecture that it is possible to provide a realistic primary-partition group membership service, with precise liveness guarantees, if one uses randomization (as in [Ben83, Rab83]), or makes well-defined probability assumptions on the behavior of the environment (as in <ref> [BT83] </ref>), or uses failure detectors with well-defined properties (as in [CT91]). 3 In contrast to primary-partition group membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership
Reference: [CD89] <author> Benny Chor and Cynthia Dwork. </author> <title> Randomization in byzantine agreement. </title> <publisher> Advances in Computer Research (JAI Press Inc.), </publisher> <pages> 4 443-497, </pages> <year> 1989. </year>
Reference-contexts: These algorithms solve Consensus with probability 1: even though they admit non-terminating runs, such runs are shown to have probability 0, and Consensus is reached within a finite expected number of steps (for a survey of randomized Consensus algorithms see <ref> [CD89] </ref>). A different way to "circumvent" the impossibility of Consensus, is the addition of (unreliable) failure detectors to the asynchronous model of computation: [CT91] shows that Consensus can be solved using failure detectors that can make an infinite number of mistakes.
Reference: [Cri91] <author> Flaviu Cristian. </author> <title> Reaching agreement on processor group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 175-187, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: A group membership protocol must manage such dynamic changes in some coherent way. In this paper we consider group membership protocols that ensure processes agree on the current membership of the group. The group membership problem was first defined for synchronous systems by <ref> [Cri91] </ref>. Since then, the group membership problem for asynchronous systems has also been the subject of intense investigation (e.g., [KT91, MPS91, RB91, VVR92, JFR93, vRBC + 93, BDGB94, BS94, DMS94, EMS95, MSMA94]).
Reference: [CT91] <author> Tushar Deepak Chandra and Sam Toueg. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1991. </year> <note> To appear in the Journal of the ACM. An extended and revised version is also available by anonymous ftp from ftp.cs.cornell.edu in pub/chandra/failure.detectors.algorithms.dvi.Z. </note>
Reference-contexts: A different way to "circumvent" the impossibility of Consensus, is the addition of (unreliable) failure detectors to the asynchronous model of computation: <ref> [CT91] </ref> shows that Consensus can be solved using failure detectors that can make an infinite number of mistakes. <p> fact, we conjecture that it is possible to provide a realistic primary-partition group membership service, with precise liveness guarantees, if one uses randomization (as in [Ben83, Rab83]), or makes well-defined probability assumptions on the behavior of the environment (as in [BT83]), or uses failure detectors with well-defined properties (as in <ref> [CT91] </ref>). 3 In contrast to primary-partition group membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the
Reference: [DKM93] <author> Danny Dolev, Shlomo Kramer, and Dalia Malki. </author> <title> Early delivery totally ordered multicast in asynchronous environment. </title> <booktitle> In Proceedings of the 23th Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 544-553, </pages> <address> Toulouse, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: These differences appear to make group membership weaker than Consensus, and in fact the first one has been widely cited as a reason why group membership is solvable in asynchronous systems while Consensus is not <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>. <p> It is important to note that this impossibility result applies to group membership services that are allowed to remove from the group, and even kill, an arbitrary number of non-faulty processes that did not wish to be removed. Thus, contrary to a widespread view <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>, the removal or killing of processes that are suspected to have crashed does not contribute to the solvability of the primary-partition group membership problem.
Reference: [DMS94] <author> Danny Dolev, Dalia Malki, and Ray Strong. </author> <title> An asynchronous membership protocol that tolerates partitions. </title> <type> Technical Report CS94-6, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1994. </year>
Reference-contexts: These differences appear to make group membership weaker than Consensus, and in fact the first one has been widely cited as a reason why group membership is solvable in asynchronous systems while Consensus is not <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>. <p> One of the reasons why WGM is weak is that it makes no attempt to "track" failures: In contrast to most existing group membership services whose goal is to maintain a set of processes that are deemed to be operational (e.g., <ref> [RB91, JFR93, BDGB94, DMS94, MSMA94] </ref>), WGM does not link the membership of the group with actual or suspected crashes. <p> So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> It is important to note that this impossibility result applies to group membership services that are allowed to remove from the group, and even kill, an arbitrary number of non-faulty processes that did not wish to be removed. Thus, contrary to a widespread view <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>, the removal or killing of processes that are suspected to have crashed does not contribute to the solvability of the primary-partition group membership problem. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [DMS95] <author> Danny Dolev, Dalia Malki, and Ray Strong. </author> <title> A framework for partition-able membership service. </title> <type> Technical Report CS95-4, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <year> 1995. </year>
Reference-contexts: So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [DMS96] <author> Danny Dolev, Dalia Malki, and Ray Strong. </author> <title> A framework for partitionable membership service. </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Philadephia, PA, </address> <year> 1996. </year>
Reference-contexts: However, they run into another fundamental problem: their specification must be strong enough to rule out useless group membership protocols, and yet it should be weak enough to remain solvable. The design of such a specification is still a subject of active research <ref> [ACBMT95, BDM95, DMS96] </ref>. Acknowledgements We are grateful to Lorenzo Alvisi and Prasad Jayanti for their insightful comments on an earlier version of this paper. We also thank Roy Fried-man, Gerard LeLann, Pascale Minet, and Robbert van Renessee for their helpful suggestions.
Reference: [EMS95] <author> Paul D. Ezhilchelvan, Raimundo A. Mac^edo, and Santosh K. Shrivastava. Newtop: </author> <title> a fault-tolerant group communication protocol. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <address> Van-couver, BC, Canada, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: These differences appear to make group membership weaker than Consensus, and in fact the first one has been widely cited as a reason why group membership is solvable in asynchronous systems while Consensus is not <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>. <p> So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> It is important to note that this impossibility result applies to group membership services that are allowed to remove from the group, and even kill, an arbitrary number of non-faulty processes that did not wish to be removed. Thus, contrary to a widespread view <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>, the removal or killing of processes that are suspected to have crashed does not contribute to the solvability of the primary-partition group membership problem. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [FLP85] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Another well-known problem requiring agreement in spite of failures is Consensus. This problem, however, cannot be solved in asynchronous systems even if commu nication is reliable, only one process may fail, and it can do so only by crashing, i.e., if it stops executing steps <ref> [FLP85] </ref>. Since the purpose of group membership is to ensure some kind of agreement among processes (on the membership of a dynamically changing set), the potential for running into a similar impossibility result is obvious. <p> The <ref> [FLP85] </ref> model does not speak about process removals, and it does not directly model process killing (i.e., program-controlled crashes). * Consensus requires progress in all runs, while group membership allows runs that "do nothing" (for instance, "doing nothing" is desirable when no process wishes to join or leave the group, and <p> We first show the impossibility of WGM in systems where communication is reliable and where at most one process may crash, exactly as in <ref> [FLP85] </ref>. We then extend this negative result to systems that allow program-controlled process crashes. <p> Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. In Section 3, we show the impossibility of WGM in the <ref> [FLP85] </ref> model of asynchronous systems. The proof is patterned after the one given in [FLP85] with the exception of the starting lemma. In Section 4 we strengthen this impossibility result in various ways, and in Section 5 we extend it to systems that allow program-controlled crashes. <p> The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. In Section 3, we show the impossibility of WGM in the <ref> [FLP85] </ref> model of asynchronous systems. The proof is patterned after the one given in [FLP85] with the exception of the starting lemma. In Section 4 we strengthen this impossibility result in various ways, and in Section 5 we extend it to systems that allow program-controlled crashes. <p> The informal specification of WGM given here is sufficient to understand the scope and meaning of our result; a formal specification in terms of the model of <ref> [FLP85] </ref> is given in the next section. Consider a system with n 4 processes p 1 ; p 2 ; : : : ; p n , that can fail only by crashing, i.e., by stopping to execute steps. <p> In other words, there are no restrictions whatsoever on message delivery, and in particular on the way such deliv eries interleave with view changes. 1 3 Impossibility of WGM in the <ref> [FLP85] </ref> Model We now formally define the WGM problem and show that it cannot be solved in the [FLP85] model of distributed computing, namely, in asynchronous systems with reliable communication where at most one process may crash. <p> In other words, there are no restrictions whatsoever on message delivery, and in particular on the way such deliv eries interleave with view changes. 1 3 Impossibility of WGM in the <ref> [FLP85] </ref> Model We now formally define the WGM problem and show that it cannot be solved in the [FLP85] model of distributed computing, namely, in asynchronous systems with reliable communication where at most one process may crash. The proof is very similar to the one of Fischer, Lynch and Paterson in [FLP85]. <p> Model We now formally define the WGM problem and show that it cannot be solved in the <ref> [FLP85] </ref> model of distributed computing, namely, in asynchronous systems with reliable communication where at most one process may crash. The proof is very similar to the one of Fischer, Lynch and Paterson in [FLP85]. Essentially, the only difference stems from the fact that Consensus requires "termination" in all executions, while WGM does not. This affects principally one lemma | the only one whose proof we give in detail here. The main features of the [FLP85] model are informally highlighted below. * The system consists <p> to the one of Fischer, Lynch and Paterson in <ref> [FLP85] </ref>. Essentially, the only difference stems from the fact that Consensus requires "termination" in all executions, while WGM does not. This affects principally one lemma | the only one whose proof we give in detail here. The main features of the [FLP85] model are informally highlighted below. * The system consists of n processes p 1 ; p 2 ; : : :; p n , that communicate by sending messages over a completely connected point-to-point network. <p> We expect readers to be familiar with the formalization of this model given in <ref> [FLP85] </ref>. We therefore do not repeat the definitions of terms already defined in that paper. Instead, we use boldface to indicate the first occurrence of a technical term borrowed from [FLP85]. <p> We expect readers to be familiar with the formalization of this model given in <ref> [FLP85] </ref>. We therefore do not repeat the definitions of terms already defined in that paper. Instead, we use boldface to indicate the first occurrence of a technical term borrowed from [FLP85]. When the definitions need to be adjusted to the new context (WGM instead of Consensus) we explain the necessary modifications. 1 Most group membership services have such requirements. For example, the Virtual Synchrony property of ISIS requires the total ordering of multicasts with respect to view changes [BJ87]. <p> The former holds a binary value indicating whether p initially wishes to leave the group G or not (x p = 1 or x p = 0, respectively). (In <ref> [FLP85] </ref> x p indicates p's input value for Consensus.) The range of the output register y p is a subset of V init = fp 1 ; : : : ; p n g. <p> After its initial setting, y p may be written at most once. When (and if) p writes V V init into y p , we say that p installs new view V . (In <ref> [FLP85] </ref>, the output register y p is initially "blank" and is written at most once with process p's decision value of the Consensus.) An initial configuration can be uniquely identified by a bit vector of length n that gives the value of x p i for each p i , 1 <p> Formally, V C = fV j9C 0 ; 9p : C 0 is reachable from C, and in C 0 y p = V g. We say that C is bivalent if jV C j 2. (In <ref> [FLP85] </ref>, C is bivalent if the set of decision values of configurations reachable from C contains two elements.) The impossibility proof of [FLP85] is structured as follows. It first shows that a bivalent initial configuration exists. <p> We say that C is bivalent if jV C j 2. (In <ref> [FLP85] </ref>, C is bivalent if the set of decision values of configurations reachable from C contains two elements.) The impossibility proof of [FLP85] is structured as follows. It first shows that a bivalent initial configuration exists. Then, starting from that biva-lent configuration, it constructs an admissible run in which no process decides | contradicting the termination requirement of Consensus (which requires that every admissible run be a deciding run). <p> Proof (Sketch): Let C be a bivalent configuration in fC 01 ; C 10 ; C 11 g (by Lemma 1 such a C exists). We can now apply the techniques of <ref> [FLP85] </ref> to construct an infinite admissible run that starts from bivalent C and remains bivalent forever: In this run, no process ever installs a new view | a contradiction to the first requirement of WGM. 2 4 Strengthening the Impossi bility Result Our specification of WGM allows processes to voluntarily request <p> This causes p to actually crash, i.e., to stop executing steps. This program-controlled crash is indistinguishable from a "genuine" crash that is due to, say, a hardware failure. The model of <ref> [FLP85] </ref> does not quite capture such program-controlled crashes: in that model a process does not have the ability to stop taking steps if it wants to. Since we use the [FLP85] model to prove the impossibility of WGM (Theorem 1), one may ask whether our negative result still holds if program-controlled <p> The model of <ref> [FLP85] </ref> does not quite capture such program-controlled crashes: in that model a process does not have the ability to stop taking steps if it wants to. Since we use the [FLP85] model to prove the impossibility of WGM (Theorem 1), one may ask whether our negative result still holds if program-controlled crashes are allowed. To see why this question is pertinent, consider the proof of impossibility of WGM based on the [FLP85] model. <p> Since we use the <ref> [FLP85] </ref> model to prove the impossibility of WGM (Theorem 1), one may ask whether our negative result still holds if program-controlled crashes are allowed. To see why this question is pertinent, consider the proof of impossibility of WGM based on the [FLP85] model. This proof constructs an admissible run in which every process takes an infinite number of steps but never installs a new view. It is crucial for this construction that every process be capable of taking the next step at any point in time. This is true in the [FLP85] <p> <ref> [FLP85] </ref> model. This proof constructs an admissible run in which every process takes an infinite number of steps but never installs a new view. It is crucial for this construction that every process be capable of taking the next step at any point in time. This is true in the [FLP85] model, but is not true if we allow program-controlled crashes: once a process has executed a crash event, it cannot be required to take a next step. Thus, the argument of [FLP85] cannot be directly applied to systems that allow program-controlled crashes. <p> This is true in the <ref> [FLP85] </ref> model, but is not true if we allow program-controlled crashes: once a process has executed a crash event, it cannot be required to take a next step. Thus, the argument of [FLP85] cannot be directly applied to systems that allow program-controlled crashes. It turns out that the impossibility of WGM is not limited to the [FLP85] model: this negative result holds even if we allow program-controlled crashes. To show this, we must first model asynchronous distributed systems with program-controlled crashes. <p> Thus, the argument of <ref> [FLP85] </ref> cannot be directly applied to systems that allow program-controlled crashes. It turns out that the impossibility of WGM is not limited to the [FLP85] model: this negative result holds even if we allow program-controlled crashes. To show this, we must first model asynchronous distributed systems with program-controlled crashes. Let M denote the model of [FLP85]. <p> It turns out that the impossibility of WGM is not limited to the <ref> [FLP85] </ref> model: this negative result holds even if we allow program-controlled crashes. To show this, we must first model asynchronous distributed systems with program-controlled crashes. Let M denote the model of [FLP85]. Recall that in M each process is an automaton, and at most one process can stop executing steps at any state.
Reference: [HS95] <author> Matti A. Hiltunen and Richard D. Schlichting. </author> <title> Properties of membership services. </title> <booktitle> In Proceedings of the 2nd International Symposium on Autonomous Decentralized Systems, </booktitle> <address> Phoenix, AZ, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: It is important to note that our result applies only to group membership services that attempt to maintain a single agreed view of the current membership of a group (e.g., <ref> [RB91, KT91, MPS91, MSMA94, HS95] </ref>). These are known as primary-partition group membership services and are intended for systems with no network partitions, or for systems that allow the group membership to change in at most one network partition, the "primary partition".
Reference: [JFR93] <author> Farnam Jahanian, Sameh Fakhouri, and Ragunathan Rajkumar. </author> <title> Processor group membership protocols: specification, </title> <booktitle> design and implementation. In Proceeding of the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Prince-ton, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: One of the reasons why WGM is weak is that it makes no attempt to "track" failures: In contrast to most existing group membership services whose goal is to maintain a set of processes that are deemed to be operational (e.g., <ref> [RB91, JFR93, BDGB94, DMS94, MSMA94] </ref>), WGM does not link the membership of the group with actual or suspected crashes. <p> So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [KT91] <author> M. Frans Kaashoek and Andrew S. Tanenbaum. </author> <title> Group communication in the amoeba distributed operating system. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 222-230, </pages> <address> Arlington, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: It is important to note that our result applies only to group membership services that attempt to maintain a single agreed view of the current membership of a group (e.g., <ref> [RB91, KT91, MPS91, MSMA94, HS95] </ref>). These are known as primary-partition group membership services and are intended for systems with no network partitions, or for systems that allow the group membership to change in at most one network partition, the "primary partition".
Reference: [MPS91] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Proceedings of the IEEE International Working Conference on Dependable Computing For Critical Applications, </booktitle> <pages> pages 137-145, </pages> <address> Tucson, AZ, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: It is important to note that our result applies only to group membership services that attempt to maintain a single agreed view of the current membership of a group (e.g., <ref> [RB91, KT91, MPS91, MSMA94, HS95] </ref>). These are known as primary-partition group membership services and are intended for systems with no network partitions, or for systems that allow the group membership to change in at most one network partition, the "primary partition".
Reference: [MSMA94] <author> P.M. Melliar-Smith, Louise Moser, and Vivek Agrawala. </author> <title> Processor membership in asynchronous distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(5) </volume> <pages> 459-473, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: One of the reasons why WGM is weak is that it makes no attempt to "track" failures: In contrast to most existing group membership services whose goal is to maintain a set of processes that are deemed to be operational (e.g., <ref> [RB91, JFR93, BDGB94, DMS94, MSMA94] </ref>), WGM does not link the membership of the group with actual or suspected crashes. <p> It is important to note that our result applies only to group membership services that attempt to maintain a single agreed view of the current membership of a group (e.g., <ref> [RB91, KT91, MPS91, MSMA94, HS95] </ref>). These are known as primary-partition group membership services and are intended for systems with no network partitions, or for systems that allow the group membership to change in at most one network partition, the "primary partition". <p> In contrast to primary-partition group membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment <ref> [MSMA94] </ref>. dependently from each other [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95]. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [Nei96] <author> Gil Neiger. </author> <title> A new look at membership services. </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Philadephia, PA, </address> <year> 1996. </year>
Reference-contexts: In a recent paper, Neiger proposes a primary--partition group membership specification that is weak enough to be solvable in asynchronous systems, and strong enough to prevent trivial implementations <ref> [Nei96] </ref>. With this specification, however, a single process crash is allowed to block all processes. So the group membership service that it defines is not fully fault-tolerant: when a crash occurs safety properties are guaranteed, but liveness can be lost.
Reference: [NT90] <author> Gil Neiger and Sam Toueg. </author> <title> Automatically increasing the fault-tolerance of distributed algorithms. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 374-419, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The impossibility proof does not change. The first property of WGM requires that no two processes, whether correct or not, disagree on the new view. This is akin to the Uniform Agreement property of <ref> [NT90] </ref>. One may wonder whether our impossibility result hinges on this uniformity requirement. It is easy to show that WGM remains unsolvable even if we only require that correct processes do not disagree.
Reference: [Rab83] <author> Michael Rabin. </author> <title> Randomized Byzan-tine generals. </title> <booktitle> In Proceedings of the Twenty-Fourth Symposium on Foundations of Computer Science, </booktitle> <pages> pages 403-409. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1983. </year>
Reference-contexts: First among these were the randomized algorithm of Ben-Or [Ben83], the probabilistic algorithm of Bracha and Toueg [BT83], and the algorithm by Rabin that assumes a shared sequence of random bits <ref> [Rab83] </ref>. These algorithms solve Consensus with probability 1: even though they admit non-terminating runs, such runs are shown to have probability 0, and Consensus is reached within a finite expected number of steps (for a survey of randomized Consensus algorithms see [CD89]). <p> In fact, we conjecture that it is possible to provide a realistic primary-partition group membership service, with precise liveness guarantees, if one uses randomization (as in <ref> [Ben83, Rab83] </ref>), or makes well-defined probability assumptions on the behavior of the environment (as in [BT83]), or uses failure detectors with well-defined properties (as in [CT91]). 3 In contrast to primary-partition group membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views
Reference: [RB91] <author> Aleta Ricciardi and Kenneth P. Bir-man. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-352, </pages> <year> 1991. </year> <note> Also available as technical report 93-1328, </note> <institution> Department of Computer Science, Cornell University. </institution>
Reference-contexts: These differences appear to make group membership weaker than Consensus, and in fact the first one has been widely cited as a reason why group membership is solvable in asynchronous systems while Consensus is not <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>. <p> One of the reasons why WGM is weak is that it makes no attempt to "track" failures: In contrast to most existing group membership services whose goal is to maintain a set of processes that are deemed to be operational (e.g., <ref> [RB91, JFR93, BDGB94, DMS94, MSMA94] </ref>), WGM does not link the membership of the group with actual or suspected crashes. <p> It is important to note that our result applies only to group membership services that attempt to maintain a single agreed view of the current membership of a group (e.g., <ref> [RB91, KT91, MPS91, MSMA94, HS95] </ref>). These are known as primary-partition group membership services and are intended for systems with no network partitions, or for systems that allow the group membership to change in at most one network partition, the "primary partition". <p> This is a natural requirement which is compatible with the specification of the Strong Group Membership Problem (S-GMP ) given in <ref> [RB91, Ric93, RB94] </ref>. In S-GMP a process p may execute event f aulty p (q) indicating that p suspects that q crashed. If this oc curs, S-GMP requires that eventually either p or q are excluded from the group view. <p> It may appear that such "program-controlled" crashes of processes that hinder the progress of the algorithm make it easier for the remaining processes to install a new group view. An example of program-controlled crashes appears in the S-GMP group membership protocol given in <ref> [RB91, Ric93] </ref>. In this protocol, if the pro cess p in charge of coordinating the update of group views comes to believe that a majority of the processes are faulty, it executes an event called crash. This causes p to actually crash, i.e., to stop executing steps. <p> It is important to note that this impossibility result applies to group membership services that are allowed to remove from the group, and even kill, an arbitrary number of non-faulty processes that did not wish to be removed. Thus, contrary to a widespread view <ref> [RB91, ADKM92, DKM93, DMS94, EMS95] </ref>, the removal or killing of processes that are suspected to have crashed does not contribute to the solvability of the primary-partition group membership problem. <p> Some implementations of primary-partition group membership do not satisfy this liveness re quirement: They have runs that "block" forever, or remove or kill all processes. 2 It is not clear, however, what liveness property (if any) such implementations do satisfy [ACBMT95]. 2 For example, in the implementation of S-GMP <ref> [RB91, Ric93] </ref> it is possible for all processes to kill themselves before any new view is installed. In a recent paper, Neiger proposes a primary--partition group membership specification that is weak enough to be solvable in asynchronous systems, and strong enough to prevent trivial implementations [Nei96].
Reference: [RB94] <author> Aleta Ricciardi and Kenneth P. Bir-man. </author> <title> Process membership in asynchronous environments. </title> <note> Available by anonymous ftp from ftp.cs.cornell.edu in pub/aleta/AsyncMembService.ps, </note> <month> April </month> <year> 1994. </year>
Reference-contexts: This is a natural requirement which is compatible with the specification of the Strong Group Membership Problem (S-GMP ) given in <ref> [RB91, Ric93, RB94] </ref>. In S-GMP a process p may execute event f aulty p (q) indicating that p suspects that q crashed. If this oc curs, S-GMP requires that eventually either p or q are excluded from the group view.
Reference: [Ric93] <author> Aleta Ricciardi. </author> <title> The group membership problem in asynchronous systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, USA, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: This is a natural requirement which is compatible with the specification of the Strong Group Membership Problem (S-GMP ) given in <ref> [RB91, Ric93, RB94] </ref>. In S-GMP a process p may execute event f aulty p (q) indicating that p suspects that q crashed. If this oc curs, S-GMP requires that eventually either p or q are excluded from the group view. <p> It may appear that such "program-controlled" crashes of processes that hinder the progress of the algorithm make it easier for the remaining processes to install a new group view. An example of program-controlled crashes appears in the S-GMP group membership protocol given in <ref> [RB91, Ric93] </ref>. In this protocol, if the pro cess p in charge of coordinating the update of group views comes to believe that a majority of the processes are faulty, it executes an event called crash. This causes p to actually crash, i.e., to stop executing steps. <p> Some implementations of primary-partition group membership do not satisfy this liveness re quirement: They have runs that "block" forever, or remove or kill all processes. 2 It is not clear, however, what liveness property (if any) such implementations do satisfy [ACBMT95]. 2 For example, in the implementation of S-GMP <ref> [RB91, Ric93] </ref> it is possible for all processes to kill themselves before any new view is installed. In a recent paper, Neiger proposes a primary--partition group membership specification that is weak enough to be solvable in asynchronous systems, and strong enough to prevent trivial implementations [Nei96].
Reference: [vRBC + 93] <author> Robbert van Renesse, Kenneth P. Bir-man, Robert Cooper, Bradford Glade, and Patrick Stephenson. </author> <title> The horus system. </title> <editor> In Kenneth P. Birman and Robbert van Renesse, editors, </editor> <booktitle> Reliable Distributed Computing with the Isis Toolkit, </booktitle> <pages> pages 133-147. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1993. </year>
Reference-contexts: So-called partitionable group membership services, which allow multiple views of the group to coexist, have also been proposed <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. Some remarks about such services are given at the end of this paper. The rest of this paper is organized as follows. In Section 2, we define WGM and explain why it is weak. <p> membership services, partitionable ones allow processes to disagree on the current membership of the group, i.e., several different views of the membership of the group may evolve concurrently and in 3 The group membership protocol of Melliar-Smith et al. makes probability assumptions on the environment [MSMA94]. dependently from each other <ref> [JFR93, vRBC + 93, BDGB94, DMS94, DMS95, EMS95] </ref>. In particular, there may be several disjoint subsets of processes such that processes in each subset agree that they are the current members of the group.
Reference: [VVR92] <author> Paulo Verissimo, Werner Vogels, and Luis Rodrigues. </author> <title> Group orientation: a paradigm for modern distributed systems. </title> <booktitle> In Proceedings of the ACM SIGOPS 1992 Workshop, </booktitle> <address> Le Mont Saint-Michel, France, </address> <year> 1992. </year>
References-found: 30

