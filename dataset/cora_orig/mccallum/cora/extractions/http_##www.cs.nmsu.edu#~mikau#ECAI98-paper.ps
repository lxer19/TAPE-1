URL: http://www.cs.nmsu.edu/~mikau/ECAI98-paper.ps
Refering-URL: http://www.cs.nmsu.edu/~mikau/
Root-URL: http://www.cs.nmsu.edu
Title: the first step towards debugging automation.  
Keyword: traditional methods of programming language semantics  Keywords. Program behavior models, events, event grammars, software testing and debugging  
Note: It appears that  definition dont address this aspect. The next problem to be addressed after the program behavior  
Abstract: In building such a model several considerations were taken in account. The first assumption we make is that the model is discrete, i.e. comprises a finite number of well-separated elements. This assumption is typical for Computer Science methods used for static and dynamic analysis of programs. For this reason the notion of event as an elementary unit of action is an appropriate basis for building the whole model. The event is an abstraction for any detectable action performed during the program execution, such as a statement execution, expression evaluation, procedure call, sending and receiving a message, etc. Actions (or events) are evolving in time and the program behavior represents the temporal relationship between actions. This implies the necessity to introduce an ordering relation for events. Semantics of parallel programming languages and even some sequential languages (such as C) dont require the total ordering of actions, so partial event ordering is the most adequate method for this purpose [17]. Actions performed during the program execution are at different levels of granularity, some of them include other actions, e.g. a subroutine call event contains statement execution events. This consideration brings to our model inclusion relation. Under this relationship events can be hierarchical objects and it becomes possible to consider program behavior at appropriate levels of granularity. Finally, the program execution can be modeled as a set of events (event trace) with two basic relations: partial ordering and inclusion. The event trace actually is a model of programs behavior temporal aspect. In order to specify meaningful program behavior properties we have to enrich events with some attributes. An event may have a type and some other attributes, such as event duration, program source code related to the event, program state associated with the event (i.e. program variable values at the beginning and at the end of event), etc. Abstract. This paper suggests an approach to the development of software testing and debugging automation tools based on precise program behavior models. The program behavior model is defined as a set of events (event trace) with two basic binary relations over events -- precedence and inclusion, and represents the temporal relationship between actions. A language for the computations over event traces is developed that provides a basis for assertion checking, debugging queries, execution profiles, and performance measurements. The approach is nondestructive, since assertion texts are separated from the target program source code and can be maintained independently. Assertions can capture both the dynamic properties of a particular target program and can formalize the general knowledge of typical bugs and debugging strategies. An event grammar provides a sound basis for assertion language implementation via target program automatic instrumentation. Event grammars may be designed for sequential as well as for parallel programs. The approach suggested can be adjusted to a variety of programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Anger, R. Rodriguez, M. Young, </author> <title> Combining Static and Dynamic Analysis of Concurrent Programs, </title> <booktitle> Proceedings of International IEEE Conference on Software Maintenance, </booktitle> <address> Victoria, BC, Canada, </address> <month> Sept. </month> <year> 1994, </year> <month> pp.89-98. </month>
Reference: [2] <author> M. Auguston, </author> <title> FORMAN -- A Program Formal Annotation Language, </title> <booktitle> Proceedings of the 5:th Israel Conference on Computer Systems and Software Engineering, </booktitle> <address> Gerclia, May 1991, </address> <publisher> IEEE Computer Society Press, </publisher> <pages> 149-154. </pages>
Reference: [3] <author> M. Auguston, </author> <title> A language for debugging automation, </title> <booktitle> Proceedings of the 6th International Conference on Software Engineering and Knowledge Engineering, </booktitle> <address> Jurmala, </address> <month> June </month> <year> 1994, </year> <journal> Knowledge Systems Institute, </journal> <pages> pp. 108-115. </pages>
Reference-contexts: The computation of an assertion is interrupted when it becomes clear that the final value will be False, and the current values of metavariables can be used to generate readable and informative messages. The following examples have been executed on our prototype FORMAN/PASCAL assertion checker <ref> [3] </ref>, [4]. The PASCAL program reads a sequence of integers from file XX.TXT. program e1; var X: integer; XX: file of text; begin X:= 7; (* initial value is assigned here *) reset (XX, XX.TXT); while X&lt;&gt;0 do read (XX, X) end.
Reference: [4] <author> M. Auguston, </author> <title> Program Behavior Model Based on Event Grammar and its Application for Debugging Automation, </title> <booktitle> in Proceedings of the 2nd International Workshop on Automated and Algorithmic Debugging, </booktitle> <address> Saint-Malo, France, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The computation of an assertion is interrupted when it becomes clear that the final value will be False, and the current values of metavariables can be used to generate readable and informative messages. The following examples have been executed on our prototype FORMAN/PASCAL assertion checker [3], <ref> [4] </ref>. The PASCAL program reads a sequence of integers from file XX.TXT. program e1; var X: integer; XX: file of text; begin X:= 7; (* initial value is assigned here *) reset (XX, XX.TXT); while X&lt;&gt;0 do read (XX, X) end. <p> More references to related work and a detailed survey may be found in <ref> [4] </ref> 5.1 Event Notion The Event Based Behavioral Abstraction (EBBA) method suggested in [8] characterizes the behavior of the whole program in terms of both primitive and composite events. Context conditions involving event attribute values can be used to distinguish events.
Reference: [5] <author> M. Auguston, P. Fritzson, </author> <title> PARFORMAN -- an Assertion Language for Specifying Behavior when Debugging Parallel Applications, </title> <journal> International Journal of Software Engineering and Knowledge Engineering, vol.6, </journal> <volume> No 4, </volume> <year> 1996, </year> <pages> pp. 609-640. </pages>
Reference: [6] <author> M. Auguston, A. Gates, M. Lujan, </author> <title> Defining a program Behavior Model for Dynamic Analyzers, </title> <booktitle> Proceedings of the 9th International Conference on Software Engineering and Knowledge Engineering, </booktitle> <address> SEKE97, Madrid, Spain, </address> <month> June </month> <year> 1997, </year> <pages> pp. 257-262 </pages>
Reference: [7] <author> F. Baiardi, N. De Francesco, G. Vaglini, </author> <title> Development of a Debugger for a Concurrent Language, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, No. 4, </volume> <month> April </month> <year> 1986, </year> <pages> pp. 547-553. </pages>
Reference-contexts: Assertions are written in Ada itself, using a number of special predefined predicates. Assertion-checking is dynamic at run-time, and does not need post-mortem analysis. The RAPIDE project [20] provides a reach event-based assertion language for software architecture description. In <ref> [7] </ref> events are introduced to describe process communication, termination, and connection and detachment of process to channels. A language of Behavior Expressions (BE) is provided to write assertions about sequences of process interactions.
Reference: [8] <author> P. C. Bates, J. C. Wileden, </author> <title> High-Level Debugging of Distributed Systems: The Behavioral Abstraction Approach, </title> <journal> The Journal of Systems and Software 3, </journal> <year> 1983, </year> <pages> pp. 255-264. </pages>
Reference-contexts: More references to related work and a detailed survey may be found in [4] 5.1 Event Notion The Event Based Behavioral Abstraction (EBBA) method suggested in <ref> [8] </ref> characterizes the behavior of the whole program in terms of both primitive and composite events. Context conditions involving event attribute values can be used to distinguish events. EBBA defines two higher level means for modeling system behavior -- clustering and filtering.
Reference: [9] <author> B. Beizer, </author> <title> Software Testing Techniques, Second Edition, </title> <publisher> International Thomson Computer Press, </publisher> <year> 1990. </year>
Reference-contexts: This makes it easy to control the amount of assertions to be checked. According to <ref> [9] </ref> and [23] approximately 40-50% of all bugs detected during the program testing are logic, structural, and functionality bugs, i.e. bugs which could be detected by appropriate assertion checking similar to the demonstrated above.
Reference: [10] <author> F. Brooks, </author> <title> The Mythical Man-Month, 2nd edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [11] <author> B. Bruegge, P. Hibbard, </author> <title> Generalized Path Expressions: A High-Level Debugging Mechanism, </title> <journal> The Journal of Systems and Software 3, </journal> <year> 1983, </year> <pages> pp. 265-276. </pages>
Reference-contexts: The path expression technique introduced for specifying parallel programs in [12] is one such formalism. Trace specifications also are used in [21] for software specification. This technique has been used in several projects as a background for high-level debugging tools, (e.g. in <ref> [11] </ref>), where path rules are suggested as kinds of debugger commands. FORMAN provides exible language means for trace specification including event patterns and regular expressions over them. 5.3 Assertion Languages Assertion (or annotation) languages provide yet another approach to debugging automation.
Reference: [12] <author> R. H. Campbell, A. N. Habermann, </author> <title> The specification of process synchronization by path expressions, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 16, </volume> <year> 1974, </year> <pages> pp. 89-102. </pages>
Reference-contexts: It is useful to give such a description in an explicit and precise form. The path expression technique introduced for specifying parallel programs in <ref> [12] </ref> is one such formalism. Trace specifications also are used in [21] for software specification. This technique has been used in several projects as a background for high-level debugging tools, (e.g. in [11]), where path rules are suggested as kinds of debugger commands.
Reference: [13] <author> E.Clarke et al., </author> <title> Verification tools for Finite State Concurrent Systems, </title> <publisher> LNCS vol.803, </publisher> <year> 1994, </year> <month> pp.124-175. </month>
Reference-contexts: This work is presented in [16] where four types of events are introduced: assignment to variables, reaching a label, interprocess communication and process instantiation or termination. Composite events cannot be defined. Different varieties of temporal logic languages are used for program static analysis called Model Checking <ref> [13] </ref>. In [25] a practical approach to programming with assertions for the C language is advocated, and it is demonstrated that even local assertions associated with particular points within the program may be extremely useful for program debugging.
Reference: [14] <author> P. Fritzson, N. Shahmehri, M. Kamkar, T. Gyimothy, </author> <title> Generalized Algorithmic Debugging and Testing, </title> <journal> ACM LOPLAS -- Letters of Programming Languages and Systems. </journal> <volume> Vol. 1, No. 4, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: The FORMAN language for computations over traces provides exible means for writing both local and global assertions, including those about temporal relations between events. 5.4 Algorithmic Debugging The original algorithmic program debugging method was introduced in [27] for the Prolog language. In [26] and <ref> [14] </ref> this paradigm is applied to a subset of PASCAL. The debugger executes the program and builds a trace execution tree at the procedure level while saving some useful trace information such as procedure names and input/output parameter values.
Reference: [15] <author> P. Fritzson, M. Auguston, N. Shahmehri, </author> <title> Using Assertions in Declarative and Operational Models for Automated Debugging, </title> <journal> The Journal of Systems and Software 25, </journal> <year> 1994, </year> <pages> pp. 223-239. </pages>
Reference: [16] <author> G. Goldszmidt, S. Katz, S. Yemini, </author> <title> Interactive Blackbox Debugging for Concurrent Languages, </title> <journal> SIGPLAN Notices vol. </journal> <volume> 24, No. 1, </volume> <year> 1989, </year> <pages> pp. 271-282. </pages>
Reference-contexts: Event types are process communication and interactions such as send, receive, terminate, connect, detach. Evaluation of assertions are done at run-time. No composite events are provided. Another recent experimental debugging tool is based on trace analysis with respect to assertions in temporal interval logic. This work is presented in <ref> [16] </ref> where four types of events are introduced: assignment to variables, reaching a label, interprocess communication and process instantiation or termination. Composite events cannot be defined. Different varieties of temporal logic languages are used for program static analysis called Model Checking [13].
Reference: [17] <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, No. 7, </volume> <month> July </month> <year> 1978, </year> <pages> pp. 558-565. </pages>
Reference: [18] <author> D. C. Luckham, D. Bryan, W. Mann, S. Meldal, D. P. Helmbold, </author> <title> An Introduction to Task Sequencing Language, </title> <note> TSL version 1.5 (Preliminary version), </note> <institution> Stanford University, </institution> <month> February 1, </month> <year> 1990, </year> <pages> pp. 1-68. </pages>
Reference-contexts: The approaches currently in use are mostly based on boolean expressions attached to selected points of the target program, like the assert macro in C. The ANNA [19] annotation language for the Ada target language supports assertions on variable and type declarations. In the TSL <ref> [18] </ref>, [24] annotation language for Ada the notion of event is introduced in order to describe the behavior of Tasks. Patterns can be written which involve parameter values of Task entry calls. Assertions are written in Ada itself, using a number of special predefined predicates.
Reference: [19] <author> D. C. Luckham, S. Sankar, S. Takahashi, </author> <title> Two-Dimensional Pinpointing: Debugging with Formal Specifications, </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1991, </year> <month> pp.74-84. </month>
Reference-contexts: The approaches currently in use are mostly based on boolean expressions attached to selected points of the target program, like the assert macro in C. The ANNA <ref> [19] </ref> annotation language for the Ada target language supports assertions on variable and type declarations. In the TSL [18], [24] annotation language for Ada the notion of event is introduced in order to describe the behavior of Tasks. Patterns can be written which involve parameter values of Task entry calls.
Reference: [20] <author> D. Luckham, J. Vera, </author> <title> An Event-Based Architecture Definition Language, </title> <journal> IEEE Transactions on Software Engineering, Vol.21, </journal> <volume> No. 9, </volume> <year> 1995, </year> <pages> pp. 717-734. </pages>
Reference-contexts: Patterns can be written which involve parameter values of Task entry calls. Assertions are written in Ada itself, using a number of special predefined predicates. Assertion-checking is dynamic at run-time, and does not need post-mortem analysis. The RAPIDE project <ref> [20] </ref> provides a reach event-based assertion language for software architecture description. In [7] events are introduced to describe process communication, termination, and connection and detachment of process to channels. A language of Behavior Expressions (BE) is provided to write assertions about sequences of process interactions.
Reference: [21] <author> J. McLean, </author> <title> A Formal Method for the Abstract Specification of Software, </title> <journal> Journal of the Association of Computing Machinery, vol.31, </journal> <volume> No. 3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 600-627. </pages>
Reference-contexts: It is useful to give such a description in an explicit and precise form. The path expression technique introduced for specifying parallel programs in [12] is one such formalism. Trace specifications also are used in <ref> [21] </ref> for software specification. This technique has been used in several projects as a background for high-level debugging tools, (e.g. in [11]), where path rules are suggested as kinds of debugger commands.
Reference: [22] <author> R. Olsson, R. Crawford, W. Wilson, </author> <title> A Dataflow Approach to Event-based Debugging, </title> <journal> Software -- Practice and Experience, </journal> <volume> Vol.21(2), </volume> <month> February </month> <year> 1991, </year> <pages> pp. 19-31. </pages>
Reference-contexts: Filtering serves to eliminate from consideration events which are not relevant to the model being investigated. Both event recognition and filtering can be performed at run-time. An event-based debugger for the C programming language called Dalek <ref> [22] </ref> provides a means for description of user-defined events which typically are points within a program execution trace. A target program has to be instrumented in order to collect values of event attributes. Composite events can be recognized at run-time as collections of primitive events.
Reference: [23] <author> S. L. Pfleeger, </author> <title> Software Engineering, Theory and Practice, </title> <publisher> Prentice hall, </publisher> <year> 1998. </year>
Reference-contexts: This makes it easy to control the amount of assertions to be checked. According to [9] and <ref> [23] </ref> approximately 40-50% of all bugs detected during the program testing are logic, structural, and functionality bugs, i.e. bugs which could be detected by appropriate assertion checking similar to the demonstrated above.
Reference: [24] <author> D. Rosenblum, </author> <title> Specifying Concurrent Systems with TSL, </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1991, </year> <month> pp.52-61. </month>
Reference-contexts: The approaches currently in use are mostly based on boolean expressions attached to selected points of the target program, like the assert macro in C. The ANNA [19] annotation language for the Ada target language supports assertions on variable and type declarations. In the TSL [18], <ref> [24] </ref> annotation language for Ada the notion of event is introduced in order to describe the behavior of Tasks. Patterns can be written which involve parameter values of Task entry calls. Assertions are written in Ada itself, using a number of special predefined predicates.
Reference: [25] <author> D. Rosenblum, </author> <title> A Practical Approach to Programming With Assertions, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No 1, </volume> <month> January </month> <year> 1995, </year> <pages> pp. 19-31. </pages>
Reference-contexts: This work is presented in [16] where four types of events are introduced: assignment to variables, reaching a label, interprocess communication and process instantiation or termination. Composite events cannot be defined. Different varieties of temporal logic languages are used for program static analysis called Model Checking [13]. In <ref> [25] </ref> a practical approach to programming with assertions for the C language is advocated, and it is demonstrated that even local assertions associated with particular points within the program may be extremely useful for program debugging.
Reference: [26] <author> N. Shahmehri, </author> <title> Generalized Algorithmic Debugging, </title> <type> Ph.D. Thesis No. 260, </type> <institution> Dept. of Computer and Information Science, Linkping University, S-581 83 Linkping, Sweden, </institution> <year> 1991. </year>
Reference-contexts: The FORMAN language for computations over traces provides exible means for writing both local and global assertions, including those about temporal relations between events. 5.4 Algorithmic Debugging The original algorithmic program debugging method was introduced in [27] for the Prolog language. In <ref> [26] </ref> and [14] this paradigm is applied to a subset of PASCAL. The debugger executes the program and builds a trace execution tree at the procedure level while saving some useful trace information such as procedure names and input/output parameter values.
Reference: [27] <author> E. Shapiro, </author> <title> Algorithmic Program Debugging, </title> <publisher> MIT Press, </publisher> <month> May </month> <year> 1982. </year>
Reference-contexts: The FORMAN language for computations over traces provides exible means for writing both local and global assertions, including those about temporal relations between events. 5.4 Algorithmic Debugging The original algorithmic program debugging method was introduced in <ref> [27] </ref> for the Prolog language. In [26] and [14] this paradigm is applied to a subset of PASCAL. The debugger executes the program and builds a trace execution tree at the procedure level while saving some useful trace information such as procedure names and input/output parameter values.
References-found: 27

