URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/pods95_2-full.ps
Refering-URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/index.html
Root-URL: http://www.cs.ucsb.edu
Email: dong@cs.mu.oz.au  su@cs.ucsb.edu  
Title: Arity Bounds in First-Order Incremental Evaluation and Definition of Polynomial Time Database Queries  
Author: Guozhu Dong Jianwen Su 
Note: An extended abstract of the paper appeared under the title "Space-Bounded FOIES" in the Proc. ACM Symp. on Principles of Database Systems, 1995. This author gratefully acknowledges support of the Australian Research Council through research grants. Part work done while on study leave at UCSB. Work by this author supported in part by NSF grants IRI-9109520 and IRI-9411330 and NASA grant NAGW-3888.  
Date: December 6, 1995 Revised: April 25, 1997  
Address: Parkville, Vic. 3052, Australia  Santa Barbara, CA 93106, U.S.A.  
Affiliation: Department of Computer Science University of Melbourne  Department of Computer Science University of California  
Abstract-found: 0
Intro-found: 1
Reference: [AF90] <author> M. Ajtai and R. Fagin. </author> <title> Reachability is harder for directed than for undirected finite graphs. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 55(1) </volume> <pages> 113-150, </pages> <year> 1990. </year> <month> 39 </month>
Reference-contexts: The result that Equal-Length-Chain 62 FOIES 0 will be established in Theorem 5.4 using Ehrenfeucht-Frasse games. It is interesting to compare the FOIES 61 classes with monadic 1 1 . On one hand, the query Even is in FOIES sf (Example 2.3) but not in monadic 1 1 <ref> [Fag75, AF90, FSV95] </ref>. On the other hand, disconnectivity of undirected graphs is in 1 1 [AF90] but not in FOIES 1 and 11 1 not in FOIES sf (Theorem 5.7). Therefore, monadic 1 1 is incomparable with FOIES 61 classes and with FOIES sf (Figure 3). 4 FOIES 1 vs. <p> It is interesting to compare the FOIES 61 classes with monadic 1 1 . On one hand, the query Even is in FOIES sf (Example 2.3) but not in monadic 1 1 [Fag75, AF90, FSV95]. On the other hand, disconnectivity of undirected graphs is in 1 1 <ref> [AF90] </ref> but not in FOIES 1 and 11 1 not in FOIES sf (Theorem 5.7). Therefore, monadic 1 1 is incomparable with FOIES 61 classes and with FOIES sf (Figure 3). 4 FOIES 1 vs. FOIES 2 (Unary vs. <p> Our results on undirected graphs and the lack of similar results for directed graphs support, if not confirm, the belief that directed graphs are harder than undirected graphs <ref> [AF90] </ref>. <p> Proposition 5.1 Let ' be a first-order sentence with quantifier depth r and I; J two structures. If I j= ' and I r J , then J j= '. Ehrenfeucht-Frasse games and extensions are a very useful tool in proving expressive power of query languages (e.g., <ref> [Fag75, AF90, AHV95, GS94] </ref>). But they cannot be used directly in proving results concerning foies, since the process of incremental evaluation is not 23 strictly first order.
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Such an approach is useful for situations where the database changes frequently and the query answer are needed in real time. The approach also has great potential for parallel evaluation; this is because first-order queries are readily adaptable to parallel implementations, and have very low parallel complexity <ref> [AHV95] </ref>. This approach also gives pure relational database systems the power of supporting recursive views without resorting to programming in host languages. <p> Proposition 5.1 Let ' be a first-order sentence with quantifier depth r and I; J two structures. If I j= ' and I r J , then J j= '. Ehrenfeucht-Frasse games and extensions are a very useful tool in proving expressive power of query languages (e.g., <ref> [Fag75, AF90, AHV95, GS94] </ref>). But they cannot be used directly in proving results concerning foies, since the process of incremental evaluation is not 23 strictly first order.
Reference: [AP87] <author> K. R. Apt and J.-M. Pugin. </author> <title> Maintenance of stratified databases viewed as a belief revision system. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 136-45, </pages> <year> 1987. </year>
Reference: [BC93] <author> A. L. Buchsbaum and M. C. Carlisle. </author> <title> Determining uni-connectivity in directed graphs. </title> <journal> Information Processing Letters, </journal> <volume> 48(1) </volume> <pages> 9-12, </pages> <year> 1993. </year>
Reference-contexts: In [DS95b], 1-path graphs were referred to as 0-1-path graphs; the singly connected (also called uni-connected) graphs <ref> [BC93] </ref> are a strictly more general class: a graph is singly connected if for each ordered pair of distinct nodes u, v, there is at most one path from u to v. 3 FOIES 61 In this section we present several queries and their foies to further illustrate the notion of
Reference: [BLT86] <author> J. A. Blakeley, P.-A. Larson, and F. W. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 61-71, </pages> <year> 1986. </year>
Reference: [Cai90] <author> J. Cai. </author> <title> Lower bounds for constant-depth circuits in the presence of help bits. </title> <journal> Information Processing Letters, </journal> <volume> 36 </volume> <pages> 79-83, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: We define a k-Mod-4 query for each k 2 N and show that it is in FOIES k but not in FOIES k1 . The non-membership proof is based on a result by Cai <ref> [Cai90] </ref> which 1 establishes an exponential lower bound on the size of constant-depth Boolean circuits with "help" bits that compute the multiple parity problem. <p> We also discuss the impact of the arity of the input databases on the arity hierarchies. We show that FOIES k 6= FOIES k+1 for each k 2 N. The proof uses a result by Cai <ref> [Cai90] </ref> (Theorem 3.2) which establishes an exponential lower bound on the size of constant-depth Boolean circuits with "help" bits to compute the "multiple parity" problem. We first state a weaker version of Cai's Theorem below. Theorem 6.1 [Cai90] Let X = fx ij j 1 6 i 6 m; 1 6 <p> The proof uses a result by Cai <ref> [Cai90] </ref> (Theorem 3.2) which establishes an exponential lower bound on the size of constant-depth Boolean circuits with "help" bits to compute the "multiple parity" problem. We first state a weaker version of Cai's Theorem below. Theorem 6.1 [Cai90] Let X = fx ij j 1 6 i 6 m; 1 6 j 6 m 5 g be a set of Boolean variables and C be an unbounded fan-in, constant depth circuit computing the m parity functions x i1 x i2 x im 5 for 1 6 i 6
Reference: [CH82] <author> A. K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: A k-ary query from S in to R Q is a (possibly partial) mapping Q from inst (S in ) to relation instances of R Q satisfying the following "genericity" criterion <ref> [CH82, Hul86] </ref>: For each permutation of dom, Q commutes with ( is extended naturally to relations and databases), i.e., 3 8I 2 inst (S in ); Q ((I)) = (Q (I)). We will refer to relation names in S in (and their instances) as base relations for Q.
Reference: [DK94] <author> G. Dong and R. Kotagiri. </author> <title> Incrementally evaluating constrained transitive closure by conjunctive queries. </title> <type> Technical Report 94/11, </type> <institution> Computer Science, University of Melbourne, </institution> <year> 1994. </year> <month> (Revised July </month> <year> 1995). </year>
Reference: [DLW95] <author> G. Dong, L. Libkin, and L. Wong. </author> <title> On impossibility of decremental recomputation of recursive queries in relational calculus and SQL. </title> <booktitle> In Proc. Int. Workshop on Database Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: the number of bits affected by the update), whereas in foies each query can only be evaluated once. (ii) The second group generalizes the foies framework in the database setting by using SQL or other query languages, which are more powerful than the first-order query language, as the incremental language <ref> [DLW95] </ref>. (iii) The third group consists of other kinds of on-line algorithms for graph problems.
Reference: [DP97] <author> G. Dong and C. Pang. </author> <title> Maintaining transitive closure in first-order after node-set and edge-set deletions. </title> <journal> Information Processing Letters, </journal> <year> 1997. </year>
Reference: [DS93] <author> G. Dong and J. Su. </author> <title> First-order incremental evaluation of datalog queries (extended abstract). </title> <booktitle> In Proc. 4th Int. Workshop on Database Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, a framework of evaluating recursive queries (or maintaining recursive views) by incrementally evaluating some non-recursive, first-order queries has been proposed and studied by Dong, Su, and Topor <ref> [DST95, DS95b, DS93] </ref>; a slightly different framework was proposed and studied by Patnaik and Immerman [PI94]. <p> as a predicate.) TC G (x; y) = TC G o (x; y) _ d TC G o (x; u) ^ d TC G o (v; y) The above provides an efficient way of updating (computing) the transitive closure query; more general results for insertion-only foies can be found in <ref> [DT92, DS93, DST95] </ref>. 9 Example 3.2 Consider now the transitive closure query defined over acyclic directed graphs. It has a space-free foies, for both insertions and deletions. Insertions are dealt with as in Example 3.1.
Reference: [DS95a] <author> G. Dong and J. Su. </author> <title> Increment boundedness and nonrecursive incremental evaluation of datalog queries (extended abstract). </title> <editor> In G. Gottlob and M. Y. Vardi, editors, </editor> <booktitle> Database Theory - ICDT '95, volume 893 of LNCS, </booktitle> <pages> pages 397-410. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1995. </year>
Reference-contexts: This approach also gives pure relational database systems the power of supporting recursive views without resorting to programming in host languages. It has been shown that many database queries, including regular chain datalog (plus a particular kind of initialization) <ref> [DT92, DS95a, DST95] </ref>, transitive closure over acyclic graphs [DS95b] and over undirected graphs [PI94], can be maintained in this way.
Reference: [DS95b] <author> G. Dong and J. Su. </author> <title> Incremental and decremental evaluation of transitive closure by first-order queries. </title> <journal> Information & Computation, </journal> <volume> 120(1) </volume> <pages> 101-106, </pages> <month> July </month> <year> 1995. </year> <month> 40 </month>
Reference-contexts: In particular, a framework of evaluating recursive queries (or maintaining recursive views) by incrementally evaluating some non-recursive, first-order queries has been proposed and studied by Dong, Su, and Topor <ref> [DST95, DS95b, DS93] </ref>; a slightly different framework was proposed and studied by Patnaik and Immerman [PI94]. <p> This approach also gives pure relational database systems the power of supporting recursive views without resorting to programming in host languages. It has been shown that many database queries, including regular chain datalog (plus a particular kind of initialization) [DT92, DS95a, DST95], transitive closure over acyclic graphs <ref> [DS95b] </ref> and over undirected graphs [PI94], can be maintained in this way. If a (finite) set of first-order queries maintains the answers to a query (and necessary auxiliary relations), we call the set a "first-order incremental evaluation system" (or "foies") for the query of interest. <p> Concerned with the design of efficient general algorithms instead of with databases, these algorithms typically use non-relational data structures such as queues or linked lists, use invented values such as integers, or use the iteration constructs such as while-loops and for-loops (see <ref> [DS95b] </ref> for references to such work). A more general complexity-theoretical framework for on-line or incremental computation is reported in [MSVT94]. Motivated from the view maintenance problem of databases, our approach uses only relations and has none of the above non-logical features. <p> For each positive integer k, a graph is a k-path graph if for each ordered pair of (not necessarily distinct) nodes u, v, there are at most k paths from u to v. In <ref> [DS95b] </ref>, 1-path graphs were referred to as 0-1-path graphs; the singly connected (also called uni-connected) graphs [BC93] are a strictly more general class: a graph is singly connected if for each ordered pair of distinct nodes u, v, there is at most one path from u to v. 3 FOIES 61 <p> For deletions, suppose G o is an acyclic graph, (a; b) an edge in G o , and G = G o f (a; b)g. If (x; y) 2 TC G o , then (x; y) remains in TC G iff (proved in <ref> [DS95b] </ref>) ( 0 !( 1 _ 2 _ 3 )) _ , where 1. 0 says that x; y; a; b are distinct nodes such that TC G o (x; a) ^ TC G o (b; y). 2. 1 says there exists a node u on a path from x to <p> This idea is applied to two other problems (minimum spanning trees and 2-colorability) on undirected graphs. We also use a "core" of directed 1-path graphs in assisting the derivation of transitive closure, where the core is an arbitrary maximal acyclic subgraph; this also improves an earlier space upper bound <ref> [DS95b] </ref> to the optimum. Our results on undirected graphs and the lack of similar results for directed graphs support, if not confirm, the belief that directed graphs are harder than undirected graphs [AF90]. <p> Proof: The negative results will be shown in Section 5. For (2), the positive results follow from Example 3.2. (That TC over acyclic graphs is in FOIES sf is proved in <ref> [DS95b] </ref>. Since by storing TC one can define (s; t)-connectivity, (s; t)-connectivity belongs to FOIES 2 .) For (1), the 1-path case, we store two binary auxiliary relations: an arbitrary maximal acyclic subgraph H of G, and TC H . <p> Note that TC H can be maintained as in Example 3.2 (and <ref> [DS95b] </ref>). We will use TC H to help derive TC G when an edge in a cycle of G is deleted. Roughly, we maintain H as follows. <p> We maintain TC G as follows. Insertions are handled as usual. Suppose (a; b) 2 G o is deleted. If a and b are not in the same strongly connected component (SCC) of G o , then we derive TC G using a query in <ref> [DS95b] </ref> (an extension of the query in Example 3.2). This is similar to the case for acyclic graphs. Suppose a and b are in a common SCC of G o (Figure 7).
Reference: [DS97] <author> G. Dong and J. Su. </author> <title> Deterministic foies are strictly weaker. </title> <journal> Annals of Mathe--matics and Artificial Intelligence, </journal> <pages> 19(3-4), </pages> <year> 1997. </year>
Reference-contexts: In general, foies can be nondeterministic since the auxiliary relations may be defined by nondeterministic mappings. If the auxiliary relations are defined by deterministic mappings, then the foies is said to be deterministic. In <ref> [DS97] </ref> we compare the deterministic foies with nondeterministic foies, and we show among other things that nondeterministic foies are more powerful and more space efficient than deterministic ones. <p> The example query (i.e., k-Mod-4) used in showing the strictness of the foies arity hierarchy also implies that the deterministic foies arity hierarchy is strict, thus answering our own problem in <ref> [DS97] </ref>. In addition to related work on view maintenance cited earlier, there are three other groups of related work. (i) The first group is the Dyn-FO framework of [PI94]. There are similarities as well as differences between Dyn-FO and our foies. Both use first-order formulas as maintenance queries. <p> The proof of that result also settles the open problem raised in our earlier paper <ref> [DS97] </ref> on the "deterministic" version of the FOIES k hierarchy. We also discuss the impact of the arity of the input databases on the arity hierarchies. We show that FOIES k 6= FOIES k+1 for each k 2 N. <p> Since C is an AC 0 circuit, it has a polynomial size (in m), contradicting Theorem 6.1. In <ref> [DS97] </ref>, we considered "deterministic" foies, which are foies with the restriction that the auxiliary relations are defined by (fixpoint) queries. This severely limits the power of foies. For example, a deterministic foies cannot maintain a total order of the active domain. In [DS97], we proved that the corresponding arity-based hierarchy det-FOIES <p> In <ref> [DS97] </ref>, we considered "deterministic" foies, which are foies with the restriction that the auxiliary relations are defined by (fixpoint) queries. This severely limits the power of foies. For example, a deterministic foies cannot maintain a total order of the active domain. In [DS97], we proved that the corresponding arity-based hierarchy det-FOIES k is strict at small arities 6 2 and conjectured that it is strict at each arity. <p> Corollary 6.4 1. For each integer k &gt; 0, (det-)FOIES 6k+1 k1 6= (det-)FOIES 6k+1 k . 2. FOIES 1 sf 6= FOIES 1 0 . 3. FOIES 2 0 6= FOIES 2 1 . 4. FOIES 2 1 6= FOIES 2 2 . In <ref> [DS97] </ref> it was shown that the det-FOIES k hierarchy collapses at level 0 if the input arity is limited to 1: S k det-FOIES 1 k = det-FOIES 1 0 .
Reference: [DST95] <author> G. Dong, J. Su, and R. Topor. </author> <title> Nonrecursive incremental evaluation of data-log queries. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 14(2-4):187-223, 1995. (Also appeared as Uni Melbourne CS TR 93/3, </note> <month> March </month> <year> 1993). </year>
Reference-contexts: In particular, a framework of evaluating recursive queries (or maintaining recursive views) by incrementally evaluating some non-recursive, first-order queries has been proposed and studied by Dong, Su, and Topor <ref> [DST95, DS95b, DS93] </ref>; a slightly different framework was proposed and studied by Patnaik and Immerman [PI94]. <p> This approach also gives pure relational database systems the power of supporting recursive views without resorting to programming in host languages. It has been shown that many database queries, including regular chain datalog (plus a particular kind of initialization) <ref> [DT92, DS95a, DST95] </ref>, transitive closure over acyclic graphs [DS95b] and over undirected graphs [PI94], can be maintained in this way. <p> Motivated from the view maintenance problem of databases, our approach uses only relations and has none of the above non-logical features. A comparison of our approach with other methods for the incremental evaluation of database queries is given in <ref> [DST95] </ref>. The paper is organized as follows. Section 2 reviews some basic notions including, in 2 particular, foies. Section 3 discusses the classes FOIES 0 and FOIES 1 and their relationships to monadic 1 1 . Section 4 focuses on queries in FOIES 2 . <p> as a predicate.) TC G (x; y) = TC G o (x; y) _ d TC G o (x; u) ^ d TC G o (v; y) The above provides an efficient way of updating (computing) the transitive closure query; more general results for insertion-only foies can be found in <ref> [DT92, DS93, DST95] </ref>. 9 Example 3.2 Consider now the transitive closure query defined over acyclic directed graphs. It has a space-free foies, for both insertions and deletions. Insertions are dealt with as in Example 3.1. <p> For regular chain datalog queries, we can assert that they all have binary insertion-only foies <ref> [DT92, DST95] </ref>, and some of them (such as the transitive closure) do not have unary insertion-only foies.
Reference: [DT92] <author> G. Dong and R. Topor. </author> <title> Incremental evaluation of datalog queries. </title> <booktitle> In Proc. Int'l Conference on Database Theory, </booktitle> <pages> pages 282-296, </pages> <address> Berlin, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This approach also gives pure relational database systems the power of supporting recursive views without resorting to programming in host languages. It has been shown that many database queries, including regular chain datalog (plus a particular kind of initialization) <ref> [DT92, DS95a, DST95] </ref>, transitive closure over acyclic graphs [DS95b] and over undirected graphs [PI94], can be maintained in this way. <p> as a predicate.) TC G (x; y) = TC G o (x; y) _ d TC G o (x; u) ^ d TC G o (v; y) The above provides an efficient way of updating (computing) the transitive closure query; more general results for insertion-only foies can be found in <ref> [DT92, DS93, DST95] </ref>. 9 Example 3.2 Consider now the transitive closure query defined over acyclic directed graphs. It has a space-free foies, for both insertions and deletions. Insertions are dealt with as in Example 3.1. <p> For regular chain datalog queries, we can assert that they all have binary insertion-only foies <ref> [DT92, DST95] </ref>, and some of them (such as the transitive closure) do not have unary insertion-only foies.
Reference: [DW97] <author> G. Dong and L. Wong. </author> <title> Some relationships between foies and 1 1 arity hierarchies. </title> <journal> Bulletin of the European Association of Theoretical Computer Science, </journal> <volume> 61, </volume> <month> February </month> <year> 1997. </year>
Reference: [Ehr61] <author> A. Ehrenfeucht. </author> <title> An application of games to the completeness problem for for malized theories. </title> <journal> Fund. Math, </journal> <volume> 49, </volume> <year> 1961. </year>
Reference-contexts: We further prove that these queries do not have foies with lower arity bounds using proof techniques based on Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref>. On the other hand, we show that the arity-based hierarchy FOIES k is strict for all arities. We define a k-Mod-4 query for each k 2 N and show that it is in FOIES k but not in FOIES k1 . <p> The proofs are based on Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref>. Specifically, we show that Mod-3 is not in FOIES sf , Equal-Length-Chain is not in FOIES 0 , and many other queries including 2-colorability, transitive closure over 1-path graphs and over undirected graphs, and various connectivity queries, etc. are not in FOIES 1 .
Reference: [Fag75] <author> R. Fagin. </author> <title> Monadic generalized spectra. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 21 </volume> <pages> 89-96, </pages> <year> 1975. </year>
Reference-contexts: The result that Equal-Length-Chain 62 FOIES 0 will be established in Theorem 5.4 using Ehrenfeucht-Frasse games. It is interesting to compare the FOIES 61 classes with monadic 1 1 . On one hand, the query Even is in FOIES sf (Example 2.3) but not in monadic 1 1 <ref> [Fag75, AF90, FSV95] </ref>. On the other hand, disconnectivity of undirected graphs is in 1 1 [AF90] but not in FOIES 1 and 11 1 not in FOIES sf (Theorem 5.7). Therefore, monadic 1 1 is incomparable with FOIES 61 classes and with FOIES sf (Figure 3). 4 FOIES 1 vs. <p> Proposition 5.1 Let ' be a first-order sentence with quantifier depth r and I; J two structures. If I j= ' and I r J , then J j= '. Ehrenfeucht-Frasse games and extensions are a very useful tool in proving expressive power of query languages (e.g., <ref> [Fag75, AF90, AHV95, GS94] </ref>). But they cannot be used directly in proving results concerning foies, since the process of incremental evaluation is not 23 strictly first order.
Reference: [Fra54] <author> R. Frasse. </author> <title> Sur les classifications des systemes de relations. </title> <type> Publ. </type> <institution> Sci. Univ Alger, I:1, </institution> <year> 1954. </year>
Reference-contexts: We further prove that these queries do not have foies with lower arity bounds using proof techniques based on Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref>. On the other hand, we show that the arity-based hierarchy FOIES k is strict for all arities. We define a k-Mod-4 query for each k 2 N and show that it is in FOIES k but not in FOIES k1 . <p> The proofs are based on Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref>. Specifically, we show that Mod-3 is not in FOIES sf , Equal-Length-Chain is not in FOIES 0 , and many other queries including 2-colorability, transitive closure over 1-path graphs and over undirected graphs, and various connectivity queries, etc. are not in FOIES 1 .
Reference: [FSV95] <author> R. Fagin, L. J. Stockmeyer, and M. Y. Vardi. </author> <title> On monadic NP vs. monadic co-NP. </title> <journal> Information & Computation, </journal> <volume> 120(1) </volume> <pages> 78-93, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: The result that Equal-Length-Chain 62 FOIES 0 will be established in Theorem 5.4 using Ehrenfeucht-Frasse games. It is interesting to compare the FOIES 61 classes with monadic 1 1 . On one hand, the query Even is in FOIES sf (Example 2.3) but not in monadic 1 1 <ref> [Fag75, AF90, FSV95] </ref>. On the other hand, disconnectivity of undirected graphs is in 1 1 [AF90] but not in FOIES 1 and 11 1 not in FOIES sf (Theorem 5.7). Therefore, monadic 1 1 is incomparable with FOIES 61 classes and with FOIES sf (Figure 3). 4 FOIES 1 vs.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1995. </year>
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, and V. S. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 157-166, </pages> <year> 1993. </year>
Reference: [GS94] <author> S. Grumbach and J. Su. </author> <title> Finitely representable databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Proposition 5.1 Let ' be a first-order sentence with quantifier depth r and I; J two structures. If I j= ' and I r J , then J j= '. Ehrenfeucht-Frasse games and extensions are a very useful tool in proving expressive power of query languages (e.g., <ref> [Fag75, AF90, AHV95, GS94] </ref>). But they cannot be used directly in proving results concerning foies, since the process of incremental evaluation is not 23 strictly first order.
Reference: [Hul86] <author> R. Hull. </author> <title> Relative information capacity of simple relational schemata. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(3) </volume> <pages> 856-886, </pages> <year> 1986. </year>
Reference-contexts: A k-ary query from S in to R Q is a (possibly partial) mapping Q from inst (S in ) to relation instances of R Q satisfying the following "genericity" criterion <ref> [CH82, Hul86] </ref>: For each permutation of dom, Q commutes with ( is extended naturally to relations and databases), i.e., 3 8I 2 inst (S in ); Q ((I)) = (Q (I)). We will refer to relation names in S in (and their instances) as base relations for Q.
Reference: [Kol95] <author> P. G. Kolaitis. </author> <title> A tutorial on combinatorial games in database theory. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1995. </year> <month> 41 </month>
Reference-contexts: Since F is a foies for Mod-3, '(I 1 ) and '(I 2 ) should produce different answers. However, by construction jI i j &gt; d for i = 1; 2, the duplicator has a winning strategy of d-round 24 Ehrenfeucht-Frasse games on I 1 and I 2 <ref> [Kol95] </ref>. It implies that ' cannot distinguish I 1 and I 2 , a clear contradiction. Space-free foies do not have auxiliary relations other than the query answer. <p> The winning strategy is similar to the winning strategy for the Ehrenfeucht-Frasse games on linear orders <ref> [Kol95] </ref>. Hence ffiI f r ffiI 0 . This contradicts the fact that yields different results on ffiI and ffiI 0 . We next consider the class FOIES 1 . Recall that each unary foies may store a fixed number of unary auxiliary relations during the incremental evaluation. <p> The argument is again based on d-round f -games where f maps the two nodes incident to the inserted edge in ffi 1 to corresponding nodes incident to the inserted edge in ffi 2 . The duplicator's winning strategy is again quite similar to the games for linear orders <ref> [Kol95] </ref>. Theorem 5.6 The transitive closure query over 1-path graphs is not in FOIES 1 . Proof: The proof is accomplished by exhibiting a database (a 1-path graph) and two separate updates which cannot be distinguished by the first-order aux-maintaining queries of an 27 assumed unary foies. <p> Since the segment length 2n is exponential in the number of rounds to play, the spoiler will not tell the difference between the two segments nor make any connection from a; b; c; d to s; t. The details of the strategy resemble again those for the connectivity query <ref> [Kol95] </ref>. Using the same approach with different graphs and update sequences, or reductions to queries known to be outside of FOIES 1 , we can establish the following.
Reference: [Kuc91] <author> V. Kuchenhoff. </author> <title> On the efficient computation of the difference between consecu-tive database states. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proc. Second Int. Conf. on Deductive Object-Oriented Databases, volume 566 of LNCS, </booktitle> <pages> pages 478-502. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [MSVT94] <author> P. B. Miltersen, S. Subramanian, J. S. Vitter, and R. Tamassia. </author> <title> Complexity models for incremental computation. </title> <journal> Theoretical Computer Science, </journal> <volume> 130(1) </volume> <pages> 203-236, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: A more general complexity-theoretical framework for on-line or incremental computation is reported in <ref> [MSVT94] </ref>. Motivated from the view maintenance problem of databases, our approach uses only relations and has none of the above non-logical features. A comparison of our approach with other methods for the incremental evaluation of database queries is given in [DST95]. The paper is organized as follows.
Reference: [PI94] <author> S. Patnaik and N. Immerman. </author> <title> Dyn-FO: A parallel dynamic complexity class. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 210-221, </pages> <year> 1994. </year>
Reference-contexts: In particular, a framework of evaluating recursive queries (or maintaining recursive views) by incrementally evaluating some non-recursive, first-order queries has been proposed and studied by Dong, Su, and Topor [DST95, DS95b, DS93]; a slightly different framework was proposed and studied by Patnaik and Immerman <ref> [PI94] </ref>. <p> It has been shown that many database queries, including regular chain datalog (plus a particular kind of initialization) [DT92, DS95a, DST95], transitive closure over acyclic graphs [DS95b] and over undirected graphs <ref> [PI94] </ref>, can be maintained in this way. If a (finite) set of first-order queries maintains the answers to a query (and necessary auxiliary relations), we call the set a "first-order incremental evaluation system" (or "foies") for the query of interest. <p> We construct foies with low arity bounds for these queries. In particular, we show that the transitive closure query for undirected graphs is in FOIES 2 ; this solves an open problem raised by Patnaik and Immerman in <ref> [PI94] </ref>. We further prove that these queries do not have foies with lower arity bounds using proof techniques based on Ehrenfeucht-Frasse games [Fra54, Ehr61]. On the other hand, we show that the arity-based hierarchy FOIES k is strict for all arities. <p> In addition to related work on view maintenance cited earlier, there are three other groups of related work. (i) The first group is the Dyn-FO framework of <ref> [PI94] </ref>. There are similarities as well as differences between Dyn-FO and our foies. Both use first-order formulas as maintenance queries. However, Dyn-FO deals with problems which do not seem to correspond to database queries. <p> Therefore, monadic 1 1 is incomparable with FOIES 61 classes and with FOIES sf (Figure 3). 4 FOIES 1 vs. FOIES 2 (Unary vs. Binary) Patnaik and Immerman <ref> [PI94] </ref> showed that transitive closure of undirected graphs can be maintained in first order with ternary auxiliary relations, and posed the open problem of whether binary auxiliary relations suffice. <p> We also show that a number of other conventional queries are in FOIES 2 but not in FOIES 1 . In resolving the open problem, the key idea in the construction is to store a directed "spanning forest", instead of the undirected spanning forest as in <ref> [PI94] </ref>, for each undi-rected graph. This idea is applied to two other problems (minimum spanning trees and 2-colorability) on undirected graphs. <p> a ternary input relation, where the first two columns specify edges and the third column specifies the weight of the edge, the problem is to return a spanning forest with minimal weight.) The maintenance queries are constructed in a way similar to 20 the ones used by Patnaik and Immerman <ref> [PI94] </ref> except that we derive their auxiliary P from our H and TC H : P (x; y; u) says u is on the unique path in F from x to y and is expressed as "'(x; y; u)_'(y; x; u)" where '(x; y; u) is TC H (x; y) ^
Reference: [RRSS94] <author> R. Ramakrishnan, K. A. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Efficient incremental evaluation of queries with aggregation. </title> <booktitle> In Int. Logic Programming Symp., </booktitle> <year> 1994. </year>
Reference: [WDSY91] <author> O. Wolfson, H. M. Dewan, S. J. Stolfo, and Y. Yemini. </author> <title> Incremental evaluation of rules and its relationship to parallelism. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 78-87, </pages> <year> 1991. </year>
References-found: 31

