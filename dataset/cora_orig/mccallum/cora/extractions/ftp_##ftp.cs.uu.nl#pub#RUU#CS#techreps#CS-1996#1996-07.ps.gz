URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1996/1996-07.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Termination of Constructor Systems  
Author: Thomas Arts Jurgen Giesl 
Abstract: We present a method to prove termination of constructor systems automatically. Our approach takes advantage of the special form of these rewrite systems because for constructor systems instead of left- and right-hand sides of rules it is sufficient to compare so-called dependency pairs [Art96]. Unfortunately, standard techniques for the generation of well-founded orderings cannot be directly used for the automation of the dependency pair approach. To solve this problem we have developed a transformation technique which enables the application of known synthesis methods for well-founded order-ings to prove that dependency pairs are decreasing. In this way termination of many (also non-simply terminating) constructor systems can be proved fully automatically.
Abstract-found: 1
Intro-found: 1
Reference: [Art96] <author> T. </author> <title> Arts. Termination by absence of infinite chains of dependency pairs. </title> <booktitle> In Proc. Colloquium on Trees in Algebra and Programming, </booktitle> <address> Linkoping, Sweden, </address> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems. Therefore, in this paper we focus on a technique specially tailored for CSs, viz. the so-called dependency pair approach <ref> [Art96] </ref>. With this approach it is also possible to prove termination of systems where all simplification orderings fail. In Sect. 2 we describe which steps have to be performed (automatically) to verify termination of CSs using this approach. <p> For all theorems of this section, proofs (which are based on semantic labelling [Zan95]) can be found in <ref> [Art96] </ref>. <p> For the first task, in <ref> [Art96] </ref> a method is presented to generate suited CSs E for a subclass of CSs R automatically: Suppose that R is a non-overlapping 2 hierarchical combination [Gra95] of R 0 with R 1 where R 0 is terminating. <p> we already proved termination of the first two minus-rules 3 , then we now only have to prove termination of the quot-rules and let 1 In many examples it is sufficient if only certain dependency pairs are decreasing and several methods to determine those dependency pairs have been suggested in <ref> [Art96] </ref>. 2 This requirement can even be weakened to overlay systems with joinable critical pairs. 3 This can for instance be done with standard techniques like e.g. the recursive path ordering [Der82] or again by the dependency pair approach. <p> For every CS, a set of dependency pairs is given. Note that not all dependency pairs are given. Only those dependency pairs that are relevant are listed. For more information about which dependency pairs are relevant and which are not, we refer to <ref> [Art96] </ref>. 1 Division, Version 1 This is the running example of this report. <p> Our method works as follows: * For a CS R a ground-convergent CS E is synthesised in which R is contained. (For CSs that are hierarchical combinations of a certain type, a suited E can be immediately obtained automatically, cf. <ref> [Art96] </ref>.) * Let DP be the set of inequalities which ensure that all dependency pairs are decreasing.
Reference: [BD86] <author> L. Bachmair & N. Dershowitz. </author> <title> Commutation, transformation and termination. </title> <booktitle> In Proc. 8th CADE, </booktitle> <publisher> LNCS 230, Oxford, </publisher> <address> England, </address> <year> 1986. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BL90] <author> F. Bellegarde & P. Lescanne. </author> <title> Termination by completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 1 </volume> <pages> 79-96, </pages> <year> 1990. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BL93] <author> E. Bevers & J. Lewi. </author> <title> Proving termination of (conditional) rewrite systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 537-568, </pages> <year> 1993. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>), which may be advantageous for further sophisticated termination proofs.
Reference: [BCL87] <author> A. Ben Cherifa & P. Lescanne. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(2) </volume> <pages> 137-159, </pages> <year> 1987. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BHHW86] <author> S. Biundo, B. Hummel, D. Hutter & C. Walther. </author> <title> The Karlsruhe induction theorem proving system. </title> <booktitle> In Proc. of the 8th International Conference on Automated Deduction, </booktitle> <publisher> LNCS 230, Oxford, </publisher> <address> England, </address> <year> 1986. </year>
Reference-contexts: Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. [BM79, BL93, Wal94, Gie95d]), which may be advantageous for further sophisticated termination proofs.
Reference: [BKR92] <author> A. Bouhoula, E. Kounalis & M. Rusinowitch. spike: </author> <title> an automatic theorem prover. </title> <booktitle> In Proc. of the Conference on Logic Programming and Automated Reasoning, </booktitle> <publisher> LNAI 624, </publisher> <address> St. Petersburg, Russia, </address> <year> 1992. </year>
Reference-contexts: Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. [BM79, BL93, Wal94, Gie95d]), which may be advantageous for further sophisticated termination proofs.
Reference: [BM79] <author> R. S. Boyer & J S. Moore. </author> <title> A computational logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: This example was taken from <ref> [BM79] </ref> resp. [Wal91]. <p> All remaining function symbols are mapped to the constant 0. This results in a suitable well-founded quasi-order. This example is inspired by an algorithm from <ref> [BM79] </ref> and [Wal94]. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm. <p> Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. [BM79, BL93, Wal94, Gie95d]), which may be advantageous for further sophisticated termination proofs. <p> Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>), which may be advantageous for further sophisticated termination proofs.
Reference: [BHHS90] <author> A. Bundy, F. van Harmelen, C. Horn & A. Smaill. </author> <title> The oyster-clam system. </title> <booktitle> In Proc. 10th CADE, </booktitle> <publisher> LNAI 449, </publisher> <address> Kaiserslautern, Germany, </address> <year> 1990. </year>
Reference-contexts: Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. [BM79, BL93, Wal94, Gie95d]), which may be advantageous for further sophisticated termination proofs.
Reference: [Der79] <author> N. Dershowitz. </author> <title> A note on simplification orderings. </title> <journal> Information Processing Letters, </journal> <volume> 9(5) </volume> <pages> 212-215, </pages> <year> 1979. </year>
Reference-contexts: following CS: minus (x; 0) ! x; minus (succ (x); succ (y)) ! minus (x; y); quot (0; succ (y)) ! 0; quot (succ (x); succ (y)) ! succ (quot (minus (x; y); succ (y))): Most methods for automated termination proofs of term rewriting systems are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot prove termination of the above CS, because no simplification ordering can orient the fourth rule if y is instantiated to succ (x).
Reference: [Der82] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> if only certain dependency pairs are decreasing and several methods to determine those dependency pairs have been suggested in [Art96]. 2 This requirement can even be weakened to overlay systems with joinable critical pairs. 3 This can for instance be done with standard techniques like e.g. the recursive path ordering <ref> [Der82] </ref> or again by the dependency pair approach. <p> The constraint DP = fF (succ (x)) F (double (x))g is for instance satisfied by the recursive path ordering rpo (with the precedence succ &gt; double), cf. <ref> [Der82] </ref>. Nevertheless, R is not terminating (e.g. f (succ (succ (0))) starts a cycling reduction). This direct application of orderings is not possible because the constraints in DP only compare the terms s and t but not their E-interpretations. <p> consist of the two minus-rules and we obtain the constraint DP = fQ (succ (x); succ (y)) Q (minus (x; y); succ (y))g: (4) None of the well-founded quasi-orderings that can be generated automatically by the usual techniques satisfies DP [ EQ: Virtually all of those quasi-orderings are quasi-simplification-orderings 4 <ref> [Der82] </ref>. Hence, if % is a quasi-simplification-ordering satisfying EQ, then we have Q (minus (x; y); succ (y)) ~ Q (minus (succ (x); succ (y)); succ (y)) (as minus (x; y) ~ minus (succ (x); succ (y)) holds and as quasi-simplification-orderings are (weakly) monotonic).
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1, </volume> 2):69-115, 1987. 
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems.
Reference: [DJ90] <author> N. Dershowitz & J.-P. Jouannaud. </author> <title> Rewrite systems. Handbook of The-oret. Comp. Sc., </title> <editor> J. van Leeuwen, ed., </editor> <volume> vol. </volume> <editor> B, ch. </editor> <volume> 6, </volume> <pages> pp. 243-320, </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <month> 27 </month>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. <ref> [DJ90] </ref>.
Reference: [DH95] <author> N. Dershowitz & C. Hoot. </author> <title> Natural Termination. </title> <journal> Theoretical Computer Science, </journal> <volume> 142(2) </volume> <pages> 179-207, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [FZ95] <author> M. C. F. Ferreira & H. Zantema. </author> <title> Dummy elimination: making termination easier. </title> <booktitle> In Proc. of the 10th International Conference on Fundamentals of Computation Theory, LNCS 965, </booktitle> <address> Dresden, Germany, </address> <year> 1995 </year>
Reference-contexts: The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))): All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [Gie95a] <institution> J. Giesl, Automatisierung von Terminierungsbeweisen fur rekursiv de-finierte Algorithmen. Doctoral Dissertation, Technische Hochschule Darmstadt, Germany, </institution> <year> 1995. </year>
Reference-contexts: x+ y. 24 13 Reachability on Directed Graphs To check whether there is a path from the node x to the node y in a directed graph g, the term reach (x; y; g; *) must be reducible to true with the rules of the CS of this example from <ref> [Gie95a] </ref>. The fourth argument of reach is used to store edges that have already been examined but that are not included in the actual solution path. If an edge from u to v (with x 6= u) is found, then it is rejected at first.
Reference: [Gie95b] <author> J. Giesl. </author> <title> Generating polynomial orderings for termination proofs. </title> <booktitle> In Proc. 6th RTA, LNCS 914, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Methods for the automated generation of such polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way termination of the CS for minus and quot can be proved fully automatically. 5. Examples This collection of examples demonstrates the power of the described method. Several of these examples are not simply terminating. <p> These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive interpretations automatically <ref> [Gie95b, Ste94] </ref>. Unfortunately, this polynomial approach, although very powerful, is not a decision procedure. For many examples, a different approach based on the recursive path ordering (rpo) can also be used, which results in a more effective method. <p> Therefore in this way termination of many CSs can be proved automatically where all other known techniques fail. Our method has been tested on numerous practically relevant CSs from different areas of computer science (using a system for the automated generation of polynomial orderings <ref> [Gie95b] </ref>) and proved successful. 26 A collection of examples which demonstrate the power of our method (including arithmetical operations such as gcd and logarithm, several sorting algorithms such as quicksort or selection sort as well as functions on trees and graphs (e.g. a reacha-bility algorithm)) has been presented in Sect. 5.
Reference: [Gie95c] <author> J. Giesl. </author> <title> Automated termination proofs with measure functions. </title> <booktitle> In Proc. 19th Annual German Conf. on AI, </booktitle> <publisher> LNAI 981, </publisher> <address> Bielefeld, Ger-many, </address> <year> 1995. </year>
Reference-contexts: Wa 652/7-1 as part of the focus program "Deduktion". z Utrecht University, E-mail: thomas@cs.ruu.nl x FB Informatik, TH Darmstadt, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@inferenzsysteme.informatik.th-darmstadt.de 1 <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems.
Reference: [Gie95d] <author> J. Giesl. </author> <title> Termination analysis for functional programs using term or-derings. </title> <booktitle> In Proc. of the Second International Static Analysis Symposium, LNCS 983, </booktitle> <address> Glasgow, Scotland, </address> <year> 1995. </year>
Reference-contexts: Wa 652/7-1 as part of the focus program "Deduktion". z Utrecht University, E-mail: thomas@cs.ruu.nl x FB Informatik, TH Darmstadt, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@inferenzsysteme.informatik.th-darmstadt.de 1 <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. <p> Hence, if g (u fl ) % g (u fl ) holds for all these subterms, then this implies est (t) % t. 5 While in the original estimation method for functional programs <ref> [Gie95d] </ref> functions had to be completely defined, here we have to extend the estimation method to incompletely defined functions. <p> Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>), which may be advantageous for further sophisticated termination proofs.
Reference: [Gra95] <author> B. Gramlich. </author> <title> Abstract relations between restricted termination and confluence properties of rewrite systems. </title> <journal> Fundam. Informaticae, </journal> <volume> 24 </volume> <pages> 3-23, </pages> <year> 1995. </year>
Reference-contexts: For the first task, in [Art96] a method is presented to generate suited CSs E for a subclass of CSs R automatically: Suppose that R is a non-overlapping 2 hierarchical combination <ref> [Gra95] </ref> of R 0 with R 1 where R 0 is terminating.
Reference: [HL78] <author> G. Huet & D. S. Lankford. </author> <title> On the uniform halting problem for term rewriting systems. </title> <institution> Rapport Laboria 283, Institut de Recherche d'In-formatique et d'Automatique, Le Chesnay, France, </institution> <year> 1978. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable <ref> [HL78] </ref>, several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [KZ89] <author> D. Kapur & H. Zhang. </author> <title> An overview of Rewrite Rule Laboratory (rrl). </title> <booktitle> In Proc. 3rd RTA, LNCS 355, </booktitle> <address> Chapel Hill, NC, </address> <year> 1989. </year>
Reference-contexts: Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. [BM79, BL93, Wal94, Gie95d]), which may be advantageous for further sophisticated termination proofs.
Reference: [Ken95] <author> R. Kennaway. </author> <title> Complete term rewrite systems for decimal arithmetic and other total recursive functions. </title> <booktitle> Presented at the Second International Workshop on Termination, </booktitle> <address> La Bresse, France, </address> <year> 1995. </year>
Reference-contexts: The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))): All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [Klo92] <author> J. W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, D. M. Gabbay & T. S. E. Maibaum (eds.), </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> vol. 2, </volume> <pages> pp. 1-116, </pages> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [KB70] <author> D. E. Knuth & P. B. Bendix. </author> <title> Simple word problems in universal algebras. Computational Problems in Abstract Algebra, </title> <editor> J. Leech, ed., </editor> <publisher> Pergamon Press, </publisher> <pages> pp. 263-297, </pages> <year> 1970. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, Mar87] </ref>, semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [Lan79] <author> D. S. Lankford. </author> <title> On proving term rewriting systems are noetherian. </title> <type> Tech. Report Memo MTP-3, </type> <institution> Louisiana Tech. University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Hence, demanding DP [ EQ is too strong, i.e. in this way most termination proofs will not succeed. 4 DP [ EQ is not satisfied by polynomial orderings <ref> [Lan79] </ref> either (which do not have to be quasi-simplification-orderings). 5 3.3. <p> For instance, we can use a polynomial ordering <ref> [Lan79] </ref> where the function symbol 0 is mapped to the number 0, succ (x) is mapped to x+ 1 and Q (x; y) and minus (x; y) are both mapped to the polynomial x. <p> For all examples of this section, a well-founded ordering satisfying DP 0 can be obtained using the algebra consisting of the natural numbers with their normal ordering in combination with polynomial orderings that map terms into the natural numbers <ref> [Lan79] </ref>. These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive interpretations automatically [Gie95b, Ste94]. Unfortunately, this polynomial approach, although very powerful, is not a decision procedure.
Reference: [Mar87] <author> U. Martin. </author> <title> How to choose weights in the Knuth-Bendix ordering. </title> <booktitle> In Proc. 2nd RTA, LNCS 256, </booktitle> <address> Bordeaux, France, </address> <year> 1987. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, Mar87] </ref>, semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [Pla78] <author> D. A. Plaisted. </author> <title> A recursively defined ordering for proving termination of term rewriting systems. </title> <type> Report R-78-943, </type> <institution> Dept. of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1978. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [Pla85] <author> D. A. Plaisted. </author> <title> Semantic confluence tests and completion methods. </title> <journal> Inform. and Control, </journal> 65(2/3):182-215, 1985. <volume> 28 </volume>
Reference-contexts: This allows to prove termination of CSs that are not sufficiently complete <ref> [Pla85] </ref>, too. 9 All subterms g (u fl ) in t are &gt; E -smaller than f (r fl ).
Reference: [Ste92] <author> J. Steinbach. </author> <title> Notes on Transformation Orderings. </title> <address> SEKI-Report SR--92-23, Universitat Kaiserslautern, Germany, </address> <year> 1992. </year>
Reference-contexts: All remaining function symbols are mapped to the constant 0. This results in a suitable well-founded quasi-order. This example is inspired by an algorithm from [BM79] and [Wal94]. In the corresponding example from <ref> [Ste92] </ref> the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Generating polynomial orderings. </title> <journal> Information Processing Letters, </journal> <volume> 49 </volume> <pages> 85-93, </pages> <year> 1994. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Methods for the automated generation of such polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way termination of the CS for minus and quot can be proved fully automatically. 5. Examples This collection of examples demonstrates the power of the described method. Several of these examples are not simply terminating. <p> These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive interpretations automatically <ref> [Gie95b, Ste94] </ref>. Unfortunately, this polynomial approach, although very powerful, is not a decision procedure. For many examples, a different approach based on the recursive path ordering (rpo) can also be used, which results in a more effective method.
Reference: [Ste95a] <author> J. Steinbach. </author> <title> Automatic termination proofs with transformation or-derings. </title> <booktitle> In Proc. 6th RTA, LNCS 914, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))): All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible. <p> This example was taken from [BM79] resp. [Wal91]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings <ref> [Ste95a] </ref>, but there the rules for le and minus were missing. 6 Logarithm, Version 1 The following CS computes the dual logarithm. half (0) ! 0 half (succ (succ (x))) ! succ (half (x)) log (0) ! 0 log (succ (succ (x))) ! succ (log (succ (half (x)))) The relevant dependency <p> This example comes from [Wal91] and a similar example was mentioned in <ref> [Ste95a] </ref>, but in Steinbach's version the rules for eq and if rm were missing. <p> Steinbach could prove termination of a corresponding example with transformation orderings <ref> [Ste95a] </ref>, but in his example the rules for le, if low if high and app were omitted.
Reference: [Ste95b] <author> J. Steinbach. </author> <title> Simplification orderings: history of results. </title> <journal> Fundamenta Informaticae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems. <p> following CS: minus (x; 0) ! x; minus (succ (x); succ (y)) ! minus (x; y); quot (0; succ (y)) ! 0; quot (succ (x); succ (y)) ! succ (quot (minus (x; y); succ (y))): Most methods for automated termination proofs of term rewriting systems are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot prove termination of the above CS, because no simplification ordering can orient the fourth rule if y is instantiated to succ (x).
Reference: [Wal91] <author> C. Walther. </author> <title> Automatisierung von Terminierungsbeweisen. </title> <publisher> Vieweg Ver-lag, </publisher> <address> Braunschweig, Germany, </address> <year> 1991. </year>
Reference-contexts: This example was taken from [BM79] resp. <ref> [Wal91] </ref>. <p> This example comes from <ref> [Wal91] </ref> and a similar example was mentioned in [Ste95a], but in Steinbach's version the rules for eq and if rm were missing.
Reference: [Wal94] <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: Wa 652/7-1 as part of the focus program "Deduktion". z Utrecht University, E-mail: thomas@cs.ruu.nl x FB Informatik, TH Darmstadt, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@inferenzsysteme.informatik.th-darmstadt.de 1 <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. <p> But this version here is even more difficult: Termination of the corresponding algorithm cannot be proved by the method of <ref> [Wal94] </ref>, because this method cannot deal with permutations of arguments.) The relevant dependency pairs of this CS are hLe (succ (x); succ (y); Le (x; y)i hM (x; succ (y)); M (x; y)i hGCD (succ (x); succ (y)); IF gcd (le (y; x); succ (x); succ (y))i hIF gcd (true; succ <p> of the last rule, add (n; purge (rm (n; x))), the n would be replaced by a term containing add (n; x) then we would obtain a non-simply terminating CS, but termination could still be proved with our method in the same way. 9 Selection Sort The CS below, from <ref> [Wal94] </ref>, is obviously not simply terminating. The CS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list. <p> All remaining function symbols are mapped to the constant 0. This results in a suitable well-founded quasi-order. This example is inspired by an algorithm from [BM79] and <ref> [Wal94] </ref>. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm. <p> With our method termination could still be proved in the same way. 12 Permutation of Lists This example is a CS from <ref> [Wal94] </ref> to compute a permutation of a list, for instance, shu*e ([1; 2; 3; 4; 5]) reduces to [1; 5; 2; 4; 3]. app (empty; y) ! y app (add (n; x); y) ! add (n; app (x; y)) reverse (empty) ! empty reverse (add (n; x)) ! app (reverse (x); <p> Future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). Then for the elimination of defined symbols apart from estimation additional transformation techniques may be possible (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>), which may be advantageous for further sophisticated termination proofs.
Reference: [Zan94] <author> H. Zantema. </author> <title> Termination of term rewriting: interpretation and type elimination. </title> <journal> Journal of Symbolic Computation 17 </journal> <pages> 23-50, </pages> <year> 1994. </year>
Reference-contexts: 1. Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation or-derings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))): All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [Zan95] <author> H. Zantema. </author> <title> Termination of term rewriting by semantic labelling. </title> <journal> Fun-damenta Informaticae, </journal> <volume> 24 </volume> <pages> 89-105, </pages> <year> 1995. </year> <month> 29 </month>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation or-derings [BD86, BL90, Ste95a], semantic labelling <ref> [Zan95] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> If there exists a well-founded ordering on ground terms such that (s)# E (t)# E holds for all 1 dependency pairs hs; ti and all ground substitutions , then R is terminating. For all theorems of this section, proofs (which are based on semantic labelling <ref> [Zan95] </ref>) can be found in [Art96].
References-found: 37

