URL: http://www.cs.indiana.edu/~dyb/papers/lasc-imp.ps.gz
Refering-URL: http://www.cs.indiana.edu/~dyb/pubs.html
Root-URL: http://www.cs.indiana.edu
Email: (tungsh@mis.yuntech.edu.tw)  (dyb@cs.indiana.edu)  
Title: 0 TUNG AND DYBVIG Reliable Interactive Programming with Modules Keywords: Modules, Linking, Loading, Interactive Programming,
Author: SHO-HUAN SIMON TUNG R. KENT DYBVIG ronments. 
Date: (Received: October, 1994) (Revised: June, 1995)  
Address: Touliu, Taiwan, R.O.C  Bloomington, IN 47405 USA  
Affiliation: Department of Management and Information Systems National Yunlin Institute of Technology  Computer Science Department Indiana University  
Abstract: Interactive programming is a convenient programming style that supports fast prototyping and debugging but often results in a loss of modularity and security. This article addresses the problem of supporting reliable and modular interactive programming. A module system designed for interactive use is introduced. This module system supports separate compilation and automatic updating of module interfaces during program development. It also allows the programmer to obtain a fresh program state for reliable testing, eliminating the need to reload an entire program. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Harold Abelson and Gerald J. Sussman with Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1985. </year>
Reference-contexts: This goal is not entirely achieved, however, since interactively added bindings cannot access lexical variables in a module. This restriction is too strong to be acceptable. Some Scheme implementations support first-class environments <ref> [1] </ref>. A first-class environment captures the current lexical environment at the point when the first-class environment is created. When used with eval or access, which allow expressions or variables to be evaluated dynamically in a first-class environment, a form of modular programming can be supported.
Reference: 2. <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report. Technical Report 31, </type> <institution> DEC Systems Research Center, </institution> <year> 1988. </year>
Reference-contexts: However, ML's type system limits its flexibility as an interactive language and makes it difficult to support arbitrary module load order. Modula-2 [15], Modula-3 <ref> [2] </ref>, and Ada [14] are conventional modular languages. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: 3. <author> Pavel Curtis and James Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: In their system, imported variables are bound early in the module definition phase. This requires the module dependency to be acyclic and defeats possibilities for flexible interaction. Curtis and Rauen recently proposed a module system designed for large-scale programming in Scheme <ref> [3] </ref>. In their proposal, a module is an isolated scope which may be nested inside other modules. Modules are anonymous. They communicate with each other by sharing items specified in interfaces. Interfaces are named environments that may contain both syntax bindings and value bindings.
Reference: 4. <author> Harley Davis, Pierre Parquier, and Nitsan Seniak. </author> <title> Talking about modules and delivery. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 113-120, </pages> <year> 1994. </year>
Reference-contexts: They did not address, however, the problem of fitting RELIABLE INTERACTIVE PROGRAMMING WITH MODULES 3 their system into Scheme's interactive programming style. Talk is a modern Lisp dialect which contains a module system, a metaob-ject protocol, a transparent interface to C and C++, and an extensive set of libraries <ref> [4] </ref>. Talk's module system is designed to support easy and efficient application delivery. An executable Talk application contains several separately compiled modules and libraries. Talk distinguishes between compilation and execution dependencies. Compilation units can be automatically excluded from the delivered executable.
Reference: 5. <author> S. I. Feldman. </author> <title> Make: A program for maintaining computer programs. </title> <note> unpublished article. </note>
Reference-contexts: Upon discovery of an error, the programmer modifies and recompiles one or more modules of the program, and the integrity of the resulting executable is maintained by recompiling dependent pieces via software utilities such as the Unix make program <ref> [5] </ref>. Interactive programming environments allow programmers to alter existing definitions by entering new definitions directly into the system. Without fl A preliminary version of this article was presented at the 1992 ACM Conference on Lisp and Functional Programming.
Reference: 6. <author> Daniel P. Friedman and Matthias Felleisen. </author> <title> A closer look at export and import statements. </title> <booktitle> Computer Language, </booktitle> <volume> 11(1) </volume> <pages> 29-37, </pages> <year> 1986. </year>
Reference-contexts: Section 5 describes an implementation of the module system. Section 6 presents our conclusions. 2 TUNG AND DYBVIG 2. Related Work Friedman and Felleisen's module system <ref> [6] </ref> is one of only a few designed with consideration for interactive programming. Interactive languages require late binding for flexible program development. By restricting exported values to procedures, Friedman and Felleisen support various late binding techniques for defining modules and importing items.
Reference: 7. <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> The definition of Standard ML. </title> <type> Technical Report ECS-LFCS-89-81, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1989. </year> <note> 20 TUNG AND DYBVIG </note>
Reference-contexts: Talk distinguishes between compilation and execution dependencies. Compilation units can be automatically excluded from the delivered executable. The process of program development in Talk, however, adheres closely to the traditional compile-link-execute model. Standard ML is a statically scoped functional programming language with a secure polymorphic type system <ref> [7] </ref>. The module extension to Standard ML associates each module with two environments: a signature containing the interface of the module, and a structure containing the implementation of the module [8].
Reference: 8. <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proceedings of the 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year>
Reference-contexts: Standard ML is a statically scoped functional programming language with a secure polymorphic type system [7]. The module extension to Standard ML associates each module with two environments: a signature containing the interface of the module, and a structure containing the implementation of the module <ref> [8] </ref>. However, ML's type system limits its flexibility as an interactive language and makes it difficult to support arbitrary module load order. Modula-2 [15], Modula-3 [2], and Ada [14] are conventional modular languages.
Reference: 9. <author> Christian Queinnec and Julian Padget. </author> <title> Modules, macros and lisp. </title> <booktitle> In Eleventh International Conference of the Chilean Computer Science Society, </booktitle> <pages> pages 111-123. </pages> <publisher> Plenum Publishing Corporation, </publisher> <year> 1991. </year>
Reference-contexts: Furthermore, information hiding is not enforced by the package system. Queinnec and Padget have designed a module system for Lisp <ref> [9] </ref>. The design goals of their system are to support separate compilation and to control the visibility of resources. A module is available for use after it is defined and loaded.
Reference: 10. <author> Rene G. Rodr iguez, Bruce F. Duba, and Matthias Felleisen. </author> <title> Can you trust your read-eval-print loop? unpublished manuscript. </title>
Reference-contexts: As a result, the program text at any given point in an interactive programming session cannot be relied upon to understand the program's behavior <ref> [10] </ref>. This problem and the module consistency problem can make modular programming in interactive and imperative languages confusing and unreliable. The approach we have taken to solve the module consistency problem is to design a module system with two levels, the meta level and the base level.
Reference: 11. <author> Guy L. Steele Jr. </author> <title> Common Lisp, the Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: When used with eval or access, which allow expressions or variables to be evaluated dynamically in a first-class environment, a form of modular programming can be supported. First-class environments, however, are inherently dynamic in nature, so that module interfaces often cannot be fully determined until run-time. Common Lisp's <ref> [11] </ref> package system uses symbol tables to represent modules. Symbols defined as external in a package can be exported. Various mechanisms are available to access or to import exported symbols. The package system could be used as the low-level implementation for fully developed (static) modules.
Reference: 12. <author> Warren Teitelman and Larry Masinter. </author> <title> The Interlisp programming environment. </title> <journal> IEEE Computer, </journal> <volume> 14(4) </volume> <pages> 25-34, </pages> <year> 1981. </year>
Reference-contexts: Several approaches may be used to solve these problems. One is to reevaluate all variable definitions, including those that do not rely on the altered bindings. This is essentially the traditional batch-oriented programming style. Another approach is to provide undo/redo facilities to the programmer, as in Interlisp <ref> [12] </ref>. The programmer, however, is required to keep track of dependencies among variable definitions and to undo/redo selected ones manually. This process is burdensome and error prone.
Reference: 13. <author> Sho-Huan Simon Tung. </author> <title> Merging Interactive, Modular, and Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, </institution> <year> 1992. </year>
Reference-contexts: After a variable is redefined by the user, the system automatically reevaluates those affected definitions only. Unfortunately, doing so is difficult, since a simple dependency analysis may lead to unnecessary recomputation, and a thorough analysis may result in more total overhead than simply reloading the program <ref> [13] </ref>. We have chosen instead to rely upon a combination of syntactic restrictions and programming conventions to solve the program text and system state consistency problem. <p> The with syntactic form would become unnecessary, as would the module specifier in public, private, and private! forms. A similar but more involved design is to use a window-based user interface that associates each module with a file and an edit window <ref> [13] </ref>. An interactive user interface should provide some mechanism for eliminating modules and bindings within modules. 5.3. Module Linkage The semantics of our module system requires free-variable bindings to be determined dynamically. This property provides the necessary flexibility for interactive programming. <p> Code for separate modules can be compiled separately as long as sufficient information is recorded for each module to determine the set of variables it exports. It is straightforward to extend this to allow separately compiled, fully developed modules to be combined with modules still under interactive development <ref> [13] </ref>. 6. Conclusion Interactive programming systems offer convenience and flexibility and can greatly speed program development. Modular programming allows the programmer to create well-structured programs with abstract interfaces among modules that simplify the coding and increase the reliability of each program part.
Reference: 14. <author> US Government Department of Defense. </author> <title> The programming language ADA: Reference manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 106, </volume> <year> 1981. </year>
Reference-contexts: However, ML's type system limits its flexibility as an interactive language and makes it difficult to support arbitrary module load order. Modula-2 [15], Modula-3 [2], and Ada <ref> [14] </ref> are conventional modular languages. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: 15. <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: However, ML's type system limits its flexibility as an interactive language and makes it difficult to support arbitrary module load order. Modula-2 <ref> [15] </ref>, Modula-3 [2], and Ada [14] are conventional modular languages. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
References-found: 15

