URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-583.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr500.html
Root-URL: 
Title: Self-Stabilization by Local Checking and Correction  
Author: by George Varghese Nancy A. Lynch Campbell L. Searle 
Degree: B.Tech, Electrical Engineering Indian Institute of Technology, Bombay (1981) M.S., Computer Studies  Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy at the  Signature of Author  Certified by Baruch Awerbuch Associate Professor Thesis Supervisor Certified by  Professor Thesis Co-supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology  
Date: (1983)  October 1992  1992  October 20, 1992  
Affiliation: North Carolina State University  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [AAG87] <author> Yehuda Afek, Baruch Awerbuch, and Eli Gafni. </author> <title> Applying static network protocols to dynamic networks. </title> <booktitle> In Proc. 28th IEEE Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: The reset protocol in this chapter is based on an existing non-stabilizing reset protocol <ref> [AAG87] </ref> that works in networks where links can fail and recover. Section 7.8 suggests that this is no accident locally checkable protocols that work in networks where links can fail and recover are likely to also be locally correctable. <p> In this chapter we introduce the most efficient known stabilizing network reset protocol. We do so by applying the method of local checking and correction of Chapter 5 to an existing reset protocol described in <ref> [AAG87] </ref> The space overhead of the protocol is logarithmic. Our reset protocol stabilizes in constant time. 7.2 Existing Solutions In Chapter 4, we described a stabilizing reset protocol due to Arora and Gouda [AG90]. <p> However, this can be deduced from the fact that the send event corresponding to a normal receive event in fi occurs at most O (n) time before the receive event. 7.3.4 Alternative Specifications of Reset Problem Traditional definitions (i.e., <ref> [AAG87] </ref>) of a reset service define the correctness of a reset service in terms of the states of protocol P , the user of the reset service. <p> The stronger condition seems to capture the essence of network synchronization in that the signal events provide consistent time points across the entire network. However, we show in the appendix that our reset protocol (and the reset protocol of <ref> [AAG87] </ref>) does not satisfy the stronger condition. The applications in this thesis do not need the stronger condition. Note that the weaker condition does imply that there is a transitive mating relation between final signal intervals at all nodes in the network. <p> Our solution basically consists of stabilizing the reset protocol of <ref> [AAG87] </ref> using the method of Chapter 5. In the first subsection, we describe a simple reset protocol that is not stabilizing. In the next subsection, the problems of the simple reset protocol are used to motivate the main ideas behind our reset protocol. <p> This seems hard to check locally, even with the addition of a small amount of state. Instead, our point of departure is the AAG reset protocol of <ref> [AAG87] </ref>. This protocol works in dynamic networks and can be made locally checkable and correctable. We describe some more details of how the AAG protocol works and why it avoids the problems of the Simple Reset Protocol in the appendix. <p> Proof: By lemmas, D.1.4, D.1.5, D.1.6, D.1.7, D.1.8, and D.1.3 in Section D.1 of the appendix. The predicates are closed because of the code in <ref> [AAG87] </ref> and the heuristic of removing unexpected packet transitions. We quickly sketch what is involved in such a proof. Consider predicate A as sketched in Figure 7.11. <p> Many of these existing protocols have not explicitly been designed to be 201 stabilizing. However, in this section, we conjecture that a number of dynamic protocols can be made locally correctable. We start with the reset protocol described in <ref> [AAG87] </ref> on which the reset protocol described in this chapter is based. This protocol was originally designed for dynamic networks. Thus besides the actions described in this chapter, the protocol in [AAG87] had actions for link failure and recovery. <p> We start with the reset protocol described in <ref> [AAG87] </ref> on which the reset protocol described in this chapter is based. This protocol was originally designed for dynamic networks. Thus besides the actions described in this chapter, the protocol in [AAG87] had actions for link failure and recovery. <p> Next, consider the reset function (Figure 7.15) used in this chapter for the reset protocol. The reset function applied to a node v with respect to a neighbor u is exactly: * The code performed in <ref> [AAG87] </ref> for a Link Down u;v event, immediately followed by * The code performed in [AAG87] for a Link Up u;v event. In other words, we can obtain a local reset function by simulating a link failure immediately followed by a link recovery. <p> The reset function applied to a node v with respect to a neighbor u is exactly: * The code performed in <ref> [AAG87] </ref> for a Link Down u;v event, immediately followed by * The code performed in [AAG87] for a Link Up u;v event. In other words, we can obtain a local reset function by simulating a link failure immediately followed by a link recovery. Is this a coincidence? We present a rough (but incomplete) argument as to why this might work. <p> But since s 0 is a valid state of the original protocol it must satisfy all local predicates, including L u;w . It is possible to formalize the intuitive arguments by adding similar local extensibility conditions, and showing that the protocol in <ref> [AAG87] </ref> satisfies these conditions. We will not do so here. 7.9 Summary The three main ideas in this chapter are as follows: First, we have given a new definition of the correctness of a reset protocol in terms of its external behaviors. <p> However, in trying to apply the reset protocol (for instance, in Chapter 8) we soon found a need for the present specification. Second. we have applied the Local Correction theorem to stabilize a version of the reset protocol described in <ref> [AAG87] </ref>. We had to make some subtle changes to the original protocol to make it locally checkable and correctable. Third, we have conjectured that many locally checkable protocols that work in dynamic networks can be made locally correctable. <p> Thus by the phase rate lemma, Lemma 5.6.5, s j must occur within 3t p time units after s i in ff. 293 Appendix C The AAG reset protocol In this chapter, we describe why three phases were used in the original AAG protocol <ref> [AAG87] </ref> and also describe the changes that were required to convert the AAG protocol into the reset protocol described in Chapter 7. We also show that the mating relation provided by the AAG protocol is not transitive. <p> We also show that the mating relation provided by the AAG protocol is not transitive. C.1 Why three phases are used in the AAG proto col The AAG reset protocol <ref> [AAG87] </ref> is much more conservative than the Simple Reset Protocol about allowing a node to to return to Ready mode. The point of all the conservatism in the AAG protocol is as follows. <p> The result is that we get a single work interval tree of infinite height. Each work interval ends in finite time but there are an infinite number of work intervals at each node! 295 C.2 Overview of the changes required for stabiliza- tion In a non-stabilizing setting (e.g. <ref> [AAG87] </ref>, buffers like buffer u [v] are modelled by unbounded queues. However, just as in the case of links, stabilizing reset protocols must use bounded size queues if they are to stabilize in bounded time. <p> The main difficulty about designing a correcting strategy is making it local, i.,e., to ensure that when we correct a link we do not affect the correctness of any other link. An interesting heuristic for this purpose is to notice that protocols designed for dynamic networks (like <ref> [AAG87] </ref>) had to deal with link failures and recovery. Now when a link fails and then immediately recovers, the original protocol must have established the local predicates for the link that failed without affecting the correctness of the other links. <p> Now when a link fails and then immediately recovers, the original protocol must have established the local predicates for the link that failed without affecting the correctness of the other links. Thus the local correction procedure we use is essentially identical to the combined code in <ref> [AAG87] </ref> that is invoked when a link fails and recovers. This seems to be a powerful heuristic in general. C.3 Mating Relation is not Transitive Consider the reset protocol described in Chapter 7 (or the protocol described in [AAG87]) when all local predicates hold. <p> correction procedure we use is essentially identical to the combined code in <ref> [AAG87] </ref> that is invoked when a link fails and recovers. This seems to be a powerful heuristic in general. C.3 Mating Relation is not Transitive Consider the reset protocol described in Chapter 7 (or the protocol described in [AAG87]) when all local predicates hold. We use the scenario shown in Figure C.1 to show that the mating relation between signal intervals at neighboring nodes is not transitive. Thus the reset protocol may cause inconsistent states of the user protocol during initial signal intervals. <p> Thus the reset protocol may cause inconsistent states of the user protocol during initial signal intervals. However, the mating relation between final intervals is indeed transitive. The original paper <ref> [AAG87] </ref> showed an example in which the 297 A B C READY ABORT from C ACK to C m2 m3 from C ABORT ABORT ABORT ACK ACK from A m3 to C ABORT to A mode (A) = ready mode (A) = converge mode (C) = ready Figure C.1: Counterexample to <p> Thus it was not clear whether the problem was due to the optimization. In fact, the simple counterexample in <ref> [AAG87] </ref> does not work as soon as we remove the optimization. However, we show in Figure C.1 that there is a (more complicated) counterexample. In Figure C.1 there are three nodes A, B and C that are connected in a cycle (not shown). <p> Another significant thing about the counterexample is that it shows that our pairwise definition of a mating relation between neighbors is probably the only statement that one can make about the non-final intervals of a reset protocol. The original specification of <ref> [AAG87] </ref> used a state-based specification. It seems hard to specify this weak safety property of non-final intervals in terms of states as opposed to using an external behavior specification. In either, case [AAG87] only needed to specify the behavior in the final interval. <p> The original specification of <ref> [AAG87] </ref> used a state-based specification. It seems hard to specify this weak safety property of non-final intervals in terms of states as opposed to using an external behavior specification. In either, case [AAG87] only needed to specify the behavior in the final interval. For stabilizing applications, we must specify the behaviors in non-final intervals.
Reference: [AB89] <author> Yehuda Afek and Geoffrey Brown. </author> <title> Self-stabilization of the alternating bit protocol. </title> <booktitle> In Proceedings of the 8th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 80-83, </pages> <year> 1989. </year>
Reference-contexts: The physical channel may also not deliver a free signal. Instead, an implementation can construct a Data Link protocol on top of the physical channel such that the resulting Data Link protocol stabilizes to the behaviors of a UDL (e.g. <ref> [AB89] </ref>, [Spi88a]). The sender end of the Data Link protocol has a queue that can contain a single packet. When the queue is empty, the Free signal is enabled. <p> However, if the physical channel can initially store packets, then the alternating bit protocol is not stabilizing [Spi88a]. There are two approaches to creating a stabilizing stop and wait protocol. Suppose the physical channel can store at most X packets in both directions. Then <ref> [AB89] </ref> 98 suggest numbering packets using a counter that has at least X + 1 values. Suppose instead that no packet can remain on the physical channel for more than a bounded amount of time. [Spi88a] exploits such a time bound to build a stabilizing Data Link protocol. <p> For instance, the Free signal for a BDL should be modified to include the number of packets currently stored in the BDL. It is also easy to implement a BDL over a physical channel with either bounded storage or bounded delay using the techniques described in <ref> [AB89] </ref> and [Spi88a]. We prefer to use a UDL for the rest of this thesis as it provides a simple and elegant interface. However, the reader concerned about efficiency should be aware that all the protocols in this thesis can be modified (slightly) to work with BDLs.
Reference: [AE86] <author> Baruch Awerbuch and Shimon Even. </author> <title> Reliable broadcast protocols in unreliable networks. </title> <journal> Networks, </journal> <volume> 16(4) </volume> <pages> 381-396, </pages> <month> Winter </month> <year> 1986. </year>
Reference-contexts: Thus each execution of the Data Link protocol induces a set of operating intervals at both nodes. Then for synchronization, we require that there is a symmetric relation between intervals at the two nodes (called a mating relation in <ref> [AE86] </ref>) such that: * An operating interval can be mated to at most one other operating interval. * Suppose an operating interval ff at u is mated to an operating interval fi at v.
Reference: [AG90] <author> Anish Arora and Mohamed G. Gouda. </author> <title> Distributed reset. </title> <booktitle> In Proc. 10th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 316-331. </pages> <publisher> Spinger-Verlag (LNCS 472), </publisher> <year> 1990. </year>
Reference-contexts: Thus the goals of this chapter are: * To describe some simple examples of local checking and correction that are more interesting than than the trivial examples given in Chapter 1. 69 * To show that existing work in [Dij74] and <ref> [AG90] </ref> can be understood very suc- cinctly using the framework of local checking and correction. The main result of the chapter is a theorem (Theorem 4.3.1) that states that any locally checkable protocol on a tree can be efficiently stabilized. <p> The main result of the chapter is a theorem (Theorem 4.3.1) that states that any locally checkable protocol on a tree can be efficiently stabilized. To motivate this theorem, we begin in Section 4.2 with a reset protocol <ref> [AG90] </ref> due to Arora and Gouda. We examine the behavior of the Arora-Gouda protocol in a good state and conclude that the protocol is in a good state when all link subsystems are in a good state. <p> Also, we will describe the correctness of Dijkstra's systems in terms of executions of the automaton. 4.2 A Reset Protocol on a Tree Before describing the reset protocol due to Arora and Gouda <ref> [AG90] </ref>, we first describe the network reset problem. 70 Recall that we have a collection of nodes that communicate by reading the state of their neighbors. The interconnection topology is described by an arbitrary graph. Assume that we are given some application protocol that is being executed by the nodes. <p> Then, since the session numbers are only used for comparisons, it suffices to replace the session numbers by a single bit that we call sbit i . This is the first idea in Arora and Gouda's reset protocol <ref> [AG90] </ref>. To realize this idea, we cannot allow a node to increment its session number as soon as it gets a reset request. Otherwise, multiple reset requests at the same node will cause the difference in session numbers to grow without bound. <p> Otherwise, multiple reset requests at the same node will cause the difference in session numbers to grow without bound. Thus nodes must 71 coordinate before they increment session numbers. In Arora and Gouda's reset protocol <ref> [AG90] </ref>, the coordination is done over a rooted tree. Arora and Gouda first show how to build a rooted tree in a stabilizing fashion. In what follows we will assume that the tree has already been built. <p> Notice that besides the actions we have already described, there is a Correct i action in Figure 4.2. This action was used in an earlier version <ref> [AG90] </ref> to ensure that the reset protocol was stabilizing. Informally, the reset protocol is stabilizing if after bounded time, any reset requests will cause the application protocol to be properly reset. The correction action in stabilization is somewhat difficult and not as intuitive as one might like. <p> Informally, the reset protocol is stabilizing if after bounded time, any reset requests will cause the application protocol to be properly reset. The correction action in stabilization is somewhat difficult and not as intuitive as one might like. The reader is referred to <ref> [AG90] </ref> for details. Instead, we will use local checking and correction to describe another correction procedure that is very intuitive. As a result, the proof of stabilization becomes transparent. We start by writing down the "good" states of the reset system in terms of link predicates L i;j . <p> Then <ref> [AG90] </ref> show that the system will execute reset requests correctly in any state starting with s. This is not very hard to believe. But it means that all we have to do is to add correction actions so that all link predicates will become true in bounded time. <p> We will return to the network reset problem in Chapter 7. Our stabilizing reset protocol is more efficient than the reset protocol of <ref> [AG90] </ref> and is also designed to work in a message passing model. 4.3 Tree Correction for Shared Memory Systems In the last section, we described informally the problem of stabilizing a reset protocol on a tree. We also suggested a technique of adding correction actions to every node. <p> For our purposes, it is convenient to model the parent values as being part of the code at each node. More generally, the parent pointers could be variables that are set by a stabilizing spanning tree protocol as shown in <ref> [AG90] </ref>. <p> Actually the theorem only requires a property we call eventual correction: if a Correct u action is continuously enabled, then a Correct u action occurs within bounded time. 83 It is interesting that the protocols in <ref> [Dij74, AG90] </ref> only require that some enabled action in the entire network occur in bounded time. In other words, all the actions in the entire automaton can be placed in a single class. <p> This property can be established 4 quite easily for the protocols in [Dij74] and <ref> [AG90] </ref>. 4.4 Rediscovering Dijkstra's Protocols In this section, we will begin by reconsidering the second example in [Dij74]. This protocol is essentially a token passing protocol on a line of nodes with process indices ranging from 0 to n 1. <p> Our reset protocol stabilizes in constant time. 7.2 Existing Solutions In Chapter 4, we described a stabilizing reset protocol due to Arora and Gouda <ref> [AG90] </ref>. Their protocol was described in terms of a shared memory model but it appears that it can be adapted to work in our message passing model. [AG90] also describes a stabilizing protocol to build a spanning tree of the network. <p> reset protocol stabilizes in constant time. 7.2 Existing Solutions In Chapter 4, we described a stabilizing reset protocol due to Arora and Gouda <ref> [AG90] </ref>. Their protocol was described in terms of a shared memory model but it appears that it can be adapted to work in our message passing model. [AG90] also describes a stabilizing protocol to build a spanning tree of the network. For the spanning tree protocol, it is assumed that processes have unique identifiers, and that there is some a priori bound K on the number of nodes in the network. <p> The first step in making this protocol stabilizing is to make it locally checkable. A clear problem with the AAG protocol is that it will deadlock if in the initial state some parent edges form a cycle. As in stabilizing spanning tree algorithms <ref> [AKY90, AG90] </ref>, we mend this flaw by maintaining a distance variable at each node, such that a node's distance is one greater than that of its parent. Specifically, distance is initialized to 0 upon reset request, and its accumulated value is appended to the abort packets. <p> In either, case [AAG87] only needed to specify the behavior in the final interval. For stabilizing applications, we must specify the behaviors in non-final intervals. It is interesting to note that the reset protocol of Arora and Gouda <ref> [AG90] </ref> (after adaptation to a message passing model) is likely to ensure a transitive mating relation. This is because it does a reset protocol on a tree and only the root (effectively) sends out the quivalent of Abort packets.
Reference: [AG91] <author> Yehuda Afek and Eli Gafni. </author> <title> Bootstrap network resynchronization. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1991. </year>
Reference-contexts: However, the Bootstrap Protocol <ref> [AG91] </ref> is more efficient in some cases, and so a stabilizing version would be of theoretical interest.
Reference: [AG92] <author> Anish Arora and Mohamed G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <type> Unpublished manuscript, </type> <month> February </month> <year> 1992. </year>
Reference-contexts: An unrestricted IOA (see Section 3.5) is one in which all states of the automaton are also start states. Such an IOA models a system that has been placed in an arbitrary initial state by an arbitrary initial fault. However, (this important observation is due to Arora and Gouda <ref> [AG92] </ref>), we might also be interested in modelling the response of a system to more restricted kinds of initial faults. Such restricted faults initially place a system A in some subset L of the states of A.
Reference: [AGLP89] <author> Baruch Awerbuch, Andrew Goldberg, Michael Luby, and Serge Plotkin. </author> <title> Network decomposition and locality in distributed computation. </title> <booktitle> In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: The Rollback compiler gives good results when applied to symmetry breaking problems such as the problems of computing a Maximum Independent Set <ref> [AGLP89] </ref>, +1 Coloring in sparse networks [GPS87], and 2 Coloring in general networks [Lin87]. For instance, for + 1 Coloring in sparse networks we achieve log fl n for both measures.
Reference: [AGR92] <author> Yehuda Afek, Eli Gafni, and Adi Rosen. </author> <title> Slide a technique for communication in unreliable networks. </title> <booktitle> In Proceedings of the 11th PODC, </booktitle> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Katz and Perry [KP90] extend the use of counter flushing to arbitrary networks in an ingenious way. Our stabilizing end-to-end protocol ([APV91b]) is obtained by first applying local correction to the Slide protocol <ref> [AGR92] </ref> and then applying a variant of counter flushing to the Majority protocol of [AGR92]. Timer Flushing The main idea is to bound the lifetime of "old" state information in the network. <p> Katz and Perry [KP90] extend the use of counter flushing to arbitrary networks in an ingenious way. Our stabilizing end-to-end protocol ([APV91b]) is obtained by first applying local correction to the Slide protocol <ref> [AGR92] </ref> and then applying a variant of counter flushing to the Majority protocol of [AGR92]. Timer Flushing The main idea is to bound the lifetime of "old" state information in the network. This is done by using node clocks that run at approximately the same rate and by enforcing a maximum packet lifetime over every link. <p> It may be possible to modify the methodology to avoid this drawback. * Invent a stabilizing version of the Bootstrap Protocol for End-to-End Communication: Our previous work on stabilizing end-to-end communication [APV91b] has concentrated on producing a stabilizing version of the simple and elegant Slide protocol <ref> [AGR92] </ref>. However, the Bootstrap Protocol [AG91] is more efficient in some cases, and so a stabilizing version would be of theoretical interest.
Reference: [AKY90] <author> Yehuda Afek, Shay Kutten, and Moti Yung. </author> <title> Memory-efficient self-stabilization on general networks. </title> <booktitle> In Proc. 4th Workshop on Distributed Algorithms, </booktitle> <pages> pages 15-28, </pages> <address> Italy, </address> <month> September </month> <year> 1990. </year> <note> Springer-Verlag (LNCS 486). 329 </note>
Reference-contexts: For example, many authors have proposed local methods for detecting termination and deadlocks. In a stabilizing setting, the intuitive notion of local checkability was first referred to in a paper by <ref> [AKY90] </ref>. However, their reference to this concept (during the description of a spanning tree protocol) was brief and intuitive. Our contribution has been to make precise the notion of local checkability, and to show that this is a useful and pervasive concept. <p> The first step in making this protocol stabilizing is to make it locally checkable. A clear problem with the AAG protocol is that it will deadlock if in the initial state some parent edges form a cycle. As in stabilizing spanning tree algorithms <ref> [AKY90, AG90] </ref>, we mend this flaw by maintaining a distance variable at each node, such that a node's distance is one greater than that of its parent. Specifically, distance is initialized to 0 upon reset request, and its accumulated value is appended to the abort packets.
Reference: [AP90] <author> Baruch Awerbuch and David Peleg. </author> <title> Sparse partitions. </title> <booktitle> In Proc. 31st IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 503-513, </pages> <year> 1990. </year>
Reference-contexts: Another interesting subsystem would consist of a single node and all its incoming and outgoing channels. Another interesting possibility is to consider subgraphs defined by the sparse network partitions <ref> [AP90] </ref> defined by Awerbuch and Peleg. Another simple generalization is to allow more than one local predicate per local subsystem. For example, consider an example consisting of two link subsystems and four link predicates, L 1 ; L 2 ; L 3 and L 4 . <p> Now, robust flow control schemes are a major component of Transport and Data link layer protocols. Perhaps existing flow control schemes can be simplified using local checking and correction. * Invent a stabilizing, distributed protocol to compute Sparse Partitions: Awerbuch and Peleg <ref> [AP90] </ref> have shown how to decompose a network into what they call sparse partitions. They use sparse partitions to build efficient solutions for online tracking of mobile users, network synchronization, and network routing with low memory.
Reference: [APV91a] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Creating self-stabilizing protocols by using a reset protocol. </title> <type> Draft, </type> <year> 1991. </year>
Reference-contexts: The interval is chosen to be large enough such that all packets from the previous phase will have disappeared at the end of the interval. This solution was advocated by us in <ref> [APV91a] </ref> and was implemented in a trial implementation on the Autonet [MAM + 90]. 133 To keep our model simple, however, we have assumed that all lower bounds (on the time between events) are zero.
Reference: [APV91b] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: In that case, a token is manufactured. The actual protocol can be understood using these ideas. 4.5 Summary Much of the initial work in self-stabilization was done in the context of Dijkstra's shared memory model of networks. Later, the work on local checking and correction was introduced <ref> [APV91b] </ref> in a message passing model. The main contribution of this chapter is to show that existing work in the shared memory model can be understood crisply in terms of local checking and correction. Protocols that appeared to be somewhat ad hoc are shown to have a common underlying principle. <p> However, there is at least one case where the method of local checking and correction is applicable where the method of [KP90] is not. This is the stabilizing end-to-end protocol that we describe in <ref> [APV91b] </ref>. The problem here is that some unknown set of network links may have infinite delay. Thus the global snapshot of [KP90] may never terminate. However, it is sufficient ([APV91b]) to do local checking and correction on the so-called viable links that have bounded delay. <p> In this problem links can fail continuously the only guarantee is that there is no cut of permanently failed links that separate the sender and receiver. We have not described our solution to this problem in this thesis but more details can be found in <ref> [APV91b] </ref>. There are a number of other protocols to which we believe local checking and correction can be applied. These include the efficient resource allocation algorithm of Awerbuch and Saks ([AS90]), and the elegant virtual circuit protocol due to Spinelli ([Spi88b]). We hope to produce stabilizing versions of these protocols. <p> Essentially, it slows down all links to the speed of the slowest link. It may be possible to modify the methodology to avoid this drawback. * Invent a stabilizing version of the Bootstrap Protocol for End-to-End Communication: Our previous work on stabilizing end-to-end communication <ref> [APV91b] </ref> has concentrated on producing a stabilizing version of the simple and elegant Slide protocol [AGR92]. However, the Bootstrap Protocol [AG91] is more efficient in some cases, and so a stabilizing version would be of theoretical interest.
Reference: [AS88] <author> Baruch Awerbuch and Michael Sipser. </author> <title> Dynamic networks are as fast as static networks. </title> <booktitle> In Proc. 29th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 206-220, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: How--ever, if the asynchronous protocol is simulating an underlying synchronous protocol then the size of the log can be reduced to the time complexity T of . This idea is implemented in the dynamic synchronizer of <ref> [AS88] </ref>. However, in [AS88] the logs are only used to avoid unnecessary recomputation after an input change, and hence are not periodically checked. By adding the periodic checking of logs, we obtain a Modified Dynamic Synchronizer that we call Rollback. <p> How--ever, if the asynchronous protocol is simulating an underlying synchronous protocol then the size of the log can be reduced to the time complexity T of . This idea is implemented in the dynamic synchronizer of <ref> [AS88] </ref>. However, in [AS88] the logs are only used to avoid unnecessary recomputation after an input change, and hence are not periodically checked. By adding the periodic checking of logs, we obtain a Modified Dynamic Synchronizer that we call Rollback.
Reference: [AS90] <author> Baruch Awerbuch and Mike Saks. </author> <title> A dining philosophers algorithm with polynomial response time. </title> <booktitle> In Proc. 31st IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference: [AV91] <author> Baruch Awerbuch and George Varghese. </author> <title> Distributed program checking: a paradigm for building self-stabilizing distributed protocols. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: The first compiler is based on a simplified form of local checking and correction that we call one-way checking and correction (see Chapter 8). The second compiler is based on local checking and global correction. When we first presented these results in <ref> [AV91] </ref>, the second compiler, the Resynchronizer, was based on a complicated construction. In this chapter, we provide a simplified construction using the reset protocol described in Chapter 7. <p> We do not have a complete proof of the simplified construction, but we will outline why we believe our simplified construction is correct. Thus while our confidence in the Resynchronizer result is based on the original result in <ref> [AV91] </ref>, we believe that the construction in this chapter offers the potential for a much simpler solution. This chapter is organized as follows. First, we describe how we model interactive protocols and synchronous protocols. Next, we summarize the major results of the chapter. <p> Our original proof of the Resynchronizer Compiler Theorem was based on a complicated construction given in <ref> [AV91] </ref>. We conjecture that the simplified construction in Section 9.6 also provides a proof of the same theorem. <p> Once all nodes get a signal (see Chapter 7) all nodes reset their pulse numbers to 0 and the cycle continues. Thus the Resynchronizer can be considered to be an application of global correction to the simplest synchronizer protocol described in [Awe85]. Our original construction and proof <ref> [AV91] </ref> relied on a special-purpose reset protocol that was specially crafted to work with the synchronizer protocol. In this chapter, we will describe a simplified version of the construction that uses the general purpose network reset protocol of Chapter 7. <p> Clearly D and n can be much larger than the actual diameter of the final network. A natural open problem is to obtain a compiler whose time overhead only depends on the actual diameter of the final network. When the results in this chapter were first presented <ref> [AV91] </ref>, the Resynchronizer compiler used a much more complicated construction (which could be regarded as a special reset protocol optimized for the case of synchronizer operation). The transformation in [AV91] added only O (D) overhead to the time complexity of the protocol, removing the factor of n which arises from the <p> When the results in this chapter were first presented <ref> [AV91] </ref>, the Resynchronizer compiler used a much more complicated construction (which could be regarded as a special reset protocol optimized for the case of synchronizer operation). The transformation in [AV91] added only O (D) overhead to the time complexity of the protocol, removing the factor of n which arises from the use of the reset protocol described in Chapter 7.
Reference: [Awe85] <author> Baruch Awerbuch. </author> <title> Complexity of network synchronization. </title> <journal> J. of the ACM, </journal> <volume> 32(4) </volume> <pages> 804-823, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Thus global correction removes the need for the original protocol to be locally correctable but pays a price in terms of stabilization time. In the next chapter, we will apply global correction to a simple synchronizer protocol <ref> [Awe85] </ref>. The focus of this chapter is the Global Correction Theorem. The Global Correction theorem should be contrasted with the Local Correction Theorem (Theorem 5.4.3) of Chapter 5. <p> In general, the Resynchronizer avoids a log by constantly re-executing a checker for . We introduce the basic idea by assuming that is deterministic and that is its own checker. We return to separate checking later. The Resynchronizer can be thought of as a stabilizing version of a synchronizer <ref> [Awe85] </ref>. Any synchronous protocol can be simulated asynchronously by using a pulse 247 number at each network node. Let us call a node synchronized if its pulse number differs by at most 1 from any of its neighbors. <p> Once all nodes get a signal (see Chapter 7) all nodes reset their pulse numbers to 0 and the cycle continues. Thus the Resynchronizer can be considered to be an application of global correction to the simplest synchronizer protocol described in <ref> [Awe85] </ref>. Our original construction and proof [AV91] relied on a special-purpose reset protocol that was specially crafted to work with the synchronizer protocol. In this chapter, we will describe a simplified version of the construction that uses the general purpose network reset protocol of Chapter 7. <p> A stabilizing distributed algorithm for sparse partitions would be an extremely useful tool. * Make the Synchronizer Methodology practical for networks with links of different speeds: The synchronizer methodology was introduced in <ref> [Awe85] </ref> and is extended to a stabilizing setting in Chapter 9. However, the method suffers from a severe drawback in networks in which links have varying delays. Essentially, it slows down all links to the speed of the slowest link.
Reference: [Awe90] <author> Baruch Awerbuch. </author> <title> Shortest paths and loop-free routing in dynamic networks. </title> <booktitle> In Proceedings of the Annual ACM SIGCOMM Symposium on Communication Architectures and Protocols, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice <ref> [CRKG89a, CRKG89b, Gar89, RF89, Awe90] </ref>. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in [Per85]. This solution uses an approach that we call timer flushing.
Reference: [BGW87] <author> G.M. Brown, M.G. Gouda, and C.L. Wu. </author> <title> A self-stabilizing token system. </title> <booktitle> In Proceedings of 20th Hawai International Conference on System Sciences, </booktitle> <pages> pages 218-223, </pages> <year> 1987. </year>
Reference: [BP89] <author> J.E. Burns and J. Pachl. </author> <title> Uniform self-stabilizing rings. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 330-344, </pages> <year> 1989. </year>
Reference: [BSW69] <author> K.A. Bartlett, R.A. Scantlebury, and P.T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 260-261, </pages> <year> 1969. </year>
Reference-contexts: If the physical channel is initially empty and the physical channel is FIFO (i.e., does not permute the order of packets), then a standard stop and wait or alternating bit protocol <ref> [BSW69] </ref> will implement a UDL. However, if the physical channel can initially store packets, then the alternating bit protocol is not stabilizing [Spi88a]. There are two approaches to creating a stabilizing stop and wait protocol. Suppose the physical channel can store at most X packets in both directions.
Reference: [CL85] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Trans. on Comput. Syst., </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> Febru-ary </month> <year> 1985. </year> <month> 330 </month>
Reference-contexts: G and constants c and ~c such that N + stabilizes to the behaviors of N (c)jL in time ~c height (&lt;). 5.4.3 Overview of the Transformation Code For those familiar with snapshot protocols, the structure of our local snapshot protocol is slightly different from the well-known Chandy-Lamport snapshot protocol <ref> [CL85] </ref>. It is easy to show that the Chandy-Lamport scheme cannot be used without modifications over unit storage links. Briefly, the reason is as follows. The correctness proof of the algorithm in [CL85] is based on reordering executions while preserving causality constraints. The only causality constraint for a link in [CL85] <p> snapshot protocols, the structure of our local snapshot protocol is slightly different from the well-known Chandy-Lamport snapshot protocol <ref> [CL85] </ref>. It is easy to show that the Chandy-Lamport scheme cannot be used without modifications over unit storage links. Briefly, the reason is as follows. The correctness proof of the algorithm in [CL85] is based on reordering executions while preserving causality constraints. The only causality constraint for a link in [CL85] is that any action that sends a packet p on link L cannot be reordered to come after an action that receives p on link L. <p> <ref> [CL85] </ref>. It is easy to show that the Chandy-Lamport scheme cannot be used without modifications over unit storage links. Briefly, the reason is as follows. The correctness proof of the algorithm in [CL85] is based on reordering executions while preserving causality constraints. The only causality constraint for a link in [CL85] is that any action that sends a packet p on link L cannot be reordered to come after an action that receives p on link L. However, a UDL has an additional causality constraint. <p> This ensures that a signal interval at u "communicates" or mates with at most one signal interval in v. The Simple Reset Protocol (SRP) is similar to the Chandy-Lamport snapshot protocol <ref> [CL85] </ref> with Abort packets replacing "markers". The problem with SRP is that it can easily be placed in a state where it never 170 u v w ABORT u v w ABORT a node is waiting for an Abort on that edge. terminates - i.e., violates the causality property.
Reference: [CRKG89a] <author> C. Cheng, R. Riley, S. P. R. Kumar, and J. J. Garcia-Luna-Aceves. </author> <title> A loop-free extended bellman-ford routing protocol without bouncing effect. </title> <booktitle> In Proceedings of the Annual ACM SIGCOMM Symposium on Communication Architectures and Protocols, </booktitle> <address> Austin, Texas, </address> <pages> pages 224-236, </pages> <year> 1989. </year>
Reference-contexts: Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice <ref> [CRKG89a, CRKG89b, Gar89, RF89, Awe90] </ref>. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in [Per85]. This solution uses an approach that we call timer flushing.
Reference: [CRKG89b] <author> Chunhsiang Cheng, Ralph Riley, Srikanta P.R. Kumar, and Jose J. Garcia-Luna-Aceves. </author> <title> A loop-free extended Bellman-Ford routing protocol without bouncing effect. </title> <booktitle> In Proceedings of the Annual ACM SIGCOMM Symposium on Communication Architectures and Protocols, </booktitle> <address> Austin, Texas, </address> <pages> pages 224-236. </pages> <publisher> ACM SIGCOMM, ACM, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice <ref> [CRKG89a, CRKG89b, Gar89, RF89, Awe90] </ref>. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in [Per85]. This solution uses an approach that we call timer flushing.
Reference: [CSV89] <author> Jeff Cooper, Robert Simcoe, and George Varghese. </author> <title> Stabilizing, hardware-based implementation of a flow control scheme for high speed links: Presented at ATM Forum, </title> <month> Aug </month> <year> 1993. </year> <type> Unpublished manuscript, </type> <month> January </month> <year> 1989. </year>
Reference-contexts: In <ref> [CSV89] </ref> we propose an extremely simple stabilizing flow control scheme for physical links. It can be considered to be a trivial application of local checking and correction to the sender-receiver flow control protocol. The 273 resulting protocol is robust and simple enough to be implemented in hardware.
Reference: [Dij74] <author> Edsger W. Dijkstra. </author> <title> Self stabilization in spite of distributed control. </title> <journal> Comm. of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: The appendix also contains a list of commonly used notation for easy reference. actions to report the value of the parent variables at each node. 68 Chapter 4 Local Checking and Correction in a Shared Memory Model In Dijkstra's <ref> [Dij74] </ref> model, a network protocol is modelled using a graph of finite state machines. In a single move, a single node is allowed to read the state of its neighbors, compute, and then possibly change its state. In a real distributed system such atomic communication is impossible. <p> However, in Dijkstra's model all state machines are node state machines and can be arbitrarily specified by the protocol designer. While Dijkstra's original model is not very realistic, it is probably the simplest model of an asynchronous distributed system. This simple model provided an ideal vehicle for introducing <ref> [Dij74] </ref> the concept of stabilization without undue complexity. For this chapter only, we will use Dijkstra's original model to introduce the method of local checking and correction. In later chapters, we will use a more realistic message passing model. <p> Thus the goals of this chapter are: * To describe some simple examples of local checking and correction that are more interesting than than the trivial examples given in Chapter 1. 69 * To show that existing work in <ref> [Dij74] </ref> and [AG90] can be understood very suc- cinctly using the framework of local checking and correction. The main result of the chapter is a theorem (Theorem 4.3.1) that states that any locally checkable protocol on a tree can be efficiently stabilized. <p> We also determine an order in which link subsystems can be corrected so as to ensure that the correction process converges. In Section 4.3 we generalize the procedure followed in Section 4.2 to obtain Theorem 4.3.1. Then in Section 4.4 we show how one of Dijkstra's protocols <ref> [Dij74] </ref> can easily be understood using Theorem 4.3.1. 4.1 Modelling Shared Memory Protocols We will use the version of the timed I/O Automaton model [MMT91] described in Chapter 2. How can we map Dijkstra's model into this model? Suppose each node in Dijkstra's model is a separate automaton. <p> Actually the theorem only requires a property we call eventual correction: if a Correct u action is continuously enabled, then a Correct u action occurs within bounded time. 83 It is interesting that the protocols in <ref> [Dij74, AG90] </ref> only require that some enabled action in the entire network occur in bounded time. In other words, all the actions in the entire automaton can be placed in a single class. <p> This property can be established 4 quite easily for the protocols in <ref> [Dij74] </ref> and [AG90]. 4.4 Rediscovering Dijkstra's Protocols In this section, we will begin by reconsidering the second example in [Dij74]. This protocol is essentially a token passing protocol on a line of nodes with process indices ranging from 0 to n 1. <p> This property can be established 4 quite easily for the protocols in <ref> [Dij74] </ref> and [AG90]. 4.4 Rediscovering Dijkstra's Protocols In this section, we will begin by reconsidering the second example in [Dij74]. This protocol is essentially a token passing protocol on a line of nodes with process indices ranging from 0 to n 1. <p> Then we can use Theorem 4.3.1 to convert D2 into a new automaton D2 + which stabilizes to executions in which there is exactly one token in each state. The correction actions we add are once again different from the original actions in <ref> [Dij74] </ref>. However, the corrections actions we add (and consequently the proofs) are much more transparent than the original version. Dijkstra also described two more stabilizing mutual exclusion protocols, one using K-state machines, where K is greater than the number of processes, and a solution using 3-state machines. <p> expect, there is a corresponding Tree Correction theorem for message passing systems that is described at the end of Chapter 6. 89 Chapter 5 Local Checking and Correction for Network Protocols In Chapter 4 we introduced a method of local checking and correction using a shared memory model taken from <ref> [Dij74] </ref>. Recall that in such a model, nodes communicate with their neighbors by reading the state of all neighbors in one atomic action. Thus there is no need to model channels between nodes. The shared memory model allowed us to introduce local checking and correction in a fairly simple way. <p> Similar forms of counter flushing can be used to implement Data Links ([AB89]) and token passing [DIM91a]) in link subsystems with bounded storage. Counter flushing is, however, not limited to link subsystems. The first example in <ref> [Dij74] </ref> can be simply understood as counter flushing in a unidirectional ring (see Appendix E for more details). Katz and Perry [KP90] extend the use of counter flushing to arbitrary networks in an ingenious way. <p> However, the latency of token traversal on a tree can be quite high, for example if the original graph is a ring. The first example in <ref> [Dij74] </ref> appears extensible to token passing in a ring. An efficient stabilizing token passing protocol for rings would be useful and practical. <p> Proof: Immediate from Definition 7.3.7 and Lemmas D.2.17, D.2.24, and D.2.27. 324 Appendix E Dijkstra's Token Protocol as an Example of Counter Flushing In Chapter 10, we described a paradigm called counter flushing. We now show that Di-jkstra's first example protocol in <ref> [Dij74] </ref> can be simply understood using this paradigm. Dijkstra's first example is modelled by the automaton D2 shown in Figure E.1.
Reference: [DIM90] <author> Shlomo Dolev, Amos Israeli, and Shlomo Moran. </author> <title> Self-stabilization of dynamic systems assuming only read/write atomicity. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Proceeding similarly, we can calculate the stabilization time of a version of the stabilizing tree protocol of Chapter 8 in which the reset protocol RjL is replaced by P . 3 Our theorem can be viewed as a generalization of previous modularity results <ref> [DIM90] </ref>. Previous results only applied to the case when a lower layer protocol computed values of a shared variable that were read by a higher layer protocol. <p> We hope the UDL model will be used by others. The UDL model can easily be generalized to Bounded Storage Data Links by changing the free signal to report the number of packets currently stored in the link. Earlier papers in stabilization (e.g., <ref> [DIM90] </ref>) seem to have used shared memory models for communication in order to avoid the problems caused by unbounded storage links. It does seem very likely (see Open Problems) that protocols that work in the low atomicity shared memory model of [DIM90] can be transformed to work correctly in our network <p> Earlier papers in stabilization (e.g., <ref> [DIM90] </ref>) seem to have used shared memory models for communication in order to avoid the problems caused by unbounded storage links. It does seem very likely (see Open Problems) that protocols that work in the low atomicity shared memory model of [DIM90] can be transformed to work correctly in our network model. <p> A precise, general definition would be very useful. 270 * Find a way of Compiling Stabilizing Protocols in the Shared Mem--ory Model into our Network Model. A number of interesting stabilizing protocols have been described using the low atomicity, shared memory model introduced by <ref> [DIM90] </ref>. It would be nice to have a compiler that that could convert protocols from their model to our network model and vice versa. This seems to be feasible. 10.2.2 Increased Understanding of Local Checking and Cor rection Our understanding of local checking and correction is far from complete.
Reference: [DIM91a] <author> Shlomo Dolev, Amos Israeli, and Shlomo Moran. </author> <title> Resource bounds for self-stabilizing message driven protocols. </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Unfortunately, this is no longer true in a stabilizing setting. If the link can store an unbounded number of packets, it can have an unbounded number of "bad" packets in the initial state. It has been shown <ref> [DIM91a] </ref> that almost any non-trivial task is impossible in such a setting. Thus in a stabilizing setting it is necessary to define Data Links that have bounded storage. <p> Unit Storage Data Links In a stabilizing setting it is necessary to define Data Links that have bounded storage. First, as shown in <ref> [DIM91a] </ref>, almost any non-trivial network task is impossible in 266 a stabilizing setting in which the links have unbounded storage and the nodes are restricted to be finite state machines. Second, bounded storage models correspond to physical reality. <p> In Chapter 5, the flushing condition is guaranteed because the sender and receiver are connected by two FIFO links in either direction. Similar forms of counter flushing can be used to implement Data Links ([AB89]) and token passing <ref> [DIM91a] </ref>) in link subsystems with bounded storage. Counter flushing is, however, not limited to link subsystems. The first example in [Dij74] can be simply understood as counter flushing in a unidirectional ring (see Appendix E for more details).
Reference: [DIM91b] <author> Shlomo Dolev, Amos Israeli, and Shlomo Moran. </author> <title> Uniform self-stabilizing leader election. </title> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: Since each phase takes O (D) the expected stabilization time is O (D). A more efficient protocol for this purpose (that works in time proportional to the actual diameter as opposed to a bound on the diameter) is given in <ref> [DIM91b] </ref>. However, our solution seems to be simpler.
Reference: [DS80] <author> Edsger W. Dijkstra and C. S. Scholten. </author> <title> Termination detection for diffusing computations. Info. Process. </title> <journal> Letters, </journal> <volume> 11(1) </volume> <pages> 1-4, </pages> <month> August </month> <year> 1980. </year>
Reference-contexts: Thus, in the second phase a wave of acks flow up the abort trees to the roots. The first and second phases work in much the same way as the Dijkstra-Scholten termination detection algorithm <ref> [DS80] </ref>. As in the Dijkstra Scholten algorithm, some nodes may be in the first phase (forward propagation of Abort packets) while other nodes may be in the second phase (sending acks up to parents).
Reference: [Fin79] <author> Steven G. Finn. </author> <title> Resynch procedures and a fail-safe network protocol. </title> <journal> IEEE Trans. on Commun., </journal> <volume> COM-27(6):840-845, </volume> <month> June </month> <year> 1979. </year>
Reference-contexts: A "legal" global state is allowed to be any global state that is reachable by the application protocol after correct initialization. The problem is called distributed reset because reset requests may arrive at any node. A simple and elegant network reset protocol is due to Finn <ref> [Fin79] </ref>. In this protocol each node i running the application protocol has a session number. When the reset protocol is not running, the session numbers at every node are the same. <p> This check prevents older instances of the application protocol from "communicating" with newer instances of the protocol. This protocol is shown to be correct <ref> [Fin79] </ref> if all the session numbers are initially zero and the session numbers are allowed to grow without bound. We rule out the use of unbounded session numbers as unrealistic. Also, in a stabilizing setting, having a "large enough" size for a session number does not work. <p> Thus all these protocols essentially synchronize two nodes in a network. 7.1.2 Network Synchronization The synchronization provided by a network reset protocol is a generalization of the synchronization guarantees of a Data link. A reset protocol synchronizes all the nodes in the network. Informally, the reset problem <ref> [Fin79] </ref> is to design a reset service that can be superimposed on any other distributed protocol P . The reset may be invoked at any node, and its effect is to output a signal at all the nodes of the system in a consistent way. <p> Ideally, we would like the signals to be delivered to every node at the same instant. However, since this seems to be impossible in a distributed system, we settle for delivering the signal in a consistent manner (see above). Why is a reset service useful? It was introduced in <ref> [Gal76, Fin79] </ref> as a tool for converting any protocol that works in a so-called static network to work in a so-called dynamic network. A static network, as the name suggests, is a network in which the topology of the network remains fixed during the execution of the algorithm. <p> However, it is assumed that topology changes eventually stop 156 and that some node in the final topology can detect the fact that there has been a topology change. Roughly, the idea behind <ref> [Fin79] </ref> is that any node that detects a topology change makes a reset request. If successful, the reset request results in restarting the static protocol. This methodology is quite practical. For instance, the Autonet local area network uses a version of [Fin79] to cope with failures. <p> Roughly, the idea behind <ref> [Fin79] </ref> is that any node that detects a topology change makes a reset request. If successful, the reset request results in restarting the static protocol. This methodology is quite practical. For instance, the Autonet local area network uses a version of [Fin79] to cope with failures. Besides its use in dynamic networks, a reset protocol is also useful in a stabilizing setting. As we show in Chapters 8 and 9, a stabilizing reset protocol is an important tool for the design of other stabilizing protocols. <p> As we show in Chapters 8 and 9, a stabilizing reset protocol is an important tool for the design of other stabilizing protocols. Notice that in order to use the reset service in dynamic networks <ref> [Fin79] </ref>, some node must detect the last topological change. More generally, suppose that any bad state of a network protocol can be detected locally by some node. This corresponds to what we have called a locally checkable protocol in Chapter 5. <p> This corresponds to what we have called a locally checkable protocol in Chapter 5. As we will see in Chapter 8, any locally checkable protocol can be stabilized using a stabilizing reset protocol. Intuitively, our idea is similar to that of <ref> [Fin79] </ref>. We add actions to each node to make a reset request if the node locally detects a bad state of the network. The technique of using a reset protocol to stabilize a locally checkable protocol is quite different from the techniques developed in Chapter 5 and 6.
Reference: [Gal76] <author> Robert G. Gallager. </author> <title> A shortest path routing algorithm with automatic resynch. </title> <type> Technical report, </type> <institution> MIT, Lab. for Information and Decision Systems, </institution> <month> March </month> <year> 1976. </year>
Reference-contexts: Ideally, we would like the signals to be delivered to every node at the same instant. However, since this seems to be impossible in a distributed system, we settle for delivering the signal in a consistent manner (see above). Why is a reset service useful? It was introduced in <ref> [Gal76, Fin79] </ref> as a tool for converting any protocol that works in a so-called static network to work in a so-called dynamic network. A static network, as the name suggests, is a network in which the topology of the network remains fixed during the execution of the algorithm.
Reference: [Gar89] <author> Jose J. Garcia-Luna-Aceves. </author> <title> A unified approach to loop-free routing using distance vectors or link states. </title> <booktitle> In Proceedings of the Annual ACM SIGCOMM Symposium on Communication Architectures and Protocols, </booktitle> <address> Austin, Texas, </address> <pages> pages 212-223. </pages> <publisher> ACM SIGCOMM, ACM, </publisher> <month> September </month> <year> 1989. </year> <month> 331 </month>
Reference-contexts: Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice <ref> [CRKG89a, CRKG89b, Gar89, RF89, Awe90] </ref>. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in [Per85]. This solution uses an approach that we call timer flushing.
Reference: [GHS83] <author> Robert G. Gallager, Pierre A. Humblet, and P. M. Spira. </author> <title> A distributed algorithm for minimum-weight spanning trees. </title> <journal> ACM Trans. on Programming Lang. and Syst., </journal> <volume> 5(1) </volume> <pages> 66-77, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: For the problems of computing a spanning tree and single source shortest paths we achieve O (n) stabilization time and O (log n) space. This is comparable to the results achieved in Chapter 7 and the best previous results. For the problem of computing a minimal spanning tree <ref> [GHS83] </ref> we achieve O (n) stabilization time (which is as good as the time of the best non-stabilizing synchronous protocol) using O (log n) space.
Reference: [GM90] <author> Mohamed G. Gouda and Nicholas J. Multari. </author> <title> Stabilizing communication protocols. </title> <type> Technical Report TR-90-20, </type> <institution> Dept. of Computer Science, University of Texas at Austin, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: The technique is similar to techniques used for proving liveness properties (e.g., [OL82, MP91]) of concurrent programs. Our theorem is a small generalization of a theorem for proving stabilization properties that was previously proposed in <ref> [GM90] </ref>. Let L be a closed predicate of automaton A once L is true in an any execution of A, L remains true for the rest of the execution. We would like to prove that in any execution of A, L becomes (and stays) true in bounded time.
Reference: [Gol85] <author> Andrew V. Goldberg. </author> <title> A new max-flow algorithm. </title> <type> Technical Report MIT/LCS/TM-291, </type> <institution> MIT, Lab. for Computer Science, </institution> <month> November </month> <year> 1985. </year>
Reference-contexts: For the problem of computing a minimal spanning tree [GHS83] we achieve O (n) stabilization time (which is as good as the time of the best non-stabilizing synchronous protocol) using O (log n) space. For the problem of computing a maximum flow <ref> [Gol85, GT88] </ref> we achieve O (n 2 ) stabilization time, which is as good as the time of the best non-stabilizing synchronous protocol.
Reference: [GPS87] <author> A. V. Goldberg, S. Plotkin, and G. Shannon. </author> <title> Parallel symmetry breaking in sparse graphs. </title> <booktitle> In Proc. 19th ACM Symp. on Theory of Computing. ACM SIGACT, ACM, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: The Rollback compiler gives good results when applied to symmetry breaking problems such as the problems of computing a Maximum Independent Set [AGLP89], +1 Coloring in sparse networks <ref> [GPS87] </ref>, and 2 Coloring in general networks [Lin87]. For instance, for + 1 Coloring in sparse networks we achieve log fl n for both measures.
Reference: [GT88] <author> Andrew V. Goldberg and Robert E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <journal> J. of the ACM, </journal> <volume> 35(4) </volume> <pages> 921-940, </pages> <month> October </month> <year> 1988. </year> <note> Also appeared in 18th stoc (1986). </note>
Reference-contexts: For the problem of computing a minimal spanning tree [GHS83] we achieve O (n) stabilization time (which is as good as the time of the best non-stabilizing synchronous protocol) using O (log n) space. For the problem of computing a maximum flow <ref> [Gol85, GT88] </ref> we achieve O (n 2 ) stabilization time, which is as good as the time of the best non-stabilizing synchronous protocol.
Reference: [IJ90] <author> Amos Israel and Marc Jalfon. </author> <title> Token management schemes and random walks yield self-stabilizing mutual exclusion. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference: [KP90] <author> Shmuel Katz and Kenneth Perry. </author> <title> Self-stabilizing extensions for message-passing systems. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: We will begin with a definition of stabilization that corresponds to the standard definitions (for example, that of Katz and Perry <ref> [KP90] </ref>). In the next section, we will describe another definition of stabilization in terms of external behaviors. We believe that the definition of behavior stabilization is appropriate for large systems that require modular proofs. <p> Because the links are unit storage, we will see that a space of 4 numbers is sufficient. Our use of numbering is taken from the stabilizing global snapshot protocol of <ref> [KP90] </ref>. However, our protocol is simpler and more efficient because we are restricted to a single link subsystem. Besides properly matching requests and responses, we must also avoid deadlock when the local snapshot/reset protocol begins in an arbitrary state. <p> Secondly, as we will see in Chapter 8, their spanning tree protocol is based on a routing algorithm that works poorly in practice. Katz and Perry <ref> [KP90] </ref> describe a stabilizing reset protocol. Their approach requires the election of a leader and the stabilization time of their approach is O (n 2 ) where n is the number of nodes in the network. <p> However, that method (which we can call independent checking of link subsystems) is limited to locally checkable protocols. One approach to check a distributed program introduced by Katz and Perry <ref> [KP90] </ref> is to collect all information at a single "leader" node, thus reducing distributed checking to centralized checking. However, the space and time complexities of this method are quite large because of the bottleneck at the "leader" node. <p> Clearly the checking protocol must be executed at least once every T time units where T is the stabilization time even after the protocol has stabilized. Hence this is really a bandwidth cost. For example, the stabilization bandwidth of the protocol in <ref> [KP90] </ref> is the worst case message complexity per link to do a snapshot, which is (m), where m is the number of links. If we check a deterministic protocol by re-executing , we have to pay a high price (T ) in stabilization bandwidth. <p> Comparison with Only Previously Known General Technique The only previously known general method for stabilization is the elegant result of Katz and Perry <ref> [KP90] </ref>. How do our methods compare with the general method of [KP90]? Recall that in [KP90], checking is done by a single leader node periodically taking a snapshot of the entire network. * Message Congestion: From a practical standpoint, the most important difference is that all our methods have considerably smaller <p> Comparison with Only Previously Known General Technique The only previously known general method for stabilization is the elegant result of Katz and Perry <ref> [KP90] </ref>. How do our methods compare with the general method of [KP90]? Recall that in [KP90], checking is done by a single leader node periodically taking a snapshot of the entire network. * Message Congestion: From a practical standpoint, the most important difference is that all our methods have considerably smaller stabilization bandwidth than that of [KP90]. <p> Comparison with Only Previously Known General Technique The only previously known general method for stabilization is the elegant result of Katz and Perry <ref> [KP90] </ref>. How do our methods compare with the general method of [KP90]? Recall that in [KP90], checking is done by a single leader node periodically taking a snapshot of the entire network. * Message Congestion: From a practical standpoint, the most important difference is that all our methods have considerably smaller stabilization bandwidth than that of [KP90]. <p> with the general method of <ref> [KP90] </ref>? Recall that in [KP90], checking is done by a single leader node periodically taking a snapshot of the entire network. * Message Congestion: From a practical standpoint, the most important difference is that all our methods have considerably smaller stabilization bandwidth than that of [KP90]. Recall from Chapter 9 that stabilization bandwidth is the periodic overhead of checking that must be paid even when the protocol is in a good state and behaving correctly. Suppose the protocol is to stabilize in time T . Roughly, [KP90] has to pay the price of a snapshot of <p> methods have considerably smaller stabilization bandwidth than that of <ref> [KP90] </ref>. Recall from Chapter 9 that stabilization bandwidth is the periodic overhead of checking that must be paid even when the protocol is in a good state and behaving correctly. Suppose the protocol is to stabilize in time T . Roughly, [KP90] has to pay the price of a snapshot of the entire network every T units of time. Now a snapshot requires at least O (m) state, where m is the number of network links. <p> By contrast, in our local correction, tree correction, and global correction methods, each link only carries a constant number of message bits every T units of time. Even the naive synchronous compilers of Chapter 9 have better stablization bandwidth than the method of <ref> [KP90] </ref> because the communication overhead of checking is spread out among all the links rather than being concentrated on links leading to the leader. <p> In real networks, each link has a limited bandwidth and the worst case bandwidth requirement is an important measure of link congestion. * Speed: If all links are UDL's, the method of <ref> [KP90] </ref> requires O (n) time to stabilize, where n is the number of network nodes. The local correction method, tree correction method, and Rollback compiler can all provide much faster stabiliza tion times. * Storage: The method of [KP90] requires O (m) storage at the leader to store the snapshot information, <p> link congestion. * Speed: If all links are UDL's, the method of <ref> [KP90] </ref> requires O (n) time to stabilize, where n is the number of network nodes. The local correction method, tree correction method, and Rollback compiler can all provide much faster stabiliza tion times. * Storage: The method of [KP90] requires O (m) storage at the leader to store the snapshot information, where m is the number of links. For fault-tolerance, 262 every node must be prepared to be the leader of the network and be able to store O (m) information bits. <p> For fault-tolerance, 262 every node must be prepared to be the leader of the network and be able to store O (m) information bits. By contrast, except for the Rollback compiler, the storage required by our methods is negligible. * Generality: The method of <ref> [KP90] </ref> is clearly more general than our methods. Our methods require protocols to be either locally checkable or to have a correctness specification that can be expressed (see Chapter 9) in terms of an I/O relation. <p> Our methods require protocols to be either locally checkable or to have a correctness specification that can be expressed (see Chapter 9) in terms of an I/O relation. However, there is at least one case where the method of local checking and correction is applicable where the method of <ref> [KP90] </ref> is not. This is the stabilizing end-to-end protocol that we describe in [APV91b]. The problem here is that some unknown set of network links may have infinite delay. Thus the global snapshot of [KP90] may never terminate. <p> one case where the method of local checking and correction is applicable where the method of <ref> [KP90] </ref> is not. This is the stabilizing end-to-end protocol that we describe in [APV91b]. The problem here is that some unknown set of network links may have infinite delay. Thus the global snapshot of [KP90] may never terminate. However, it is sufficient ([APV91b]) to do local checking and correction on the so-called viable links that have bounded delay. To summarize, our methods are less general but more efficient than the method of [KP90]. <p> Thus the global snapshot of <ref> [KP90] </ref> may never terminate. However, it is sufficient ([APV91b]) to do local checking and correction on the so-called viable links that have bounded delay. To summarize, our methods are less general but more efficient than the method of [KP90]. <p> Counter flushing is, however, not limited to link subsystems. The first example in [Dij74] can be simply understood as counter flushing in a unidirectional ring (see Appendix E for more details). Katz and Perry <ref> [KP90] </ref> extend the use of counter flushing to arbitrary networks in an ingenious way. Our stabilizing end-to-end protocol ([APV91b]) is obtained by first applying local correction to the Slide protocol [AGR92] and then applying a variant of counter flushing to the Majority protocol of [AGR92]. <p> More generally, a subsystem is the composition of the nodes and channels corresponding to some subgraph of the network graph. For example if we define locality using the subsystems corresponding to the entire network graph, then our method reduces to the method of Katz and Perry <ref> [KP90] </ref>. Another interesting subsystem would consist of a single node and all its incoming and outgoing channels. Another interesting possibility is to consider subgraphs defined by the sparse network partitions [AP90] defined by Awerbuch and Peleg. Another simple generalization is to allow more than one local predicate per local subsystem. <p> Self-stabilization is also applicable at the lowest layer of the protocol hierarchy. For example, it would be desirable to have stabilizing clock recovery and framing protocols at the physical layer. * Generalized Local Checking: The method of Katz and Perry <ref> [KP90] </ref> consists of a single leader that checks the entire network. In our method of local checking, nodes independently (and in parallel) check each link subsystem. The Katz and Perry method is more general but less efficient. <p> If the application is doing any general form of checking, it may detect an inconsistent state and keep making reset requests, leading to non-termination. For example, if we were to use the global snapshot protocol due to <ref> [KP90] </ref> to check the application and then 299 use our stabilizing reset, the protocol may never terminate! Our stabilizing reset is still useful in a number of cases. For instance, (Chapter 8) when used in conjunction with a local snapshot protocol that checks for closed local predicates.
Reference: [LA90] <author> Nancy Lynch and Hagit Attiya. </author> <title> Using mappings to prove timing properties. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1990. </year>
Reference-contexts: We prove the "liveness" condition by proving time bounds on the occurence of events. We have proved time bounds in a fairly ad hoc, operational way. However, there is no reason why the time bounds could not be established by more rigorous inductive arguments (as in <ref> [LA90] </ref>). Thus while the Execution Convergence Theorem may appear slightly unusual, it is really a combination of existing verification techniques. We believe this continuity (with the body of existing work in verification) is an advantage of our work.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM TOPLAS, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: This can be done using a definition of stabilization in terms of executions if we are prepared to introduce an abstraction function into the definitions as in Lamport's work <ref> [Lam83] </ref>. However, we prefer the behavior definitions as they seem to be more natural; we prefer to use the equivalent of an abstraction function to prove behavior stabilization results using the Refinement Mapping Theorem.
Reference: [Lam84] <author> L. Lamport. </author> <title> Solved problems, unsolved problems, </title> <booktitle> and non-problems in concu-rancy. In Proc. of the 3rd ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Vancouver, BC, Canada, </address> <pages> pages 1-11, </pages> <month> Aug </month> <year> 1984. </year> <booktitle> Invited address at the 2nd ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <month> August </month> <year> 1983. </year>
Reference: [Lau90] <author> Tony Lauck. </author> <type> personal communication. unpublished, </type> <year> 1990. </year>
Reference: [Lin87] <author> Nathan Linial. </author> <title> Locality as an obstacle to distributed computing. </title> <booktitle> In 27 th Annual Symposium on Foundations of Computer Science. IEEE, </booktitle> <month> October </month> <year> 1987. </year> <month> 332 </month>
Reference-contexts: The Rollback compiler gives good results when applied to symmetry breaking problems such as the problems of computing a Maximum Independent Set [AGLP89], +1 Coloring in sparse networks [GPS87], and 2 Coloring in general networks <ref> [Lin87] </ref>. For instance, for + 1 Coloring in sparse networks we achieve log fl n for both measures.
Reference: [LS91] <author> N. Linial and M. Saks. </author> <title> Decomposing graphs into regions of small diame-ter. </title> <booktitle> In Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 320-330. </pages> <address> ACM/SIAM, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: They use sparse partitions to build efficient solutions for online tracking of mobile users, network synchronization, and network routing with low memory. The most efficient distributed algorithm for constructing sparse partitions is based on the work of Linial and Saks <ref> [LS91] </ref>. A stabilizing distributed algorithm for sparse partitions would be an extremely useful tool. * Make the Synchronizer Methodology practical for networks with links of different speeds: The synchronizer methodology was introduced in [Awe85] and is extended to a stabilizing setting in Chapter 9.
Reference: [LSP82] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference: [LT89] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <year> 1989. </year>
Reference-contexts: with the I/O automaton model may wish to only read the formal description in Section 2.2. 35 2.1 The I/O Automaton Model Our model of computation is a variant of the timed Input/Output automaton model [MMT], which in turn is based on the Input/Output automaton model of Lynch and Tuttle <ref> [LT89] </ref>. We will omit the word "timed" in what follows. For instance, we will refer to a timed I/O automaton simply as an automaton. 2.1.1 Why use the I/O Automaton Model? We wish to model systems of processes that compute but also communicate with other processes. <p> to the executions of automaton C in time t 2 , then A stabilizes to the executions of C in time t 1 + t 2 . 51 3.2 Definitions of Stabilization based on External Behavior In Chapter 2, we argued that a major theme of the I/O Automaton model <ref> [LT89] </ref> is the focus on external behaviors of an automaton. For instance, the correctness of an automaton is specified in terms of its external behaviors. <p> There are well-known techniques (e.g., <ref> [LT89] </ref>) to show any behavior of an automaton A is a behavior of another automaton B. A commonly used technique is a refinement mapping. The basic idea is to establish a suitable mapping f between a state of A and a state of B. <p> Our model of computation is based on the timed I/O automaton [MMT91] which is in turn based on the I/O automaton of <ref> [LT89] </ref>. We have even described the shared memory network model in Chapter 4 as an I/O automaton that meets certain restrictions. We also use standard proof techniques. We use mapping techniques (Refinement Mapping Theorem, Theorem 3.4.3) to show that one automaton has the same behaviors as another automaton.
Reference: [MAM + 90] <author> M.Schroeder, A.Birrell, M.Burrows, H.Murray, R.Needham, T.Rodeheffer, E.Sattenthwaite, and C.Thacker. Autonet: </author> <title> a high-speed, self-configuring local area network using point-to-point links. </title> <type> Technical Report 59, </type> <institution> Digital Systems Research Center, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The interval is chosen to be large enough such that all packets from the previous phase will have disappeared at the end of the interval. This solution was advocated by us in [APV91a] and was implemented in a trial implementation on the Autonet <ref> [MAM + 90] </ref>. 133 To keep our model simple, however, we have assumed that all lower bounds (on the time between events) are zero. Thus we have no way to model timers, which are needed to control the interval between phases.
Reference: [MMT91] <author> M. Merritt, F. Modugno, </author> <title> and M.R. Tuttle. Time constrained automata. </title> <booktitle> In CONCUR 91, </booktitle> <pages> pages 408-423, </pages> <year> 1991. </year>
Reference-contexts: In this thesis, we will use the following model which is a special case of the model in <ref> [MMT91] </ref>. However, our terminology is slightly different from that of [MMT91]. An automaton A consists of five components: * a finite set of actions actions (A) that is partitioned into three sets called the set of input, output, and internal actions. <p> In this thesis, we will use the following model which is a special case of the model in <ref> [MMT91] </ref>. However, our terminology is slightly different from that of [MMT91]. An automaton A consists of five components: * a finite set of actions actions (A) that is partitioned into three sets called the set of input, output, and internal actions. <p> Notice that the time associated with the first state of an execution, s 0 :time, is allowed to be an arbitrary non-negative real number. As we see below, this assumption allows a clean statement of an important lemma about stabilizing automata. In the timed automaton model <ref> [MMT91] </ref>, each class also has an associated lower bound. In our model, the lower bound associated with each class is implicitly assumed to be zero. These two assumptions (or lack of assumptions) restrict us to modelling systems in which the value of time is not used by the protocol. <p> Then in Section 4.4 we show how one of Dijkstra's protocols [Dij74] can easily be understood using Theorem 4.3.1. 4.1 Modelling Shared Memory Protocols We will use the version of the timed I/O Automaton model <ref> [MMT91] </ref> described in Chapter 2. How can we map Dijkstra's model into this model? Suppose each node in Dijkstra's model is a separate automaton. Then in the Input/Output automata model, it is not possible to model the simultaneous reading of the state of neighboring nodes. <p> Our model of computation is based on the timed I/O automaton <ref> [MMT91] </ref> which is in turn based on the I/O automaton of [LT89]. We have even described the shared memory network model in Chapter 4 as an I/O automaton that meets certain restrictions. We also use standard proof techniques.
Reference: [MP91] <author> Zohar Manna and Amir Pnueli. </author> <title> Completing the temporal picture. </title> <journal> Theoretical Computer Science, </journal> <volume> 83, </volume> <year> 1991. </year>
Reference-contexts: The technique is similar to techniques used for proving liveness properties (e.g., <ref> [OL82, MP91] </ref>) of concurrent programs. Our theorem is a small generalization of a theorem for proving stabilization properties that was previously proposed in [GM90].
Reference: [MPV90] <author> Yishay Mansour, Boaz Patt, and George Varghese. </author> <title> Self-stabilizing data structures. </title> <type> unpublished manuscript, </type> <month> December </month> <year> 1990. </year>
Reference-contexts: The head and tail pointers can be restricted to stay within the array bounds. However, it appears to be much harder to obtain good tradeoffs for say a tree-based implementation of a dictionary. We have done some preliminary thinking in this area <ref> [MPV90] </ref>. * Applying Self-Stabilization to Other Areas: Most of the stabilizing protocols described in this thesis are used for routing, scheduling, and resource allocation tasks typically found in the network and Data Link layers of the communication hierarchy.
Reference: [MRR80] <author> John McQuillan, Ira Richer, and Eric Rosen. </author> <title> The new routing algorithm for the arpanet. </title> <journal> IEEE Trans. on Commun., </journal> <volume> 28(5) </volume> <pages> 711-719, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: Now the sequence number field is finite. Even if we allocate 64 bits for sequence numbers, it is always possible (due to errors) for a link state packet with a maximum sequence number value to be present in the initial state of the network. In the ARPANET <ref> [MRR80] </ref> and DECNET [Per83] protocols, erroneous updates with the maximum number are removed by what we had earlier called "timer flushing". 234 State requestbit u [v] boolean, true if a request is to be done later. All other variables remain unchanged.
Reference: [OL82] <author> S. Owicki and L. Lamport. </author> <title> Proving liveness properties of concurrent programs. </title> <journal> ACM Trans. on Programming Lang. and Syst., </journal> <volume> 4(3) </volume> <pages> 455-495, </pages> <year> 1982. </year>
Reference-contexts: The technique is similar to techniques used for proving liveness properties (e.g., <ref> [OL82, MP91] </ref>) of concurrent programs. Our theorem is a small generalization of a theorem for proving stabilization properties that was previously proposed in [GM90].
Reference: [Per83] <author> Radia Perlman. </author> <title> Fault tolerant broadcast of routing information. </title> <booktitle> Computer Networks, </booktitle> <month> December </month> <year> 1983. </year>
Reference-contexts: Even if we allocate 64 bits for sequence numbers, it is always possible (due to errors) for a link state packet with a maximum sequence number value to be present in the initial state of the network. In the ARPANET [MRR80] and DECNET <ref> [Per83] </ref> protocols, erroneous updates with the maximum number are removed by what we had earlier called "timer flushing". 234 State requestbit u [v] boolean, true if a request is to be done later. All other variables remain unchanged. <p> A complete design of a stabilizing topology update protocol would also have to add a number of other actions as suggested in <ref> [Per83] </ref>. For instance, each node must periodically increment its sequence number and send its latest Link State Packets to all its neighbors. Basically, we suggest keeping the essential simplicity of [Per83] and only replace the need for global timers in [Per83] with global correction. 8.7 Summary The major point of this <p> design of a stabilizing topology update protocol would also have to add a number of other actions as suggested in <ref> [Per83] </ref>. For instance, each node must periodically increment its sequence number and send its latest Link State Packets to all its neighbors. Basically, we suggest keeping the essential simplicity of [Per83] and only replace the need for global timers in [Per83] with global correction. 8.7 Summary The major point of this chapter is to show that any locally checkable protocol can be stabilized using the global reset protocol developed in the last chapter. <p> to add a number of other actions as suggested in <ref> [Per83] </ref>. For instance, each node must periodically increment its sequence number and send its latest Link State Packets to all its neighbors. Basically, we suggest keeping the essential simplicity of [Per83] and only replace the need for global timers in [Per83] with global correction. 8.7 Summary The major point of this chapter is to show that any locally checkable protocol can be stabilized using the global reset protocol developed in the last chapter. <p> We saw that one-way checkable protocols could be checked without the need for a local snapshot it is sufficient for each node to periodically send its state to its neighbors. The protocols in <ref> [Per83] </ref> and [Per85] do checking in this way. In some cases, the protocol is also one-way correctable - i.e., we can apply local correction to a one-way checkable protocol without the need for a local reset of the link subsystem. <p> This is done by using node clocks that run at approximately the same rate and by enforcing a maximum packet lifetime over every link. State information that is not periodically refreshed is "timed out" by the nodes. In Perlman's <ref> [Per83] </ref> topology update protocol, timer flushing is used to get rid of erroneous updates that are numbered with the maximum possible sequence number.
Reference: [Per85] <author> Radia Perlman. </author> <title> An algorithm for distributed computation of a spanning tree in an extended LAN. </title> <booktitle> In Proceedings of the the 9th Data Communication Symposium, </booktitle> <pages> pages 44-53, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Our definition (Definition 5.3.6) has some subtle aspects: for example, the requirement that each local predicate be closed may not be immediately obvious. Also, we have implemented local checking by doing a snapshot of each link subsystem. Now, a number of practical, self-stabilizing protocols (e.g., <ref> [Per85] </ref>) do what essentially amounts to local checking in the following way. Periodically each node sends its state to all its neighbors. However, (as we will show in Chapter 8) such periodic sending of state is not always sufficient to do local checking. <p> Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice [CRKG89a, CRKG89b, Gar89, RF89, Awe90]. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in <ref> [Per85] </ref>. This solution uses an approach that we call timer flushing. The basic idea [Per85] is that each node "times out" information received from its neighbors unless the information is refreshed periodically. <p> Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in <ref> [Per85] </ref>. This solution uses an approach that we call timer flushing. The basic idea [Per85] is that each node "times out" information received from its neighbors unless the information is refreshed periodically. Any node that thinks it is the root is responsible for periodically sending updates to all its neighbors in order to refresh their state information. <p> We saw that one-way checkable protocols could be checked without the need for a local snapshot it is sufficient for each node to periodically send its state to its neighbors. The protocols in [Per83] and <ref> [Per85] </ref> do checking in this way. In some cases, the protocol is also one-way correctable - i.e., we can apply local correction to a one-way checkable protocol without the need for a local reset of the link subsystem. <p> State information that is not periodically refreshed is "timed out" by the nodes. In Perlman's [Per83] topology update protocol, timer flushing is used to get rid of erroneous updates that are numbered with the maximum possible sequence number. In Perlman's <ref> [Per85] </ref> spanning tree protocol, timer flushing is used to get rid of "ghost" roots (see Chapter 8 for details.) Spinelli [Spi88b] uses timer flushing to build stabilizing Data Link and virtual circuit protocols. 10.2 Open Questions and Further Problems The following is a list of further problems.
Reference: [Per88] <author> Radia Perlman. </author> <title> Network Layer Protocols With Byzantine Robustness. </title> <type> PhD thesis, </type> <institution> MIT, Laboratory for Computer Science, </institution> <month> August </month> <year> 1988. </year>
Reference: [RF89] <author> Balasubramanian Rajagopalan and Michael Faiman. </author> <title> A new responsive distributed shortest path routing algorihtm. </title> <booktitle> In Proceedings of the Annual ACM SIGCOMM 333 Symposium on Communication Architectures and Protocols, </booktitle> <address> Austin, Texas, </address> <pages> pages 237-246. </pages> <publisher> ACM SIGCOMM, ACM, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Unfortunately, this pre-determined bound must be quite high, and hence, the stabilization time of such counting up schemes is poor in practice <ref> [CRKG89a, CRKG89b, Gar89, RF89, Awe90] </ref>. Another widely used stabilizing Spanning tree protocol is the IEEE 802.1 bridge routing protocol which is based on the design in [Per85]. This solution uses an approach that we call timer flushing.
Reference: [RL81] <author> M. Rabin and D. Lehmann. </author> <title> On the advantages of free choice: a symmetric and fully distributed solution to the dining philosophers problem. </title> <booktitle> In Proceedings of 8th POPL, </booktitle> <pages> pages 133-138, </pages> <year> 1981. </year>
Reference-contexts: There are several randomized protocols 274 (e.g., the Rabin-Lehman dining philosophers protocol of <ref> [RL81] </ref>) that use ran-domization to break symmetry and to guarantee termination. Such protocols can often be locally checked in a deterministic fashion. For example, in graph coloring, it is easy to check whether a neighboring node has the same color.
Reference: [Ros81] <author> E. C. Rosen. </author> <title> Vulnerabilities of network control protocols: An example. </title> <journal> Computer Communications Review, </journal> <month> July </month> <year> 1981. </year>
Reference: [SG89] <author> John M. Spinelli and Robert G. Gallager. </author> <title> Broadcasting topology information in computer networks. </title> <journal> IEEE Trans. on Commun., </journal> <month> May </month> <year> 1989. </year>
Reference-contexts: For the protocol to be one-way correctable, the dependency relation among the one-way predicates must be acyclic, as in the definition of local correctability. For example, the Rollback protocol of Chapter 9 is one-way correctable. We speculate that the stabilizing topology update protocol of Spinelli-Gallager <ref> [SG89] </ref> is also one-way correctable Counter Flushing Suppose a sender wishes to periodically send a Request packet to a set of network nodes. The responders must each send back a Response packet before the sender sends its next request.
Reference: [Spi88a] <author> John M. Spinelli. </author> <title> Reliable communication. </title> <type> Ph.d. thesis, </type> <institution> MIT, Lab. for Information and Decision Systems, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: The physical channel may also not deliver a free signal. Instead, an implementation can construct a Data Link protocol on top of the physical channel such that the resulting Data Link protocol stabilizes to the behaviors of a UDL (e.g. [AB89], <ref> [Spi88a] </ref>). The sender end of the Data Link protocol has a queue that can contain a single packet. When the queue is empty, the Free signal is enabled. <p> However, if the physical channel can initially store packets, then the alternating bit protocol is not stabilizing <ref> [Spi88a] </ref>. There are two approaches to creating a stabilizing stop and wait protocol. Suppose the physical channel can store at most X packets in both directions. Then [AB89] 98 suggest numbering packets using a counter that has at least X + 1 values. <p> Suppose the physical channel can store at most X packets in both directions. Then [AB89] 98 suggest numbering packets using a counter that has at least X + 1 values. Suppose instead that no packet can remain on the physical channel for more than a bounded amount of time. <ref> [Spi88a] </ref> exploits such a time bound to build a stabilizing Data Link protocol. The main idea is to use either numbered packets or timers to "flush" the physical channel of stale packets. <p> For instance, the Free signal for a BDL should be modified to include the number of packets currently stored in the BDL. It is also easy to implement a BDL over a physical channel with either bounded storage or bounded delay using the techniques described in [AB89] and <ref> [Spi88a] </ref>. We prefer to use a UDL for the rest of this thesis as it provides a simple and elegant interface. However, the reader concerned about efficiency should be aware that all the protocols in this thesis can be modified (slightly) to work with BDLs. <p> Before we describe what we mean by synchronizing all the nodes in a network, it is helpful to understand a form of synchronization between a pair of nodes in a network. Such synchronization is provided by a Data Link protocol <ref> [Spi88a] </ref>. We will then see that in essence a network reset protocol generalizes the guarantees of a Data Link protocol to multiple nodes in a network. 7.1.1 Data Link Synchronization Consider a pair of neighboring nodes in a network, say u and v. <p> But if Link up and down events are reported independently (and possibly at different times) at both ends, the Data Link must provide some additional functions to synchronize u and v. 153 The synchronization requirements for a Data Link protocol can be stated elegantly <ref> [Spi88a] </ref> as follows. First, for node u (or node v) we can define an operating interval at node u (or at node v) to be the time from a Link up event at that node until the next Link down event at that node. <p> To obtain a reset function, we concatenate the code that the original protocol used for a link down event with the code used for a link up event. As another example, Spinelli <ref> [Spi88a] </ref> describes a virtual circuit protocol that works in dynamic networks. This protocol appears to be locally checkable and it appears that we can use the link up and link down code to create a reset function. Interestingly, Spinelli [Spi88a] makes his protocol stabilizing by sending 203 a message periodically from <p> As another example, Spinelli <ref> [Spi88a] </ref> describes a virtual circuit protocol that works in dynamic networks. This protocol appears to be locally checkable and it appears that we can use the link up and link down code to create a reset function. Interestingly, Spinelli [Spi88a] makes his protocol stabilizing by sending 203 a message periodically from the source of the virtual circuit to the destination of the virtual circuit and back. He also uses a timer whose value is proportional to the maximum end-to-end delay in the network. <p> He also uses a timer whose value is proportional to the maximum end-to-end delay in the network. If, as we conjecture, local checking and correction is applicable to Spinelli's protocol, the resulting protocol will be simpler and faster than the one presented in <ref> [Spi88a] </ref>. 204 Chapter 8 Global Correction Theorem The previous three chapters have been concerned with local checking and local correction. This chapter marks an important transition as we move to local checking and global correction.

References-found: 61

