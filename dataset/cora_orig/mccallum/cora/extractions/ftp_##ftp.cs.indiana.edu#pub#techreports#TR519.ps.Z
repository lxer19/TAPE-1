URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR519.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Title: C++ Templates as Partial Evaluation  
Author: Todd L. Veldhuizen 
Abstract: This paper explores the relationship between C++ templates and partial evaluation. Templates were designed to support generic programming, but unintentionally provided the ability to perform compile-time computations and code generation. These features are completely accidental, and as a result their syntax is awkward. By recasting these features in terms of partial evaluation, a much simpler syntax can be achieved. C++ may be regarded as a two-level language in which types are first-class values. Template instantiation resembles an o*ine partial evaluator. This paper describes preliminary work toward a single mechanism based on Partial Evaluation which unifies generic programming, compile-time computation and code generation. The language Catat is introduced to illustrate these ideas. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. O. Andersen, </author> <title> Program Analysis and Specialization for the C Programming Language, </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> (DIKU report 94/19). </type>
Reference-contexts: f return a [0]*b [0]; g g; // Example use: float x [3], y [3]; float z = meta dot&lt;float,2,3&gt;::f (x,y); // ** In the above example, the call to meta dot in line marked ** results in code equivalent to: float z = a [0]*b [0] + a <ref> [1] </ref>*b [1] + a [2]*b [2]; Head recursion is used to unroll the loop over the vector elements. The syntax for writing such code generators is clumsy. <p> A partial evaluator such as CMix <ref> [1] </ref> would evaluate the static constructs to produce the residual code: float volumeOfCube (float length) f return pow3 (length); g float pow3 (float x) f float y = 1; y *= x; y *= x; Such specializations can result in substantial performance improvements for scientific code [2, 9]. 2.1 C++ as
Reference: [2] <author> A. Berlin and D. Weise, </author> <title> Compiling scientific code using partial evaluation, </title> <booktitle> Computer, 23 (1990), </booktitle> <pages> pp. 25-37. </pages>
Reference-contexts: [0]; g g; // Example use: float x [3], y [3]; float z = meta dot&lt;float,2,3&gt;::f (x,y); // ** In the above example, the call to meta dot in line marked ** results in code equivalent to: float z = a [0]*b [0] + a [1]*b [1] + a <ref> [2] </ref>*b [2]; Head recursion is used to unroll the loop over the vector elements. The syntax for writing such code generators is clumsy. <p> evaluator such as CMix [1] would evaluate the static constructs to produce the residual code: float volumeOfCube (float length) f return pow3 (length); g float pow3 (float x) f float y = 1; y *= x; y *= x; Such specializations can result in substantial performance improvements for scientific code <ref> [2, 9] </ref>. 2.1 C++ as a two-level language C++ templates resemble a two-level language. Function templates take both template parameters (which have static binding) and function arguments (which have dynamic binding).
Reference: [3] <author> S. Chiba, </author> <title> A Metaobject Protocol for C++, </title> <booktitle> in OOPSLA'95, </booktitle> <year> 1995, </year> <pages> pp. 285-299. </pages>
Reference-contexts: meta dot f static inline T f (T* a, T* b) f return meta dot&lt;T,I-1,N&gt;::f (a,b) + a [I]*b [I]; g g; template&lt;class T, int N&gt; struct meta dot&lt;T,0,N&gt; f static inline T f (T* a, T* b) f return a [0]*b [0]; g g; // Example use: float x <ref> [3] </ref>, y [3]; float z = meta dot&lt;float,2,3&gt;::f (x,y); // ** In the above example, the call to meta dot in line marked ** results in code equivalent to: float z = a [0]*b [0] + a [1]*b [1] + a [2]*b [2]; Head recursion is used to unroll the loop <p> f static inline T f (T* a, T* b) f return meta dot&lt;T,I-1,N&gt;::f (a,b) + a [I]*b [I]; g g; template&lt;class T, int N&gt; struct meta dot&lt;T,0,N&gt; f static inline T f (T* a, T* b) f return a [0]*b [0]; g g; // Example use: float x <ref> [3] </ref>, y [3]; float z = meta dot&lt;float,2,3&gt;::f (x,y); // ** In the above example, the call to meta dot in line marked ** results in code equivalent to: float z = a [0]*b [0] + a [1]*b [1] + a [2]*b [2]; Head recursion is used to unroll the loop over the <p> Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time. Relevant examples are Xroma [5], MPC++ [10], Open C++ <ref> [3] </ref>, and Magik [6]. These systems are not phrased in terms of partial evaluation or two-level languages; code generation is generally done by constructing abstract syntax trees. A more closely related system is Catacomb [16], which provides a two-level language for generating runtime library code for parallelizing compilers.
Reference: [4] <author> K. Czarnecki and U. Eisenecker, </author> <title> Meta-control structures for template metaprogramming. </title> <address> http://home.t-online.de/home/Ulrich.Eisenecker/meta.htm. </address>
Reference-contexts: Similar techniques can be used to find greatest common divisors, test for primality, and so on. It is even possible to implement an interpreter for a subset of Lisp which runs at compile time <ref> [4] </ref>. 1.3 Code generation It turns out that compile-time versions of flow control structures (loops, if/else, case switches) can all be implemented in terms of templates. For example, the definition of ctime pow (Section 1.2) emulates a for loop using tail recursion.
Reference: [5] <author> K. Czarnecki, U. Eisenecker, R. Gluck, D. Vandevoorde, and T. L. Veldhuizen, </author> <title> Generative Programming and Active Libraries, </title> <booktitle> in Proceedings of the 1998 Dagstuhl-Seminar on Generic Programming, vol. TBA of Lecture Notes in Computer Science, </booktitle> <year> 1998. </year> <note> (in review). </note>
Reference-contexts: Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time. Relevant examples are Xroma <ref> [5] </ref>, MPC++ [10], Open C++ [3], and Magik [6]. These systems are not phrased in terms of partial evaluation or two-level languages; code generation is generally done by constructing abstract syntax trees.
Reference: [6] <author> D. R. Engler, </author> <title> Incorporating application semantics and control into compilation, </title> <booktitle> in USENIX Conference on Domain-Specific Languages (DSL'97), </booktitle> <month> October 15-17, </month> <year> 1997. </year>
Reference-contexts: Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time. Relevant examples are Xroma [5], MPC++ [10], Open C++ [3], and Magik <ref> [6] </ref>. These systems are not phrased in terms of partial evaluation or two-level languages; code generation is generally done by constructing abstract syntax trees. A more closely related system is Catacomb [16], which provides a two-level language for generating runtime library code for parallelizing compilers.
Reference: [7] <author> Y. Futamura, </author> <title> Partial evaluation of computation process an approach to a compiler-compiler, Systems, Computers, Controls, </title> <booktitle> 2 (1971), </booktitle> <pages> pp. 45-50. </pages>
Reference-contexts: We could design our interpreter to take the input text as a static parameter, and input variables as dynamic parameters. Residualization of the interpreter would result in the DSL code being compiled into the dynamic subset of Catat, via the first Futamura projection <ref> [7] </ref>. This approach would allow users to incorporate fragments of domain-specific languages into their applications, without sacrificing efficiency. 3.5.3 Reflection and Meta-level Processing A language like Catat may provide a natural environment for implementing reflection and meta-level processing capabilities, since the ability to perform compile-time calculations is there already.
Reference: [8] <author> R. Gluck and J. Jorgensen, </author> <title> An automatic program generator for multi-level specialization, </title> <booktitle> Lisp and Symbolic Computation, 10 (1997), </booktitle> <pages> pp. 113-158. </pages>
Reference-contexts: The most closely related work is MetaML, a statically typed multi-level language for hand-writing code generators [17]. Gluck and Jorgensen described a program generator for multi-level specialization <ref> [8] </ref> which uses a multi-level functional language to represent automatically produced program generators. Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time.
Reference: [9] <author> R. Gluck, R. Nakashige, and R. Zochling, </author> <title> Binding-time analysis applied to mathematical algorithms, in System Modelling and Optimization, </title> <editor> J. Dolezal and J. Fidler, eds., </editor> <publisher> Chapman & Hall, </publisher> <year> 1995, </year> <pages> pp. 137-146. </pages>
Reference-contexts: evaluator such as CMix [1] would evaluate the static constructs to produce the residual code: float volumeOfCube (float length) f return pow3 (length); g float pow3 (float x) f float y = 1; y *= x; y *= x; Such specializations can result in substantial performance improvements for scientific code <ref> [2, 9] </ref>. 2.1 C++ as a two-level language C++ templates resemble a two-level language. Function templates take both template parameters (which have static binding) and function arguments (which have dynamic binding).
Reference: [10] <author> Y. Ishikawa, A. Hori, M. Sato, M. Matsuda, J. Nolte, H. Tezuka, H. Konaka, M. Maeda, and K. Kubota, </author> <title> Design and implementation of metalevel architecture in C++ - MPC++ approach, </title> <booktitle> in Reflection'96, </booktitle> <year> 1996. </year>
Reference-contexts: In Catat a similar process would occur, but it is more accurately called residualization: a partial evaluator produces a residual function by evaluating the static constructs. This function call: int data <ref> [10] </ref>; // .. float result = average (data,10); triggers the partial evaluation of average; the resulting residual (translated into C++) might be float average__int (int* array, int N) f float sum = 0; for (int i=0; i &lt; N; ++i) sum += array [i]; return sum; g 8 3.4 Classes Classes <p> Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time. Relevant examples are Xroma [5], MPC++ <ref> [10] </ref>, Open C++ [3], and Magik [6]. These systems are not phrased in terms of partial evaluation or two-level languages; code generation is generally done by constructing abstract syntax trees.
Reference: [11] <author> N. D. Jones, </author> <title> An introduction to partial evaluation, </title> <journal> ACM Computing Surveys, </journal> <volume> 28 (1996), </volume> <pages> pp. 480-503. </pages>
Reference-contexts: Here is an implementation of average: template&lt;class T&gt; average traits&lt;T&gt;::T average average (T* array, int N) f average traits&lt;T&gt;::T average result = sum (array,N); return result / N; g 2 Templates as partial evaluation Partial evaluators <ref> [11] </ref> regard a program's data as containing two subsets: static data, which is known at compile time, and dynamic data, which is not known until run time. A partial evaluator evaluates as much of a program as possible (using the static data) and outputs a specialized residual program.
Reference: [12] <author> S. Karmesin, J. Crotinger, J. Cummings, S. Haney, W. Humphrey, J. Reynders, S. Smith, and T. Williams, </author> <title> Array design and expression evaluation in POOMA II, </title> <booktitle> in ISCOPE'98, </booktitle> <volume> vol. 1505, </volume> <publisher> Springer-Verlag, </publisher> <year> 1998. </year> <note> Lecture Notes in Computer Science. </note>
Reference-contexts: 1 Introduction Templates were added to the C++ language to support generic programming. However, their addition unintentionally introduced powerful mechanisms for compile-time computation and code generation. These mechanisms have proven themselves very useful in generating optimized code for scientific computing applications <ref> [12, 15, 21, 22] </ref>. Since they are accidental features, their syntax is somewhat awkward. The goal of this paper is to achieve a simpler syntax by recasting these features as partial evaluation. <p> This is the basis of the expression templates technique [19], which creates parse trees of array expressions at compile time. These parse trees are used to generate efficient evaluation routines for array expressions. This technique is the backbone of several libraries for object-oriented numerics <ref> [12, 21] </ref>. 1.4 Traits The traits technique [13] allows programmers to define "functions" which operate on and return types rather than data. As a motivating example, consider a generic function which calculates the average value of an array.
Reference: [13] <author> N. Myers, </author> <title> A new and useful template technique: "Traits", C++ Report, </title> <booktitle> 7 (1995), </booktitle> <pages> pp. 32-35. </pages>
Reference-contexts: These parse trees are used to generate efficient evaluation routines for array expressions. This technique is the backbone of several libraries for object-oriented numerics [12, 21]. 1.4 Traits The traits technique <ref> [13] </ref> allows programmers to define "functions" which operate on and return types rather than data. As a motivating example, consider a generic function which calculates the average value of an array. What should its return type be? If the array contains integers, a floating-point result should be returned.
Reference: [14] <author> F. Nielson and H. R. Neilson, </author> <title> Two-Level Functional Languages, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Such capabilities would allow programmers to query objects about their methods and members, determine the parameter types of functions, and perhaps even manipulate and generate abstract syntax trees. 4 Related Work Nielson and Nielson <ref> [14] </ref> first investigated two-level languages and showed that binding-time analysis can be expressed as a form of type checking. The most closely related work is MetaML, a statically typed multi-level language for hand-writing code generators [17].
Reference: [15] <author> J. G. Siek and A. Lumsdaine, </author> <title> The Matrix Template Library: A generic programming approach to high performance numerical linear algebra, </title> <booktitle> in International Symposium on Computing in Object-Oriented Parallel Environments, </booktitle> <year> 1998. </year>
Reference-contexts: 1 Introduction Templates were added to the C++ language to support generic programming. However, their addition unintentionally introduced powerful mechanisms for compile-time computation and code generation. These mechanisms have proven themselves very useful in generating optimized code for scientific computing applications <ref> [12, 15, 21, 22] </ref>. Since they are accidental features, their syntax is somewhat awkward. The goal of this paper is to achieve a simpler syntax by recasting these features as partial evaluation. <p> The syntax for writing such code generators is clumsy. However, the technique has proven very useful in producing specialized algorithms for scientific computing <ref> [15, 22] </ref>. 4 It is even possible to create and manipulate static data structures at compile time, by encoding them as templates. This is the basis of the expression templates technique [19], which creates parse trees of array expressions at compile time.
Reference: [16] <author> J. Stichnoth and T. Gross, </author> <title> Code composition as an implementation language for compilers, </title> <booktitle> in USENIX Conference on Domain-Specific Languages, </booktitle> <year> 1997. </year>
Reference-contexts: Relevant examples are Xroma [5], MPC++ [10], Open C++ [3], and Magik [6]. These systems are not phrased in terms of partial evaluation or two-level languages; code generation is generally done by constructing abstract syntax trees. A more closely related system is Catacomb <ref> [16] </ref>, which provides a two-level language for generating runtime library code for parallelizing compilers. However, it does not address issues of generic programming.
Reference: [17] <author> W. Taha and T. Sheard, </author> <title> Multi-stage programming with explicit annotations, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 32 (1997), </volume> <pages> pp. 203-217. </pages>
Reference-contexts: The most closely related work is MetaML, a statically typed multi-level language for hand-writing code generators <ref> [17] </ref>. Gluck and Jorgensen described a program generator for multi-level specialization [8] which uses a multi-level functional language to represent automatically produced program generators. Metalevel processing systems address many of the same problems as Catat; they give library writers the ability to directly manipulate abstract syntax trees at compile time.
Reference: [18] <author> E. Unruh, </author> <title> Prime number computation, </title> <note> 1994. ANSI X3J16-94-0075/ISO WG21-462. </note>
Reference-contexts: Templates allow programmers to develop classes and functions which are very customizable, yet retain the efficiency of statically configured code. 1.2 Compile-time computations Templates can be exploited to perform computations at compile time. This was discovered by Erwin Unruh <ref> [18] </ref>, who wrote a program which produced these errors at compile time: erwin.cpp 10: Cannot convert 'enum' to 'D&lt;2&gt;' erwin.cpp 10: Cannot convert 'enum' to 'D&lt;3&gt;' erwin.cpp 10: Cannot convert 'enum' to 'D&lt;5&gt;' erwin.cpp 10: Cannot convert 'enum' to 'D&lt;7&gt;' erwin.cpp 10: Cannot convert 'enum' to 'D&lt;11&gt;' ...
Reference: [19] <author> T. L. Veldhuizen, </author> <title> Expression templates, C++ Report, </title> <booktitle> 7 (1995), </booktitle> <pages> pp. 26-31. </pages> <note> Reprinted in C++ Gems, </note> <editor> ed. Stanley Lippman. </editor> <title> [20] , Using C++ template metaprograms, C++ Report, </title> <booktitle> 7 (1995), </booktitle> <pages> pp. 36-43. </pages> <note> Reprinted in C++ Gems, </note> <editor> ed. Stanley Lippman. </editor> <booktitle> [21] , Arrays in Blitz++, in ISCOPE'98, vol. 1505 of Lecture Notes in Computer Science, </booktitle> <year> 1998. </year>
Reference-contexts: However, the technique has proven very useful in producing specialized algorithms for scientific computing [15, 22]. 4 It is even possible to create and manipulate static data structures at compile time, by encoding them as templates. This is the basis of the expression templates technique <ref> [19] </ref>, which creates parse trees of array expressions at compile time. These parse trees are used to generate efficient evaluation routines for array expressions.
Reference: [22] <author> T. L. Veldhuizen and K. Ponnambalam, </author> <title> Linear algebra with C++ template metaprograms, </title> <journal> Dr. Dobb's Journal of Software Tools, </journal> <volume> 21 (1996), </volume> <pages> pp. 38-44. </pages>
Reference-contexts: 1 Introduction Templates were added to the C++ language to support generic programming. However, their addition unintentionally introduced powerful mechanisms for compile-time computation and code generation. These mechanisms have proven themselves very useful in generating optimized code for scientific computing applications <ref> [12, 15, 21, 22] </ref>. Since they are accidental features, their syntax is somewhat awkward. The goal of this paper is to achieve a simpler syntax by recasting these features as partial evaluation. <p> The syntax for writing such code generators is clumsy. However, the technique has proven very useful in producing specialized algorithms for scientific computing <ref> [15, 22] </ref>. 4 It is even possible to create and manipulate static data structures at compile time, by encoding them as templates. This is the basis of the expression templates technique [19], which creates parse trees of array expressions at compile time.
References-found: 20

