URL: http://www.cs.indiana.edu/pub/dswise/ICFP.tr437.ps.Z
Refering-URL: http://www.cs.indiana.edu/pub/dswise/
Root-URL: http://www.cs.indiana.edu
Email: dswise,jwalgenb@cs.indiana.edu  
Title: Static and Dynamic Partitioning of Pointers as Links and Threads  
Author: David S. Wise and Joshua Walgenbach 
Keyword: Categories and subject descriptors: D.3.3 [Programming Languages]: Language Constructs and Features|data types and structures, dynamic storage management, abstract data types; E.2 [Data Storage Representations]: Linked representations; B.3.2 [Memory Structures]: Design Styles|primary memory. General Term: Languages. Additional Key Words and Phrases: storage management, reference counting, garbage collection, tags.  
Address: Bloomington, Indiana 47405-4101 USA  
Affiliation: Computer Science Department, Indiana University  
Pubnum: Technical Report 437  
Abstract: Identifying some pointers as invisible threads, for the purposes of storage management, is a generalization from several widely used programming conventions, like threaded trees. The necessary invariant is that nodes that are accessible (without threads) emit threads only to other accessible nodes. Dynamic tagging or static typing of threads ameliorates storage recycling both in functional and imperative languages. We have seen the distinction between threads and links sharpen both hardware- and software-supported storage management in Scheme, and also in C. Certainly, therefore, implementations of languages that already have abstract management and concrete typing, should detect and use this as a new static type. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Inform. Proc. Ltrs. </journal> <volume> 25, </volume> <month> 4 (June </month> <year> 1987), </year> <pages> 275-279. </pages>
Reference-contexts: Uniquely referenced nodes should be identified at compile time by a type system or at run time by tagging. Then they can be reused through purely local transactions (while resident in cache) or recycled with less resources, even, than idealized collection <ref> [1] </ref>. Baker offers a good example of this behavior [4]. Distinguishing threads from links has the effect of reducing reference counts, making unique references more frequent and more frequently useful. Generation-scavenging, however, will suffer from violations on the genetic order of addresses that arise from this sort of in-situ reuse.
Reference: [2] <author> A. W. Appel & Z. Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with closures. </title> <journal> J. Funct. </journal> <note> Programming (to appear). </note>
Reference: [3] <author> H. G. Baker, Jr. </author> <title> List processing in real time on a serial computer. </title> <journal> Comm. ACM 21, </journal> <month> 4 (April </month> <year> 1978), </year> <pages> 280-294. </pages>
Reference-contexts: Although they reside at the address of the node, they do not consume the address space usually associated with main memory; "hidden" memory contains the tags and the reference counts at the same address. (This illusion contrasts with Baker's assertion <ref> [3] </ref> that reference counting consumed both address space and processor cycles.) Although the type is reset at allocation, the content and live/dead tags remain meaningful until a write instruction changes both them and the visible content of the node.
Reference: [4] <author> H. G. Baker, Jr. </author> <title> Lively linear Lisp|`Look Ma, no garbage.' </title> <journal> ACM SIGPLAN Notices 27, </journal> <month> 8 (August </month> <year> 1992), </year> <pages> 89-98. </pages>
Reference-contexts: Then they can be reused through purely local transactions (while resident in cache) or recycled with less resources, even, than idealized collection [1]. Baker offers a good example of this behavior <ref> [4] </ref>. Distinguishing threads from links has the effect of reducing reference counts, making unique references more frequent and more frequently useful. Generation-scavenging, however, will suffer from violations on the genetic order of addresses that arise from this sort of in-situ reuse.
Reference: [5] <author> D. W. Clark and C. C. Green. </author> <title> A note on shared structure in Lisp. </title> <journal> Inform. Proc. Ltrs. </journal> <volume> 7, </volume> <month> 6 (October </month> <year> 1978), </year> <pages> 312-314. </pages>
Reference-contexts: Definition 9 [27] A link is unique when its destination has a reference count known to be one. Otherwise, it is sticky. The term "sticky" is borrowed from the convention of fitting a static infinity into the range of reference counts <ref> [5] </ref>, whence neither increments nor decrements change it. (But a full garbage collection might [24, 27].) A reference count can be both one and sticky, after an imperfect counting protocol loses the precise count on a node and no longer "knows" it. Convention Roots emit only links.
Reference: [6] <author> J. Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Comput. Surveys 13, </journal> <month> 3 (September </month> <year> 1981), </year> <pages> 341-367. </pages>
Reference-contexts: The exact impact depends on the kind of storage manager used. (This paper takes the perspective that reference counting is distinguished from garbage collection [24, 8, 12, p. 412], rather than one of its techniques <ref> [6] </ref>.) For instance, a garbage collection can ignore all threads, saving the time to traverse them. Under reference counting, some counts will be one tick lower, saving both their increments and decrements, and often avoiding troublesome cycles.
Reference: [7] <author> G. E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Comm. ACM 3, </journal> <month> 12 (December </month> <year> 1960), </year> <pages> 655-657. </pages>
Reference-contexts: Another is to extend the pointer function to one in N fi L ! N fi T so every pointer carries a tag; this corresponds to dynamic tagging of an attribute at run time. Definition 8 <ref> [7] </ref> The reference count of a node is the number of links absorbed by it. Definition 9 [27] A link is unique when its destination has a reference count known to be one. Otherwise, it is sticky. <p> In all cases of a linear list, the links form a simple, singly linked list whose space might easily be recycled, either by hand, by elementary reference counting, or by "unique" typing at compile time. The use of reference counting in early list-processing systems <ref> [7, 23] </ref> reveals other kinds of pointers long treated as threads. The readers of Slip, which used reference counting well [24], contained references that were never counted 2 [23, Fig. 3]. From a modern perspective, the readers im-plemented a crude recursion stack of threads.
Reference: [8] <author> L. P. Deutsch & D. G. Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Comm. ACM 19, </journal> <month> 9 (September </month> <year> 1976), </year> <pages> 522-526. </pages>
Reference-contexts: The exact impact depends on the kind of storage manager used. (This paper takes the perspective that reference counting is distinguished from garbage collection <ref> [24, 8, 12, p. 412] </ref>, rather than one of its techniques [6].) For instance, a garbage collection can ignore all threads, saving the time to traverse them. Under reference counting, some counts will be one tick lower, saving both their increments and decrements, and often avoiding troublesome cycles.
Reference: [9] <author> D. P. Friedman and D. S. Wise. </author> <title> Reference counting can manage the circular environments of mutual recursion. </title> <journal> Inform. Proc. Ltrs. </journal> <volume> 8, </volume> <month> 1 (January </month> <year> 1979), </year> <pages> 41-44. </pages>
Reference-contexts: device that manages the heap in real time, purely local transactions provided storage management directly from the mutator, without its processor accessing more RAM . 3.2 Dynamic Links and Threads Singly-linked circular lists can be recovered by real-time reference counting when the enclosing link can be treated as a thread <ref> [9] </ref>.
Reference: [10] <author> W. Goldman. The Princess Bride, (screenplay). Nelson Entertainment & Twentieth-Century Fox Film Corp. </author> <year> (1987), </year> <title> Miracle Max scene. </title>
Reference-contexts: Later incarnations [15, x2:2:2] had the garbage collector replace them with nil (or equivalent). While this protocol enforces Invariant 1, it renders a pointer only mostly dead <ref> [10] </ref>, because it causes work for the collector and because a nil weak pointer now confuses the empty list with lost denotation that disappeared in an intervening collection. 3.3 More Examples are Solicited The examples cited here are by no means intended to be complete.
Reference: [11] <author> E. Horowitz & S. Sahni. </author> <title> Fundamentals of Data Structures in Pascal, </title> <address> Rockville, Md, </address> <publisher> Computer Science Press (1983). </publisher>
Reference-contexts: Then front and all its internal links likely remain unique. A corollary to this convention, that directly yields superior code, is that rear of an empty queue must be undefined: ? <ref> [11] </ref>, rather than something meaningful [12, pp. 256-257] [20, p. 29] [13, pp. 79-80], because there is no accessible node to absorb a thread. In doubly-linked lists where forward pointers are links, we can treat reverse pointers as threads.
Reference: [12] <author> D. E. Knuth. </author> <title> The Art of Computer Programming, I, Fundamental Algorithms (2nd ed.), </title> <address> Reading, MA, </address> <publisher> Addison-Wesley, </publisher> <year> (1973.) </year>
Reference-contexts: Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or permissions@acm.org. Proc. 1996 Intl. Conf. on Functional Programming, 42-49. To appear in SIGPLAN Notices 31. Informally, a linked structures must be rooted and spanned by links. Definition 2 A pointer or reference is a thread <ref> [12] </ref> if it is optional in a linked structure, in the sense that it can be inferred from a traversal from the roots that follows links exclusively. On first reading of any program, one may assume that all pointers/references are links; threads can be introduced later. <p> Examples of threads are already familiar to the reader. The rear pointer to the end of a singly-linked queue should statically be treated as a thread. Threaded trees <ref> [12] </ref>, in contrast, are an example of a dynamic link/thread distinction, because a pointer requires a run-time tag to imply its meaning. Another familiar thread is the "reverse" pointer paired to every "forward" link as an edge in a doubly-linked list. <p> The exact impact depends on the kind of storage manager used. (This paper takes the perspective that reference counting is distinguished from garbage collection <ref> [24, 8, 12, p. 412] </ref>, rather than one of its techniques [6].) For instance, a garbage collection can ignore all threads, saving the time to traverse them. Under reference counting, some counts will be one tick lower, saving both their increments and decrements, and often avoiding troublesome cycles. <p> Section 5 describes our motivation and results, the motivation for the general observation, and the final section offers conclusions and a challenge for compiler-writers. 2 Definitions and Invariant Definition 3 T = flive; deadg is the set of tags. "Tag," is used as in threading of binary trees <ref> [12] </ref>. Links are live, and threads are dead. Definition 4 Let the set of active nodes in the heap be N ; each one is perceived as a record with a small set of fields, each identified from a finite set L of labels. <p> Then front and all its internal links likely remain unique. A corollary to this convention, that directly yields superior code, is that rear of an empty queue must be undefined: ? [11], rather than something meaningful <ref> [12, pp. 256-257] </ref> [20, p. 29] [13, pp. 79-80], because there is no accessible node to absorb a thread. In doubly-linked lists where forward pointers are links, we can treat reverse pointers as threads. Definition 12 Reverse pointers in a doubly linked list are called counterpointers. <p> The presence of header nodes <ref> [23, 12, x2.2.5] </ref> alters these conventions only slightly. "Nailing down" a node is a dynamic trick that uses a static protocol. <p> No explicit tags are necessary because a static partitioning exists only for the span of code while the nail is "in." There are several ways to thread a tree <ref> [12, x2.3.1-2] </ref>: for example, inorder [19] or level-order [12, p. 350] successors. Tarjan introduces several threadings to explain his palm trees [21]; his tree arcs are links, but his fronds, reverse fronds, and cross-links are all threads. <p> No explicit tags are necessary because a static partitioning exists only for the span of code while the nail is "in." There are several ways to thread a tree [12, x2.3.1-2]: for example, inorder [19] or level-order <ref> [12, p. 350] </ref> successors. Tarjan introduces several threadings to explain his palm trees [21]; his tree arcs are links, but his fronds, reverse fronds, and cross-links are all threads. Where these threads are overloaded in a field that could alternatively contain a link, they must be treated as dynamic.
Reference: [13] <author> H. R. Lewis & L. Dennenberg. </author> <title> Data Structures & their Algorithms, </title> <address> New York, </address> <month> HarperCollins </month> <year> (1991). </year>
Reference-contexts: Then front and all its internal links likely remain unique. A corollary to this convention, that directly yields superior code, is that rear of an empty queue must be undefined: ? [11], rather than something meaningful [12, pp. 256-257] [20, p. 29] <ref> [13, pp. 79-80] </ref>, because there is no accessible node to absorb a thread. In doubly-linked lists where forward pointers are links, we can treat reverse pointers as threads. Definition 12 Reverse pointers in a doubly linked list are called counterpointers.
Reference: [14] <author> D. Liles, P. Mamnami, R. Sinclair, J. Walgenbach, & S. Williams. </author> <title> ROD User's Guide. Class notes for Software Development, </title> <institution> Computer Science Dept., New Mex-ico State Univ. </institution> <month> (Spring </month> <year> 1994). </year>
Reference-contexts: ROD was originally written in C, using linked lists and arrays for data structures, at New Mexico State University in Fall 1993 and used there in later semesters <ref> [14] </ref>, In Spring 1995, ROD was converted to run using the Reference-Counting Memory at Indiana University, as an experiment to excise explicit memory management from the ROD system, replacing it with RCM's hardware support.
Reference: [15] <author> J. S. Miller. MultiScheme: </author> <title> a Parallel Processing System Based on MIT Scheme, </title> <type> Ph.D. dissertation, </type> <institution> Mass. Institute of Tech. </institution> <year> (1987). </year>
Reference-contexts: Threaded trees [12], in contrast, are an example of a dynamic link/thread distinction, because a pointer requires a run-time tag to imply its meaning. Another familiar thread is the "reverse" pointer paired to every "forward" link as an edge in a doubly-linked list. Others include weak pointers <ref> [15] </ref> in many Lisp and Scheme implementations. The new principle for implementors of programming systems and for low-level programmers is (Invariant 1) that threads point only to nodes accessible exclusively via links. Programmers should recognize dynamic threading more effectively than they do now; compilers should better recognize static threading [17]. <p> These are pointers installed by the programmer as a convenience, flagged so not to be traversed by the garbage collector. In MacLisp these appeared first in un-garbage-collected arrays [16, pp. 79-80] whose content were threads, but with a caution instead of Invariant 1. Later incarnations <ref> [15, x2:2:2] </ref> had the garbage collector replace them with nil (or equivalent).
Reference: [16] <author> Moon, David A. </author> <title> MACLISP Reference Manual , Project MAC, </title> <address> Mass. </address> <institution> Institute of Tech. </institution> <month> (April </month> <year> 1974). </year>
Reference-contexts: Several Lisp and Scheme implementations provide weak pointers. These are pointers installed by the programmer as a convenience, flagged so not to be traversed by the garbage collector. In MacLisp these appeared first in un-garbage-collected arrays <ref> [16, pp. 79-80] </ref> whose content were threads, but with a caution instead of Invariant 1. Later incarnations [15, x2:2:2] had the garbage collector replace them with nil (or equivalent).
Reference: [17] <author> Y. Park & B. Goldberg. </author> <title> Static analysis for optimizing reference counting. </title> <journal> Info. Proc. Lett. </journal> <volume> 55, </volume> <month> 4 (August </month> <year> 1995), </year> <pages> 229-234. </pages>
Reference-contexts: The new principle for implementors of programming systems and for low-level programmers is (Invariant 1) that threads point only to nodes accessible exclusively via links. Programmers should recognize dynamic threading more effectively than they do now; compilers should better recognize static threading <ref> [17] </ref>. Their use accelerates production code (sometimes called the mutator in systems with automatic storage management) by short-circuiting redundant reallocation, and also they can accelerate space recovery (the collector when one exists).
Reference: [18] <author> W. Pugh. </author> <title> Skip lists: a probabilistic alternative to balanced trees. </title> <journal> Comm. ACM 33, </journal> <month> 6 (June </month> <year> 1990), </year> <pages> 668-676. </pages>
Reference-contexts: Its main purpose here is to characterize the impact on storage management of distinguishing links from threads, and to lay a foundation for understanding the tables in the next subsection. A skip list <ref> [18] </ref> is a search structure generalized from a sorted linear list, with additional pointers woven into it that allow its search algorithm to take long strides. As defined, it is an acyclic structure.
Reference: [19] <author> A. J. Perlis & C. Thornton. </author> <title> Symbol manipulation by threaded lists. </title> <journal> Comm. ACM 3, </journal> <month> 4 (April </month> <year> 1960), </year> <pages> 195-204. </pages>
Reference-contexts: No explicit tags are necessary because a static partitioning exists only for the span of code while the nail is "in." There are several ways to thread a tree [12, x2.3.1-2]: for example, inorder <ref> [19] </ref> or level-order [12, p. 350] successors. Tarjan introduces several threadings to explain his palm trees [21]; his tree arcs are links, but his fronds, reverse fronds, and cross-links are all threads.
Reference: [20] <author> T. Standish. </author> <title> Data Structure Techniques, </title> <address> Reading, MA, </address> <publisher> Addison-Wesley ((1980). </publisher>
Reference-contexts: Then front and all its internal links likely remain unique. A corollary to this convention, that directly yields superior code, is that rear of an empty queue must be undefined: ? [11], rather than something meaningful [12, pp. 256-257] <ref> [20, p. 29] </ref> [13, pp. 79-80], because there is no accessible node to absorb a thread. In doubly-linked lists where forward pointers are links, we can treat reverse pointers as threads. Definition 12 Reverse pointers in a doubly linked list are called counterpointers.
Reference: [21] <author> R. Tarjan. </author> <title> Finding dominators in directed graphs. </title> <journal> SIAM J. Comput. </journal> <volume> 3, </volume> <month> 1 (March </month> <year> 1974), </year> <pages> 62-89. </pages>
Reference-contexts: Tarjan introduces several threadings to explain his palm trees <ref> [21] </ref>; his tree arcs are links, but his fronds, reverse fronds, and cross-links are all threads. Where these threads are overloaded in a field that could alternatively contain a link, they must be treated as dynamic. Several Lisp and Scheme implementations provide weak pointers.
Reference: [22] <author> D. N. Turner & P. Wadler. </author> <title> Once upon a type. </title> <booktitle> Conference on Functional Programming and Computer Architecture. </booktitle> <address> New York, </address> <publisher> ACM Press (1995), </publisher> <pages> 1-11. </pages>
Reference: [23] <author> J. Weizenbaum. </author> <title> Symmetric list processor. </title> <journal> Comm. ACM 6, </journal> <month> 9 (September </month> <year> 1963), </year> <pages> 524-544. </pages>
Reference-contexts: In all cases of a linear list, the links form a simple, singly linked list whose space might easily be recycled, either by hand, by elementary reference counting, or by "unique" typing at compile time. The use of reference counting in early list-processing systems <ref> [7, 23] </ref> reveals other kinds of pointers long treated as threads. The readers of Slip, which used reference counting well [24], contained references that were never counted 2 [23, Fig. 3]. From a modern perspective, the readers im-plemented a crude recursion stack of threads. <p> The use of reference counting in early list-processing systems [7, 23] reveals other kinds of pointers long treated as threads. The readers of Slip, which used reference counting well [24], contained references that were never counted 2 <ref> [23, Fig. 3] </ref>. From a modern perspective, the readers im-plemented a crude recursion stack of threads. Weizenbaum's convention worked because the extra references were necessarily redundant, satisfying Invariant 1. Alternatively, we might view their destinations as "nailed down" by other pointers. <p> The presence of header nodes <ref> [23, 12, x2.2.5] </ref> alters these conventions only slightly. "Nailing down" a node is a dynamic trick that uses a static protocol. <p> This is a hardwired revision of an algorithm due to Weizenbaum <ref> [23, p. 527] </ref>. RCM's design also contains an unimplemented provision that a pointer can be tagged (in its units bit that should be 0 with word addressing) as a thread.
Reference: [24] <author> J. Weizenbaum. </author> <title> More on the reference counter method of erasing list structures. </title> <journal> Comm. </journal> <note> ACM 7, 1 (January 1964), 38. </note>
Reference-contexts: The exact impact depends on the kind of storage manager used. (This paper takes the perspective that reference counting is distinguished from garbage collection <ref> [24, 8, 12, p. 412] </ref>, rather than one of its techniques [6].) For instance, a garbage collection can ignore all threads, saving the time to traverse them. Under reference counting, some counts will be one tick lower, saving both their increments and decrements, and often avoiding troublesome cycles. <p> Otherwise, it is sticky. The term "sticky" is borrowed from the convention of fitting a static infinity into the range of reference counts [5], whence neither increments nor decrements change it. (But a full garbage collection might <ref> [24, 27] </ref>.) A reference count can be both one and sticky, after an imperfect counting protocol loses the precise count on a node and no longer "knows" it. Convention Roots emit only links. <p> The use of reference counting in early list-processing systems [7, 23] reveals other kinds of pointers long treated as threads. The readers of Slip, which used reference counting well <ref> [24] </ref>, contained references that were never counted 2 [23, Fig. 3]. From a modern perspective, the readers im-plemented a crude recursion stack of threads. Weizenbaum's convention worked because the extra references were necessarily redundant, satisfying Invariant 1. Alternatively, we might view their destinations as "nailed down" by other pointers.
Reference: [25] <author> D. S. Wise. </author> <title> Referencing lists by an edge. </title> <journal> Comm. ACM 19, </journal> <month> 6 (June </month> <year> 1976), </year> <pages> 338-342. </pages>
Reference-contexts: Figures 1-6 show the sequence of event in a node deletion. threads. The pointer O refers to the structure containing both the head and tail of the object queue <ref> [25] </ref>.
Reference: [26] <author> D. S. Wise. </author> <title> Design for a multiprocessing heap with on-board reference counting. </title> <editor> In J.-P. Jouannaud (ed.), </editor> <booktitle> Functional Programming Languages and Computer Architecture, Lecture Notes in Computer Science 201, </booktitle> <address> Berlin, </address> <publisher> Springer (1985), </publisher> <pages> 289-304. 8 </pages>
Reference-contexts: chance!) In either case, the checker must validate these invariants. 5 Experience The perspective above is a result of experience with a design for hardware that was built [28] (in prototype without initialization of its live/dead tag) and subsequently used in serendipitous ways that were not anticipated at its design <ref> [26] </ref>. <p> That experience led to our vision of static link/thread typing at compile time. The reference-counting memory (RCM) was designed in 1984 <ref> [26] </ref> and built in 1989 [28] as an experiment in rapid prototyping, in digital design derivation, and in memory support for multiprocessing. The uniprocessing hardware currently supports an elementary Scheme compiler and direct manipulation through languages like C or C++. The latter programming style is reported here.
Reference: [27] <author> D. S. Wise. </author> <title> Stop-and-copy and one-bit reference count-ing. </title> <journal> Inform. Proc. Ltrs. </journal> <volume> 46, </volume> <month> 5 (July </month> <year> 1993), </year> <pages> 243-249. </pages>
Reference-contexts: Definition 8 [7] The reference count of a node is the number of links absorbed by it. Definition 9 <ref> [27] </ref> A link is unique when its destination has a reference count known to be one. Otherwise, it is sticky. <p> Otherwise, it is sticky. The term "sticky" is borrowed from the convention of fitting a static infinity into the range of reference counts [5], whence neither increments nor decrements change it. (But a full garbage collection might <ref> [24, 27] </ref>.) A reference count can be both one and sticky, after an imperfect counting protocol loses the precise count on a node and no longer "knows" it. Convention Roots emit only links. <p> It that bit were 1 as a pointer were written into a binary node, not only would the usual increment be cancelled but also that field would be tagged as dead|as if it were in an atomic node. Intended to provide circular references <ref> [27] </ref>, that protocol is simulated in this work by three write instructions that tell RCM * to write the pointer as if it were live; * to decrement the reference count of its content, just incremented; * to reset the tag on that field to be dead, cancelling the future decrement.
Reference: [28] <author> D. S. Wise, B. Heck, C. Hess, W. Hunt, and E. </author> <title> Ost. Uniprocessor performance of reference-counting hardware heap. </title> <type> Technical Report 401, </type> <institution> Computer Science Dept., Indiana Univ. </institution> <month> (June </month> <year> 1994). </year> <month> 9 </month>
Reference-contexts: Either the programmer must identify links as seeds, or an eager compiler might optimistically conjecture the threads. (Fat chance!) In either case, the checker must validate these invariants. 5 Experience The perspective above is a result of experience with a design for hardware that was built <ref> [28] </ref> (in prototype without initialization of its live/dead tag) and subsequently used in serendipitous ways that were not anticipated at its design [26]. <p> That experience led to our vision of static link/thread typing at compile time. The reference-counting memory (RCM) was designed in 1984 [26] and built in 1989 <ref> [28] </ref> as an experiment in rapid prototyping, in digital design derivation, and in memory support for multiprocessing. The uniprocessing hardware currently supports an elementary Scheme compiler and direct manipulation through languages like C or C++. The latter programming style is reported here. <p> Therefore, it now requires two more control instructions to simulate the single write, as designed for multiprocessing. Speculation that this work triples the timing, however, is inappropriate because the implementation (on a Nu-bus with NeXT's controller chip) muddles such analyses <ref> [28, x2] </ref>. As mentioned, we discovered that this simulated instruction proved to be far more useful than merely to build simple circular lists.
References-found: 28

