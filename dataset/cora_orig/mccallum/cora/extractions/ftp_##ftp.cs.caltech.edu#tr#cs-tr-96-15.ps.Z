URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-96-15.ps.Z
Refering-URL: http://swarm.cs.wustl.edu/cs673/
Root-URL: 
Email: fadam,manig@cs.caltech.edu  
Title: Systematic Composition of Objects in Distributed Internet Applications: Processes and Sessions  
Author: K. Mani Chandy and Adam Rifkin 
Date: June 9, 1996  
Address: Pasadena, California 91125  
Affiliation: Computer Science 256-80 California Institute of Technology  
Abstract: We consider a system with the infrastructure for the creation and interconnection of large numbers of distributed persistent objects. This system is exemplified by the Internet: potentially, every appliance and document on the Internet has both persistent state and the ability to interact with large numbers of other appliances and documents on the Internet. This paper elucidates the characteristics of such a system, and proposes the compositional requirements of its corresponding infrastructure. We explore the problems of specifying, composing, reasoning about, and implementing applications in such a system. A specific concern of our research is developing the infrastructure to support structuring distributed applications by using sequential, choice, and parallel composition, in the anarchic environment where application compositions may be unforeseeable, and interactions may be unknown prior to actually occurring. The structuring concepts discussed are relevant to a wide range of distributed applications; our implementation is illustrated with collaborative Java processes interacting over the Internet, but the methodology provided can be applied independent of specific platforms. Key words: Distributed Systems, Composition, Reasoning, Java, Internet. fl This research is supported in part by NSF grants CCR-912008 and CCR-9527130. This work constitutes part of the Caltech Infospheres Project; more information is available on the Web at http://www.infospheres.caltech.edu/. Note that this paper is Copyright 1996 IEEE, Published in the Pro ceedings of the 30th Hawaii International Conference on System Sciences, January 7-10, 1997, Maui, Hawaii. 
Abstract-found: 1
Intro-found: 1
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year> <note> Also available as DEC SRC Research Report 66. </note>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [CM88, Lam94]. Sessions are collections of processes composed in parallel <ref> [AL93, Cha94] </ref>. A session is specified in terms of the precondition and postcondition predicates [Hoa69] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [DS90]. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [BLCGP92] <author> T. Berners-Lee, R. Cailliau, J. Groff, and B. Pollermann. </author> <title> World Wide Web: The Information Universe. </title> <journal> Electronic Networking: Research, Applications, and Policy, </journal> <volume> 1(2), </volume> <year> 1992. </year>
Reference-contexts: The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java [GJS96], TCP/IP [Ste94], and the World Wide Web <ref> [BLCGP92] </ref>. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system. <p> ILU can be used to build multi-lingual distributed object systems; remote procedure call services can be described and used as ILU objects. Whereas CORBA provides a useful architecture for disseminating structured information, the World Wide Web <ref> [BLCGP92] </ref> has proven useful as a mechanism for distributing less structured information. As a result, many research groups [OW96] are presently working on systems and applications in which distributed (and possibly mobile) objects interact over the World Wide Web.
Reference: [BN84] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year> <month> 21 </month>
Reference-contexts: Therefore, the delay between sending a message and the eventual response to the message can vary a great deal. For this reason, asynchronous buffered message-passing mechanisms are used, as illustrated in Figure 3. Therefore, the underlying communication mechanism is not a synchronized remote procedure call (RPC) <ref> [BN84] </ref>; a process P cannot modify Q's state by executing an RPC on Q. Rather, a process P can send a message to Q requesting that Q execute an asynchronous (i.e., one-way) RPC, and this message is placed in one of process Q's incoming message queues. <p> Putting the concepts discussed in this paper into the distributed object context, processes are objects that interact using remote procedure calls <ref> [BN84] </ref>, and the interfaces through which they receive messages are the public interfaces they export. Sessions are conglomerations of interacting objects; such object interface definitions are part of the CORBA standard, which defines an implementation language-independent interface definition language.
Reference: [BNOW95] <author> A. Birrell, G. Nelson, S. Owicki, </author> <title> and E.P. Wobber. Network Objects. </title> <journal> Software Practice and Experience, </journal> <volume> 25(S4):87-130, </volume> <month> December </month> <year> 1995. </year> <note> Also available as DEC SRC Research Report 115. </note>
Reference-contexts: Our implementation shares many design features of network objects <ref> [BNOW95] </ref>, including distributed typechecking, transparent remote invocation, marshaling, and buffered streams.
Reference: [BST89] <author> H.E. Bal, J.G. </author> <title> Steiner, and A.S. Tanenbaum. Programming Languages for Distributed Computing Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 261-322, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The Web can also be used to locate the running programs themselves. 19 5 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [Tan95], distributed languages <ref> [BST89] </ref>, and distributed algorithms [CM88, Lyn96]. Our programming model and theories of structured composition build on this research and recent work in formal methods [DS90, CT92, AL93, Cha94, Lam94, CS95].
Reference: [Car95] <author> L. Cardelli. </author> <title> A Language with Distributed Scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Many systems, including the Obliq distributed scripting language <ref> [Car95] </ref>, have been built using Modula-3 network objects. Obliq objects have state and are local to a site; Obliq enables a dynamic form of distributed programming, where objects can redirect their behavior over the network, and where computations can roam between network sites.
Reference: [Cha94] <author> K.M. Chandy. </author> <title> Properties of Concurrent Programs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6) </volume> <pages> 607-619, </pages> <year> 1994. </year>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [CM88, Lam94]. Sessions are collections of processes composed in parallel <ref> [AL93, Cha94] </ref>. A session is specified in terms of the precondition and postcondition predicates [Hoa69] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [DS90]. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [CL85] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining the Global States of Distributed Systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The problem is that processes do not share a global clock. Though local clocks are quite accurate they are not perfectly synchronized. We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion <ref> [CL85] </ref>. The global snapshot criterion is satisfied, provided every message that is sent when the sender's clock is T , is received when the receiver's clock exceeds T .
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: In the structured examples, an application program can be partitioned into components in systematic ways. The computer science community has discovered methodical ways of dividing a task into components, and composing those components using sequential, choice, and parallel composition (c.f., <ref> [CM88, CT92] </ref>). In the anarchic case, the components are given, and the task is to compose them to achieve some end. The application developer needs to determine whether components have compatible interfaces, and whether the components can be composed in a meaningful way. <p> We propose two kinds of compositional units, processes and sessions, and demonstrate properties of these units in the context of other work done on the theory of composition. Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic <ref> [CM88, Lam94] </ref>. Sessions are collections of processes composed in parallel [AL93, Cha94]. A session is specified in terms of the precondition and postcondition predicates [Hoa69] of its component processes. <p> Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [CM88, Lam94, CS95] </ref>. <p> The Web can also be used to locate the running programs themselves. 19 5 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [Tan95], distributed languages [BST89], and distributed algorithms <ref> [CM88, Lyn96] </ref>. Our programming model and theories of structured composition build on this research and recent work in formal methods [DS90, CT92, AL93, Cha94, Lam94, CS95].
Reference: [CRS + 96] <author> K.M. Chandy, A. Rifkin, P.A.G. Sivilotti, J. Mandelson, M. Richardson, W. Tanaka, and L. Weisman. </author> <title> A World-Wide Distributed System Using Java and the Internet. </title> <booktitle> In Proceedings of the Fifth Workshop on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [DS90]. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure <ref> [CRS + 96] </ref> supports such capability. Composing Distributed Objects on the Internet. We model every program, appliance, and document connected to the Internet with a state that is persistent for the lifetime of its corresponding entity, as shown in Figure 2. <p> We conjecture that our programming model could handle both client-server and peer-to-peer interactions, though the focus in this paper is on peer-to-peer communication. Implemented Infrastructure. Our Caltech group is designing and implementing an infrastructure <ref> [CRS + 96] </ref> based on the models and theories of structured composition discussed in this paper. The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. <p> Our message-passing mechanism ensures FIFO delivery of messages on any given channel. input queue, only the output queues of these processes can be bound to the input queue. In our implementation, this condition is ensured by the binding mechanism provided by our infrastructure <ref> [CRS + 96] </ref>. Thus, the infrastructure facilitates control of messages that can be delivered to the input queue of a process. For instance, an input queue may restrict the binding to it to only allow "manager" processes. <p> When all of the participating processes commit to a session, the session is initiated, and the corresponding threads suspend; when the session terminates, the modified process states are saved in the persistent store, and the suspended threads resume. 14 3.3 Services to Support Sessions Our infrastructure supports services to sessions <ref> [CRS + 96] </ref>. One of the challenges is to provide a service layer that sessions can employ when we do not know in advance what the applications that include the sessions do. Next, we give a brief discussion of some of the service support we have planned for sessions. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods [DS90, CT92, AL93, Cha94, Lam94, CS95]. To supplement our model, we are designing and implementing a communication infrastructure <ref> [CRS + 96] </ref>, in which processes can be written as multithreaded Java objects called dapplets. Using the compositional theory described in this paper, dapplets can be composed into sessions, wherein the states of the component dapplets can be modified in a peer-to-peer fashion through transactions. <p> We provide formally verified reliable libraries for synchronization between threads (e.g., single-assignment variables, reusable barriers, locks, and semaphores, as specified in [SC96]), and will be working on formally verified reliable libraries providing services for use in sessions (e.g., tokens, clocks, distributed data structures, and stack layering facilities, as specified in <ref> [CRS + 96] </ref>). Our implementation shares many design features of network objects [BNOW95], including distributed typechecking, transparent remote invocation, marshaling, and buffered streams.
Reference: [CS95] <author> K.M. Chandy and B.A. Sanders. </author> <title> Predicate Transformers for Reasoning about Concurrent Computation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24(2) </volume> <pages> 129-147, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [CM88, Lam94, CS95] </ref>. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [CS96] <author> K.M. Chandy and E.M. Schooler. </author> <title> Designing Directories in Distributed Systems: A Systematic Framework. </title> <booktitle> In Proceedings of the Fifth Workshop on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Mobility and Resource Discovery. We are investigating enhancements in our system design to support communication between mobile objects through the use of directory registries <ref> [CS96] </ref>. As described at the end of Section 2.1, each process can have an immutable home address URL (that is available to Web search engines); this home address includes the unchanging address of an input queue to which requests to participate in sessions are sent.
Reference: [CT92] <author> K.M. Chandy and S. Taylor. </author> <title> An Introduction to Parallel Programming. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, MA, </address> <year> 1992. </year>
Reference-contexts: In the structured examples, an application program can be partitioned into components in systematic ways. The computer science community has discovered methodical ways of dividing a task into components, and composing those components using sequential, choice, and parallel composition (c.f., <ref> [CM88, CT92] </ref>). In the anarchic case, the components are given, and the task is to compose them to achieve some end. The application developer needs to determine whether components have compatible interfaces, and whether the components can be composed in a meaningful way. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [DS90] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Sessions are collections of processes composed in parallel [AL93, Cha94]. A session is specified in terms of the precondition and postcondition predicates [Hoa69] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming <ref> [DS90] </ref>. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure [CRS + 96] supports such capability. Composing Distributed Objects on the Internet. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [Fuc96] <author> M. Fuchs. </author> <title> Let's Talk: Extending the Web to Support Collaboration. </title> <editor> Walt Disney Imagineering, </editor> <year> 1996. </year>
Reference-contexts: As a result, many research groups [OW96] are presently working on systems and applications in which distributed (and possibly mobile) objects interact over the World Wide Web. One interesting approach is the idea of nodes with scalable intelligence <ref> [Fuc96] </ref>, in which the objects of a peer-to-peer system dynamically integrate tools into distributed cooperative applications. To support ad hoc collaborations, these objects can employ domain-specific little languages to handle interactions, and these languages can be understood both by the agent objects themselves and the humans who interact with them.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java <ref> [GJS96] </ref>, TCP/IP [Ste94], and the World Wide Web [BLCGP92]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system.
Reference: [Gro96] <institution> ILU Group. </institution> <note> Inter-Language Unification. Xerox Parc, </note> <institution> Palo Alto, </institution> <address> CA, </address> <year> 1996. </year>
Reference-contexts: This interface 20 definition provides a convenient framework in which to specify the behavior of services available to sessions as well. An example of a CORBA-like object system is the Inter-Language Unification (ILU) system <ref> [Gro96] </ref>. The object interfaces provided by ILU hide implementation distinctions between different languages, between different address spaces, and between operating system types. ILU can be used to build multi-lingual distributed object systems; remote procedure call services can be described and used as ILU objects.
Reference: [GYtJT96] <author> J. Gosling, F. Yellin, </author> <title> and the Java Team. The Java Application Programming Interface. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <booktitle> 1996. </booktitle> <pages> 22 </pages>
Reference-contexts: Also, some servlets, rather than providing services to sessions, provide services to processes or threads. For example, Java provides constructs for synchronizing threads within a process by using something like a monitor <ref> [GYtJT96] </ref>. We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a process [SC96].
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [CM88, Lam94]. Sessions are collections of processes composed in parallel [AL93, Cha94]. A session is specified in terms of the precondition and postcondition predicates <ref> [Hoa69] </ref> of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [DS90]. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure [CRS + 96] supports such capability.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion [CL85]. The global snapshot criterion is satisfied, provided every message that is sent when the sender's clock is T , is received when the receiver's clock exceeds T . A simple algorithm <ref> [Lam78] </ref> to establish this criterion is: every message is timestamped with the sender's clock; upon receiving a message, if the receiver's clock value does not exceed the timestamp of the message, then the receiver's clock is set to a value greater than the timestamp.
Reference: [Lam94] <author> L. Lamport. </author> <title> The Temporal Logic of Actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year> <note> Also available as DEC SRC Research Report 79. </note>
Reference-contexts: We propose two kinds of compositional units, processes and sessions, and demonstrate properties of these units in the context of other work done on the theory of composition. Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic <ref> [CM88, Lam94] </ref>. Sessions are collections of processes composed in parallel [AL93, Cha94]. A session is specified in terms of the precondition and postcondition predicates [Hoa69] of its component processes. <p> Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [CM88, Lam94, CS95] </ref>. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [DS90, CT92, AL93, Cha94, Lam94, CS95] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [CRS + 96], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference-contexts: The Web can also be used to locate the running programs themselves. 19 5 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [Tan95], distributed languages [BST89], and distributed algorithms <ref> [CM88, Lyn96] </ref>. Our programming model and theories of structured composition build on this research and recent work in formal methods [DS90, CT92, AL93, Cha94, Lam94, CS95].
Reference: [Mas97] <author> B.L. Massingill. </author> <title> Parallel Programming Archetypes in Scientific Computing. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [SC96], analyzing application performance [Rif96], and reasoning about parallel 9 programs <ref> [Tho96, Mas97] </ref>, but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [Obj95] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA). OMG, </title> <booktitle> 1995. Revision 2.0. </booktitle>
Reference-contexts: Our implementation uses standard platforms that are widely available: Java [GJS96], TCP/IP [Ste94], and the World Wide Web [BLCGP92]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system. As discussed in Section 5, CORBA <ref> [Obj95] </ref> can be employed to obtain a more elegant implementation, but our current system does not use this technology. 5 2 The Structure of Collaborative Applications This section elaborates on the basic objects for composition introduced in Section 1.2: processes and sessions. <p> Although our dapplet support for collaborative distributed application development was implemented using Java, the theories and tools for composition we propose are employable in conjunction with other platforms, such as CORBA-compliant Object Request Brokers <ref> [Obj95] </ref>. CORBA is a language-independent industry standard for remote invocation; through Object Request Brokers, objects in one location in a network can invoke methods on other objects in the network in a location-independent manner.
Reference: [OW96] <editor> Object Management Group and World Wide Web Consortium. </editor> <booktitle> Proceedings of the Workshop on Distributed Objects and Mobile Code. </booktitle> <address> OMG/W3C, Boston, MA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Whereas CORBA provides a useful architecture for disseminating structured information, the World Wide Web [BLCGP92] has proven useful as a mechanism for distributing less structured information. As a result, many research groups <ref> [OW96] </ref> are presently working on systems and applications in which distributed (and possibly mobile) objects interact over the World Wide Web. One interesting approach is the idea of nodes with scalable intelligence [Fuc96], in which the objects of a peer-to-peer system dynamically integrate tools into distributed cooperative applications.
Reference: [Pos80] <author> J.B. Postel. </author> <title> User Datagram Protocol. </title> <type> RFC 768, </type> <month> August </month> <year> 1980. </year>
Reference-contexts: The state can be changed only by servicing requests received from other processes. From an implementation standpoint, each process is a multithreaded persistent Java object that can communicate with other processes using UDP <ref> [Pos80] </ref>. Requests to Modify State. A process cannot modify the state of another process directly; however, a process P can request a process Q, that Q modify its state in a manner prescribed by P , as illustrated in Figure 3.
Reference: [Rif96] <author> A. Rifkin. </author> <title> Application Development using Analytic and Experimental Performance Tuning. </title> <type> Technical Report CS-TR-96-09, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [SC96], analyzing application performance <ref> [Rif96] </ref>, and reasoning about parallel 9 programs [Tho96, Mas97], but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [SC96] <author> P.A.G. Sivilotti and K.M. Chandy. </author> <title> Toward High Confidence Distributed Programming with Java: Reliable Thread Libraries. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages <ref> [SC96] </ref>, analyzing application performance [Rif96], and reasoning about parallel 9 programs [Tho96, Mas97], but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes. <p> We focus our discussion here on inter-process services. Methods for coordination within a process use standard Java classes <ref> [SC96] </ref>. The questions we address are: How can objects associated with a service be bound into a process in a straightforward way, and, what sorts of services are helpful for process designers? There are complementary ways of providing services to processes. <p> For example, Java provides constructs for synchronizing threads within a process by using something like a monitor [GYtJT96]. We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a process <ref> [SC96] </ref>. We are extending these designs to allow synchronizations between threads in different processes in different address spaces. 4 Finding Distributed Ob jects A collaborative application can require two kinds of searches: finding processes and finding process types. <p> We provide formally verified reliable libraries for synchronization between threads (e.g., single-assignment variables, reusable barriers, locks, and semaphores, as specified in <ref> [SC96] </ref>), and will be working on formally verified reliable libraries providing services for use in sessions (e.g., tokens, clocks, distributed data structures, and stack layering facilities, as specified in [CRS + 96]).
Reference: [Ste94] <author> W.R. Stevens. </author> <title> TCP/IP Illustrated, Volume 1: The Protocols. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java [GJS96], TCP/IP <ref> [Ste94] </ref>, and the World Wide Web [BLCGP92]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system.
Reference: [Tan95] <author> A.S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year>
Reference-contexts: Next, we give a brief discussion of some of the service support we have planned for sessions. Traditional distributed systems (e.g., <ref> [Tan95] </ref>) are architected in a series of well-defined layers, with each layer providing services to the layer above it and using services of the layer below. For instance, a distributed database application employs services (e.g., checkpointing, deadlock detection, and transaction abortion) of the distributed operating system on which it runs. <p> Our focus in this paper is on the former approach; we give a few examples of service objects and show how these services can be used within a process. Tokens and Capabilities. Distributed operating systems manage indivisible resources shared by processes <ref> [Tan95] </ref>; we would like to provide service objects with this functionality, which a process designer can incorporate as needed. A problem is that generic service objects do not have information about the specific resources used in a given application. A solution is to treat indivisible resources in a generic way. <p> The Web can also be used to locate the running programs themselves. 19 5 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems <ref> [Tan95] </ref>, distributed languages [BST89], and distributed algorithms [CM88, Lyn96]. Our programming model and theories of structured composition build on this research and recent work in formal methods [DS90, CT92, AL93, Cha94, Lam94, CS95].
Reference: [Tho96] <author> J. Thornley. </author> <title> A Parallel Programming Model with Sequential Semantics. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [SC96], analyzing application performance [Rif96], and reasoning about parallel 9 programs <ref> [Tho96, Mas97] </ref>, but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [Whi94] <author> J.E. White. </author> <title> Telescript Technology: The Foundation for the Electronic Marketplace. General Magic, </title> <publisher> Inc, </publisher> <year> 1994. </year> <month> 23 </month>
Reference-contexts: Obliq allows mobility of program code as well as the context in which the code operates; similarly, Telescript <ref> [Whi94] </ref> allows mobile agents that carry their context with them as they move from location to location. Whereas Obliq contexts can include established network connections, agents are self-contained and resource-limited: instead of communicating remotely with other locations, agents move themselves to a remote location site and communicate locally.
References-found: 32

