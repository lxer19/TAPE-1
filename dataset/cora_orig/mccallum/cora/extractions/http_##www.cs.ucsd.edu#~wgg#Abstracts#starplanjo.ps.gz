URL: http://www.cs.ucsd.edu/~wgg/Abstracts/starplanjo.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/starplanjo.html
Root-URL: http://www.cs.ucsd.edu
Email: fwgg,jdmg@cs.ucsd.edu  mchen@GDEsystems.com  bowdidge@watson.ibm.com  cabaniss@qualcomm.com  vnguyen@nuera.com  
Title: Tool Support for Planning the Restructuring of Data  
Note: This work supported in part by NSF Grants CCR-9211002 and CCR-9508745, a Hellman Faculty Fellowship, and UC MICRO grants 95-065 and 96-5449 with Hughes Aircraft.  
Address: La Jolla, CA 92093-0114  16250 Technology Dr. San Diego, CA 92127-1806  P.O. Box 704, Yorktown Heights NY 10598  6455 Lusk Boulevard San Diego, CA 92121  10445 Pacific Center Court San Diego, CA 92121  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  GDE Systems, Inc.  IBM T. J. Watson Research Center  Qualcomm Incorporated  -Nuera Communications, Inc.  
Abstract: ions in Large Systems fl Abstract Restructuring software to improve its design can lower software maintenance costs. One problem in restructuring is planning out the redesign. The star diagram manipulable visualization can help a programmer redesign a program based on abstract data types. However, the underlying meaning-preserving transformational support for restructuring is costly to provide. In particular, an efficient data flow analysis implementation is needed, and multi-language analysis and transformation is needed for any program written in multiple languages (a common practice in large projects). We also found that a star diagram view can be too large for a programmer to effectively assimilate and inflexible for a complicated restructuring, such as one involving complex types. To solve this problem we moved away from meaning-preserving transformational support and focused on helping programmers plan and carry out their restructurings. For example, we created a way of manipulating a star diagramcalled trimmingthat mimics the way that basic restructuring transformations affect the star diagram display, allowing a programmer to plan a restructuring without depending upon restructuring transformations. With the ability to annotate trimmed star diagram components, plans can be recorded and later recalled. Also, programmer-controlled elision can remove clutter from the star diagram view. We built a star diagram planning tool for C programs, measured its elision capabilities, and performed a programmer study for the encapsulation of a widely-used data structure in a 28,000 line program. We found that elision is effective in controlling star diagram size. In the study we found that each programming team successfully planned its restructuring in rather different, unanticipated ways. These experiments indirectly influenced important improvements in the tool's software design and user interface. 
Abstract-found: 1
Intro-found: 1
Reference: [Adams 80] <author> S. Adams. </author> <title> Pirate's adventure. </title> <journal> Byte, </journal> <volume> 5(12) </volume> <pages> 192-212, </pages> <month> December </month> <year> 1980. </year>
Reference-contexts: discuss the ability of other tools to record plans. 2 A Planning Scenario To provide a more detailed, dynamic perspective of the ideas introduced in the previous section, we present part of a session for planning the restructuring of a dungeon exploration game program written by Scott Adams called saadventure <ref> [Adams 80] </ref>. This version of saadventure is a 1,700 line C program (excluding comments and blank lines), although it was originally written in BASIC. The maintenance task. A major enhancement is planned for the rooms data structure, a global array of room descriptions.
Reference: [Atkinson & Griswold 96] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Implementing scalable data flow and alias analysis for semantic checking of meaning-preserving transformations is complicated, although possible <ref> [Atkinson & Griswold 96, Morgenthaler 97] </ref>. An even more severe challenge is that a large software system is likely implemented in multiple languages, requiring a comprehensive restructuring tool to provide support for multi-language data flow analysis and transformation.
Reference: [Ball & Eick 94] <author> T. Ball and S. G. Eick. </author> <title> Visualizing program slices. </title> <booktitle> In Proceedings of the IEEE Symposium on Visual Languages, </booktitle> <pages> pages 288-295, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The color of the pixels represents a value of a metric measured for that line, such as how recently the line was modified, whether a line is associated with a specific modification, or whether a given line is a member of a program slice <ref> [Weiser 84, Ball & Eick 94] </ref>. (Later enhancements to SeeSoft condense the view further by displaying one or more measurements per file, rather than per line.) Such visualizations can facilitate the planning of program modifications by highlighting historical or intrinsic structure that would be invisible otherwise.
Reference: [Belady & Lehman 71] <author> L. A. Belady and M. M. Lehman. </author> <title> Programming system dynamics or the metady-namics of systems in maintenance and growth. </title> <institution> Research Report RC3546, IBM, </institution> <year> 1971. </year> <note> Reprinted in M. </note> <editor> M. Lehman, L. A. Belady, editors, </editor> <title> Program Evolution: Processes of Software Change, Ch. </title> <booktitle> 5, APIC Studies in Data Processing No. </booktitle> <volume> 27. </volume> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Boehm documented an Air Force project in which the development cost was $30 per line, but the maintenance cost was $4,000 per line [Boehm 75]. Much of these costs can be attributed to degraded software structure <ref> [Belady & Lehman 71] </ref>. One way to lower software maintenance costs is to restructure the system into a more modular form while preserving the original functionality [Griswold 91, Opdyke 92, Griswold & Notkin 93, Johnson & Opdyke 93].
Reference: [Boehm 75] <author> B. W. Boehm. </author> <title> The high cost of software. </title> <editor> In E. Horowitz, editor, </editor> <booktitle> Practical Strategies for Developing Large Software Systems, </booktitle> <pages> pages 3-15. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: 1 Introduction Lientz and Swanson found that software maintenance can account for 70% of a software system's lifetime cost [Lientz & Swanson 80]. Boehm documented an Air Force project in which the development cost was $30 per line, but the maintenance cost was $4,000 per line <ref> [Boehm 75] </ref>. Much of these costs can be attributed to degraded software structure [Belady & Lehman 71].
Reference: [Bowdidge & Griswold 94] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Even with such support, a programmer must keep careful records in order to correctly perform the data encapsulation task. To address these problems we invented the star diagram, a graphical view of a data structure that can be used as a user interface to a meaning-preserving restructuring tool <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>.
Reference: [Bowdidge & Griswold 97] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> How software tools organize programmer behavior during the task of data encapsulation. Empirical Software Engineering, </title> ?(?), <note> To Appear 1997. </note>
Reference-contexts: In particular, its management and presentation of program information helped programmers perform their changes completely and consistently <ref> [Bowdidge & Griswold 97] </ref>. However, a few problems limit its usefulness on large systems. First, our examination of star diagrams for large C and MUMPS programs revealed that a star diagram for a widely used data structure can be unacceptably large. <p> However, the quick reversibility of these operations allows for flexible viewing strategies. 3 User Study Our earlier experience with programming tools taught us the importance of designing tools using knowledge of how programmers work <ref> [Bowdidge & Griswold 97] </ref>. Consequently, we undertook an exploratory systematic observational study [Weick 68] on the first star diagram planning tool prototype in order to guide the its continued design [Griswold et al. 96b].
Reference: [Bowdidge 95] <author> R. W. Bowdidge. </author> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD dissertation, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering, </institution> <month> November </month> <year> 1995. </year> <note> Technical Report CS95-457. </note>
Reference-contexts: Even with such support, a programmer must keep careful records in order to correctly perform the data encapsulation task. To address these problems we invented the star diagram, a graphical view of a data structure that can be used as a user interface to a meaning-preserving restructuring tool <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. <p> Shortcomings of the star diagram. The star diagram has proven to be useful in planning and carrying out small restructurings, and a detailed study of its usage showed that it can help programmers keep track of crucial information during the restructuring task <ref> [Bowdidge 95] </ref>. In particular, its management and presentation of program information helped programmers perform their changes completely and consistently [Bowdidge & Griswold 97]. However, a few problems limit its usefulness on large systems. <p> The study was designed to investigate the impact of the tool's planning functionality on programmer behavior when performing a restructuring to encapsulate a key data type. Three programming teams were observed. 3.1 Methodology Our study is modeled after Bowdidge's programmer study <ref> [Bowdidge 95] </ref>, which is based on Flor's laboratory studies of organization within programmer teams [Flor & Hutchins 91, Flor 94]. <p> We believe that viewing such a star diagram can be eased by laying out the first-level nodes according to their class of access, such as placing all structure field accesses together, placing all function calls together, and so forth <ref> [Bowdidge 95] </ref>. Additionally, programmer-controlled node-stacking criteria could increase node stackingsuch as stacking all printing operations togetherto produce more compact diagrams [Bowdidge 95, Chen 96]. 5 Software Design and Implementation Because the C star diagram planning tool is intended for use on large programs, scalability of performance is a major concern. <p> Additionally, programmer-controlled node-stacking criteria could increase node stackingsuch as stacking all printing operations togetherto produce more compact diagrams <ref> [Bowdidge 95, Chen 96] </ref>. 5 Software Design and Implementation Because the C star diagram planning tool is intended for use on large programs, scalability of performance is a major concern.
Reference: [Brighton 93] <author> A. </author> <note> Brighton. Tktree widget, Copyright 1993. Available by anonymous ftp at ftp.aud.alcatel.com/tcl/extensions/tree. </note>
Reference-contexts: Not only can such depth elision remove a significant number of nodes in a diagram, but it also allows for a more compact layout of the remaining nodes when using some off-the-shelf tree drawing algorithms. For example, the standard Tcl/Tk tree widget <ref> [Brighton 93] </ref> uses an algorithm that places the children of a 6 node as close together as possible [Moen 90], meaning that two siblings with many children will be placed far apart from each other. <p> To allow displaying the diagrams, a Tcl/Tk interface was added [Ousterhout 94], and the Brighton tree widget <ref> [Brighton 93] </ref> was adopted for representation and drawing of the star diagram. 4 At this point, there were two stages of star diagram constructionone in C++ called the internal star diagram and one in Tcl/Tk called the visualized star diagramintroducing some redundancy.
Reference: [Brothers 89] <author> L. Brothers. </author> <title> omega [A complex, rogue-like game of dungeon exploration], </title> <note> Copyright 1989. Available from: brothers@paul.rutgers.edu. </note>
Reference-contexts: We did not provide source listings in order to force the teams to inspect the code on the computer screen in view of the video camera. We gave the programmers the source code to a complex, rogue-like dungeon exploration game called omega <ref> [Brothers 89] </ref>. It consists of roughly 28,000 lines of C. To complicate the task slightly, we had modified the program to introduce some parameter passing of the Objects array.
Reference: [Brown 88] <author> C. M. Brown. </author> <title> Human-Computer Interface Design Guidelines. </title> <publisher> Ablex Publishing Corporation, </publisher> <address> Norwood, New Jersey, </address> <year> 1988. </year>
Reference-contexts: Inevitably, visibility would have to play a big role in our redesign, although we felt we could only achieve limited success due to the global understanding required to restructure complicated programs. The consistency principle: Things that are similar should look similar, and things that are different should look different <ref> [Brown 88, pp. 9, 21-24, 32, 101] </ref>[MacLennan 87]. <p> We expected that our programmer studies and subsequent interactions with users would play a role in helping us make these decisions. The clear and concise language principle: Names or images given to functions and displayed data should be easy to understand without cluttering the interface <ref> [Brown 88, pp. 21-24] </ref>. Our first interface was cluttered with obscure language such as elision and AST, and many programmers found these terms unfamiliar and intimidating.
Reference: [Cabaniss 97] <author> J. C. Cabaniss. </author> <title> Lessons learned from applying HCI techniques to the redesign of a user interface. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> June </month> <year> 1997. </year> <note> Technical Report CS97-548. </note>
Reference-contexts: forced to wait unexpectedly for the drawing of a small diagram. 6 User Interface Design Although our experiments on the first prototype yielded positive results in terms of how programmers exploited the basic functionality, we also observed a number of user interface problems that promoted frustration and other undesirable results <ref> [Cabaniss 97] </ref>. Most notably, as programmers progressed in their work, the number of windows on the screen grew, leading to confusion when trying to find an old window. Also, inconsistent placement and access to functionality in different windows caused delays.
Reference: [Carroll 91] <author> J. Carroll. </author> <title> Design Interaction: Psychology at the Human-Computer Interface. </title> <publisher> Ambridge University Press, </publisher> <address> New York, New York, </address> <year> 1991. </year>
Reference-contexts: Our first interface was cluttered with obscure language such as elision and AST, and many programmers found these terms unfamiliar and intimidating. The streamlined scenarios principle: Common patterns of work should be recognized and then streamlined so as to avoid awkward interactions such as repetitive clicking or keyboard entry <ref> [Carroll 91, pp. 293-5] </ref>. 5 Repetition leads to fatigue, mistakes, wasted time, and forgetting of key information. However, streamlining should not lead to an increase in the number of ways to carry out a task, which can confuse the user. <p> However, we found few obvious changes to be made and the interface had not been substantially improved. Also, we 5 A scenario is an account of a sequence of events involving people and artifacts that perhaps has been generalized or simplified to expose important issues <ref> [Carroll 91, p. 81] </ref>. 25 realized that even the simple change of fixing the window-closing functionality involved the complementary interaction of all four of the principles: the functionality was now always visible in a button, in a consistent location, with a clear, concise, and consistent name (for instance, dismiss does not
Reference: [Chen 96] <author> M. I. Chen. </author> <title> A tool for planning the restructuring of data abstractions in large systems. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> February </month> <year> 1996. </year> <note> Technical Report CS96-472. </note>
Reference-contexts: Additionally, programmer-controlled node-stacking criteria could increase node stackingsuch as stacking all printing operations togetherto produce more compact diagrams <ref> [Bowdidge 95, Chen 96] </ref>. 5 Software Design and Implementation Because the C star diagram planning tool is intended for use on large programs, scalability of performance is a major concern. <p> Adding type star diagrams and more elision choices could only make performance worse, since star diagrams could be bigger and the tweaking of elisions would increase. Consequently, we undertook a redesign of the software in order to improve performance. The first version of the tool <ref> [Chen 96, Griswold et al. 96b] </ref> was prototyped in stages, yielding a pipeline architecture (See Figure 18).
Reference: [Eick et al. 92] <author> S. C. Eick, J. L. Steffen, and J. E. E. Sumner. </author> <title> Seesofta tool for visualizing line-oriented software statistics. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(11) </volume> <pages> 957-68, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The SeeSoft system supports visualizing a property (such as age) of each line of a program as a colored graphical line, thus allowing a programmer to identify patterns between lines in multiple files by comparing colors <ref> [Eick et al. 92] </ref>. Each file of source code in a program is represented as a long box, and each line of code is represented by a horizontal line of pixels in the box.
Reference: [Flor & Hutchins 91] <author> N. V. Flor and E. L. Hutchins. </author> <title> Analyzing distributed cognition in software teams: A case study of team programming during perfective software maintenance. </title> <editor> In J. Koenemann-Belliveau, T. G. Moher, and S. P. Robertson, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Fourth Workshop, </booktitle> <pages> pages 36-64. </pages> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1991. </year>
Reference-contexts: Three programming teams were observed. 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's laboratory studies of organization within programmer teams <ref> [Flor & Hutchins 91, Flor 94] </ref>. Their approach of observing a pair of programmers working together, known as constructive interaction [Miyake 86, Wildman 95], is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods.
Reference: [Flor 94] <author> N. Flor. </author> <title> Dynamic Organization in Multi-Agent Distributed Cognitive Systems. </title> <type> PhD dissertation, </type> <institution> Cognitive Science Department, University of California, </institution> <address> San Diego, </address> <year> 1994. </year> <month> 33 </month>
Reference-contexts: Three programming teams were observed. 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's laboratory studies of organization within programmer teams <ref> [Flor & Hutchins 91, Flor 94] </ref>. Their approach of observing a pair of programmers working together, known as constructive interaction [Miyake 86, Wildman 95], is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods.
Reference: [Gentner & Grudin 96] <author> D. R. Gentner and J. Grudin. </author> <title> Design models for computer-human interaction. </title> <journal> IEEE Computer, </journal> <volume> 29(6) </volume> <pages> 28-35, </pages> <year> 1996. </year>
Reference-contexts: These observations made us aware that we had to have a unifying concept of how to apply the principles. 6.2 Unifying Design Rules At about this time, we came upon the concepts of the engineering model and the user model <ref> [Gentner & Grudin 96] </ref>. An engineering model represents the way that a system engineer conceptualizes and realizes a tool. Consequently, a tool interface based on this model provides direct access to the functionality inside a tool, which makes it ideal for testing and other tool construction activities.
Reference: [Griswold & Notkin 93] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 228-269, </pages> <month> July </month> <year> 1993. </year>
Reference: [Griswold 91] <author> W. G. Griswold. </author> <title> Program Restructuring as an Aid to Software Maintenance. </title> <type> PhD dissertation, </type> <institution> University of Washington, Dept. of Computer Science & Engineering, </institution> <month> August </month> <year> 1991. </year> <note> Technical Report No. 91-08-04. </note>
Reference: [Griswold et al. 96a] <author> W. G. Griswold, D. C. Atkinson, and C. McCurdy. </author> <title> Fast, flexible syntactic pattern matching and processing. </title> <booktitle> In Proceeedings of the IEEE 1996 Workshop on Program Comprehension, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: At the time same, to avoid the preprocessor problem as much as possible, we will be applying simple parser techniques to permit the representation of most macros in an AST <ref> [Griswold et al. 96a] </ref>. 8 Related Work Like many program visualization techniques, the star diagram attempts to graphically highlight relationships of interest for some task while hiding irrelevant details.
Reference: [Griswold et al. 96b] <author> W. G. Griswold, M. I. Chen, R. W. Bowdidge, and J. D. Morgenthaler. </author> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: 1.4 First Prototype, Experiments, and Redesign To gain insight on the ability of a tool employing these ideas to assist a programmer in understanding and changing a complex system, we implemented a star diagram planning tool for C programs and then performed a programmer study and a quantitative scalability study <ref> [Griswold et al. 96b] </ref>. This first prototype contained all of the above ideas, with the exception that elision was limited to depth elision and it was not possible to use the type of a variable to specify multiple roots. <p> Consequently, we undertook an exploratory systematic observational study [Weick 68] on the first star diagram planning tool prototype in order to guide the its continued design <ref> [Griswold et al. 96b] </ref>. The study was designed to investigate the impact of the tool's planning functionality on programmer behavior when performing a restructuring to encapsulate a key data type. <p> Adding type star diagrams and more elision choices could only make performance worse, since star diagrams could be bigger and the tweaking of elisions would increase. Consequently, we undertook a redesign of the software in order to improve performance. The first version of the tool <ref> [Chen 96, Griswold et al. 96b] </ref> was prototyped in stages, yielding a pipeline architecture (See Figure 18).
Reference: [Johnson & Opdyke 93] <author> R. E. Johnson and W. F. Opdyke. </author> <title> Refactoring and Aggregation. </title> <booktitle> In Object Technologies for Advanced Software, volume 742 of Lecture Notes in Computer Science, </booktitle> <pages> pages 264-278. </pages> <booktitle> First JSSST International Symposium, </booktitle> <month> November </month> <year> 1993. </year>
Reference: [Knight & Myers 93] <author> J. C. Knight and E. A. Myers. </author> <title> An improved inspection technique. </title> <journal> Communications of the ACM, </journal> <volume> 36(11) </volume> <pages> 51-61, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Such a tool could prove useful in planning complex restructurings regardless of whether the programmer performs the restructuring with an editor or with a restructuring tool. However, such support also could be used for activities other than restructuring. For example, a phased inspection <ref> [Knight & Myers 93] </ref> of data structure invariants could be facilitated by a star diagram view. If problems were detected in such an inspection, changes would be necessary, but they probably would not be restructuring changes.
Reference: [Lientz & Swanson 80] <author> B. Lientz and E. Swanson. </author> <title> Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Lientz and Swanson found that software maintenance can account for 70% of a software system's lifetime cost <ref> [Lientz & Swanson 80] </ref>. Boehm documented an Air Force project in which the development cost was $30 per line, but the maintenance cost was $4,000 per line [Boehm 75]. Much of these costs can be attributed to degraded software structure [Belady & Lehman 71].
Reference: [Liskov & Zilles 74] <author> B. Liskov and S. Zilles. </author> <title> Programming with abstract data types. </title> <booktitle> In ACM SIGPLAN Symposium on Very High Level Languages, </booktitle> <pages> pages 50-59, </pages> <month> March </month> <year> 1974. </year> <journal> SIGPLAN Notices 9(4). </journal>
Reference-contexts: By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost [Parnas 72]. Restructuring in order to achieve data encapsulation <ref> [Parnas 72, Liskov & Zilles 74] </ref> is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code.
Reference: [MacLennan 87] <author> B. J. MacLennan. </author> <booktitle> Principles of Programming Languages: Design, Evaluation, and Implementation. </booktitle> <publisher> Holt, Rinehart, and Winston, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference: [Miyake 86] <author> N. Miyake. </author> <title> Constructive interaction and the iterative process of understanding. </title> <journal> Cognitive Science, </journal> <volume> 10(2) </volume> <pages> 151-177, </pages> <year> 1986. </year>
Reference-contexts: Three programming teams were observed. 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's laboratory studies of organization within programmer teams [Flor & Hutchins 91, Flor 94]. Their approach of observing a pair of programmers working together, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods. Working dialogue also reveals how the programmers perform problem solving.
Reference: [Moen 90] <author> S. Moen. </author> <title> Drawing dynamic trees. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 21-8, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: For example, the standard Tcl/Tk tree widget [Brighton 93] uses an algorithm that places the children of a 6 node as close together as possible <ref> [Moen 90] </ref>, meaning that two siblings with many children will be placed far apart from each other. Eliding the children allows the siblings to be placed close together, making for a more compact layout that permits easier comparison of the siblings.
Reference: [Morgenthaler 97] <author> J. D. Morgenthaler. </author> <title> Static Analysis for a Software Transformation Tool. </title> <type> PhD dissertation, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: Implementing scalable data flow and alias analysis for semantic checking of meaning-preserving transformations is complicated, although possible <ref> [Atkinson & Griswold 96, Morgenthaler 97] </ref>. An even more severe challenge is that a large software system is likely implemented in multiple languages, requiring a comprehensive restructuring tool to provide support for multi-language data flow analysis and transformation.
Reference: [Muller et al. 92] <author> H. A. Muller, S. R. Tilley, M. A. Orgun, B. D. Corrie, and N. H. Madhavji. </author> <title> A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> In Proceedings of the SIGSOFT '92 Fifth Symposium on Software Development Environments, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, the Rigi reverse engineering environment provides semi-automatic construction of graphical views of a system to assist broad architectural understanding <ref> [Muller et al. 92] </ref>. A view based on entities such as functions, files, classes, or modules is initially constructed by the environment and then augmented by the programmer. The additions allow the programmer to describe the system in terms of abstractions not visible in the implementation.
Reference: [Nguyen 97] <author> V. B. Nguyen. </author> <title> Impact of adding customizability on software architecture: A case study. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> March </month> <year> 1997. </year> <note> Technical Report CS97-523. 34 </note>
Reference-contexts: On top of all this, we found programmers repeating simple actions such as selections in order to get real work done. Being aware that these problems would only get worse as larger tasks were undertaken and functionality was added to the tool <ref> [Nguyen 97] </ref>, we decided to redesign the original user interface using standard HCI principles. We identified four basic principles seemed most relevant to our application. 6.1 Basic Principles and Their Initial Application The visibility principle: Relevant data and functionality ought to be as visible as possible to a tool user. <p> In an earlier design the star diagram started out empty but the elision window was still a hidden pop-up <ref> [Nguyen 97] </ref>, which confused programmers.) Following the left-to-right, top-to-bottom ordering, the star diagram itself is next examined, and even the star diagram itself tends to be read left-to-right. Next is the trimmed nodes panel, which the programmer may now begin using as the star diagram becomes better understood.
Reference: [Opdyke 92] <author> W. F. Opdyke. </author> <title> Refactoring: A Program Restructuring Aid in Designing Object-Oriented Applications Frameworks. </title> <type> PhD dissertation, </type> <institution> University of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <year> 1992. </year> <note> Technical Report No. 1759. </note>
Reference: [Ousterhout 94] <author> J. K. Ousterhout, </author> <title> editor. Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: To allow displaying the diagrams, a Tcl/Tk interface was added <ref> [Ousterhout 94] </ref>, and the Brighton tree widget [Brighton 93] was adopted for representation and drawing of the star diagram. 4 At this point, there were two stages of star diagram constructionone in C++ called the internal star diagram and one in Tcl/Tk called the visualized star diagramintroducing some redundancy.
Reference: [Parnas 72] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost <ref> [Parnas 72] </ref>. Restructuring in order to achieve data encapsulation [Parnas 72, Liskov & Zilles 74] is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code. <p> By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost [Parnas 72]. Restructuring in order to achieve data encapsulation <ref> [Parnas 72, Liskov & Zilles 74] </ref> is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code.
Reference: [Preece 94] <author> J. Preece. </author> <title> Human Computer Interaction. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1994. </year>
Reference-contexts: This principle is predicated on the assumption that the human capacity for recognition is more powerful than recall <ref> [Preece 94, pp. 118-121] </ref>. Clearly, the programmers in our studies were suffering from severe visibility problems due to the proliferation of windows and hidden functionality.
Reference: [Stallman 93] <author> R. Stallman. </author> <title> GNU Emacs (The extensible self-documenting text editor). Free Software Foundation, </title> <address> Cambridge, MA., </address> <month> November </month> <year> 1993. </year> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: First, our examination of star diagrams for large C and MUMPS programs revealed that a star diagram for a widely used data structure can be unacceptably large. For example, a star diagram for all variables of type struct buffer in GNU Emacs 19.22 <ref> [Stallman 93] </ref> contained 3741 nodes and was 246 inches high when printed on paper. Such a star diagram is time-consuming for a programmer to assimilate while comprehensively planning a restructuring. <p> For this experiment, we used the second prototype, which includes the more general property-based elision mechanism. For these measurements we used ubiquitous data structures in omega (See the previous Section) and temacs, the terminal-based version of GNU Emacs version 19.34 <ref> [Stallman 93] </ref>, which contains 78,000 lines of actual C code. The primary concern about the size of star diagrams is the effort required to assimilate a star diagram. Two influential factors are the volume of information in a star diagram and how much scrolling is required to view this information.
Reference: [Weick 68] <author> K. E. Weick. </author> <title> Systematic observational methods. </title> <editor> In G. Lindzey and E. Aronson, editors, </editor> <booktitle> The Handbook of Social Psychology, </booktitle> <pages> pages 357-451. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference-contexts: However, the quick reversibility of these operations allows for flexible viewing strategies. 3 User Study Our earlier experience with programming tools taught us the importance of designing tools using knowledge of how programmers work [Bowdidge & Griswold 97]. Consequently, we undertook an exploratory systematic observational study <ref> [Weick 68] </ref> on the first star diagram planning tool prototype in order to guide the its continued design [Griswold et al. 96b]. The study was designed to investigate the impact of the tool's planning functionality on programmer behavior when performing a restructuring to encapsulate a key data type.
Reference: [Weiser 84] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: The color of the pixels represents a value of a metric measured for that line, such as how recently the line was modified, whether a line is associated with a specific modification, or whether a given line is a member of a program slice <ref> [Weiser 84, Ball & Eick 94] </ref>. (Later enhancements to SeeSoft condense the view further by displaying one or more measurements per file, rather than per line.) Such visualizations can facilitate the planning of program modifications by highlighting historical or intrinsic structure that would be invisible otherwise.
Reference: [Wildman 95] <author> D. Wildman. </author> <title> Getting the most from paired-user testing. </title> <journal> ACM Interactions, </journal> <volume> 2(3) </volume> <pages> 21-27, </pages> <year> 1995. </year>
Reference-contexts: Three programming teams were observed. 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's laboratory studies of organization within programmer teams [Flor & Hutchins 91, Flor 94]. Their approach of observing a pair of programmers working together, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods. Working dialogue also reveals how the programmers perform problem solving.
References-found: 40

