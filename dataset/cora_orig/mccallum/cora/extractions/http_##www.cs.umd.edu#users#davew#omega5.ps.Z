URL: http://www.cs.umd.edu/users/davew/omega5.ps.Z
Refering-URL: http://www.cs.umd.edu/users/davew/pubs.html
Root-URL: 
Email: pugh@cs.umd.edu,  davew@cs.umd.edu,  
Phone: (301) 405-2705  (301) 405-2726  
Title: extended abstract Nonlinear Array Dependence Analysis  
Author: William Pugh David Wonnacott 
Date: November 15, 1994  
Address: College Park, MD 20742  
Affiliation: Dept. of Computer Science Univ. of Maryland,  
Abstract: Standard array data dependence techniques can only reason about linear constraints. There has also been work on analyzing some dependences involving polynomial constraints. Analyzing array data dependences in real-world programs requires handling many "unanalyzable" terms: subscript arrays, run-time tests, function calls. The standard approach to analyzing such programs has been to omit and ignore any constraints that cannot be reasoned about. This is unsound when reasoning about value-based dependences and whether privatization is legal. Also, this prevents us from determining the conditions that must be true to disprove the dependence. These conditions could be checked by a run-time test or verified by a programmer or aggressive, demand-driven interprocedural analysis. We describe a solution to these problems. Our solution makes our system sound and more accurate for analyzing value-based dependences and derives conditions that can be used to disprove dependences. We also give some preliminary results from applying our techniques to programs from the Perfect benchmark suite. 
Abstract-found: 1
Intro-found: 1
Reference: [AWZ88] <author> B. Alpern, M. N. Wegman, and F. K. Zadeck. </author> <title> Detecting equality of values in programs. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: To summarize, we determine the level at which an expression is loop variant, and create a function symbol with as few arguments as possible. We identify syntactically distinct expressions that should be represented with the same function symbol by an adaptation of global value numbering <ref> [AWZ88, RWZ88] </ref>.
Reference: [B + 89] <author> M. Berry et al. </author> <title> The PERFECT Club benchmarks: Effective performance evaluation of supercomputers. </title> <journal> International Journal of Supercomputing Applications, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> March </month> <year> 1989. </year>
Reference: [BE94] <author> William Blume and Rudolf Eigenmann. </author> <title> Symbolic analysis techniques needed for effective parallelization of the Perfect benchmarks. </title> <type> Technical Report 1332, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <year> 1994. </year>
Reference-contexts: time measured in minutes, hours, or days). 6 Real world examples In this section, we describe the results of applying the techniques describes here to a number of loops from the Perfect club that have been identified by other researchers as being parallel but not made parallel by current compilers <ref> [EHLP91, BE94, BEH + 94, RP94] </ref>. MDG INTERF 1000 (Example 12) The difficult issue in the analysis of this program is proving that the rl array can be privatized. <p> Our techniques provide information that is useful in determining that some code from the Perfect Club Benchmark programs can be run in parallel. This information is not provided by standard analysis techniques. Some of this information might be derived by advanced interprocedural analysis techniques <ref> [BE94] </ref>, but it may be more efficient to derive such information in a demand-driven way, rather than trying to derive all interprocedural information that can be proven.
Reference: [BEH + 94] <author> William Blume, Rudolf Eigenmann, Jay Hoeflinger, David Padua, Lawrence Rauchwerger, and Peng Tu. </author> <title> Automatic detection of parallelism: A grand challenge for high-performance computing. </title> <type> Technical Report 1349, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <year> 1994. </year>
Reference-contexts: time measured in minutes, hours, or days). 6 Real world examples In this section, we describe the results of applying the techniques describes here to a number of loops from the Perfect club that have been identified by other researchers as being parallel but not made parallel by current compilers <ref> [EHLP91, BE94, BEH + 94, RP94] </ref>. MDG INTERF 1000 (Example 12) The difficult issue in the analysis of this program is proving that the rl array can be privatized.
Reference: [CF94] <author> Jean-Fran~cois Collard and Paul Feautrier. </author> <title> Fuzzy array dataflow analysis. </title> <type> Technical Report Research Report N o 94-21, </type> <institution> Laboratoire de l'Informatique du Parallelisme, Ecolo Normal Superieure de Lyon, Instiut IMAG, </institution> <month> July </month> <year> 1994. </year> <note> Postscript available as lip.ens-lyon.fr:pub/LIP/RR/RR94/RR94-21.ps.Z. </note>
Reference-contexts: We believe that the most significant distinction between our work and <ref> [CF94] </ref> is our ability to relate the nonlinear terms in our dependence relations to expressions in the program, and thus discuss the program with some external agent (such as the programmer), as described in Section 4. The techniques described in [CF94] produce information about the possible sources of a value that <p> believe that the most significant distinction between our work and <ref> [CF94] </ref> is our ability to relate the nonlinear terms in our dependence relations to expressions in the program, and thus discuss the program with some external agent (such as the programmer), as described in Section 4. The techniques described in [CF94] produce information about the possible sources of a value that is read from an array, but do not provide information about which expressions in the program control which source actually produces the value.
Reference: [Coo72] <author> D. C. Cooper. </author> <title> Theorem proving in arithmetic with multiplication. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 7, </booktitle> <pages> pages 91-99. </pages> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1972. </year>
Reference: [Dow72] <author> P. Downey. </author> <title> Undeciability of presburger arithmetic with a single monadic predicate letter. </title> <type> Technical Report 18-72, </type> <institution> Center for Research in Computing Technology, Havard Univ., </institution> <year> 1972. </year>
Reference: [EHLP91] <author> R. Eigenmann, J. Hoeflinger, Z. Li, and D. Padua. </author> <title> Experience in the automatic parallelization of 4 Perfect benchmark programs. </title> <booktitle> In Proc. of the 4th Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: time measured in minutes, hours, or days). 6 Real world examples In this section, we describe the results of applying the techniques describes here to a number of loops from the Perfect club that have been identified by other researchers as being parallel but not made parallel by current compilers <ref> [EHLP91, BE94, BEH + 94, RP94] </ref>. MDG INTERF 1000 (Example 12) The difficult issue in the analysis of this program is proving that the rl array can be privatized.
Reference: [Fea88] <author> Paul Feautrier. </author> <title> Array expansion. </title> <booktitle> In ACM Int. Conf. on Supercomputing, St Malo, </booktitle> <pages> pages 429-441, </pages> <year> 1988. </year>
Reference-contexts: For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences <ref> [Fea88, PW92, PW93a, PW93b, Mas94] </ref>, in which there are no intervening writes. In our approach [PW93a], we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freemand and Company, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction Standard algorithms for determining if two array references are aliased (i.e., might refer to the same memory location) are posed in terms of checking to see if a set of linear constraints has an integer solution. This problem is NP-Complete <ref> [GJ79] </ref>. Both approximate and exact algorithms have been proposed for solving this problem. Unfortunately, many array dependence problems cannot be exactly translated into linear constraints, such as Example 1.
Reference: [KK67] <author> G. Kreisel and J. L. Krevine. </author> <title> Elements of Mathematical Logic. </title> <publisher> North-Holland Pub. Co., </publisher> <year> 1967. </year>
Reference: [Mas94] <author> Vadim Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In ACM '94 Conf. on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences <ref> [Fea88, PW92, PW93a, PW93b, Mas94] </ref>, in which there are no intervening writes. In our approach [PW93a], we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write.
Reference: [Opp78] <author> D. Oppen. </author> <title> A 2 2 2 pn upper bound on the complexity of presburger arithmetic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(3) </volume> <pages> 323-332, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: There are a number of algorithms for testing the satisfiability of arbitrary Presburger formulas ([KK67, Coo72, PW93a]). This problem appears to have worst-case complexity of 2 2 2 O (n) <ref> [Opp78] </ref>. We formulate value-based array data dependence in terms of (simple) Presburger formulas, with only two nested alternating quantifiers. Memory based array data dependence can be formulated in terms of even simpler Presburger formulas, with only a single quantifier.
Reference: [Pug92] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference: [PW92] <author> William Pugh and David Wonnacott. </author> <title> Eliminating false data dependences using the Omega test. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 140-151, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: : f [i; j 0 ] ! [i 0 ; j 0 ] j 1 i &lt; i 0 n ^ 1 j; j 0 p ^ i = i 0 x ^ j = j 0 g Since all the terms are affine, we can use techniques described in <ref> [PW92] </ref> to compute the conditions on symbolic constants (x; n and p) that must be true in order for a flow dependence to exist: 1 x &lt; n ^ 1 p Once we compute these conditions, we might use more powerful analysis techniques to see if they can be disproved, allow <p> As described in <ref> [PW92] </ref>, we can eliminate the test 1 p as uninteresting. If a program contains non-linear expressions and we simply omit the corresponding non-linear constraints from the dependence problem, we will be unable to accurately compute necessary and sufficient conditions for the dependence to exist. <p> For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences <ref> [Fea88, PW92, PW93a, PW93b, Mas94] </ref>, in which there are no intervening writes. In our approach [PW93a], we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write.
Reference: [PW93a] <author> William Pugh and David Wonnacott. </author> <title> An evaluation of exact methods for analysis of value-based array data dependences. </title> <booktitle> In Sixth Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences <ref> [Fea88, PW92, PW93a, PW93b, Mas94] </ref>, in which there are no intervening writes. In our approach [PW93a], we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write. <p> For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences [Fea88, PW92, PW93a, PW93b, Mas94], in which there are no intervening writes. In our approach <ref> [PW93a] </ref>, we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write. <p> Memory based array data dependence can be formulated in terms of even simpler Presburger formulas, with only a single quantifier. Fortunately, the formulas we generate for array dependence analysis of real programs can be solved quite efficiently <ref> [PW93a] </ref>. Presburger arithmetic can be extended to allow uninterpreted function symbols: terms representing the application of a function to a list of argument terms.
Reference: [PW93b] <author> William Pugh and David Wonnacott. </author> <title> Static analysis of upper and lower bounds on dependences and parallelism. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1993. accepted for publication. </note>
Reference-contexts: For a number of program optimizations and transformations, it is desirable to also compute "value-based" dependences <ref> [Fea88, PW92, PW93a, PW93b, Mas94] </ref>, in which there are no intervening writes. In our approach [PW93a], we start with a set of constraints describing the iterations that are aliased and then subtract out the pairs clobbered by an intervening write.
Reference: [RP94] <author> Lawrence Rauchwerger and David Padua. </author> <title> The privatizing doall test: A run-time technique for doall loop identification and array privatization. </title> <type> Technical Report 1383, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <year> 1994. </year>
Reference-contexts: time measured in minutes, hours, or days). 6 Real world examples In this section, we describe the results of applying the techniques describes here to a number of loops from the Perfect club that have been identified by other researchers as being parallel but not made parallel by current compilers <ref> [EHLP91, BE94, BEH + 94, RP94] </ref>. MDG INTERF 1000 (Example 12) The difficult issue in the analysis of this program is proving that the rl array can be privatized.
Reference: [RWZ88] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 12-27, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: To summarize, we determine the level at which an expression is loop variant, and create a function symbol with as few arguments as possible. We identify syntactically distinct expressions that should be represented with the same function symbol by an adaptation of global value numbering <ref> [AWZ88, RWZ88] </ref>.
Reference: [Sho79] <author> Robert E. Shostak. </author> <title> A practical decision procedure for arithmetic with function symbols. </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 351-360, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: It is possible to apply the techniques described in <ref> [Sho79] </ref> to the formula in this relation, but these techniques simply test for satisfiability; we need to subtract this relation from the relation giving memory-based dependences. Note that we can compose the loop-independent flow dependence with the loop-carried output dependence.
Reference: [SW94] <author> Eric Stoltz and Michael Wolfe. </author> <title> Detecting value-based scalar dependence. </title> <booktitle> In Proc. of the Seventh Annual Workshop on Languages and Compilers for Parallel Computing. </booktitle> <institution> Cornell University, </institution> <month> August </month> <year> 1994. </year> <month> 11 </month>
References-found: 21

