URL: http://www.cs.umn.edu/Users/dept/users/riedl/CS-8103/Papers/Chorus/CS-TR-92-80.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/riedl/CS-8103/Papers/Chorus/
Root-URL: http://www.cs.umn.edu
Title: CS/TR-92-80 The COOL architecture and abstractions for object-oriented distributed operating systems  
Author: Rodger Lea, Christian Jacquemot 
Degree: approved by:  
Note: c Chorus systemes,  
Date: distribution: COOL  1992 September 21, 1992  
Abstract: Building distributed operating systems benefits from the micro-kernel approach by allowing better support for modularization. However, we believe that we need to take this support a step further. A more modular, or object oriented approach is needed if we wish to cross the barrier of complexity that is holding back distributed operating system development. The Chorus Ob ject Oriented Layer (COOL) is a layer built above the Chorus micro-kernel designed to extend the micro-kernel abstractions with support for object oriented systems. COOL v2, the second iteration of this layer provides generic support for clusters of objects, in a distributed virtual memory model. It is built as a layered system where the lowest layer support only clusters and the upper layers support objects. c fl Chorus systemes, 1992
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Marc Rozier, Vadim Abrossimov, Francois Armand, Ivan Boule, Michel Gien, Marc Guille-mont, Frederic Herrmann, Claude Kaiser, Sylvain Langlois, </author> <title> Pierre Leonard, </title> <journal> Will Neuhauser CHORUS Distributed Operating Systems Computing Systems Journal, </journal> <volume> Vol 1,No 4, </volume> <month> December </month> <year> 1988, </year> <institution> USENIX Association </institution>
Reference-contexts: It has the interface of a set of system calls and encapsulates the CHORUS micro-kernel <ref> [1] </ref>.
Reference: [2] <author> Sabine Habert, Laurence Mosseri, and Vadim Abrossimov. </author> <title> COOL: Kernel support for object-oriented environments. </title> <booktitle> In ECOOP/ OOPSLA'90 Conference, volume 25 of SIGPLAN Notices, </booktitle> <pages> pages 269-277, </pages> <address> Ottawa (Canada), </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: persistent Bus or network Language specific run-time C++ Eiffel Language specific run-time other Language specific run-time Application level 2 COOL v2 The COOL project is now in its second iteration, our first platform, COOL v1 2 , was designed as a testbed for initial ideas and implemented in late '88 <ref> [2] </ref> [3] [6] [7]. Our early work with COOL (COOL v1) consisted with experimentation in the way that systems could be built using the object oriented model, and how this supported distributed applications.
Reference: [3] <author> Deshayes, J.M., Abrossimov, V. and Lea, R. </author> <title> The CIDRE distributed object system based on Chorus. </title> <booktitle> Proceedings of the TOOLS'89 Conference, </booktitle> <address> Paris, France. </address> <month> July </month> <year> 1989. </year>
Reference-contexts: Bus or network Language specific run-time C++ Eiffel Language specific run-time other Language specific run-time Application level 2 COOL v2 The COOL project is now in its second iteration, our first platform, COOL v1 2 , was designed as a testbed for initial ideas and implemented in late '88 [2] <ref> [3] </ref> [6] [7]. Our early work with COOL (COOL v1) consisted with experimentation in the way that systems could be built using the object oriented model, and how this supported distributed applications.
Reference: [4] <institution> The Integrated Systems Architecture project. ISA Esprit project 2267. The ISA consortium, APM ltd, </institution> <address> Castle Park, Cambridge, UK. </address>
Reference-contexts: This work was carried out in conjunction with two European research projects, both building distributed object based systems, the Esprit ISA project <ref> [4] </ref> and the Esprit Comandos project [5].
Reference: [5] <author> Vinny Cahill, Rodger Lea and Pedro Sousa. Comandos: </author> <title> generic support for persistent object oriented languages. </title> <booktitle> Proceedings of the Esprit Conference 1991. </booktitle> <address> Brussels, </address> <month> November </month> <year> 1991. </year> <note> also Chorus systemes technical report CS-TR-91-56. </note>
Reference-contexts: This work was carried out in conjunction with two European research projects, both building distributed object based systems, the Esprit ISA project [4] and the Esprit Comandos project <ref> [5] </ref>.
Reference: [6] <author> Lea, R. and Weightman, J., </author> <title> COOL: An object support environment co-existing with Unix. </title> <booktitle> Proceedings of Convention Unix '91, </booktitle> <address> AFUU, Paris France. </address> <month> March </month> <year> 1991. </year>
Reference-contexts: or network Language specific run-time C++ Eiffel Language specific run-time other Language specific run-time Application level 2 COOL v2 The COOL project is now in its second iteration, our first platform, COOL v1 2 , was designed as a testbed for initial ideas and implemented in late '88 [2] [3] <ref> [6] </ref> [7]. Our early work with COOL (COOL v1) consisted with experimentation in the way that systems could be built using the object oriented model, and how this supported distributed applications.
Reference: [7] <author> Lea, R. and Weightman, J. </author> <title> Supporting Object Oriented Languages in a Distributed Environment: The COOL approach. </title> <booktitle> Proceedings of TOOLS USA'91, </booktitle> <address> July 29-August 1, 1991. Santa Barbara, CA. USA. </address>
Reference-contexts: network Language specific run-time C++ Eiffel Language specific run-time other Language specific run-time Application level 2 COOL v2 The COOL project is now in its second iteration, our first platform, COOL v1 2 , was designed as a testbed for initial ideas and implemented in late '88 [2] [3] [6] <ref> [7] </ref>. Our early work with COOL (COOL v1) consisted with experimentation in the way that systems could be built using the object oriented model, and how this supported distributed applications.
Reference: [8] <author> Abrossimov, V., Rozier, M. and Shapiro, M., </author> <title> Generic virtual memory management for operating system kernels. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 123-136, </pages> <address> Litchfield Park AZ (USA), </address> <month> December </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: A cluster is viewed from higher levels as a place where related objects exist. When mapped into an address space, it is simply a collection of virtual memory regions <ref> [8] </ref>. The mapping can be done on an arbitrary address. The collection of regions that belong to a mapped cluster is a set of CHORUS regions backed by segments, and forms a semantic unit managed by the base layer.
Reference: [9] <author> Campbell, R. H. and Madany, P. W. </author> <title> Considerations of Persistence and Security in Choices, an Object-Oriented Operating System. Procs. </title> <booktitle> of International Workshop on Computer Architectures to Support Security and Persistence of Information. </booktitle> <month> May </month> <year> 1990, </year> <institution> Bremen (Germany). c fl Chorus systemes, </institution> <year> 1992 </year> <month> -8- September 21, </month> <title> 1992 Chorus systemes The COOL architecture and abstractions CS/TR-92-80 </title>
Reference-contexts: Thus for example, elements of the generic run-time are built using objects who interact using serv&lt;ices provided by the core of the run-time. Some aspects of this are similar to work carried out in <ref> [9] </ref>. However, Choices concentrates more on the functional objects that make up the operating system and their relationship at build time. Our emphasis is how those objects are supported and interact at run-time.
Reference: [10] <author> Jeffrey S. Chase, Franz G. Amador, Edward D. Lazowska, Henry M. Levy, and Richard J. </author> <title> Littlefield The Amber System: </title> <booktitle> Parallel Programming on a Network of Multiprocessors ACM SIGOPS, </booktitle> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989 </year>
Reference-contexts: When a machine exhausts this initial space, it must arbitrate with others to allocate space from a common pool as is done in <ref> [10] </ref>. 4.2 Single invocation model The base level abstractions include an invocation mechanism that works between clusters. Invocation falls into one of three cases. Local invocation, ie that which stays within an address space.
Reference: [11] <author> Partha Dasgupta, R Ananthanarayanan, Sathis Menon, Ajay Mohindra, </author> <title> Raymond Chen Distributed Programming with objects and Threads in the Clouds System Computing Systems, </title> <booktitle> Vol 4, </booktitle> <volume> No 3, </volume> <booktitle> Summer 1991, USENIX Association </booktitle>
Reference-contexts: In addition, because clusters are persistent, the COOL-base provides a mechanism to locate non-active clusters, i.e., clusters currently swapped-out on secondary storage and load them transparently into a cluster spaces. This model is similar to work described in <ref> [11] </ref>. The mapper is used to store and retrieve passive clusters to and from secondary storage. Therefore, the COOL-base level supports a single-level, persistent cluster store with synchronous and asynchronous invocation between clusters, and distributed cluster sharing. 3.2 The COOL generic run-time The generic run-time implements a notion of objects.
Reference: [12] <editor> March Shapiro Structure and Encapsulation in Distributed Systems: </editor> <booktitle> the Proxy Principle Proceedings of the 6th ICDS Conference, </booktitle> <address> May 86 c fl Chorus systemes, </address> <year> 1992 </year> <month> -9- September 21, </month> <year> 1992 </year>
Reference-contexts: The generic run-time defines the primitives to convert one type of reference to the other one. When a domain wide reference to a remote object is converted to language reference a proxy associated to the object is created <ref> [12] </ref>. This proxy is used to transparently invoke the remote object. Objects are always created in clusters.
References-found: 12

