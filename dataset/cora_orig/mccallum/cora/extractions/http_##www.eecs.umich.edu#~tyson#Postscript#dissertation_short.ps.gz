URL: http://www.eecs.umich.edu/~tyson/Postscript/dissertation_short.ps.gz
Refering-URL: http://www.eecs.umich.edu/~tyson/publications.html
Root-URL: http://www.cs.umich.edu
Title: Evaluation of a Scalable Decoupled Microprocessor Design following exceptions: Modification of title page. Removal of
Author: By GARY SCOTT TYSON 
Degree: DISSERTATION submitted in partial satisfaction of the requirements for the degree of DOCTOR OF PHILOSOPHY in Computer Science in the GRADUATE DIVISION of the  
Note: This is a reformated version of the dissertation to reduce the number of pages required to print it from 238 to 104. It is unchanged from the original with the  from 76 pages to 1 page.  
Date: 1986  1988  
Address: Sacramento)  Sacramento)  DAVIS  
Affiliation: B.S. (California State University,  M.S. (California State University,  UNIVERSITY OF CALIFORNIA  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Brian Moore, Andris Padegs, Ron Smith and Werner Buchholz, </author> <booktitle> Concepts of the System/370 Vector Architecture, Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <year> (1987) </year> <month> 282-288. </month>
Reference-contexts: Some tasks contain data manipulations that are completely independent from one another. These tasks can be thought of as containing explicit parallelism that can be exploited regardless of the programming model employed. Many architectures exist which exploit data parallelism, including vector processors <ref> [1] </ref>, Single Instruction Multiple Data (SIMD) [2] designs, Multiple Instruction Multiple Data (MIMD) [3] designs, and dataflow machines [4]. <p> This leads to a schedule that utilizes the full capabilities of the target architecture. This schedule is shown in Figure 4.6. Chapter 4: Design of the MISC Compiler 48 <ref> [1] </ref> t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC <p> Figures 4.7 and 4.8 show the results of partitioning the intermediate code of the InnerProduct () and LinkedList () examples. Each line in the figures contains an enumeration (e.g. <ref> [1] </ref>), a group placement identifier and an RTL statement. The enumeration is used in the text to specify a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = <p> Each line in the figures contains an enumeration (e.g. <ref> [1] </ref>), a group placement identifier and an RTL statement. The enumeration is used in the text to specify a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; <p> Finally, since no groups can be assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines [2] through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code <ref> [1] </ref> t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must <p> This would allow those latencies to be subsumed by the partitioning process (and the slip [52] between the asynchronous PEs). Table 4.3 shows the results of DAE partitioning on the benchmark suite. The Chapter 4: Design of the MISC Compiler 51 <ref> [1] </ref> FREE t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] <p> None of the applications require more than two PEs because there are 6 Note that this is not an optimal schedule, but does provide the same level of performance as schedules involving more PEs using the algorithms described in this dissertation. Chapter 4: Design of the MISC Compiler 52 <ref> [1] </ref> CONTROL t1 = head ; list=head [2] CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 <ref> [1] </ref> FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 <p> Two scientific applications, KMP and sobel, show excellent results using group partitioning. Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 <ref> [1] </ref> CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] <p> This is a difficult task for the hardware to perform; however, it is vital to release the compiler from the tremendous restriction of scheduling in the presence of frequent function calls. Chapter 4: Design of the MISC Compiler 58 <ref> [1] </ref> CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] <p> Furthermore, all loop instructions (VLOOP and SLOOP) are examined to determine the number of instructions in the delay slots; if only one instruction is iterated in the loop, Chapter 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code <ref> [1] </ref> t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8
Reference: [2] <author> Mehrad Yasrebi and G. J. Lipovski, </author> <title> A State-of-the-Art SIMD Two-Dimensional FFT Array Processor, </title> <booktitle> Proceedings of the 11th Annual International Symposium on Computer Architecture, </booktitle> <year> (1984) </year> <month> 21-27. </month>
Reference-contexts: Some tasks contain data manipulations that are completely independent from one another. These tasks can be thought of as containing explicit parallelism that can be exploited regardless of the programming model employed. Many architectures exist which exploit data parallelism, including vector processors [1], Single Instruction Multiple Data (SIMD) <ref> [2] </ref> designs, Multiple Instruction Multiple Data (MIMD) [3] designs, and dataflow machines [4]. <p> Each line in the figures contains an enumeration (e.g. [1]), a group placement identifier and an RTL statement. The enumeration is used in the text to specify a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head <ref> [2] </ref> t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = <p> Line [13] is also included because it calculates the loop iterator (k++). Finally, since no groups can be assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines <ref> [2] </ref> through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 <p> This would allow those latencies to be subsumed by the partitioning process (and the slip [52] between the asynchronous PEs). Table 4.3 shows the results of DAE partitioning on the benchmark suite. The Chapter 4: Design of the MISC Compiler 51 [1] FREE t1 = 0 ; q=0 <ref> [2] </ref> CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; <p> Chapter 4: Design of the MISC Compiler 52 [1] CONTROL t1 = head ; list=head <ref> [2] </ref> CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 <p> In fact, CONTROL partitioning is able to perform an optimal partitioning in this particular example. For this reason, it will be omitted throughout the remainder of the partitioning approaches. As mentioned earlier, the LinkedList () example (Figure 4.10) shows little improvement in partitioning; only lines <ref> [2] </ref> and [13] could be relocated to the FREE group. The memory reference at line [10] returns data later used in a branch calculation, which forces the placement of that operation in the control group 7 . <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 <ref> [2] </ref> CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] <p> Two scientific applications, KMP and sobel, show excellent results using group partitioning. Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head <ref> [2] </ref> CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) <p> This is a difficult task for the hardware to perform; however, it is vital to release the compiler from the tremendous restriction of scheduling in the presence of frequent function calls. Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head <ref> [2] </ref> FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5)
Reference: [3] <author> Toshio Kondom, Toshio Tsuchiya, Yoshihiro Kitamura, Yoshi Sugiyama, Takashi Kimura and Takayoshi Nakashima, </author> <title> Pseudo MIMD Array Processor | AAP2, </title> <booktitle> Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <year> (1986) </year> <month> 330-337. </month>
Reference-contexts: These tasks can be thought of as containing explicit parallelism that can be exploited regardless of the programming model employed. Many architectures exist which exploit data parallelism, including vector processors [1], Single Instruction Multiple Data (SIMD) [2] designs, Multiple Instruction Multiple Data (MIMD) <ref> [3] </ref> designs, and dataflow machines [4]. <p> This leads to a schedule that utilizes the full capabilities of the target architecture. This schedule is shown in Figure 4.6. Chapter 4: Design of the MISC Compiler 48 [1] t1 = 0 ; q=0 <ref> [3] </ref> t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if <p> The enumeration is used in the text to specify a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list <ref> [3] </ref> t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, <p> Finally, since no groups can be assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines [2] through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 <ref> [3] </ref> t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to <p> Table 4.3 shows the results of DAE partitioning on the benchmark suite. The Chapter 4: Design of the MISC Compiler 51 [1] FREE t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 <ref> [3] </ref> CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = <p> Chapter 4: Design of the MISC Compiler 52 [1] CONTROL t1 = head ; list=head [2] CONTROL t2 = 4 ; calc z offset from list <ref> [3] </ref> CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 <ref> [3] </ref> CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 <p> Two scientific applications, KMP and sobel, show excellent results using group partitioning. Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 <ref> [3] </ref> CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, <p> This is a difficult task for the hardware to perform; however, it is vital to release the compiler from the tremendous restriction of scheduling in the presence of frequent function calls. Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 <ref> [3] </ref> FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, <p> Furthermore, all loop instructions (VLOOP and SLOOP) are examined to determine the number of instructions in the delay slots; if only one instruction is iterated in the loop, Chapter 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 <ref> [3] </ref> t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2:
Reference: [4] <editor> Guang R. Gao, Lubomir Bic and Jean-Luc Gaudiot, </editor> <title> Advanced Topics in Dataflow Computing and Multithreading, </title> <publisher> IEEE Computer Society Press, </publisher> <year> (1995). </year>
Reference-contexts: These tasks can be thought of as containing explicit parallelism that can be exploited regardless of the programming model employed. Many architectures exist which exploit data parallelism, including vector processors [1], Single Instruction Multiple Data (SIMD) [2] designs, Multiple Instruction Multiple Data (MIMD) [3] designs, and dataflow machines <ref> [4] </ref>. The key difference between instruction level parallelism and data parallelism is the difference in locality of the dependencies between adjacent instructions; instruction level parallelism exists when instructions are independent from some adjacent instructions but may have dependencies with others that are close in the execution stream. <p> This leads to a schedule that utilizes the full capabilities of the target architecture. This schedule is shown in Figure 4.6. Chapter 4: Design of the MISC Compiler 48 [1] t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test <ref> [4] </ref> t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; <p> The enumeration is used in the text to specify a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list <ref> [4] </ref> t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M <p> Table 4.3 shows the results of DAE partitioning on the benchmark suite. The Chapter 4: Design of the MISC Compiler 51 [1] FREE t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test <ref> [4] </ref> CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = <p> Chapter 4: Design of the MISC Compiler 52 [1] CONTROL t1 = head ; list=head [2] CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list <ref> [4] </ref> CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true <p> eqntott 82 18 6 1 espresso 92 8 2 1 gcc 56 44 9 2 xlisp 81 19 4 2 sc 52 48 8 3 povray 74 26 4 2 sobel 42 58 6 3 ear 65 35 8 2 InnerProduct 50 50 5 4 LinkedList 70 30 4 2 <ref> [4] </ref> and [5] can also be relocated because they do not generate values required by the CONTROL group. In fact, CONTROL partitioning is able to perform an optimal partitioning in this particular example. For this reason, it will be omitted throughout the remainder of the partitioning approaches. <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 <ref> [4] </ref> FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 <p> Two scientific applications, KMP and sobel, show excellent results using group partitioning. Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 <ref> [4] </ref> CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 <ref> [4] </ref> CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 =
Reference: [5] <author> B. Ramakrishna Rau and Christopher D. Glaeser, </author> <title> Some Scheduling Techniques and an Easily Schedulable Horizontal Architecture for High Performance Scientific Computing, </title> <booktitle> Proceedings of the 14th Annual Workshop on Microprogramming (1981) 183-198. </booktitle>
Reference-contexts: This schedule is shown in Figure 4.6. Chapter 4: Design of the MISC Compiler 48 [1] t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z <ref> [5] </ref> t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; <p> a line, the group placement identifier Chapter 4: Design of the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list <ref> [5] </ref> t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = <p> Line [13] is also included because it calculates the loop iterator (k++). Finally, since no groups can be assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines [2] through <ref> [5] </ref>, Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 <p> since no groups can be assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines [2] through <ref> [5] </ref>, Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to the CONTROL group. <p> The Chapter 4: Design of the MISC Compiler 51 [1] FREE t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z <ref> [5] </ref> CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = <p> Chapter 4: Design of the MISC Compiler 52 [1] CONTROL t1 = head ; list=head [2] CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list <ref> [5] </ref> CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load <p> 18 6 1 espresso 92 8 2 1 gcc 56 44 9 2 xlisp 81 19 4 2 sc 52 48 8 3 povray 74 26 4 2 sobel 42 58 6 3 ear 65 35 8 2 InnerProduct 50 50 5 4 LinkedList 70 30 4 2 [4] and <ref> [5] </ref> can also be relocated because they do not generate values required by the CONTROL group. In fact, CONTROL partitioning is able to perform an optimal partitioning in this particular example. For this reason, it will be omitted throughout the remainder of the partitioning approaches. <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] <ref> [5] </ref> FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL <p> Two scientific applications, KMP and sobel, show excellent results using group partitioning. Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 <ref> [5] </ref> CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 <ref> [5] </ref> CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] <p> the number of instructions in the delay slots; if only one instruction is iterated in the loop, Chapter 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 <ref> [5] </ref> t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing
Reference: [6] <author> Anant Agarwal, Ricardo Bianchini, David Chaiken, Kirk Johnson, David Kranz, John Kubiatowicz, Beng-Hong Lim, Ken Mackenzie and Donald Yeung, </author> <title> The MIT Alewife Machine: Architecture and Performance, </title> <booktitle> Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <year> (1995) </year> <month> 2-13. </month>
Reference-contexts: Examples of this type of architecture include the MIT Alewife machine <ref> [6] </ref>, the Stan-ford DASH architecture [7], and the Wisconsin Windtunnel design [8]. The separation of a program into multiple single issue instruction streams allows the decentralization of the hardware resources in these architectures by replacing a central instruction window with multiple windows from which instructions can be issued. <p> Chapter 4: Design of the MISC Compiler 48 [1] t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x <ref> [6] </ref> L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; load t8= x [k] [11] t9 = t7 * t8 ; (z <p> the MISC Compiler 49 [1] t1 = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test <ref> [6] </ref> t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, <p> [1] FREE t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x <ref> [6] </ref> L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] [11] FREE t9 = <p> CONTROL t1 = head ; list=head [2] CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test <ref> [6] </ref> FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] CONTROL t9 = (t8==t5) ; calc inverse if <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] <ref> [6] </ref> L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] <p> Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 <ref> [6] </ref> FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 <ref> [6] </ref> FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 /
Reference: [7] <author> Daniel Lenoski, James Laudon, Truman Joe, David Nakahira, Luis Stevens, Anoop Gupta and John Hennessy, </author> <title> The DASH Prototype: Implementation and Performance, </title> <booktitle> Proceedings of the 19th Annual Symposium on Computer Architecture, </booktitle> <year> (1992) </year> <month> 92-103. </month> <note> Bibliography 91 </note>
Reference-contexts: Examples of this type of architecture include the MIT Alewife machine [6], the Stan-ford DASH architecture <ref> [7] </ref>, and the Wisconsin Windtunnel design [8]. The separation of a program into multiple single issue instruction streams allows the decentralization of the hardware resources in these architectures by replacing a central instruction window with multiple windows from which instructions can be issued. <p> Chapter 4: Design of the MISC Compiler 48 [1] t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: <ref> [7] </ref> t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; load t8= x [k] [11] t9 = t7 * t8 ; (z [k] * <p> = head ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 <ref> [7] </ref> L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, L3 ; branch if true (list-&gt;x==0) <p> Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to a leading PE); line <ref> [7] </ref> falls in this category because it defines the branch control value (register t6) used by the branch instruction in line [8]. Line [13] is also included because it calculates the loop iterator (k++). <p> assigned to the FREE group that contain values used by the access group (no upstream communication allowed), lines [2] through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] <ref> [7] </ref> t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to the CONTROL group. <p> t1 = 0 ; q=0 [2] CONTROL t2 = 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: <ref> [7] </ref> CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] [11] FREE t9 = t7 * <p> CONTROL t2 = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 <ref> [7] </ref> L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] CONTROL t9 = (t8==t5) ; calc inverse if condition [12] CONTROL PC = t9, L3 <p> This is an example of a broadcast memory load operation. Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: <ref> [7] </ref> CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] CONTROL PC <p> Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 <ref> [7] </ref> L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t12 [15] FREE t6 = <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 <ref> [7] </ref> L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t8 [15] FREE t6 = <p> the delay slots; if only one instruction is iterated in the loop, Chapter 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] <ref> [7] </ref> t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing in the delay slot is
Reference: [8] <author> Steven Reinhardt, Mark Hill, James Larus, Alvin Lebeck, James Lewis and David Wood, </author> <title> The Wisconsin Wind Tunnel: Virtual Pro-totyping of Parallel Computers, </title> <booktitle> Proceedings of the 1993 ACM Sig-metrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <year> (1993) </year> <month> 48-60. </month>
Reference-contexts: Examples of this type of architecture include the MIT Alewife machine [6], the Stan-ford DASH architecture [7], and the Wisconsin Windtunnel design <ref> [8] </ref>. The separation of a program into multiple single issue instruction streams allows the decentralization of the hardware resources in these architectures by replacing a central instruction window with multiple windows from which instructions can be issued. Furthermore, each of these instruction windows can be less complex. <p> 48 [1] t1 = 0 ; q=0 [3] t3 = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond <ref> [8] </ref> PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; load t8= x [k] [11] t9 = t7 * t8 ; (z [k] * x [k]) [13] t2 = t2 + 1 <p> ; list=head [2] t2 = 4 ; calc z offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: <ref> [8] </ref> t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, L3 ; branch if true (list-&gt;x==0) [13] t10 <p> Virtual register labels (specified as t1, t2, t3, etc.) define intermediate points in the calculation and may or may not map to physical registers or queues (for the sake of clarity, the actual register mapping has been omitted). In the InnerProduct example (Figure 4.7, lines <ref> [8] </ref> and [14] are placed in the CONTROL group because they are branch instructions. Lines [9] and [10] are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will <p> InnerProduct example (Figure 4.7, lines <ref> [8] </ref> and [14] are placed in the CONTROL group because they are branch instructions. Lines [9] and [10] are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to a leading PE); line [7] falls in this category because it defines the branch control value (register t6) used by the branch instruction in line [8]. <p> operation (lines <ref> [8] </ref>, [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to a leading PE); line [7] falls in this category because it defines the branch control value (register t6) used by the branch instruction in line [8]. Line [13] is also included because it calculates the loop iterator (k++). <p> 0 ; k=0 [3] CONTROL t3 = 1024 ; set register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond <ref> [8] </ref> CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] [11] FREE t9 = t7 * t8 ; (z [k] * x [k]) [12] FREE <p> = 4 ; calc z offset from list [3] CONTROL t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: <ref> [8] </ref> CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] CONTROL t9 = (t8==t5) ; calc inverse if condition [12] CONTROL PC = t9, L3 ; branch <p> Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) <ref> [8] </ref> CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] CONTROL PC = L1 [15] L2: characteristic; <p> Group partitioning is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: <ref> [8] </ref> CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t12 [15] FREE t6 = t6 + <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: <ref> [8] </ref> CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t8 [15] FREE t6 = t6 + <p> only one instruction is iterated in the loop, Chapter 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) <ref> [8] </ref> VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing in the delay slot is translated into vector (or
Reference: [9] <author> James E. Smith, </author> <title> Decoupled Access/Execute Computer Architectures, </title> <booktitle> Proceedings of the 9th Annual International Symposium on Computer Architecture, </booktitle> <year> (1982) </year> <month> 112-119. </month>
Reference-contexts: Placing several processing elements on the same die circumvents the pin limitations on bandwidth, and supports high on-chip data transfer rates. In addition, using First-In-First-Out (FIFO) ordered queues in a manner similar to that used by decoupled machines <ref> [9] </ref> provides a clean way to handle synchronization. As transistor densities have continued to increase, single chip MIMD designs are now becoming feasible. One study [10] indicates that as tens of millions of transistors become available, something more than simply increasing on-chip cache sizes must be done. <p> Some of the earliest superscalar processors came from Apollo Computers [14], IBM [15] and Intel [16]. Decoupled processor designs also began to appear in the 1980's both in supercomputer <ref> [9] </ref> and microprocessor [17] versions. These processors separate program execution into distinct tasks, each of which executes instructions from an independent stream. For the most part decoupled designs have been relegated to a university research setting 1 . <p> This requirement is relaxed with an explicit message passing approach. The greater flexibility found in a decoupled design allows both single and multiple instruction stream descriptions of a task. The ZS-1 <ref> [9] </ref> and WM [22] systems operate in a decoupled manner while receiving instructions from a single instruction stream. Their architectural component descriptions are similar to those of Split Register superscalar designs [23]. <p> = 1024 ; set register for test [4] t4 = LOC [_z] ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true <ref> [9] </ref> t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; load t8= x [k] [11] t9 = t7 * t8 ; (z [k] * x [k]) [13] t2 = t2 + 1 ; k++ [15] L2: 4.6 Separation Strategies This section <p> offset from list [3] t3 = 8 ; calc x offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond <ref> [9] </ref> PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, L3 ; branch if true (list-&gt;x==0) [13] t10 = M [ t1+t2 ]; load t7= list-&gt;z [14] <p> In the InnerProduct example (Figure 4.7, lines [8] and [14] are placed in the CONTROL group because they are branch instructions. Lines <ref> [9] </ref> and [10] are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing <p> Lines <ref> [9] </ref> and [10] are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to a leading PE); line [7] falls in this category because it defines the branch control value (register t6) used by the branch instruction in line [8]. <p> group that contain values used by the access group (no upstream communication allowed), lines [2] through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) <ref> [9] </ref> t7 = M [t4+t2] [11] t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to the CONTROL group. <p> register for test [4] CONTROL t4 = LOC [_z] ; t4 = base of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true <ref> [9] </ref> CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] [11] FREE t9 = t7 * t8 ; (z [k] * x [k]) [12] FREE t1 = t1 + t9 ; q = q + <p> t3 = 8 ; calc x offset from list [4] CONTROL t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond <ref> [9] </ref> CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] CONTROL t9 = (t8==t5) ; calc inverse if condition [12] CONTROL PC = t9, L3 ; branch if true (list-&gt;x==0) [13] CONTROL t10 = M [ t1+t2 <p> Examining our two example programs, we see improvement in InnerProduct (), but no improvement in LinkedList (). In the InnerProduct () example 4.9, the memory access operations (lines <ref> [9] </ref> and [10]) were successfully separated from the control group; they have no impact on the control flow decisions, so the control processor can continue processing independent of the execution of the load instructions. <p> Chapter 4: Design of the MISC Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 <ref> [9] </ref> FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] CONTROL PC = L1 [15] L2: characteristic; it may be possible to have <p> is also effective in the Chapter 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) <ref> [9] </ref> CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t12 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL <p> Chapter 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) <ref> [9] </ref> CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t8 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL <p> 4: Design of the MISC Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 <ref> [9] </ref> t7 = M [t4+VREG] [10] t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing in the delay slot is translated into vector (or sentinel) form. <p> This clearly limits the effectiveness of an interleaved approach Chapter 6: Improving Memory Performance 79 when no reordering logic is provided. The technique of reordering memory operations has been explored by Smith <ref> [9] </ref> and has more recently been implemented in the R10000 processor. These designs show a significant improvement in cache performance, especially when cache misses can be bypassed (a technique referred to as a NON-blocking cache design [64]).
Reference: [10] <author> Matthew Farrens, Gary Tyson and Andrew Pleszkun, </author> <title> Study of Single-Chip Processor/Cache Organizations for Large Numbers of Transistors, </title> <booktitle> Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <year> (1994) </year> <month> 338-347. </month>
Reference-contexts: In addition, using First-In-First-Out (FIFO) ordered queues in a manner similar to that used by decoupled machines [9] provides a clean way to handle synchronization. As transistor densities have continued to increase, single chip MIMD designs are now becoming feasible. One study <ref> [10] </ref> indicates that as tens of millions of transistors become available, something more than simply increasing on-chip cache sizes must be done. <p> ; t4 = base of array z [5] t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] <ref> [10] </ref> t8 = M [ t5+t2 ] ; load t8= x [k] [11] t9 = t7 * t8 ; (z [k] * x [k]) [13] t2 = t2 + 1 ; k++ [15] L2: 4.6 Separation Strategies This section examines the effect of various partitioning heuristics on the ability to separate <p> offset from list [4] t4 = 12 ; calc next offset from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) <ref> [10] </ref> t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, L3 ; branch if true (list-&gt;x==0) [13] t10 = M [ t1+t2 ]; load t7= list-&gt;z [14] t11 = t10 / t8 ; (list-&gt;z / list-&gt;x) [15] <p> In the InnerProduct example (Figure 4.7, lines [8] and [14] are placed in the CONTROL group because they are branch instructions. Lines [9] and <ref> [10] </ref> are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to <p> Lines [9] and <ref> [10] </ref> are also placed in the CONTROL group because they are memory access instructions. Any RTLs that define a value later used by a CONTROL group operation (lines [8], [9], [10] or [14]) will also be placed in the CONTROL group to avoid moving data upstream (from a trailing PE to a leading PE); line [7] falls in this category because it defines the branch control value (register t6) used by the branch instruction in line [8]. <p> of array z [5] CONTROL t5 = LOC [_x] ; t5 = base of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] <ref> [10] </ref> CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] [11] FREE t9 = t7 * t8 ; (z [k] * x [k]) [12] FREE t1 = t1 + t9 ; q = q + (z [k] * x [k]) [13] CONTROL t2 = t2 + 1 ; <p> t4 = 12 ; calc next offset from list [5] CONTROL t5 = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) <ref> [10] </ref> CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x [11] CONTROL t9 = (t8==t5) ; calc inverse if condition [12] CONTROL PC = t9, L3 ; branch if true (list-&gt;x==0) [13] CONTROL t10 = M [ t1+t2 ]; load t7= list-&gt;z [14] FREE t11 = t10 / t8 <p> Examining our two example programs, we see improvement in InnerProduct (), but no improvement in LinkedList (). In the InnerProduct () example 4.9, the memory access operations (lines [9] and <ref> [10] </ref>) were successfully separated from the control group; they have no impact on the control flow decisions, so the control processor can continue processing independent of the execution of the load instructions. <p> For this reason, it will be omitted throughout the remainder of the partitioning approaches. As mentioned earlier, the LinkedList () example (Figure 4.10) shows little improvement in partitioning; only lines [2] and [13] could be relocated to the FREE group. The memory reference at line <ref> [10] </ref> returns data later used in a branch calculation, which forces the placement of that operation in the control group 7 . <p> Finally, the memory access in line [13] can only be placed into the CONTROL group if the compiler can determine that it does not reference the same address as found in reference <ref> [10] </ref>. The vpcc compiler will make this decision (an unsafe one) because of the different element names in the structure. If this assumption cannot be made, no improvement over DAE partitioning will be found. <p> IF statements often have this 7 It should be noted that the value read from memory by line <ref> [10] </ref> may be required by two PEs: The control PE to calculate the branch condition in line [11], and the division performed in line [14]. This is an example of a broadcast memory load operation. <p> Compiler 55 [1] FREE t1 = 0 [2] CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] <ref> [10] </ref> FREE t8 = M [ t5+t2 ] [11] FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] CONTROL PC = L1 [15] L2: characteristic; it may be possible to have a trailing PE perform the entire computation of <p> 4: Design of the MISC Compiler 56 [1] CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 <ref> [10] </ref> CONTROL t8 = M [ t1+t3 ] [11] CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t12 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL t1 = M [ t1+t4 ] <p> 4: Design of the MISC Compiler 58 [1] CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 <ref> [10] </ref> FREE t8 = M [ t1+t3 ] [11] FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t8 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL t1 = M [ t1+t4 ] <p> Compiler 61 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] <ref> [10] </ref> t8 = M [t5+VREG] [11] t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing in the delay slot is translated into vector (or sentinel) form.
Reference: [11] <author> Gary Tyson, Matthew Farrens and Andrew R. Pleszkun, </author> <month> MISC: </month>
Reference-contexts: This observation led to the design of the Multiple Instruction Stream Computer (MISC) architecture, a decoupled MIMD machine that is designed to support and exploit instruction level parallelism <ref> [11] </ref>. Chapter 1. Introduction 4 1.3 A Multiple Instruction Stream Computer The MISC architecture was designed to study a wide range of design points in exploiting all levels of parallel program execution. <p> ; t5 = base of array x [6] L1: [7] t6 = (t2&gt;=t3) ; calculate branch cond [8] PC = t6, L2 ; branch if true [9] t7 = M [ t4+t2 ] ; load t7= z [k] [10] t8 = M [ t5+t2 ] ; load t8= x [k] <ref> [11] </ref> t9 = t7 * t8 ; (z [k] * x [k]) [13] t2 = t2 + 1 ; k++ [15] L2: 4.6 Separation Strategies This section examines the effect of various partitioning heuristics on the ability to separate the strongly connect groups across the available PEs in a particular MISC <p> from list [5] t5 = 0 ; set register for loop test [6] t6 = 0 ; value=0 [7] L1: [8] t7 = (t1==t5) ; calc loop branch cond [9] PC = t7, L2 ; branch if true (list==0) [10] t8 = M [ t1+t3 ] ; load t8= list-&gt;x <ref> [11] </ref> t9 = (t8==t5) ; calc inverse if condition [12] PC = t9, L3 ; branch if true (list-&gt;x==0) [13] t10 = M [ t1+t2 ]; load t7= list-&gt;z [14] t11 = t10 / t8 ; (list-&gt;z / list-&gt;x) [15] t6 = t6 + t11 ; value = value + (z <p> by the access group (no upstream communication allowed), lines [2] through [5], Chapter 4: Design of the MISC Compiler 50 PE1 Code PE2 Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] <ref> [11] </ref> t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to the CONTROL group. This leaves three lines ([1], [11] and [12]) available to allocate to the FREE group. <p> [7] t6 = (t2&gt;=t3) [9] t7 = M [t4+t2] <ref> [11] </ref> t9 = t7 * t8 [13] t2 = t2 + 1 [15] L2: L2: L2: L2: which initialize the registers used by instructions in the CONTROL group, must also be assigned to the CONTROL group. This leaves three lines ([1], [11] and [12]) available to allocate to the FREE group. During execution of this example on a DAE partitioned processor, the CONTROL processor would execute 6150 instructions (accounting for 75 percent of all instructions), leaving 2049 instructions (25 percent) to be executed by the remaining PEs. <p> of array x [6] L1: [7] CONTROL t6 = (t2&gt;=t3) ; calculate branch cond [8] CONTROL PC = t6, L2 ; branch if true [9] CONTROL t7 = M [ t4+t2 ] ; load t7= z [k] [10] CONTROL t8 = M [ t5+t2 ] ; load t8= x [k] <ref> [11] </ref> FREE t9 = t7 * t8 ; (z [k] * x [k]) [12] FREE t1 = t1 + t9 ; q = q + (z [k] * x [k]) [13] CONTROL t2 = t2 + 1 ; k++ [14] CONTROL PC = L1 [15] L2: first column identifies the application <p> = 0 ; set register for loop test [6] FREE t6 = 0 ; value=0 [7] L1: [8] CONTROL t7 = (t1==t5) ; calc loop branch cond [9] CONTROL PC = t7, L2 ; branch if true (list==0) [10] CONTROL t8 = M [ t1+t3 ] ; load t8= list-&gt;x <ref> [11] </ref> CONTROL t9 = (t8==t5) ; calc inverse if condition [12] CONTROL PC = t9, L3 ; branch if true (list-&gt;x==0) [13] CONTROL t10 = M [ t1+t2 ]; load t7= list-&gt;z [14] FREE t11 = t10 / t8 ; (list-&gt;z / list-&gt;x) [15] FREE t6 = t6 + t11 ; <p> IF statements often have this 7 It should be noted that the value read from memory by line [10] may be required by two PEs: The control PE to calculate the branch condition in line <ref> [11] </ref>, and the division performed in line [14]. This is an example of a broadcast memory load operation. <p> CONTROL t2 = 0 [3] CONTROL t3 = 1024 [4] FREE t4 = LOC [_z] [5] FREE t5 = LOC [_x] [6] L1: [7] CONTROL t6 = (t2&gt;=t3) [8] CONTROL PC = t6, L2 [9] FREE t7 = M [ t4+t2 ] [10] FREE t8 = M [ t5+t2 ] <ref> [11] </ref> FREE t9 = t7 * t8 [12] FREE t1 = t1 + t9 [13] CONTROL t2 = t2 + 1 [14] CONTROL PC = L1 [15] L2: characteristic; it may be possible to have a trailing PE perform the entire computation of an if statement while the leading PEs can <p> CONTROL t1 = head [2] CONTROL t2 = 4 [3] CONTROL t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] CONTROL t8 = M [ t1+t3 ] <ref> [11] </ref> CONTROL t9 = (t8==t5) [12] CONTROL PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t12 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL t1 = M [ t1+t4 ] [18] CONTROL PC = L1 [19] L2: LinkedList <p> CONTROL t1 = head [2] FREE t2 = 4 [3] FREE t3 = 8 [4] CONTROL t4 = 12 [5] CONTROL t5 = 0 [6] FREE t6 = 0 [7] L1: [8] CONTROL t7 = (t1==t5) [9] CONTROL PC = t7, L2 [10] FREE t8 = M [ t1+t3 ] <ref> [11] </ref> FREE t9 = (t8==t5) [12] FREE PC = t9, L3 [13] FREE t10 = M [ t1+t2 ] [14] FREE t11 = t10 / t8 [15] FREE t6 = t6 + t11 [16] L3: [17] CONTROL t1 = M [ t1+t4 ] [18] CONTROL PC = L1 [19] L2: An <p> Code PE3 Code PE4 Code [1] t1 = 0 [3] t3 = 1024 t3 = 1024 t3 = 1024 t3 = 1024 [5] t5 = LOC [_x] [7] t6 = (t2&gt;=t3) [8] VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 VLOOP 1,0,t3 [9] t7 = M [t4+VREG] [10] t8 = M [t5+VREG] <ref> [11] </ref> t9 = t7 * t8 [13] [15] L2: L2: L2: L2: then the loop instruction is removed and the scalar instruction residing in the delay slot is translated into vector (or sentinel) form.
References-found: 11

