URL: http://www.cs.cornell.edu/Info/People/praveen/papers/thesis.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/praveen/papers.html
Root-URL: http://www.cs.brown.edu/
Title: MANAGEMENT OF SEQUENCE DATA  
Author: By Praveen Seshadri 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1996  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [APWZ95] <author> Rakesh Agrawal, Giuseppe Psaila, Edward Wimmers, and Mohammed Zait. </author> <title> Querying Shapes of Histories. </title> <booktitle> In Proceedings of the Twenty First International Conference on Very Large Databases (VLDB), </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases <ref> [APWZ95] </ref>, and finding similarity between sequences [FRM94]. In OLAP queries [CCS93], time is often an important dimension of the data, and moving window queries are common.
Reference: [AS86] <author> Ilsoo Ahn and Richard Snodgrass. </author> <title> Performance Evaluation of a Temporal Database Management System. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 96-107, </pages> <year> 1986. </year>
Reference-contexts: This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2. In terms of physical implementation, various access structures have been proposed for temporal relational data [EWK90, LS89] and some performance studies have been conducted <ref> [AS86, EKW90] </ref>. Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences [FRM94].
Reference: [BBG + 86] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, C. Twichell, and T. Wise. </author> <title> GENESIS: A Reconfigurable Database Management System. </title> <type> Technical Report TR-86-07, </type> <institution> University of Texas at Austin, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Each ADT was associated with methods that defined its behavior, and that could be invoked within an SQL query. Around the same time, there were other research prototypes like Genesis <ref> [BBG + 86] </ref> and Starburst [HCL + 90] that explored other aspects of database system extensibility, but did not focus on the type system. Other researchers addressed the obvious need for complex data support by developing object-oriented database systems (OO-DBMSs).
Reference: [BDK92] <author> F. Bancilhon, C. Delobel, and P. Kanellakis. </author> <title> Building an Object-Oriented Database System: The Story of O2. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but interpreted solely by the application program. Some object-oriented systems like O2 <ref> [BDK92] </ref> provide array and list constructs that allow collections of data to be ordered. <p> These ideas were extended with parallelism in the SVP model [SSV92]. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93]. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. <p> There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 <ref> [BDK92] </ref> also support a nested model with composite objects. The recently proposed OQL query language [Cat94] for OO databases allows collection types to be nested, and permits nested queries over them. The idea of enhancing ADTs with query language and query processing capabilities seems to be unique to PREDATOR.
Reference: [Cat94] <author> R.G.G. Cattell. </author> <title> The Object Database Standard:ODMB-93. </title> <address> Morgan-Kaufman, </address> <year> 1994. </year>
Reference-contexts: Extra/Excess [VD91] was one such model, as was Melampus [RS91]. Further, the OO-DBMS community gradually agreed on OQL (Object Query Language) <ref> [Cat94] </ref> as a high-level query language to manipulate object-oriented databases. As momentum was building behind the OO-DBMS ideas, the relational database community was motivated to address the same problems in a different manner, by leveraging their existing strengths in supporting relational data. <p> As a trivial example of this, there is usually only one implementation for each function, corresponding to only one evaluation strategy for each operation. In the OQL language design <ref> [Cat94] </ref>, methods are allowed to have multiple implementations, and the system has the freedom to choose the best one. This is a small first step towards declarative functional expressions. Recognizing the expression boundaries has benefits independent of the maintenance of compile-time statistics, or indeed the specification of transformation rules. <p> There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects. The recently proposed OQL query language <ref> [Cat94] </ref> for OO databases allows collection types to be nested, and permits nested queries over them. The idea of enhancing ADTs with query language and query processing capabilities seems to be unique to PREDATOR.
Reference: [CCH + 95] <author> M. Carey, W. Cody, L. Haas, W. Niblack, M. Arya, R. Fagin, M. Flickner, D. Lee, D. Petkovic, P. Schwarz, J. Thomas, M. Tork-Roth, J. Williams, and E. Wimmers. </author> <title> Querying Multimedia Data From Multiple Repositories By Content: The Garlic Project. </title> <booktitle> Proceedings of the IFIP Working Conference on Visual Database Systems, </booktitle> <address> Lausanne, Switzerland, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Within the system, the queries may be mapped into subexpressions belonging to the various component systems and expressed in the corresponding languages. This proposal contrasts with the popular approach of providing heterogeneity by writing "wrappers" over data sources <ref> [CGMH + 94, CCH + 95] </ref>. In the wrapper-based approach to integrating diverse systems, each system provides a common abstraction of its data, usually using an object-oriented model. This common abstraction is provided by implementing a wrapper around each system.
Reference: [CCS93] <author> E.F. Codd, </author> <title> S.B. Codd, and C.T. Salley. Beyond Decision Support. </title> <journal> ComputerWorld, </journal> <volume> 27(30), </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences [FRM94]. In OLAP queries <ref> [CCS93] </ref>, time is often an important dimension of the data, and moving window queries are common. These areas represent possible application domains to which SEQ could perhaps be adapted in the future. 9.3 Complex Data Types There is much research work related to the E-ADT paradigm.
Reference: [CDF + 93] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O. Tsatalos, S. White, and M.J. Zwilling. </author> <title> Shoring up persistent objects. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <pages> pages 526-541, </pages> <year> 1993. </year>
Reference-contexts: Each query 35 was executed four times in succession, the maximum and minimum execution times were excluded, and the average of the other two times was used as the performance metric. 4.2.2 Storage Implementation SEQ supports two repositories for sequence data, the Unix file system and the SHORE storage manager <ref> [CDF + 93] </ref>, with the ability to add further repositories as well. The default sequence data repository is built using the SHORE storage manager library, which supports concur-rency control, recovery and buffer management. <p> The high-level picture of the system is shown in arithmetic and boolean expressions, constant values and functions is part of this layer. An important portion of the utility layer is the SHORE Storage Manager <ref> [CDF + 93] </ref>, which provides facilities for concurrency control, recovery and buffer management for large volumes of data. It also provides a threads package that interacts with the rest of the storage management layers; PREDATOR uses this package to build a multi-threaded server.
Reference: [CDG + 90] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita, and S. Vandenberg. </author> <title> The EXODUS Extensible DBMS Project: An Overview. </title> <booktitle> In Readings in Object-Oriented Databases. </booktitle> <address> Morgan-Kaufman, </address> <year> 1990. </year>
Reference-contexts: Other researchers addressed the obvious need for complex data support by developing object-oriented database systems (OO-DBMSs). There are a number of current OO-DBMS commercial products (like O2, Ode, ObjectStore, Versant, etc.), most of which grew out of research systems of the late 1980s. Exodus <ref> [CDG + 90] </ref> was an OO-DBMS toolkit that was used in several research projects. All of these systems allow the definition of persistent database types using a programming language (usually some variant of C++).
Reference: [CGMH + 94] <author> S. Chawathe, H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. Ullman, and J. Widom. </author> <title> The TSIMMIS Project: Integration of Heterogeneous Information Sources. </title> <booktitle> In "Proceedings of the IPSJ Conference, </booktitle> <address> Tokyo, Japan", </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Within the system, the queries may be mapped into subexpressions belonging to the various component systems and expressed in the corresponding languages. This proposal contrasts with the popular approach of providing heterogeneity by writing "wrappers" over data sources <ref> [CGMH + 94, CCH + 95] </ref>. In the wrapper-based approach to integrating diverse systems, each system provides a common abstraction of its data, usually using an object-oriented model. This common abstraction is provided by implementing a wrapper around each system.
Reference: [Cha96] <author> Don Chamberlin. </author> <title> Using the New DB2. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: The issues regarding support for ADTs in database systems were first explored in [SRG83] and [Sto86]. This work lead to the development of the Postgres research DBMS [SRH90] and its commercial incarnation, Illustra [Ill94]. More recently, several commercial database systems including DB2 C/S V2 <ref> [Cha96] </ref> have begun providing some support for type extensibility. Among research systems, 74 the Paradise client-server DBMS [DKL + 94] is exploring issues related to the development of ADTs for spatial, geographic, and scientific data. The problems being addressed include the parallelization of operations over ADTs like scientific arrays [TD96].
Reference: [Cod70] <author> E.F. Codd. </author> <title> A Relational Model of Data for Large Shared Data Banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: The operations supported on relational data are well-known operations on sets and multi-sets of records: union, intersection, cross-product, selection and projection. These operations constitute the relational algebra <ref> [Cod70] </ref>, and serve as the established framework to query relational data. There has, however, been an increasing focus on extending database systems to provide efficient support for new and interesting kinds of data like time-series, images, and arrays.
Reference: [Com94] <author> TSQL2 Language Design Committee. </author> <title> TSQL2 Language Specification. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1) </volume> <pages> 65-86, </pages> <month> March </month> <year> 1994. </year> <month> 76 </month>
Reference-contexts: Similar extensions have already received much attention in the temporal database research community, and there is even an extension to SQL proposed to handle such operations <ref> [Com94] </ref>. Consequently, these operators are not the focus of the research in this thesis, and are not considered after this section. <p> The timestamp represents the positions in time at which the 73 tuple or object was "true". The associated query language is extended with predicates that access the timestamp. This is mostly complementary to this thesis because it involves changes to relations and to SQL <ref> [Com94] </ref>. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data [SK86, SS87, CS92, SP90, SSV92] provided initial direction to this thesis.
Reference: [CR86] <author> James Clifford and Ahobala Rao. </author> <title> A Simple, General Structure for Temporal Domains. </title> <type> CRIS 154, </type> <institution> Center for Research on Information Systems, Stern School of Business, </institution> <address> New York University, </address> <month> October </month> <year> 1986. </year>
Reference-contexts: The definition of blocked collapse and expansion of ordering domains is similar to the concept of intervallic partitions in <ref> [CR86] </ref>, and the concept of time units in [WJS93]. The definition of order-preserving collapses will be used in the next chapter on optimization techniques. There is one other variant of an order-preserving Collapse operator that does not have a corresponding Expand operator.
Reference: [CRSG94] <author> L.S. Colby, E.L. Robertson, L.V. Saxton, and D.V. Gucht. </author> <title> A Query Language for List-Based COmplex Objects. </title> <booktitle> In Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Minneapolis, MN, </address> <pages> pages 179-189, </pages> <year> 1994. </year>
Reference-contexts: The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have been languages proposed that model ordered data in addition to sets [DV92], as well as formal languages for list-based complex objects (see <ref> [CRSG94] </ref> as an example of such a language). Much of the formal work in this area was motivated by [MV93] which stressed the importance of supporting ordered data. There have also been languages proposed to match regular patterns over sequence data [SX92, GJS92].
Reference: [CS92] <author> Rakesh Chandra and Arie Segev. </author> <title> Managing Temporal Financial Data in an Extensible Database. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 238-249, </pages> <year> 1992. </year>
Reference-contexts: This is mostly complementary to this thesis because it involves changes to relations and to SQL [Com94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data <ref> [SK86, SS87, CS92, SP90, SSV92] </ref> provided initial direction to this thesis. The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed.
Reference: [CS93] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Query Optimization in the Presence of Foreign Functions. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Databases (VLDB), Dublin, Ireland, </booktitle> <pages> pages 526-541, </pages> <year> 1993. </year>
Reference-contexts: The rule is applied at "compile time", which is a significant change. A recent research proposal <ref> [CS93] </ref> suggests that rewrite rules could be applied in this manner (though the purpose of the proposal was to optimize access to external databases). There are a couple of important limitations to this extension.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This is analogous to thinking of all tables in an RDBMS as relations, with meta-information for each relation specifying the schema and other properties. The term "parametric types" <ref> [CW85] </ref> has also been used in this context to describe a type which is parameterized by additional meta-information, though this is not a feature commonly supported by an OR-DBMS. 5.2 Storing the Matrix There may be several different implementations of a matrix.
Reference: [DDS95] <author> Werner Dreyer, Angelika Kotz Dittrich, and Duri Schmidt. </author> <title> Using the CALANDA Time Series Management System. </title> <booktitle> In Proceedings of ACM SIGMOD '95 International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <year> 1995. </year>
Reference-contexts: Main-memory based systems like S-Plus [Sta91] perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data. A proprietary time-series management system has been developed at the Union Bank of Switzerland <ref> [DDS95] </ref>, but it is not publicly available. The ODE object-oriented system has an event recognition system that allows complex event patterns to be identified over event streams [GJS92]. These are all examples of special-purpose database support for sequences. Current general-purpose database systems provide limited support for sequence data.
Reference: [DKL + 94] <author> D.J. DeWitt, N. Kabra, J. Luo, J.M. Patel, and J. Yu. </author> <title> Client-server paradise. </title> <booktitle> In Proceedings of the Twentieth International Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: A commercial version of Postgres called Illustra [Ill94] was developed, whose primary attraction was that it provided the functionality of combining relational data with several kinds of complex data. Several commonly used data types (like images, time-series, etc.) along with their manipulation methods were provided as "datablades". Paradise <ref> [DKL + 94] </ref> is a recent research OR-DBMS that explores the use of complex data types in geographic and scientific databases in a parallel execution environment. The RDBMS community as a whole has in the meantime been attempting to incorporate this approach into its new SQL-3 standard [ISO93]. <p> This work lead to the development of the Postgres research DBMS [SRH90] and its commercial incarnation, Illustra [Ill94]. More recently, several commercial database systems including DB2 C/S V2 [Cha96] have begun providing some support for type extensibility. Among research systems, 74 the Paradise client-server DBMS <ref> [DKL + 94] </ref> is exploring issues related to the development of ADTs for spatial, geographic, and scientific data. The problems being addressed include the parallelization of operations over ADTs like scientific arrays [TD96].
Reference: [DKS92] <author> W. Du, R. Krishnamurthy, and M.C. Shan. </author> <title> Query Optimization in Heterogeneous Database Management Systems. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Databases (VLDB), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 277-291, </pages> <year> 1992. </year>
Reference-contexts: Consequently, strict transaction semantics may not be possible (this is a difficult problem anyway in heterogeneous systems [Moh95]). Finding a common cost model across multiple database systems is a difficult research area <ref> [DKS92] </ref>, and some approximate cost model must be used.
Reference: [DNS91] <author> David DeWitt, Jeffrey Naughton, and Donovan Schneider. </author> <title> An Evaluation of N on Equijoin Operations. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(V LDB), </booktitle> <year> 1991. </year>
Reference-contexts: The operator scope specifies exactly how many such records are needed at the adjacent site, and these boundary records need to be replicated at that site as well. Such an approach has been studied in the specific context of a "band-join" <ref> [DNS91] </ref>, and in the context of a "temporal-join" [LM92]. However, the characterization of all operators by their scope provides a general framework in which to parallelize all sequence queries. Recursive operators present a challenge to this form of partitioned parallelism, because their definition is essentially sequential.
Reference: [DV92] <author> S. Danforth and P. Valduriez. </author> <title> A FAD for Data-Intensive Applications. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(1), </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have been languages proposed that model ordered data in addition to sets <ref> [DV92] </ref>, as well as formal languages for list-based complex objects (see [CRSG94] as an example of such a language). Much of the formal work in this area was motivated by [MV93] which stressed the importance of supporting ordered data.
Reference: [EKW90] <author> Ramez Elmasri, Yeung-Joon Kim, and Gene Wuu. </author> <title> Efficient Implementation Techniques for the Time Index. </title> <booktitle> In Proceedings of the Seventh IEEE Data Engineering Conference, </booktitle> <month> April </month> <year> 1990. </year>
Reference-contexts: This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2. In terms of physical implementation, various access structures have been proposed for temporal relational data [EWK90, LS89] and some performance studies have been conducted <ref> [AS86, EKW90] </ref>. Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences [FRM94].
Reference: [ES94] <author> Ramez Elmasri and S.B.Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> Benjamin/Cummins Publishing Co., </publisher> <year> 1994. </year>
Reference: [EWK90] <author> Ramez Elmasri, Gene Wuu, and Yeung-Joon Kim. </author> <title> The Time Index : An Access Structure for Temporal Data. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(V LDB), </booktitle> <pages> pages 1-12, </pages> <year> 1990. </year>
Reference-contexts: This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2. In terms of physical implementation, various access structures have been proposed for temporal relational data <ref> [EWK90, LS89] </ref> and some performance studies have been conducted [AS86, EKW90]. Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences [FRM94].
Reference: [fADF90] <author> The Committee for Advanced Database Function. </author> <title> Third-Generation Database System Manifesto. </title> <journal> ACM SIGMOD Record, </journal> <volume> 19(3) </volume> <pages> 31-44, </pages> <year> 1990. </year>
Reference-contexts: As momentum was building behind the OO-DBMS ideas, the relational database community was motivated to address the same problems in a different manner, by leveraging their existing strengths in supporting relational data. Object-Relational databases (OR-DBMSs) <ref> [fADF90] </ref> were proposed as an extension of RDBMS technology to support object-oriented type systems in essence, extending the ideas behind the Postgres type system.
Reference: [FAM90] <institution> FAME Software Corporation, </institution> <address> 6869 Marshall Road, Dexter, MI 48130. </address> <note> User's Guide to FAME, 1990. 77 </note>
Reference-contexts: categorized into: * Systems (commercial and research) that support sequence data. * Proposals (mostly research) that deal with sequences or temporal data. * Systems and proposals that support the inclusion of complex data types in a database system. 9.1 Systems Supporting Sequences Financial management products like MIM [Log] and FAME <ref> [FAM90] </ref> provide special purpose systems for analyzing stock market data. Main-memory based systems like S-Plus [Sta91] perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data.
Reference: [FRM94] <author> C. Faloutsos, M. Ranganathan, and Y. Manolopoulos. </author> <title> Fast Subsequence Matching in Time-Series Databases. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <pages> pages 419-430, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences <ref> [FRM94] </ref>. In OLAP queries [CCS93], time is often an important dimension of the data, and moving window queries are common. These areas represent possible application domains to which SEQ could perhaps be adapted in the future. 9.3 Complex Data Types There is much research work related to the E-ADT paradigm.
Reference: [GHK92] <author> Sumit Ganguly, Waqar Hasan, and Ravi Krishnamurthy. </author> <title> Query Optimization for Parallel Execution. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <pages> pages 9-18, </pages> <year> 1992. </year>
Reference-contexts: The indexed access cost is the indexed access cost of the input sequence multiplied by this estimate, which can be based on the density of the input sequence. Algorithmic Analysis The Selinger algorithm has been extensively studied and is known to generate the class of "left-deep tree" join plans. <ref> [GHK92] </ref> contains a detailed analysis of this algorithm. The optimization algorithm presented here also explores the class of left-deep query trees within each block. The entire query evaluation plan however is not restricted to be a left-deep tree because the tree may be bushy across query blocks.
Reference: [GJS92] <author> N.H Gehani, H.V. Jagadish, and O. Shmueli. </author> <title> Composite Event Specification in Active Databases: Model and Implementation. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 327-338, </pages> <year> 1992. </year>
Reference-contexts: However, the mechanism by which this can be // defined using SEQUIN has not yet been worked out. SELECT DA.pfname, $SQL (``SELECT SEQSUM (P.perf_seq) FROM $1 P'', DA.per_stock_perf) FROM DetailedAnswer DA 70 8.3 Stream Pattern Matching <ref> [GJS92] </ref> presents a model and implementation of a system to recognize composite event patterns. The system provides an event expression language that creates composite events from basic events. <p> The input event sequence has no empty positions. The pattern itself can be as complicated as an arbitrary regular expression. The approach used in <ref> [GJS92] </ref> is to translate the event expression into a finite state automaton that can then be used to evaluate the expression in a "memoryless" fashion. Because the pattern has to be matched at every possible starting position, the automaton needs to be "restarted" on every input. <p> A proprietary time-series management system has been developed at the Union Bank of Switzerland [DDS95], but it is not publicly available. The ODE object-oriented system has an event recognition system that allows complex event patterns to be identified over event streams <ref> [GJS92] </ref>. These are all examples of special-purpose database support for sequences. Current general-purpose database systems provide limited support for sequence data. The Order-By clause in SQL only specifies the order in which answers are presented to the user. Most existing support for such data deals with temporal sequences. <p> Much of the formal work in this area was motivated by [MV93] which stressed the importance of supporting ordered data. There have also been languages proposed to match regular patterns over sequence data <ref> [SX92, GJS92] </ref>. This work is complementary to this thesis, since SEQ is oriented to more traditional database queries, and currently does not have powerful pattern-matching capabilities. On the other hand, SEQ has explored practical implementation issues that the more theoretical work did not address.
Reference: [GM81] <author> J. Grant and J. Minker. </author> <title> Optimization in Deductive and Conventional Relational Database Systems. </title> <editor> In H. Gallaire, J. Minker, and J. M. Nicolas, editors, </editor> <booktitle> Advances in Data Base Theory, </booktitle> <volume> volume 1, </volume> <pages> pages 195-234. </pages> <publisher> Plenum Press, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: There has been research that describes how common subexpressions may be identified and used in this manner in several different environments <ref> [Sel88, GM81] </ref>. In a sequence query, however, there is a possible third option that is more efficient.
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ninth IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <year> 1993. </year>
Reference-contexts: This leads to the next possible extension. 7.2.3 Applying Cost-Based Transformations The two limitations of heuristic rules may be eliminated by (a) allowing the rules to be specified using complex procedural code, and (b) allowing the rules to be associated with cost metrics. A rule-based optimizer engine like Volcano <ref> [GM93] </ref> could then be used to apply the rules. Since the rules require procedural code, they need to be written by a "database implementor" rather than by a naive user. This is keeping with the model of implementing important data types as vendor-supplied "datablade" 62 libraries.
Reference: [GS89a] <author> Himawan Gunadhi and Arie Segev. </author> <title> A Framework For Query Optimization In Temporal Databases. </title> <booktitle> In Fifth International Conference on Statistical and Scientific Database Management Systems, </booktitle> <year> 1989. </year>
Reference-contexts: While the emphasis was not on a cost-based query optimization for sequence queries in the database context, the emphasis on stream processing is similar. <ref> [GS89a] </ref> argues, as does this thesis, that special statistical information needs to be maintained for temporal data. However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. <p> An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models [GS89b, LM93, NG93]. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and <ref> [GS89a] </ref> proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2.
Reference: [GS89b] <author> Himawan Gunadhi and Arie Segev. </author> <title> Event-join Optimization in Temporal Relational Databases. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <year> 1989. </year>
Reference-contexts: However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models <ref> [GS89b, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2.
Reference: [GS91] <author> Himawan Gunadhi and Arie Segev. </author> <title> Query Processing Algorithms for Temporal Intersection Joins. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <year> 1991. </year>
Reference-contexts: However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models [GS89b, LM93, NG93]. For instance <ref> [GS91, LM93] </ref> propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2.
Reference: [HCL + 90] <author> L. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: Each ADT was associated with methods that defined its behavior, and that could be invoked within an SQL query. Around the same time, there were other research prototypes like Genesis [BBG + 86] and Starburst <ref> [HCL + 90] </ref> that explored other aspects of database system extensibility, but did not focus on the type system. Other researchers addressed the obvious need for complex data support by developing object-oriented database systems (OO-DBMSs).
Reference: [Hel95] <author> Joseph M. Hellerstein. </author> <title> Optimization and Execution Techniques for Queries With Expensive Methods. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: This is similar to the usual evaluation of functions in a language like SQL, and to the nested evaluation of correlated sub-queries in SQL. There are many optimizations like function caching <ref> [Hel95] </ref> and magic decorrelation [SPL96] that have been proposed in those contexts and similar optimizations could be performed in SEQ too.
Reference: [HS86] <author> W.D. Hillis and G. Steele. </author> <title> Data Parallel Algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 29(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: However, the characterization of all operators by their scope provides a general framework in which to parallelize all sequence queries. Recursive operators present a challenge to this form of partitioned parallelism, because their definition is essentially sequential. However, techniques like "parallel-prefix" computation <ref> [HS86] </ref> could be used to execute such operators. 33 Chapter 4 A Sequence Database System This chapter discusses the implementation of the SEQ sequence database system, a component of the larger PREDATOR DBMS which provides support for several kinds of complex data.
Reference: [Hul87] <author> Richard Hull. </author> <title> A Survey of Theoretic Research on Typed Complex Database Objects. </title> <editor> In J. Paradeans, editor, </editor> <booktitle> Databases, </booktitle> <pages> pages 193-256. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: Consequently, the work on parallel execution of ADT methods fits in neatly with the E-ADT paradigm, and would perhaps even be easier to develop within a system based on E-ADTs. There has been extensive work on nested data models (especially nested relational models <ref> [Hul87] </ref>), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects.
Reference: [Ill94] <institution> Illustra Information Technologies, Inc, </institution> <address> 1111 Broadway, Suite 2000, Oakland, CA 94607. </address> <note> Illustra User's Guide, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Object-Relational databases (OR-DBMSs) [fADF90] were proposed as an extension of RDBMS technology to support object-oriented type systems in essence, extending the ideas behind the Postgres type system. A commercial version of Postgres called Illustra <ref> [Ill94] </ref> was developed, whose primary attraction was that it provided the functionality of combining relational data with several kinds of complex data. Several commonly used data types (like images, time-series, etc.) along with their manipulation methods were provided as "datablades". <p> A database system that allows such nested structures is usually referred to as a non-1NF or complex object database. Data models supporting such nested types are becoming increasingly common, especially in object-relational systems <ref> [Ill94, Uni93] </ref>. In such a complex object system, sequence data could be modeled even more simply as a one-to-one mapping, where each position maps to either no record or one record. That record could itself contain a nested set of records as an attribute. <p> Each function plan invocation in turn calls the ExprEvaluate () method of the sequence E-ADT which causes the sequence subexpression to be evaluated. 6.4 Comparison with An Existing System Illustra <ref> [Ill94] </ref> is a commercial OR-DBMS supporting sequences (more specifically, time-series) as ADTs with a collection of methods providing query primitives. This section qualitatively compares this approach with PREDATOR, based on the performance experiments presented in Section 4.4. While a quantitative performance comparison with Illustra [Ill94] was performed, those results cannot be <p> Comparison with An Existing System Illustra <ref> [Ill94] </ref> is a commercial OR-DBMS supporting sequences (more specifically, time-series) as ADTs with a collection of methods providing query primitives. This section qualitatively compares this approach with PREDATOR, based on the performance experiments presented in Section 4.4. While a quantitative performance comparison with Illustra [Ill94] was performed, those results cannot be published under the terms of the license from Illustra. However, the experiments of Chapter 4 that demonstrate the effects of each individual optimization indirectly indicate the expected performance of Illustra, which lacks several of the optimizations. <p> The choice of implementation may be specified by the user or decided automatically by code provided as part of the ADT. This functionality is already present in the Illustra database system <ref> [Ill94] </ref>. Of course, there may be some ADTs for which a single implementation may suffice. <p> Some object-oriented systems like O2 [BDK92] provide array and list constructs that allow collections of data to be ordered. The object-relational database system Illustra <ref> [Ill94] </ref> provides database support for time-series data as an ADT. 9.2 Research Proposals for Sequence Data Since temporal sequences are among the most commonly occurring sequences in real life, there has been much research on temporal databases. The reader is referred to [Soo91] for a bibliography of recent work. <p> The issues regarding support for ADTs in database systems were first explored in [SRG83] and [Sto86]. This work lead to the development of the Postgres research DBMS [SRH90] and its commercial incarnation, Illustra <ref> [Ill94] </ref>. More recently, several commercial database systems including DB2 C/S V2 [Cha96] have begun providing some support for type extensibility. Among research systems, 74 the Paradise client-server DBMS [DKL + 94] is exploring issues related to the development of ADTs for spatial, geographic, and scientific data.
Reference: [ISO93] <author> ISO-ANSI. </author> <note> ISO-ANSI Working Draft: Database Language SQL2 and SQL3, 1993. X3H2; ISO/IEC JTC1/SC21/WG3. </note>
Reference-contexts: Paradise [DKL + 94] is a recent research OR-DBMS that explores the use of complex data types in geographic and scientific databases in a parallel execution environment. The RDBMS community as a whole has in the meantime been attempting to incorporate this approach into its new SQL-3 standard <ref> [ISO93] </ref>. Committees are debating the issues of exactly which data types should be specially supported, and what methods should be provided on those types.
Reference: [JSS92] <author> C.S. Jensen, M.D. Soo, and R.T. Snodgrass. </author> <title> Unification of Temporal Relations. </title> <type> Technical Report 92-15, </type> <institution> Computer Sciences Department, University of Arizona, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: The reader is referred to [Soo91] for a bibliography of recent work. Extensive research on temporal databases has dealt with temporal models <ref> [JSS92] </ref>, algebras [SM89] and query processing [TCG + 93]. Most of the work has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed.
Reference: [KBZ86] <author> R. Krishnamurthy, H. Boral, and C. Zaniolo. </author> <title> Optimization of Non-Recursive Queries. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases, </booktitle> <pages> pages 128-137, </pages> <year> 1986. </year> <month> 78 </month>
Reference-contexts: This is a dynamic programming algorithm that searches an exponential space of options. In practice, it might be acceptable to search a smaller space of options (for example, a polynomial space, as suggested by the KBZ join optimization algorithm <ref> [KBZ86] </ref>). 29 if (single operator of non-unit scope) - Find cheapest plan for each access mode; - else - /* collection of compose operators */ Curr_Set := Cheapest plans for each input sequence for each access mode; Repeat till all sequences have been joined - New_Set := Cheapest plans for joining
Reference: [Kim82] <author> W. Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7, </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: The 27 Query Position Sequence is also specified as part of the template. If the input sequences or any of the operators are themselves represented by SQTs, they are expanded out. This is similar to the policy of expanding view definitions used in relational database systems <ref> [Kim82] </ref>. At this stage, the query is a hierarchical tree of operators, with base sequences at the leaves of the tree and the Start operator at the root.
Reference: [Klu82] <author> Anthony Klug. </author> <title> Equivalence of relational algebra and relational calculus query languages having aggregate functions. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 699-717, </pages> <year> 1982. </year>
Reference-contexts: The operators are defined by specifying the RF of the output sequence. There already exists extensive literature that describes a realistic algebra of operators on sets of records; this is the relational algebra. There have also been well-documented extensions to the relational algebra to model partitioned aggregate functions <ref> [Klu82] </ref>. Record-Oriented operators are merely extensions of the relational algebra operators with added semantics to specify the RF mapping of the output set of records.
Reference: [LL92] <author> Charles LeBeau and David Lucas. </author> <title> Computer Analysis of the Futures Market. </title> <publisher> Irwin Professional Publishing, </publisher> <year> 1992. </year>
Reference-contexts: This thesis has focused in its presentation on the simpler underlying queries that form the building blocks for the more realistic technical analysis calculations. The reader is referred to <ref> [LL92] </ref> for a better understanding of technical analysis techniques. Example 2.4.1 Assume that daily sequences of stock data are available for IBM, DEC and HP.
Reference: [LM90] <author> Cliff T.Y. Leung and Richard R. Muntz. </author> <title> Query Processing for Temporal Databases. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> February </month> <year> 1990. </year>
Reference: [LM92] <author> Cliff Leung and Richard Muntz. </author> <title> Temporal Query Processing and Optimization in Multiprocesor Database Machines. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Databases (VLDB), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 383-394, </pages> <year> 1992. </year>
Reference-contexts: The operator scope specifies exactly how many such records are needed at the adjacent site, and these boundary records need to be replicated at that site as well. Such an approach has been studied in the specific context of a "band-join" [DNS91], and in the context of a "temporal-join" <ref> [LM92] </ref>. However, the characterization of all operators by their scope provides a general framework in which to parallelize all sequence queries. Recursive operators present a challenge to this form of partitioned parallelism, because their definition is essentially sequential.
Reference: [LM93] <author> Cliff T.Y. Leung and Richard R. Muntz. </author> <title> Stream Processing: Temporal Query Processing and Optimization, </title> <type> chapter 14. </type> <institution> Benjamin/Cummings, </institution> <year> 1993. </year>
Reference-contexts: Some of the optimization techniques used in this thesis are similar to other proposals in the literature. For instance, the concept of operator caches is similar to the notion of "working-memory" in <ref> [LM93, SP90] </ref>. [SP90] studies stream processing techniques using a logic language as the underlying data engine. <p> However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models <ref> [GS89b, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2. <p> However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models [GS89b, LM93, NG93]. For instance <ref> [GS91, LM93] </ref> propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2.
Reference: [LMW96] <author> Leonid Libkin, Rona Machlin, and Limsoon Wong. </author> <title> A Query Language for Multidimensional Arrays: Design, Implementation, and Optimization Techniques. </title> <booktitle> In Proceedings of ACM SIGMOD '96 International Conference on Management of Data, </booktitle> <address> Montreal, Canada, </address> <year> 1996. </year>
Reference-contexts: The matrix ADT has been used as an example, with a simple "query language" over it. More complex query languages for matrixes and multi-dimensional arrays have been proposed <ref> [LMW96] </ref>, and the same query processing problems could be demonstrated with these languages. Similar arguments could be made using sequences as the data type of interest. Any attempt at integrating sequences into a general purpose DBMS must address these problems.
Reference: [Log] <institution> Logical Information Machines. </institution> <note> MIM User Manual. </note>
Reference-contexts: This has been categorized into: * Systems (commercial and research) that support sequence data. * Proposals (mostly research) that deal with sequences or temporal data. * Systems and proposals that support the inclusion of complex data types in a database system. 9.1 Systems Supporting Sequences Financial management products like MIM <ref> [Log] </ref> and FAME [FAM90] provide special purpose systems for analyzing stock market data. Main-memory based systems like S-Plus [Sta91] perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data.
Reference: [LS89] <author> David Lomet and Betty Salzberg. </author> <title> Access Methods for Multiversion Data. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 315-324, </pages> <year> 1989. </year>
Reference-contexts: This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2. In terms of physical implementation, various access structures have been proposed for temporal relational data <ref> [EWK90, LS89] </ref> and some performance studies have been conducted [AS86, EKW90]. Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [APWZ95], and finding similarity between sequences [FRM94].
Reference: [MDZ93] <author> Gail Mitchell, Umeshwar Dayal, and Stanley Zdonik. </author> <title> Control of an Extensible Query Optimizer: A Planning-Based Approach. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Databases (VLDB), Dublin, Ireland, </booktitle> <pages> pages 517-528, </pages> <year> 1993. </year>
Reference-contexts: The loosely-coupled architecture with multiple top-level collection types with different query languages also appears to be novel. The notion of breaking a query into regions, each of which is optimized separately is similar in flavor to the "blackboard" architecture for relational query optimizers proposed in <ref> [MDZ93] </ref>; however, that work was not directed at supporting operations on complex data types. As an interesting counterpoint to the approach taken in this thesis, there have been efforts that try to find a holistic solution to the problem of querying new data types.
Reference: [Moh95] <author> C. Mohan. </author> <title> An Overview of the Exotica Research Project on Workflow Management Systems. </title> <booktitle> In Proceedings of the 6th International Workshop on High Performance Transaction Systems, Asilomar, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Consequently, strict transaction semantics may not be possible (this is a difficult problem anyway in heterogeneous systems <ref> [Moh95] </ref>). Finding a common cost model across multiple database systems is a difficult research area [DKS92], and some approximate cost model must be used.
Reference: [MV93] <author> D. Maier and B. Vance. </author> <title> A call to order. </title> <booktitle> In Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Washington, DC, </address> <year> 1993. </year>
Reference-contexts: There have been languages proposed that model ordered data in addition to sets [DV92], as well as formal languages for list-based complex objects (see [CRSG94] as an example of such a language). Much of the formal work in this area was motivated by <ref> [MV93] </ref> which stressed the importance of supporting ordered data. There have also been languages proposed to match regular patterns over sequence data [SX92, GJS92]. This work is complementary to this thesis, since SEQ is oriented to more traditional database queries, and currently does not have powerful pattern-matching capabilities.
Reference: [NG93] <author> Sunil S. Nair and Shashi K. Gadia. </author> <title> Algebraic Optimization in a Relational Model for Temporal Databases. </title> <editor> In Richard Snodgrass, editor, </editor> <booktitle> Proceedings of the International Workshop on an Infrastructure for Temporal Databases, </booktitle> <pages> pages 390-397, </pages> <address> Arlington, Texas, </address> <year> 1993. </year>
Reference-contexts: However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in [WG93]. There has been some work on query optimization based on temporal relational data models <ref> [GS89b, LM93, NG93] </ref>. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques. This work is of significance in supporting the Record-Oriented sequence operators of Chapter 2.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph Hellerstein, and Waqar Hasan. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <year> 1992. </year>
Reference-contexts: It might be possible to recognize that it is the very same E-ADT on both sides of the expression interface, and merge the two expressions. The resulting merged expression might result in more efficient performance (possibly using techniques like those suggested in <ref> [PHH92] </ref>). Extrapolating from this, if there are two similar E-ADTs like relations and sequences involved in a query, it might be possible to propagate information from one E-ADT expression to the other. For example, a selection condition might be pushed across the interface.
Reference: [Ric92] <author> Joel Richardson. </author> <title> Supporting Lists in a Data Model. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year> <month> 79 </month>
Reference-contexts: While most object-oriented database proposals include constructors for complex types like lists and arrays [VD91, BDK92], they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in <ref> [Ric92] </ref> is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have been languages proposed that model ordered data in addition to sets [DV92], as well as formal languages for list-based complex objects (see [CRSG94] as an example of such a language).
Reference: [RS91] <author> Joel Richardson and Peter Schwartz. </author> <title> Aspects: Extending Objects to SUpport Multiple Independent Roles. </title> <booktitle> In Proceedings of ACM SIGMOD '91 International Conference on Management of Data, </booktitle> <address> Denver, CO, </address> <year> 1991. </year>
Reference-contexts: Observing that this low-level data manipulation interface was inadequate for many applications, some research on OO-DBMSs looked at advanced data models that would directly support certain complex data types like lists, sets, bags, etc. Extra/Excess [VD91] was one such model, as was Melampus <ref> [RS91] </ref>. Further, the OO-DBMS community gradually agreed on OQL (Object Query Language) [Cat94] as a high-level query language to manipulate object-oriented databases.
Reference: [SAC + 79] <author> Patricia G. Selinger, M. Astrahan, D. Chamberlin, Raymond Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> In Proceedings of ACM SIGMOD '79 International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: A conventional relational query optimizer as described in <ref> [SAC + 79] </ref> would probably generate the following query evaluation plan. For every Volcano tuple in the outer query, the sub-query would be invoked to find the time of the most recent earthquake. Each such access to the subquery involves an aggregate over the entire Earthquake relation. <p> The approach taken to generate a plan for each block is similar in spirit to the plan generation algorithm for SQL query blocks described in <ref> [SAC + 79] </ref>, which is referred to as the Selinger algorithm. A brief explanation of the Selinger algorithm is in order.
Reference: [Sel88] <author> T. Sellis. </author> <title> Multiple Query Optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: There has been research that describes how common subexpressions may be identified and used in this manner in several different environments <ref> [Sel88, GM81] </ref>. In a sequence query, however, there is a possible third option that is more efficient.
Reference: [SHR + 96] <author> P. Seshadri, J. Hellerstein, R. Ramakrishnan, H. Pirahesh, T.Y.C. Leung, D. Srivastava, S. Sudarshan, and P. Stuckey. </author> <title> Cost-Based Optimization for Magic: Algebra and Implementation. </title> <booktitle> In Proceedings of ACM SIGMOD '96 International Conference on Management of Data, </booktitle> <address> Montreal, Canada, </address> <year> 1996. </year>
Reference-contexts: If each expression also provides a "set-at-a-time" plan (i.e., given a set of arguments, instead of a single one, evaluate the expression for each of the arguments), then this provides a set-oriented interface across E-ADTs . Recent work <ref> [SHR + 96] </ref> has described how cost-based optimization can be used by a database system to determine how best 65 to utilize set-oriented plans. The same techniques can be applied to E-ADT queries as well.
Reference: [SK86] <author> Arie Shoshani and Kyoji Kawagoe. </author> <title> Temporal Data Management. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases, </booktitle> <pages> pages 79-88, </pages> <year> 1986. </year>
Reference-contexts: These are similar to the properties associated with a Time Sequence in <ref> [SS87, SK86] </ref>. * Start and end positions, which determine the valid range or span of the sequence. <p> This is mostly complementary to this thesis because it involves changes to relations and to SQL [Com94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data <ref> [SK86, SS87, CS92, SP90, SSV92] </ref> provided initial direction to this thesis. The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed.
Reference: [SLR94] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrishnan. </author> <title> Sequence Query Processing. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This chapter discusses optimization techniques for sequence queries based on the LSEQ data model, with some minor restrictions on the kinds of queries that may be posed. Much of this material was presented in <ref> [SLR94] </ref>.
Reference: [SLR95] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrishnan. SEQ: </author> <title> A Model for Sequence Databases. </title> <booktitle> In Proceedings of the Eleventh IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <pages> pages 232-239, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Consequently, as long as sequences co-exist with relations, the simplified sequence data model suffices. The earlier sections present the entire SE Q model in detail, since the development of the data model for sequences is itself an individual research contribution <ref> [SLR95] </ref>. Readers who wish to bypass the details should directly read Section 2.4.1; this describes the LSEQ model at an intuitive level which is sufficient for the reader to comprehend the rest of the thesis. 2.1 Data Model Fundamentals Assume the existence of a set T Basic of basic types.
Reference: [SLR96a] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrishnan. </author> <title> The Case for Enhanced Abstract Data Types. </title> <type> Technical Report TR-1319, </type> <institution> University of Wisconsin-Madison, Computer Sciences Department, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Further, it is not clear that such queries will be easy to pose, or practical to optimize and evaluate. 53 The Enhanced ADT (E-ADT) approach proposed in this thesis (and described in detail in <ref> [SLR96a] </ref>) lies between the two extremes of the ADT approach and the "mega-model" approach. Each of the subexpressions of the query corresponding to a specific data type is declarative. However, across subexpressions, the interaction is mostly procedural.
Reference: [SLR96b] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrishnan. </author> <title> The Design and Implementation of a Sequence Database System. </title> <booktitle> In Proceedings of the Twenty Second International Conference on Very Large Databases (VLDB), </booktitle> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: SEQ provides the SEQUIN language to specify declarative queries over sequences, and an optimization and execution engine to process the queries. The effects of several design choices and optimization techniques are demonstrated via experiments on a synthetic sequence database. Much of this material was presented in <ref> [SLR96b] </ref>.
Reference: [SLVZ95] <author> Bharati Subramaniam, Theodore Leung, Scott Vandenberg, and Stanley Zdonik. </author> <title> The AQUA Approach to Querying Lists and Trees in Object-Oriented Databases. </title> <booktitle> In Proceedings of the Eleventh IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: A system based on this model would require a single unified algebra that can represent all operations over the various types of data (examples of such proposals are the Aqua algebra <ref> [SLVZ95] </ref> and the higher-order monadic algebra used in the Kleisli programming environment [Won94]). While in these proposals, the entire query expression can be declarative, the important questions are whether such a system is extensible, and whether it is practical. <p> Instead of breaking a query into many parts with local query optimization, these approaches try to find a global integrated solution. Obviously, this requires that the entire query be modeled somehow in an integrated framework. AQUA <ref> [SLVZ95] </ref> is an algebraic framework that has been proposed for this purpose, while CPL/Kleisli [Won94] is a framework based on comprehensions as a query language and a higher-order monadic algebra.
Reference: [SM89] <author> Richard Snodgrass and Edwin McKenzie. </author> <title> An Evaluation of Algebras Incorporating Time. </title> <type> Technical Report TR-89-22. </type> <institution> Computer Science Department. University of Arizona., </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: The reader is referred to [Soo91] for a bibliography of recent work. Extensive research on temporal databases has dealt with temporal models [JSS92], algebras <ref> [SM89] </ref> and query processing [TCG + 93]. Most of the work has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed.
Reference: [Soo91] <author> Michael D. Soo. </author> <title> Bibliography on Temporal Databases. </title> <journal> ACM SIGMOD Record, </journal> <volume> 20(1) </volume> <pages> 14-23, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The object-relational database system Illustra [Ill94] provides database support for time-series data as an ADT. 9.2 Research Proposals for Sequence Data Since temporal sequences are among the most commonly occurring sequences in real life, there has been much research on temporal databases. The reader is referred to <ref> [Soo91] </ref> for a bibliography of recent work. Extensive research on temporal databases has dealt with temporal models [JSS92], algebras [SM89] and query processing [TCG + 93].
Reference: [SP90] <author> D. Stott Parker. </author> <title> Stream Data Analysis in Prolog, chapter 8. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This is mostly complementary to this thesis because it involves changes to relations and to SQL [Com94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data <ref> [SK86, SS87, CS92, SP90, SSV92] </ref> provided initial direction to this thesis. The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed. <p> The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed. Implementation issues were discussed in the context of how the model could be mapped to a relational data model.The Tangram Stream Processor <ref> [SP90] </ref> uses transducers and stream processing to query sequences in a logic programming context. These ideas were extended with parallelism in the SVP model [SSV92]. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93]. <p> Some of the optimization techniques used in this thesis are similar to other proposals in the literature. For instance, the concept of operator caches is similar to the notion of "working-memory" in <ref> [LM93, SP90] </ref>. [SP90] studies stream processing techniques using a logic language as the underlying data engine. <p> Some of the optimization techniques used in this thesis are similar to other proposals in the literature. For instance, the concept of operator caches is similar to the notion of "working-memory" in [LM93, SP90]. <ref> [SP90] </ref> studies stream processing techniques using a logic language as the underlying data engine.
Reference: [SPL96] <author> Praveen Seshadri, Hamid Pirahesh, and Cliff Leung. </author> <title> Complex Query Decorrelation. </title> <booktitle> In Proceedings of the Twelfth IEEE Conference on Data Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: This is similar to the usual evaluation of functions in a language like SQL, and to the nested evaluation of correlated sub-queries in SQL. There are many optimizations like function caching [Hel95] and magic decorrelation <ref> [SPL96] </ref> that have been proposed in those contexts and similar optimizations could be performed in SEQ too. The current implementation, however, uses a simple value-at-a-time nested evaluation. 7.1.5 Granularity of Statistics Another issue that arises in the nested design is the granularity at which statistics are maintained.
Reference: [SRG83] <author> M. Stonebraker, B. Rubenstein, and A. Guttman. </author> <title> Application of Abstract Data Types and Abstract Indices to CAD Data Bases. </title> <booktitle> In Proceedings of the Engineering Applications Stream of Database Week, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1983. </year> <month> 80 </month>
Reference-contexts: Neither solution resulted in suitable support for complex data, and by the 1980s, there was a growing move to enhance the type system of an RDBMS to directly support complex data. Much of the early work in this area came out of the Ingres project at Berkeley. In <ref> [SRG83] </ref> and [Sto84], Stonebraker proposed that the type system of Ingres could be extended to allow a field of a record to contain a complex value, and even the result of a whole query. <p> These areas represent possible application domains to which SEQ could perhaps be adapted in the future. 9.3 Complex Data Types There is much research work related to the E-ADT paradigm. The issues regarding support for ADTs in database systems were first explored in <ref> [SRG83] </ref> and [Sto86]. This work lead to the development of the Postgres research DBMS [SRH90] and its commercial incarnation, Illustra [Ill94]. More recently, several commercial database systems including DB2 C/S V2 [Cha96] have begun providing some support for type extensibility.
Reference: [SRH90] <author> Michael Stonebraker, Lawrence Rowe, and Michael Hirohama. </author> <title> The Implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: However, in order to allow full-fledged extensions to the type system, basic changes to the design of the database system were needed. These design requirements were described 3 by Stonebraker in [Sto86], and led to the development of the new Postgres system <ref> [SRH90] </ref> as a fully extensible DBMS. An important part of Postgres was the extensible type system that allowed the definition of an arbitrary number of new Abstract Data Types (ADTs). Each ADT was associated with methods that defined its behavior, and that could be invoked within an SQL query. <p> The issues regarding support for ADTs in database systems were first explored in [SRG83] and [Sto86]. This work lead to the development of the Postgres research DBMS <ref> [SRH90] </ref> and its commercial incarnation, Illustra [Ill94]. More recently, several commercial database systems including DB2 C/S V2 [Cha96] have begun providing some support for type extensibility.
Reference: [SS87] <author> Arie Segev and Arie Shoshani. </author> <title> Logical Modelling of Temporal Data. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 454-466, </pages> <year> 1987. </year>
Reference-contexts: These are similar to the properties associated with a Time Sequence in <ref> [SS87, SK86] </ref>. * Start and end positions, which determine the valid range or span of the sequence. <p> This is mostly complementary to this thesis because it involves changes to relations and to SQL [Com94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data <ref> [SK86, SS87, CS92, SP90, SSV92] </ref> provided initial direction to this thesis. The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed. <p> However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data [SK86, SS87, CS92, SP90, SSV92] provided initial direction to this thesis. The model of a time-series in <ref> [SS87] </ref> is similar to that of the LSEQ model, and an SQL-like language was also proposed.
Reference: [SS94] <author> Sunita Sarawagi and Michael Stonebraker. </author> <title> Efficient Organization of Large Multidimensional Arrays. </title> <booktitle> In Proceedings of the Tenth IEEE Conference on Data Engineering, </booktitle> <year> 1994. </year>
Reference-contexts: For example, there is the issue of whether the matrix is stored in a row-major or a column-major format (in fact for multi-dimensional matrices, there are many more possibilities), or whether it is broken into tiles <ref> [SS94] </ref>. Further, different implementation techniques may be used depending on the size of the matrix. Depending on the sparseness of the matrix, compression may be used. How can one specify what storage implementation is to be used? The ADT solution is to add this information to the type constructor.
Reference: [SSV92] <author> D. Stott Parker, Eric Simon, and Patrick Valduriez. </author> <title> SVP a Model Capturing Sets, Streams, and Parallelism. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Databases (VLDB), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 115-126, </pages> <year> 1992. </year>
Reference-contexts: This is mostly complementary to this thesis because it involves changes to relations and to SQL [Com94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. Research directed at modeling time-series data <ref> [SK86, SS87, CS92, SP90, SSV92] </ref> provided initial direction to this thesis. The model of a time-series in [SS87] is similar to that of the LSEQ model, and an SQL-like language was also proposed. <p> Implementation issues were discussed in the context of how the model could be mapped to a relational data model.The Tangram Stream Processor [SP90] uses transducers and stream processing to query sequences in a logic programming context. These ideas were extended with parallelism in the SVP model <ref> [SSV92] </ref>. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93].
Reference: [Sta91] <institution> Statistical Sciences, Inc., </institution> <address> Seattle, WA. </address> <note> S-Plus User's Manual, </note> <year> 1991. </year>
Reference-contexts: Main-memory based systems like S-Plus <ref> [Sta91] </ref> perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data. A proprietary time-series management system has been developed at the Union Bank of Switzerland [DDS95], but it is not publicly available.
Reference: [Sto84] <author> Michael Stonebraker. </author> <title> QUEL as a Data Type. </title> <booktitle> In Proceedings of ACM SIGMOD '84 International Conference on Management of Data, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: Much of the early work in this area came out of the Ingres project at Berkeley. In [SRG83] and <ref> [Sto84] </ref>, Stonebraker proposed that the type system of Ingres could be extended to allow a field of a record to contain a complex value, and even the result of a whole query.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Data Base Systems. </title> <booktitle> In Proceedings of the Second IEEE Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year>
Reference-contexts: However, in order to allow full-fledged extensions to the type system, basic changes to the design of the database system were needed. These design requirements were described 3 by Stonebraker in <ref> [Sto86] </ref>, and led to the development of the new Postgres system [SRH90] as a fully extensible DBMS. An important part of Postgres was the extensible type system that allowed the definition of an arbitrary number of new Abstract Data Types (ADTs). <p> These areas represent possible application domains to which SEQ could perhaps be adapted in the future. 9.3 Complex Data Types There is much research work related to the E-ADT paradigm. The issues regarding support for ADTs in database systems were first explored in [SRG83] and <ref> [Sto86] </ref>. This work lead to the development of the Postgres research DBMS [SRH90] and its commercial incarnation, Illustra [Ill94]. More recently, several commercial database systems including DB2 C/S V2 [Cha96] have begun providing some support for type extensibility.
Reference: [SX92] <author> S.Ginsburg and X.Wang. </author> <title> Pattern Matching by Rs-operations: Towards a Unified Approach to Querying Sequenced Data. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1992. </year>
Reference-contexts: Much of the formal work in this area was motivated by [MV93] which stressed the importance of supporting ordered data. There have also been languages proposed to match regular patterns over sequence data <ref> [SX92, GJS92] </ref>. This work is complementary to this thesis, since SEQ is oriented to more traditional database queries, and currently does not have powerful pattern-matching capabilities. On the other hand, SEQ has explored practical implementation issues that the more theoretical work did not address.
Reference: [TCG + 93] <author> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. Snodgrass. </author> <title> Temporal Databases, Theory, Design and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: This is the approach that has been taken in the temporal relational database research community, and there is extensive literature on a variety of approaches to actually implement such support <ref> [TCG + 93] </ref>. Since the underlying assumption of this thesis is that support for sequence data will be provided in the context of a general-purpose system, it is reasonable to assume that support for relational data will also be present. <p> While many temporal queries can be expressed in SQL-92 using features like correlated subqueries and aggregation, these are typically very inefficient to execute. Much research in the temporal database community has focused on enhancing relational data models with temporal semantics <ref> [TCG + 93] </ref>, but there have been few publicly available implementations. Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but interpreted solely by the application program. <p> The reader is referred to [Soo91] for a bibliography of recent work. Extensive research on temporal databases has dealt with temporal models [JSS92], algebras [SM89] and query processing <ref> [TCG + 93] </ref>. Most of the work has focused on extending existing data models to support temporal data, or extending existing query languages to allow temporal queries to be expressed. Typically, the relational or object-oriented model is extended by associating a "timestamp" with each tuple or object.
Reference: [TD96] <author> Kristin Tufte and David J. DeWitt. </author> <title> Design and Implementation of HDF in the Paradise DBMS. Copy from kristint@cs.wisc.edu, </title> <year> 1996. </year>
Reference-contexts: Among research systems, 74 the Paradise client-server DBMS [DKL + 94] is exploring issues related to the development of ADTs for spatial, geographic, and scientific data. The problems being addressed include the parallelization of operations over ADTs like scientific arrays <ref> [TD96] </ref>. Since the traditional ADT support for functions and methods proves insufficient when one wants to parallelize query execution, the Paradise system explores extensions to ADTs that enhance parallelism. From the E-ADT viewpoint, parallel execution is simply yet another possible benefit of declarative ADT expressions.
Reference: [Uni93] <institution> UniData Inc., </institution> <address> Denver, CO. </address> <note> UniSQL User's Guide (Release 2.1), </note> <year> 1993. </year>
Reference-contexts: A database system that allows such nested structures is usually referred to as a non-1NF or complex object database. Data models supporting such nested types are becoming increasingly common, especially in object-relational systems <ref> [Ill94, Uni93] </ref>. In such a complex object system, sequence data could be modeled even more simply as a one-to-one mapping, where each position maps to either no record or one record. That record could itself contain a nested set of records as an attribute. <p> There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData <ref> [Uni93] </ref>, based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects. The recently proposed OQL query language [Cat94] for OO databases allows collection types to be nested, and permits nested queries over them.
Reference: [VD91] <author> S.L. Vandenberg and D.J. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> In Proceedings of ACM SIGMOD '91 International Conference on Management of Data, </booktitle> <address> Denver, </address> <publisher> CO, </publisher> <pages> pages 158-167, </pages> <year> 1991. </year>
Reference-contexts: Observing that this low-level data manipulation interface was inadequate for many applications, some research on OO-DBMSs looked at advanced data models that would directly support certain complex data types like lists, sets, bags, etc. Extra/Excess <ref> [VD91] </ref> was one such model, as was Melampus [RS91]. Further, the OO-DBMS community gradually agreed on OQL (Object Query Language) [Cat94] as a high-level query language to manipulate object-oriented databases. <p> These ideas were extended with parallelism in the SVP model [SSV92]. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93]. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists.
Reference: [WG93] <author> Richard Wolniewicz and Goetz Graefe. </author> <title> Algebraic Optimization of Computations over Scientific Databases. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Databases (VLDB), Dublin, Ireland, </booktitle> <pages> pages 13-24, </pages> <year> 1993. </year>
Reference-contexts: However, research on optimization and processing strategies has been relatively limited. An extension of a relational query optimizer to handle scientific data was presented in <ref> [WG93] </ref>. There has been some work on query optimization based on temporal relational data models [GS89b, LM93, NG93]. For instance [GS91, LM93] propose efficient stream access techniques of processing various types of temporal "joins", and [GS89a] proposes an optimization framework for temporal data based on such techniques.
Reference: [WJS93] <author> Sean X. Wang, Sushil Jajodia, </author> <title> and V.S. Subrahmanian. Temporal Modules: An Approach Toward Federated Tempora Databases. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <pages> pages 227-237, </pages> <year> 1993. </year>
Reference-contexts: The definition of blocked collapse and expansion of ordering domains is similar to the concept of intervallic partitions in [CR86], and the concept of time units in <ref> [WJS93] </ref>. The definition of order-preserving collapses will be used in the next chapter on optimization techniques. There is one other variant of an order-preserving Collapse operator that does not have a corresponding Expand operator. This variant is not based on a pre-defined collapse fl. Instead, the block boundaries are data-dependent. <p> This is a recognition of the fact that a sequence is at once "Positional " as well as "Record-Oriented ". This duality has also been recognized in the context of temporal databases by <ref> [WJS93] </ref>, which defines a bimodal temporal calculus based on these two abstractions. In the Record-Oriented abstraction, a sequence can be viewed as a relation whose records have some extra attributes that contain the RF mapping information. <p> These ideas were extended with parallelism in the SVP model [SSV92]. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of <ref> [WJS93] </ref>. While most object-oriented database proposals include constructors for complex types like lists and arrays [VD91, BDK92], they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided.
Reference: [Won94] <author> Limsoon Wong. </author> <title> Querying Nested Collections. </title> <type> PhD thesis, </type> <institution> U.Pennsylvania, </institution> <year> 1994. </year> <month> 81 </month>
Reference-contexts: A system based on this model would require a single unified algebra that can represent all operations over the various types of data (examples of such proposals are the Aqua algebra [SLVZ95] and the higher-order monadic algebra used in the Kleisli programming environment <ref> [Won94] </ref>). While in these proposals, the entire query expression can be declarative, the important questions are whether such a system is extensible, and whether it is practical. <p> Obviously, this requires that the entire query be modeled somehow in an integrated framework. AQUA [SLVZ95] is an algebraic framework that has been proposed for this purpose, while CPL/Kleisli <ref> [Won94] </ref> is a framework based on comprehensions as a query language and a higher-order monadic algebra. The primary difficulty is that the integrated solution must be capable of modeling all possible queries and query processing strategies for all possible data types.
References-found: 89

