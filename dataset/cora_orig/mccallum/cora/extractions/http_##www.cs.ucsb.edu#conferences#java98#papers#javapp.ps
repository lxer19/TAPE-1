URL: http://www.cs.ucsb.edu/conferences/java98/papers/javapp.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Email: email: First.Last@sophia.inria.fr  
Phone: tel: 33 93 65 76 31, fax: 33 93 65 78 58,  
Title: A Java Framework for Seamless Sequential, Multi-threaded, and Distributed Programming  
Author: Denis Caromel, Julien Vayssiere 
Web: http://www.inria.fr/sloop/javall/  
Address: BP 93, 06902 Sophia Antipolis Cedex  
Affiliation: INRIA Sophia Antipolis CNRS I3S Univ. Nice Sophia Antipolis  
Abstract: Due to its platform-independent execution model, its support for networking, multithreading and mobile code, Java has given hope that easy Internet-wide high-performance network computing was at hand. Numerous attempts have then been made at providing a framework for the development of such metacomputing applications. Unfortunately, none of them addresses seamless cross-paradigm computing, i-e the execution of the same application on a multiprocessor shared-memory machine as well as on a network of workstations, or on any combination of both. In this article we first identify four requirements for the development of such metacomputing frameworks. We then introduce Java//, a 100% Java library that provides transparent remote objects as well as asynchronous calls and high-level synchronization mechanisms. We also present the metaob-ject protocol Java// is built on and give some performance figures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. The Java Series. </title> <address> Addi-son-Wesley, Reading, MA, USA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction In order to provide a framework for the development of cross-paradigm metacomputing environments [7][10][8] within the scope of the Java language <ref> [1] </ref> and environment [12], we identify four key requirements: polymorphism between local and remote objects, higher-level synchronization mechanisms, reuse of sequential code and the availability of a 100% Java portable library. 1.1 Transparent remote objects First, let us focus on cross-paradigm portability.
Reference: [2] <author> Jean-Pierre Briot and Akinori Yonezawa. </author> <title> Inheritance and synchronization in concurrent OOP. </title> <booktitle> In European Conference on Object-Oriented Programming (ECOOP'87), </booktitle> <pages> pages 32-40. </pages> <publisher> Springer-Verlag, LNCS 276, </publisher> <year> 1987. </year>
Reference-contexts: Although monitor-like primitives [13] may be theoretically sufficient for expressing synchronization, implementing complex synchronization specifications using such low-levels tools is definitely cumbersome and error-prone. Moreover, such architectures do not scale well and have some reuse problems <ref> [2] </ref>.
Reference: [3] <author> Denis Caromel. </author> <title> Service, Asynchrony, </title> <journal> and Wait-By-Necessity. Journal of Object Orientated Programming (JOOP), </journal> <pages> pages 12-22, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The interface Reflect does not provide any functionality but acts as a common root interface for all behaviors implemented using the Java// metaobject protocol. 2.4 A method for reuse As Java// is an extension of Eiffel// <ref> [3] </ref> and C++// [6], it may be the support for a method for reuse first described in [5]. Its main feature is to postpone the identification of active objects in the design of an application.
Reference: [4] <author> Denis Caromel. </author> <title> Programming Abstractions for Concurrent Programming. </title> <booktitle> In Technology of Object-Oriented Languages and Systems, PACIFIC (TOOLS PACIFIC '90), </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: However, high-performance computing often relies on relatively simple synchronization policies. and synchronization This technique is easily extensible and the programmer is free to implement new abstractions for intra-object synchronization <ref> [4] </ref>. Each of these implementations should result in a body class that implements the synchronization policy and an interface inheriting directly or indirectly from Active which declares the name of the proxy class (usually the default asynchronous proxy) and the name of the body class (see figure 3).
Reference: [5] <author> Denis Caromel. </author> <title> Toward a method of object-oriented concurrent programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 90-102, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Location transparency provides polymorphism between local and remote objects. Activity transparency hides the fact that methods invoked on an active object actually execute in a separate thread using transparent future objects and wait-by-necessity <ref> [5] </ref>. Advanced synchronization mechanisms allow an easy and safe implementation of potentially complex synchronization policies. 2 Let's have a look at how these different features can be obtained within the scope of the Java language. <p> does not provide any functionality but acts as a common root interface for all behaviors implemented using the Java// metaobject protocol. 2.4 A method for reuse As Java// is an extension of Eiffel// [3] and C++// [6], it may be the support for a method for reuse first described in <ref> [5] </ref>. Its main feature is to postpone the identification of active objects in the design of an application. The programmer may then concentrate on application design and not mix it with the division of the application in concurrent activities.
Reference: [6] <author> Denis Caromel, Fabrice Belloncle, and Yves Roudier. </author> <title> The C++// System. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The interface Reflect does not provide any functionality but acts as a common root interface for all behaviors implemented using the Java// metaobject protocol. 2.4 A method for reuse As Java// is an extension of Eiffel// [3] and C++// <ref> [6] </ref>, it may be the support for a method for reuse first described in [5]. Its main feature is to postpone the identification of active objects in the design of an application.
Reference: [7] <author> C. Catlett and L. </author> <title> Smarr. Metacomputing. </title> <journal> Communications of the ACM, </journal> <volume> 35 </volume> <pages> 44-152, </pages> <year> 1992. </year>
Reference: [8] <author> Geoffrey C.Fox and Wojtek Furmanski. </author> <title> Java for parallel computing and as a general language for scientific and engineering simulation and modelling. </title> <year> 1996. </year>
Reference: [9] <author> John T. Feo. </author> <title> A comparative study of parallel programming languages: the Salishan problems, </title> <booktitle> volume 6 of Special topics in supercomputing. </booktitle> <publisher> North-Holland Publishing Co., </publisher> <address> Ams-terdam, The Netherlands, </address> <year> 1992. </year>
Reference-contexts: We're also working on an implementation of the Salishan problems <ref> [9] </ref> as a test bed. Java// is available for download along with source code and examples at http://www.inria.fr/sloop/javall. 8
Reference: [10] <author> I. Foster and C. Kesselman. Globus: </author> <title> A meta-computing infrastructure toolkit. </title> <journal> The International Journal of Supercomputer Applications and High Performance Computing, </journal> <volume> 11(2) </volume> <pages> 115-128, </pages> <month> Summer </month> <year> 1997. </year>
Reference: [11] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns Elements of Reusable Object-Oriented Software. Professional Computing Series. </title> <publisher> AW, </publisher> <year> 1995. </year>
Reference-contexts: In most distributed objects systems, such as RMI or CORBA, location transparency is achieved using the proxy pattern <ref> [11] </ref>. A local object (the so-called proxy) acts as a representative for an object that resides in another address space, possibly on another machine across a network. This proxy encapsulates all communication details so that other local objects do not know they are actually sending messages to a remote object. <p> This is especially useful when we do not have access to the code that creates the standard object. We suggest the use of the factory method pattern <ref> [11] </ref> in order to nicely encapsulate the code needed to instanciate active objects.
Reference: [12] <author> James Gosling and H. McGilton. </author> <title> The Java Language Environment. </title> <publisher> Sun Microsystems Computer Company, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: 1 Introduction In order to provide a framework for the development of cross-paradigm metacomputing environments [7][10][8] within the scope of the Java language [1] and environment <ref> [12] </ref>, we identify four key requirements: polymorphism between local and remote objects, higher-level synchronization mechanisms, reuse of sequential code and the availability of a 100% Java portable library. 1.1 Transparent remote objects First, let us focus on cross-paradigm portability. Cross-platform portability is genuinely achieved by the standard Java execution environment.
Reference: [13] <author> C.A.R Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 10 </volume> <pages> 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: It is strongly required in order to let the programmer concentrate first on modeling and algorithmic issues rather than lower-level tasks such as object distribution, mapping and load balancing. 1.2 High-level synchronization mechanism Our second requirement for metacomputing is higher-level synchronization mechanisms. Although monitor-like primitives <ref> [13] </ref> may be theoretically sufficient for expressing synchronization, implementing complex synchronization specifications using such low-levels tools is definitely cumbersome and error-prone. Moreover, such architectures do not scale well and have some reuse problems [2].
Reference: [14] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: As a general rule, it is currently hard to achieve speedup on a network of workstations when the communication/computation ratio is too high. 4 Implementation: a Meta Object Protocol Java// is built on top of a metaobject protocol (MOP) <ref> [14] </ref> that permits reification of method invocation and constructor call. As this MOP is not limited to the implementation of our transparent remote objects library, it also provides an open framework for implementing powerful libraries for the Java language.
Reference: [15] <author> Juergen Kleinoeder and Michael Golm. Meta-java: </author> <title> An efficient run-time meta architecture for java. </title> <type> Techn. Report TR-I4-96-03, </type> <institution> Univ. of Erlangen-Nuernberg, IMMD IV, </institution> <year> 1996. </year> <note> english. </note>
Reference-contexts: As for any other element of Java//, this MOP is entirely written in Java and does not require any modification or extension to the Java Virtual Machine, as opposed to other metaobject protocols for Java <ref> [15] </ref>. It makes extensive use of the Java Reflection API, thus requiring JDK 1.1 or higher. JDK 1.2 is required in order to suppress default Java language access control checks when executing reified non-public method or constructor calls.
Reference: [16] <author> Doug Lea. </author> <title> Concurrent programming in Java: design principles and patterns. Addi-son/Wesley Java series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: This thread is started by the object that owns the queue of pending method invocations on an object: the body. Java// provides a mechanism for specifying synchronization of method invocations on a given active object. The purpose of this mechanism is to enhance the standard thread synchronization mechanism <ref> [16] </ref> with two different methods for specifying synchronization : an explicit one and an implicit one. The biggest difference with the standard thread synchronization mechanism is that synchronization is now centralized in one special method of a class, instead of being disseminated in 4 all methods of a class.
Reference: [17] <author> Michael Philippsen and Matthias Zenger. </author> <title> Java-party transparent remote objects in java. </title> <booktitle> In ACM 1997 Workshop on Java for Science and Engineering Computation, </booktitle> <month> June </month> <year> 1997. </year>
Reference: [18] <author> Rajeev R. Raje, Joseph I. William, and Michael Boyles. </author> <title> An asynchronous remote method invocation (armi) mechanism for java. </title> <booktitle> In ACM 1997 Workshop on Java for Science and Engineering Computation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The main steps of this method are shown in figure 4. 3 Example and performances 3.1 Distributed matrix-vector prod uct We have implemented an example proposed by Raje, William and Boyles in <ref> [18] </ref>: a matrix-vector product, the rows of the matrix being split between two machines. The matrix is a square matrix of size 1000 containing float numbers. We make extensive use of wait-by-necessity in order to automatically overlap local and remote calculations. <p> The only modification needed would be to change myRemoteNode to the current node name (localNode here), through the javall-mapping file. 3.2 Performances product with respect to the number of rows on the remote machine. Both the local and the remote machine were UltraSparcs. As in <ref> [18] </ref>, the minimum is reached for 400 remote rows and 600 local ones. This is not surprising at all since both Java// and ARMI are implemented on top of RMI. computation Our implementation of Java// is based on Java RMI.
Reference: [19] <author> W. M. Yu and A. L. Cox. Java/DSM: </author> <title> a platform for heterogeneous computing. </title> <booktitle> In ACM 1997 Workshop on Java for Science and Engineering Computation, </booktitle> <month> June </month> <year> 1997. </year> <month> 9 </month>
References-found: 19

