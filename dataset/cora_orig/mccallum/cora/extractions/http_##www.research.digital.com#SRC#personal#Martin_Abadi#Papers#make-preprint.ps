URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/make-preprint.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  blampson@microsoft.com  Jean-Jacques.Levy@inria.fr  
Title: Analysis and Caching of Dependencies  
Author: Martin Abadi Butler Lampson Jean-Jacques Levy 
Address: Rocquencourt  
Affiliation: Digital Systems Research Center  Microsoft  INRIA  
Abstract: We address the problem of dependency analysis and caching in the context of the -calculus. The dependencies of a - term are (roughly) the parts of the -term that contribute to the result of evaluating it. We introduce a mechanism for keeping track of dependencies, and discuss how to use these dependencies in caching. 
Abstract-found: 1
Intro-found: 1
Reference: [ACCL91] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: In section 3, we study dependency analysis and caching in the pure -calculus. In sections 4, we extend our techniques to a more realistic language; this language includes records and has a weak operational semantics based on explicit substitutions <ref> [ACCL91, Fie90] </ref>. 2 Motivation and Related Work The motivation for this work arose in the context of a system-modelling system called Vesta [LM93, HL93]|roughly a replacement for tools like make and rcs.
Reference: [Bar84] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus. </title> <address> North Holland, </address> <note> Revised edition, </note> <year> 1984. </year>
Reference-contexts: Intuitively, we will mark every subexpression of a necessary to compute v along the leftmost outermost reduction. 3.2 A labelled -calculus In order to compute minimum prefixes as discussed above, we follow the underlined method of Barendregt <ref> [Bar84] </ref>, generalized by use of labels as in the work of Field, Levy, or Maranget [Fie90, Lev78, Mar91]. Our application of this method gives rise to a new labelled calculus, which we de fine next.
Reference: [Ber78] <author> G. Berry. </author> <title> Stable models of typed lambda-calculi. </title> <booktitle> In Proc. 5th Coll. on Automata, Languages and Programming, Lectures Notes in Computer Science, </booktitle> <pages> pages 72-89. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Theorem 3 (Stability) If a is a term, v is a term in normal form, and a ! ? v, then there is a minimum prefix a 0 a such that a 0 ! ? v. Proof The stability theorem follows from the stability of Bohm trees <ref> [Ber78] </ref>. Here we sketch a simple, alternative proof.
Reference: [BHA86] <author> G. L. Burn, C. Hankin, and S. Abramsky. </author> <title> Strictness analysis for higher-order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7 </volume> <pages> 249-278, </pages> <year> 1986. </year>
Reference-contexts: In particular, Pugh's dissertation concerns incremental evaluation of functional programs; it raises the issue of caching for functions that do not depend on all of their arguments [Pug88, pp. 70-71]. Dependency analysis is also similar to traditional analyses such as strictness analysis (e.g., <ref> [BHA86] </ref>). There is even a recent version of strictness analysis that relies on a labelled -calculus [GVS95]. Strictness analysis is concerned with what parts of a program must be evaluated; in contrast, for doing cache lookups, we need to know what parts of a program may affect the result.
Reference: [Fie90] <author> John Field. </author> <title> On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <year> 1990. </year>
Reference-contexts: In section 3, we study dependency analysis and caching in the pure -calculus. In sections 4, we extend our techniques to a more realistic language; this language includes records and has a weak operational semantics based on explicit substitutions <ref> [ACCL91, Fie90] </ref>. 2 Motivation and Related Work The motivation for this work arose in the context of a system-modelling system called Vesta [LM93, HL93]|roughly a replacement for tools like make and rcs. <p> will mark every subexpression of a necessary to compute v along the leftmost outermost reduction. 3.2 A labelled -calculus In order to compute minimum prefixes as discussed above, we follow the underlined method of Barendregt [Bar84], generalized by use of labels as in the work of Field, Levy, or Maranget <ref> [Fie90, Lev78, Mar91] </ref>. Our application of this method gives rise to a new labelled calculus, which we de fine next.
Reference: [FT90] <author> John Field and Tim Teitelbaum. </author> <title> Incremental reduction in the lambda calculus. </title> <booktitle> In Proceedings of the 1990 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 307-322. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Here we discuss techniques for the - calculus; these are somewhat simpler, easier to explain, and perhaps of more general interest. In the -calculus, the work that seems most closely related to ours is that of Field and Teitelbaum <ref> [FT90] </ref>. They have investigated the problem of reductions of similar expressions (which may not even yield the same result). Their approach is based on a -calculus with a new "fork" primitive () rather than on a labelled -calculus.
Reference: [GLM92] <author> Georges Gonthier, Jean-Jacques Levy, and Paul-Andre Mellies. </author> <title> An abstract standardisation theorem. </title> <booktitle> In Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: The confluence theorem follows from Klop's dissertation work, because the labelled calculus is a regular combinatory reduction systems [Klo80]; the labelled calculus is left-linear and without critical pairs. The normalization theorem can also be derived from Klop's work; alternatively it can be obtained from results about abstract reductions systems <ref> [GLM92] </ref>, via O'Donnell's notion of left systems [O'D77]. The proof of the stability theorem is similar to the one in [HL91]. 3.3 Basic caching Suppose that a ! ? v, where a is a term and v is its normal form. <p> This -calculus enjoys the same theorems as the pure -calculus of section 3.1 (modulo that now is actually a pre-order, not an order). These theorems should not be taken for granted, however. Their proofs are less easy, but they can be done by using results on abstract reduction systems <ref> [GLM92] </ref>. The stability theorem ensures that there is a minimum prefix for obtaining any result; moreover, the maximality and monotonicity propositions are the basis for a caching mechanism. Finally, we should note that, in this calculus, closures may contain irrelevant bindings.
Reference: [GVS95] <author> Milind Gandhe, G. Venkatesh, and Amitabha Sanyal. </author> <title> Labeled -calculus and a generalised notion of strictness. </title> <booktitle> In Asian Computing Science Conference, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: Dependency analysis is also similar to traditional analyses such as strictness analysis (e.g., [BHA86]). There is even a recent version of strictness analysis that relies on a labelled -calculus <ref> [GVS95] </ref>. Strictness analysis is concerned with what parts of a program must be evaluated; in contrast, for doing cache lookups, we need to know what parts of a program may affect the result.
Reference: [HL91] <author> Gerard Huet and Jean-Jacques Levy. </author> <title> Computations in Orthogonal Term Rewriting Systems. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The normalization theorem can also be derived from Klop's work; alternatively it can be obtained from results about abstract reductions systems [GLM92], via O'Donnell's notion of left systems [O'D77]. The proof of the stability theorem is similar to the one in <ref> [HL91] </ref>. 3.3 Basic caching Suppose that a ! ? v, where a is a term and v is its normal form. Put a different label on every subexpression of a, obtaining a labelled term a 0 .
Reference: [HL93] <author> Chris Hanna and Roy Levin. </author> <title> The Vesta language for configuration management. </title> <type> Research Report 107, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> June </month> <year> 1993. </year> <note> Available from http://www.research.digital.com/SRC. </note>
Reference-contexts: In sections 4, we extend our techniques to a more realistic language; this language includes records and has a weak operational semantics based on explicit substitutions [ACCL91, Fie90]. 2 Motivation and Related Work The motivation for this work arose in the context of a system-modelling system called Vesta <ref> [LM93, HL93] </ref>|roughly a replacement for tools like make and rcs. In Vesta, the analogue of a makefile is a program written in a specialized, un-typed, higher-order, functional, lazy, interpreted language. The functional character of the language guarantees that the results of system building are predictable and reproducible. <p> This paper, however, is not about Vesta. There has been some research on caching in Vesta <ref> [HL93] </ref>, and more is currently in progress. Here we discuss techniques for the - calculus; these are somewhat simpler, easier to explain, and perhaps of more general interest. In the -calculus, the work that seems most closely related to ours is that of Field and Teitelbaum [FT90]. <p> Similar examples arise in the context of Vesta (see section 2 and <ref> [HL93] </ref>). A simple one is the term: (if isC (file) then Ccompile else M3compile)(file) where isC (f ) returns true whenever f is a C source file, and file is either a C source file or an M3 source file.
Reference: [Hug85] <editor> John Hughes. Lazy memo-functions. In Jean-Pierre Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 129-146, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: The programs can be reasonably large; it is therefore desirable to notice cache hits for large subexpressions rather than for individual calls to primitives (e.g., individual compilations). Furthermore, irrelevant changes in parameters are expected to be frequent; when there are such changes, a simple memoisation <ref> [Mic68, Hug85] </ref> does not suffice for avoiding recomputations, and a more savvy caching strategy is necessary. This paper, however, is not about Vesta. There has been some research on caching in Vesta [HL93], and more is currently in progress.
Reference: [Klo80] <author> Jan Willem Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> CWI, </institution> <year> 1980. </year> <month> 8 </month>
Reference-contexts: The labelled calculus enjoys the same fundamental theorems as the unlabelled calculus: confluence, normalization, and stability. The confluence theorem follows from Klop's dissertation work, because the labelled calculus is a regular combinatory reduction systems <ref> [Klo80] </ref>; the labelled calculus is left-linear and without critical pairs. The normalization theorem can also be derived from Klop's work; alternatively it can be obtained from results about abstract reductions systems [GLM92], via O'Donnell's notion of left systems [O'D77].
Reference: [Lev78] <author> Jean-Jacques Levy. </author> <title> Reductions Correctes et Op--timales dans le Lambda Calcul. </title> <type> PhD thesis, </type> <institution> University of Paris 7, </institution> <year> 1978. </year>
Reference-contexts: We develop a simple way of capturing and of exploiting these fairly elaborate dependencies. Our approach is based on a labelled -calculus <ref> [Lev78] </ref>. Roughly, our labelled -calculus is like a -calculus with names for subexpressions. In the course of computation, the names propagate, and some of them end up in the result. <p> will mark every subexpression of a necessary to compute v along the leftmost outermost reduction. 3.2 A labelled -calculus In order to compute minimum prefixes as discussed above, we follow the underlined method of Barendregt [Bar84], generalized by use of labels as in the work of Field, Levy, or Maranget <ref> [Fie90, Lev78, Mar91] </ref>. Our application of this method gives rise to a new labelled calculus, which we de fine next.
Reference: [LM93] <author> Roy Levin and Paul R. McJones. </author> <title> The Vesta approach to precise configuration of large software systems. </title> <type> Research Report 105, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> June </month> <year> 1993. </year> <note> Available from http://www.research.digital.com/SRC. </note>
Reference-contexts: In sections 4, we extend our techniques to a more realistic language; this language includes records and has a weak operational semantics based on explicit substitutions [ACCL91, Fie90]. 2 Motivation and Related Work The motivation for this work arose in the context of a system-modelling system called Vesta <ref> [LM93, HL93] </ref>|roughly a replacement for tools like make and rcs. In Vesta, the analogue of a makefile is a program written in a specialized, un-typed, higher-order, functional, lazy, interpreted language. The functional character of the language guarantees that the results of system building are predictable and reproducible.
Reference: [Mar91] <author> Luc Maranget. </author> <title> Optimal derivations in weak lambda-calculi and in orthogonal term rewriting systems. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: will mark every subexpression of a necessary to compute v along the leftmost outermost reduction. 3.2 A labelled -calculus In order to compute minimum prefixes as discussed above, we follow the underlined method of Barendregt [Bar84], generalized by use of labels as in the work of Field, Levy, or Maranget <ref> [Fie90, Lev78, Mar91] </ref>. Our application of this method gives rise to a new labelled calculus, which we de fine next.
Reference: [Mic68] <author> D. Michie. </author> <title> `Memo' functions and machine learning. </title> <journal> Nature, </journal> <volume> 218 </volume> <pages> 19-22, </pages> <year> 1968. </year>
Reference-contexts: The programs can be reasonably large; it is therefore desirable to notice cache hits for large subexpressions rather than for individual calls to primitives (e.g., individual compilations). Furthermore, irrelevant changes in parameters are expected to be frequent; when there are such changes, a simple memoisation <ref> [Mic68, Hug85] </ref> does not suffice for avoiding recomputations, and a more savvy caching strategy is necessary. This paper, however, is not about Vesta. There has been some research on caching in Vesta [HL93], and more is currently in progress.
Reference: [O'D77] <author> Michael O'Donnell. </author> <title> Computing in Systems described by Equations. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1977. </year>
Reference-contexts: The normalization theorem can also be derived from Klop's work; alternatively it can be obtained from results about abstract reductions systems [GLM92], via O'Donnell's notion of left systems <ref> [O'D77] </ref>. The proof of the stability theorem is similar to the one in [HL91]. 3.3 Basic caching Suppose that a ! ? v, where a is a term and v is its normal form. Put a different label on every subexpression of a, obtaining a labelled term a 0 .
Reference: [Pug88] <author> William Pugh. </author> <title> Incremental Computation and the Incremental Evaluation of Functional Programs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1988. </year> <month> 9 </month>
Reference-contexts: There has been much other work on incremental computation, and some of it is related to ours. In particular, Pugh's dissertation concerns incremental evaluation of functional programs; it raises the issue of caching for functions that do not depend on all of their arguments <ref> [Pug88, pp. 70-71] </ref>. Dependency analysis is also similar to traditional analyses such as strictness analysis (e.g., [BHA86]). There is even a recent version of strictness analysis that relies on a labelled -calculus [GVS95].
References-found: 18

