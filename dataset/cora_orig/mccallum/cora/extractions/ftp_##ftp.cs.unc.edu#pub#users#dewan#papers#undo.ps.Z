URL: ftp://ftp.cs.unc.edu/pub/users/dewan/papers/undo.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/cse.html
Root-URL: http://www.cs.unc.edu
Email: choudhary@ccm.jf.intel.com)  (dewan@cs.unc.edu)  
Title: A General Multi-User Undo/Redo Model  
Author: Rajiv Choudhary Intel Corporation (rajiv Prasun Dewan 
Address: Carolina  
Affiliation: University of North  
Abstract: A general multi-user undo/redo model must satisfy several requirements. It must be compatible with an existing single-user undo/redo model, give individual users autonomy in executing undo/redo commands, support undo/redo of remote commands and the remote effects of local commands, be independent of the coupling, multicast, and concurrency control model, and allow undo/redo of arbitrary commands. We have developed a multi-user undo/redo model for meeting these requirements. The model constructs the command history of a particular user by including all local commands and those remote commands whose results were made visible to that user. It allows a user to undo/redo corresponding commands in the command histories of all users of a program. Moreover, it allows a user to undo/redo both symmetric user-interface commands and asymmetric collaboration commands. We have implemented the model in a collaboration system called Suite. In this paper, we motivate, describe, and illustrate these requirements and our model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. D. Abowd and A. J. Dix. </author> <title> Giving Undo Attention Interacting Comput., </title> <booktitle> 4(3) </booktitle> <pages> 317-342. </pages>
Reference-contexts: Conclusion The contributions of this paper are a set of undo/redo requirements, a design that meets these requirements, and several detailed examples to motivate and illustrate the requirements and the design. Multiuser undo/redo has also been addressed by other works <ref> [10, 3, 1] </ref>. These works and our model, which were developed independently and simultaneously, address mostly different issues arising in the design of multiuser undo/redo. In particular, none of these works addresses the undo issues that arise in a collaborative system allowing the histories of different users to diverge.
Reference: [2] <author> James E. Archer, Jr., Richard Conway, and Fred B. Schneider. </author> <title> User recovery and reversal in interactive systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 1-19, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Introduction Undo/redo is an important interactive feature whose absence seriously degrades the usability of an interactive program. It provides automatic support for recovery from user errors and misunderstandings as well as a mechanism for exploring alternatives [11]. It is offered in some form or another by most popular single-user programs <ref> [2, 12, 13, 14] </ref>. But few of the multi-user programs known to us offer this feature although it is crucial in a group setting for several reasons. First, features available to users in the single-user case must also be available in the multi-user case. <p> The model determines how command histories of the users of a multi-user program are constructed, which commands are undone/redone by an undo/redo request from a particular user, and which users can undo/redo a command. It is an extension of the linear single-user undo/redo model <ref> [2, 14] </ref>. It constructs the command history of a particular user by including all local commands and the remote commands whose results were made visible to that user. It allows a user to undo/redo corresponding commands in the command histories of all users of a program.
Reference: [3] <editor> Thomas Berlage A selective undo mechanism for graphical user interfaces. </editor> <booktitle> ACM Transactions on Computer-Human Interaction, </booktitle> <volume> 1(3) </volume> <pages> 269-294. </pages>
Reference-contexts: Conclusion The contributions of this paper are a set of undo/redo requirements, a design that meets these requirements, and several detailed examples to motivate and illustrate the requirements and the design. Multiuser undo/redo has also been addressed by other works <ref> [10, 3, 1] </ref>. These works and our model, which were developed independently and simultaneously, address mostly different issues arising in the design of multiuser undo/redo. In particular, none of these works addresses the undo issues that arise in a collaborative system allowing the histories of different users to diverge.
Reference: [4] <author> Rajiv Choudhary and Prasun Dewan. </author> <title> Multi-user undo/redo. </title> <type> Technical Report SERC-TR-125-P, </type> <institution> Purdue University, </institution> <year> 1992. </year>
Reference-contexts: For instance, we have not discussed what happens if a user asks the application to compute the indirect costs of the budget and then wants to undo this computations. We address this issue in <ref> [4] </ref>. Acknowledgments We would like to thank the reviewers for their detailed comments, which helped us improve the presentation of the paper. We would also like to thank the reviewer who pointed out the problem of a command conflicting with only a subset of the histories that share it.
Reference: [5] <author> Prasun Dewan and Rajiv Choudhary. </author> <title> Flexible user interface coupling in collaborative systems. </title> <booktitle> In Proceedings of the ACM CHI'91 Conference, </booktitle> <pages> pages 41-49. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: We have implemented this model as part of a system called Suite <ref> [5] </ref>. In this paper, we motivate, describe, and illustrate our undo/redo model using the concrete example of Suite. The remainder of the paper is organized as follows. Section 2 outlines the set of multi-user undo/redo requirements we have identified. <p> We did not choose the alternative approach of requiring a user to lock the system before an undo/redo since that would increase the overhead of executing all undos/redos. Selective Command Sharing Now consider a system that provides non-WYSIWIS coupling <ref> [5, 9] </ref>, that is, does not require the results of all commands to be shared immediately with all users. <p> This is illustrated in the corresponding (non-last) command in the interface of user pd. Undo/Redo of Asymmetric Commands So far, our model has addressed undo/redo of only symmetric commands - commands that have the same effect on local and remote user interfaces. Some non-WYSIWIS systems such as Suite <ref> [5] </ref>, also provide asymmetric commands, commands that trigger the execution of previous commands in the local history in the user-interfaces of other users. These commands are asymmetric since the previous commands are not (re)executed in the local user interface. <p> To illustrate the nature of these commands, consider the Suite Transmit command, which transmits to other users commands in the local history that have not been shared with these users. The set of local commands transmitted to a remote user is determined by the Suite coupling scheme <ref> [5] </ref>. Continuing with the example, if user pd executes this command, his change to the Travel field, which has not been shared so far with user rxc (Figures 9 and 10), is now transmitted to rxc (Figure 11).
Reference: [6] <author> W. D. Elliot, W. A. Potas, and A. van Dam. </author> <title> Computer assisted tracing of text evolution. </title> <booktitle> In Proceedings of the AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 533-540, </pages> <year> 1971. </year>
Reference-contexts: In particular, it does not attempt to find conflicts that arise in the undo of a non-last command between the command be undone and subsequent commands in the history that are not be undone <ref> [6, 10] </ref>. The design described in this paper is only a first step towards a general multi-user undo/redo model and we propose to address the conflict issue in our future work.
Reference: [7] <author> R. F. Gordon, G. B. Leeman, and C. H. Lewis. </author> <title> Concepts and implications of undo for interactive recovery. </title> <booktitle> In Proceedings of the 1985 ACM Annual Conference, </booktitle> <pages> pages 150-157. </pages> <address> ACM New York, </address> <year> 1985. </year>
Reference: [8] <author> George B. Leeman, Jr. </author> <title> A formal approach to undo operations in programming languages. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 50-87, </pages> <month> January </month> <year> 1986. </year>
Reference: [9] <author> C.M. Neuwirth, D.S. Kaufer, R. Chandhok, and J. H. Morris. </author> <title> Computer support for distributed collaborative writing: defining parameters of interaction. </title> <booktitle> In Proceedings of CSCW'94, </booktitle> <pages> pages 145-152, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: We did not choose the alternative approach of requiring a user to lock the system before an undo/redo since that would increase the overhead of executing all undos/redos. Selective Command Sharing Now consider a system that provides non-WYSIWIS coupling <ref> [5, 9] </ref>, that is, does not require the results of all commands to be shared immediately with all users.
Reference: [10] <author> Atul Prakash and Michael J. Knister. </author> <title> A framework for undoing actions in collaborative systems. </title> <journal> ACM Transactions on Computer-Human Interaction, </journal> <volume> 1(4) </volume> <pages> 295-330, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: In general, as discussed in detail in <ref> [10] </ref>, before undoing/redoing a non-last history command, subsequent commands in the history that depend on it must be considered. Our system, currently, does not attempt to detect conflicts. We illustrate our modified undo/redo model with a continuation of the previous example. <p> Conclusion The contributions of this paper are a set of undo/redo requirements, a design that meets these requirements, and several detailed examples to motivate and illustrate the requirements and the design. Multiuser undo/redo has also been addressed by other works <ref> [10, 3, 1] </ref>. These works and our model, which were developed independently and simultaneously, address mostly different issues arising in the design of multiuser undo/redo. In particular, none of these works addresses the undo issues that arise in a collaborative system allowing the histories of different users to diverge. <p> In particular, it does not attempt to find conflicts that arise in the undo of a non-last command between the command be undone and subsequent commands in the history that are not be undone <ref> [6, 10] </ref>. The design described in this paper is only a first step towards a general multi-user undo/redo model and we propose to address the conflict issue in our future work.
Reference: [11] <author> Herold Thimbleby. </author> <title> User Interface Design. </title> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Introduction Undo/redo is an important interactive feature whose absence seriously degrades the usability of an interactive program. It provides automatic support for recovery from user errors and misunderstandings as well as a mechanism for exploring alternatives <ref> [11] </ref>. It is offered in some form or another by most popular single-user programs [2, 12, 13, 14]. But few of the multi-user programs known to us offer this feature although it is crucial in a group setting for several reasons.
Reference: [12] <author> Jeffery Scott Vitter. US&R: </author> <title> A new framework for Redoing. </title> <journal> IEEE Software, </journal> <volume> 1(4) </volume> <pages> 39-52, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: Introduction Undo/redo is an important interactive feature whose absence seriously degrades the usability of an interactive program. It provides automatic support for recovery from user errors and misunderstandings as well as a mechanism for exploring alternatives [11]. It is offered in some form or another by most popular single-user programs <ref> [2, 12, 13, 14] </ref>. But few of the multi-user programs known to us offer this feature although it is crucial in a group setting for several reasons. First, features available to users in the single-user case must also be available in the multi-user case.
Reference: [13] <author> Haiying Wang and Mark Green. </author> <title> An event-object recovery model for object-oriented user interfaces. </title> <booktitle> In Proceedings of the ACM Symposium on User Interface Software and Technology, </booktitle> <pages> pages 107-115, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Introduction Undo/redo is an important interactive feature whose absence seriously degrades the usability of an interactive program. It provides automatic support for recovery from user errors and misunderstandings as well as a mechanism for exploring alternatives [11]. It is offered in some form or another by most popular single-user programs <ref> [2, 12, 13, 14] </ref>. But few of the multi-user programs known to us offer this feature although it is crucial in a group setting for several reasons. First, features available to users in the single-user case must also be available in the multi-user case. <p> It must also support undoing of collaboration commands. We describe below the model we have designed to meet these requirements. Single-User Interactive Undo/Redo Our multi-user undo/redo model is based on a minor variation of the linear single-user undo/redo model <ref> [13] </ref>, which is provided in some popular tools such as the InterViews idraw editor. The model maintains a history list of ex-ecuted commands and provides undo/redo/skip commands. These commands are metacommands, that is, they are themselves not added to the list.
Reference: [14] <institution> Xerox PARC, </institution> <address> Palo Alto, CA. </address> <note> INTERLISP Reference Manual, </note> <month> December </month> <year> 1975. </year>
Reference-contexts: Introduction Undo/redo is an important interactive feature whose absence seriously degrades the usability of an interactive program. It provides automatic support for recovery from user errors and misunderstandings as well as a mechanism for exploring alternatives [11]. It is offered in some form or another by most popular single-user programs <ref> [2, 12, 13, 14] </ref>. But few of the multi-user programs known to us offer this feature although it is crucial in a group setting for several reasons. First, features available to users in the single-user case must also be available in the multi-user case. <p> The model determines how command histories of the users of a multi-user program are constructed, which commands are undone/redone by an undo/redo request from a particular user, and which users can undo/redo a command. It is an extension of the linear single-user undo/redo model <ref> [2, 14] </ref>. It constructs the command history of a particular user by including all local commands and the remote commands whose results were made visible to that user. It allows a user to undo/redo corresponding commands in the command histories of all users of a program.
References-found: 14

