URL: http://www.cs.utexas.edu/users/kornerup/oddeven.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/kornerup/kornerup-papers.html
Root-URL: http://www.cs.utexas.edu
Email: E-mail: kornerup@cs.utexas.edu  
Title: Odd-Even Sort in Powerlists  
Author: Jacob Kornerup 
Keyword: Program derivation; Parallel algorithms; Functional programming; Programming calculi.  
Note: November 7, 1996  
Address: Austin  
Affiliation: Department of Computer Sciences The University of Texas at  
Abstract-found: 0
Intro-found: 1
Reference: [0] <author> W. E. Adams. </author> <title> Verifying adder circuits using powerlists. </title> <type> Technical Report CS-TR-94-02, </type> <institution> University of Texas at Austin, Department of Computer Sciences, </institution> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: In contrast to Misra's presentation [6] of Batcher's networks, we derive the odd-even sort, and our proofs of correctness do not use the 0-1 principle. 1 Preliminaries In this paper we use the notation and concepts that exist in the literature on powerlists <ref> [0, 4, 6] </ref>. As a convenience to the reader we give a brief introduction to the powerlist notation below. A powerlist is a linear data structure, whose elements are all of the same data type. The length of a powerlist is always a power of two. <p> and # (for minimum) are defined by: (8x; y : x; y 2 M : x " y = y x y) (12) (8x : x 2 M : ? x ^ x &gt; ) (14) In order to derive the algorithm we define the operators ! ("right-shift") and ("left-shift") <ref> [0] </ref>: x!(p ./ q) = x!q ./ p ^ x!hai = hx i (15) 1 The operator ! takes a scalar and a powerlist as arguments, and returns the list obtained by shifting all the elements of the supplied list one position to the right and inserting the scalar as the
Reference: [1] <author> K. Batcher. </author> <title> Sorting networks and their application. </title> <booktitle> In Proceedings of the AFIPS Spring Joint Computer Conference, </booktitle> <volume> volume 32, </volume> <pages> pages 307-314, </pages> <address> Reston, Va, 1968. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: 0 Introduction In [6] Misra introduced the powerlist notation and used it to succintly describe several parallel algorithms. In particular, algorithms that use a balanced divide and conquer strategy have elegant descriptions as powerlist functions. Among the examples presented were two sorting networks due to Batcher <ref> [1] </ref>. To prove their correctness a-posteriori, Misra used the 0-1 principle, which states that a compare-and-swap sorting algorithm is correct iff it sorts all inputs consisting of 0s and 1s. Misra attributed the 0-1 principle to Knuth [3], where Batcher's networks are presented.
Reference: [2] <author> C.-H. Huang and C. Lengauer. </author> <title> The automated proof of a trace transformation for a bitonic sort. </title> <journal> Theoretical Computer Science, </journal> (46):261-284, 1986. 
Reference-contexts: Misra attributed the 0-1 principle to Knuth [3], where Batcher's networks are presented. One of Batcher's networks, the Bitonic Sort, can be derived as a parallel algorithm, as shown by Huang and Lengauer <ref> [2] </ref>. In this paper we study the odd-even sort which can be considered a parallel version of bubble sort; it is simple to implement and to explain operationally, yet it is inefficient and somewhat tedious to prove correct 0 .
Reference: [3] <author> D. E. Knuth. </author> <title> The Art of computer programming, Vol. 3 : Sorting and Searching. </title> <booktitle> Series in Computer Science and Information Processing. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1973. </year>
Reference-contexts: Among the examples presented were two sorting networks due to Batcher [1]. To prove their correctness a-posteriori, Misra used the 0-1 principle, which states that a compare-and-swap sorting algorithm is correct iff it sorts all inputs consisting of 0s and 1s. Misra attributed the 0-1 principle to Knuth <ref> [3] </ref>, where Batcher's networks are presented. One of Batcher's networks, the Bitonic Sort, can be derived as a parallel algorithm, as shown by Huang and Lengauer [2]. <p> Powerlists of equal length with elements from the same data type are called similar. Two similar powerlists, p; q, can be combined into a powerlist of twice their lengths in two different ways: 0 As a parallel sorting technique the odd-even sort is well established in the literature. Knuth <ref> [3, exercise 5.3.4.37] </ref> poses the its proof of correctness as an exercise. 0 * p j q (p "tie" q) is the powerlist that consists of the elements of p (in order) followed by the elements of q (also in order); * p ./ q (p "zip" q) is the powerlist
Reference: [4] <author> J. Kornerup. </author> <title> Mapping a functional notation for parallel programs onto hypercubes. </title> <journal> Information Processing Letters, </journal> <volume> 53 </volume> <pages> 153-158, </pages> <year> 1995. </year>
Reference-contexts: In contrast to Misra's presentation [6] of Batcher's networks, we derive the odd-even sort, and our proofs of correctness do not use the 0-1 principle. 1 Preliminaries In this paper we use the notation and concepts that exist in the literature on powerlists <ref> [0, 4, 6] </ref>. As a convenience to the reader we give a brief introduction to the powerlist notation below. A powerlist is a linear data structure, whose elements are all of the same data type. The length of a powerlist is always a power of two.
Reference: [5] <author> F. T. Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays * Trees * Hypercubes. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA 94403, </address> <year> 1992. </year>
Reference-contexts: The algorithm consists of a sequence of phases, where each phase consists of an "even" step followed by an "odd" step. It is often described operationally as follows <ref> [5] </ref>: At odd steps, we compare the contents of cells 1 and 2, 3 and 4, etc., exchanging values if necessary so that the smaller value ends up in the leftmost cell. At even steps, we perform the same operation for cells 2 and 3, 4 and 5, etc.
Reference: [6] <author> J. Misra. Powerlist: </author> <title> A structure for parallel recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1737-1767, </pages> <month> Nov. </month> <year> 1994. </year> <month> 8 </month>
Reference-contexts: 0 Introduction In <ref> [6] </ref> Misra introduced the powerlist notation and used it to succintly describe several parallel algorithms. In particular, algorithms that use a balanced divide and conquer strategy have elegant descriptions as powerlist functions. Among the examples presented were two sorting networks due to Batcher [1]. <p> The remaining proof of correctness consists of proving that after a finite number of phases of the computation, odd-even sort reaches a fixpoint, and that each phase produces a permutation of the input. In contrast to Misra's presentation <ref> [6] </ref> of Batcher's networks, we derive the odd-even sort, and our proofs of correctness do not use the 0-1 principle. 1 Preliminaries In this paper we use the notation and concepts that exist in the literature on powerlists [0, 4, 6]. <p> In contrast to Misra's presentation [6] of Batcher's networks, we derive the odd-even sort, and our proofs of correctness do not use the 0-1 principle. 1 Preliminaries In this paper we use the notation and concepts that exist in the literature on powerlists <ref> [0, 4, 6] </ref>. As a convenience to the reader we give a brief introduction to the powerlist notation below. A powerlist is a linear data structure, whose elements are all of the same data type. The length of a powerlist is always a power of two.
References-found: 7

