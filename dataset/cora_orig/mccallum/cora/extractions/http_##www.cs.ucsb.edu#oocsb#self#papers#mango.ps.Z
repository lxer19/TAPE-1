URL: http://www.cs.ucsb.edu/oocsb/self/papers/mango.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/mango.html
Root-URL: http://www.cs.ucsb.edu
Email: email address: ole.agesen@eng.sun.com  
Title: Mango: A Parser Generator for Self a realistic tool. A parser for full ANSI C
Author: Ole Agesen Mango. 
Address: M/S 29-01 2550 Garcia Avenue Mountain View, CA 94043  
Note: Mango is  
Date: June 1994  
Pubnum: SMLI TR-94-27  
Abstract: Mango is a parser generator that is included in Release 3.0 of the Self system. Mango goes beyond LEX/YACC in several respects. First, Mango grammars are structured, thus easier to read and map onto parse trees. Second, Mango parsers automatically build parse trees rather than merely provide hooks for calling low-level reduce actions during parsing. Third, Mango automatically maintains invariance of the structure of parse trees, even while grammars are transformed to enable LR parsing. Fourth, Mango and the parsers it generates are completely integrated in the Self object world. In particular, a parser is an object. Unlike YACC, several independent parsers can co-exist in a single program. We show how to generate a Mango parser and how to use it by means of an example: a simple expression language. Furthermore, we show how to add semantic properties to the parse trees that the Mango parser produces. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A. V., R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <address> Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Secondarily, the person who is designing an object-oriented parser generator may benefit from reading the discussion sections. We assume some familiarity with parsing terminology and technology such as is described in the dragon book <ref> [1] </ref>. Experience with the use of other parser generators, e.g., LEX/ YACC [2], is also an advantage. Like YACC, Mango generates lexers and parsers that take streams of characters as input and deliver streams of tokens or parse trees as output. <p> Mango generates a parser from a structured grammar in two steps. First, it expands the structured grammar into an unstructured grammar. The structured and unstructured gram 5 mars both define the same language. Second, Mango uses standard techniques to generate a parser from the unstructured grammar <ref> [1] </ref>. 2.1 Structured vs. unstructured grammars Structured grammars are often easier to read than unstructured grammars, because common idioms such as lists and optionals are expressed directly using an easily recognized syntax. <p> The parse tree resulting from parsing this string is the standard derivation tree as described in <ref> [1] </ref>. It has an interior node for each nonterminal expanded in the derivation and a leaf node for each terminal in the string. The root of the parse tree will correspond to the first production used (the start production).
Reference: 2. <author> Johnson, S. C. </author> <title> YACCYet Another Compiler Compiler. </title> <institution> AT&T Bell Laboratories Computing Science Technical Report 32 (1978). </institution>
Reference-contexts: Secondarily, the person who is designing an object-oriented parser generator may benefit from reading the discussion sections. We assume some familiarity with parsing terminology and technology such as is described in the dragon book [1]. Experience with the use of other parser generators, e.g., LEX/ YACC <ref> [2] </ref>, is also an advantage. Like YACC, Mango generates lexers and parsers that take streams of characters as input and deliver streams of tokens or parse trees as output.
Reference: 3. <author> Kernighan, B. W. and D. M. Ritchie. </author> <title> The C Programming Language. 2d edition. </title> <address> New Jersey: </address> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Use of the parser is also demonstrated. The parse trees produced by Mango parsers are described in Section 4. Section 5 describes how keywords such as THEN and PROCEDURE in Pascal are recognized by a Mango parser. Section 6 introduces a Mango parser for ANSI C <ref> [3] </ref>. This parser can be used as a skeleton for implementing grammar-based tools for ANSI C. It also constitutes a large concrete example for study. Section 7 gives an overview of the files that implement Mango. <p> The parser is based on the grammar found in the book by Kernighan and Ritchie <ref> [3] </ref>. The grammar in the book is unstructured; the grammar in Ansi-C.grm is a structured version of it. There is currently no behavior added to the grammar (except what is needed for parsing, as described below). <p> Adding behavior to this grammar would be a quick way to get started writing grammar-based C tools. The structured and unstructured ANSI C grammars are similar (although there is one exception which is explained below). For example, in <ref> [3] </ref> the unstructured productions for expressions include: &lt;exclusive_OR_exp&gt; fi &lt;AND_exp&gt; | &lt;exclusive_OR_exp&gt; '^' <AND_exp> ; &lt;AND_exp&gt; fi &lt;equality_exp&gt; | &lt;AND_exp&gt; '&' <equality_exp> ; &lt;equality_exp&gt; fi &lt;relational_exp&gt; | &lt;equality_exp&gt; '==' <relational_exp> | &lt;equality_exp&gt; '!=' <relational_exp> ; &lt;relational_exp&gt; fi &lt;shift_exp&gt; | &lt;relational_exp&gt; '<' &lt;shift_exp&gt; | &lt;relational_exp&gt; '>' &lt;shift_exp&gt; | &lt;relational_exp&gt; '<=' &lt;shift_exp&gt; | <p> The ability to cope with C demonstrates clearly that Mango is a robust tool. The C parser is interesting on its own since it gives the full picture of the C syntax. Specifically, we started with the C grammar in the standard C reference <ref> [3] </ref>, but had to address two major issues before we had a satisfactory parser. First, we restructured the grammar to correct a deficiency that would otherwise allow illegal C type declarations with multiple type names to be derived. <p> Second, we resolved the typedef ambiguity by timely supplying context dependent information to the parser. The restructured grammar and the Self code that collects the context dependent information is given in the appendix. Neither of these issues are addressed in Kernighan and Ritchies The C Programming Language <ref> [3] </ref>. 28 10 Acknowledgments The author would like to thank David Ungar and Mario Wolczko for comments on an earlier draft of this paper. Also, thanks to the Self group in general for many useful discussions.
Reference: 4. <author> Knudsen, J. L., O. L. Madsen, C. Nrgaard, L. B. Petersen, and E. S. Sandvad. </author> <title> An Overview of the Mjlner BETA System. </title> <booktitle> Proceedings on Conference on Software Engineering Environments (SEE91) (1991). </booktitle>
Reference-contexts: The separator is again optional. Optional: A ::? E The nonterminal A derives E or e. The concept of structured grammars is described in detail in An Object-Oriented Metapro-gramming System [5]. Structured grammars, in fact, are the basis of the Mjlner programming environment <ref> [4] </ref>. The semantics of structured productions may be precisely defined in terms of equivalent unstructured productions. Table 1 shows the expansions used by Mango. If a list production has no separator, simply leave out the separator from the expansion given in the table.
Reference: 5. <author> Madsen, O. L., and C. Nrgaard. </author> <title> An Object-Oriented Metaprogramming System. </title> <booktitle> Proceedings of the Twenty-First Annual Hawaii International Conference on System Sciences (January 1988): </booktitle> <pages> 406415. </pages>
Reference-contexts: The separator is again optional. Optional: A ::? E The nonterminal A derives E or e. The concept of structured grammars is described in detail in An Object-Oriented Metapro-gramming System <ref> [5] </ref>. Structured grammars, in fact, are the basis of the Mjlner programming environment [4]. The semantics of structured productions may be precisely defined in terms of equivalent unstructured productions. Table 1 shows the expansions used by Mango.
Reference: 6. <author> Roskind, J. </author> <title> ANSI C and C++ Grammars. Suitable for YACC parsing. </title> <note> Available by anonymous ftp from ics.uci.edu (128.195.1.1) in the ftp/gnu directory. Alternative site: mach.1.npac.syr.edu (128.230.7.14) in the ftp/pub/C++ directory. 29 </note>
Reference-contexts: Structured productions and their expansion into unstructured productions. 6 mediate unstructured grammar from the user of Mango, we have not taken this step, mostly due to lack of time. James Roskinds C and C++ grammars <ref> [6] </ref> are good examples of how the low-level nature of unstructured grammars may be exploited. He has written unstructured grammars that are well suited for LALR (1) parsing in the sense that there are few conicts in the parse tables.
References-found: 6

