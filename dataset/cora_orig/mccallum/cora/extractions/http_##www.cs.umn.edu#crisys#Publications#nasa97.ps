URL: http://www.cs.umn.edu/crisys/Publications/nasa97.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Email: heimdahl@cs.umn.edu  
Title: Verifying Communication Constraints in RSML Specifications  
Author: Mats P.E. Heimdahl 
Date: 1003-521-5965.  
Note: This work has been partially supported by NSF grant CCR-9624324 and University of Minnesota Grant in Aid of Research  
Address: Minneapolis, MN 55455  
Affiliation: University of Minnesota, Institute of Technology Department of Computer Science, 4-192 EE/CS Bldg.  
Abstract: Languages based on hierarchical finite state machines, for example, Statecharts, SCR (Software Cost Reduction), and the Requirements State Machine Language (RSML), are suitable for specification of software for embedded systems. The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support execution and dynamic evaluation of the specifications. However, the support to rigorously specify and analyze the communication between physically distinct components in a system is currently not well supported in either of the approaches. We know that the interfaces between the software and the embedding environment is a major source of costly errors. For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware. In this paper we introduce a formal approach to the specification of system level inter-component communication and show how this formalism can be used to prove certain types of safety and liveness constraints. The interface definitions and the constraints are translated to PVS (Prototype Verification System) proof obligations, and the proofs of compliance with the constraints are performed in the PVS domain. To demonstrate the feasibility of the approach we have implemented a prototype tool and used the tool to prove some desirable properties of the inter-component communication of an avionics system. 
Abstract-found: 1
Intro-found: 1
Reference: [2] <author> J. Atlee and J. Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems. Software Engineering Notes. </booktitle> <volume> Volume 16 Number 5, </volume> <year> 1991. </year>
Reference-contexts: To assure that more complex properties hold in a specification, more powerful analysis approaches are needed. Several groups have attempted to apply model checking techniques to RSML and SCR. Atlee et al. reported success with applying the SMV model checker to SCR style specifications <ref> [2, 19] </ref>. In a similar effort, Anderson et al. have applied the SMV model checker to a part of the TCAS II RSML specification [1].
Reference: [3] <author> M. Chechik and J. Gannon. </author> <title> Automatic verification of requirements implementations. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 1-14, </pages> <year> 1994. </year>
Reference-contexts: To overcome such problems, many approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean <ref> [3, 4] </ref> or enumerated types [16]. Recently, we have addressed this problem in RSML by using PVS for the analysis and in that way enable interpretation of all terms in the Boolean expressions, including terms using linear and non-linear arithmetic.
Reference: [4] <author> M. Chechik and J. Gannon. </author> <title> Automatic analysis of consistency between implementations and requirements: A case study. </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <year> 1995. </year>
Reference-contexts: To overcome such problems, many approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean <ref> [3, 4] </ref> or enumerated types [16]. Recently, we have addressed this problem in RSML by using PVS for the analysis and in that way enable interpretation of all terms in the Boolean expressions, including terms using linear and non-linear arithmetic.
Reference: [5] <author> J. Crow, S. Owre, J. Rushby, et al. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In WIFT 95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <year> 1995. </year>
Reference-contexts: This approach greatly simplifies the proofs of certain safety and liveness constraints in complex state-based models. The interface definitions and the constraints are translated to PVS <ref> [5, 26, 27] </ref> proof obligations and the proofs of compliance with the constraints are performed in the PVS domain. <p> to: Action: Invalid-Intruder-ID-Event receive an invalid Mode-S-Address we must always raise an exception. section gives an example of the translation approach. 5 Generating Proof Obliga tions for PVS The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [5, 26, 27] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. To illustrate our approach, consider the interface definition in Figure 7 and the assertion in Figure 9.
Reference: [6] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Experience with formal methods in critical systems. </title> <journal> IEEE Software, </journal> <volume> vol-11(1):21-39, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches.
Reference: [7] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Formal methods reality check: Industrial usage. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 90-98, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches.
Reference: [8] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [8, 9, 10] </ref>, SCR (Software Cost Reduction) [17, 15], and the Requirements State Machine Language (RSML) [21], are powerful modeling languages suitable for specification of software for these types of systems. <p> The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Stat-echarts (Figure 1) <ref> [8, 11] </ref>. One of the main design goals of RSML was readability and understandability by non computer professionals such as, in our case, pilots, air frame manufacturers, and FAA representatives. During the TCAS project, we discovered that the guarding con ditions required to accurately capture the requirements were often complex.
Reference: [9] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [8, 9, 10] </ref>, SCR (Software Cost Reduction) [17, 15], and the Requirements State Machine Language (RSML) [21], are powerful modeling languages suitable for specification of software for these types of systems.
Reference: [10] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [8, 9, 10] </ref>, SCR (Software Cost Reduction) [17, 15], and the Requirements State Machine Language (RSML) [21], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches.
Reference: [11] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Stat-echarts (Figure 1) <ref> [8, 11] </ref>. One of the main design goals of RSML was readability and understandability by non computer professionals such as, in our case, pilots, air frame manufacturers, and FAA representatives. During the TCAS project, we discovered that the guarding con ditions required to accurately capture the requirements were often complex.

Reference: [13] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> TSE-22(6):363-377, </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches. <p> Both SCR and RSML allow a specification to be automatically checked for consistency (there are no conflicting requirements) and a notion of completeness (all possible input scenarios are handled by the specification) <ref> [13, 15] </ref>. Although this analysis has been used to detect problems in large specifications, the analysis procedures are rather limited. <p> that the input and output definitions are consistently and completely defined and (2) prove that some safety and liveness assertions always hold in the model. 4.1 Completeness and Consistency In a previous investigation, we defined a collection of analysis procedures that assures that an RSML specification is complete and consistent <ref> [13] </ref>. The notion of completeness and consistency extends to the interface definitions. In this paper it suffices to state the completeness and consistency rules informally: 1. Within an interface definition, every pair of handlers must have mutually exclusive guarding conditions; exactly one handler can be used at any time. 2. <p> This, however, is not the focus of the paper and the interested reader must be referred to <ref> [13, 12] </ref> for a rigorous treatment of this topic. 4.2 Safety and Liveness Verification In TCAS, a safety constraint may be that we cannot remove a Resolution-Advisory from the pilot's display as long at the intruder that caused the advisory to be generated is declared to be a Threat (Other-Aircraft in
Reference: [14] <author> M.P.E. Heimdahl and J.M. Thompson. </author> <title> Specification and analysis of system level inter-component communication. </title> <type> Technical report, </type> <institution> University of Minnesota, </institution> <year> 1996. </year>
Reference-contexts: Due to space constraints, a detailed description and discussion of our communication model will have to be left out of this paper. 2 The interested reader is referred to <ref> [14] </ref> for a detailed discussion. The focus of this report is on the analysis capabilities enabled by our approach to the specification of inter-component communication. <p> Due to space constraints, we cannot included the full definition of all primitives; we are limited to showing how interrupt driven communication is defined. The interested reader is referred to <ref> [14] </ref> for a complete definition. 3.1 Low-Level Foundation Shaw's notation is based on communicating finite state machines.
Reference: [15] <author> C. L. Heitmeyer, , R.D. Jeffords, and B. L. Labaw. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> vol-5(3):231-261, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [8, 9, 10], SCR (Software Cost Reduction) <ref> [17, 15] </ref>, and the Requirements State Machine Language (RSML) [21], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches. <p> Both SCR and RSML allow a specification to be automatically checked for consistency (there are no conflicting requirements) and a notion of completeness (all possible input scenarios are handled by the specification) <ref> [13, 15] </ref>. Although this analysis has been used to detect problems in large specifications, the analysis procedures are rather limited.
Reference: [16] <author> C. L. Heitmeyer, B. L. Labaw, and D. Kiskis. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <booktitle> In Proceedings of the International Symposium on Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: To overcome such problems, many approaches to static analysis enforce restrictions on the modeling language to facilitate accurate analysis, such as restricting variables to Boolean [3, 4] or enumerated types <ref> [16] </ref>. Recently, we have addressed this problem in RSML by using PVS for the analysis and in that way enable interpretation of all terms in the Boolean expressions, including terms using linear and non-linear arithmetic. In our work we want to avoid enforcing unnecessary confining restrictions on our modeling language.
Reference: [17] <author> K. L. Heninger. </author> <title> Specifying software for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 2-13, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [8, 9, 10], SCR (Software Cost Reduction) <ref> [17, 15] </ref>, and the Requirements State Machine Language (RSML) [21], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches.
Reference: [18] <author> M. S. Jaffe, N. G. Leveson, M. P.E. Heim-dahl, and B. Melhart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 241-258, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [24, 23, 20, 25, 18] </ref>. Thus, it is imperative that a requirements specification for an embedded software system rigorously captures the interfaces and the communication between the software and its embedding environment. The specification of high-level inter-component communication pose many interesting challenges.
Reference: [19] <author> J.M.Atlee and M.A. Buckley. </author> <title> A logic-model semantics for scr software requirements. </title> <editor> In S.J. Zeil, editor, </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA'97), </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: To assure that more complex properties hold in a specification, more powerful analysis approaches are needed. Several groups have attempted to apply model checking techniques to RSML and SCR. Atlee et al. reported success with applying the SMV model checker to SCR style specifications <ref> [2, 19] </ref>. In a similar effort, Anderson et al. have applied the SMV model checker to a part of the TCAS II RSML specification [1].
Reference: [20] <author> N. G. Leveson. </author> <title> Software safety: What, why, and how. </title> <journal> ACM Computing surveys, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1986. </year>
Reference-contexts: The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [24, 23, 20, 25, 18] </ref>. Thus, it is imperative that a requirements specification for an embedded software system rigorously captures the interfaces and the communication between the software and its embedding environment. The specification of high-level inter-component communication pose many interesting challenges.
Reference: [21] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 694-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [8, 9, 10], SCR (Software Cost Reduction) [17, 15], and the Requirements State Machine Language (RSML) <ref> [21] </ref>, are powerful modeling languages suitable for specification of software for these types of systems. The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications [6, 7, 21, 13, 15, 17, 10]. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation of the specifications <ref> [6, 7, 21, 13, 15, 17, 10] </ref>. However, the support for rigorous specification and analysis of 1 the communication between physically distinct com-ponents in a system is currently not well supported in either of the approaches. <p> The formalism is influenced by our previous experiences with using RSML to capture the requirements of a large avionics system <ref> [21] </ref>. We encapsulate information about the physical properties of the communication in an interface specification and encapsulate the definition of how incoming and outgoing messages are treated in communication handlers associated with the inter faces. <p> In our work we want to avoid enforcing unnecessary confining restrictions on our modeling language. RSML was successfully used to model a complex avionics system <ref> [21] </ref> and our experience from that effort convinced us that enforcing restrictions, such as the restrictions mentioned above, will limit the usability of the modeling language to a point where practitioners will find the language too restrictive to use. <p> A macro is simply a named and/or table defined elsewhere in the document. A detailed description of the full notation can be found in <ref> [21] </ref>. In RSML we view a system as a collection of components connected by communication channels. <p> To facilitate ease of specification and encapsulation we supply a high-level language based on our communication primitives. As a high-level interface description language we chose to use simple textual forms (Figure 7). Leveson et al. successfully used a similar approach when specifying the communication mechanisms for TCAS II <ref> [21] </ref>. The definitions in this paper are an extension and refinement of their approach. 3.3 Send-Receive Communication The interface definition in Figure 7 is adopted from TCAS II and defines how the TCAS box communicates with the pilot's display.
Reference: [22] <author> N.G. Leveson, T.J. Shimeall, J.L. Stolzy, and J.C. Thomas. </author> <title> Designing for safe software. </title> <booktitle> In Proceedings of the AIAA 21st Aerospace Sciences Meeting, </booktitle> <year> 1993. </year>
Reference-contexts: This approach to enforcement of constraints is not unique to our work. Leveson et al. discussed the use of a safety kernel to enforce safety policies in safety critical systems <ref> [22] </ref>. The kernel centralizes the enforcement of safety policies and detection/recovery of safety violation in one small easily verifiable component. The notion of safety kernels responsible for policy enforcement has been further discussed by Wika and Knight [30, 31].
Reference: [23] <author> R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SOGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware <ref> [24, 23] </ref>. The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated [24, 23, 20, 25, 18]. <p> The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [24, 23, 20, 25, 18] </ref>. Thus, it is imperative that a requirements specification for an embedded software system rigorously captures the interfaces and the communication between the software and its embedding environment. The specification of high-level inter-component communication pose many interesting challenges.
Reference: [24] <author> R. R. Lutz. </author> <title> Analyzing software requirements errors in safety-critical, embedded systems. </title> <booktitle> In Proceedings of the IEEE international symposium on requirements engineering, </booktitle> <pages> pages 35-46, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware <ref> [24, 23] </ref>. The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated [24, 23, 20, 25, 18]. <p> The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [24, 23, 20, 25, 18] </ref>. Thus, it is imperative that a requirements specification for an embedded software system rigorously captures the interfaces and the communication between the software and its embedding environment. The specification of high-level inter-component communication pose many interesting challenges.
Reference: [25] <author> B.E. Melhart. </author> <title> Specification and Analysis of the Requirements for Embedded Software with an External Interaction Model. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The problems often involve, for example, misunderstandings about how the hardware operates, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [24, 23, 20, 25, 18] </ref>. Thus, it is imperative that a requirements specification for an embedded software system rigorously captures the interfaces and the communication between the software and its embedding environment. The specification of high-level inter-component communication pose many interesting challenges.
Reference: [26] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: This approach greatly simplifies the proofs of certain safety and liveness constraints in complex state-based models. The interface definitions and the constraints are translated to PVS <ref> [5, 26, 27] </ref> proof obligations and the proofs of compliance with the constraints are performed in the PVS domain. <p> to: Action: Invalid-Intruder-ID-Event receive an invalid Mode-S-Address we must always raise an exception. section gives an example of the translation approach. 5 Generating Proof Obliga tions for PVS The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [5, 26, 27] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. To illustrate our approach, consider the interface definition in Figure 7 and the assertion in Figure 9.
Reference: [27] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: This approach greatly simplifies the proofs of certain safety and liveness constraints in complex state-based models. The interface definitions and the constraints are translated to PVS <ref> [5, 26, 27] </ref> proof obligations and the proofs of compliance with the constraints are performed in the PVS domain. <p> to: Action: Invalid-Intruder-ID-Event receive an invalid Mode-S-Address we must always raise an exception. section gives an example of the translation approach. 5 Generating Proof Obliga tions for PVS The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [5, 26, 27] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. To illustrate our approach, consider the interface definition in Figure 7 and the assertion in Figure 9.
Reference: [28] <author> J. Rushby. </author> <title> Safe and Secure Computing Systems, chapter Kernels for Safety?, </title> <address> pages 210-220. </address> <publisher> Blackwell Scientific Publications, </publisher> <year> 1989. </year>
Reference-contexts: These approaches, however, mainly address the design and implementation stages of development and do not discuss verification of safety properties in the high-level specification stage. Rushby has provided a detailed and formal discussion of the suitability of a kernel approach for safety enforcement <ref> [28] </ref>. He concluded that a kernel architecture is most suited to enforce negative properties, for example, that certain actions are not taken in some situations. A kernel approach is more limited when it comes to enforcing positive properties, for instance, that an action is always performed under certain conditions.
Reference: [29] <author> A. C. Shaw. </author> <title> Communicating real-time state machines. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9), </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: We build our formalism on top of an existing model defined by Alan Shaw as part of his work with Communicating Real-Time State Machines <ref> [29] </ref>. Using Shaw's model as a base, we define a collection of RSML communication primitives. We then provide a high level notation, built from the RSML primitives, suitable for the description of system level inter-component communication.
Reference: [30] <author> K.G. Wika. </author> <title> Safty Kernel Enforcement of Software Safety Policies. </title> <type> PhD thesis, </type> <institution> University of Virginia, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The kernel centralizes the enforcement of safety policies and detection/recovery of safety violation in one small easily verifiable component. The notion of safety kernels responsible for policy enforcement has been further discussed by Wika and Knight <ref> [30, 31] </ref>. These approaches, however, mainly address the design and implementation stages of development and do not discuss verification of safety properties in the high-level specification stage. Rushby has provided a detailed and formal discussion of the suitability of a kernel approach for safety enforcement [28].
Reference: [31] <author> K.G. Wika and J.C. Knight. </author> <title> On the enforcement of software safety policies. </title> <booktitle> In COMPASS Proceedings, </booktitle> <pages> pages 83-93, </pages> <year> 1995. </year> <month> 16 </month>
Reference-contexts: The kernel centralizes the enforcement of safety policies and detection/recovery of safety violation in one small easily verifiable component. The notion of safety kernels responsible for policy enforcement has been further discussed by Wika and Knight <ref> [30, 31] </ref>. These approaches, however, mainly address the design and implementation stages of development and do not discuss verification of safety properties in the high-level specification stage. Rushby has provided a detailed and formal discussion of the suitability of a kernel approach for safety enforcement [28].
References-found: 29

