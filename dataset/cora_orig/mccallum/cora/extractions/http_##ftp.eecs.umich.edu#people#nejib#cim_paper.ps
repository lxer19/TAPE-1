URL: http://ftp.eecs.umich.edu/people/nejib/cim_paper.ps
Refering-URL: http://ftp.eecs.umich.edu/people/nejib/
Root-URL: http://www.eecs.umich.edu
Title: Developing Control and Integration Software for Flexible Manufacturing Systems  
Author: Nejib Ben Hadj-Alouane Jarir K. Chaar Arch W. Naylor 
Keyword: computer-integrated manufacturing systems, automation, software components, models.  
Note: The names of the authors appear in alphabetical order  
Address: 1101 Beal Avenue Ann Arbor, MI 48109-2110  
Affiliation: Advanced Technologies Laboratory The University of Michigan  
Email: e-mail: nha@crim.eecs.umich.edu  e-mail: jkc@crim.eecs.umich.edu  e-mail: awn@crim.eecs.umich.edu  
Phone: phone: (313)-763-6842  phone: (313)-936-2830  phone: (313)-936-2974  
Date: February 22, 1995  
Abstract: The slow growth of computer-integrated manufacturing is attributed to the complexity of designing and implementing their control and integration software. This paper expands on a methodology for designing and implementing this software that was introduced in [15]. The goal of this methodology is to build flexible and reusable control and integration software for computer-integrated manufacturing systems. It hinges upon the concepts of software/hardware components, their assemblages, a distributed common language environment, formal models and generic controllers. Major sources of flexibility are obtained by decoupling process plan models from the model of the factory floor and by using a generic controller. Reusability is achieved by building self-contained software/hardware components with general, possibly parametrized, interfaces. The interplay between simulated and actual hardware internals of software/hardware components is used as the basis of a testing strategy that performs off-line simulation followed by on-line testing. The methodology has been applied in designing and implementing the control and integration software of an actual Prismatic Machining Cell. The paper also reports on the details of this implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Ben Hadj-Alouane, J. K. Chaar, and A. W. Naylor. </author> <title> The Design and Implementation of the Control and Integration Software of a Flexible Manufacturing System. </title> <booktitle> In The First International Conference on Systems Integration, </booktitle> <month> April 23-26 </month> <year> 1990. </year>
Reference-contexts: Furthermore, alternating between the simulations and the actual devices is easily done and follows naturally from our use of software/hardware components. The concepts of our methodology have been presented in <ref> [1, 10, 15] </ref>. Furthermore, these concepts have been validated by applying it to the design and implementation of the control software of several systems [1, 2]. <p> The concepts of our methodology have been presented in [1, 10, 15]. Furthermore, these concepts have been validated by applying it to the design and implementation of the control software of several systems <ref> [1, 2] </ref>. This paper reports on the application of this methodology to the design and implementation of the control and integration software of a full-fledged real manufacturing system: a Prismatic Machining Cell of a major automobile manufacturer.
Reference: [2] <author> N. Ben Hadj-Alouane, J. K. Chaar, A. W. Naylor, and R. A. Volz. </author> <title> Material handling systems as software components: An implementation. </title> <type> Technical Report RSD-TR-10-88, </type> <institution> Robot Systems Division The University of Michigan, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The concepts of our methodology have been presented in [1, 10, 15]. Furthermore, these concepts have been validated by applying it to the design and implementation of the control software of several systems <ref> [1, 2] </ref>. This paper reports on the application of this methodology to the design and implementation of the control and integration software of a full-fledged real manufacturing system: a Prismatic Machining Cell of a major automobile manufacturer. <p> In reality, however, many systems require interacting with their external environments. As a result, it may seem that their software/hardware components cannot be made reusable. Fortunately, this is not the case. A solution enforcing one-way naming while still allowing components to interact with their environments is provided in <ref> [2] </ref>. This solution is detailed below due to the surprisingly important role one-way naming plays in designing and implementing reusable software/hardware components. The nature of the one-way naming problem is a function of the interaction of a software/hardware component with its environment. Two different situations can be identified.
Reference: [3] <author> G. Booch. </author> <title> Software Components with Ada: Structures, Tools, and Subsystems. </title> <publisher> The Ben-jamin/Cummings Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: Our starting point is the claim that many would agree with that current practices for such software are archaic and often result in a high cost, an extended development period, and extremely inflexible systems. We argue as many have <ref> [3] </ref> that the key is software reusability based on the careful design of software components and their assemblages. However, we go beyond these customary ideas to argue that developing reusable software for the real-time distributed control of computer-integrated manufacturing systems requires additional concepts and approaches. <p> A software/hardware component is a generalized version of a software component [15]. A software component is an object-oriented construct that is characterized by a set of public software interfaces and a body (internals) <ref> [3] </ref>. A software interface specifies a set of services that can be performed by this component. Users can capture a distinct view of the component by accessing the services in a subset of its software interfaces. The internals of the component implement the services listed in its interfaces.
Reference: [4] <author> G. Bruno. </author> <title> Using ada for discrete event simulation. </title> <journal> Software Practice and Experience, </journal> <volume> 14(7) </volume> <pages> 685-695, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: PROT nets are extensions to Petri nets that associate attributes with tokens and model hierarchy by enclosing other PROT nets in net transitions. PROT nets are translated into Ada program structures to be used as the basis for control software prototyping <ref> [4, 5, 7] </ref>. The same nets can be translated into OPS5 rules to derive a production schedule for the system [6, 8, 9]. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation.
Reference: [5] <author> G. Bruno and A. Balsamo. </author> <booktitle> Petri net-based object-oriented modeling of distributed systems. In OOPSLA'86: Object-Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <pages> pages 284-293, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> The most popular models of manufacturing systems are based on extensions of Petri Nets [5, 7, 11, 12, 13, 16, 17]. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets <ref> [5, 7] </ref>. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> Both conditions and actions are coded as C expressions and procedures respectively. A methodology based on Process Translatable (PROT) nets that supports the specification, rapid prototyping and simulation of manufacturing systems is reported in <ref> [5, 7] </ref>. PROT nets are extensions to Petri nets that associate attributes with tokens and model hierarchy by enclosing other PROT nets in net transitions. PROT nets are translated into Ada program structures to be used as the basis for control software prototyping [4, 5, 7]. <p> PROT nets are extensions to Petri nets that associate attributes with tokens and model hierarchy by enclosing other PROT nets in net transitions. PROT nets are translated into Ada program structures to be used as the basis for control software prototyping <ref> [4, 5, 7] </ref>. The same nets can be translated into OPS5 rules to derive a production schedule for the system [6, 8, 9]. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation.
Reference: [6] <author> G. Bruno and A. Elia. </author> <title> Operational specification of process control systems: Execution of prot nets using ops5. </title> <editor> In H. J. Kugler, editor, </editor> <booktitle> Information Processing (IFIP) 86, </booktitle> <pages> pages 35-40, </pages> <year> 1986. </year>
Reference-contexts: PROT nets are translated into Ada program structures to be used as the basis for control software prototyping [4, 5, 7]. The same nets can be translated into OPS5 rules to derive a production schedule for the system <ref> [6, 8, 9] </ref>. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation. This intermix results in a rigid cell controller, i.e., a change in a process plan or the control strategy calls for major changes in the controller.
Reference: [7] <author> G. Bruno and G. Marchetto. </author> <title> Process-translatable petri nets for the rapid prototyping of process control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):346-357, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> The most popular models of manufacturing systems are based on extensions of Petri Nets [5, 7, 11, 12, 13, 16, 17]. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets <ref> [5, 7] </ref>. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> Both conditions and actions are coded as C expressions and procedures respectively. A methodology based on Process Translatable (PROT) nets that supports the specification, rapid prototyping and simulation of manufacturing systems is reported in <ref> [5, 7] </ref>. PROT nets are extensions to Petri nets that associate attributes with tokens and model hierarchy by enclosing other PROT nets in net transitions. PROT nets are translated into Ada program structures to be used as the basis for control software prototyping [4, 5, 7]. <p> PROT nets are extensions to Petri nets that associate attributes with tokens and model hierarchy by enclosing other PROT nets in net transitions. PROT nets are translated into Ada program structures to be used as the basis for control software prototyping <ref> [4, 5, 7] </ref>. The same nets can be translated into OPS5 rules to derive a production schedule for the system [6, 8, 9]. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation.
Reference: [8] <author> G. Bruno and M. Morisio. </author> <title> Petri-net based simulation of manufacturing cells. </title> <booktitle> In 1987 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1174-1179, </pages> <month> March </month> <year> 1987. </year> <month> 32 </month>
Reference-contexts: PROT nets are translated into Ada program structures to be used as the basis for control software prototyping [4, 5, 7]. The same nets can be translated into OPS5 rules to derive a production schedule for the system <ref> [6, 8, 9] </ref>. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation. This intermix results in a rigid cell controller, i.e., a change in a process plan or the control strategy calls for major changes in the controller.
Reference: [9] <author> G. Bruno and M. Morisio. </author> <title> The role of rule based programming for production scheduling. </title> <booktitle> In 1987 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 545-550, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: PROT nets are translated into Ada program structures to be used as the basis for control software prototyping [4, 5, 7]. The same nets can be translated into OPS5 rules to derive a production schedule for the system <ref> [6, 8, 9] </ref>. A major shortcoming of the above approaches is the intermix in their models of process plans, control and cell operation. This intermix results in a rigid cell controller, i.e., a change in a process plan or the control strategy calls for major changes in the controller.
Reference: [10] <author> J. K. Chaar and R. A. Volz. </author> <title> On the Ada Implementation of a Component-Oriented Rule-Based Specification Language for Manufacturing Systems Control Software. </title> <booktitle> In Proceedings of the Fifth Annual Conference on Artificial Intelligence and Ada (AIDA-89), </booktitle> <pages> pages 39-50, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Furthermore, alternating between the simulations and the actual devices is easily done and follows naturally from our use of software/hardware components. The concepts of our methodology have been presented in <ref> [1, 10, 15] </ref>. Furthermore, these concepts have been validated by applying it to the design and implementation of the control software of several systems [1, 2].
Reference: [11] <author> D. Crockett, A. Desrochers, F. DiCesare, and T. Ward. </author> <title> Implementation of a petri net controller for a machining workstation. </title> <booktitle> In Proceedings of the 1987 IEEE International Conference on Robotics & Automation, </booktitle> <pages> pages 1861-1867, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> The most popular models of manufacturing systems are based on extensions of Petri Nets [5, 7, 11, 12, 13, 16, 17]. Among those that actually implement control software are <ref> [11] </ref>, GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> The most popular models of manufacturing systems are based on extensions of Petri Nets [5, 7, 11, 12, 13, 16, 17]. Among those that actually implement control software are <ref> [11] </ref>, GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets.
Reference: [12] <author> M. Kamath and N. Viswanadham. </author> <title> Applications of petri net based models in the modelling and analysis of flexible manufacturing systems. </title> <booktitle> In Proceedings of the 1986 IEEE International Conference on Robotics & Automation, </booktitle> <pages> pages 312-317, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets.
Reference: [13] <author> Y. Narahari and N. Viswanadham. </author> <title> Modeling flexible manufacturing systems with map/1. </title> <booktitle> In Proceedings of the First ORSA/TIMS Special Interest Conference on Flexible Manufacturing Systems: Operations Research Models and Applications, </booktitle> <pages> pages 346-358, </pages> <institution> The University of Michigan, </institution> <address> Ann Arbor, </address> <month> August 15-17 </month> <year> 1984. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets.
Reference: [14] <author> A. W. Naylor and M. C. Maletz. </author> <title> The manufacturing game: A formal approach to manufacturing software. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> SMC-16(3):321-334, </volume> <month> May/June </month> <year> 1986. </year>
Reference-contexts: The workings of this controller are described in the next section. In the meantime, we describe the general structure of the formal models <ref> [14] </ref> used in building this cell controller. For our purpose, the formal model of a software/hardware component captures, at the logical level [14], its functionality as viewed through both its software [15] and its hardware interfaces. <p> The workings of this controller are described in the next section. In the meantime, we describe the general structure of the formal models <ref> [14] </ref> used in building this cell controller. For our purpose, the formal model of a software/hardware component captures, at the logical level [14], its functionality as viewed through both its software [15] and its hardware interfaces. The logical level is, as the name suggests, largely concerned with logical conditions and transformations of logical conditions.
Reference: [15] <author> A. W. Naylor and R. A. Volz. </author> <title> Design of integrated manufacturing system control software. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> SMC-17(6):881-897, </volume> <month> November/December </month> <year> 1987. </year>
Reference-contexts: Furthermore, alternating between the simulations and the actual devices is easily done and follows naturally from our use of software/hardware components. The concepts of our methodology have been presented in <ref> [1, 10, 15] </ref>. Furthermore, these concepts have been validated by applying it to the design and implementation of the control software of several systems [1, 2]. <p> A software/hardware component is a generalized version of a software component <ref> [15] </ref>. A software component is an object-oriented construct that is characterized by a set of public software interfaces and a body (internals) [3]. A software interface specifies a set of services that can be performed by this component. <p> Our ultimate goal is to develop a generic controller that can be used in controlling any set of manufacturing software/hardware components <ref> [15] </ref>. Figure 4 illustrates our perception of this generic controller. The role of the generic controller is to generate the control strategy for the assembly software/hardware component. <p> In the meantime, we describe the general structure of the formal models [14] used in building this cell controller. For our purpose, the formal model of a software/hardware component captures, at the logical level [14], its functionality as viewed through both its software <ref> [15] </ref> and its hardware interfaces. The logical level is, as the name suggests, largely concerned with logical conditions and transformations of logical conditions. <p> While the above assertion is true, its significance can be considerably reduced by 14 the choice of an efficient network and communication protocol <ref> [15] </ref>, [18]. Moreover, critical areas, where communication traffic is particularly heavy, should be identified and the corresponding software should be appropriately tuned.
Reference: [16] <author> R. Ravichandran and A. K. Chakravarty. </author> <title> Decision support in flexible manufacturing systems using timed petri nets. </title> <journal> Journal of Manufacturing Systems, </journal> <volume> 5(2), </volume> <year> 1986. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets.
Reference: [17] <author> B. H. Thomas and C. McLean. </author> <title> Using grafcet to design generic controllers. </title> <booktitle> In Proceedings of the 1988 International Conference on Computer Integrated Manufacturing, </booktitle> <pages> pages 110-119, </pages> <institution> Rensselaer Polytechnic Institute, </institution> <address> Troy New York, </address> <month> May 23-25 </month> <year> 1988. </year>
Reference-contexts: The most popular models of manufacturing systems are based on extensions of Petri Nets <ref> [5, 7, 11, 12, 13, 16, 17] </ref>. Among those that actually implement control software are [11], GRAFCETs [17] and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> The most popular models of manufacturing systems are based on extensions of Petri Nets [5, 7, 11, 12, 13, 16, 17]. Among those that actually implement control software are [11], GRAFCETs <ref> [17] </ref> and PROT nets [5, 7]. [11] is based on Petri net hierarchies. Places in these nets are either simple or macro places. Macro places are themselves Petri nets. <p> Macro places are themselves Petri nets. The controller, developed in C, associates a C procedure with every place in the net and acts as a Petri net interpreter by executing this procedure whenever a token arrives in the place. A similar approach is adopted by <ref> [17] </ref>. GRAFCET, an extension to Petri nets is used. In a GRAFCET, a place is associated with an action, a macro place is itself a GRAFCET and a transition is associated with a condition. Both conditions and actions are coded as C expressions and procedures respectively.
Reference: [18] <author> R. A. Volz, P. Krishnan, and R. Theriault. </author> <title> An approach to distributed execution of ada programs. </title> <booktitle> In NASA Workshop on Telerobotics, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: Second, it facilitates the software development process, since it rids the programmer from having to think across processor boundaries, and instead concentrate on the real programming task. Third, this approach can benefit from automatic program distribution tools such as the Ada distributed translator developed at The University of Michigan <ref> [18] </ref>. While it is widely recognized that testing distributed software is a complex task due to the inter 3 spersed nature of this software, this complexity is further augmented in testing computer-integrated manufacturing control and integration software by the presence of manufacturing devices and their mechanical interactions. <p> Distributing this software across the network is performed after the implementation and testing stages are completed; the appropriate communication software is inserted either by hand or automatically by means of a distributed translator <ref> [18] </ref>. This approach avoids all the problems stated above; in addition, the programmer can concentrate on the task of implementing the control software without being concerned with its distributed aspects. <p> While the above assertion is true, its significance can be considerably reduced by 14 the choice of an efficient network and communication protocol [15], <ref> [18] </ref>. Moreover, critical areas, where communication traffic is particularly heavy, should be identified and the corresponding software should be appropriately tuned.
Reference: [19] <author> R. A. Volz and T. N. Mudge. </author> <title> Robots are (nothing more than) abstract data types. </title> <booktitle> In Proceedings of the SME Conference on Robotics Research: The Next 5 Years and Beyond, </booktitle> <pages> pages MS84-493: 1-16, </pages> <month> August </month> <year> 1984. </year> <month> 33 </month>
Reference-contexts: This is achieved by separating the interfaces from the internals and making the internals inaccessible to the users. A software/hardware component generalizes the concept of a software component by allowing the internals of the component to enclose hardware <ref> [19] </ref>; i.e, these internals are interfaced to and drive hardware devices. Moreover, the specification of a software/hardware component provides a software interface, in the common implementation language, to the hardware it drives. As an example, the Ada specification of a robot software/hardware component is given below.
References-found: 19

