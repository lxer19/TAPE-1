URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tm.outbox/MIT-LCS-TM-480.b.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/catatm.html
Root-URL: 
Email: lynch@theory.lcs.mit.edu  fritsv@cwi.nl  
Title: Action Transducers and Timed Automata  
Author: Nancy Lynch Frits Vaandrager 
Date: October 26, 1994  
Address: Cambridge, MA 02139, USA  P.O. Box 94079, NL-1090 GB Amsterdam  Kruislaan 403, NL-1098 SJ Amsterdam  
Affiliation: MIT Laboratory for Computer Science  CWI  University of Amsterdam Programming Research Group  
Abstract: The timed automaton model of [29, 30] is a general model for timing-based systems. A notion of timed action transducer is here defined as an automata-theoretic way of representing operations on timed automata. It is shown that two timed trace inclusion relations are substitutive with respect to operations that can be described by timed action transducers. Examples are given of operations that can be described in this way, and a preliminary proposal is given for an appropriate language of operators for describing timing-based systems. 1991 Mathematics Subject Classification: 68Q55, 68Q60, 68Q75. 1991 CR Categories: D.3.3, F.1.1, F.3.2, F.3.3. Keywords and Phrases: Real-time, process algebra, action transducers, timed automata, timed trace inclusion, congruence properties. Notes: The first author was supported by ONR contracts N00014-85-K-0168 and N00014-91-J-1988, by NSF grant CCR-8915206, and by ARPA contracts N00014-89-J-1988 and N00014-92-J-4033. The second author was supported by ESPRIT BRA 7166 Concur2 and by the HCM network EXPRESS. Part of the work on this paper was done while the author was employed by the Ecole des Mines, CMA, Sophia Antipolis, France. A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455. Springer-Verlag, 1992. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In de Bakker et al. </editor> <volume> [12], </volume> <pages> pages 1-27. </pages>
Reference-contexts: Such bounds can be imposed by parameterizing the transducer with an additional boolean that tells whether the time bound is strict or not. Alternatively, one can follow a suggestion of Abadi and Lamport <ref> [1] </ref>, and introduce, as additional elements of the time domain, the set of all `infinitesimally shifted' real numbers r , where t r iff t &lt; r, for any reals t and r. 33 Now the steps of BOUND b x can be defined by: (t; u) d (t; u) a <p> Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, 40 for instance, [44, 18, 9]). Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see <ref> [1, 9] </ref>), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of [29, 30], in the setting of our language L t .
Reference: [2] <author> R. Alur and D.L. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [10] and CSP [20], disjoint union, and a binary version of Kleene's star. We also describe several timed operations as timed action transducers: a CLOCK operation directly inspired by the clock variables of <ref> [2, 3] </ref>, a BOUND operation that can block the passage of time, and a RATE operation that can change the speed of its argument. <p> Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill <ref> [2] </ref>, the timeout construct of Timed CSP [42, 11], and the execution delay operation of the timed process algebra ATP [38]. We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle <p> very general timer similar to that used in the timed !-automata model of Alur and Dill <ref> [2] </ref>, the timeout construct of Timed CSP [42, 11], and the execution delay operation of the timed process algebra ATP [38]. We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [32]. All of this provides evidence of the power of our proposed language. <p> One way to impose such constraints is by using explicit clock variables, as advocated in <ref> [2, 3] </ref>. In this subsection, we show how clock variables can be expressed using timed action transducers. The unary timed action transducer CLOCK x models the effect of adding a clock variable x to a system. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this transducer. Our definition of clocks directly follows the one proposed in <ref> [2, 3] </ref>. <p> Clearly, BOUND b x is Zeno- and t -respecting. Thus relations t fl and t are substitutive for this transducer. In the literature several other proposals can be found on how to constrain the passage of time: <ref> [2] </ref> uses a Buchi style acceptance criterion for this purpose, [19] advocates the use of program invariants, [3] proposes the related notion of delay predicates, and [31] uses so-called important events. <p> An obvious question left open in this paper is to find a sound and complete axiomatization of timed trace inclusion for the language L t or a fragment of it. Results of <ref> [2] </ref> can be adapted to show that, even if we exclude the RATE operator and only allow for rational numbers in clock constraints and bounds, deciding timed trace inclusion for L t is 1 hard.
Reference: [3] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time system = discrete system + clock variables. </title> <editor> In T. Rus and C. Rattray, editors, </editor> <booktitle> Theories and Experiences for Real-Time System Development | Papers presented at First AMAST Workshop on Real-Time System Development, </booktitle> <address> Iowa City, Iowa, </address> <month> November </month> <year> 1993. </year> <title> World Scientific, </title> <note> 1994. To appear. </note>
Reference-contexts: Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [10] and CSP [20], disjoint union, and a binary version of Kleene's star. We also describe several timed operations as timed action transducers: a CLOCK operation directly inspired by the clock variables of <ref> [2, 3] </ref>, a BOUND operation that can block the passage of time, and a RATE operation that can change the speed of its argument. <p> Together, these operations form a language that we will call L t . Paraphrasing Alur and Henzinger <ref> [3] </ref>, we can summarize the main idea behind L t as: 30 real-time process algebra = untimed process algebra + timers. <p> One way to impose such constraints is by using explicit clock variables, as advocated in <ref> [2, 3] </ref>. In this subsection, we show how clock variables can be expressed using timed action transducers. The unary timed action transducer CLOCK x models the effect of adding a clock variable x to a system. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this transducer. Our definition of clocks directly follows the one proposed in <ref> [2, 3] </ref>. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this transducer. Our definition of clocks directly follows the one proposed in [2, 3]. In fact, it is possible to encode each (finite state) clock-constrained system in the sense of <ref> [3] </ref> within our language: by Theorem 3.1 we can encode the underlying finite automaton (with the clock constraints viewed as part of the transition labels), and if we then apply a CLOCK operator for each of the clock variables that is used, the resulting expression will generate the same timed traces <p> Thus relations t fl and t are substitutive for this transducer. In the literature several other proposals can be found on how to constrain the passage of time: [2] uses a Buchi style acceptance criterion for this purpose, [19] advocates the use of program invariants, <ref> [3] </ref> proposes the related notion of delay predicates, and [31] uses so-called important events. It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori.
Reference: [4] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> Real time process algebra. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 3(2) </volume> <pages> 142-188, </pages> <year> 1991. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [6, 34]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [4, 23, 35, 38, 47] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [4, 35, 38, 47] </ref>. This operation cannot be expressed as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> Nicollin, Sifakis and Yovine [39] give a translation from ATP into Alur-Dill automata, but do not investigate the reverse translation. In fact it appears that, besides our language, only the real-time ACP language of Baeten and Bergstra <ref> [4] </ref> is sufficiently expressive to allow for a direct encoding of Alur-Dill automata. We present our definitions and results for timed systems by first presenting related definitions and results for untimed systems, and then building upon those to obtain the corresponding timed concepts. <p> The operations from L t are sufficiently expressive to define | as derived operators | all the constructs that we have encountered in the literature on timed process algebras, except those that involve binding mechanisms (like the integration construct of <ref> [4] </ref>) and those that are not compatible with timed trace inclusion (like the + from CCS). In this section, we give some of these derived operators. <p> Another example, taken from <ref> [4] </ref>, is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3 Execution delay The execution delay operator of ATP [39, 38] is given by: dAe d <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [35], the timed extension of CCS proposed in [47], ATP [38], and ACP <ref> [4] </ref>). <p> However, it may be possible to find interesting partial results: axioms that allow the elimination of certain operators in favor of others, or complete axiomatizations of subcalculi. For this it might be necessary to add to the language auxiliary operators such as the integration construct of timed ACP <ref> [4] </ref>. Before it can become practically useful, the language L t will have to be extended with a more powerful mechanism for recursion, and with the possibility to parametrize processes and actions with data.
Reference: [5] <editor> J.C.M. Baeten and J.W. Klop, editors. </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [6] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Showing that this property holds 3 for a given timed automaton A is an interesting problem, but we do not address this problem in this paper. In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems <ref> [6, 34] </ref>. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting [4, 23, 35, 38, 47]. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> in Section 3.4. 3 An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [20], CIRCAL [33], CCS [34], Extended LOTOS [10] and ACP <ref> [6] </ref>.
Reference: [7] <author> J.A. Bergstra, I. Bethke, and A. Ponse. </author> <title> Process algebra with iteration and nesting. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 243-258, </pages> <year> 1994. </year>
Reference-contexts: Recently, the binary star has been studied in the context of ACP in <ref> [7, 13] </ref>. The iteration construct exploits the ability of transducers to copy their arguments: it uses an infinite number of copies of both the first and the second argument.
Reference: [8] <author> B. Bloom, S. Istrail, and A.R. Meyer. </author> <title> Bisimulation can't be traced: Preliminary report. </title> <booktitle> In Conference Record of the 15 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <pages> pages 229-239, </pages> <year> 1988. </year> <note> Full version available as Technical Report 90-1150, </note> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> August </month> <year> 1990. </year> <note> Accepted to appear in Journal of the ACM. </note>
Reference-contexts: finite number of arguments, and a setting where automata just have one start state and no explicit set of associated actions. 9 Note that, since we always start copies of an argument automaton from a start state, our notion of copying is different from that of Bloom, Istrail and Meyer <ref> [8] </ref>, who also allow copying from intermediate states. As a consequence, the trace preorder is substitutive for our operations, whereas it is not substitutive in general for the operations of [8]. In this section we have defined the semantics of a transducer as an operation on automata. <p> an argument automaton from a start state, our notion of copying is different from that of Bloom, Istrail and Meyer <ref> [8] </ref>, who also allow copying from intermediate states. As a consequence, the trace preorder is substitutive for our operations, whereas it is not substitutive in general for the operations of [8]. In this section we have defined the semantics of a transducer as an operation on automata. In fact, it is often useful to interpret transducers in a more general (and somewhat more complex) way, as operations on transducers. <p> For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [43, 8, 17] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [9] <author> D.J.B. Bosscher, I. Polak, and F.W. Vaandrager. </author> <title> Verification of an audio control protocol. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Proceedings of the Third International School and Symposium on Formal Techniques in Real Time 41 and Fault Tolerant Systems, Lubeck, </booktitle> <address> Germany, </address> <month> September </month> <year> 1994, </year> <booktitle> volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 170-192. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> Full version available as Report CS-R9445, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [25, 9, 18] </ref> to verify the correctness of timed protocols for communication, audio control and real-time process control, respectively. In this paper, we continue the development by studying process algebras for the same model. <p> SWITCH 0 = TIMER 1 x (fsw on; reset (x); x:10g ; (fsw on; reset (x)g fl fsw off ; x2 <ref> [9; 10] </ref>; x:1g)) ! ): Example. To illustrate the use of multiple, nested clocks we specify the process of having breakfast. Breakfast should be both started and finished after 6 am and before 9 am. <p> For t 1, RATE [1;1+] introduces a tolerance of on all timing of its argument. We think that RATE transducers can be useful in the process algebraic description of protocols that involve drifting clocks, such as the audio control protocol analyzed in <ref> [9] </ref>. An interesting property of the RATE transducers is that in general they do not preserve Wang's [47] axiom of time determinism. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, 40 for instance, <ref> [44, 18, 9] </ref>). <p> Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, 40 for instance, [44, 18, 9]). Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see <ref> [1, 9] </ref>), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of [29, 30], in the setting of our language L t .
Reference: [10] <author> E. Brinksma. </author> <title> On the design of Extended LOTOS aspecification language for open distributed systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Twente, </institution> <year> 1988. </year>
Reference-contexts: These include most of the usual untimed operations from process algebra, in particular, sequential and parallel composition, external choice, action hiding and renaming. Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS <ref> [10] </ref> and CSP [20], disjoint union, and a binary version of Kleene's star. <p> give one example in Section 3.4. 3 An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [20], CIRCAL [33], CCS [34], Extended LOTOS <ref> [10] </ref> and ACP [6]. <p> SWITCH 0 = TIMER 1 x (fsw on; reset (x); x:10g ; (fsw on; reset (x)g fl fsw off ; x2 <ref> [9; 10] </ref>; x:1g)) ! ): Example. To illustrate the use of multiple, nested clocks we specify the process of having breakfast. Breakfast should be both started and finished after 6 am and before 9 am. <p> Such extensions are standard, however, and one could simply follow the approaches taken in process algebras such as Extended LOTOS <ref> [10] </ref> or CRL [16]. We do not believe that one single approach, assertional or process algebraic, can solve all problems regarding the specification and verification of timed systems. A solution has to be sought rather in a smooth combination of various formalisms.
Reference: [11] <author> J. Davies and S. Schneider. </author> <title> An introduction to Timed CSP. </title> <type> Technical Monograph PRG-75, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [2], the timeout construct of Timed CSP <ref> [42, 11] </ref>, and the execution delay operation of the timed process algebra ATP [38]. We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [32]. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of [32]. 35 5.2.1 Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP <ref> [42, 11] </ref>, which waits time d and then terminates successfully. WAIT d = TIMER d x (x=d): More generally, we can specify a process that terminates successfully after waiting some nondeterministically chosen time from the closed interval [l; u]. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS [35] and ATP [38]: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. For a given delay d this operator is defined, as in <ref> [11] </ref>, by A fl B = (A 2 (WAIT d ; abort ; B))nfabortg; where abort is a fresh label, not in the label set of A and B. If, at time d, A has not performed any visible action, an interrupt occurs and automaton B is started.
Reference: [12] <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Proceedings REX Workshop on Real-Time: Theory in Practice, Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [13] <author> W.J. Fokkink and H. Zantema. </author> <title> Basic process algebra with iteration: Completeness of its equational axioms. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 259-267, </pages> <year> 1994. </year>
Reference-contexts: Recently, the binary star has been studied in the context of ACP in <ref> [7, 13] </ref>. The iteration construct exploits the ability of transducers to copy their arguments: it uses an infinite number of copies of both the first and the second argument.
Reference: [14] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <editor> In S. Abiteboul and E. Shamir, editors, </editor> <booktitle> Proceedings 21 th ICALP, Jerusalem, volume 820 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> A full version appears as MIT Technical Report number MIT/LCS/TR-587. </note>
Reference-contexts: Justification for the use of trace inclusions to define "implementation" appears, for example, in the work of Gawlick, Segala, Stgaard-Andersen and Lynch <ref> [14] </ref>. Basically, this justification amounts to showing that the set of admissible timed traces of A is not trivial. Doing this depends on a classification of the visible actions of A as input actions or output actions, as in the I/O automaton model of [28].
Reference: [15] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum II (the semantics of sequential systems with silent moves). </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 66-81. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Even though we advocate in this paper the use of timed trace equivalence, we think it will be quite interesting to extend Van Glabbeek's <ref> [15] </ref> lattice of process equivalences with a real-time dimension, and to study the impact of the patient construction on congruence properties for other equivalences as well. 5.4 Remarks Some untimed operators display undesired behavior when transformed into timed operators via the patient construction. We give an example.
Reference: [16] <author> J.F. Groote and A. Ponse. </author> <title> Proof theory for CRL: A language for processes with data. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg, editors, </editor> <booktitle> Proceedings of the International Workshop on Semantics of Specification Languages, Workshops in Computer Science, </booktitle> <pages> pages 231-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Such extensions are standard, however, and one could simply follow the approaches taken in process algebras such as Extended LOTOS [10] or CRL <ref> [16] </ref>. We do not believe that one single approach, assertional or process algebraic, can solve all problems regarding the specification and verification of timed systems. A solution has to be sought rather in a smooth combination of various formalisms.
Reference: [17] <author> J.F. Groote and F.W. Vaandrager. </author> <title> Structured operational semantics and bisimulation as a congruence. </title> <journal> Information and Computation, </journal> <volume> 100(2) </volume> <pages> 202-260, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In <ref> [17] </ref>, a sequential composition operator is described for which this is not the case: s 1 ! f (1;a)g s 1 if 6= a b s 2 ! f (2;b)g s 2 For the patient version of this operator we obtain the undesired identity WAIT 1 ; WAIT 1 = WAIT <p> For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [43, 8, 17] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [18] <author> C. Heitmeyer and N.A. Lynch. </author> <title> The generalized railroad crossing | a case study in formal verification of real-time systems. </title> <booktitle> In Proceedings 15th IEEE Real-Time Systems Symposium, </booktitle> <address> San Juan, Puerto Rico, </address> <month> December </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [25, 9, 18] </ref> to verify the correctness of timed protocols for communication, audio control and real-time process control, respectively. In this paper, we continue the development by studying process algebras for the same model. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, 40 for instance, <ref> [44, 18, 9] </ref>).
Reference: [19] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <booktitle> In Proceedings 7 th Annual Symposium on Logic in Computer Science, </booktitle> <address> Santa Cruz, California, </address> <pages> pages 394-406. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: Clearly, BOUND b x is Zeno- and t -respecting. Thus relations t fl and t are substitutive for this transducer. In the literature several other proposals can be found on how to constrain the passage of time: [2] uses a Buchi style acceptance criterion for this purpose, <ref> [19] </ref> advocates the use of program invariants, [3] proposes the related notion of delay predicates, and [31] uses so-called important events. <p> It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori. Our approach to use BOUND operators can be viewed as a special case of the invariant approach of <ref> [19] </ref>, with a fixed invariant stating that the values of the clock variables never exceed the values of the corresponding bound variables. 5.1.4 Timers In applications, we will mostly want to use the clock and bound transducers in combination.
Reference: [20] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> En-glewood Cliffs, </address> <year> 1985. </year> <month> 42 </month>
Reference-contexts: These include most of the usual untimed operations from process algebra, in particular, sequential and parallel composition, external choice, action hiding and renaming. Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [10] and CSP <ref> [20] </ref>, disjoint union, and a binary version of Kleene's star. <p> We give one example in Section 3.4. 3 An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP <ref> [20] </ref>, CIRCAL [33], CCS [34], Extended LOTOS [10] and ACP [6].
Reference: [21] <author> A.S.A. Jeffrey, S.A. Schneider, and F.W. Vaandrager. </author> <title> A comparison of additivity axioms in timed transition systems. </title> <type> Report CS-R9366, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: The trajectory axiom S2 is a kind of converse to S1; it says that any time-passage step can be "filled in" with states for each intervening time, in a "consistent" way. For a further discussion of this axiom we refer to <ref> [30, 21] </ref>. 4.2 Timed Traces Executions of timed automata correspond to what are called sampling computations in [31]: they provide information about a run of a system at a countable number of points in time.
Reference: [22] <author> S.C. Kleene. </author> <title> Representation of events in nerve nets and finite automata. </title> <booktitle> In Automata Studies, </booktitle> <pages> pages 3-41. </pages> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: A key identity satisfied by the operator is A fl B A ; (A fl B) 2 B: Kleene's star operation is best known in its unary form, but in fact the original operator introduced by Kleene in <ref> [22] </ref> was binary. Recently, the binary star has been studied in the context of ACP in [7, 13]. The iteration construct exploits the ability of transducers to copy their arguments: it uses an infinite number of copies of both the first and the second argument.
Reference: [23] <author> A.S. Klusener. </author> <title> Models and axioms for a fragment of real time process algebra. </title> <type> PhD thesis, </type> <institution> Department of Mathematics and Computing Science, Technical University of Eindhoven, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [6, 34]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [4, 23, 35, 38, 47] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. The problem is that they do not allow one to abstract in specifications from the often very complex timing behavior of implementations (see Chapter 10 of <ref> [23] </ref> for an example). Since we believe that timed trace inclusion does form a good notion of implementation, we are interested in identifying operations on timed automata for which the timed trace inclusion relation is substitutive. This substitutivity is a prerequisite for the compositional verification of systems using timed automata.
Reference: [24] <author> L. Lamport. </author> <title> How to write a long formula. </title> <type> Research Report 119, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: If the remainder of fl 0 starts with an a step and, for each hole i that participate in this step, the remainder of ff i starts 1 Here and elsewhere we use Lamport's <ref> [24] </ref> list notation for conjunction.
Reference: [25] <author> B.W. Lampson, N.A. Lynch, and J.F. Stgaard-Andersen. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In FORTE'93 Sixth International Conference on Formal Description Techniques, </booktitle> <address> Boston, MA, </address> <month> October </month> <year> 1993, </year> <pages> pages 387-402, </pages> <year> 1993. </year>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [25, 9, 18] </ref> to verify the correctness of timed protocols for communication, audio control and real-time process control, respectively. In this paper, we continue the development by studying process algebras for the same model.
Reference: [26] <author> K.G. Larsen and L. Xinxin. </author> <title> Compositionality through an operational semantics of contexts. </title> <booktitle> In Paterson [40], </booktitle> <pages> pages 526-539. </pages> <note> An extended version appeared as: Report R89-13, </note> <institution> The University of Aalborg, Dept. of Mathematics and Computer Science, Aal-borg, Denmark, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: However, action transducers are more convenient for our purposes. First, although it is easy to see how SOS specifications determine automata, it is less clear how to regard them as defining operations on automata. For action transducers, this correspondence is more direct. Second, as noted by Larsen and Xinxin <ref> [26] </ref>, action transducers are a convenient tool for studying compositionality questions, and their use tends to simplify proofs. Third, action transducers can easily be defined to allow multiple start states. <p> In fact, our 4 transducers also allow holes to be colored, which allows us to express the condition that several holes (those of the same color) must hold copies of the same automaton. The concepts of multiple start states and of colored holes are not present in <ref> [26] </ref>. The major result of our paper is that the timed trace inclusion relation is substitutive with respect to all operations that can be described by our action transducers, provided they satisfy a number of conditions that concern the handling of internal and time-passage steps. <p> 1 s 1 a 2 2 s 2 is an execution of T , and for each hole i of T , trace (fl; i ) 2 traces ((color (T; i))). 2.3.5 Remarks The importance of transducers for process algebra and concurrency theory was first noted by Larsen and Xinxin <ref> [26] </ref>, who introduced a certain type of transducer, which they call context systems, to study compositionality questions in the setting of process algebra. Our transducers generalize those of Larsen and Xinxin [26] in several respects: the distinction between colors and holes, which allows us to copy arguments, is new here. <p> 2.3.5 Remarks The importance of transducers for process algebra and concurrency theory was first noted by Larsen and Xinxin <ref> [26] </ref>, who introduced a certain type of transducer, which they call context systems, to study compositionality questions in the setting of process algebra. Our transducers generalize those of Larsen and Xinxin [26] in several respects: the distinction between colors and holes, which allows us to copy arguments, is new here. Also, Larsen and Xinxin [26] only consider operations with a finite number of arguments, and a setting where automata just have one start state and no explicit set of associated actions. 9 <p> Our transducers generalize those of Larsen and Xinxin <ref> [26] </ref> in several respects: the distinction between colors and holes, which allows us to copy arguments, is new here. Also, Larsen and Xinxin [26] only consider operations with a finite number of arguments, and a setting where automata just have one start state and no explicit set of associated actions. 9 Note that, since we always start copies of an argument automaton from a start state, our notion of copying is different from that
Reference: [27] <author> N.A. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: If, at time d, A has not performed any visible action, an interrupt occurs and automaton B is started. Note the use of the auxiliary label abort to force the choice between A and B at time d. Example. We consider a simple resource-granting system described in <ref> [27] </ref>. The system consists of two components, a watch and a manager. The watch ticks at an approximately predictable rate, and the manager counts ticks in order to decide when to grant a resource. <p> i1 for 0 &lt; i k MANAGER 0 = WAIT [0; l] ; grant 36 The full system can now be described as the parallel composition of automata WATCH and MANAGER, with the tick action hidden: SYSTEM = (WATCH kMANAGER)nftick g: Essentially, the result about the resource-granting system proved in <ref> [27] </ref> is that SYSTEM t (WAIT [k c 1 l; k c 2 + l] ; grant ) ! : Example. <p> We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [32]. The MMT-automata model is an extension with real-time of the I/O automata model of [28]. It has been used extensively in <ref> [27, 44] </ref> for verification purposes. <p> input, output and internal actions, respec tively; it is required that input actions are enabled in each state, i.e., for each state s 0 and for each input action a there exists a state s such that s 0 a ! A s, 4 Here we follow the definition from <ref> [27] </ref>, which is slightly more restrictive than the original definition of [32] because it does not allow for strict bounds.
Reference: [28] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: Basically, this justification amounts to showing that the set of admissible timed traces of A is not trivial. Doing this depends on a classification of the visible actions of A as input actions or output actions, as in the I/O automaton model of <ref> [28] </ref>. Then A is required to have the property that each of its finite executions can be extended to an admissible execution in a way that includes any given "non-Zeno" input pattern. <p> Conditions 1 and 2 slightly strengthen similar constraints that are presented in [45] in the setting of SOS. Condition 3 does not occur in [45] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of <ref> [28] </ref>. Theorem 2.3 The relations fl and on automata are substitutive for all t -respecting action transducers. 10 Proof Let T be a t -respecting action transducer. We show that is substitutive for T . The proof that fl is substitutive for T is similar but slightly simpler. <p> We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [32]. The MMT-automata model is an extension with real-time of the I/O automata model of <ref> [28] </ref>. It has been used extensively in [27, 44] for verification purposes.
Reference: [29] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In de Bakker et al. </editor> <volume> [12], </volume> <pages> pages 397-446. </pages>
Reference-contexts: 1 Introduction The timed automaton model of <ref> [29, 30] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods <p> 1 Introduction The timed automaton model of <ref> [29, 30] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods are used in [25, 9, 18] to verify the correctness of timed protocols for communication, audio control and real-time process control, respectively. <p> Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see [1, 9]), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of <ref> [29, 30] </ref>, in the setting of our language L t . Together with a limited repertoire of algebraic laws, this may then form the basis of a methodology in which the benefits of algebraic and assertional methods can be combined.
Reference: [30] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: Timing-based systems. </title> <type> Report CS-R9314, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1993. </year> <note> Also, </note> <institution> MIT/LCS/TM-487.b, Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cam-bridge, MA. </address>
Reference-contexts: 1 Introduction The timed automaton model of <ref> [29, 30] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods <p> 1 Introduction The timed automaton model of <ref> [29, 30] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [29, 30], we develop a full range of simulation proof methods for timed automata; these methods are used in [25, 9, 18] to verify the correctness of timed protocols for communication, audio control and real-time process control, respectively. <p> We follow the same general outline, introducing time systematically into all of the definitions and results. 4.1 Timed Automata We use a slight variant of the timed automaton model from <ref> [30] </ref>. 2 A timed automaton A is an automaton whose set of actions includes R + , the set of positive reals. Actions from R + are referred to as time-passage actions. <p> The trajectory axiom S2 is a kind of converse to S1; it says that any time-passage step can be "filled in" with states for each intervening time, in a "consistent" way. For a further discussion of this axiom we refer to <ref> [30, 21] </ref>. 4.2 Timed Traces Executions of timed automata correspond to what are called sampling computations in [31]: they provide information about a run of a system at a countable number of points in time. <p> For a further discussion of this axiom we refer to [30, 21]. 4.2 Timed Traces Executions of timed automata correspond to what are called sampling computations in [31]: they provide information about a run of a system at a countable number of points in time. In <ref> [30] </ref>, a notion of timed execution is also defined for timed automata: these are alternating sequences of trajectories and actions, which correspond to the super-dense computations of 2 The difference is just the explicit indication of the amount of elapsed time in the time-passage action instead of using a .now function <p> Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see [1, 9]), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of <ref> [29, 30] </ref>, in the setting of our language L t . Together with a limited repertoire of algebraic laws, this may then form the basis of a methodology in which the benefits of algebraic and assertional methods can be combined.
Reference: [31] <author> Z. Manna and A. Pnueli. </author> <title> Verifying hybrid systems. In R.L. </title> <editor> Grossman, A. Nerode, A.P. Ravn, and H. Rischel, editors, </editor> <booktitle> Hybrid Systems, volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 4-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: For a further discussion of this axiom we refer to [30, 21]. 4.2 Timed Traces Executions of timed automata correspond to what are called sampling computations in <ref> [31] </ref>: they provide information about a run of a system at a countable number of points in time. <p> timed automata: these are alternating sequences of trajectories and actions, which correspond to the super-dense computations of 2 The difference is just the explicit indication of the amount of elapsed time in the time-passage action instead of using a .now function that associates the current time to a state. 20 <ref> [31] </ref>. It can be argued that timed executions provide a more precise representation of the behavior of real-time systems than (sampling) executions. However, our trajectory axiom S2 guarantees that for each (sampling) execution of a timed automaton there exists a corresponding timed execution. <p> In the literature several other proposals can be found on how to constrain the passage of time: [2] uses a Buchi style acceptance criterion for this purpose, [19] advocates the use of program invariants, [3] proposes the related notion of delay predicates, and <ref> [31] </ref> uses so-called important events. It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori.
Reference: [32] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle <ref> [32] </ref>. All of this provides evidence of the power of our proposed language. The decidability and closure properties of Alur-Dill automata suggest that they can be regarded as a real-time analog of classical finite automata. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of <ref> [32] </ref>. 35 5.2.1 Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP [42, 11], which waits time d and then terminates successfully. <p> A minor difference between our execution delay operator and the one from ATP is that ours allows machine A to perform visible actions at time d. 5.2.4 MMT-automata It is possible to encode within L t each finite state timed-bounded automaton in the sense of <ref> [32] </ref>. We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [32]. The MMT-automata model is an extension with real-time of the I/O automata model of [28]. It has been used extensively in [27, 44] for verification purposes. <p> ATP is that ours allows machine A to perform visible actions at time d. 5.2.4 MMT-automata It is possible to encode within L t each finite state timed-bounded automaton in the sense of <ref> [32] </ref>. We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [32]. The MMT-automata model is an extension with real-time of the I/O automata model of [28]. It has been used extensively in [27, 44] for verification purposes. <p> input actions are enabled in each state, i.e., for each state s 0 and for each input action a there exists a state s such that s 0 a ! A s, 4 Here we follow the definition from [27], which is slightly more restrictive than the original definition of <ref> [32] </ref> because it does not allow for strict bounds. <p> Without proof, we claim that expr (B) generates exactly the same timed behaviors as the MMT-automaton B according to the definition of <ref> [32] </ref>. 5.3 Counterexamples Although the converse of Theorem 4.4 does not hold, our result appears to be quite sharp: for many examples of timed transducers that are not Zeno- and t -respecting, the timed trace preorders are indeed not substitutive. 38 The timed trace preorders t fl and t are for
Reference: [33] <author> G.J. Milne. </author> <title> CIRCAL and the representation of communication, concurrency, and time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 270-298, </pages> <year> 1985. </year> <month> 43 </month>
Reference-contexts: We give one example in Section 3.4. 3 An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [20], CIRCAL <ref> [33] </ref>, CCS [34], Extended LOTOS [10] and ACP [6].
Reference: [34] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: Showing that this property holds 3 for a given timed automaton A is an interesting problem, but we do not address this problem in this paper. In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems <ref> [6, 34] </ref>. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting [4, 23, 35, 38, 47]. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> We give one example in Section 3.4. 3 An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [20], CIRCAL [33], CCS <ref> [34] </ref>, Extended LOTOS [10] and ACP [6].
Reference: [35] <author> F. Moller and C. Tofts. </author> <title> A temporal calculus of communicating systems. </title> <booktitle> In Baeten and Klop [5], </booktitle> <pages> pages 401-415. </pages>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [6, 34]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [4, 23, 35, 38, 47] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [4, 35, 38, 47] </ref>. This operation cannot be expressed as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS <ref> [35] </ref> and ATP [38]: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS <ref> [35] </ref>, the timed extension of CCS proposed in [47], ATP [38], and ACP [4]).
Reference: [36] <author> F. Moller and C. Tofts. </author> <title> Behavioural abstraction in TCCS. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Proceedings 19 th ICALP, Vienna, volume 623 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The loss of substitutivity may be viewed as a problem for a process algebra with CCS choice based on trace equivalence (it is not a problem if certain other equivalence are used, such as observational congruence <ref> [36] </ref>). Via Lemma 5.1 we have identified a general class of operations for which trace equivalence is a congruence and with patient versions for which timed trace equivalence is a congruence.
Reference: [37] <author> X. Nicollin and J. Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In K.G. Larsen and A. Skou, editors, </editor> <booktitle> Proceedings of the 3rd International Workshop on Computer Aided Verification, Aalborg, Denmark, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 376-398. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: As a starting point, we believe that such a language ought to include the basic untimed operations that are already well understood and generally accepted. To this end, we describe a simple and general construction, inspired by Nicollin and Sifakis <ref> [37] </ref>, to transform any untimed operation into a timed one that behaves essentially the same and moreover does not use or constrain the time. <p> In this subsection we present a simple but important construction, inspired by Nicollin and Sifakis <ref> [37] </ref>, that transforms an untimed action transducer into a timed one, by simply inserting arbitrary time-passage steps. Suppose T is an (untimed) action transducer with R + " acts (T ) = ; and R + " acts (T; c) = ;, for all c.
Reference: [38] <author> X. Nicollin and J. Sifakis. </author> <title> The algebra of timed processes ATP: Theory and application. </title> <journal> Information and Computation, </journal> <volume> 114(1) </volume> <pages> 131-178, </pages> <year> 1994. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [6, 34]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [4, 23, 35, 38, 47] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [4, 35, 38, 47] </ref>. This operation cannot be expressed as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [2], the timeout construct of Timed CSP [42, 11], and the execution delay operation of the timed process algebra ATP <ref> [38] </ref>. We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [32]. All of this provides evidence of the power of our proposed language. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS [35] and ATP <ref> [38] </ref>: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. <p> Another example, taken from [4], is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3 Execution delay The execution delay operator of ATP <ref> [39, 38] </ref> is given by: dAe d (B) = (TIMER d x ((A ^ (abort ; B)) k C))nfabort; cancel g; where C = (cancel 2 fabort; x=dg) ; x:1 ; STOP: dAe d (B) behaves as A until time d; at time d, A is interrupted and B is started. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [35], the timed extension of CCS proposed in [47], ATP <ref> [38] </ref>, and ACP [4]).
Reference: [39] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> From ATP to timed graphs and hybrid systems. </title> <journal> Acta Informatica, </journal> <volume> 30(2) </volume> <pages> 181-202, </pages> <year> 1993. </year>
Reference-contexts: In the untimed setting, a crucial 5 characteristic of algebras like CCS is that they can easily describe finite automata. Thus by analogy, a natural requirement for a real-time process language is that it can easily describe Alur-Dill automata. Nicollin, Sifakis and Yovine <ref> [39] </ref> give a translation from ATP into Alur-Dill automata, but do not investigate the reverse translation. In fact it appears that, besides our language, only the real-time ACP language of Baeten and Bergstra [4] is sufficiently expressive to allow for a direct encoding of Alur-Dill automata. <p> Another example, taken from [4], is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3 Execution delay The execution delay operator of ATP <ref> [39, 38] </ref> is given by: dAe d (B) = (TIMER d x ((A ^ (abort ; B)) k C))nfabort; cancel g; where C = (cancel 2 fabort; x=dg) ; x:1 ; STOP: dAe d (B) behaves as A until time d; at time d, A is interrupted and B is started.
Reference: [40] <editor> M. Paterson, editor. </editor> <booktitle> Proceedings 17 th ICALP, Warwick, volume 443 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1990. </year>
Reference: [41] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: It should also enable verification of systems using a combination of compositional methods and methods based on levels of abstraction. We represent operations by automaton-like objects that we call action transducers, rather than, for example, using SOS specifications <ref> [41] </ref>. For an example of an action transducer, consider the operation jjj of interleaving parallel composition.
Reference: [42] <author> G.M. Reed and A.W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <year> 1988. </year>
Reference-contexts: Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [2], the timeout construct of Timed CSP <ref> [42, 11] </ref>, and the execution delay operation of the timed process algebra ATP [38]. We can also define a minor variant of Alur and Dill's timed automata [2], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [32]. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of [32]. 35 5.2.1 Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP <ref> [42, 11] </ref>, which waits time d and then terminates successfully. WAIT d = TIMER d x (x=d): More generally, we can specify a process that terminates successfully after waiting some nondeterministically chosen time from the closed interval [l; u].
Reference: [43] <author> R. de Simone. </author> <title> Higher-level synchronising devices in meije-SCCS. </title> <journal> Theoretical Computer Science, </journal> <volume> 37 </volume> <pages> 245-267, </pages> <year> 1985. </year>
Reference-contexts: In fact, it is shown in [46] how SOS specifications in a variant of a format proposed by De Simone <ref> [43] </ref> can be translated to equivalent action transducers, and vice versa. However, action transducers are more convenient for our purposes. First, although it is easy to see how SOS specifications determine automata, it is less clear how to regard them as defining operations on automata. <p> For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [43, 8, 17] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [44] <author> J.F. Stgaard-Andersen, B.W. Lampson, and N.A. Lynch. </author> <title> Correctness of communication protocols a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [32]. The MMT-automata model is an extension with real-time of the I/O automata model of [28]. It has been used extensively in <ref> [27, 44] </ref> for verification purposes. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, 40 for instance, <ref> [44, 18, 9] </ref>).
Reference: [45] <author> F.W. Vaandrager. </author> <title> On the relationship between process algebra and input/output automata (extended abstract). </title> <booktitle> In Proceedings 6 th Annual Symposium on Logic in Computer Science, Amsterdam, </booktitle> <pages> pages 387-398. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Condition 3 does not explicitly mention internal steps; however, this condition is needed in the substitutivity proof because of complications caused by internal steps. Conditions 1 and 2 slightly strengthen similar constraints that are presented in <ref> [45] </ref> in the setting of SOS. Condition 3 does not occur in [45] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of [28]. <p> Condition 3 does not explicitly mention internal steps; however, this condition is needed in the substitutivity proof because of complications caused by internal steps. Conditions 1 and 2 slightly strengthen similar constraints that are presented in <ref> [45] </ref> in the setting of SOS. Condition 3 does not occur in [45] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of [28].
Reference: [46] <author> F.W. Vaandrager. </author> <title> Expressiveness results for process algebras. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Semantics: Foundations and Applications, </booktitle> <address> Beekbergen, The Netherlands, </address> <month> June </month> <year> 1992, </year> <booktitle> volume 666 of Lecture Notes in Computer Science, </booktitle> <pages> pages 609-638. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, it is shown in <ref> [46] </ref> how SOS specifications in a variant of a format proposed by De Simone [43] can be translated to equivalent action transducers, and vice versa. However, action transducers are more convenient for our purposes.
Reference: [47] <author> Wang Yi. </author> <title> Real-time behaviour of asynchronous agents. </title> <booktitle> In Baeten and Klop [5], </booktitle> <pages> pages 502-520. </pages>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [6, 34]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [4, 23, 35, 38, 47] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [4, 35, 38, 47] </ref>. This operation cannot be expressed as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> We think that RATE transducers can be useful in the process algebraic description of protocols that involve drifting clocks, such as the audio control protocol analyzed in [9]. An interesting property of the RATE transducers is that in general they do not preserve Wang's <ref> [47] </ref> axiom of time determinism. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [35], the timed extension of CCS proposed in <ref> [47] </ref>, ATP [38], and ACP [4]).
References-found: 47

