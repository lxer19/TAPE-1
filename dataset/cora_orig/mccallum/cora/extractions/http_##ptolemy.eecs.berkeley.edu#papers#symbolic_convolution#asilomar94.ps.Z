URL: http://ptolemy.eecs.berkeley.edu/papers/symbolic_convolution/asilomar94.ps.Z
Refering-URL: http://ptolemy.eecs.berkeley.edu/annual95.html
Root-URL: 
Email: E-mail: ble@eecs.berkeley.edu  E-mail: mcclella@eedsp.gatech.edu  
Title: ALGORITHMS FOR SYMBOLIC LINEAR CONVOLUTION  
Author: Brian L. Evans James H. McClellan Van Leer Building 
Address: 211-105 Cory Hall  Berkeley, CA 94720-1772 USA  Atlanta, GA 30332-0250 USA  
Affiliation: Dept. of Electrical Eng. and Comp. Sciences  University of California  School of Electrical and Comp. Eng.  Georgia Institute of Technology  
Note: In 1994 Proc. of IEEE Asilomar Conf. on Signals, Systems, and Computers  
Abstract: This paper describes algorithms to perform linear convolution of both piecewise continuous functions and discrete functions symbolically. The algorithms manipulate the piecewise representation of the functions to produce a piecewise representation of the result. In our piecewise representation, the end points of and the function defined over each interval may be symbolic expressions. We have encoded the symbolic linear convolution algorithms in both Mathematica and Maple. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Oppenheim and A. Willsky, </author> <title> Signals and Systems. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, Inc., </publisher> <year> 1983. </year>
Reference-contexts: 1. Introduction Linear convolution is a linear time-invariant operator that takes two functions as arguments and produces a new function as its output. In the continuous domain, the linear convolution of two functions, f (t) and g (t), is defined as <ref> [1] </ref> f (t) ? g (t) = 1 B. L. Evans was supported by the Ptolemy project. The Ptolemy project is supported by the Advanced Research Projects Agency and the U.S. <p> Functions whose names do not imply a domain such as PiecewiseToFormula support a Domain option. 4.1. Mathematica Version The linear convolution of a finite sequence and a discrete step function is computed below. The finite sequence has a value of a for n 2 <ref> [3; 1] </ref>, a value of b for n 2 [0; 3], and a value of 0 otherwise. <p> The finite sequence has a value of a for n 2 [3; 1], a value of b for n 2 [0; 3], and a value of 0 otherwise. Note that the functions in the finite sequence are symbolic quantities and that the discrete step function extends for n 2 <ref> [0; 1] </ref>. (In the context of linear systems theory, we are symbolically computing the step response of a non-causal finite impulse response filter.) The Math-ematica dialogue follows, but the initialization of the SPPs is not shown. <p> 2 a (the result is a trapezoid). &gt; CTPiecewiseConvolution ( CPulse (t1, t), CPulse (t2, t), t ); [[t, 0, t2], [-t + t1 + t2, t1, t1 + t2]] &gt; AutoCorrelation ( [[1, -a, a]], n, Domain = Discrete ); [[n + 2 a + 1, -2 a, -1], <ref> [2 a + 1 - n, 1, 2 a] </ref>] 5. Conclusion This paper describes algorithms to compute linear discrete and continuous convolution symbolically. The algorithms work on the piecewise representations of the input functions and return a piecewise representation of the result.
Reference: [2] <author> A. V. Oppenheim and R. W. Schafer, </author> <title> Discrete-Time Signal Processing. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: J. H. McClellan was supported in part by the Joint Services Electronics Program under contract DAAH-04-93-G-0027. J. H. McClellan can be reached by phone at +1 404 894-8325 and by fax +1 404 894-8363. For discrete linear convolution, the integral is replaced by summation <ref> [2] </ref> f [n] ? g [n] = m=1 The output is computed by accumulating the product of one of the functions with a flipped and shifted version of the other function. In almost all cases, the convolution integral (or summation) has to be performed in pieces. <p> In <ref> [2] </ref>:= twoPulses = --a, -3, -1-, -b, 0, 3--; In [3]:= DTPiecewiseConvolution [ twoPulses, Step [n], n ] Out [3]= --a (4 + n), -3, -1-, &gt; -3 a + 4 b, 3, Infinity-- In [4]:= PiecewiseToFormula [ conv, n, Domain -&gt; Discrete ] Out [4]= a (4 + n) Pulse
Reference: [3] <author> K. A. West and J. H. McClellan, </author> <title> "Symbolic convolution," </title> <journal> IEEE Trans. on Education, </journal> <volume> vol. 36, </volume> <pages> pp. 386-393, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Once the limits have been determined, a symbolic mathematics environment can perform the integrations (or summations). This paper extends the work on piecewise convolution algorithms reported by West and McClellan <ref> [3] </ref>. West and McClellan developed algorithms that perform continuous and discrete linear convolution for finite-extent functions whose piecewise representations are defined over numeric end points. We extend their work to handle infinite-extent functions and functions defined over symbolic end points. <p> We extend their work to handle infinite-extent functions and functions defined over symbolic end points. We have added our modifications to the Mathematica [4] code written by West and McClellan <ref> [3] </ref>, and we have created an equivalent version for Maple V [5]. In Section 2, we highlight three methods to compute linear convolution. Section 3 discusses our modifications to the algorithm by West and McClellan to support piecewise functions with infinite and symbolic end points. <p> The Square Matrix Rule, however, is important because it can be used in an algorithm to compute linear convolution. 2.3. The Symbolic Convolution Rule West and McClellan <ref> [3] </ref> developed symbolic overlap-and-save convolution algorithms. The key data structure in their algorithms is the representation of piecewise functions as unions of function intervals. <p> The next section generalizes their work to lift the assumptions on the function intervals. 3. New Symbolic Convolution Rule Our key modification to the symbolic convolution algorithms reported by West and McClellan <ref> [3] </ref>, which were given in Section 2.3, is the generalization of their Symbolic Convolution Rule. The Symbolic Convolution Rule, given in Table , convolves two function intervals. <p> Functions whose names do not imply a domain such as PiecewiseToFormula support a Domain option. 4.1. Mathematica Version The linear convolution of a finite sequence and a discrete step function is computed below. The finite sequence has a value of a for n 2 <ref> [3; 1] </ref>, a value of b for n 2 [0; 3], and a value of 0 otherwise. <p> Mathematica Version The linear convolution of a finite sequence and a discrete step function is computed below. The finite sequence has a value of a for n 2 [3; 1], a value of b for n 2 <ref> [0; 3] </ref>, and a value of 0 otherwise. <p> In [2]:= twoPulses = --a, -3, -1-, -b, 0, 3--; In <ref> [3] </ref>:= DTPiecewiseConvolution [ twoPulses, Step [n], n ] Out [3]= --a (4 + n), -3, -1-, &gt; -3 a + 4 b, 3, Infinity-- In [4]:= PiecewiseToFormula [ conv, n, Domain -&gt; Discrete ] Out [4]= a (4 + n) Pulse [3 + n] + 3 &gt; (3 a + b <p> In [2]:= twoPulses = --a, -3, -1-, -b, 0, 3--; In <ref> [3] </ref>:= DTPiecewiseConvolution [ twoPulses, Step [n], n ] Out [3]= --a (4 + n), -3, -1-, &gt; -3 a + 4 b, 3, Infinity-- In [4]:= PiecewiseToFormula [ conv, n, Domain -&gt; Discrete ] Out [4]= a (4 + n) Pulse [3 + n] + 3 &gt; (3 a + b + b n) Pulse [n] + 3 &gt; (3
Reference: [4] <author> S. Wolfram, </author> <title> Mathematica: A System for Doing Mathematics by Computer. </title> <address> Redwood City, CA: </address> <publisher> Addison-Wesley, </publisher> <editor> second ed., </editor> <year> 1991. </year>
Reference-contexts: West and McClellan developed algorithms that perform continuous and discrete linear convolution for finite-extent functions whose piecewise representations are defined over numeric end points. We extend their work to handle infinite-extent functions and functions defined over symbolic end points. We have added our modifications to the Mathematica <ref> [4] </ref> code written by West and McClellan [3], and we have created an equivalent version for Maple V [5]. In Section 2, we highlight three methods to compute linear convolution. <p> In [2]:= twoPulses = --a, -3, -1-, -b, 0, 3--; In [3]:= DTPiecewiseConvolution [ twoPulses, Step [n], n ] Out [3]= --a (4 + n), -3, -1-, &gt; -3 a + 4 b, 3, Infinity-- In <ref> [4] </ref>:= PiecewiseToFormula [ conv, n, Domain -&gt; Discrete ] Out [4]= a (4 + n) Pulse [3 + n] + 3 &gt; (3 a + b + b n) Pulse [n] + 3 &gt; (3 a + 4 b) Step [-3 + n] In the Mathematica implementation of the convolution routines, <p> In [2]:= twoPulses = --a, -3, -1-, -b, 0, 3--; In [3]:= DTPiecewiseConvolution [ twoPulses, Step [n], n ] Out [3]= --a (4 + n), -3, -1-, &gt; -3 a + 4 b, 3, Infinity-- In <ref> [4] </ref>:= PiecewiseToFormula [ conv, n, Domain -&gt; Discrete ] Out [4]= a (4 + n) Pulse [3 + n] + 3 &gt; (3 a + b + b n) Pulse [n] + 3 &gt; (3 a + 4 b) Step [-3 + n] In the Mathematica implementation of the convolution routines, we have added a Dialogue option.
Reference: [5] <author> B. Char, K. Geddes, G. Gonnet, B. Leong, M. Monagan, and S. Watt, </author> <title> First Leaves: A Tutorial Introduction to Maple V. </title> <address> New York: </address> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We extend their work to handle infinite-extent functions and functions defined over symbolic end points. We have added our modifications to the Mathematica [4] code written by West and McClellan [3], and we have created an equivalent version for Maple V <ref> [5] </ref>. In Section 2, we highlight three methods to compute linear convolution. Section 3 discusses our modifications to the algorithm by West and McClellan to support piecewise functions with infinite and symbolic end points. Section 4 discusses the Mathematica and Maple implementations and give examples of convolution problems.
Reference: [6] <author> Z. Zuhao, </author> <title> "The square matrix rule of the convolution integral," </title> <journal> IEEE Trans. on Education, </journal> <volume> vol. 33, </volume> <pages> pp. 369-372, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: When the end points are symbolic, setting up the necessary limits on the definite integrations (or summations) requires reasoning about symbolic inequalities. 2.2. The Square Matrix Rule Zuhao reported the Square Matrix Rule <ref> [6] </ref> for continuous convolution of two finite-extent functions. The rule automates the setting up of the limits of integration and states that convolving two finite-extent intervals produces four finite-extent intervals.
Reference: [7] <author> B. L. Evans, L. J. Karam, K. A. West, and J. H. Mc-Clellan, </author> <title> "Learning signals and systems with Mathemat-ica," </title> <journal> IEEE Trans. on Education, </journal> <volume> vol. 36, </volume> <pages> pp. 72-78, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: We have generalized their implementation to work with infinite end points and symbolic end points, according to the strategy given in the previous section. The Mathematica implementation is part of the Signal Processing Packages (SPPs) <ref> [7, 8] </ref>. The convolution routines in Version 2.9.5 of the SPPs (see the end of the paper for FTP instructions) support infinite end points, but not symbolic end points. The complete implementation will be available in version 3.0 of the SPPs due for commercial release in January of 1995. <p> The complete implementation will be available in version 3.0 of the SPPs due for commercial release in January of 1995. The release of version 2 of the SPPs contains several tutorial notebooks, including one on convolution <ref> [7, 8] </ref>. The rest of this section will show examples of the convolution implementation in version 2.9.5 of the SPPs and an equivalent Maple V implementation. We use the same function names in both implementations.
Reference: [8] <author> B. L. Evans, J. H. McClellan, and H. J. Trussell, </author> <title> "Investigating signal processing theory with Mathematica," </title> <booktitle> in Proc. IEEE Int. Conf. Acoust., Speech, and Signal Processing, vol. I, </booktitle> <address> (Minneapolis, MN), </address> <pages> pp. 12-15, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: We have generalized their implementation to work with infinite end points and symbolic end points, according to the strategy given in the previous section. The Mathematica implementation is part of the Signal Processing Packages (SPPs) <ref> [7, 8] </ref>. The convolution routines in Version 2.9.5 of the SPPs (see the end of the paper for FTP instructions) support infinite end points, but not symbolic end points. The complete implementation will be available in version 3.0 of the SPPs due for commercial release in January of 1995. <p> The complete implementation will be available in version 3.0 of the SPPs due for commercial release in January of 1995. The release of version 2 of the SPPs contains several tutorial notebooks, including one on convolution <ref> [7, 8] </ref>. The rest of this section will show examples of the convolution implementation in version 2.9.5 of the SPPs and an equivalent Maple V implementation. We use the same function names in both implementations.
References-found: 8

