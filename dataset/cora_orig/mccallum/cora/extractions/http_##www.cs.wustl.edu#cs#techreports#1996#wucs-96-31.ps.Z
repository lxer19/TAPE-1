URL: http://www.cs.wustl.edu/cs/techreports/1996/wucs-96-31.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Building Distributed Applications with Design Patterns  
Author: Gruia-Catalin Roman James C. Hu 
Date: December 19, 1996  
Pubnum: WUCS-96-31  
Abstract: Design patterns are a topic of great current interest within the object-oriented programming community. The motivation is both economical and intellectual. On one hand, there is a need to leverage off past experiences on new projects. On the other hand, there is the hope of establishing a common culture and language that fosters communication and growth in the software engineering field. While a community dominated by empiricism is seeking to achieve higher levels of formality by capturing its experiences in the form of catalogs of design patterns, another community, deeply rooted in formal thinking, is seeking to make its mark on the every day workings of the software engineering process. Distributed algorithms and the heuristics used by program derivation methods represent a large repository of fundamental knowledge that has been acquired over the years by the distributed computing community. Attempts to make this body of knowledge available to the broader community have been frustrating to say the least. The main thesis of this paper is that design patterns are a viable mechanism by which distributed computing know-how can impact the practical development of dependability-minded distributed applications. We contend, however, that in order to do so one needs to view design patterns in a new perspective, more formal and more language-independent than the view adopted by the object-oriented programming community. The paper provides a possible characterization of the notion of a distributed design pattern and discusses ways by which design patterns can be transformed into specific applications. An airport baggage delivery system with distributed control is used for illustration purposes. fl This paper is based upon work supported in part by Siemens AG. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the views of Siemens. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.J.R. Back and K. Sere. </author> <title> Stepwise refinement of parallel algorithms. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 13(2-3):133-80, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Specification refinement [2] starts with an abstract formulation of the desired properties of the target program, usually expressed in logic, and gradually transforms it into an increasingly more concrete representation up to the point that writing a correct program becomes a trivial exercise. Program refinement <ref> [1] </ref>, on the other hand, uses a simple but correct program as the starting point for a serious of transformations that change it into another program which meets the same correctness criteria but it is more amenable to efficient implementation.
Reference: [2] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <month> May </month> <year> 1989. </year>
Reference-contexts: Our investigation is centered on application-specific systems of small to medium size. The approach we explore in this paper is akin to program derivation. Several forms of program derivation have been used successfully in both academic exercises and even in industrial-grade systems [12]. Specification refinement <ref> [2] </ref> starts with an abstract formulation of the desired properties of the target program, usually expressed in logic, and gradually transforms it into an increasingly more concrete representation up to the point that writing a correct program becomes a trivial exercise.
Reference: [3] <author> James O. Coplien and Douglas C. Schmidt. </author> <title> Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Conclusions are presented in Section 5. December 19, 1996 Building Distributed Applications with Design Patterns 4 2 Design Patterns Design pattern, as a technical software engineering term, has its origins in the object-oriented programming literature <ref> [6, 3] </ref>. In this paper we attempt to apply the basic concept to the realities of distributed computing.
Reference: [4] <editor> J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Stepwise Refinement of Distributed Systems, </booktitle> <publisher> LNCS 430. Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [5] <author> Edsger W. Dijkstra. </author> <title> Go to statement considered harmful. </title> <journal> Communications of the ACM, </journal> <volume> 11(3) </volume> <pages> 147-148, </pages> <month> March </month> <year> 1968. </year>
Reference-contexts: The idea is not new. Design rules and structured forms have been promoted for their ability to simplify verification. This very notion was central to the push for wide spread use of structured programming and block-structured languages <ref> [5] </ref>. Program derivation techniques have been the result of a philosophy which contends that one can deliver programs that are correct by construction through a process of gradual refinement.
Reference: [6] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Conclusions are presented in Section 5. December 19, 1996 Building Distributed Applications with Design Patterns 4 2 Design Patterns Design pattern, as a technical software engineering term, has its origins in the object-oriented programming literature <ref> [6, 3] </ref>. In this paper we attempt to apply the basic concept to the realities of distributed computing.
Reference: [7] <author> Matthew Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Another strategy is to build the system out of components and, after each step, to compute the properties of the composite from those of the components. Process algebras follow this particular strategy <ref> [7] </ref>. We too are interested in an engineering approach to the development of distributed systems. Our investigation is centered on application-specific systems of small to medium size. The approach we explore in this paper is akin to program derivation.
Reference: [8] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Refinement and projection of relational specifications. </title> <editor> In de Bakker et al. </editor> <volume> [4]. </volume>
Reference: [9] <author> Amy L. Murphy, Gruia-Catalin Roman, and George Varghese. </author> <title> An algorithm for message delivery to mobile nodes. </title> <type> Draft, </type> <month> November </month> <year> 1996. </year>
Reference-contexts: The focus is no longer on presenting and analyzing the solution to a specific problem but on structuring the algorithm and its properties for reusability. We experienced this first hand recently as part of an investigation into the application of established distributed algorithms to problems in mobile computing <ref> [9] </ref>.
Reference: [10] <author> Gruia-Catalin Roman, Rose F. Gamble, and William E. Ball. </author> <title> Formal derivation of rule-based programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 277-296, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Examples of mixed specification and program refinements can also be found in the literature <ref> [10, 11] </ref>. The novel elements of the program derivation strategy being explored in this paper are the use of design patterns and plastic transformations.
Reference: [11] <author> Gruia-Catalin Roman and C. Donald Wilcox. </author> <title> Architecture-directed refinement. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(4) </volume> <pages> 239-258, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Examples of mixed specification and program refinements can also be found in the literature <ref> [10, 11] </ref>. The novel elements of the program derivation strategy being explored in this paper are the use of design patterns and plastic transformations.
Reference: [12] <author> Mark G. Staskauskas. </author> <title> Formal derivation of concurrent programs: An example from industry. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 19(5) </volume> <pages> 503-528, </pages> <month> May </month> <year> 1993. </year> <month> December 19, </month> <year> 1996 </year>
Reference-contexts: Our investigation is centered on application-specific systems of small to medium size. The approach we explore in this paper is akin to program derivation. Several forms of program derivation have been used successfully in both academic exercises and even in industrial-grade systems <ref> [12] </ref>. Specification refinement [2] starts with an abstract formulation of the desired properties of the target program, usually expressed in logic, and gradually transforms it into an increasingly more concrete representation up to the point that writing a correct program becomes a trivial exercise.
References-found: 12

