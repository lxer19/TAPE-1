URL: http://www.cs.cornell.edu/kozen/papers/sclp.ps
Refering-URL: http://www.cs.cornell.edu/kozen/papers/papers.html
Root-URL: http://www.cs.cornell.edu
Title: Set Constraints and Logic Programming  
Author: Dexter Kozen 
Address: Ithaca, NY 14853-7501, USA  
Affiliation: Computer Science Department, Cornell University,  
Abstract: Set constraints are inclusion relations between expressions denoting sets of ground terms over a ranked alphabet. They are the main ingredient in set-based program analysis [4,5,15,16,19,23,24,26]. In this paper we describe a constraint logic programming language clp(sc) over set constraints in the style of Jaffar and Lassez [17]. The language subsumes ordinary logic programs over an Herbrand domain. We give an efficient unification algorithm and operational, declarative, and fixpoint semantics. We show how the language can be applied in set-based program analysis by deriving explicitly the monadic approximation of the collecting semantics of Heintze and Jaffar [15,16].
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken. </author> <type> Personal communication, </type> <year> 1994. </year>
Reference-contexts: Even in the presence of operators of arity two or greater, the following greedy heuristic may be useful in improving performance: always annihilate the u i that removes the largest number of constraints (20) with 0 on the right hand side. Aiken <ref> [1] </ref> also suggests the following heuristic: keep track of atoms that are necessary to the solution. For example, if u = u 1 ; : : : ; u n are all necessary and E f (u) = fu 0 g, then u 0 is necessary.
Reference: [2] <author> A. Aiken, D. Kozen, M. Vardi, and E. Wimmers. </author> <title> The complexity of set constraints. </title> <editor> In E. Borger, Y. Gurevich, and K. Meinke, editors, </editor> <booktitle> Proc. 1993 Conf. Computer Science Logic (CSL'93), volume 832 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 1-17. </pages> <institution> Eur. Assoc. Comput. Sci. </institution> <address> Logic, </address> <publisher> Springer, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: The following theorem was proved in <ref> [2] </ref>. Theorem 6 ([2]) Let C = (U; X; E; P ) be a system of set constraints in atomic form considered as a hypergraph as described above. <p> Here is an algorithm, which is essentially the same as the normal form algorithm of <ref> [2] </ref>. Let X be the set of variables appearing in the original system. These are the primary variables. <p> However, if there are no operators of arity two or greater, then there is no nondeterministic choice to be made and the process becomes deterministic. This is the essence of the proof of the result of <ref> [2] </ref> that the satisfiability problem can be solved in deterministic exponential time in this case.
Reference: [3] <author> A. Aiken, D. Kozen, and E. Wimmers. </author> <title> Decidability of systems of set constraints with negative constraints. </title> <institution> Infor. and Comput., </institution> <year> 1995. </year> <note> To appear. Also Cornell University Tech. Report 93-1362, </note> <month> June, </month> <year> 1993. </year>
Reference-contexts: In x4, we discuss techniques for solving set constraints, including the definition of a useful normal form. In x5, we give a unification algorithm based on the constraint satisfaction algorithm of <ref> [3] </ref>, as well as some heuristics which may improve performance.
Reference: [4] <author> A. Aiken and B. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proc. 1991 Conf. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year> <month> 26 </month>
Reference: [5] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Proc. 18th Symp. Principles of Programming Languages, </booktitle> <pages> pages 279-290. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference: [6] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Proc. 7th Symp. Logic in Computer Science, </booktitle> <pages> pages 329-340. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1992. </year>
Reference: [7] <author> L. Bachmair, H. Ganzinger, and U. Waldmann. </author> <title> Set constraints are the monadic class. </title> <booktitle> In Proc. 8th Symp. Logic in Computer Science, </booktitle> <pages> pages 75-83. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: This normal form corresponds to the combinatorial method of [2,3,20] involving hypergraphs. It is also strongly related to the automata-theoretic approach of [13,14] and to the approach of <ref> [7] </ref> involving finite models of monadic logic.
Reference: [8] <author> A. Cardon and M. Crochemore. </author> <title> Partitioning a graph in O(jAj log 2 jV j). </title> <journal> Theor. Comput. Sci, </journal> <volume> 19 </volume> <pages> 85-98, </pages> <year> 1982. </year>
Reference: [9] <author> W. Charatonik and L. Pacholski. </author> <title> Negative set constraints with equality. </title> <booktitle> In Proc. 9th Symp. Logic in Computer Science, </booktitle> <pages> pages 128-136. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1994. </year>
Reference: [10] <author> A. Dovier, E. G. Omodeo, E. Pontelli, and G. Rossi. </author> <title> Embedding finite sets in a logic programming language. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Proc. 3rd Int. Workshop Extensions of Logic Programming (ELP'92), volume 660 of Lect. Notes Artificial Intell., </booktitle> <pages> pages 150-167. </pages> <publisher> Springer, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: Kuper mentions a suitable treatment of negation as an important open problem. Dovier et al. <ref> [10] </ref> present a language with membership and equality predicates for finite sets and a constructor with for adding new elements to sets. Constraints are used in the unification process. Stolzenburg [28,29] introduces a logic programming language with finite sets in which membership is dealt with via constraints.
Reference: [11] <author> J. Englefriet. </author> <title> Tree automata and tree grammars. </title> <type> Technical Report DAIMI FN-10, </type> <institution> Aarhus University, </institution> <month> April </month> <year> 1975. </year>
Reference-contexts: It can be proved by induction on the depth of terms that any such system has a unique solution (see <ref> [11] </ref>). The family of regular sets over is denoted Reg . <p> The resulting system of equations (20) is of the form (13), which has a unique regular solution (see <ref> [11] </ref>). Moreover, every f (u) occurs in exactly one equation (20); this implies that (18) and (19) hold as well.
Reference: [12] <author> T. Fruhwirth, E. Shapiro, M. Y. Vardi, and E. Yardeni. </author> <title> Logic programs as types for logic programs. </title> <booktitle> In Proc. 6th Symp. Logic in Computer Science, </booktitle> <pages> pages 300-309. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: The domain of computation consists of all regular sets of ground terms, including infinite regular sets. Any such set can be uniquely specified by a finite collection of set constraints. All Boolean operations, including negation, are allowed. Negations are dealt with using a generalized DeMorgan law. Fruhwirth et al. <ref> [12] </ref> have also shown how to express the monadic approximation using logic programs. However, their approach is quite different: they transform a given logic program into another logic program such that the latter computes exactly the monadic approximation of the former.
Reference: [13] <author> R. Gilleron, S. Tison, and M. Tommasi. </author> <title> Solving systems of set constraints using tree automata. </title> <journal> In Proc. Symp. Theor. Aspects of Comput. Sci., </journal> <volume> volume 665, </volume> <pages> pages 505-514. </pages> <note> Springer-Verlag Lect. Notes in Comput. Sci., </note> <month> February </month> <year> 1993. </year>
Reference-contexts: For example, the system x = a [ g (y) y = g (x) (14) has the unique regular solution (x) = fg n (a) j n eveng (y) = fg n (a) j n oddg : Gilleron et al. <ref> [13] </ref> have shown that every satisfiable system of set constraints has a regular solution, i.e. one in which all variables are interpreted as regular 7 sets. We give an alternative proof of this fact below (Theorem 7). <p> However, as choices are made about which atoms to annihilate, the set of necessary atoms will increase, leading to more deterministic search in later steps. 4.4 Regular Solutions In this section we give an alternative proof of a result of Gilleron et al. <ref> [13] </ref> that we can restrict our attention to regular solutions of systems of set constraints. This result is essential in the semantics of clp (sc). 15 Theorem 7 ([13]) Every satisfiable system of set constraints has a regular solution. PROOF.
Reference: [14] <author> R. Gilleron, S. Tison, and M. Tommasi. </author> <title> Solving systems of set constraints with negated subset relationships. </title> <booktitle> In Proc. 34th Symp. Foundations of Comput. Sci., </booktitle> <pages> pages 372-380. </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1993. </year>
Reference: [15] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Although information is lost, enough is retained to allow useful program optimization and type inference, and the resulting systems remain decidable [2,3,6,7,9,13,14,27]. Heintze and Jaffar [16] and Heintze <ref> [15] </ref> apply set-based program analysis in both the imperative and logic programming settings. They first give a least fixpoint characterization of the sets of valuations of program variables that can occur at each point in a program during execution; this is called the collecting semantics. <p> Heintze and Jaffar [16] introduced the technique of monadic approximation in which variable interdependencies are ignored. See <ref> [15] </ref> for a thorough intro 21 duction to this technique and examples of its application to imperative and logic programs. <p> Extending the language to handle these constructs constitutes a worthwhile topic for further investigation. 6.1 Collecting Semantics The collecting semantics associates with each point in the program the set of valuations of program variables that can occur at that point during execution. Following Heintze <ref> [15] </ref>, we describe here the collecting semantics for while programs. Let p be a while program and let X be the set of program variables occurring in p. We associate with each subprogram q two points, one just before and one just after q. <p> Each such point is labeled with a letter a; b; c; : : : We denote by a the set of valuations : X ! fvaluesg of program variables that ever occur at point a during execution. Heintze <ref> [15] </ref> gives a system of set inclusions whose least solution characterizes the sets a exactly. These are given in Figure 1. <p> If s is the starting point of the program, then we set s = f 0 g, where 0 is some initial valuation. 6.2 Monadic Approximation Heintze <ref> [15] </ref> shows that the monadic approximation to the collecting semantics can be computed as the least solution to the same set of equations as in Figure 1, except that the meaning of a is altered to ignore dependencies among variables. <p> One can show that b a (x) is a superset of the set f (x) j 2 a g of the values assigned to x under the old interpretation; i.e., the monadic interpretation is a safe approximation to the collecting semantics. See Heintze <ref> [15] </ref> for further details. Below we give a clp (sc) program to compute the monadic approximation to the collecting semantics.
Reference: [16] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In Proc. 17th Symp. Principles of Programming Languages, </booktitle> <pages> pages 197-209. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Although information is lost, enough is retained to allow useful program optimization and type inference, and the resulting systems remain decidable [2,3,6,7,9,13,14,27]. Heintze and Jaffar <ref> [16] </ref> and Heintze [15] apply set-based program analysis in both the imperative and logic programming settings. They first give a least fixpoint characterization of the sets of valuations of program variables that can occur at each point in a program during execution; this is called the collecting semantics. <p> Of course this is undecidable in general, but it is often possible to describe a superset of the values a variable can take on at a given point, and this approximate information may still be useful in performing optimizations. Heintze and Jaffar <ref> [16] </ref> introduced the technique of monadic approximation in which variable interdependencies are ignored. See [15] for a thorough intro 21 duction to this technique and examples of its application to imperative and logic programs. <p> diagonal set f j (x) = (y)g to obtain the set [x = y] as defined above. (Any other reasonable test can be used here.) (iii) Take b [x = y] = x 2 X:f (x) j 2 [x = y]g ; the so-called cartesian closure of [x = y] <ref> [16] </ref>. This is the smallest set valuation approximating [x = y]. 24 This construction is illustrated in the following diagram. y ? b (x) = (y) The construction of b [x 6= y] is similar, except that the set f j (x) 6= (y)g is used in step (ii).
Reference: [17] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proc. Symp. Principles of Programming Languages (POPL) 1987, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: One might desire a language in which algorithms in set-based program analysis can be easily expressed. In this paper we introduce a logic programming language clp (sc) for this purpose. The language clp (sc) is a constraint logic programming language in the style of Jaffar and Lassez <ref> [17] </ref> using set constraints over an Herbrand domain. Sets of ground terms satisfy many nice algebraic properties. An axiomatization of these properties was proposed in [20] (see x2.1 below). Models of these axioms are called termset algebras. <p> Formally, the law can be derived from the termset algebra axioms by purely equational reasoning. 3 clp (sc) In this section we describe a logic programming language clp (sc), a constraint logic programming language in the style of Jaffar and Lassez <ref> [17] </ref> over set constraints. We describe the syntax of the language and give three equivalent semantics: operational, declarative or model-theoretic, and fixpoint. The equivalence of these three semantics follows from standard results and techniques of constraint logic programming [17]. 5 3.1 Examples Before describing the syntax and semantics of the language <p> a constraint logic programming language in the style of Jaffar and Lassez <ref> [17] </ref> over set constraints. We describe the syntax of the language and give three equivalent semantics: operational, declarative or model-theoretic, and fixpoint. The equivalence of these three semantics follows from standard results and techniques of constraint logic programming [17]. 5 3.1 Examples Before describing the syntax and semantics of the language clp (sc), here are some sample programs to whet the intuition. Consider the clauses sng (a): for all constants a 2 and function symbols f 2 of arity n 1. <p> The domain of regular sets also satisfies the two fundamental desiderata for constraint logic programming languages as set forth in <ref> [17] </ref>, namely: Every element of the domain is the unique solution of a finite or infinite family of constraints. In fact, every regular set is the unique solution of a finite family of constraints of the form (13). <p> Following <ref> [17] </ref>, our operational semantics involves sequences of one-step derivations of the form p (s); B; C ! s = t; B; B 0 ; C; C 0 (15) which reduces the goal on the left hand side to the goal on the right hand side whenever there is a fresh instantiation <p> Let M be the model specified by as described in x3.5; i.e., M = . The following results assert the equivalence of these three semantics. The proofs are standard, using results and techniques of logic programming and constraint logic programming <ref> [17] </ref>. Lemma 1 The set M is a prefixpoint of T (i.e., T ( M ) M ) if and only if M j= . By the Knaster-Tarski Theorem, the least prefixpoint of T is also its least fixpoint. It follows that M is the minimal model of .
Reference: [18] <author> B. Jayaraman and D. A. Plaisted. </author> <title> Programming with equations, subsets, and relations. </title> <editor> In E. L. Lusk and R. A. Overbeek, editors, </editor> <booktitle> Proc. North Amer. Conf. Logic Programming 1989, </booktitle> <volume> volume 2, </volume> <pages> pages 1051-1068. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year> <month> 27 </month>
Reference-contexts: The language clp (sc) subsumes ordinary logic programming over an Her-brand domain, since ground terms can be identified with singleton sets, and singleton sets are definable in clp (sc). There have been several previous approaches to augmenting logic programming languages with sets. Jayaraman and Plaisted <ref> [18] </ref> present a language in the equational programming style which combines relational, subset, and equational assertions. Operational and fixpoint semantics are given. A collect all property is posed as part of the semantics, which plays the same role as minimal models or least fixpoints in logic programming.
Reference: [19] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Proc. 6th Symp. Principles of Programming Languages, </booktitle> <pages> pages 244-256. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1979. </year>
Reference: [20] <author> D. Kozen. </author> <title> Logical aspects of set constraints. </title> <editor> In E. Borger, Y. Gurevich, and K. Meinke, editors, </editor> <booktitle> Proc. 1993 Conf. Computer Science Logic (CSL'93), volume 832 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 175-188. </pages> <institution> Eur. Assoc. Comput. Sci. </institution> <address> Logic, </address> <publisher> Springer, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: The language clp (sc) is a constraint logic programming language in the style of Jaffar and Lassez [17] using set constraints over an Herbrand domain. Sets of ground terms satisfy many nice algebraic properties. An axiomatization of these properties was proposed in <ref> [20] </ref> (see x2.1 below). Models of these axioms are called termset algebras. The axioms of termset algebra are reminiscent of the Clark axioms for Herbrand domains; in fact, constraint logic programming over set constraints and conventional logic programming over Herbrand domains have much in common. <p> A system C of set constraints is satisfiable if there is a set valuation that satisfies all the constraints in C; in this case we write j= C and say is a solution of C. 2.1 Axioms of Termset Algebra In <ref> [20] </ref>, the following axiomatization of the algebra of sets of ground terms was introduced: f (: : : ; x [ y; : : :) = f (: : : ; x; : : :) [ f (: : : ; y; : : :) (2) [ f (1; : : <p> The hypergraph is said to have a closed induced subhypergraph if there is a subset V U such that for every f 2 n and every n-tuple u 2 V n , the set E f (u) intersects V . The notion of closure is captured axiomatically by (6) <ref> [20] </ref>.
Reference: [21] <author> D. Kozen. </author> <title> Set constraints and logic programming (abstract). </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Proc. First Conf. Constraints in Computational Logics (CCL'94), volume 845 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 302-303. </pages> <publisher> ESPRIT, Springer, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: The support of the National Science Foundation under grant CCR-9317320 and the U.S. Army Research Office through the ACSyAM branch of the Mathematical Sciences Institute of Cornell University under contract DAAL03-91-C-0027 is gratefully acknowledged. An abstract of this paper appeared in <ref> [21] </ref>.
Reference: [22] <author> G. M. Kuper. </author> <title> Logic programming with sets. </title> <booktitle> In Proc. Symp. Principles of Database Systems (PODS) 1987, </booktitle> <pages> pages 11-20. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Operational and fixpoint semantics are given. A collect all property is posed as part of the semantics, which plays the same role as minimal models or least fixpoints in logic programming. Kuper <ref> [22] </ref> presents a language with two types of objects, individuals and sets, and a membership predicate.
Reference: [23] <author> P. Mishra. </author> <title> Towards a theory of types in PROLOG. </title> <booktitle> In Proc. 1st Symp. Logic Programming, </booktitle> <pages> pages 289-298. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference: [24] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proc. 12th Symp. Principles of Programming Languages, </booktitle> <pages> pages 7-21. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference: [25] <author> R. Paige and R. E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 16(6) </volume> <pages> 973-989, </pages> <year> 1987. </year>
Reference: [26] <author> J. C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68, </booktitle> <pages> pages 456-461. </pages> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference: [27] <author> K. Stefansson. </author> <title> Systems of set constraints with negative constraints are NEXPTIME-complete. </title> <booktitle> In Proc. 9th Symp. Logic in Computer Science, </booktitle> <pages> pages 137-141. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1994. </year>
Reference: [28] <author> F. Stolzenburg. </author> <title> An algorithm for general set unification and its complexity. </title> <editor> In E. Omodeo and G. Rossi, editors, </editor> <booktitle> Proc. Workshop Logic Programming with Sets, in conjunction with 10th Int. Conf. Logic Programming, </booktitle> <pages> pages 17-22, </pages> <month> June </month> <year> 1993. </year>
Reference: [29] <author> F. Stolzenburg. </author> <title> Logic programming with sets by membership-constraints. </title> <editor> In N. E. Fuchs and G. Gottlob, editors, </editor> <booktitle> Proceedings of the 10th Logic Programming Workshop, </booktitle> <address> Universitat Zurich, </address> <year> 1994. </year> <institution> Institut fur Informatik. </institution> <type> Technical Report ifi 94.10. 28 </type>
References-found: 29

