URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/ilps93.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: kohlhase@cs.uni-sb.de  fp@cs.cmu.edu  
Title: Unification in a -Calculus with Intersection Types  
Author: Michael Kohlhase Frank Pfenning 
Address: W-6600 Saarbrucken, Germany  Pittsburgh, PA 15213, USA  
Affiliation: FB Informatik Universitat des Saarlandes  Department of Computer Science Carnegie Mellon University  
Abstract: We propose related algorithms for unification and constraint simplification in !& , a refinement of the simply-typed -calculus with subtypes and bounded intersection types. !& is intended as the basis of a logical framework in order to achieve more succinct and declarative axiomatizations of deductive systems than possible with the simply-typed -calculus. The unification and constraint simplification algorithms described here lay the groundwork for a mechanization of such frameworks as constraint logic programming languages and theorem provers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Coppo and P. Giannini. </author> <title> A complete type inference algorithm for simple intersection types. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> 17th Colloquium on Trees in Algebra and Programming, Rennes, France, </booktitle> <pages> pages 102-123, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag LNCS 581. </note>
Reference-contexts: We will call A & B the intersection of A and B, but refer to A and B as its conjuncts. Our system is more restrictive than customary formulations of intersection types (see, for example, <ref> [1, 19, 20] </ref>). The validity judgments below introduce a distinction between proper types and sorts. Proper types behave essentially like simple types and do not contain intersections.
Reference: [2] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Com puter and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-89-53. </note>
Reference-contexts: We have many other examples where refinement types are beneficial in higher-order logic programming. For example, in the higher-order representation of natural deductions <ref> [2] </ref> one can distinguish normal forms as a refinement of arbitrary derivations instead of explicitly encoding two different representations. In the implementation of functional languages [4] refinement types can distinguish values from arbitrary expressions instead of leaving this distinction implicit.
Reference: [3] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Proper types behave essentially like simple types and do not contain intersections. Sorts further refine proper types by enabling a more precise classification of terms, but sorts can only be intersected or compared if they refine the same proper type. In the context of a functional language as in <ref> [3] </ref>, this leads to a decidable type inference problem. Here we are more concerned with the fact that the adequacy of representations in the logical framework is preserved.
Reference: [4] <author> John Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Language for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> January </month> <year> 1991. </year> <note> Available as MS-CIS-91-09. </note>
Reference-contexts: We have many other examples where refinement types are beneficial in higher-order logic programming. For example, in the higher-order representation of natural deductions [2] one can distinguish normal forms as a refinement of arbitrary derivations instead of explicitly encoding two different representations. In the implementation of functional languages <ref> [4] </ref> refinement types can distinguish values from arbitrary expressions instead of leaving this distinction implicit. The interested reader is referred to [17] for further examples and discussion. 3 Basic Definitions The syntax of !& is that of the simply-typed -calculus augmented with the intersection operator & for types.
Reference: [5] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The motivation for our work comes from the area of logical frameworks. A logical framework is a meta-language for the specification and implementation of deductive systems as they arise in logic and the study of programming languages. Examples of such frameworks are LF <ref> [5] </ref>, hereditary Harrop formulae [12], and ALF [10]. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog [13] and Elf [16].
Reference: [6] <author> P. M. Hill. </author> <title> Combining prescriptive and taxonomic types in logic programming. </title> <note> Submitted, </note> <month> January </month> <year> 1993. </year>
Reference-contexts: In first-order languages the potential of order-sorted type structures have long been realized (see, for example, <ref> [22, 21, 6] </ref>) and we see our work as a natural extension of these efforts. At the heart of theorem proving or logic programming lies unification. <p> We conclude the paper by presenting transformations for unification restricted to higher-order patterns in the sense of Miller [11]. 2 A Motivating Example The value of subsorting (sometimes called subtyping) for first-order logic programming languages has long been recognized and extensively investigated (see, for example, <ref> [22, 6, 18] </ref>). Type systems with subsorts afford a concise, yet declaratively correct formulation of many programs. Furthermore, many programming errors manifest themselves as type errors at compile-time.
Reference: [7] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: At the heart of theorem proving or logic programming lies unification. In this paper we present 3 related algorithms for unification and constraint simplification for !& , a refinement of the simply-typed -calculus with subtypes and bounded intersection types. It builds upon Huet's algorithm for the simply-typed -calculus <ref> [7] </ref> and extensions to related languages by Nipkow and Qian [14] and the first author [8, 9], although the systems are incomparable in terms of their expressive power. The motivating example below should help to illustrate the differences.
Reference: [8] <author> Michael Kohlhase. </author> <title> Order-sorted type theory I: Unification. </title> <type> SEKI Report SR-91-18, </type> <institution> Universitat des Saarlandes, Saarbrucken, Germany, </institution> <year> 1991. </year>
Reference-contexts: It builds upon Huet's algorithm for the simply-typed -calculus [7] and extensions to related languages by Nipkow and Qian [14] and the first author <ref> [8, 9] </ref>, although the systems are incomparable in terms of their expressive power. The motivating example below should help to illustrate the differences. A -calculus with simple subtypes as considered by [14] contains no intersections and type labels on -abstractions are not interpreted as bounds.
Reference: [9] <author> Michael Kohlhase. </author> <title> Unification in order-sorted type theory. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 421-432, </pages> <address> St. Pe-tersburg, Russia, July 1992. </address> <publisher> Springer-Verlag LNAI 624. </publisher>
Reference-contexts: It builds upon Huet's algorithm for the simply-typed -calculus [7] and extensions to related languages by Nipkow and Qian [14] and the first author <ref> [8, 9] </ref>, although the systems are incomparable in terms of their expressive power. The motivating example below should help to illustrate the differences. A -calculus with simple subtypes as considered by [14] contains no intersections and type labels on -abstractions are not interpreted as bounds. <p> A -calculus with simple subtypes as considered by [14] contains no intersections and type labels on -abstractions are not interpreted as bounds. This means that the necessary sort computations for our algorithm are significantly more complex. The system considered by the first author in <ref> [9] </ref> permits so-called term declarations which lead to an undecidable type-checking problem and is thus in some ways more general. <p> In contrast to the simply typed -calculus, general bindings for terms in !& are not unique up to the choice of the new variables. Therefore we obtain additional nondeterminism in the imitation and projection steps. However, in contrast to the case with full term declarations <ref> [9] </ref>, we have that type-erasures of all general bindings are unique and the types of the new variables only depend on the types of the binding and its head.
Reference: [10] <author> Lena Magnusson. </author> <title> The new implementation of ALF. </title> <editor> In B. Nordstrom, K. Petersson, and G. Plotkin, editors, </editor> <booktitle> Proceedings of the 1992 Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 265-282, </pages> <address> B-astad, Sweden, </address> <month> June </month> <year> 1992. </year> <institution> University of Goteborg. </institution>
Reference-contexts: A logical framework is a meta-language for the specification and implementation of deductive systems as they arise in logic and the study of programming languages. Examples of such frameworks are LF [5], hereditary Harrop formulae [12], and ALF <ref> [10] </ref>. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog [13] and Elf [16].
Reference: [11] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 321-358, </pages> <year> 1992. </year>
Reference-contexts: We begin with a motivating example in the context of Prolog, followed by the definition of !& . We then discuss general (pre)-unification in !& . We conclude the paper by presenting transformations for unification restricted to higher-order patterns in the sense of Miller <ref> [11] </ref>. 2 A Motivating Example The value of subsorting (sometimes called subtyping) for first-order logic programming languages has long been recognized and extensively investigated (see, for example, [22, 6, 18]). Type systems with subsorts afford a concise, yet declaratively correct formulation of many programs. <p> In order to simplify the presentation of the algorithm, we assume that all unification formulae are in 98-form. Each formula is equivalent to one in this form by raising <ref> [11] </ref>. We will refer to the universally quantified variables as parameters and use the meta-variables u and v to range over parameters. Note that they may not occur in the substitution terms for existential vari-ables, which we denote by x, y, and z. <p> Furthermore we require the structural rules that deal with quantifier exchange from <ref> [11] </ref> and rules to erase &gt; from a conjunction. These transformations (and those of the following unification algorithms) can be employed by very different algorithms, depending on the strategy involved in constraint simplification.
Reference: [12] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction The motivation for our work comes from the area of logical frameworks. A logical framework is a meta-language for the specification and implementation of deductive systems as they arise in logic and the study of programming languages. Examples of such frameworks are LF [5], hereditary Harrop formulae <ref> [12] </ref>, and ALF [10]. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog [13] and Elf [16]. <p> Programs and goals must be restricted in order to guarantee that the uniform proof property is satisfied for the resulting logic and goal-directed search will be complete. The restriction we show here is to higher-order hereditary Harrop formulae <ref> [12] </ref>. The notation At r stands for rigid atoms, that is, atoms whose head must be a constant.
Reference: [13] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Examples of such frameworks are LF [5], hereditary Harrop formulae [12], and ALF [10]. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog <ref> [13] </ref> and Elf [16]. Extensive experiments in logic and the theory of programming languages have been carried out in these implementations.
Reference: [14] <author> Tobias Nipkow and Zhenyu Qian. </author> <title> Reduction and unification in lambda calculi with subtypes. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 66-78, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: In this paper we present 3 related algorithms for unification and constraint simplification for !& , a refinement of the simply-typed -calculus with subtypes and bounded intersection types. It builds upon Huet's algorithm for the simply-typed -calculus [7] and extensions to related languages by Nipkow and Qian <ref> [14] </ref> and the first author [8, 9], although the systems are incomparable in terms of their expressive power. The motivating example below should help to illustrate the differences. A -calculus with simple subtypes as considered by [14] contains no intersections and type labels on -abstractions are not interpreted as bounds. <p> for the simply-typed -calculus [7] and extensions to related languages by Nipkow and Qian <ref> [14] </ref> and the first author [8, 9], although the systems are incomparable in terms of their expressive power. The motivating example below should help to illustrate the differences. A -calculus with simple subtypes as considered by [14] contains no intersections and type labels on -abstractions are not interpreted as bounds. This means that the necessary sort computations for our algorithm are significantly more complex. <p> But this fact cannot be expressed in a system of simple subtypes (such as the one considered in <ref> [14] </ref>): we need to add intersection types, written as A 1 & A 2 .
Reference: [15] <author> Lawrence C. Paulson and Tobias Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Examples of such frameworks are LF [5], hereditary Harrop formulae [12], and ALF [10]. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle <ref> [15] </ref> and the logic programming languages Prolog [13] and Elf [16]. Extensive experiments in logic and the theory of programming languages have been carried out in these implementations.
Reference: [16] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Examples of such frameworks are LF [5], hereditary Harrop formulae [12], and ALF [10]. All these frameworks are based on some type theory. They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog [13] and Elf <ref> [16] </ref>. Extensive experiments in logic and the theory of programming languages have been carried out in these implementations. In a recent paper [17] the second author has proposed a refinement of the type theory underlying the LF logical framework in order to simplify the presentation of many deductive systems. <p> We would also like to extend the algorithm to & , a type theory with intersection and dependent types proposed in [17]. An extension of the language Elf <ref> [16] </ref> along these lines would be based on a constraint solver (rather than a unification or pre-unification algorithm) that solves pattern unification problems, but maintains other equations and sort conditions as constraints.
Reference: [17] <author> Frank Pfenning. </author> <title> Intersection types for a logical framework. </title> <type> POP Report 92-006, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: They have been used as the basis for the logic-independent theorem prover Isabelle [15] and the logic programming languages Prolog [13] and Elf [16]. Extensive experiments in logic and the theory of programming languages have been carried out in these implementations. In a recent paper <ref> [17] </ref> the second author has proposed a refinement of the type theory underlying the LF logical framework in order to simplify the presentation of many deductive systems. This refinement, & , incorporates subtypes and intersection types. <p> In the implementation of functional languages [4] refinement types can distinguish values from arbitrary expressions instead of leaving this distinction implicit. The interested reader is referred to <ref> [17] </ref> for further examples and discussion. 3 Basic Definitions The syntax of !& is that of the simply-typed -calculus augmented with the intersection operator & for types. The main change in the language concerns signatures, where we drop the restriction that each constant be declared at most once. <p> By the restrictions sketched above only finitely many such sorts B exist up to a simple syntactic equivalence. For further discussion and some examples the interested reader is referred to <ref> [17] </ref>. 3.1 Judgments The validity judgments have the following form. <p> This situation is familiar from (first-order) order-sorted logic programming and we believe that such static analysis is necessary to obtain a practical system. We would also like to extend the algorithm to & , a type theory with intersection and dependent types proposed in <ref> [17] </ref>. An extension of the language Elf [16] along these lines would be based on a constraint solver (rather than a unification or pre-unification algorithm) that solves pattern unification problems, but maintains other equations and sort conditions as constraints.
Reference: [18] <author> Frank Pfenning, </author> <title> editor. Types in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: We conclude the paper by presenting transformations for unification restricted to higher-order patterns in the sense of Miller [11]. 2 A Motivating Example The value of subsorting (sometimes called subtyping) for first-order logic programming languages has long been recognized and extensively investigated (see, for example, <ref> [22, 6, 18] </ref>). Type systems with subsorts afford a concise, yet declaratively correct formulation of many programs. Furthermore, many programming errors manifest themselves as type errors at compile-time.
Reference: [19] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymorphism. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mel-lon University, </institution> <month> December </month> <year> 1991. </year> <note> Available as Technical Report CMU-CS-91-205. </note>
Reference-contexts: We will call A & B the intersection of A and B, but refer to A and B as its conjuncts. Our system is more restrictive than customary formulations of intersection types (see, for example, <ref> [1, 19, 20] </ref>). The validity judgments below introduce a distinction between proper types and sorts. Proper types behave essentially like simple types and do not contain intersections. <p> Following Pierce <ref> [19] </ref>, we formulate new versions of these judgments which directly embody an algorithm for deciding subsorting and synthesizing a minimal type for an object. We start with the algorithmic version of the subtype judgment, ` A v B. <p> Furthermore, if A and B are types not containing the * operator such that ` A :: C and ` B :: C for some C, then ` A B, iff ` A v B. Proof: By an interpretation into Pierce's system <ref> [19] </ref>. The second judgment expresses that M has minimal type A, written as ` M 2 A. For the purposes of this system and the remainder of the paper, it is convenient to treat intersection as an operator on multiple arguments and occasionally a set of arguments.
Reference: [20] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: We will call A & B the intersection of A and B, but refer to A and B as its conjuncts. Our system is more restrictive than customary formulations of intersection types (see, for example, <ref> [1, 19, 20] </ref>). The validity judgments below introduce a distinction between proper types and sorts. Proper types behave essentially like simple types and do not contain intersections.
Reference: [21] <author> Manfred Schmidt-Schau. </author> <title> Computational Aspects of an Order-Sorted Logic with Term Declarations. </title> <publisher> Springer-Verlag LNAI 395, </publisher> <year> 1989. </year>
Reference-contexts: In first-order languages the potential of order-sorted type structures have long been realized (see, for example, <ref> [22, 21, 6] </ref>) and we see our work as a natural extension of these efforts. At the heart of theorem proving or logic programming lies unification.
Reference: [22] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> Dissertation, </type> <institution> Universitat Kaiserslautern, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: In first-order languages the potential of order-sorted type structures have long been realized (see, for example, <ref> [22, 21, 6] </ref>) and we see our work as a natural extension of these efforts. At the heart of theorem proving or logic programming lies unification. <p> We conclude the paper by presenting transformations for unification restricted to higher-order patterns in the sense of Miller [11]. 2 A Motivating Example The value of subsorting (sometimes called subtyping) for first-order logic programming languages has long been recognized and extensively investigated (see, for example, <ref> [22, 6, 18] </ref>). Type systems with subsorts afford a concise, yet declaratively correct formulation of many programs. Furthermore, many programming errors manifest themselves as type errors at compile-time.
Reference: [23] <author> Wayne Snyder. </author> <title> A Proof Theory for General Unification. </title> <booktitle> Progress in Computer Science and Applied Logic. </booktitle> <publisher> Birkhauser, </publisher> <year> 1991. </year>
Reference-contexts: T ; y 2 :F ! T & T ! F 5 General Unification and Pre-Unification Building upon the notion of general binding and type constraint simplification we give a set of transformations for general unification and pre unification, which we will prove correct and complete with the methods of <ref> [23] </ref>. <p> The soundness of the transformations can readily be established from the soundness of the constraint simplifier and lemmata 8 and 4 by using the techniques from <ref> [23] </ref>. Now we will turn to the completeness of the transformations.
References-found: 23

