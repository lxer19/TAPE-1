URL: http://www.eecs.umich.edu/~tyson/Postscript/IJPP96.ps.gz
Refering-URL: http://www.eecs.umich.edu/~tyson/publications.html
Root-URL: http://www.cs.umich.edu
Email: (tyson@cs.ucr.edu) (farrens@cs.ucdavis.edu)  
Title: d d Evaluating the Effects of Predicated Execution on Branch Prediction  
Author: Gary Tyson Matthew Farrens 
Note: This work was supported by National Science Foundation Grants CCR-8706722 and CCR-90-11535.  
Address: Riverside, CA Davis, CA 95616  
Affiliation: Department of Computer Science Computer Science Department University of California, Riverside University of California, Davis  
Abstract: High performance architectures have always had to deal with the performance-limiting impact of branch operations. Microprocessor designs are going to have to deal with this problem as well, as they move towards deeper pipelines and support for multiple instruction issue. Branch prediction schemes are often used to alleviate the negative impact of branch operations by allowing the speculative execution of instructions after an unresolved branch. Another technique is to eliminate branch instructions altogether. Predication can remove forward branch instructions by translating the instructions following the branch into predicate form. This paper analyzes a variety of existing predication models for eliminating branch operations, and the effect that this elimination has on the branch prediction schemes in existing processors, including single issue architectures with simple prediction mechanisms, to the newer multi-issue designs with correspondingly more sophisticated branch predictors. The effect on branch prediction accuracy, branch penalty and basic block size is studied. hhhhhhhhhhhhhhhhhhhhhhhh
Abstract-found: 1
Intro-found: 1
Reference: [AlAv93] <author> D. Alpert and D. Avnon, </author> <title> ``Architecture of the Pentium Microprocessor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 11-21. </pages>
Reference-contexts: The entry is later updated to reflect the actual condition of the branch. The prediction approach used by the Pentium processor <ref> [AlAv93] </ref> features a 256 entry Branch Target Buffer (BTB). Each BTB entry contains the target address of the branch and a two bit counter used to store previous branch activity associated with that address. The BTB is 4-way set associative and uses a random replacement strategy.
Reference: [AADM93] <author> T. Asprey, G. S. Averill, E. DeLano, R. Mason, B. Weiner and J. Yetter, </author> <title> ``Performance Features of the PA7100 Microprocessor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 22-35. </pages>
Reference-contexts: The simplest of schemes predicts that all branches will be taken thus the processor will always d d attempt to fetch instructions from the target of the branch. The Hewlett Packard Precision RISC Architecture (PA-RISC) <ref> [AADM93] </ref> uses a static prediction method for calculating the direction of instruction flow across branches termed Branch Backward. In this scheme, all forward branches are predicted not to be taken and all backward branches are predicted to be taken.
Reference: [CMCW91] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter and W. Hwu, </author> <title> ``IMPACT: An Architectural Framework for Multiple-Instruction-Issue Processors'', </title> <booktitle> Proceedings of the Eighteenth Annual International Symposium on Computer Architecture, </booktitle> <address> Toronto, Canada (May 27-30, </address> <year> 1991), </year> <pages> pp. 266-275. </pages> <address> d d </address>
Reference-contexts: Predication, on the other hand, is a technique for completely removing conditional branches from the instruction stream via the conditional execution (or completion) of individual instructions based on the result of a boolean condition. This is a much more recent area of research <ref> [CMCW91, DeHB89] </ref> although vector machines like the CRAY [Russ78] have long supported a type of predicated execution with their vector masks.
Reference: [DeHB89] <author> J. C. Dehnert, P. Y. T. Hsu and J. P. Bratt, </author> <title> ``Overlapped Loop Support for the Cydra 5'', </title> <booktitle> Proceedings of the 17th Annual Symposium on Computer Architecture(May 1989), </booktitle> <pages> pp. 26-38. </pages>
Reference-contexts: Predication, on the other hand, is a technique for completely removing conditional branches from the instruction stream via the conditional execution (or completion) of individual instructions based on the result of a boolean condition. This is a much more recent area of research <ref> [CMCW91, DeHB89] </ref> although vector machines like the CRAY [Russ78] have long supported a type of predicated execution with their vector masks.
Reference: [FiFr92] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> ``Predicting Conditional Branch Directions from Previous Runs of a Program'', </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Boston, MA (October 12-15, </address> <year> 1992), </year> <pages> pp. 85-95. </pages>
Reference-contexts: This has been an active area of research for many years, and continues to be to this day [Smit81] [LeS84] <ref> [FiFr92] </ref> [YeP93]. There are two main approaches to branch prediction static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [HePa90] <author> J. Hennessy and D. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, California, </address> <year> (1990). </year>
Reference: [LeS84] <author> J. K. L. Lee and A. J. Smith, </author> <title> ``Branch Prediction Strategies and Branch Target Buffer Design'', </title> <journal> Computer, </journal> <volume> vol. 17, no. </volume> <month> 1 (January </month> <year> 1984), </year> <pages> pp. 6-22. </pages>
Reference-contexts: Branch prediction eliminates much of the branch delay by predicting the direction the branch will take before the actual direction is known, and continuing instruction fetch along that instruction pathway. This has been an active area of research for many years, and continues to be to this day [Smit81] <ref> [LeS84] </ref> [FiFr92] [YeP93]. There are two main approaches to branch prediction static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [McLe93] <author> E. McLellan, </author> <title> ``The Alpha AXP Architecture and 21064 Processor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 35-47. </pages>
Reference-contexts: In this scheme, all forward branches are predicted not to be taken and all backward branches are predicted to be taken. This scheme performs better than branch always when applications contain forward branches that are not taken more often than they are taken. The Alpha processor <ref> [McLe93, Site92] </ref> supports three different prediction methods: opcode specified hints, a branch backward strategy, and a one bit branch history table. While a given implementation of the Alpha architecture may use any or all of these methods, in this study only the last two were modeled.
Reference: [PnSo94] <author> D. N. Pnevmatikatos and G. S. Sohi, </author> <title> ``Guarded Execution and Branch Prediction in Dynamic ILP Processors'', </title> <booktitle> Proceedings of the 21th Annual Symposium on Computer Architecture, </booktitle> <address> Chicago, Illinois (April 18-21, </address> <year> 1994), </year> <pages> pp. 120-129. </pages>
Reference-contexts: Another way is to introduce a special instruction which controls the conditional execution of following (non-predicated) instructions. An example of this approach is seen in the guarded execution model proposed by Pnevmatikatos and Sohi <ref> [PnSo94] </ref>, which includes special instructions whose execution specify whether following instructions should or should not be executed. This section will present 4 different existing predication models, those used in the Alpha processor, the HP-RISC, guarded execution model and the Cydra 5.
Reference: [Russ78] <author> R. M. Russell, </author> <title> ``The CRAY-1 Computer System'', </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. </volume> <month> 1 (January </month> <year> 1978), </year> <pages> pp. 63-72. </pages>
Reference-contexts: This is a much more recent area of research [CMCW91, DeHB89] although vector machines like the CRAY <ref> [Russ78] </ref> have long supported a type of predicated execution with their vector masks. This is a very promising area of research because, in hhhhhhhhhhhhhhhhhhhhhhhh d d addition to removing the branch itself from instruction stream, it provides the additional benefit of improving scheduling capability. <p> Support for multiple guards can be provided by allowing additional guard instructions to modify those entries in the scalar mask that have not been previously marked for elimination. This approach is reminiscent of the vector mask register approach used on earlier vector processors <ref> [Russ78] </ref>, with the bit mask controlling the issue of a sequence of instructions in the instruction stream instead of the ALU operations in vector instruction. It is unclear how guarded branch instruction can be handled or what effect guarding will have on fetch latency.
Reference: [Site92] <author> R. L. </author> <title> Sites, ``Alpha Architecture Reference manual'', </title> <publisher> Digital Press(1992). </publisher>
Reference-contexts: In this scheme, all forward branches are predicted not to be taken and all backward branches are predicted to be taken. This scheme performs better than branch always when applications contain forward branches that are not taken more often than they are taken. The Alpha processor <ref> [McLe93, Site92] </ref> supports three different prediction methods: opcode specified hints, a branch backward strategy, and a one bit branch history table. While a given implementation of the Alpha architecture may use any or all of these methods, in this study only the last two were modeled.
Reference: [Smit81] <author> J. E. Smith, </author> <title> ``A Study of Branch Prediction Strategies'', </title> <booktitle> Proceedings of the Eighth Annual International Symposium on Computer Architecture, </booktitle> <address> Minneapolis, Minnesota (May 1981), </address> <pages> pp. 135-148. </pages> <address> d d </address>
Reference-contexts: Branch prediction eliminates much of the branch delay by predicting the direction the branch will take before the actual direction is known, and continuing instruction fetch along that instruction pathway. This has been an active area of research for many years, and continues to be to this day <ref> [Smit81] </ref> [LeS84] [FiFr92] [YeP93]. There are two main approaches to branch prediction static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [SrWa94] <author> A. Srivastava and D. W. Wall, </author> <title> ``Atom: A system for building custonized program analysis tools'', </title> <booktitle> Proceedings of the ACM SIGPLAN Notices 1994 Conference on Programming Languages and Implementations(June 1994), </booktitle> <pages> pp. 196-205. </pages>
Reference-contexts: Each program was compiled on an Alpha-based DEC 3000/400 workstation, using the native compiler and -O2 -non_shared compiler flags. The ATOM <ref> [SrWa94] </ref> toolkit was used to generate and help analyze the data gathered for this study. Branch instructions were instrumented to simulate the branch prediction schemes outlined in section 2. Predicate transformation was then implemented on the instrumented code to account for the removal of some branches.
Reference: [YeP91] <author> T. Yeh and Y. Patt, </author> <title> ``Two-Level Adaptive Training Branch Prediction'', </title> <booktitle> Proceedings of the 24th Annual International Symposium on Microarchitecture, </booktitle> <address> Albuquerque, New Mexico (November 18-20, </address> <year> 1991), </year> <pages> pp. 51-61. </pages>
Reference-contexts: If the history table value predicts not taken, then the branch address is removed from the BTB (if it currently resides there). The final branch prediction strategy modeled is the two level adaptive strategy developed by Yeh and Patt <ref> [YeP91] </ref>. This strategy requires considerably more hardware resources than the other methods, but provides greater branch prediction performance than any of the other methods. This scheme features a set of branch history registers in addition to a branch history pattern table.
Reference: [YeP93] <author> T. Yeh and Y. Patt, </author> <title> ``A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History'', </title> <booktitle> Proceedings of the Twentieth Annual International Symposium on Computer Architecture, </booktitle> <address> San Diego, CA (May 16-19, </address> <year> 1993), </year> <pages> pp. </pages> <month> 257-266. </month> <title> [94] ``PowerPC 601 RISC Microprocessor Users's Manual Addendum for 604'', </title> <institution> Motorola / IBM Microelectronics(1993, </institution> <year> 1994). </year> <title> d d </title>
Reference-contexts: This has been an active area of research for many years, and continues to be to this day [Smit81] [LeS84] [FiFr92] <ref> [YeP93] </ref>. There are two main approaches to branch prediction static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
References-found: 15

