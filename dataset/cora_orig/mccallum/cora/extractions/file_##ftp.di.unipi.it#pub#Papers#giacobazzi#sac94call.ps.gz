URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/sac94call.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: Goal independency and call patterns in the analysis of logic programs  
Author: Maurizio Gabbrielli Roberto Giacobazzi 
Affiliation: CWI  Ecole Polytechnique  
Abstract: We propose an abstract semantics for the goal independent analysis of properties of "procedure calls" in SLD derivations (call patterns). This can be used to derive information useful for logic program optimizations. Keywords: Logic programs, abstract interpretation, procedure calls. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: A pair in the relation corresponds to the reduction of a goal with a renamed clause from the program. A selection rule is a function (on the "histories" of SLD-derivations, see <ref> [1] </ref>) which selects in any goal G (in a derivation) an atom. In the following we will denote by R (G) the atoms selected by R in G. Definition 3.1 Let P be a logic program, R be a selection rule and # 2 Sub.
Reference: [2] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: j2J &lt;&lt; C I a [ ff (id) = mgu a (hH k jhH j i j2J ; 0 i; hB k jhB j i j2J ; 0 i) 9 &gt; &gt; &gt; &gt; &gt; ; The corresponding fixpoint abstract semantics F a R (P ) extends the one in <ref> [2] </ref> with call patterns. The equivalence with the top-down semantics is stated by the following theorem. Theorem 4.5 (Equivalence) Let P be program and R be a local selection rule.
Reference: [3] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <note> 1994. To appear. </note>
Reference: [4] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proc. of the Int'l Conf. on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580, </pages> <year> 1992. </year>
Reference-contexts: The atom A is an R-call pattern for the goal G in P iff G # fl A. The R-call pattern A is called correct iff there exists a derivation as before and G 0 has a refutation. A semantics for resultants was given in <ref> [4] </ref> by enhancing the standard semantic objects modeling computed answers (i.e. non ground atoms [11]). This is obtained by using clauses as semantic objects since a clause naturally represents a partial computation (from the head to the body). <p> The problems mentioned in a) and b) have recently been solved in [8] by modifying the transformation and by using techniques taken from the compositional semantics in <ref> [4] </ref>.
Reference: [5] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretations of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference: [6] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: This is useful for abstract interpretation, since often the abstract domains have such a finiteness property (see section 4). In <ref> [6] </ref> call patterns are characterized (for the case of the leftmost selection rule only) by a transformational approach. <p> Call patterns can then be obtained from the (bottom up) denotation S (P G ) which describes the success patterns, according to the following Theorem 3.9 <ref> [6] </ref> Let P be a program and G be a goal. If p ( t) is a leftmost call pattern for G in P , then the atom p C ( t) 2 S (P G ), while the converse does not hold.
Reference: [7] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The meaning of I a is specified by the following concretization function fl (I ) = c fi fi 2 fl S () Several abstract objects may represent the same concrete interpretation (i.e. fl may not be injective). A similar problem was solved in <ref> [7] </ref>, where abstract clauses were used to support compositionality in the analysis, by defining an equivalence relation ~ fl on -(LC fi ASub) such that I a 1 ~ fl I a iff fl (I a 2 ). <p> Thus fl P rop () = 2 Sub fi 0 ) asg ( 0 ) j= Consider the following program to reverse a list, and the leftmost selection rule: 3 A similar problem was considered in compositional analysis of modular logic programs <ref> [7] </ref>, where an additional layer of abstraction was required. append ([], L, L). append ([H|Y], X2, [H|Z]) append (Y, X2, Z). nrev ([], []). nrev ([H|L], R) nrev (L, L1), append (L1, [H], R).
Reference: [8] <author> M. Codish and B. Demoen. </author> <title> Analysing logic programs using "prop"-ositional logic programs and a magic wand. </title> <booktitle> In Proceedings of the 1993 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In particular, because of a), the analysis based on S (P G ), although safe, is in general less accurate than one based on F R (P ). The problems mentioned in a) and b) have recently been solved in <ref> [8] </ref> by modifying the transformation and by using techniques taken from the compositional semantics in [4].
Reference: [9] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: We consider the abstract domain P rop <ref> [9] </ref>, consisting of (equivalence classes of) propositional formulas over a set of connectives ^, _ and $. P rop provides a concise representation for abstract substitutions which describes ground dependency relations among their arguments. A propositional formula with connectives f$; _; ^g is associated with each substitution.
Reference: [10] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: introduction) and abstract interpretation <ref> [10] </ref>. Let be a possibly infinite set of symbols. We denote by fl the family of finite-length strings (sequences) from symbols in , including the empty string fl. <p> We approximate sets of concrete substitutions in -(Sub) by (abstract) descriptions of substitutions in a lattice ASub v A . Since the standard theory of abstract interpretation is formalized in terms of Galois insertions <ref> [10] </ref>, by specifying the relation between abstract and concrete semantic objects, we assume (-(Sub); ff S ; fl S ; ASub) to be a Galois insertion 1 .
Reference: [11] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: The R-call pattern A is called correct iff there exists a derivation as before and G 0 has a refutation. A semantics for resultants was given in [4] by enhancing the standard semantic objects modeling computed answers (i.e. non ground atoms <ref> [11] </ref>). This is obtained by using clauses as semantic objects since a clause naturally represents a partial computation (from the head to the body). Such a semantics was extended by considering the selection rule, thus modeling also (possibly correct) call patterns in [14]. <p> Clearly such a semantics generalizes that of definition 3.4. Moreover, essentially because of the completeness of the s-semantics <ref> [11] </ref>, a goal B 1 ; : : : ; B n successfully terminates in P iff there exist n atoms A i in O R;R (P ) such that B 1 ; : : : ; B n 2 The same kind of domains were called compositionally tractable in [13].
Reference: [12] <author> M. Gabbrielli. </author> <title> The Semantics of Logic Programming as a Programming Language. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference: [13] <author> M. Gabbrielli, R. Giacobazzi, and D. Montesi. </author> <title> Modular logic programs over finite domains. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proc. Eight Italian Conference on Logic Programming, </booktitle> <year> 1993. </year>
Reference-contexts: [11], a goal B 1 ; : : : ; B n successfully terminates in P iff there exist n atoms A i in O R;R (P ) such that B 1 ; : : : ; B n 2 The same kind of domains were called compositionally tractable in <ref> [13] </ref>. and A 1 ; : : : ; A n unify. Therefore we can characterize correct call pattern by extending proposition 3.8 in the obvious way. We show the abstract semantics for resultants obtained by generalizing O R;R (P ). <p> However, in the case of finite domains we can force termination of the fixpoint iteration of T R;R P (denoted T P " nfl) by using the results given in <ref> [13] </ref>. In the case of (correct) call patterns, there exists (according to theorem 4.7) the fixpoint iteration of T R P terminates describing all the (possibly non-correct) call patterns.
Reference: [14] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proc. of the Third Int'l Conf., volume 632 of LNCS, </booktitle> <pages> pages 84-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: We write 1 2 iff there exists a substitution such that 1 = 2 . 3 A concrete semantics for call patterns We show now a specialized version of the construction in <ref> [14] </ref> which provides a base collecting semantics for abstraction. The semantics described below models call patterns and therefore it is simpler than the original general definition which models resultants, that will be needed to treat correct call patterns (its abstract version will be shown in section 5). <p> This is obtained by using clauses as semantic objects since a clause naturally represents a partial computation (from the head to the body). Such a semantics was extended by considering the selection rule, thus modeling also (possibly correct) call patterns in <ref> [14] </ref>. If we consider plain call patterns, such an extension can be simplified since we only need to use a domain based on Krom clauses. As shown in the following, this clause domain leads to a very simple finiteness property which is very useful in abstract interpretation. <p> The atom A is introduced in the resolvent N if A is in the body of the clause used to obtain N from its parent in the derivation. This definition was refined in <ref> [14] </ref> by requiring also an ordering to be given (by the function in definition 3.5) for the selection of one of the atoms in the bodies, and therefore for the selection of one the most recently introduced atoms. <p> If the atom A i j in a resolvent ~ R is replaced by B 1 ; : : : ; B n in a derivation step, then the B j 's are superscripted by i + 1. Definition 3.5 <ref> [14] </ref> Let be a given bijection on the set of integer numbers. <p> In order to model also correct call patterns, the same kind of construction can de done by taking the semantics for resultants defined in <ref> [14] </ref> as the concrete reference semantics. The resulting framework is a powerful tool for dealing with a variety of analysis and optimization problems since it allows approximations, in a goal independent way, of both computed answers and call patterns. <p> This kind of information is given by the resultants semantics in <ref> [14] </ref>: O R;R (P ) = A B 2 Clause fi fi p (x) ; P;R B; where P is a program R is a computation rule and sets of (equivalence classes of) clauses are used as interpretations. Clearly such a semantics generalizes that of definition 3.4. <p> We show the abstract semantics for resultants obtained by generalizing O R;R (P ). The abstraction is performed as in the previous section (using abstract clauses instead of abstract Krom clauses). The following definitions and results are the abstract counterpart of those in <ref> [14] </ref> and we refer to that paper for further details. The abstract semantics is obtained by taking all the abstract resultants for atomic generic goals.
Reference: [15] <author> R. Giacobazzi. </author> <title> Semantic Aspects of Logic Program Analysis. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference: [16] <author> D. Jacobs and A. Langen. </author> <title> Static Analysis of Logic Programs for Independent AND Parallelism. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):291-314, 1992. 
Reference: [17] <author> N. D. Jones and H. Stndergaard. </author> <title> A Semantics-based Framework for the Abstract Interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference: [18] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 733-748. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [19] <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: A local selection rule is defined in <ref> [19] </ref> as a rule which always selects in a resolvent N one of the most recently introduced atoms in the derivation from the goal to N . <p> Note that the PROLOG leftmost rule is "local" (with (i) = i). Local rules produce SLD trees with a simple structure, suitable for efficient searching techniques <ref> [19] </ref>. We show now the immediate consequences operator modeling call patterns. Let id denote the interpretation p (x) p (x) fi p 2 where each clause is a tautology. Note that the reduction of a goal with any of the clauses in id is basically a "no-op".
References-found: 19

