URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR92232.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Email: johnmc@rice.edu  
Title: Compile-time Support for Efficient Data Race Detection in Shared-Memory Parallel Programs  
Author: John Mellor-Crummey 
Address: Houston, TX 77251-1892  
Affiliation: Center for Research on Parallel Computation Rice University  
Abstract: Data race detection strategies based on software run-time monitoring are notorious for dramatically inflating execution times of shared-memory parallel programs. Without significant reductions in the execution overhead incurred when using these techniques, there is little hope that they will be widely used. A promising approach to this problem is to apply compile-time analysis to identify variable references that need not be monitored at run time because they will never be involved in a data race. In this paper we describe eraser, a data race instrumentation tool that uses aggressive program analysis to prune the number of references to be monitored. To quantify the effectiveness of our analysis techniques, we compare the overhead of race detection with three levels of compile-time analysis ranging from little analysis to aggressive interprocedural analysis for a suite of test programs. For the programs tested, using interpro-cedural analysis and dependence analysis dramatically reduced the data race instrumentation added by eraser, resulting in a corresponding reduction of run-time monitoring overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen, D. Baumgartner, K. Kennedy, and A. Porterfield. </author> <title> PTOOL: A semi-automatic parallel programming assistant. </title> <booktitle> In Proc. of the 1986 Inter Page 10 national Conference on Parallel Processing, </booktitle> <pages> pages 164-170, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Detecting data races in shared-memory parallel programs is a difficult problem. Strategies for detecting such race conditions can be generally classified as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable <ref> [1, 3, 4, 24] </ref>, (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur
Reference: [2] <author> T. R. Allen and D. A. Padua. </author> <title> Debugging fortran on a shared memory machine. </title> <booktitle> In Proc. of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pages 721-727, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable [1, 3, 4, 24], (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races <ref> [2, 8, 17, 19, 20] </ref>, or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution [11, 12, 15, 16, 21, 22, 23].
Reference: [3] <author> W. F. Appelbe and C. E. McDowell. </author> <title> Anomaly reporting a tool for debugging and developing parallel numerical applications. </title> <booktitle> In Proc. First International Conference on Supercomputers, </booktitle> <address> FL, </address> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Detecting data races in shared-memory parallel programs is a difficult problem. Strategies for detecting such race conditions can be generally classified as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable <ref> [1, 3, 4, 24] </ref>, (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur
Reference: [4] <author> V. Balasundaram, K. Kennedy, U. Kremer, K. McKinley, and J. Sublok. </author> <title> The ParaScope editor: An interactive parallel programming tool. </title> <booktitle> In Proc. Supercomputing '89, </booktitle> <pages> pages 540-550, </pages> <address> Reno, NV, </address> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: Detecting data races in shared-memory parallel programs is a difficult problem. Strategies for detecting such race conditions can be generally classified as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable <ref> [1, 3, 4, 24] </ref>, (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur
Reference: [5] <author> M. Burke and L. Torczon. </author> <title> Interprocedural optimization: Eliminating unnecessary recompilation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1993. to appear. </note>
Reference-contexts: ParaScope has served as a testbed for recompilation analysis which identifies modules that have not been affected by program changes and do not need to be updated <ref> [5, 10] </ref>.
Reference: [6] <author> D. Callahan, S. Carr, and K. Kennedy. </author> <title> Improving register allocation for subscripted variables. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Program Language Design and Implementation, </booktitle> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: than those tested are forms of inter-statement analysis that could remove redundant access check operations within a procedure. (Currently, eraser performs no inter-statement analysis.) Inter-statement analysis strategies that could reduce instrumentation requirements include using global value numbering, control flow graph domination, and analysis developed for recognizing reuse of array variables <ref> [6] </ref> to eliminate redundant access check operations. Even with the impressive reductions in dynamic counts of monitoring operations that eraser was able to achieve, monitoring overhead for automatic detection of data races ran as high as a factor of 5.8.
Reference: [7] <author> D. Callahan, K. Cooper, R. Hood, K. Kennedy, and L. Torczon. </author> <title> ParaScope: A parallel programming environment. </title> <journal> The International Journal of Supercomputer Applications, </journal> <volume> 2(4), </volume> <month> Winter </month> <year> 1988. </year>
Reference-contexts: The ParaScope infrastructure has served as a platform for research on aggressive optimization of scientific codes for both scalar and shared-memory machines <ref> [7] </ref>. A key function of ParaScope is to support whole-program (interprocedural) analysis and optimization. To a large extent, support for whole-program analysis in ParaScope preserves the benefits of separate compilation of procedures by minimizing the number of times a procedure is examined. <p> To a large extent, support for whole-program analysis in ParaScope preserves the benefits of separate compilation of procedures by minimizing the number of times a procedure is examined. In general, interprocedural analysis and transformation in ParaScope uses the following 3-phase approach <ref> [7, 9, 13] </ref>: 1. Local Analysis. At the end of an editing session with one of the editors in the ParaScope toolset, summary information concerning all local interprocedural effects for each procedure in the edited module is calculated and stored.
Reference: [8] <author> J.-D. Choi, B. P. Miller, and R. H. B. Netzer. </author> <title> Techniques for debugging parallel programs with flow-back analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1991. </year>
Reference-contexts: as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable [1, 3, 4, 24], (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races <ref> [2, 8, 17, 19, 20] </ref>, or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution [11, 12, 15, 16, 21, 22, 23].
Reference: [9] <author> K. Cooper, K. Kennedy, and L. Torczon. </author> <title> The impact of interprocedural analysis and optimization in the R n programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 491-523, </pages> <month> Oct. </month> <year> 1986. </year>
Reference-contexts: To a large extent, support for whole-program analysis in ParaScope preserves the benefits of separate compilation of procedures by minimizing the number of times a procedure is examined. In general, interprocedural analysis and transformation in ParaScope uses the following 3-phase approach <ref> [7, 9, 13] </ref>: 1. Local Analysis. At the end of an editing session with one of the editors in the ParaScope toolset, summary information concerning all local interprocedural effects for each procedure in the edited module is calculated and stored.
Reference: [10] <author> K. Cooper, K. Kennedy, and L. Torczon. </author> <title> Inter-procedural optimization: Eliminating unnecessary recompilation. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <address> Palo Alto, CA, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: ParaScope has served as a testbed for recompilation analysis which identifies modules that have not been affected by program changes and do not need to be updated <ref> [5, 10] </ref>.
Reference: [11] <author> A. Dinning and E. Schonberg. </author> <title> An evaluation of monitoring algorithms for access anomaly detection. Ultracomputer Note 163, </title> <institution> Courant Institute, </institution> <address> New York University, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race. <p> of on-the-fly techniques is that for parallel programs with complex patterns of synchronization, the worst-case space and time overhead of detecting races during a program's execution includes a term proportional VT, where V is the number of shared variables and T is the maximum logical concurrency in the program execution <ref> [11] </ref>.
Reference: [12] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Second ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPOPP), </booktitle> <pages> pages 1-10, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race.
Reference: [13] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: To a large extent, support for whole-program analysis in ParaScope preserves the benefits of separate compilation of procedures by minimizing the number of times a procedure is examined. In general, interprocedural analysis and transformation in ParaScope uses the following 3-phase approach <ref> [7, 9, 13] </ref>: 1. Local Analysis. At the end of an editing session with one of the editors in the ParaScope toolset, summary information concerning all local interprocedural effects for each procedure in the edited module is calculated and stored.
Reference: [14] <author> M. W. Hall, K. Kennedy, and K. S. M c Kinley. </author> <title> Interprocedural transformations for parallel code generation. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <address> Albuquerque, NM, </address> <month> Nov. </month> <year> 1991. </year>
Reference: [15] <author> J. M. Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proc. of Supercomputing '91, </booktitle> <pages> pages 24-33, </pages> <address> Albuquerque, NM, </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race. <p> nested fork-join constructs (e.g., nested parallel loops), the worst-case asymptotic space overhead can be reduced to O (VN), where N is the maximum dynamic nesting depth of parallel constructs, and the asymptotic time for testing if a particular access participates in a data race can be reduced to O (N) <ref> [15] </ref>. These tighter bounds offer the promise of efficient on-the-fly detection of data races for this restricted class of programs. Both on-the-fly and post-mortem techniques rely on monitoring all potentially conflicting accesses to shared variables during a program's execution. <p> omit these access history declarations to generate instrumented programs more suitable for use with a run-time library that collects reference and synchronization traces for postmortem analysis. eraser and it's companion run-time library were designed to efficiently support detection of data races that arise in programs with closed, nested fork-join parallelism <ref> [15] </ref>. eraser's implementation focuses on instrumentation of of programs with concurrency specified in the form of nested parallel loops. <p> Elsewhere we have 3 Sun is a trademark of Sun Microsystems Page 9 shown that sequential executions suffice for detect-ing data races in programs with loop-based parallelism <ref> [15] </ref>. All programs were compiled with the Sun f77 compiler using -O optimization. Comparing raw execution times of the uninstrumented and instrumented code varieties shows the run-time overhead for on-the-fly monitoring to be relatively high.
Reference: [16] <author> S. L. Min and J.-D. Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proc. of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 235-244, </pages> <address> Palo Alto, CA, </address> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race.
Reference: [17] <author> R. H. B. Netzer. </author> <title> Race Condition Detection for Debugging Shared-Memory Parallel Programs. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin | Madison, </institution> <year> 1991. </year>
Reference-contexts: as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable [1, 3, 4, 24], (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races <ref> [2, 8, 17, 19, 20] </ref>, or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution [11, 12, 15, 16, 21, 22, 23]. <p> Several approaches to post-mortem analysis that use smaller trace logs are promising. Netzer has studied the capabilities and limitations of postmortem analysis based on partial information <ref> [17] </ref>. Page 1 A promising alternative to pure post-mortem anal-ysis is a hybrid approach that uses abbreviated logs containing only synchronization information to compute guaranteed orderings [18]. Such orderings can be used in conjunction with subsequent static analysis or on-the-fly monitoring to report race conditions.
Reference: [18] <author> R. H. B. Netzer and S. Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with post/wait synchronization. </title> <booktitle> In 1992 Intl. Conference on Parallel Processing, </booktitle> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Netzer has studied the capabilities and limitations of postmortem analysis based on partial information [17]. Page 1 A promising alternative to pure post-mortem anal-ysis is a hybrid approach that uses abbreviated logs containing only synchronization information to compute guaranteed orderings <ref> [18] </ref>. Such orderings can be used in conjunction with subsequent static analysis or on-the-fly monitoring to report race conditions. On-the-fly techniques maintain additional state information during a program's execution to determine when unordered, conflicting accesses to a shared variable have occurred.
Reference: [19] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Detecting data races in parallel program executions. </title> <editor> In D. Gelern-ter, T. Gross, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <booktitle> Also in Proc. of the 3rd Workshop on Prog. Langs. and Compilers for Parallel Computing, </booktitle> <address> Irvine, CA, </address> <month> (Aug. </month> <year> 1990). </year>
Reference-contexts: as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable [1, 3, 4, 24], (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races <ref> [2, 8, 17, 19, 20] </ref>, or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution [11, 12, 15, 16, 21, 22, 23].
Reference: [20] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <booktitle> In 3rd ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming, </booktitle> <pages> pages 133-144, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable [1, 3, 4, 24], (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races <ref> [2, 8, 17, 19, 20] </ref>, or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution [11, 12, 15, 16, 21, 22, 23].
Reference: [21] <author> I. Nudler and L. Rudolph. </author> <title> Tools for efficient development of efficient parallel programs. </title> <booktitle> In First Is-raeli Conference on Computer Systems Engineering, </booktitle> <year> 1986. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race.
Reference: [22] <author> E. Schonberg. </author> <title> On-the-fly detection of access anomalies. </title> <booktitle> In Proc. ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 285-297, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race.
Reference: [23] <author> G. L. Steele, Jr. </author> <title> Making asynchronous parallelism safe for the world. </title> <booktitle> In Proc. of the 1990 Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 218-231, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur during its execution <ref> [11, 12, 15, 16, 21, 22, 23] </ref>. Static analysis techniques rely on classical program dependence analysis and an analysis of a program's concurrency structure to determine when two references may potentially be involved in a data race.
Reference: [24] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Detecting data races in shared-memory parallel programs is a difficult problem. Strategies for detecting such race conditions can be generally classified as (1) static analysis | analysis of a program's text to determine when two references may refer to the same shared variable <ref> [1, 3, 4, 24] </ref>, (2) post-mortem analysis | collection of a log of events that occur during a program's execution and post-processing the log to isolate data races [2, 8, 17, 19, 20], or (3) on-the-fly analysis | augmentation of a program to detect and report data races as they occur
Reference: [25] <author> V. J. Torczon. </author> <title> Multi-directional search: A direct search algorithm for parallel machines. </title> <type> Technical Report TR90-7, </type> <institution> Department of Mathematical Sciences, Rice University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: To date, we have carefully studied results with three shared-memory parallel programs. The first program, search, implements a multi-directional direct search method for finding a local minimizer of an unconstrained minimization problem <ref> [25] </ref>. Search contains four parallel loop nests (each of which contain a call to the same evaluator function) surrounded by an outer serial loop that tests for convergence.
Reference: [26] <author> M. Young and R. N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1499-1511, </pages> <month> Oct. </month> <year> 1988. </year> <pages> Page 11 </pages>
Reference-contexts: Experience with static analysis tools has shown that the number of false positives reported using these techniques is too high for programmers to rely exclusively on static methods for isolating data races. Combining static analysis with symbolic execution offers hope for reducing reports of infeasible races <ref> [26] </ref>. Post-mortem techniques for detecting data races have the advantage that they can limit reports to feasible races. However, to guarantee that only feasible races are reported, exhaustive execution trace logs are necessary.
References-found: 26

