URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/able/ftp/wright-fase98.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/able/www/paper_abstracts/wright-fase98.html
Root-URL: 
Title: Specifying and Analyzing Dynamic Software Architectures  
Author: Robert Allen, Rmi Douence, and David Garlan 
Date: (March 1998)  
Note: Proceedings of 1998 Conference on Fundamental Approaches to Software  
Address: IRISA-INRIA CMU  Pittsburgh, PA 15213, USA  35042 Rennes Cedex, France  Lisbon, Portugal  
Affiliation: CMU  School of Computer Science, Carnegie Mellon University,  IRISA, Campus de Beaulieu,  Engineering  
Abstract: A critical issue for complex component-based systems design is the modeling and analysis of architecture. One of the complicating factors in developing architectural models is accounting for systems whose architecture changes dynamically (during run time). This is because dynamic changes to architectural structure may interact in subtle ways with on-going computations of the system. In this paper we argue that it is possible and valuable to provide a modeling approach that accounts for the interactions between architectural reconfiguration and non-reconfiguration system functionality, while maintaining a separation of concerns between these two aspects of a system. The key to the approach is to use a uniform notation and semantic base for both reconfiguration and steady-state behavior, while at the same time providing syntactic separation between the two. As we will show, this permits us to view the architecture in terms of a set of possible architectural snapshots, each with its own steady-state behavior. Transitions between these snapshots are accounted for by special reconfiguration-triggering events.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. J. Allen. </author> <title> A Formal Approach to Software Architecture. </title> <type> Ph.D. Thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <note> available as TR# CMU-CS-97-144, </note> <month> May </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Recently, there has been considerable progress on the development of architecture description languages (ADLs [12]) to support software architecture design and analysis. These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright <ref> [1] </ref>, UniCon [14], Rapide [10], Darwin [11] and ACME [5]. There are many aspects of a software system that can be addressed in an architectural description, including functional behavior, allocation of resources, performance, fault-tolerance, exibility in the face of altered requirements, and so on. <p> So, can occur at choice points (e.g., P [] and P ), which is illegal in standard CSP. An alternative definition of the sequencing operator ; makes this kind of expression consistent. See <ref> [1] </ref> for details. 5 Finally, a glue specification describes how the roles of a connector interact with each other. In the example, a client request (c.request) must be transmitted to the server (s.request), and the server reply (s.reply) must be transmitted back to the client (c.reply). <p> Our semantics is a formal basis to further develop analysis and transformations. Intractable analysis could be replaced by proofs based on the semantic expressions and CSP. For example, a case study in <ref> [1] </ref> does not rely on model checking to study the deadlock freedom of a buffered connector style. Also, we restricted our study to dynamic systems with a finite number of configurations. The subordination CSP operator (//) can be used to dynamically duplicate processes by recursion. <p> Because of space constraints, we illustrated the approach with a very simple example, showing how specification and analysis could help us detect and then fix a bug in the description. However we are confident that our extension scales up to realistic systems, as static Wright does <ref> [1] </ref>. Indeed, our checks remain local, and identical checks can be shared in systems with a high degree of symmetry (e.g. multiple instances of the same component). Further study would be necessary.
Reference: [2] <author> R. J. Allen and D. Garlan. </author> <title> A Formal Basis for Architectural Connection. </title> <journal> In ACM Transactions on Software Engineering and Methodology, </journal> <month> July </month> <year> 1997. </year>
Reference-contexts: A role, on the other hand, acts has a placeholder representing the range of potential participants in the interaction described by a connector. An important check is whether the port of a component is consistent with respect to a role to which it is attached (see especially <ref> [2] </ref>). Specifically, the port-role consistency check must ensure that when in a situation described by the role protocol, the port must always continue the protocol in a way that the role could have. This property can be expressed with a CSP refinement check.
Reference: [3] <author> J.-P. Ban---tre, C. Bryce and D. Le Mtayer. </author> <title> Compile-time detection of information ow in sequential programs. </title> <booktitle> In Proc. of Research in Comp. Security, </booktitle> <publisher> Springer Verlag, LNCS 875, </publisher> <year> 1995. </year>
Reference-contexts: This technique might allow us to express semantics of dynamic architectures with regular pattern topology involving an unbounded number of configurations. The present work focuses on protocols and deadlock freedom. Other properties should be studied in Wright. For example, <ref> [3] </ref> proposes a security analysis based on information ow in CSP expression. We think, this work could be adapted to Wright by introducing extra information specifying information ows hidden by the specifications.
Reference: [4] <editor> Failures Divergence Refinement: </editor> <title> User Manual and Tutorial. Formal Systems (Europe) Ltd., </title> <address> Oxford, </address> <note> England,1.2b edition October 1992. </note>
Reference-contexts: This is detected by another test: Check 2 Each role r 1 ,r n of the connector C is deadlock free. Both checks can be directly reused in our dynamic extension. They are easily performed with the help of the FDR model checker <ref> [4] </ref>. In case of failure, the tool provides the execution traces leading to the deadlock. <p> The following check ensures that our fault-tolerant system has the functionality of a simple client-server system: Rename (Strip (DynamicClient-Server " -_.control._, _.go-)) = Simple With the tool FDR <ref> [4] </ref>, we discover that these two systems are nearly equivalent: they have the same traces and failures, but Simple never diverges, while the left-hand side system may diverge (performing no useful communication, but only an infinite sequence of reconfigurations).
Reference: [5] <author> D. Garlan, R. T. Monroe and D. Wile. ACME: </author> <title> An Architecture Description Interchange Language. </title> <note> Submitted for publication, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright [1], UniCon [14], Rapide [10], Darwin [11] and ACME <ref> [5] </ref>. There are many aspects of a software system that can be addressed in an architectural description, including functional behavior, allocation of resources, performance, fault-tolerance, exibility in the face of altered requirements, and so on. Each ADL tends to focus on one or more of these aspects.
Reference: [6] <author> Hoare, </author> <title> C.A.R. Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: The notation for specifying event-based behavior is adapted from CSP <ref> [6] </ref>. Each CSP process defines an alphabet of events and the permitted patterns of events that the process may exhibit. These processes synchronize on common events (i.e., interact) when composed in parallel. Wright uses such process descriptions in computation, port, role and glue specifications. <p> In this section we present the formal basis for this. The basic idea is to translate the notation into pure CSP <ref> [6] </ref>. The behavior of the system is constructed from the process that defines the constituent components and connectors. Specifically, the behavior of a system is the parallel composition of all the computation, glue and configuror processes. <p> Also, we restricted our study to dynamic systems with a finite number of configurations. The subordination CSP operator (//) can be used to dynamically duplicate processes by recursion. For example, <ref> [6] </ref> gives a definition of a factorial process where each level of recursion declares a new local process to deal with the recursive call. This technique might allow us to express semantics of dynamic architectures with regular pattern topology involving an unbounded number of configurations.
Reference: [7] <author> P. Inverardi and A. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures Using the Chemical Abstract Machine Model. </title> <journal> In IEEE Trans on SW Eng., </journal> <volume> 21(4), </volume> <pages> pp. 373-386, </pages> <year> 1995. </year>
Reference-contexts: The second area of related work is general formalisms for reasoning about architectural designs. Among these two are most closely related. The first is term rewriting systems. For example, Inverar-di and Wolf have shown how to model architectures using the CHAM <ref> [7] </ref>. As a general term rewriting system, CHAM is can describe arbitrary reconfigurations of architectures.
Reference: [8] <author> L. Lamport. </author> <title> The Temporal Logic of Actions. </title> <journal> In ACM TOPLAS, </journal> <volume> 16(3), </volume> <pages> pp. 872-923, </pages> <year> 1994. </year>
Reference-contexts: Finally, all interesting properties cant be expressed in CSP, but our framework and the tagging technique of our semantics could be reused with another formalism (e.g., CSP which lacks fairness must be replaced by temporal logic <ref> [8] </ref>). 15 In this paper, we have described an approach to architectural specification that permits the repre sentation and analysis of dynamic architectures.
Reference: [9] <author> D. Le Mtayer. </author> <title> Software Architecture Styles as Graph Grammars. </title> <booktitle> In Proceedings of the Fourth ACM Symposium on the Foundations of Software Engineering, ACM SIGSOFT, </booktitle> <year> 1996. </year>
Reference-contexts: In contrast, Wright has tried to provide a notation that makes explicit the intentions of a designer for handling reconfigurability. 3 Another general-purpose formalism applied to dynamic architectures is the use of graph grammars to describe the allowable topologies of architectures <ref> [9] </ref>. Graph grammars provide a nice notation for capturing patterns of transformation. However, thus far they have not been used to relate the reconfiguration aspects of an architecture with its behavior.
Reference: [10] <author> D. C. Luckham, L. M. Augustin, J. J. Kenney, J. Vera, D. Bryan and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> In IEEE Trans. on Soft. Eng., </journal> <volume> 21(4), </volume> <year> 1995. </year>
Reference-contexts: These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright [1], UniCon [14], Rapide <ref> [10] </ref>, Darwin [11] and ACME [5]. There are many aspects of a software system that can be addressed in an architectural description, including functional behavior, allocation of resources, performance, fault-tolerance, exibility in the face of altered requirements, and so on. <p> The most prominent among these are Rapide and Darwin. In the case of Rapide, the notation takes an object-oriented view: new architectural components can be created much as one would create new objects in a object-oriented programming language <ref> [10] </ref>. A consequence of this design is that it is in general undecidable what topologies will be created during a Rapide execution. For this and other reasons, Rapide focuses on simulation and analysis of sets of execution traces. In contrast, Wright focuses on static checking.
Reference: [11] <author> J. Magee and J. Kramer. </author> <title> Dynamic Structure in Software Architectures. </title> <booktitle> In Proc. of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp. 3-14, </pages> <year> 1996. </year>
Reference-contexts: These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright [1], UniCon [14], Rapide [10], Darwin <ref> [11] </ref> and ACME [5]. There are many aspects of a software system that can be addressed in an architectural description, including functional behavior, allocation of resources, performance, fault-tolerance, exibility in the face of altered requirements, and so on. Each ADL tends to focus on one or more of these aspects. <p> For this and other reasons, Rapide focuses on simulation and analysis of sets of execution traces. In contrast, Wright focuses on static checking. In the case of Darwin, the language is solely concerned with the structural aspects of an architecture <ref> [11] </ref>. Thus, the issue of how reconfigurations interact with on-going computations does not arise. However, their use of the Pi-Calculus to give semantics to reconfiguration is elegant and suggestive of the power of a more exible dynamic process algebras.
Reference: [12] <author> N. </author> <title> Medvidovic.A Classification and Comparison Framework for Software Architecture Description Languages. </title> <institution> Univ. of Irvine, Dept. of Information and Computer Science, </institution> <year> 1997. </year>
Reference-contexts: 1 Introduction Recently, there has been considerable progress on the development of architecture description languages (ADLs <ref> [12] </ref>) to support software architecture design and analysis. These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright [1], UniCon [14], Rapide [10], Darwin [11] and ACME [5].
Reference: [13] <author> L. Sha, R. Ragunathan and M. Gagliardi. </author> <title> Evolving Dependable Real-Time Systems. </title> <institution> Carnegie Mellon University SEI Report CMU-SEI-95-TR-005, </institution> <year> 1995. </year>
Reference-contexts: way to use these is to alter the architecture such that both servers are present, and when the primary server goes down, the client uses the secondary server until such time as the primary server returns to service. (This kind of fault-tolerant architecture is actually used by the Simplex System <ref> [13] </ref>.) The topology of the system is shown in Figure 3. A Wright description of a possible client is shown in Figure 4.
Reference: [14] <author> M. Shaw, R. DeLine, D. V. Klein, T. L. Ross, D. M. Young and G. Zelesnik. </author> <title> Abstractions for Software Architecture and Tools to Support Them. </title> <journal> In IEEE Trans. on Soft. Eng., </journal> <volume> 21(4), </volume> <year> 1995. </year>
Reference-contexts: These languages capture the key design properties of a system by exposing the architectural structure as a composition of components interacting via connectors. Examples include Wright [1], UniCon <ref> [14] </ref>, Rapide [10], Darwin [11] and ACME [5]. There are many aspects of a software system that can be addressed in an architectural description, including functional behavior, allocation of resources, performance, fault-tolerance, exibility in the face of altered requirements, and so on.
References-found: 14

