URL: http://www.cs.indiana.edu/database/Publications/TR452.ps
Refering-URL: http://www.cs.indiana.edu/database/Publications/index.html
Root-URL: http://www.cs.indiana.edu
Title: Providing Better Support for Quantified Queries  
Author: Sudhir G. Rao Antonio Badia Dirk Van Gucht 
Abstract: Relational database systems do not effectively support complex queries containing quantifiers (quantified queries) that are increasingly becoming important in decision support applications. Generalized quantifiers provide an effective way of expressing such queries naturally. In this paper, we consider the problem of processing quantified queries within the generalized quantifier framework. We demonstrate that current relational systems are ill-equipped, both at the language and at the query processing level, to deal with such queries. We also provide insights into the intrinsic difficulties associated with processing such queries. We then describe the implementation of a quantified query processor, Q 2 P, that is based on multidimensional and boolean matrix structures. We provide results of performance experiments run on Q 2 P that demonstrate superior performance on quantified queries. Our results indicate that it is feasible to augment relational systems with query subsystems like Q 2 P for significant performance benefits for quantified queries in decision support applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Badia, A., Gyssens, M., and Van Gucht, D. </author> <title> Query Languages with Generalized Quantifiers. In Applications of Logic Databases, </title> <editor> R. Ramakrishnan, Ed. </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995, </year> <pages> pp. 235-258. </pages>
Reference-contexts: While relational systems are already equipped with multiple access methods, join algorithms, etc., allowing very good performance on a wide range of queries, there is very little support for quantified queries. In two recent papers, Hsu and Parker [16] and, independently, Badia, Van Gucht, and Gyssens <ref> [1] </ref>, showed that generalized quantifiers in query languages are an effective way of expressing quantified queries naturally. It then becomes important to demonstrate that such quantified queries can be supported effectively. <p> It is often argued that these features enhance the declarativeness of the query language. In two recent papers, Hsu and Parker [16] and, independently, Badia, Van Gucht, and Gyssens <ref> [1] </ref>, validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [2] for natural language formalization. We illustrate the use of generalized quantifiers through an example. <p> Sets have also been incorporated into logical query languages (for a recent example, see [23]). However, the idea of using the general notion of quantifier and explicitly making sets part of the language does not seem to appear until [16] and <ref> [1] </ref>. As seen in the examples, Hsu and Parker try to integrate their system on top of SQL, and propose a translation of their extension back into SQL2. <p> Dayal presented generalized 8 join and aggregate primitives for nested queries with quantifiers [9]. However, there is no discussion on how these operators perform in practice or on queries with more than one nesting level. The approach in <ref> [1] </ref> tries to be more general, by considering the quantification as an explicit operation on the sets, and several ways to construct the sets involved. As a result, the kind of universal quantification queries captured using relational division are a special case of the all quantifier.
Reference: [2] <author> Barwise, J., and Cooper, R. </author> <title> Generalized Quantifiers and Natural Language. </title> <booktitle> In Linguistic and Philosophy (1981), </booktitle> <pages> pp. 159-219. </pages>
Reference-contexts: In two recent papers, Hsu and Parker [16] and, independently, Badia, Van Gucht, and Gyssens [1], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper <ref> [2] </ref> for natural language formalization. We illustrate the use of generalized quantifiers through an example. Consider, as part of a health-care study, a database with the relations disease (dname,dtype) patient-symptom (pname,symptom) disease-symptom (dname,symptom) We first need the notion of a set term.
Reference: [3] <author> Braunwald, E., J.Isselbacher, K., G.Petersdorf, R., Wilson, J. D., Martin, J. B., and S.Fauci, A., Eds. </author> <title> Harrison's Principles of Internal Medicine, 11 ed. </title> <publisher> McGraw Hill Book Company, </publisher> <year> 1987. </year>
Reference-contexts: An organ transplant from a donor to a recipient is said to have a high probability of success if the match between the donor's and recipient's Human Leukocyte Antigen types (hla types) is high <ref> [3] </ref>.
Reference: [4] <author> Carlis, J. V. </author> <title> HAS: A Relational Algebra Operator, or Divide is Not Enough to Conquer. </title> <booktitle> In IEEE Data Engineering (1986), p. </booktitle> <volume> 254. </volume> <pages> 9 </pages>
Reference-contexts: As for extended algebraic primitives, there has been considerable work at the algebraic level to support more sophisticated primitives. Carlis presents a division operator that allows a wide variety of set operations to be considered <ref> [4] </ref>. Dadashzadeh [7] presents an extended division operator (GCD) that also allows more flexibility on the set operations and relates dividend and divisor values. Dayal presented generalized 8 join and aggregate primitives for nested queries with quantifiers [9].
Reference: [5] <author> Cattell, R., Ed. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Other examples are: (exists) exactly one, (exists) at least ten, at least 10%, exactly as many. 2.1 Generalized Quantifiers Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [17], OQL <ref> [5] </ref>, CORAL [23], RC/S [21] 3 One may argue that uses of NOT EXISTS (which is used to express universal quantification in SQL) are rarely seen.
Reference: [6] <author> Chaudhuri, S., and Shim, K. </author> <title> Including Group-By in Query Optimization. </title> <booktitle> In Proc. of the 20th Int'l Conf. on VLDB (1994), </booktitle> <pages> pp. 354-366. </pages>
Reference-contexts: 1 Introduction Several recent papers have pointed out that users often use embedded and correlated queries <ref> [6, 18] </ref>. These queries aggregate data into sets of entities and - (1) produce a statistical summary by applying aggregate functions on these sets or (2) show complex relationships amongst such sets of entities.
Reference: [7] <author> Dadashzadez, M. </author> <title> An Improved Division Operator for Relational Algebra. </title> <booktitle> Information Systems 14, 5 (1989), </booktitle> <pages> 431-437. </pages>
Reference-contexts: As for extended algebraic primitives, there has been considerable work at the algebraic level to support more sophisticated primitives. Carlis presents a division operator that allows a wide variety of set operations to be considered [4]. Dadashzadeh <ref> [7] </ref> presents an extended division operator (GCD) that also allows more flexibility on the set operations and relates dividend and divisor values. Dayal presented generalized 8 join and aggregate primitives for nested queries with quantifiers [9].
Reference: [8] <author> Dayal, U. </author> <title> Processing Queries With Quantifiers: A Horticultural Approach. </title> <booktitle> In Proc. of the ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> Atlanta (1983). </address>
Reference-contexts: The first type of queries are an important subset of the aggregate queries that are commonly used in decision support applications. The second type of queries are often expressed as quantified queries, i.e., the queries are expressed using quantifiers <ref> [8] </ref>. Quantified queries are becoming increasingly important in decision support applications in general, and in the insurance and health-care sectors in particular.
Reference: [9] <author> Dayal, U. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries that contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> In Proc. of the 13th Int'l Conf. on VLDB (1987), </booktitle> <pages> pp. 197-208. </pages>
Reference-contexts: Dadashzadeh [7] presents an extended division operator (GCD) that also allows more flexibility on the set operations and relates dividend and divisor values. Dayal presented generalized 8 join and aggregate primitives for nested queries with quantifiers <ref> [9] </ref>. However, there is no discussion on how these operators perform in practice or on queries with more than one nesting level. The approach in [1] tries to be more general, by considering the quantification as an explicit operation on the sets, and several ways to construct the sets involved. <p> Our general algorithm for all uses hash-based aggregation techniques similar to those of Graefe's, but with different structures. With respect to optimization, there have been many papers on query transformations and optimizations for performance benefits <ref> [9, 13, 22] </ref>. As Pirahesh et. al. point out in [22], there has not been any implementation for performance testing before theirs.
Reference: [10] <author> DeWitt, D. J., Katz, R. H., Olken, F., Shapiro, L. D., Stonebraker, M. R., and Wood, D. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> In Proc. of ACM-SIGMOD Int'l Conf. on Management of Data (1984), </booktitle> <address> p. </address> <month> 1. </month>
Reference-contexts: However, we fully describe the details of the experiments in [25]. 4.1 Conceptualization In relational query processors, hash-based join (j some) algorithms have been known to perform well <ref> [10] </ref>. They map relations at run-time to a 1-dimensional space by hashing on the join attribute values (each hash-value represents a point in this space). However, this scheme is inadequate for supporting the all, no, and not all operators efficiently.
Reference: [11] <author> EXODUS. </author> <title> Using the EXODUS Storage Manager V3.0. unpublished,included in the EXODUS Storage Manager Software Release. </title>
Reference-contexts: Q 2 P was implemented on top of the EXODUS storage manager <ref> [11] </ref>. 7 PS DS some all not all no 2k 2k 1.26 2.77 5.32 4.36 8k 2.2k 2.17 6.36 14.32 11.56 32k 2.4k 7.09 22.55 49.57 51.85 128k 2.6k 26.43 88.65 206.65 280.5 512k 2.9k 157.2 410.0 1045.9 2904.2 Table 1: This table gives performance figures for our Q 2 P
Reference: [12] <author> Database Research: </author> <title> Achievements and Opportunities Into the 21st Century. Report of an NSF Workshop on the Future of Database Systems Research, </title> <note> May, 1995. </note> <author> Avi Silberschatz, Mike Stonebraker, Jeff Ullman, </author> <title> editors. </title>
Reference-contexts: In this paper, we demonstrate the feasibility of augmenting existing relational database systems with appropriate data structures and algorithms for supporting the critical 1 A recent report on the future of database systems has identified health-care information systems as part of the next generation application areas <ref> [12] </ref>. 2 Quantified queries are expressed in SQL using the GROUP BY, (NOT) EXISTS, and (NOT) IN clauses.
Reference: [13] <author> Ganski, R. A., and Wong, H. K. T. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> In Proc. of ACM-SIGMOD Int'l Conf. on Management of Data (1987), </booktitle> <pages> pp. 23-33. </pages>
Reference-contexts: Our general algorithm for all uses hash-based aggregation techniques similar to those of Graefe's, but with different structures. With respect to optimization, there have been many papers on query transformations and optimizations for performance benefits <ref> [9, 13, 22] </ref>. As Pirahesh et. al. point out in [22], there has not been any implementation for performance testing before theirs.
Reference: [14] <author> Graefe, G. </author> <title> Relation Division: Four Algorithms and Their Performance. </title> <booktitle> In Proc. of IEEE Int'l Conf. on Data Eng. </booktitle> <month> (February </month> <year> 1989), </year> <note> p. 94. </note>
Reference-contexts: For simplicity, all attributes belonging to a common domain in the 9 Otherwise the high sparsity will prove expensive in terms of disk space usage and I/O operations. 10 Run-time hash table structures can be used for providing this mapping information <ref> [14] </ref>. This is an acceptable alternative if these structures can be constructed efficiently with minimal overhead. Otherwise, the incremental cost of maintaining auxiliary storage structures can be amortized in the long run. 4 database are named after the domain. <p> Bit-mapped join indexes have also been proposed for multi-way joins in relational systems [15]. As far as we know, though, no structure is specially devoted to support quantified queries. Graefe presented four algorithms for relational division with performance experiments <ref> [14] </ref>. Relational division, unlike our all operator, is an asymmetric operator in that no part of the result can come from the divisor. Observe also that other attributes in the divisor cannot be asked to match the grouping attribute of the dividend, as it happens on Dadashzadeh's GCD operator.
Reference: [15] <author> Graefe, G. </author> <title> Multi-Table Joins Through Bitmapped Join Indices. </title> <booktitle> SIGMOD Record 24, </booktitle> <month> 3 (September </month> <year> 1995), </year> <pages> 8-11. </pages>
Reference-contexts: Sybase, a major relational database vendor, has in recent times offered a product, Sybase IQ, which uses bit-vector indexes for better performance on queries with multiple restriction and join predicates [27]. Bit-mapped join indexes have also been proposed for multi-way joins in relational systems <ref> [15] </ref>. As far as we know, though, no structure is specially devoted to support quantified queries. Graefe presented four algorithms for relational division with performance experiments [14]. Relational division, unlike our all operator, is an asymmetric operator in that no part of the result can come from the divisor.
Reference: [16] <author> Hsu, P., and Parker, D. </author> <title> Improving SQL with Generalized Quantifiers. </title> <booktitle> In Proc. of the 10th Int'l Conf. on Data Engineering (1995). </booktitle>
Reference-contexts: While relational systems are already equipped with multiple access methods, join algorithms, etc., allowing very good performance on a wide range of queries, there is very little support for quantified queries. In two recent papers, Hsu and Parker <ref> [16] </ref> and, independently, Badia, Van Gucht, and Gyssens [1], showed that generalized quantifiers in query languages are an effective way of expressing quantified queries naturally. It then becomes important to demonstrate that such quantified queries can be supported effectively. <p> It is often argued that these features enhance the declarativeness of the query language. In two recent papers, Hsu and Parker <ref> [16] </ref> and, independently, Badia, Van Gucht, and Gyssens [1], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [2] for natural language formalization. <p> that have at least 10% of the symptoms of any disease except those symptoms belonging to heart diseases" is expressed as fp j at least 10% (fs j patient-symptom (p; s)g fs n j no (fd j disease-symptom (d; s n )g)g fd j disease (d; heart-disease)g)g)g Hsu and Parker <ref> [16] </ref> discussed the syntactic limitations of SQL to express GQ-queries. To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from extended-SQL to SQL2 [17]. <p> Sets have also been incorporated into logical query languages (for a recent example, see [23]). However, the idea of using the general notion of quantifier and explicitly making sets part of the language does not seem to appear until <ref> [16] </ref> and [1]. As seen in the examples, Hsu and Parker try to integrate their system on top of SQL, and propose a translation of their extension back into SQL2.
Reference: [17] <author> International Organization of Standardization (ISO). </author> <title> Database Language SQL. Document ISO/IEC 9075:1992. </title>
Reference-contexts: Other examples are: (exists) exactly one, (exists) at least ten, at least 10%, exactly as many. 2.1 Generalized Quantifiers Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL <ref> [17] </ref>, OQL [5], CORAL [23], RC/S [21] 3 One may argue that uses of NOT EXISTS (which is used to express universal quantification in SQL) are rarely seen. <p> In SQL, EXISTS (S) is true if and only if the set S 6= ;. 5 The all quantifier described in this paper should not be confused with SQL's ALL predicate which is used for quantified comparison <ref> [17] </ref>. <p> To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from extended-SQL to SQL2 <ref> [17] </ref>. Reconsider the health-care database and the queries we used as an example: "Find the patient-disease pairs (p; d) such that patient p has [somejalljnojnot all] symptoms associated with disease d." In Hsu and Parker's extended-SQL, these queries can be formulated as shown in Figure 1.
Reference: [18] <author> Lu, H., Chan, H. C., and Wei, K. K. </author> <title> A Survey on Usage of SQL. </title> <booktitle> SIGMOD Record (1993), </booktitle> <pages> 60-65. </pages>
Reference-contexts: 1 Introduction Several recent papers have pointed out that users often use embedded and correlated queries <ref> [6, 18] </ref>. These queries aggregate data into sets of entities and - (1) produce a statistical summary by applying aggregate functions on these sets or (2) show complex relationships amongst such sets of entities.
Reference: [19] <author> Nievergelt, A., and Hinterberger, H. </author> <title> The Grid File: An Adaptable, Symmetric Multikey File Structure. </title> <journal> ACM Transactions on Database Systems (1984), </journal> <pages> 38-71. </pages>
Reference-contexts: We use a multi-attribute structure (similar to those in <ref> [19, 20] </ref>) for providing the mapping to a multidimensional space. We use a boolean matrix structure for providing the mapping to a 2-dimensional space and therefore to support the complement operator. <p> Multidimensional database products like Essbase from Arbor Software, Express from Oracle and so on are available in the market that target aggregate queries in an on-line analytical processing environment. Multidimensional structures have been suggested for support for range-queries for relational databases <ref> [19, 20] </ref>. Sybase, a major relational database vendor, has in recent times offered a product, Sybase IQ, which uses bit-vector indexes for better performance on queries with multiple restriction and join predicates [27]. Bit-mapped join indexes have also been proposed for multi-way joins in relational systems [15].
Reference: [20] <author> Otoo, E. J. </author> <title> A Multidimensional Digital Hashing Scheme for Files. </title> <booktitle> In Proc. of ACM-SIGMOD (1985), </booktitle> <pages> pp. 214-229. </pages>
Reference-contexts: We use a multi-attribute structure (similar to those in <ref> [19, 20] </ref>) for providing the mapping to a multidimensional space. We use a boolean matrix structure for providing the mapping to a 2-dimensional space and therefore to support the complement operator. <p> Multidimensional database products like Essbase from Arbor Software, Express from Oracle and so on are available in the market that target aggregate queries in an on-line analytical processing environment. Multidimensional structures have been suggested for support for range-queries for relational databases <ref> [19, 20] </ref>. Sybase, a major relational database vendor, has in recent times offered a product, Sybase IQ, which uses bit-vector indexes for better performance on queries with multiple restriction and join predicates [27]. Bit-mapped join indexes have also been proposed for multi-way joins in relational systems [15].
Reference: [21] <author> Ozsoyo glu, G., and Wang, H. </author> <title> A Relational Calculus with Set Operators, Its Safety, and Equivalent Graphical Languages. </title> <journal> IEEE Transactions on Software Engineering (1989), </journal> <pages> 1038-1052. </pages>
Reference-contexts: Other examples are: (exists) exactly one, (exists) at least ten, at least 10%, exactly as many. 2.1 Generalized Quantifiers Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [17], OQL [5], CORAL [23], RC/S <ref> [21] </ref> 3 One may argue that uses of NOT EXISTS (which is used to express universal quantification in SQL) are rarely seen. <p> As for extended query languages, there has been work on extending relational languages with primitives that can manipulate sets. An early example is Ozsoyo-glu and Wang's work <ref> [21] </ref>, where the operations on sets are limited. Sets have also been incorporated into logical query languages (for a recent example, see [23]). However, the idea of using the general notion of quantifier and explicitly making sets part of the language does not seem to appear until [16] and [1].
Reference: [22] <author> Pirahesh, H., Hellerstein, J. M., and Hasan, W. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proc. of ACM SIGMOD Int'l Conf. on Management of Data (1992), </booktitle> <pages> pp. 39-48. </pages>
Reference-contexts: Our general algorithm for all uses hash-based aggregation techniques similar to those of Graefe's, but with different structures. With respect to optimization, there have been many papers on query transformations and optimizations for performance benefits <ref> [9, 13, 22] </ref>. As Pirahesh et. al. point out in [22], there has not been any implementation for performance testing before theirs. <p> Our general algorithm for all uses hash-based aggregation techniques similar to those of Graefe's, but with different structures. With respect to optimization, there have been many papers on query transformations and optimizations for performance benefits [9, 13, 22]. As Pirahesh et. al. point out in <ref> [22] </ref>, there has not been any implementation for performance testing before theirs. Even their paper does not discuss performance benefits for the NOT EXISTS and EXCEPT predicates in SQL. 6 Conclusion Our primary objective was to explore the feasibility of extending relational systems for supporting quantified queries efficiently.
Reference: [23] <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S. </author> <title> The CORAL User Manual: A Tutorial Introduction to CORAL. </title> <institution> Computer Science Department, University of Wisconsin-Madison, </institution> <note> available via anonymous ftp from ftp.cs.wisc.edu in the directory coral/doc., Software Release. </note>
Reference-contexts: Other examples are: (exists) exactly one, (exists) at least ten, at least 10%, exactly as many. 2.1 Generalized Quantifiers Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [17], OQL [5], CORAL <ref> [23] </ref>, RC/S [21] 3 One may argue that uses of NOT EXISTS (which is used to express universal quantification in SQL) are rarely seen. <p> As for extended query languages, there has been work on extending relational languages with primitives that can manipulate sets. An early example is Ozsoyo-glu and Wang's work [21], where the operations on sets are limited. Sets have also been incorporated into logical query languages (for a recent example, see <ref> [23] </ref>). However, the idea of using the general notion of quantifier and explicitly making sets part of the language does not seem to appear until [16] and [1].
Reference: [24] <author> Rao, S. G., Badia, A., and Van Gucht, D. </author> <title> Processing Queries Containing Generalized Quantifiers. </title> <type> Technical Report 428, </type> <institution> Indiana University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: We have run experiments on the some and all operator algorithms for boolean matrices which show good characteristics <ref> [24] </ref>. 16 Every operator has access to information on the join, non-join, and grouping attributes of the input structures.
Reference: [25] <author> Rao, S. G., Badia, A., and Van Gucht, D. </author> <title> Efficient Processing Support for Quantified Queries. </title> <type> Technical Report 452, </type> <institution> Indiana University, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: Following this we show comparative performance results. involved a dataset without duplicates. 8 We are not publishing the performance figures for the commercial RDBMSs due to legal concerns. However, we fully describe the details of the experiments in <ref> [25] </ref>. 4.1 Conceptualization In relational query processors, hash-based join (j some) algorithms have been known to perform well [10]. They map relations at run-time to a 1-dimensional space by hashing on the join attribute values (each hash-value represents a point in this space). <p> These operators basically use the domain file structures to map the surrogate values back to the original attribute values to produce the output tuples. The complexity analysis of the quantifier operator algorithms is covered in <ref> [25] </ref>. The I/O time complexity for the some, group, and all operators is O (n), where n is the size of the input relations, unless the output relations dominate the cost.
Reference: [26] <author> Shoshani, A., and Wong, H. K. T. </author> <title> Statistical and Scientific Database Issues. </title> <journal> IEEE Transactions on Software Engineering 11 (1985), </journal> <pages> 1040-1047. </pages>
Reference-contexts: With respect to the former, researchers and database system vendors have always looked at alternative structures for performance based on the requirements of their areas of application or on the kind of queries targeted. Scientific and statistical databases have used multidimensional structures for performance on statistical queries <ref> [26] </ref>. Multidimensional database products like Essbase from Arbor Software, Express from Oracle and so on are available in the market that target aggregate queries in an on-line analytical processing environment. Multidimensional structures have been suggested for support for range-queries for relational databases [19, 20].
Reference: [27] <author> Sybase, Inc. </author> <title> Interactive Query Accelerator Too Much Data, Not Enough Information. Sybase White Papers, </title> <note> available on the web as of March 26, 1996 at http://www.sybase.com/toc.html. </note>
Reference-contexts: Multidimensional structures have been suggested for support for range-queries for relational databases [19, 20]. Sybase, a major relational database vendor, has in recent times offered a product, Sybase IQ, which uses bit-vector indexes for better performance on queries with multiple restriction and join predicates <ref> [27] </ref>. Bit-mapped join indexes have also been proposed for multi-way joins in relational systems [15]. As far as we know, though, no structure is specially devoted to support quantified queries. Graefe presented four algorithms for relational division with performance experiments [14].
Reference: [28] <editor> Transaction Processing Council (TPC). </editor> <title> TPC Benchmark T M D (Decision Support) Standard Specification, </title> <month> May </month> <year> 1995. </year> <note> Revision 1.0. </note>
Reference-contexts: It is significant that the TPC-D (Decision Support) Benchmark Specification by the Transaction Processing Council includes two quantified queries (Q4 and Q16) that involve these clauses for measuring performance in a decision support environment <ref> [28] </ref>. 1 operations necessary in the evaluation of quantified queries.
Reference: [29] <author> Ullman, J. </author> <title> Principles of Database and Knowledge-Base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference: [30] <author> Westerstahl, D. </author> <title> Quantifiers in Formal and Natural Languages. In Handbook of Philosophical Logic, </title> <editor> D. Gab-bay and F. Guenthner, Eds. D. </editor> <publisher> Reidel Publishing Company, </publisher> <year> 1989, </year> <pages> pp. 1-131. </pages>
Reference-contexts: There are, however, natural unary, as well as higher arity, generalized quantifiers <ref> [30] </ref>. A well-known example in the database community of a unary generalized quantifier is SQL's EXISTS.
References-found: 30

