URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/walk.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: gaylord@ux1.cso.uiuc.edu  kamin@cs.uiuc.edu  
Title: A Random Walk Through Functional Programming  
Author: Richard J. Gaylord Samuel Kamin 
Keyword: functional programming, Mathematica, random walks  
Date: August 17, 1992  
Address: 1304 W. Green St. Urbana, IL 61801  1304 W. Springfield Urbana, IL 61801  
Affiliation: Dept. of Materials Science Engineering University of Illinois  Computer Science Dept. University of Illinois  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John Backus, </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs, </title> <journal> Comm. ACM 21(8), </journal> <month> Aug. </month> <year> 1978, </year> <pages> 613-641. </pages>
Reference-contexts: John Backus, the original designer of FORTRAN, in a scathing attack on procedural languages in 1978 <ref> [1] </ref>, called this "the von Neumann bottleneck." An alternative approach to programming is the "functional" style. Simply stated, this is an attempt to lift the entire programming process to the same level of convenience as using arithmetic expressions in procedural languages. <p> For example, f0, 0g [[1]] is 0, NESW [[1]] is f0, 1g, and NESW [[1]][[1]] is 0. (The latter can also be expressed more concisely as NESW <ref> [[1, 1] </ref>].) Furthermore, we can select a sublist of a list in one shot: if X is the list fx 1 ; : : : x n g and I is the list fi 1 ; : : : ; i k g, then X [[I]] is the list fx i <p> It is runEncode, which counts consecutive occurrences of identical elements in a list. For example, runEncode <ref> [f1, 1, 2, 3, 1, 1, 1g] </ref> returns ff1, 2g, f2, 1g, f3, 1g, f1, 3gg. Base cases: Because the induction step will be applicable only when the list is of length two or greater, we need two base cases: runEncode [fg] = fg, and runEncode [fxg] = ffx, 1gg. <p> Rendering all this in Mathematica, we have: runEncode [L ] := If [L==fg, fg, If [Length [L]==1, ffL [[1]], 1gg, With [frunencRest = runEncode [Rest [L]]g, If [L [[1]]===runencRest <ref> [[1, 1] </ref>], Prepend [Rest [runencRest], fL [[1]], runencRest [[1, 2]]+1g], Prepend [runencRest, fL [[1]], 1g]]]] (Prepend is the same as Append, but adds the new element at the end of the list.) It is debatable whether this code is "better" than the code in section 4.2. <p> We use pattern-matching and transformation rules to accomplish this. The argument to runEncode does not have to be a list of pairs. It can find runs in any list. For example, runEncode <ref> [f1, 4, 4, 2, 1, 1, 1g] </ref> will produce ff1, 1g, f4, 2g, f2, 1g, f1, 3gg. <p> For a particular path generated by evaluating walk one time the square end-to-end distance of the walk is given by squaredist [path ] := path <ref> [[-1, 1] </ref>]^2 + path [[-1, 2]]^2] Recall that given list L, the expression L [[i]] denotes the i th element of L, and L [[-i]] denotes the i th element from the end. Thus, path [[-1]] is the last element in path. It is a pair of numbers. <p> Thus, path [[-1]] is the last element in path. It is a pair of numbers. The first element of the pair is path <ref> [[-1, 1] </ref>]. Likewise, the y coordinate of the last step location is path [[-1, 2]]. Of course, the ending location of a walk varies greatly from one randomly generated walk to another and what is most meaningful is the mean-square-end-to-end distance, realized over many executions of the walk. <p> For specificity, we will consider m equal to 1000 and n equal to 50, 100, 150, and 200. Map [curry [meansqdist][1000], Table <ref> [50i, fi, 1, 4g] </ref>] To create powerLawlist, we need to create pairs consisting of the elements of the above list with the elements of Table [50i, fi, 1, 4g]. This can be done using Transpose: powerLawlist = Transpose [fMap [curry [meansqdist][1000], Table [50i, fi, 1, 4g]], Table [50i, fi, 1, 4g]g] <p> For specificity, we will consider m equal to 1000 and n equal to 50, 100, 150, and 200. Map [curry [meansqdist][1000], Table <ref> [50i, fi, 1, 4g] </ref>] To create powerLawlist, we need to create pairs consisting of the elements of the above list with the elements of Table [50i, fi, 1, 4g]. This can be done using Transpose: powerLawlist = Transpose [fMap [curry [meansqdist][1000], Table [50i, fi, 1, 4g]], Table [50i, fi, 1, 4g]g] 5 OTHER WALKS 17 We can use powerLawlist to determine the power law relationship beween the mean-square-end-to-end distance and the number of steps by taking <p> Map [curry [meansqdist][1000], Table <ref> [50i, fi, 1, 4g] </ref>] To create powerLawlist, we need to create pairs consisting of the elements of the above list with the elements of Table [50i, fi, 1, 4g]. This can be done using Transpose: powerLawlist = Transpose [fMap [curry [meansqdist][1000], Table [50i, fi, 1, 4g]], Table [50i, fi, 1, 4g]g] 5 OTHER WALKS 17 We can use powerLawlist to determine the power law relationship beween the mean-square-end-to-end distance and the number of steps by taking the Log of each part of each pair in the list and fitting the result to a <p> [curry [meansqdist][1000], Table <ref> [50i, fi, 1, 4g] </ref>] To create powerLawlist, we need to create pairs consisting of the elements of the above list with the elements of Table [50i, fi, 1, 4g]. This can be done using Transpose: powerLawlist = Transpose [fMap [curry [meansqdist][1000], Table [50i, fi, 1, 4g]], Table [50i, fi, 1, 4g]g] 5 OTHER WALKS 17 We can use powerLawlist to determine the power law relationship beween the mean-square-end-to-end distance and the number of steps by taking the Log of each part of each pair in the list and fitting the result to a polynomial using the built-in least-squares <p> than 100, then repeat [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat <ref> [(# + NESW [[Random [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = <p> repeat [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat [(# + NESW <ref> [[Random [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = 1 or the <p> [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat [(# + NESW [[Random <ref> [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = 1 or the line
Reference: [2] <author> Richard J. Gaylord et al., </author> <title> The Mathematica Programming Language: A Primer, </title> <note> in preparation. </note>
Reference-contexts: However, this problem has been alleviated to a considerable extent by recent advances in computer hardware which have also permitted scientific computing to expand beyond number crunching on mainframes to symbolic manipulation and visualization on desktops. In this paper we illustrate functional programming using the Mathematica programming language <ref> [2, 3, 4, 5] </ref>, which is widely available in the scientific community. <p> It is runEncode, which counts consecutive occurrences of identical elements in a list. For example, runEncode <ref> [f1, 1, 2, 3, 1, 1, 1g] </ref> returns ff1, 2g, f2, 1g, f3, 1g, f1, 3gg. Base cases: Because the induction step will be applicable only when the list is of length two or greater, we need two base cases: runEncode [fg] = fg, and runEncode [fxg] = ffx, 1gg. <p> Rendering all this in Mathematica, we have: runEncode [L ] := If [L==fg, fg, If [Length [L]==1, ffL [[1]], 1gg, With [frunencRest = runEncode [Rest [L]]g, If [L [[1]]===runencRest [[1, 1]], Prepend [Rest [runencRest], fL [[1]], runencRest <ref> [[1, 2] </ref>]+1g], Prepend [runencRest, fL [[1]], 1g]]]] (Prepend is the same as Append, but adds the new element at the end of the list.) It is debatable whether this code is "better" than the code in section 4.2. <p> We use pattern-matching and transformation rules to accomplish this. The argument to runEncode does not have to be a list of pairs. It can find runs in any list. For example, runEncode <ref> [f1, 4, 4, 2, 1, 1, 1g] </ref> will produce ff1, 1g, f4, 2g, f2, 1g, f1, 3gg. <p> For a particular path generated by evaluating walk one time the square end-to-end distance of the walk is given by squaredist [path ] := path [[-1, 1]]^2 + path <ref> [[-1, 2] </ref>]^2] Recall that given list L, the expression L [[i]] denotes the i th element of L, and L [[-i]] denotes the i th element from the end. Thus, path [[-1]] is the last element in path. It is a pair of numbers. <p> Thus, path [[-1]] is the last element in path. It is a pair of numbers. The first element of the pair is path [[-1, 1]]. Likewise, the y coordinate of the last step location is path <ref> [[-1, 2] </ref>]. Of course, the ending location of a walk varies greatly from one randomly generated walk to another and what is most meaningful is the mean-square-end-to-end distance, realized over many executions of the walk.
Reference: [3] <author> Roman Maeder, </author> <title> Programming in Mathematica, 2nd Ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: However, this problem has been alleviated to a considerable extent by recent advances in computer hardware which have also permitted scientific computing to expand beyond number crunching on mainframes to symbolic manipulation and visualization on desktops. In this paper we illustrate functional programming using the Mathematica programming language <ref> [2, 3, 4, 5] </ref>, which is widely available in the scientific community. <p> Thus, if L is the list just given, the expression Count <ref> [L, 3] </ref> returns 2, and the expression f3, Count [L, 3]g returns f3, 2g. Now suppose M is the list of all the values occurring in L, without repetitions. <p> Thus, if L is the list just given, the expression Count <ref> [L, 3] </ref> returns 2, and the expression f3, Count [L, 3]g returns f3, 2g. Now suppose M is the list of all the values occurring in L, without repetitions. <p> It is runEncode, which counts consecutive occurrences of identical elements in a list. For example, runEncode <ref> [f1, 1, 2, 3, 1, 1, 1g] </ref> returns ff1, 2g, f2, 1g, f3, 1g, f1, 3gg. Base cases: Because the induction step will be applicable only when the list is of length two or greater, we need two base cases: runEncode [fg] = fg, and runEncode [fxg] = ffx, 1gg. <p> We can illustrate the use of add simply : In []:= add <ref> [3] </ref> Out []= Function [y$, 3 + y$] In []:= %[4] We can now create powerLawlist using curry and meansqdist. For specificity, we will consider m equal to 1000 and n equal to 50, 100, 150, and 200.
Reference: [4] <author> Roman Maeder, </author> <title> Mathematica as a programming language, </title> <journal> Dr. Dobbs Journal 187, </journal> <pages> 86-97, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, this problem has been alleviated to a considerable extent by recent advances in computer hardware which have also permitted scientific computing to expand beyond number crunching on mainframes to symbolic manipulation and visualization on desktops. In this paper we illustrate functional programming using the Mathematica programming language <ref> [2, 3, 4, 5] </ref>, which is widely available in the scientific community. <p> We use pattern-matching and transformation rules to accomplish this. The argument to runEncode does not have to be a list of pairs. It can find runs in any list. For example, runEncode <ref> [f1, 4, 4, 2, 1, 1, 1g] </ref> will produce ff1, 1g, f4, 2g, f2, 1g, f1, 3gg. <p> than 100, then repeat [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat <ref> [(# + NESW [[Random [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = <p> repeat [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat [(# + NESW <ref> [[Random [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = 1 or the <p> [s, f1g, t] produces the list f1, 2, 5.41421, 31.6406, 1006.75g: In []:= repeat [(#^2+Sqrt [#])&, f1.0g, (Last [#]&gt;=100)&] Out []= f1, 2, 5.41421, 31.6406, 1006.75g Here is how we can rewrite the simple random walk program using the repeat function walk [n ] := repeat [(# + NESW [[Random <ref> [Integer, 1, 4] </ref>]])&, ff0,0gg, (Length [#] == n)&] 6 WALKS ON COMPLEX TERRAIN 18 The repeat function can be used for a lattice walk which terminates when the walk starting at the origin attempts to move out of the northeast quadrant, i.e. reaches the line x = 1 or the line
Reference: [5] <author> Stephen Wolfram, </author> <title> Mathematica: A System for Doing Mathematics by Computer, 2nd Ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: However, this problem has been alleviated to a considerable extent by recent advances in computer hardware which have also permitted scientific computing to expand beyond number crunching on mainframes to symbolic manipulation and visualization on desktops. In this paper we illustrate functional programming using the Mathematica programming language <ref> [2, 3, 4, 5] </ref>, which is widely available in the scientific community.
Reference: [6] <author> M. N. Barber, B.W. Ninham, </author> <title> Random and Restricted Walks: Theory and Applications, </title> <publisher> Gordon and Breach, </publisher> <address> New York, </address> <year> 1970. </year>
Reference-contexts: single problem domain, the "random walk" model, in order to demonstrate the range and power of computational tools that the functional style of programming can bring to bear on a subject of current scientific interest. 2 The General Two-Dimensional Lattice Walk The random walk model is the quintessential stochastic process <ref> [6, 7, 8] </ref>. First posed in 1905, it has since found application in many areas including the physical sciences (Einstein employed the model in his work on atomistic diffusion), biological and ecological sciences (animal territorial behavior) and economics (stock market trends).
Reference: [7] <author> George H. Weiss, </author> <title> Random walks and their applications, </title> <journal> American Scientist 71, </journal> <month> 65-71 </month> <year> (1983). </year>
Reference-contexts: single problem domain, the "random walk" model, in order to demonstrate the range and power of computational tools that the functional style of programming can bring to bear on a subject of current scientific interest. 2 The General Two-Dimensional Lattice Walk The random walk model is the quintessential stochastic process <ref> [6, 7, 8] </ref>. First posed in 1905, it has since found application in many areas including the physical sciences (Einstein employed the model in his work on atomistic diffusion), biological and ecological sciences (animal territorial behavior) and economics (stock market trends).
Reference: [8] <author> George H. Weiss, Robert J. Rubin, RandomWalks: </author> <title> Theory and Selected Applications, </title> <booktitle> in Advances in Chemical Physics 52, </booktitle> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1983, </year> <pages> pp. 363-503 </pages> . 
Reference-contexts: single problem domain, the "random walk" model, in order to demonstrate the range and power of computational tools that the functional style of programming can bring to bear on a subject of current scientific interest. 2 The General Two-Dimensional Lattice Walk The random walk model is the quintessential stochastic process <ref> [6, 7, 8] </ref>. First posed in 1905, it has since found application in many areas including the physical sciences (Einstein employed the model in his work on atomistic diffusion), biological and ecological sciences (animal territorial behavior) and economics (stock market trends). <p> The following illustrates the notation for defining functions in Mathematica: In []:= walk [n ] := FoldList [Plus, f0, 0g, NESW [[ Table [Random [Integer, f1, 4g], fn-1g] ]] ] In []:= walk <ref> [8] </ref> Out []= ff0, 0g, f-1, 0g, f-1, 1g, f-1, 2g, f0, 2g, f0, 1g, f0, 0g, f-1, 0gg The main thing to notice about the definition of walk is that the argument must be followed by an underline character when it appears on the left-hand side of the ":=". <p> [n ] := NESW [[ Table [Random [Integer, f1, 4g], fn-1g] ]] and, given a list of steps, we can easily obtain the list of sites: stepsToWalk [steps ] := FoldList [Plus, f0, 0g, steps] For example, we could obtain our previous walk as follows: In []:= steps8 = walkSteps <ref> [8] </ref> Out []= ff-1, 0g, f0, 1g, f0, 1g, f1, 0g, f0, -1g, f0, -1g, f-1, 0gg.
References-found: 8

