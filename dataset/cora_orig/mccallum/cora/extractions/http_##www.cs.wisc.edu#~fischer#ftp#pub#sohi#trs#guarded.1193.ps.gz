URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/trs/guarded.1193.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/trs/
Root-URL: http://www.cs.wisc.edu
Email: pnevmati@cs.wisc.edu  
Phone: FAX (608) 262-9777  FAX (608) 262-9777  
Title: Guarded Execution and Branch Prediction in Dynamic ILP Processors  Contact Address  
Author: Dionisios N. Pnevmatikatos and Gurindar S. Sohi Dionisios N. Pnevmatikatos 
Note: This work was supported in part by NSF grant CCR-9303030 and by ONR grant N00014-93-1-0465.  
Address: 1210 West Dayton Street, Madison, WI 53706  1210 West Dayton Street, Madison, WI 53706  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  Computer Sciences Department, University of Wisconsin-Madison,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Allen, K. Kennedy, C. Porterfield, and J. Warren, </author> <title> ``Conversion of Control Dependence to Data Dependence,'' </title> <booktitle> Proc. 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the decision tree. These diverging control structures are not amenable to if-conversion <ref> [1] </ref>, and guarding is used as a general and powerful technique to fill multiple delay slots of branch instructions.
Reference: [2] <author> T. M. Austin and G. S. Sohi, </author> <title> ``Dynamic Dependency Analysis of Ordinary Programs,'' </title> <booktitle> in Proc. 19th Annual Symposium on Computer Architecture, </booktitle> <address> Queensland, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Many studies have shown that the parallelism available within basic blocks is limited <ref> [2, 3, 21, 23] </ref>, and it is clear that one has to look beyond basic block boundaries for more parallelism. The larger the number of instructions that can be examined, the greater the parallelism that can be extracted. To get past branch instructions, processor designers have two options.
Reference: [3] <author> M. Butler, T. Yeh, Y. Patt, M. Alsup, H. Scales, and M. Shebanow, </author> <title> ``Single Instruction Stream Parallelism Is Greater than Two,'' </title> <booktitle> in Proc. 18th Annual International Symposium on Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: Many studies have shown that the parallelism available within basic blocks is limited <ref> [2, 3, 21, 23] </ref>, and it is clear that one has to look beyond basic block boundaries for more parallelism. The larger the number of instructions that can be examined, the greater the parallelism that can be extracted. To get past branch instructions, processor designers have two options.
Reference: [4] <author> Brian Case, </author> <title> ``SPARC V9 Adds Wealth of New Features,'' Microprocessor Report, </title> <journal> vol. </journal> <volume> 7, </volume> <month> Febru-ary </month> <year> 1993. </year>
Reference-contexts: Furthermore, there have been very few studies of the utility of guarded execution for general-purpose application programs [18]. Recent microprocessors, however, have combined the two, offering simple guarded instructions such as the conditional move instruction, while allowing for dynamic branch prediction <ref> [4, 6] </ref>. The presence of both guarded and speculative execution opens up many opportunities (both static and dynamic) to exploit ILP. It also raises several questions regarding the interactions of the two techniques. 2 This paper has three purposes. <p> The DEC Alpha [6] and the SPARC V9 <ref> [4] </ref> architectures are prime examples, offering a conditional move (CMOVE) instruction. (Since a move instruction has only two operands (one source and one destination), bits to specify the third operand (the guard register) explicitly can easily be taken from unused instruction bits (the second source operand of computation instructions).) The second
Reference: [5] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu, </author> <title> ``IMPACT: An Architectural Framework for Multiple-Instruction-Issue Processors,'' </title> <booktitle> Proc. 18th International Symposium on Computer Architecture, </booktitle> <pages> pp. 266-275, </pages> <year> 1991. </year>
Reference-contexts: We do not count any instructions required to set the condition registers. We also do not count any (static) NOPs or any guarded instructions that are dynamically transformed into NOPs. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [5, 11, 18] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the static guarded block size.
Reference: [6] <author> R. Comerford, </author> <title> ``How DEC Developed Alpha,'' </title> <journal> IEEE Spectrum, </journal> <volume> vol. 29, </volume> <pages> pp. 43-47, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Furthermore, there have been very few studies of the utility of guarded execution for general-purpose application programs [18]. Recent microprocessors, however, have combined the two, offering simple guarded instructions such as the conditional move instruction, while allowing for dynamic branch prediction <ref> [4, 6] </ref>. The presence of both guarded and speculative execution opens up many opportunities (both static and dynamic) to exploit ILP. It also raises several questions regarding the interactions of the two techniques. 2 This paper has three purposes. <p> The DEC Alpha <ref> [6] </ref> and the SPARC V9 [4] architectures are prime examples, offering a conditional move (CMOVE) instruction. (Since a move instruction has only two operands (one source and one destination), bits to specify the third operand (the guard register) explicitly can easily be taken from unused instruction bits (the second source operand
Reference: [7] <author> J. C. Dehnert, P. Y. T. Hsu, and J. P. Bratt, </author> <title> ``Overlapped loop support in the Cydra-5,'' </title> <booktitle> Proc. Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: Using these vector masks, loops with if-statements can be vector-ized. Recently proposed VLIW machines, for example the Cydra-5 [20], and the IBM VLIW machine [9], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions <ref> [7, 16] </ref>. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction. Proposed methods for specifying guarded execution suggest the use of an additional operand field for each instruction.
Reference: [8] <author> D. R. Ditzel, H. R. McLellan, and A. D. Berenbaum, </author> <title> ``The Hardware Architecture of the CRISP Microprocessor,'' </title> <booktitle> in Proc. 14th Annual Symposium on Computer Architecture, </booktitle> <address> Pittsburgh, PA, </address> <pages> pp. 309-319, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In this case, the instruction can be interpreted by the hardware which will expand all the instructions specified in the guard mask adding the condition register, and will keep the expanded guarded instructions close to the execution stages in a decoded instruction cache <ref> [8] </ref>. This ``macro'' expansion can take place on demand, when the instruction cache misses, so it will not affect the critical path of instruction fetching or execution.
Reference: [9] <author> K. Ebcioglu, </author> <title> ``Some Design Ideas for a VLIW Architecture for Sequential Natured Software,'' </title> <booktitle> in Parallel Processing (Proceedings of IFIP WG 10.3 Working Conference on Parallel Processing), </booktitle> <editor> ed., Cosnard at al. </editor> <publisher> North Holland, </publisher> <pages> pp. 3-21, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here vector masks are used to express (multiple) guard conditions. Using these vector masks, loops with if-statements can be vector-ized. Recently proposed VLIW machines, for example the Cydra-5 [20], and the IBM VLIW machine <ref> [9] </ref>, have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions [7, 16]. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction.
Reference: [10] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> ``Predicting Conditional Branch Directions from Previous Runs of a Program,'' </title> <booktitle> Proc. ASPLOS V, </booktitle> <year> 1992. </year>
Reference-contexts: for almost all programs the (average) window size is greater than 150 useful hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 It is interesting to compare the dynamic window sizes that can be established with guarding and dynamic branch prediction with the window sizes that can be established with trace scheduling, which uses static branch prediction <ref> [10] </ref>. 5 The window size for each program is the average of all window sizes that are established dynamically. 12 instructions.
Reference: [11] <author> J. A. Fisher, </author> <title> ``Trace Scheduling: A Technique for Global Microcode Compaction,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-30, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: We do not count any instructions required to set the condition registers. We also do not count any (static) NOPs or any guarded instructions that are dynamically transformed into NOPs. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [5, 11, 18] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the static guarded block size.
Reference: [12] <author> M. D. Hill and A. J. Smith, </author> <title> ``Evaluating Associativity in CPU Caches,'' </title> <journal> IEEE Transactions On Computer, </journal> <month> December </month> <year> 1989. </year>
Reference-contexts: Benchmarks For benchmark programs, we used the entire integer SPEC92 benchmark suite, namely the programs Compress, Eqntott, Espresso, Gcc, Sc and Xlisp. We also used three architecture simulators, Tycho, a cache simulator <ref> [12] </ref>, Supermips, a superscalar processor simulator based on the MIPS instruction set, and Thissim, a trace driven simulator similar to the one we used for this study. Finally, we used the TeX text formatter and the Yacc parser generator, as well as two Object Oriented Database benchmarks, Sunbench and Tektronix.
Reference: [13] <author> P. Y. T. Hsu and E. S. Davidson, </author> <title> ``Highly Concurrent Scalar Processing,'' </title> <booktitle> Proc. 13th Annual Symposium on Computer Architecture, </booktitle> <pages> pp. 386-395, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: This technique requires a branch prediction mechanism, which can be either static or dynamic, and the ability to undo the effects of instructions executed after an incorrectly predicted branch. The second option is the use of guarded execution <ref> [13] </ref> (also called conditional execution or predicated execution). By eliminating some branch instructions, the effective block size (the number of instructions between branches) is increased, increasing opportunities for parallelism extraction. Traditionally, guarded execution and speculative execution (especially speculative execution with dynamic branch prediction), have been treated mutually exclusively. <p> We discuss how the proposed technique overcomes the drawbacks of existing methods of specifying guarded execution, and also evaluate it quantitatively. Finally, section 7 presents concluding remarks. 2. Guarded Execution Guarded execution (or simply guarding), for scalar processors was first proposed by Hsu and Davidson <ref> [13, 14] </ref> to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the decision tree.
Reference: [14] <author> P. Y. T. Hsu, </author> <title> ``Highly Concurrent Scalar Processing,'' </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: We discuss how the proposed technique overcomes the drawbacks of existing methods of specifying guarded execution, and also evaluate it quantitatively. Finally, section 7 presents concluding remarks. 2. Guarded Execution Guarded execution (or simply guarding), for scalar processors was first proposed by Hsu and Davidson <ref> [13, 14] </ref> to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the decision tree.
Reference: [15] <author> W. W. Hwu and Y. N. Patt, </author> <title> ``Checkpoint Repair for High-Performance Out-of-Order Execution Machines,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-36, </volume> <pages> pp. 1496-1514, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: In this approach, handling of traps (which cannot be deferred until the state of the processor becomes clean) requires that processor reverts to the last PC for which the state was clean, in a manner similar to the checkpoint repair of <ref> [15] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh A C T T PREDICATE A always always i1: ld r6, 0 (r2) beq r7, zero, Label i3: ld r3, 0 (r1) i5: sw r17, 0 (r1) beq r5, zero, Label i6: mov r1, r3 Label: i8: add r7, r7, 1 Assembly Code 0 0 0 0 0 1
Reference: [16] <author> M. S. Lam, </author> <title> ``Software Pipelining: An Effective Scheduling Technique for VLIW Machines,'' </title> <booktitle> Proceedings of the SIGPLAN 1988 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 318-328. </pages>
Reference-contexts: Using these vector masks, loops with if-statements can be vector-ized. Recently proposed VLIW machines, for example the Cydra-5 [20], and the IBM VLIW machine [9], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions <ref> [7, 16] </ref>. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction. Proposed methods for specifying guarded execution suggest the use of an additional operand field for each instruction.
Reference: [17] <author> J. K. F. Lee and A. J. Smith, </author> <title> ``Branch Prediction Strategies and Branch Target Buffer Design,'' </title> <journal> IEEE Computer, </journal> <volume> vol. 17, </volume> <pages> pp. 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Two, since the number of (static and dynamic) branches that need to be predicted is changed, the mechanics of the prediction mechanism could change completely. For example, if the prediction mechanism is counter-based <ref> [17, 22] </ref>, a prediction mechanism with a smaller number of table entries may suffice. If the prediction mechanism is pattern-based [19, 25], its behavior might be radically altered since the pattern of dynamic branches is changed.
Reference: [18] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann, </author> <title> ``Effective Compiler Support for Predicated Execution Using the Hyperblock,'' </title> <booktitle> Proceedings of the 25th Annual Workshop on Microprogramming and Microarchitecture (Micro 25), </booktitle> <pages> pp. 45-54, </pages> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Traditionally, guarded execution and speculative execution (especially speculative execution with dynamic branch prediction), have been treated mutually exclusively. Furthermore, there have been very few studies of the utility of guarded execution for general-purpose application programs <ref> [18] </ref>. Recent microprocessors, however, have combined the two, offering simple guarded instructions such as the conditional move instruction, while allowing for dynamic branch prediction [4, 6]. The presence of both guarded and speculative execution opens up many opportunities (both static and dynamic) to exploit ILP. <p> Proposed methods for specifying guarded execution suggest the use of an additional operand field for each instruction. This operand field is used to specify a register that holds the guard condition; the register could either be a general-purpose register, or part of a special predicate register file <ref> [18, 20] </ref>. Introducing guarded execution into scalar processors can be a very powerful concept; Figure 1 presents a small example. Figure 1 (a) show the C-code for inner loop of the Cmppt function of the SPEC92 benchmark Eqntott. <p> The problem is exacerbated by the instruction scheduler which, by rearranging the instructions, can increase the register lifetime. A possible solution to this problem is to add a separate predicate register file <ref> [18, 20] </ref>, to relieve the pressure on the architectural registers. This solution, however, may result in extra instructions to transfer values between the two register files and clearly cannot be easily incorporated into existing architectures. <p> Mahlke et al addressed some of these issues for statically scheduled machines (such as VLIW), taking in account mainly the basic block size and the execution frequency <ref> [18] </ref>. In their scheme, a Hyper-block of instructions is formed, using trace selection based on branch frequencies, such that the Hyper-block has a single entry point and one or more exit points. Branches that are not amenable to static prediction are eliminated using if-conversion. <p> We do not count any instructions required to set the condition registers. We also do not count any (static) NOPs or any guarded instructions that are dynamically transformed into NOPs. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [5, 11, 18] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the static guarded block size. <p> Should aggressive loop unrolling and function inlining be performed, the potential of guarded execution would be enhanced. The guarded blocks constructed by our algorithm differ from the ones constructed in the Hyperblock formation of <ref> [18] </ref> in two ways. First, we require that all branches internal to the block (except the last one) are eliminated by the if-conversion; a Hyperblock is allowed to contain multiple branches and exit points. We treat what would be a Hyperblock in [18] as a sequence of basic blocks and guarded <p> the ones constructed in the Hyperblock formation of <ref> [18] </ref> in two ways. First, we require that all branches internal to the block (except the last one) are eliminated by the if-conversion; a Hyperblock is allowed to contain multiple branches and exit points. We treat what would be a Hyperblock in [18] as a sequence of basic blocks and guarded blocks. Our metrics, namely the effective and the static guarded block size, are not affected by these differences as the useful computation remains the same, and the number of branches and the non-useful guarded computation depend solely on the if-conversion transformations. <p> smaller overhead than existing methods of specifying guarded execution. (It is possible to realize the full power of guarding with as few as three additional instructions: a GUARD_BOTH, and move instructions to save and restore the active_mask, as compared to tens of instructions to incorporate guarding using a traditional specification <ref> [18] </ref> ). For our benchmark programs, two flavors of GUARD instructions allowed the full power of guarding to be realized (large effective block sizes and large dynamic windows), with an overhead of about 13.9% and 9.72%, respectively. We are carrying out more studies to reduce this overhead even further. 18
Reference: [19] <author> S.-T. Pan, K. So, and J. T. Rahmeh, </author> <title> ``Improving the Accuracy of Dynamic Branch Prediction Us--ing Branch Correlation,'' </title> <booktitle> Proc. Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <month> October, </month> <year> 1992. </year>
Reference-contexts: For example, if the prediction mechanism is counter-based [17, 22], a prediction mechanism with a smaller number of table entries may suffice. If the prediction mechanism is pattern-based <ref> [19, 25] </ref>, its behavior might be radically altered since the pattern of dynamic branches is changed.
Reference: [20] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. Towle, </author> <title> ``The Cydra 5 Departmental Supercomputer: Design Philosophies, Decisions, and Trade-offs,'' </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January, </month> <year> 1989. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here vector masks are used to express (multiple) guard conditions. Using these vector masks, loops with if-statements can be vector-ized. Recently proposed VLIW machines, for example the Cydra-5 <ref> [20] </ref>, and the IBM VLIW machine [9], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions [7, 16]. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction. <p> Proposed methods for specifying guarded execution suggest the use of an additional operand field for each instruction. This operand field is used to specify a register that holds the guard condition; the register could either be a general-purpose register, or part of a special predicate register file <ref> [18, 20] </ref>. Introducing guarded execution into scalar processors can be a very powerful concept; Figure 1 presents a small example. Figure 1 (a) show the C-code for inner loop of the Cmppt function of the SPEC92 benchmark Eqntott. <p> The problem is exacerbated by the instruction scheduler which, by rearranging the instructions, can increase the register lifetime. A possible solution to this problem is to add a separate predicate register file <ref> [18, 20] </ref>, to relieve the pressure on the architectural registers. This solution, however, may result in extra instructions to transfer values between the two register files and clearly cannot be easily incorporated into existing architectures.
Reference: [21] <author> E. M. Riseman and C. C. Foster, </author> <title> ``The Inhibition of Potential Parallelism by Conditional Jumps,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-21, </volume> <pages> pp. 1405-1411, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: Many studies have shown that the parallelism available within basic blocks is limited <ref> [2, 3, 21, 23] </ref>, and it is clear that one has to look beyond basic block boundaries for more parallelism. The larger the number of instructions that can be examined, the greater the parallelism that can be extracted. To get past branch instructions, processor designers have two options.
Reference: [22] <author> J. E. Smith, </author> <title> ``A Study of Branch Prediction Strategies,'' </title> <booktitle> Proc. 8th International Symposium on Computer Architecture, </booktitle> <pages> pp. 135-148, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: Two, since the number of (static and dynamic) branches that need to be predicted is changed, the mechanics of the prediction mechanism could change completely. For example, if the prediction mechanism is counter-based <ref> [17, 22] </ref>, a prediction mechanism with a smaller number of table entries may suffice. If the prediction mechanism is pattern-based [19, 25], its behavior might be radically altered since the pattern of dynamic branches is changed.
Reference: [23] <author> D. W. Wall, </author> <title> ``Limits of Instruction-Level Parallelism,'' </title> <booktitle> Proc. ASPLOS IV, </booktitle> <pages> pp. 176-188, </pages> <year> 1991. </year>
Reference-contexts: Many studies have shown that the parallelism available within basic blocks is limited <ref> [2, 3, 21, 23] </ref>, and it is clear that one has to look beyond basic block boundaries for more parallelism. The larger the number of instructions that can be examined, the greater the parallelism that can be extracted. To get past branch instructions, processor designers have two options.
Reference: [24] <author> N. J. Warter, S. A. Mahlke, W. W. Hwu, and B. R. Rau, </author> <title> ``Reverse If-Conversion,'' </title> <booktitle> Proceedings of the SIGPLAN 1993 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 290-299. </pages>
Reference-contexts: Branches that are not amenable to static prediction are eliminated using if-conversion. Finally, after the Hyperblock formation, the instructions are scheduled using conventional parallelism enhancing techniques. The problem of wasted computation resulting from if-conversion was addressed by Warter et al <ref> [24] </ref>. They propose the use of if-conversion before the instruction scheduling phase of the compiler, to eliminate the control dependencies and expose parallelism to the optimizer. After the optimization phase, a reverse if-conversion transformation is proposed, in which guarded computation is transformed back into normal instructions covered by conditional branches.
Reference: [25] <author> T. Yeh and Y. Patt, </author> <title> ``A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History,'' </title> <booktitle> Proc. 20th Annual Int'l Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: For example, if the prediction mechanism is counter-based [17, 22], a prediction mechanism with a smaller number of table entries may suffice. If the prediction mechanism is pattern-based <ref> [19, 25] </ref>, its behavior might be radically altered since the pattern of dynamic branches is changed. <p> We use two different prediction mechanisms: a 2-bit counter-based mechanism, and a GAs (8,x) pattern-based mechanism <ref> [25] </ref>. For either case, we used three different table sizes: 1K, 4K, and 16K entries. (These translate into prediction tables of 2K, 8K, and 32K bits, respectively.) The above configurations are chosen since they are reasonable in terms of size and hardware complexity while achieving respectable performance.
References-found: 25

