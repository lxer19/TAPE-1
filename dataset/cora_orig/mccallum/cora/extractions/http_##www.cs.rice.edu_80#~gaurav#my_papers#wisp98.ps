URL: http://www.cs.rice.edu:80/~gaurav/my_papers/wisp98.ps
Refering-URL: http://www.cs.rice.edu:80/~gaurav/gaurav_research.html
Root-URL: 
Title: Better operating system features for faster network servers  
Author: Gaurav Banga Peter Druschel Jeffrey C. Mogul 
Abstract: Widely-used operating systems provide inadequate support for large-scale Internet server applications. Their algorithms and interfaces fail to efficiently support either event-driven or multi-threaded servers. They provide poor control over the scheduling and management of machine resources, making it difficult to provide robust and controlled service. We propose new UNIX interfaces to improve scalability, and to provide fine-grained scheduling and resource management. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Almeida, M. Dabu, A. Manikutty, and P. Cao. </author> <title> Providing Differentiated Quality-of-Service in Web Hosting Services. </title> <booktitle> In Proceedings of the Workshop on Internet Server Performance, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Moreover, the consumption of other resources, such as buffer space, is also uncontrolled. This lack of control over kernel resources makes it difficult to build a Web server to provide differentiated quality of service (QoS) to its clients <ref> [1] </ref>. <p> Also, migrating threads, processor capacity reserves and shuttles are micro-kernel specific solutions which do not address the problem of controlling the resource consumption of kernel I/O processing. Almeida et al. attacked the problem of providing QoS support in a Web server running on a widely available general-purpose operating system <ref> [1] </ref>. They mapped QoS requirements onto scheduling priorities, experimenting both with a user-level implementation, and with a slightly modified Linux kernel scheduler. They used the Apache server [4], and so followed the process-per-connection model, although their approach could probably be extended to a thread-based server.
Reference: [2] <author> E. W. Anderson and J. Pasquale. </author> <title> The Performance of the Container Shipping I/O System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles, </booktitle> <pages> page 229, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: We look at how such applications need to control scheduling and kernel resource consumption. We then describe new application programming interfaces (APIs) to support these require-ments. This paper does not address issues related to efficient operating system support for data movement. Other research has addressed those issues <ref> [2, 32, 36, 40] </ref>. 2 Evolution of Internet server execution models We begin by describing the evolution of Internet server execution models. To be concrete, we focus on Web servers. However, most of the issues we discuss apply to other Internet servers such as proxy, mail, file, and directory servers.
Reference: [3] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: effective kernel support for the user-level management of parallelism. </title> <booktitle> In Proceedings of 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 95109. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: This forces an application to use cumbersome methods to wait simultaneously for network and disk events. 3.2 Multi-threaded servers Previous research has exposed the limitations of thread support in current operating systems <ref> [3] </ref>. Pure kernel threads impose the overhead of a kernel call for each synchronization and context-switch operation. User-level threads have efficient context-switching and synchronization, but if any one user-level thread blocks on an I/O event, all of the threads in the process stall. <p> User-level threads have efficient context-switching and synchronization, but if any one user-level thread blocks on an I/O event, all of the threads in the process stall. This is analogous to the blocking I/O problem in event-driven servers. To rectify these problems, Anderson et. al. <ref> [3] </ref> proposed scheduler activations. Scheduler activations are kernel thread-like schedulable entities which provide execution contexts to user level threads. Context-switching is usually handled at user-level without changing the underlying scheduler activation. <p> Certainly threads are necessary to exploit the full power of a multiprocessor. A hybrid model, using a moderate number of threads and an event-based notification mechanism, may be best for Internet servers. As mentioned in Section 3.2, the issues involved in efficiently supporting threads are relatively well understood <ref> [3, 10, 19] </ref>. Thus, we concentrate here on efficient support for event-driven servers. 4.1 Resource containers We propose a new model for fine-grained resource management and scheduling.
Reference: [4] <author> Apache. </author> <note> http://www.apache.org/. </note>
Reference-contexts: In this model, a master server process accepts new connections and passes them to the pre-forked servers, using UNIX domain sockets. The next innovation eliminates the master process. Instead, each pre-forked server calls accept () directly to accept new connection requests. The Apache server <ref> [4] </ref> has this architecture. <p> Almeida et al. attacked the problem of providing QoS support in a Web server running on a widely available general-purpose operating system [1]. They mapped QoS requirements onto scheduling priorities, experimenting both with a user-level implementation, and with a slightly modified Linux kernel scheduler. They used the Apache server <ref> [4] </ref>, and so followed the process-per-connection model, although their approach could probably be extended to a thread-based server. They found that this approach allowed them to provide differentiated service to HTTP requests in different QoS classes, albeit with some limitations on effectiveness.
Reference: [5] <author> G. Banga, F. Douglis, and M. Rabinovich. </author> <title> Optimistic Deltas for WWW Latency Reduction. </title> <booktitle> In Proceedings of the 1997 USENIX Technical Conference, </booktitle> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid [11, 39], Zeus [44], thttpd [42] and several research servers <ref> [5, 24, 36] </ref> all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread. The thread scheduler is responsible for time-sharing the CPU between the various server threads.
Reference: [6] <author> G. Banga and J. C. Mogul. </author> <title> Scalable kernel performance for Internet servers under realistic loads. </title> <booktitle> In Proceedings of the 1998 USENIX Technical Conference, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Some of this has been as simple as tuning kernel parameters; in other cases it has been necessary to improve the implementation of some kernel features, such as the protocol control block (PCB) lookup algorithm in BSD-based systems [27, 38], and the select () system call <ref> [6] </ref>. Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems [6, 18, 25]. <p> Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems <ref> [6, 18, 25] </ref>. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. For instance, the scalability of UNIX-based event-driven servers is limited by the inherently linear-time select () system call [6]. <p> The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. For instance, the scalability of UNIX-based event-driven servers is limited by the inherently linear-time select () system call <ref> [6] </ref>. We propose extending the UNIX system call interface to provide more efficient support for Internet server applications. We discuss two control models for servers (event-driven and multi-threaded), and examine what they require from the operating system. <p> Signals therefore do not scale to support multiple connections. Although select () scales much better than signals, both the interface and traditional implementation of select () scale poorly with large numbers of descriptors. The implementation can be improved <ref> [6] </ref>, but the inter face inherently imposes costs linear in the number of descriptors (and makes optimizing the implementation difficult). The interface scales poorly because it passes information about all established connections from user-space to the kernel at each wait-for-next-event request.
Reference: [7] <author> S. M. Bellovin. </author> <title> Security Problems in the TCP/IP Protocol Suite. </title> <journal> Computer Communication Review, </journal> <volume> 19(2):3248, </volume> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: This leads to poor server throughput and instability under heavy load. This instability makes servers susceptible to denial-of-service attacks. For instance, a high rate of connection establishment requests sent to a server can potentially bring it to its knees <ref> [7] </ref>. 4 Operating system support for server applications In this section, we propose new operating system features to support server applications. We first describe a fine-grained resource management system for servers; this is the key to enabling robust and controlled service, independent of the execution model (thread-based or event-driven).
Reference: [8] <author> M. Burrows. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: This gets around some problems of pure event-driven servers, such as blocking disk I/O system calls, while still keeping thread management overhead low. Unfortunately, very little has been published about the use and performance of purely multi-threaded servers, even though several important high-performance servers, such as the AltaVista front-end <ref> [8] </ref>, have successfully adopted this approach. There has been a lot of research in the runtime systems community on improving the performance of massively threaded applications [10, 15, 19] by reducing the storage management overhead. However, these approaches have not yet been applied to general purpose operating systems.
Reference: [9] <institution> The Common Gateway Interface. </institution> <address> http://hoohoo. ncsa.uiuc.edu/cgi/. </address>
Reference-contexts: These pages are subsequently transferred to the client through the Web server. To make the construction of such auxiliary programs easier, several standard interfaces that govern the communication between Web servers and such programs have been defined. Examples include CGI <ref> [9] </ref> and FastCGI [16]. The earlier interface, CGI, creates a new process to handle each dynamic document request. The newer FastCGI allows persistent dynamic document server processes.
Reference: [10] <author> S. Chandra, B. Richards, and J. Larus. Teapot: </author> <title> Language Support for Writing Memory Coherence Protocols. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: There has been a lot of research in the runtime systems community on improving the performance of massively threaded applications <ref> [10, 15, 19] </ref> by reducing the storage management overhead. However, these approaches have not yet been applied to general purpose operating systems. <p> Certainly threads are necessary to exploit the full power of a multiprocessor. A hybrid model, using a moderate number of threads and an event-based notification mechanism, may be best for Internet servers. As mentioned in Section 3.2, the issues involved in efficiently supporting threads are relatively well understood <ref> [3, 10, 19] </ref>. Thus, we concentrate here on efficient support for event-driven servers. 4.1 Resource containers We propose a new model for fine-grained resource management and scheduling.
Reference: [11] <author> A. Chankhunthod, P. B. Danzig, C. Neerdaels, M. F. Schwartz, and K. J. Worrell. </author> <title> A Hierarchical Internet Object Cache. </title> <booktitle> In Proceedings of the 1996 USENIX Technical Conference, </booktitle> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers <ref> [11, 39, 42, 44] </ref> use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems [6, 18, 25]. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. <p> When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid <ref> [11, 39] </ref>, Zeus [44], thttpd [42] and several research servers [5, 24, 36] all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread.
Reference: [12] <author> D. D. Clark. </author> <title> The structuring of systems using up-calls. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171180, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: The kernel could use an efficient data structure, such as a priority queue, to represent the SIGNALLED EVENTS set. There are other viable alternatives to the proposed de-queue next events () system call. For example, event notifications can be structured as upcalls <ref> [12] </ref>, with the server process specifying handlers for various types of events directly to the operating system kernel. Similarly, the kernel could indicate events to the server process by using a pending-events queue in a memory region shared with the application process.
Reference: [13] <author> R. K. Clark, E. D. Jensen, and F. D. Reynolds. </author> <title> An architectural overview of the alpha real-time distributed kernel. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 127146, </pages> <address> Seattle WA (USA), </address> <month> Apr. </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: These include the processor capacity reserves of Mercer et. al. [28], the activities [22] of Rialto, the migrating threads of Mach [17] and AlphaOS <ref> [13] </ref>, and the shuttles of Spring [20]. The chief differences are related to the more general nature of resource containers. Processor capacity reserves and activities are real-time abstractions and are thus more complex to implement than resource containers.
Reference: [14] <author> P. Druschel and G. Banga. </author> <title> Lazy Receiver Processing (LRP): A Network Subsystem Architecture for Server Systems. </title> <booktitle> In Proc. 2nd Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Moreover, software interrupts have strictly higher priority than the execution of any user-level code. This can lead to scheduling anomalies, decreased throughput, and starvation or livelock <ref> [14, 30] </ref>. This is particularly important for servers because they are, by their nature, particularly network intensive. The LRP network subsystem architecture [14] was de signed to address these problems by more closely follow-ing the process-centric model. <p> Moreover, software interrupts have strictly higher priority than the execution of any user-level code. This can lead to scheduling anomalies, decreased throughput, and starvation or livelock [14, 30]. This is particularly important for servers because they are, by their nature, particularly network intensive. The LRP network subsystem architecture <ref> [14] </ref> was de signed to address these problems by more closely follow-ing the process-centric model. In this architecture, network processing is correctly integrated into the system's global resource management. Resources spent in processing network traffic are associated with and charged to the application process that caused the traffic. <p> of the process model in current operating systems, where the process itself is the resource container. (This is only approximately true in vanilla UNIX, where kernel resource utilization is often charged to the wrong process, or none at all; it is more nearly true using a mechanism such as LRP <ref> [14] </ref>.) In current systems, a process has a dual function: it serves as a protection domain, and as a resource container. The protection domain aspect of a process provides a mechanism for isolation between applications. <p> For example, the sendmsg () system call can be used to transfer file descriptors, and hence resource containers, between protection domains. The kernel execution model in the new system is a generalization of the LRP approach <ref> [14] </ref>. Like in LRP, a variety of methods can be used to execute kernel code. For instance, a dedicated per-process kernel thread can be used to perform all kernel processing for each process. We are currently in the process of building and refining these mechanisms and interfaces.
Reference: [15] <author> D. R. Engler, D. K. Lowenthal, and G. R. Andrews. </author> <title> Shared Filaments: Efficient Fine-Grain Parallelism on Shared-Memory Multiprocessors. </title> <type> Technical Report TR 93-13a, </type> <institution> University of Arizona, CS Dept., </institution> <address> Tucson, AZ, </address> <year> 1993. </year>
Reference-contexts: There has been a lot of research in the runtime systems community on improving the performance of massively threaded applications <ref> [10, 15, 19] </ref> by reducing the storage management overhead. However, these approaches have not yet been applied to general purpose operating systems.
Reference: [16] <author> Open Market. </author> <title> FastCGI Specification. </title> <address> http://www. fastcgi.com/. </address>
Reference-contexts: These pages are subsequently transferred to the client through the Web server. To make the construction of such auxiliary programs easier, several standard interfaces that govern the communication between Web servers and such programs have been defined. Examples include CGI [9] and FastCGI <ref> [16] </ref>. The earlier interface, CGI, creates a new process to handle each dynamic document request. The newer FastCGI allows persistent dynamic document server processes.
Reference: [17] <author> B. Ford and J. Lepreau. </author> <title> Evolving Mach 3.0 to a migrating thread model. </title> <booktitle> In Proceedings of the 1994 Winter Usenix Conference, </booktitle> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: These include the processor capacity reserves of Mercer et. al. [28], the activities [22] of Rialto, the migrating threads of Mach <ref> [17] </ref> and AlphaOS [13], and the shuttles of Spring [20]. The chief differences are related to the more general nature of resource containers. Processor capacity reserves and activities are real-time abstractions and are thus more complex to implement than resource containers.
Reference: [18] <author> A. Fox, S. D. Gribble, Y. Chawathe, E. A. Brewer, and P. Gauthier. </author> <title> Cluster-based scalable network services. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating System Principles, </booktitle> <address> San Malo, France, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems <ref> [6, 18, 25] </ref>. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. For instance, the scalability of UNIX-based event-driven servers is limited by the inherently linear-time select () system call [6].
Reference: [19] <author> D. Grunwald and R. Neves. </author> <title> Whole-Program Optimization for Time and Space Efficient Threads. </title> <booktitle> In Proceedings of the 2nd Intl. Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Cambridge, MA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: There has been a lot of research in the runtime systems community on improving the performance of massively threaded applications <ref> [10, 15, 19] </ref> by reducing the storage management overhead. However, these approaches have not yet been applied to general purpose operating systems. <p> Certainly threads are necessary to exploit the full power of a multiprocessor. A hybrid model, using a moderate number of threads and an event-based notification mechanism, may be best for Internet servers. As mentioned in Section 3.2, the issues involved in efficiently supporting threads are relatively well understood <ref> [3, 10, 19] </ref>. Thus, we concentrate here on efficient support for event-driven servers. 4.1 Resource containers We propose a new model for fine-grained resource management and scheduling.
Reference: [20] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proc. of the 1993 Summer Usenix Conference, </booktitle> <pages> pages 147159, </pages> <address> Cincinatti, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: These include the processor capacity reserves of Mercer et. al. [28], the activities [22] of Rialto, the migrating threads of Mach [17] and AlphaOS [13], and the shuttles of Spring <ref> [20] </ref>. The chief differences are related to the more general nature of resource containers. Processor capacity reserves and activities are real-time abstractions and are thus more complex to implement than resource containers.
Reference: [21] <institution> Microsoft Corporation ISAPI Overview. </institution> <address> http://ww w.microsoft.com/msdn/sdk/platforms/doc/sdk /internet/src/isapimrg.htm. </address>
Reference-contexts: Examples include CGI [9] and FastCGI [16]. The earlier interface, CGI, creates a new process to handle each dynamic document request. The newer FastCGI allows persistent dynamic document server processes. Microsoft and Netscape have also defined new library interfaces <ref> [21, 34] </ref> to allow the construction of third-party components that can reside in the main server process, when fault isolation is not an issue. Internet servers are moving towards an architecture where a small set of processes implement the functionality of the server.
Reference: [22] <author> M. B. Jones, P. J. Leach, R. P. Draves, and J. S. Bar-rera. </author> <title> Modular real-time resource management in the Rialto operating system. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems (HotOS-V), </booktitle> <address> Orcas Island, WA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: At a superficial level, the functionality provided by resource containers is similar to that provided by a number of operating system abstractions developed in the context of multimedia and real-time operating systems. These include the processor capacity reserves of Mercer et. al. [28], the activities <ref> [22] </ref> of Rialto, the migrating threads of Mach [17] and AlphaOS [13], and the shuttles of Spring [20]. The chief differences are related to the more general nature of resource containers. Processor capacity reserves and activities are real-time abstractions and are thus more complex to implement than resource containers.
Reference: [23] <author> M. F. Kaashoek, D. R. Engler, G. R. Ganger, H. Briceno, R. Hunt, D. Mazieres, T. Pinckney, R. Grimm, J. Janotti, and K. Mackenzie. </author> <title> Application performance and flexibility on Exokernel systems. </title> <booktitle> In Proceedings of the Sizteenth Symposium on Operating System Principles, </booktitle> <address> Saint-Malo, France, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Resource containers have some properties that makes them similar to a number of resource management mechanisms that have been developed in the context of some recent experimental operating systems <ref> [23, 31] </ref>. The key factors that distinguish the resource container abstraction from these mechanisms are its generality and direct applicability to current, general purpose operating systems. <p> Scout is a special-purpose operating system built from scratch to efficiently support network appliances. The path abstraction is not available in general-purpose operating systems, and there has been no attempt to integrate paths into current operating system interfaces. Kaashoek et. al. <ref> [23, 24] </ref> advocate a customized operating system tailored specifically for servers. In a server operating system based on the Exokernel, the application controls essentially all of the protocol stack, including the device drivers, through a combination of library code and a novel kernel architecture.
Reference: [24] <author> M. F. Kaashoek, D. R. Engler, G. R. Ganger, and D. A. Wallach. </author> <title> Server Operating Systems. </title> <booktitle> In 1996 SIGOPS European Workshop, </booktitle> <address> Connemara, Ireland, </address> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid [11, 39], Zeus [44], thttpd [42] and several research servers <ref> [5, 24, 36] </ref> all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread. The thread scheduler is responsible for time-sharing the CPU between the various server threads. <p> Scout is a special-purpose operating system built from scratch to efficiently support network appliances. The path abstraction is not available in general-purpose operating systems, and there has been no attempt to integrate paths into current operating system interfaces. Kaashoek et. al. <ref> [23, 24] </ref> advocate a customized operating system tailored specifically for servers. In a server operating system based on the Exokernel, the application controls essentially all of the protocol stack, including the device drivers, through a combination of library code and a novel kernel architecture.
Reference: [25] <author> C. Maltzahn, K. J. Richardson, and D. Grunwald. </author> <title> Performance Issues of Enterprise Level Web Proxies. </title> <booktitle> In Proceedings of the ACM SIGMETRICS '97 Conference, </booktitle> <address> Seattle, WA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems <ref> [6, 18, 25] </ref>. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. For instance, the scalability of UNIX-based event-driven servers is limited by the inherently linear-time select () system call [6].
Reference: [26] <author> R. E. McGrath. </author> <title> Performance of Several HTTP Demons on an HP 735 Workstation. </title> <address> http://www. ncsa.uiuc.edu/InformationServers/Performance/ V1.4/report.html, </address> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: The application has no control over the consumption of many system resources, such as kernel memory, that the kernel manages on behalf of the application. This makes it difficult or impossible to prevent low-priority clients from hogging resources. Researchers have been aware of these problems for several years <ref> [26, 29] </ref>, and together with system vendors have devoted much effort to improving Internet server performance.
Reference: [27] <author> P. E. McKenney and K. F. Dove. </author> <title> Efficient demul-tiplexing of incoming tcp packets. </title> <booktitle> In Proceedings of the SIGCOMM '92 Conference, </booktitle> <pages> pages 269280, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Some of this has been as simple as tuning kernel parameters; in other cases it has been necessary to improve the implementation of some kernel features, such as the protocol control block (PCB) lookup algorithm in BSD-based systems <ref> [27, 38] </ref>, and the select () system call [6]. Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead.
Reference: [28] <author> C. W. Mercer, S. Savage, and H. Tokuda. </author> <title> Processor Capacity Reserves for Multimedia Operating Systems. </title> <booktitle> In Proceedings of the IEEE International Conference on Multimedia Computing and Systems, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: At a superficial level, the functionality provided by resource containers is similar to that provided by a number of operating system abstractions developed in the context of multimedia and real-time operating systems. These include the processor capacity reserves of Mercer et. al. <ref> [28] </ref>, the activities [22] of Rialto, the migrating threads of Mach [17] and AlphaOS [13], and the shuttles of Spring [20]. The chief differences are related to the more general nature of resource containers.
Reference: [29] <author> J. C. Mogul. </author> <title> Operating system support for busy internet servers. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems (HotOS-V), </booktitle> <address> Orcas Island, WA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The application has no control over the consumption of many system resources, such as kernel memory, that the kernel manages on behalf of the application. This makes it difficult or impossible to prevent low-priority clients from hogging resources. Researchers have been aware of these problems for several years <ref> [26, 29] </ref>, and together with system vendors have devoted much effort to improving Internet server performance.
Reference: [30] <author> J. C. Mogul and K. K. Ramakrishnan. </author> <title> Eliminat--ing receive livelock in an interrupt-driven kernel. </title> <booktitle> In Proc. of the 1996 Usenix Technical Conference, </booktitle> <pages> pages 99111, </pages> <year> 1996. </year>
Reference-contexts: Moreover, software interrupts have strictly higher priority than the execution of any user-level code. This can lead to scheduling anomalies, decreased throughput, and starvation or livelock <ref> [14, 30] </ref>. This is particularly important for servers because they are, by their nature, particularly network intensive. The LRP network subsystem architecture [14] was de signed to address these problems by more closely follow-ing the process-centric model.
Reference: [31] <author> D. Mosberger and L. L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proc. 2nd Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Resource containers have some properties that makes them similar to a number of resource management mechanisms that have been developed in the context of some recent experimental operating systems <ref> [23, 31] </ref>. The key factors that distinguish the resource container abstraction from these mechanisms are its generality and direct applicability to current, general purpose operating systems. <p> We will discuss these mechanisms, and their relationship to resource containers, in some detail below. The Scout operating system <ref> [31] </ref> has explicit support for a path abstraction, which allows an application to control resource consumption for a given communication path at all levels of the system. Paths are similar to resource containers; however, resource containers are more general as they can encompass several otherwise unconnectable paths.
Reference: [32] <author> E. Nahum, T. Barzilai, and D. Kandlur. </author> <title> Evaluating High Performance Socket APIs on AIX. </title> <note> submitted for publication, </note> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: We look at how such applications need to control scheduling and kernel resource consumption. We then describe new application programming interfaces (APIs) to support these require-ments. This paper does not address issues related to efficient operating system support for data movement. Other research has addressed those issues <ref> [2, 32, 36, 40] </ref>. 2 Evolution of Internet server execution models We begin by describing the evolution of Internet server execution models. To be concrete, we focus on Web servers. However, most of the issues we discuss apply to other Internet servers such as proxy, mail, file, and directory servers.
Reference: [33] <institution> NCSA httpd. http://hoohoo.ncsa.uiuc.edu/. </institution>
Reference-contexts: The earliest Web servers forked a new process to handle each HTTP connection, following the classical UNIX model. The forking overhead quickly became a problem, and subsequent servers (such as the NCSA httpd <ref> [33] </ref>) used a set of pre-forked processes. In this model, a master server process accepts new connections and passes them to the pre-forked servers, using UNIX domain sockets. The next innovation eliminates the master process. Instead, each pre-forked server calls accept () directly to accept new connection requests.
Reference: [34] <editor> Netscape Server API. </editor> <address> http://www.netscape.com/ newsref/std/server api.html. </address>
Reference-contexts: Examples include CGI [9] and FastCGI [16]. The earlier interface, CGI, creates a new process to handle each dynamic document request. The newer FastCGI allows persistent dynamic document server processes. Microsoft and Netscape have also defined new library interfaces <ref> [21, 34] </ref> to allow the construction of third-party components that can reside in the main server process, when fault isolation is not an issue. Internet servers are moving towards an architecture where a small set of processes implement the functionality of the server.
Reference: [35] <author> J. Ousterhout. </author> <title> Why Threads Are A Bad Idea (for most purposes). </title> <booktitle> Invited talk at the 1996 USENIX Technical Conference. </booktitle> <address> http://www.scriptics.com/ people/john.ousterhout/threads.ps. </address>
Reference-contexts: We then propose improved support for event-driven servers. While the choice between execution models remains complex, in the limit a good event-driven implementation might perform better than a good thread-based implementation. We base this expectation on reasons given by Ousterhout <ref> [35] </ref>, including the necessity for locking and context-switching in a thread-based system. Also, an event-based program can use a single execution stack; a thread-based program uses multiple stacks, putting more pressure on the data caches and TLB.
Reference: [36] <author> V. S. Pai, P. Druschel, and W. Zwaenepoel. IO-Lite: </author> <title> A unified I/O buffering and caching system. </title> <type> Technical Report TR97-294, </type> <institution> Rice University, CS Dept., Houston, TX, </institution> <year> 1997. </year>
Reference-contexts: We look at how such applications need to control scheduling and kernel resource consumption. We then describe new application programming interfaces (APIs) to support these require-ments. This paper does not address issues related to efficient operating system support for data movement. Other research has addressed those issues <ref> [2, 32, 36, 40] </ref>. 2 Evolution of Internet server execution models We begin by describing the evolution of Internet server execution models. To be concrete, we focus on Web servers. However, most of the issues we discuss apply to other Internet servers such as proxy, mail, file, and directory servers. <p> When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid [11, 39], Zeus [44], thttpd [42] and several research servers <ref> [5, 24, 36] </ref> all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread. The thread scheduler is responsible for time-sharing the CPU between the various server threads. <p> Sometimes, however, the situation resembles a multi-process scenario. This happens, for example, when the main server process forks off a CGI script to handle a dynamic document request, or when it retrieves a dynamic document from a persistent CGI server <ref> [36] </ref>. In both cases, the desired unit of resource management differs from a process. This breakdown of equivalence between a protection domain and a resource container in server systems provides the motivation to develop an explicit resource container abstraction.
Reference: [37] <author> Y. Rekhter and T. Li. </author> <title> An Architecture for IP Address Allocation with CIDR. </title> <type> RFC 1518, </type> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: To support this, we define a new sockaddr namespace that includes not only the local port number and Internet address, but also a filter specifying a set of foreign addresses. The filter is specified as a tuple consisting of a template address and a CIDR network mask <ref> [37] </ref>. The server application may then use the bind () system call to bind multiple server sockets, each with the same &lt;local-address, local-port&gt; tuple but with a different &lt;template-address, CIDR-mask&gt; filter.
Reference: [38] <institution> Solaris 2 TCP/IP. </institution> <address> http://www.sun.com/sunsoft /solaris/networking/tcpip.html. </address>
Reference-contexts: Some of this has been as simple as tuning kernel parameters; in other cases it has been necessary to improve the implementation of some kernel features, such as the protocol control block (PCB) lookup algorithm in BSD-based systems <ref> [27, 38] </ref>, and the select () system call [6]. Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers [11, 39, 42, 44] use a single-process event-driven architecture, to reduce context-switching overhead.
Reference: [39] <author> Squid. </author> <note> http://squid.nlanr.net/Squid/. </note>
Reference-contexts: Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers <ref> [11, 39, 42, 44] </ref> use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems [6, 18, 25]. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. <p> When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid <ref> [11, 39] </ref>, Zeus [44], thttpd [42] and several research servers [5, 24, 36] all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread.
Reference: [40] <author> M. N. Thadani and Y. A. Khalidi. </author> <title> An efficient zero-copy I/O framework for UNIX. </title> <type> Technical Report SMLI TR-95-39, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: We look at how such applications need to control scheduling and kernel resource consumption. We then describe new application programming interfaces (APIs) to support these require-ments. This paper does not address issues related to efficient operating system support for data movement. Other research has addressed those issues <ref> [2, 32, 36, 40] </ref>. 2 Evolution of Internet server execution models We begin by describing the evolution of Internet server execution models. To be concrete, we focus on Web servers. However, most of the issues we discuss apply to other Internet servers such as proxy, mail, file, and directory servers.
Reference: [41] <institution> The Standard Performance Evaluation Corporation. SPECweb96 Results. </institution> <address> http://www.specbench.org /osg/web96/results/, </address> <month> Apr. </month> <year> 1998. </year> <note> [42] thttpd. http://www.acme.com/software/thttpd/. </note>
Reference-contexts: This prevents any progress, even on unrelated connections that could be handled without additional I/O. Although event-driven servers on fast SMP hardware today can otherwise handle at least 7214 requests/second <ref> [41] </ref> (i.e. a request every 139 s), even moderate amounts of disk I/O can degrade performance to disk speed, i.e. 60-120 requests/sec. Some system vendors have implemented the POSIX aio interface for non-blocking disk I/O.
Reference: [43] <author> B. Totty. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: Excessive synchronization overhead can also be a problem. It is because of these overheads that some servers, such as the Inktomi traffic server, use a hybrid control model <ref> [43] </ref>. Such servers use a moderate number of threads, each of which is an event-driven state machine. This gets around some problems of pure event-driven servers, such as blocking disk I/O system calls, while still keeping thread management overhead low.
Reference: [44] <author> Zeus. </author> <note> http://www.zeus.co.uk/. </note>
Reference-contexts: Application writers have also worked to make more efficient use of existing operating system services. While early servers used a process-per-connection approach, recent servers <ref> [11, 39, 42, 44] </ref> use a single-process event-driven architecture, to reduce context-switching overhead. Even these servers have some scalability problems [6, 18, 25]. The work cited above has generally assumed the use of the existing system-call interface, which limits the degree to which performance problems can be addressed. <p> When select () delivers one or more events, the server's main loop invokes handlers for each ready connection. Squid [11, 39], Zeus <ref> [44] </ref>, thttpd [42] and several research servers [5, 24, 36] all use an event-driven architecture. Another alternative is the single-process multi-threaded architecture. In a simple multi-threaded server, each connection is assigned to a dedicated thread. The thread scheduler is responsible for time-sharing the CPU between the various server threads.
References-found: 43

