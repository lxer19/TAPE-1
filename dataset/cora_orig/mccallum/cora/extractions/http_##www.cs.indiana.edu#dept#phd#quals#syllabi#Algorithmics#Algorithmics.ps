URL: http://www.cs.indiana.edu/dept/phd/quals/syllabi/Algorithmics/Algorithmics.ps
Refering-URL: http://www.cs.indiana.edu/dept/phd/quals/syllabi/Algorithmics/
Root-URL: http://www.cs.indiana.edu
Title: Algorithmics Syllabus Design and Analysis of Algorithms and Data Structures 2.1 Algorithmics background 2. Data
Date: 2, 3.1-2, 3.4-6.  
Note: 2 Topics  [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis (a) Asymptotic notation: [4] Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter  
Abstract: 1 Description This exam tests your knowledge of fundamental concepts in the design and analysis of algorithms and data structures. Our understanding is that you have had strong data structures and algorithms courses in your undergraduate training or that you have taken the first-year graduate course in algorithms at Indiana University. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1974. </year>
Reference-contexts: Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, <ref> [1] </ref> Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: [4] Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. <p> Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: <ref> [1] </ref> Chapter 10.
Reference: [2] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1983. </year>
Reference-contexts: Basic data structures (lists, stacks, queues and trees): [3] Chapters 3, 4. 2. Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) <ref> [2] </ref> Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. <p> Mathematical notation and techniques: (a) Asymptotic notation: [4] Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: <ref> [2] </ref> Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. <p> Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: <ref> [2] </ref> Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. <p> Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: <ref> [2] </ref> Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10. <p> Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: <ref> [2] </ref> Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10.
Reference: [3] <author> H.R. Lewis and L. Denenberg. </author> <title> Data Structures & Their Algorithms, </title> <publisher> HarperCollins Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Our understanding is that you have had strong data structures and algorithms courses in your undergraduate training or that you have taken the first-year graduate course in algorithms at Indiana University. 2 Topics 2.1 Algorithmics background 1. Basic data structures (lists, stacks, queues and trees): <ref> [3] </ref> Chapters 3, 4. 2. Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. <p> Basic data structures (lists, stacks, queues and trees): <ref> [3] </ref> Chapters 3, 4. 2. Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms <p> Basic data structures (lists, stacks, queues and trees): <ref> [3] </ref> Chapters 3, 4. 2. Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. <p> data structures (lists, stacks, queues and trees): <ref> [3] </ref> Chapters 3, 4. 2. Data structures for sets (a) Hashing (including extendible hashing): [3] Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. <p> Data structures for sets (a) Hashing (including extendible hashing): <ref> [3] </ref> Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: [4] Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. <p> Hashing (including extendible hashing): <ref> [3] </ref> Chapter 8. (b) Search trees (including AVL trees and B-trees) [2] Chapters 4 and 5. (c) Self-organizing lists and trees: [3] Chapters 6.2 and 7.3. 3. String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: [4] Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3.
Reference: [4] <author> P.W. Purdom and C.A. Brown. </author> <title> The Analysis of Algorithms, </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1985. </year>
Reference-contexts: String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: <ref> [4] </ref> Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] <p> String matching: [3] Chapter 5.5. 4. Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: <ref> [4] </ref> Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter <p> Graphs and graph algorithms: [3] Chapter 12, [1] Chapter 5. 5. Memory management: [3] Chapter 10. 2.2 Algorithms analysis 1. Mathematical notation and techniques: (a) Asymptotic notation: <ref> [4] </ref> Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. <p> notation and techniques: (a) Asymptotic notation: <ref> [4] </ref> Chapter 1.10, 4.2. (b) Summing series, Products and Binomials: [4] Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. <p> 4.2. (b) Summing series, Products and Binomials: <ref> [4] </ref> Chapter 2, 3.1-2, 3.4-6. (c) Recurrence relations: [4] Chapter 5. 2. Algoritmic analysis techniques: (a) Worst case asymptotic analysis (b) Average case analysis 1 3. Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees [5]. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6.
Reference: [5] <author> G.J.E. Rawlins. </author> <note> Compared to What? Computer Science Press, 1991. 2 </note>
Reference-contexts: Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees <ref> [5] </ref>. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10. <p> Algorithm design techniques: (a) Divide-and-conquer: [2] Chapter 10.1; [4] Chapter 5.2, 5.5. (b) Backtracking: [2] Chapter 10.4; [4] Chapter 4.3.1. (c) Dynamic programming: [2] Chapter 10.2. (d) Greedy: [2] Chapter 10.3, 10.5. 4. Basic lower-bound techniques: (a) Decision trees <ref> [5] </ref>. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10. <p> Basic lower-bound techniques: (a) Decision trees <ref> [5] </ref>. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10. <p> Basic lower-bound techniques: (a) Decision trees <ref> [5] </ref>. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10. <p> Basic lower-bound techniques: (a) Decision trees <ref> [5] </ref>. (b) Adversary arguments [5]. 5. Algorithms for searching, selecting, and sorting: (a) Searching: [5] Chapter 2. (b) Selecting: [5] Chapter 3. (c) Sorting: [5] Chapter 4. 6. Introduction to NP-complete theory: [1] Chapter 10.
References-found: 5

