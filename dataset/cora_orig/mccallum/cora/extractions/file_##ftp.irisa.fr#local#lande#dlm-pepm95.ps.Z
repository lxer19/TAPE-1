URL: file://ftp.irisa.fr/local/lande/dlm-pepm95.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: lemetayer@irisa.fr  
Title: Proving properties of programs defined over recursive data structures  
Author: Daniel Le Metayer Irisa/Inria, 
Address: 35042 Rennes, France  
Affiliation: Campus de Beaulieu,  
Abstract: We present a technique for the mechanical proof of correctness properties of programs. We define a language of properties over recursive data structures and an inference system to assign properties to programs. In order to be able to design a tractable inference algorithm, we impose restrictions on both the programming language and the language of properties. We show that these restrictions do not preclude the treatment of interesting programs and properties. As an example, our analyser is able to prove automatically that a sort program returns a list of non-increasing values. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer and J. S. Moore, </author> <title> A computational logic handbook, </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: P [[P ]] e d g ? P [[8 r P ]] e d = f (d; [d 0 ; d 1 ; : : : ; d n ]) j (d 0 = void or (d; d 0 ) 2 P [[P ]] e d ) and 8i 2 <ref> [1; n] </ref>:(d; d i ) 2 P [[8 r P ]] e d g ? P [[8 l P ]] e d = f ([d 0 ; d 1 ; : : : ; d n ]; d) j (d 0 = void or (d 0 ; d) 2 P [[P <p> r P ]] e d g ? P [[8 l P ]] e d = f ([d 0 ; d 1 ; : : : ; d n ]; d) j (d 0 = void or (d 0 ; d) 2 P [[P ]] e d ) and 8i 2 <ref> [1; n] </ref>:(d i ; d) 2 P [[8 l P ]] e d g ? 0 ; d 0 n ]) j (d 0 = void or d 0 0 = void or (d 0 ; d 0 0 ) 2 P [[P ]] e d ) and (d 0 = <p> 2 P [[8 l P ]] e d g ? 0 ; d 0 n ]) j (d 0 = void or d 0 0 = void or (d 0 ; d 0 0 ) 2 P [[P ]] e d ) and (d 0 = void or 8i 2 <ref> [1; n] </ref>:(d 0 ; d 0 i ) 2 P [[8 r P ]] e d ) and 0 = void or 8i 2 [1; n]:(d i ; d 0 0 ) 2 P [[8 l P ]] e d ) and j ) 2 P [[3P ]] e d g <p> 0 = void or (d 0 ; d 0 0 ) 2 P [[P ]] e d ) and (d 0 = void or 8i 2 <ref> [1; n] </ref>:(d 0 ; d 0 i ) 2 P [[8 r P ]] e d ) and 0 = void or 8i 2 [1; n]:(d i ; d 0 0 ) 2 P [[8 l P ]] e d ) and j ) 2 P [[3P ]] e d g ? P [[8P ]] e d = f [d 0 ; d 1 ; : : : ; d n ] j (d 0 <p> ) and j ) 2 P [[3P ]] e d g ? P [[8P ]] e d = f [d 0 ; d 1 ; : : : ; d n ] j (d 0 = void or d 0 2 P [[P ]] e d ) and 8i 2 <ref> [1; n] </ref>:d i 2 P [[8P ]] e d g ? P [[rP ]] e d = f [d 0 ; d 1 ; : : : ; d n ] j (d 0 = void or 8i 2 [1; n]:(d 0 ; d i ) 2 P [[8 r P <p> 0 2 P [[P ]] e d ) and 8i 2 <ref> [1; n] </ref>:d i 2 P [[8P ]] e d g ? P [[rP ]] e d = f [d 0 ; d 1 ; : : : ; d n ] j (d 0 = void or 8i 2 [1; n]:(d 0 ; d i ) 2 P [[8 r P ]] e d ) and 8i 2 [1; n]:d i 2 P [[rP ]] e d )g ? P 1 ) P 2 P 2 ) P 3 P 1 ) P 2 P 2 ) P 1 P <p> d g ? P [[rP ]] e d = f [d 0 ; d 1 ; : : : ; d n ] j (d 0 = void or 8i 2 <ref> [1; n] </ref>:(d 0 ; d i ) 2 P [[8 r P ]] e d ) and 8i 2 [1; n]:d i 2 P [[rP ]] e d )g ? P 1 ) P 2 P 2 ) P 3 P 1 ) P 2 P 2 ) P 1 P 1 , P 2 P 1 , P 2 P 1 ) P 2 P 1 ) P 3 <p> E 2 ); (P 1 fi P 2 )) &gt; 1 2 F ` a ((E 1 ; E 2 ); P ) &gt; E 2 ) &gt; F ` a (E 0 ; P ) &gt; 0 F ` a (E i ; 8P ) &gt; i 8i 2 <ref> [1; n] </ref> V 7 Space considerations prevent us from providing the deriva-tion steps of the proof that sort returns a list of non-increasing values. We just outline the proof here. The initial goal is sort : true ! rgeq. <p> Existing tools for proving program correctness can be classified in two main categories: 1. Provers which represent properties as programs and proofs as program transformations. The transformations themselves can be described in different ways. Boyer and Moore's theorem prover <ref> [1] </ref> contains a number of heuristics and inference rules (like structural induction) and relies on the user to provide intermediate lemmas. In LCF [6] and its descendants, the user can define proof strategies in a proof meta-language. <p> The most striking departure of our technique from most of these tools is the complete mechanisation that we can achieve in return for a lower level of generality. These works are based on very expressive logics and require a prover involving a complex strategy (like <ref> [1] </ref> which may even enter loops when performing simplifications) or a strong interaction with the user. In contrast, we impose restrictions on the form of properties and programs to be able to carry out proofs without any assistance from the user. We believe that both approaches are complementary.
Reference: [2] <author> T. Coquand and G. Huet, </author> <title> The calculus of constructions, </title> <journal> Information and Computation, </journal> <volume> 76(2/3), </volume> <year> 1988, </year> <pages> pp. 95-120. </pages>
Reference-contexts: Lawall [11] proposes to use partial evaluation to mechanise the rewriting task in proofs by structural induction. 2. Provers like <ref> [2, 3] </ref> which represent properties as types in a generalised type system and proofs as type checking. The initial motivation for this trend of work was theoretical since the theories were originally developed to serve as a foundation of constructive mathematics.
Reference: [3] <author> T. Coquand, B. Nordstrom, J. M. Smith and B. von Sydow, </author> <title> Type theory and programming, Programming Methodology Group, </title> <institution> University of Goteborg and Chalmers University of Technology, </institution> <note> Research Report 81, </note> <year> 1994. </year>
Reference-contexts: Lawall [11] proposes to use partial evaluation to mechanise the rewriting task in proofs by structural induction. 2. Provers like <ref> [2, 3] </ref> which represent properties as types in a generalised type system and proofs as type checking. The initial motivation for this trend of work was theoretical since the theories were originally developed to serve as a foundation of constructive mathematics.
Reference: [4] <author> P. Cousot and R. Cousot, </author> <title> Static determination of dynamic properties of recursive procedures, </title> <editor> in E. J. Neuhold (ed.), </editor> <booktitle> Formal Description of Programming Concepts, </booktitle> <publisher> North-Holland, </publisher> <year> 1977, </year> <pages> pp. 237-277. </pages>
Reference: [5] <author> J. V. Guttag and J. J. Horning, </author> <title> Larch: languages and tools for formal specification, </title> <publisher> Springer Verlag, Texts and Monographs in Computer Science, </publisher> <year> 1993. </year>
Reference-contexts: Boyer and Moore's theorem prover [1] contains a number of heuristics and inference rules (like structural induction) and relies on the user to provide intermediate lemmas. In LCF [6] and its descendants, the user can define proof strategies in a proof meta-language. Other systems like Larch <ref> [5] </ref> use equational term rewriting to carry out transformations (in fact Larch also includes inference rules like structural induction and induction-less induction which is based on a consistency check using a completion procedure).
Reference: [6] <author> M. Gordon, R. Milner and C. </author> <title> Wadsworth, </title> <publisher> Edinburgh LCF, LNCS 78, Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Provers which represent properties as programs and proofs as program transformations. The transformations themselves can be described in different ways. Boyer and Moore's theorem prover [1] contains a number of heuristics and inference rules (like structural induction) and relies on the user to provide intermediate lemmas. In LCF <ref> [6] </ref> and its descendants, the user can define proof strategies in a proof meta-language.
Reference: [7] <author> C. L. Hankin and D. Le Metayer, </author> <title> Deriving algorithms from type inference systems: application to strictness analysis, </title> <booktitle> in Proceedings of POPL'94, </booktitle> <publisher> ACM Press, </publisher> <year> 1994, </year> <pages> pp. 202-212. </pages>

Reference: [9] <author> T. P. Jensen, </author> <title> Strictness analysis in logical form, </title> <booktitle> in Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS 523, Springer Verlag, </publisher> <year> 1991, </year> <pages> pp. 352-366. </pages>
Reference: [10] <author> T. P. Jensen, </author> <title> Abstract interpretation over algebraic data types, </title> <booktitle> in Proceedings of the 1994 int. Conference on Computer Languages, IEEE, </booktitle> <year> 1994, </year> <pages> 265-276. </pages>
Reference-contexts: Backwards analysis of functional programs has been studied in the past mainly in the context of strictness analysis of lazy functional programs [13]. [14] also involves rules for decomposing properties on lists into properties on their components. <ref> [10] </ref> presents a notion of uniform strictness properties on recursive data structures which is similar to the 8 and 9 properties in our logic. The work presented here departs from these analyses in several ways.
Reference: [11] <author> J. L. Lawall, </author> <title> Proofs by structural induction using partial evaluation, </title> <booktitle> in Proceedings of the 1993 PEPM Symp., ACM, </booktitle> <pages> pp. 155-166. </pages>
Reference-contexts: Other systems like Larch [5] use equational term rewriting to carry out transformations (in fact Larch also includes inference rules like structural induction and induction-less induction which is based on a consistency check using a completion procedure). Lawall <ref> [11] </ref> proposes to use partial evaluation to mechanise the rewriting task in proofs by structural induction. 2. Provers like [2, 3] which represent properties as types in a generalised type system and proofs as type checking.
Reference: [12] <author> R. Milner, </author> <title> A theory of type polymorphism in programming, </title> <journal> Journal of Comp. Syst. Sci., </journal> <volume> 17, </volume> <year> 1978, </year> <pages> pp. 348-375. </pages>
Reference: [13] <author> P. Wadler and J. Hughes, </author> <title> Projections for Strictness Analysis, </title> <booktitle> in Proceedings of the 1987 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS 274, Springer Verlag, </publisher> <year> 1987, </year> <pages> pp. 385-407. </pages>
Reference-contexts: Backwards analysis of functional programs has been studied in the past mainly in the context of strictness analysis of lazy functional programs <ref> [13] </ref>. [14] also involves rules for decomposing properties on lists into properties on their components. [10] presents a notion of uniform strictness properties on recursive data structures which is similar to the 8 and 9 properties in our logic. The work presented here departs from these analyses in several ways.

References-found: 12

