URL: http://www.cs.washington.edu/homes/savage/papers/sosp95.ps
Refering-URL: http://www.cs.washington.edu/homes/savage/
Root-URL: 
Title: Extensibility, Safety and Performance in the SPIN Operating System  
Author: Brian N. Bershad Stefan Savage Przemysaw Pardyak Emin Gun Sirer Marc E. Fiuczynski David Becker Craig Chambers Susan Eggers 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: This paper describes the motivation, architecture and performance of SPIN, an extensible operating system. SPIN provides an extension infrastructure, together with a core set of extensible services, that allow applications to safely change the operating system's interface and implementation. Extensions allow an application to specialize the underlying operating system in order to achieve a particular level of performance and functionality. SPIN uses language and link-time mechanisms to inexpensively export fine-grained interfaces to operating system services. Extensions are written in a type safe language, and are dynamically linked into the operating system kernel. This approach offers extensions rapid access to system services, while protecting the operating system code executing within the kernel address space. SPIN and its extensions are written in Modula-3 and run on DEC Alpha workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [Abrossimov et al. 89] <author> Abrossimov, V., Rozier, M., and Shapiro, M. </author> <title> Generic Virtual Memory Management for Operating System Kernels. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 123-136, </pages> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Waldspurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Anderson et al. 91] <author> Anderson, T. E., Levy, H. M., Bershad, B. N., and La-zowska, E. D. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 108-120, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The FORE cards use programmed I/O and can maximally deliver only about 53Mb/sec between a pair of hosts [Brus-toloni & Bershad 93]. We avoid comparisons with operating systems running on different hardware as benchmarks tend to scale poorly for a variety of architectural reasons <ref> [Anderson et al. 91] </ref>. All measurements are taken while the operating systems run in single-user mode. 5.1 System components SPIN runs as a standalone kernel on DEC Alpha workstations. The system consists of five main components, sys, core, rt, lib and sal, that support different classes of service. <p> For example, concurrent and generational garbage collectors can use write faults to maintain invariants or collect reference information. A longstanding problem with fault-based strategies has been the overhead of handling a page fault in an application <ref> [Thekkath & Levy 94, Anderson et al. 91] </ref>. There are two sources of this overhead. First, handling each fault in a user application requires crossing the user/kernel boundary several times. Second, conventional systems provide quite general exception interfaces that can perform many functions at once.
Reference: [Anderson et al. 92] <author> Anderson, T. E., Bershad, B. N., Lazowska, E. D., and Levy, H. M. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference: [Appel & Li 91] <author> Appel, W. and Li, K. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: If it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions can use these events to define services, such as demand paging, copy-on-write [Rashid et al. 87], distributed shared memory [Carter et al. 91], or concurrent garbage collection <ref> [Appel & Li 91] </ref>. The physical page service may at any time reclaim physical memory by raising the PhysAddr.Reclaim event. The interface allows the handler for this event to volunteer an alternative page, which may be of less importance than the candidate page. <p> Virtual memory Applications can exploit the virtual memory fault path to extend system services <ref> [Appel & Li 91] </ref>. For example, concurrent and generational garbage collectors can use write faults to maintain invariants or collect reference information. A longstanding problem with fault-based strategies has been the overhead of handling a page fault in an application [Thekkath & Levy 94, Anderson et al. 91]. <p> SPIN allows applications to define specialized fault handling extensions to avoid user/kernel boundary crossings and implement precisely the functionality that is required. Table 4 shows the time to execute several commonly referenced virtual memory benchmarks <ref> [Appel & Li 91, Engler et al. 95] </ref>. The line labeled Dirty in the table measures the time for an application to query the status of a particular virtual page. Neither DEC OSF/1 nor Mach provide this facility.
Reference: [Bala et al. 94] <author> Bala, K., Kaashoek, M. F., and Weihl, W. E. </author> <title> Software Prefetching and Caching for Translation Lookaside Buffers. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 243-253, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries <ref> [Bala et al. 94] </ref>, entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications. SPIN's virtual memory system provides such control, and is enabled by the system's low-overhead invocation and protection services.
Reference: [Balakrishnan et al. 95] <author> Balakrishnan, H., Seshan, S., Amir, E., and Katz., R. H. </author> <title> Improving TCP/IP Performance over Wireless Networks. </title> <booktitle> In Proceedings of the First ACM Conference on Mobile Computing and Networking, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: The maximum usable Ethernet and ATM bandwidths between a pair of hosts are roughly 9 Mb/sec and 53Mb/sec. Protocol forwarding SPIN's extension architecture can be used to provide protocol functionality not generally available in conventional systems. For example, some TCP redirection protocols <ref> [Balakrishnan et al. 95] </ref> that have otherwise required kernel modifications can be straightforwardly defined by an application as a SPIN extension. A forwarding protocol can also be used to load balance service requests across multiple servers.
Reference: [Barrera 91] <author> Barrera, J. S. </author> <title> A Fast Mach Network IPC Implementation. </title> <booktitle> In Proceedings of the Second USENIX Mach Symposium, </booktitle> <pages> pages 1-11, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Waldspurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Bartlett 88] <author> Bartlett, J. F. </author> <title> Compacting Garbage Collection with Ambiguous Roots. </title> <type> Technical Report WRL-TR-88-2, </type> <institution> Digital Equipment Corporation Western Research Labs, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: As previously mentioned, memory management schemes that allow extensions to return objects to the system heap are unsafe because a rogue client can violate the type system by retaining a reference to a freed object. SPIN uses a trace-based, mostly-copying, garbage collector <ref> [Bartlett 88] </ref> to safely reclaim memory resources. The collector serves as a safety net for untrusted extensions, and ensures that resources released by an extension, either through inaction or as a result of prema-ture termination, are eventually reclaimed.
Reference: [Berners-Lee et al. 94] <author> Berners-Lee, T., Cailliau, R., Luotonen, A., Nielsen, H. F., and Secretr, A. </author> <title> The World-Wide Web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Ovals represent events raised to route control to handlers, which are represented by boxes. Handlers implement the protocol corresponding to their label. the HTTP extension implements the HyperText Transport Protocol <ref> [Berners-Lee et al. 94] </ref> directly within the kernel, enabling a server to respond quickly to HTTP requests by splicing together the protocol stack and the local file system.
Reference: [Bershad 93] <author> Bershad, B. N. </author> <title> Practical Considerations for Non-Blocking Concurrent Objects. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-274, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1993. </year>
Reference: [Bershad et al. 90] <author> Bershad, B. N., Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference: [Bershad et al. 92a] <author> Bershad, B. N., Draves, R. P., and Forin, A. </author> <title> Using Microbenchmarks to Evaluate System Performance. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 148-153, </pages> <address> Key Biscayne, FL, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: They define the bounds of system performance and provide a framework for understanding larger operations. Times presented in this section, measured with the Alpha's internal cycle counter, are the average of a large number of iterations, and may therefore be overly optimistic regarding cache effects <ref> [Bershad et al. 92a] </ref>.
Reference: [Bershad et al. 92b] <author> Bershad, B. N., Redell, D. D., and Ellis, J. R. </author> <title> Fast Mutual Exclusion for Uniprocessors. </title> <booktitle> In Proceedings of the Fifth International Conferenceon Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 223-233, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference: [Black et al. 92] <editor> Black, D. L. et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, pages 11-30,Seattle, </booktitle> <address> WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Unlike other operating systems based on capabilities, which rely on special-purpose hardware [Carter et al. 94], virtual memory mechanisms [Wulf et al. 81], probabilistic protection [Engler et al. 94], or protected message channels <ref> [Black et al. 92] </ref>, SPIN implements capabilities directly using pointers, which are supported by the language. A pointer is a reference to a block of memory whose type is declared within an interface. Figure 1 demonstrates the definition and use of interfaces and capabilities (pointers) in SPIN.
Reference: [Bricker et al. 91] <author> Bricker, A., Gien, M., Guillemont, M., Lipkis, J., Orr, D., and Rozier, M. </author> <title> A New Look at Micro-kernel-basedUNIX Operating Systems: Lessons in Performance and Compatibility. </title> <booktitle> In Proceedings of the EurOpen Spring'91 Conference,Tromsoe, </booktitle> <address> Norway, </address> <month> May </month> <year> 1991. </year>
Reference: [Brockschmidt 94] <author> Brockschmidt, K. </author> <title> Inside OLE 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: A module that exports an interface explicitly creates a domain for its interface, and exports the domain through an in-kernel nameserver. The exported name of the interface, which can be specified within the interface, is used to coordinate the export and import as in many RPC systems <ref> [Schroeder & Burrows 90, Brockschmidt 94] </ref>. The constant Console.InterfaceName in Figure 1 defines a name that exporters and importers can use to uniquely identify a particular version of a service. Some interfaces, such as those for devices, restrict access at the time of the import.
Reference: [Brustoloni & Bershad 93] <author> Brustoloni, J. C. and Bershad, B. N. </author> <title> Simple Protocol Processing for High-Bandwidth Low-Latency Networking. </title> <type> Technical Report CMU-CS-93-132, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1993. </year>
Reference: [Cao et al. 94] <author> Cao, P., Felten, E. W., and Li, K. </author> <title> Implementation and Performance of Application-Controlled File Caching. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Carter et al. 91] <author> Carter, J. B., Bennett, J. K., and Zwaenepoel, W. </author> <title> Implementation and Performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-64, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: If it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions can use these events to define services, such as demand paging, copy-on-write [Rashid et al. 87], distributed shared memory <ref> [Carter et al. 91] </ref>, or concurrent garbage collection [Appel & Li 91]. The physical page service may at any time reclaim physical memory by raising the PhysAddr.Reclaim event.
Reference: [Carter et al. 94] <author> Carter, N. P., Keckler, S. W., and Dally, W. J. </author> <title> Hardware Support for Fast Capability-Based Addressing. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 319-327, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Interfaces and collections of interfaces are protected to allow different extensions to have different views on the set of available services. Unlike other operating systems based on capabilities, which rely on special-purpose hardware <ref> [Carter et al. 94] </ref>, virtual memory mechanisms [Wulf et al. 81], probabilistic protection [Engler et al. 94], or protected message channels [Black et al. 92], SPIN implements capabilities directly using pointers, which are supported by the language.
Reference: [Chankhunthod et al. 95] <author> Chankhunthod, A., Danzig, P., Neerdaels, C., Schwartz, M., and Worrell, K. </author> <title> A Hierarchical Internet Object Cache. </title> <type> Technical Report CU-CS-766-95, </type> <institution> DCS University of Colorado, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Each stream requires approximately 3 Mb/sec. Another application that can benefit from SPIN's architecture is a web server. To service requests quickly, a web server should cache recently accessed objects, not cache large objects that are infrequently accessed <ref> [Chankhunthod et al. 95] </ref>, and avoid double buffering with other caching agents [Stone-braker 81]. A server that does not itself cache but is built on top of a conventional caching file system avoids the double buffering problem, but is unable to control the caching policy.
Reference: [Chen & Bershad 93] <author> Chen, J. B. and Bershad, B. N. </author> <title> The Impact of Operating System Structure on Memory System Performance. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 120-133, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference: [Cheriton & Duda 94] <author> Cheriton, D. R. and Duda, K. J. </author> <title> A Caching Model of Operating System Kernel Functionality. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 179-194, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Cheriton & Zwaenepoel 83] <author> Cheriton, D. R. and Zwaenepoel, W. </author> <title> The Distributed V Kernel and its Performance for Diskless Workstations. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 129-140, </pages> <address> Bretton Woods, NH, </address> <month> October </month> <year> 1983. </year>
Reference: [Colwell 85] <author> Colwell, R. </author> <title> The Performance Effects of Functional Migration and Architectural Complexity in Object-Oriented Systems. </title> <type> Technical Report CMU-CS-85-159, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1985. </year>
Reference-contexts: As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times <ref> [Colwell 85] </ref>, and was generally considered unacceptable. Some systems rely on little languages to safely extend the operating system interface through the use of interpreted code that runs in the kernel [Lee et al. 94, Mogul et al. 87, Yuhara et al. 94]. These systems suffer from three problems.
Reference: [Cooper & Draves 88] <author> Cooper, E. C. and Draves, R. P. </author> <title> C Threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: User-level thread management systems have addressed this mismatch [Wulf et al. 81, Cooper & Draves 88, Marsh et al. 91, Anderson et al. 92], but only partially. For example, Mach's user-level C-Threads implementation <ref> [Cooper & Draves 88] </ref> can have anomalous behavior because it is not well-integrated with kernel services [Ander-son et al. 92]. In contrast, scheduler activations, which are integrated with the kernel, have high communication overhead [Davis et al. 93]. <p> In the current implementation, the global scheduler implements a round-robin, preemptive, priority policy. We have used the strand interface to implement as kernel extensions a variety of thread management interfaces including DEC OSF/1 kernel threads [Dig 93], C-Threads <ref> [Cooper & Draves 88] </ref>, and Modula-3 threads. The implementations of these interfaces are built directly from strands and not layered on top of others. The interface supporting DEC OSF/1 kernel threads allows us to incorporate the vendor's device drivers directly into the kernel.
Reference: [Cooper et al. 91] <author> Cooper, E., Harper, R., and Lee, P. </author> <title> The Fox Project: Advanced Development of Systems Software. </title> <type> Technical Report CMU-CS-91-178, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1991. </year>
Reference: [Davis et al. 93] <author> Davis, P.-B., McNamee, D., Vaswani, R., and Lazowska, E. </author> <title> Adding Scheduler Activations to Mach 3.0. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium, </booktitle> <pages> pages 119-136, </pages> <address> Santa Fe, NM, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: For example, Mach's user-level C-Threads implementation [Cooper & Draves 88] can have anomalous behavior because it is not well-integrated with kernel services [Ander-son et al. 92]. In contrast, scheduler activations, which are integrated with the kernel, have high communication overhead <ref> [Davis et al. 93] </ref>. In SPIN an application can provide its own thread package and scheduler that executes within the kernel. The thread package defines the application's execution model and synchronization constructs. The scheduler controls the multiplexing of the processor across multiple threads.
Reference: [Dig 93] <author> Digital Equipment Corporation. </author> <title> DEC OSF/1 Writing Device Drivers: </title> <booktitle> Advanced Topics, </booktitle> <year> 1993. </year>
Reference-contexts: An object file is safe if it is unknown to the kernel but has been signed by the Modula-3 compiler, or if the kernel can otherwise assert the object file to be safe. For example, SPIN's lowest level device interface is identical to the DEC OSF/1 driver interface <ref> [Dig 93] </ref>, allowing us to dynamically link vendor drivers into the kernel. Although the drivers are written in C, the kernel asserts their safety. <p> In the current implementation, the global scheduler implements a round-robin, preemptive, priority policy. We have used the strand interface to implement as kernel extensions a variety of thread management interfaces including DEC OSF/1 kernel threads <ref> [Dig 93] </ref>, C-Threads [Cooper & Draves 88], and Modula-3 threads. The implementations of these interfaces are built directly from strands and not layered on top of others. The interface supporting DEC OSF/1 kernel threads allows us to incorporate the vendor's device drivers directly into the kernel.
Reference: [Draves 93] <author> Draves, R. </author> <title> The Case for Run-Time Replaceable Kernel Modules. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 160-164, </pages> <address> Napa, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: While individual applications have benefited from this level of freedom, the lack of safe interfaces to either operating system services or operating system extension services has created system configuration chaos <ref> [Draves 93] </ref>. 2.1 Related work Previous efforts to build extensible systems have demonstrated the three-way tension between extensibility, safety and performance. For example, Hydra [Wulf et al. 81] de-fined an infrastructure that allowed applications to manage resources through multi-level policies.
Reference: [Draves 94] <author> Draves, R. P. </author> <title> Control Transfer in Operating System Kernels. </title> <type> Technical Report CMU-CS-94-142, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The third line in the table shows the time to perform a protected, cross-address space procedure call. DEC OSF/1 supports cross-address space procedure call using sockets and SUN RPC. Mach provides an optimized path for cross-address space communication using messages <ref> [Draves 94] </ref>. SPIN's cross-address space procedure call is implemented as an extension that uses system calls to transfer control in and out of the kernel and cross-domain procedure calls within the kernel to transfer control between address spaces.
Reference: [Draves et al. 91] <author> Draves, R. P., Bershad, B. N., Rashid, R. F., and Dean, R. W. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-136, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference: [Engler & Kaashoek 95] <author> Engler, D. and Kaashoek, M. F. </author> <title> Exterminate All Operating System Abstractions. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in OperatingSystems, </booktitle> <pages> pages 78-83, </pages> <address> Orcas Island, WA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Aegis [Engler et al. 95] is an operating system that relies on efficient trap redirection to export hardware services, such as exception handling and TLB management, directly to applications. The system itself defines no abstractions beyond those minimally provided by the hardware <ref> [Engler & Kaashoek 95] </ref>. Instead, conventional operating system services, such as virtual memory and scheduling, are implemented as libraries executing in an application's address space. System service code executing in a library can be changed by the application according to its needs.
Reference: [Engler & Proebsting 94] <author> Engler, D. R. and Proebsting, T. A. </author> <title> DCG: An Efficient, Retargettable Dynamic Code Generation System. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 263-272, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1994. </year>
Reference: [Engler et al. 94] <author> Engler, D., Kaashoek, M. F., and O'Toole, J. </author> <title> The Oper--ating System Kernel as a Secure Programmable Machine. </title> <booktitle> In Proceedings of the 1994 ACM European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Interfaces and collections of interfaces are protected to allow different extensions to have different views on the set of available services. Unlike other operating systems based on capabilities, which rely on special-purpose hardware [Carter et al. 94], virtual memory mechanisms [Wulf et al. 81], probabilistic protection <ref> [Engler et al. 94] </ref>, or protected message channels [Black et al. 92], SPIN implements capabilities directly using pointers, which are supported by the language. A pointer is a reference to a block of memory whose type is declared within an interface.
Reference: [Engler et al. 95] <author> Engler, D. R., Kaashoek, M. F., and Jr, J. O. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Otherwise, protected interaction between system components, which occurs frequently in a system with fine-grained extensions, can be a limiting performance factor. Although the performance of cross-domain communication has improved substantially in recent years <ref> [Hamilton & Kougiouris 93, Hildebrand 92, Engler et al. 95] </ref>, it still does not approach that of a procedure call, encouraging the construction of monolithic, non-extensible systems. <p> In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects <ref> [Lucco 94, Engler et al. 95, Small & Seltzer 94] </ref> are exploring the use of software fault isolation [Wahbe et al. 93] to safely link application code, written in any language, into the kernel's virtual address space. <p> In addition, software fault isolation is only a protection mechanism and does not define an extension model or the service interfaces that determine the degree to which a system can be extended. Aegis <ref> [Engler et al. 95] </ref> is an operating system that relies on efficient trap redirection to export hardware services, such as exception handling and TLB management, directly to applications. The system itself defines no abstractions beyond those minimally provided by the hardware [Engler & Kaashoek 95]. <p> SPIN allows applications to define specialized fault handling extensions to avoid user/kernel boundary crossings and implement precisely the functionality that is required. Table 4 shows the time to execute several commonly referenced virtual memory benchmarks <ref> [Appel & Li 91, Engler et al. 95] </ref>. The line labeled Dirty in the table measures the time for an application to query the status of a particular virtual page. Neither DEC OSF/1 nor Mach provide this facility.
Reference: [Fall & Pasquale 94] <author> Fall, K. and Pasquale, J. </author> <title> Improving Continuous-Media Playback Performance with In-Kernel Data Paths. </title> <booktitle> In Proceedings of the First IEEE International Conference on Multimedia Computing and Systems, </booktitle> <pages> pages 100-109, </pages> <address> Boston, MA, </address> <month> May </month> <year> 1994. </year>
Reference: [Felten 92] <author> Felten, E. W. </author> <title> The Case for Application-Specific Communication Protocols. </title> <booktitle> In Intel Supercomputer Systems Technology Focus Conference, </booktitle> <pages> pages 171-181, </pages> <month> April </month> <year> 1992. </year>
Reference: [Fiuczynski & Bershad 96] <author> Fiuczynski, M. and Bershad, B. </author> <title> An Extensible Protocol Architecture for Application-Specific Networking. </title> <booktitle> In Proceedings of the 1996 Winter USENIX Conference, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Neither DEC OSF/1 nor Mach provide an interface for querying the internal state of a page frame. 5.3 Networking We have used SPIN's extension architecture to implement a set of network protocol stacks for Ethernet and ATM networks <ref> [Fiuczynski & Bershad 96] </ref>. Figure 5 illustrates the structure of the protocol stacks, which are similar to the x-kernel's [Hutchinson et al. 89] except that SPIN permits user code to be dynamically placed within the stack.
Reference: [Forin et al. 91] <author> Forin, A., Golub, D., and Bershad, B. N. </author> <title> An I/O System for Mach 3.0. </title> <booktitle> In Proceedings of the Second USENIX Mach Symposium, </booktitle> <pages> pages 163-176, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Unfortunately, applications often require substantial changes to a microkernel's implementation to compensate for limitations in interfaces [Lee et al. 94, Davis et al. 93, Waldspurger & Weihl 94]. Although a microkernel's communication facilities provide the infrastructure for extending nearly any kernel service <ref> [Barrera 91, Abrossimov et al. 89, Forin et al. 91] </ref>, few have been so extended.
Reference: [Geschke et al. 77] <author> Geschke, C., Morris, J., and Satterthwaite, E. </author> <title> Early Experiences with Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 540-553, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: Several systems [Cooper et al. 91, Redell et al. 80, Mossenbock 94, Organick 73] like SPIN, have relied on language features to extend operating system services. Pilot, for instance, was a single-address space system that ran programs written in Mesa <ref> [Geschke et al. 77] </ref>, an ancestor of Modula-3. In general, systems such as Pilot have depended on the language for all protection in the system, not just for the protection of the operating system and its extensions.
Reference: [Golub et al. 90] <author> Golub, D., Dean, R., Forin, A., and Rashid, R. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the 1990 Summer USENIX Conference, </booktitle> <pages> pages 87-95, </pages> <month> June </month> <year> 1990. </year>
Reference: [Hamilton & Kougiouris 93] <author> Hamilton, G. and Kougiouris, P. </author> <title> The Spring Nucleus: A Microkernel for Objects. </title> <booktitle> In Proceedings of the 1993 Summer USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <address> Cincinnati, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Otherwise, protected interaction between system components, which occurs frequently in a system with fine-grained extensions, can be a limiting performance factor. Although the performance of cross-domain communication has improved substantially in recent years <ref> [Hamilton & Kougiouris 93, Hildebrand 92, Engler et al. 95] </ref>, it still does not approach that of a procedure call, encouraging the construction of monolithic, non-extensible systems.
Reference: [Harty & Cheriton 91] <author> Harty, K. and Cheriton, D. R. </author> <title> Application-Controlled Physical Memory using External Page-Cache Management. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 187-197, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces [Young et al. 87, Kha-lidi & Nelson 93], or to direct expensive operations, for example page-out <ref> [Harty & Cheriton 91, McNamee & Armstrong 90] </ref>, entirely from user level. Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries [Bala et al. 94], entirely from the kernel.
Reference: [Heidemann & Popek 94] <author> Heidemann, J. and Popek, G. </author> <title> File-System Development with Stackable Layers. </title> <journal> Communications of the ACM, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead can limit performance. Many systems provide interfaces that enable arbitrary code to be installed into the kernel at runtime <ref> [Heidemann & Popek 94, Rozier et al. 88] </ref>. In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible.
Reference: [Hildebrand 92] <author> Hildebrand, D. </author> <title> An Architectural Overview of QNX. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 113-126, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Otherwise, protected interaction between system components, which occurs frequently in a system with fine-grained extensions, can be a limiting performance factor. Although the performance of cross-domain communication has improved substantially in recent years <ref> [Hamilton & Kougiouris 93, Hildebrand 92, Engler et al. 95] </ref>, it still does not approach that of a procedure call, encouraging the construction of monolithic, non-extensible systems.
Reference: [Hutchinson et al. 89] <author> Hutchinson, N. C., Peterson, L., Abbott, M. B., and O'Malley, S. </author> <title> RPC in x-kernel: Evaluating New Design Techniques. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Figure 5 illustrates the structure of the protocol stacks, which are similar to the x-kernel's <ref> [Hutchinson et al. 89] </ref> except that SPIN permits user code to be dynamically placed within the stack. Each incoming packet is pushed through the protocol graph by events and pulled by handlers.
Reference: [Int 81] <author> Intel Corporation. </author> <booktitle> Introductionto the iAPX 432 Architecture, </booktitle> <year> 1981. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times [Liedtke 92, Liedtke 93, Int 90]. As a point of comparison, the Intel 432 <ref> [Int 81] </ref>, which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Int 90] <author> Intel Corporation. </author> <title> i486 Microprocessor Programmer's Reference Manual, </title> <year> 1990. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Khalidi & Nelson 93] <author> Khalidi, Y. A. and Nelson, M. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 469-480, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference: [Lazowska et al. 81] <author> Lazowska, E. D., Levy, H. M., Almes, G. T., Fischer, M., Fowler, R., and Vestal, S. </author> <title> The Architecture of the Eden System. </title> <booktitle> In Proceedingsof the Eighth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 148159, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: For example, a protection model based on address spaces ensures that a process can only access memory within a particular range of virtual addresses. Address spaces, though, are frequently inadequate for the fine-grained protection and management of resources, being expensive to create and slow to access <ref> [Lazowska et al. 81] </ref>. Capabilities All kernel resources in SPIN are referenced by capabilities. A capability is an unforgeable reference to a resource which can be a system object, an interface, or a collection of interfaces.
Reference: [Lee et al. 94] <author> Lee, C. H., Chen, M. C., and Chang, R. C. </author> <title> HiPEC: High Performance External Virtual Memory Caching. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 153-164, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Liedtke 92] <author> Liedtke, J. </author> <title> Fast Thread Management and Communication Without Continuations. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 213-221, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Liedtke 93] <author> Liedtke, J. </author> <title> Improving IPC by Kernel Design. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 175-188, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: For example, the L3 microkernel, even with its aggressive design, has a protected procedure call implementation with overhead of nearly 100 procedure call times <ref> [Liedtke 92, Liedtke 93, Int 90] </ref>. As a point of comparison, the Intel 432 [Int 81], which provided hardware support for protected cross-domain transfer, had a cross-domain communication overhead on the order of about 10 procedure call times [Colwell 85], and was generally considered unacceptable.
Reference: [Lucco 94] <author> Lucco, S. </author> <title> High-Performance MicrokernelSystems. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> page 199, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects <ref> [Lucco 94, Engler et al. 95, Small & Seltzer 94] </ref> are exploring the use of software fault isolation [Wahbe et al. 93] to safely link application code, written in any language, into the kernel's virtual address space.
Reference: [Maeda & Bershad 93] <author> Maeda, C. and Bershad, B. N. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference: [Marsh et al. 91] <author> Marsh, B., Scott, M., LeBlanc, T., and Markatos, E. </author> <title> First-Class User-Level Threads. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles,pages 110-121,Pacific Grove, </booktitle> <address> CA, </address> <month> October </month> <year> 1991. </year>
Reference: [McNamee & Armstrong 90] <author> McNamee, D. and Armstrong, K. </author> <title> Extending the Mach External Pager Interface to Accommodate User-Level Page Replacement Policies. </title> <booktitle> In Proceedings of the USENIX Mach Symposium, </booktitle> <pages> pages 17-29, </pages> <address> Burlington, VT, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces [Young et al. 87, Kha-lidi & Nelson 93], or to direct expensive operations, for example page-out <ref> [Harty & Cheriton 91, McNamee & Armstrong 90] </ref>, entirely from user level. Others have enabled control over relatively small objects, such as cache pages [Romer et al. 94] or TLB entries [Bala et al. 94], entirely from the kernel.
Reference: [Mogul et al. 87] <author> Mogul, J., Rashid, R., and Accetta, M. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference: [Mossenbock 94] <author> Mossenbock, H. </author> <title> Extensibility in the Oberon System. </title> <journal> Nordic Journal of Computing, </journal> <volume> 1(1) </volume> <pages> 77-93, </pages> <month> February </month> <year> 1994. </year>
Reference: [Mullender et al. 90] <author> Mullender, S. J., Rossum, G. V., Tanenbaum, A. S., Renesse, R. V., and van Staveren, H. </author> <title> Amoeba A Distributed Operating System for the 1990's. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 44-54, </pages> <month> May </month> <year> 1990. </year>
Reference: [Nelson 91] <author> Nelson, G., </author> <title> editor. System Programmingin Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Operating system extensions are dynamically linked into the kernel virtual address space. Co-location enables communication between system and extension code to have low cost. * Enforced modularity. Extensions are written in Modula-3 <ref> [Nelson 91] </ref>, a modular programming language for which the compiler enforces interface boundaries between modules. Extensions, which execute in the kernel's virtual address space, cannot access memory or execute privileged instructions unless they have been given explicit access through an interface. <p> The interface supporting DEC OSF/1 kernel threads allows us to incorporate the vendor's device drivers directly into the kernel. The C-Threads implementation supports our UNIX server, which uses the Mach C-Threads interface for concurrency. Within the kernel, a trusted thread package and scheduler implements the Modula-3 thread interface <ref> [Nelson 91] </ref>. 4.3 Implications for trusted services The processor and memory services are two instances of SPIN's core services, which provide interfaces to hardware mechanisms. The core services are trusted, which means that they must perform according to their interface specification.
Reference: [Organick 73] <editor> Organick, E., editor. </editor> <booktitle> Computer System Organizatrion: The B5700/B6700 Series. </booktitle> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference: [Pardyak & Bershad 94] <author> Pardyak, P. and Bershad, B. </author> <title> A Group Structuring Mechanism for a Distributed Object Oriented Language Objects. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 312-219, </pages> <address> Poznan, Poland, </address> <month> June </month> <year> 1994. </year>
Reference: [Rashid et al. 87] <author> Rashid, R., Tevanian, Jr., A., Young, M., Golub, D., Baron, R., Black, D., Bolosky, W., and Chew, J. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-II), </booktitle> <pages> pages 31-39, </pages> <address> Palo Alto, CA, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: If it accesses an allocated, but unmapped virtual page, then the Translation.PageNotPresent event is raised. Implementors of higher level memory management abstractions can use these events to define services, such as demand paging, copy-on-write <ref> [Rashid et al. 87] </ref>, distributed shared memory [Carter et al. 91], or concurrent garbage collection [Appel & Li 91]. The physical page service may at any time reclaim physical memory by raising the PhysAddr.Reclaim event.
Reference: [Redell 88] <author> Redell, D. </author> <title> Experience with Topaz Teledebugging. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <month> October </month> <year> 1988. </year>
Reference: [Redell et al. 80] <author> Redell, D. D., Dalal, Y. K., Horsley, T. R., Lauer, H. C., Lynch, W. C., McJones, P. R., Murray, H. G., and Purcell, S. C. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference: [Romer et al. 94] <author> Romer, T. H., Lee, D., and Bershad, B. N. </author> <title> Dynamic Page Mapping Policies for Cache Conflict Resolution on Standard Hardware. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 255-266, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Others have enabled control over relatively small objects, such as cache pages <ref> [Romer et al. 94] </ref> or TLB entries [Bala et al. 94], entirely from the kernel. None have allowed for fast, fine-grained control over the physical and virtual memory resources required by applications. SPIN's virtual memory system provides such control, and is enabled by the system's low-overhead invocation and protection services.
Reference: [Romer et al. 95] <author> Romer, T., Ohlrich, W., Karlin, A., and Bershad, B. </author> <title> Reducing TLB and Memory Overhead Using Online Superpage Promotion. </title> <booktitle> In Proceedings of the Twenty-Third International Symposium on Computer Architecture, </booktitle> <pages> pages 176-187, </pages> <year> 1995. </year>
Reference: [Rozier et al. 88] <author> Rozier, M., Abrossimov, V., Armand, F., Boule, I., Giend, M., Guillemont, M., Herrmann, F., Leonard, P., Langlois, S., and Neuhauser, W. </author> <title> The Chorus Distributed Operating System. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <year> 1988. </year>
Reference-contexts: Second, the interface between the language's programming environment and the rest of the system is generally narrow, making system integration difficult. Finally, interpretation overhead can limit performance. Many systems provide interfaces that enable arbitrary code to be installed into the kernel at runtime <ref> [Heidemann & Popek 94, Rozier et al. 88] </ref>. In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible.
Reference: [Schroeder & Burrows 90] <author> Schroeder, M. D. and Burrows, M. </author> <title> Performance of Firefly RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 1-17, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: A module that exports an interface explicitly creates a domain for its interface, and exports the domain through an in-kernel nameserver. The exported name of the interface, which can be specified within the interface, is used to coordinate the export and import as in many RPC systems <ref> [Schroeder & Burrows 90, Brockschmidt 94] </ref>. The constant Console.InterfaceName in Figure 1 defines a name that exporters and importers can use to uniquely identify a particular version of a service. Some interfaces, such as those for devices, restrict access at the time of the import.
Reference: [Schulman et al. 92] <author> Schulman, A., Maxey, D., and Pietrek, M. </author> <title> Undocu--mented Windows. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The need for extensibility in operating systems is shown clearly by systems such as MS-DOS, Windows, or the Macintosh Operating System. Although these systems were not designed to be extensible, their weak protection mechanisms have allowed application programmers to directly modify operating system data structures and code <ref> [Schulman et al. 92] </ref>.
Reference: [Small & Seltzer 94] <author> Small, C. and Seltzer, M. VINO: </author> <title> An Integrated Platform for Operating System and Database Research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard University, </institution> <year> 1994. </year>
Reference-contexts: In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects <ref> [Lucco 94, Engler et al. 95, Small & Seltzer 94] </ref> are exploring the use of software fault isolation [Wahbe et al. 93] to safely link application code, written in any language, into the kernel's virtual address space.
Reference: [Stevenson & Julin 95] <author> Stevenson, J. M. and Julin, D. P. Mach-US: </author> <title> Unix On Generic OS Object Servers. </title> <booktitle> In Proceedings of the 1995 Winter USENIX Conference, </booktitle> <address> New Orleans, LA, </address> <month> January </month> <year> 1995. </year>
Reference: [Stodolsky et al. 93] <author> Stodolsky, D., Bershad, B. N., and Chen, B. </author> <title> Fast Interrupt Priority Management for Operating System Kernels. </title> <booktitle> In Proceedings of the Second USENIX Workshop on Microkernels and Other Kernel Architectures,pages 105-110,San Diego, </booktitle> <address> CA, </address> <month> Septem-ber </month> <year> 1993. </year>
Reference: [Stonebraker 81] <author> Stonebraker, M. </author> <title> Operating System Support for Database Management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: A poorly matched implementation prevents an application from working well, while a poorly matched interface prevents it from working at all. For example, the implementations of disk buffering and paging algorithms found in modern operating systems can be inappropriate for database applications, resulting in poor performance <ref> [Stonebraker 81] </ref>. General This research was sponsored by the Advanced Research Projects Agency, the National Science Foundation (Grants no. CDA-9123308 and CCR-9200832) and by an equipment grant from Digital Equipment Corporation. Bershad was partially supported by a National Science Foundation Presidential Faculty Fellowship.
Reference: [Thacker et al. 88] <author> Thacker, C. P., Stewart, L. C., and Satterthwaite, Jr., E. H. Firefly: </author> <title> a Multiprocessor Workstation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 909-920, </pages> <month> August </month> <year> 1988. </year>
Reference: [Thekkath & Levy 93] <author> Thekkath, C. A. and Levy, H. M. </author> <title> Limits to Low-Latency RPC. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 179-203, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: We use the same vendor device drivers for both DEC OSF/1 and SPIN to isolate differences due to system architecture from those due to the characteristics of the underlying device driver. Neither the Lance Ethernet driver nor the FORE ATM driver are optimized for latency <ref> [Thekkath & Levy 93] </ref>, and only the Lance Ethernet driver is optimized for throughput. Using different device drivers we achieve a round-trip latency of 337 secs on Ethernet and 241 secs on ATM, while reliable ATM bandwidth between a pair of hosts rises to 41 Mb/sec.
Reference: [Thekkath & Levy 94] <author> Thekkath, C. A. and Levy, H. M. </author> <title> Hardware and Software Support for Efficient Exception Handling. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 145-156, </pages> <address> San Jose, CA, </address> <note> October 1994. </note> <author> [von Eicken et al. 92] von Eicken, T., Culler, D. E., Goldstein, S. C., and Schauser, K. E. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceedings of the Nineteenth International Symposium on Computer Architecture, </booktitle> <pages> pages 256-266, </pages> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: For example, concurrent and generational garbage collectors can use write faults to maintain invariants or collect reference information. A longstanding problem with fault-based strategies has been the overhead of handling a page fault in an application <ref> [Thekkath & Levy 94, Anderson et al. 91] </ref>. There are two sources of this overhead. First, handling each fault in a user application requires crossing the user/kernel boundary several times. Second, conventional systems provide quite general exception interfaces that can perform many functions at once. <p> Neither signals nor external pagers, though, have especially efficient implementations, as the focus of each is generalized functionality <ref> [Thekkath & Levy 94] </ref>. The second reason for SPIN's dominance is that each virtual memory event, which requires a series of interactions between the kernel and the application, is reflected to the application through a fast in-kernel protected procedure call.
Reference: [Wahbe et al. 93] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In these systems the right to define extensions is restricted because any extension can bring down the entire system; application-specific extensibility is not possible. Several projects [Lucco 94, Engler et al. 95, Small & Seltzer 94] are exploring the use of software fault isolation <ref> [Wahbe et al. 93] </ref> to safely link application code, written in any language, into the kernel's virtual address space. Software fault isolation relies on a binary rewriting tool that inserts explicit checks on memory references and branch instructions.
Reference: [Waldspurger & Weihl 94] <author> Waldspurger, C. A. and Weihl, W. E. </author> <title> Lottery Scheduling: Flexible Proportional-Share Resource Management. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 1-11, </pages> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference: [Wheeler & Bershad 92] <author> Wheeler, B. and Bershad, B. N. </author> <title> Consistency Management for Virtually Indexed Caches. </title> <booktitle> In Proceedings of the Fifth International Conferenceon Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 124-136, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference: [Wulf et al. 81] <author> Wulf, W. A., Levin, R., and Harbison, S. P. Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: For example, Hydra <ref> [Wulf et al. 81] </ref> de-fined an infrastructure that allowed applications to manage resources through multi-level policies. The kernel defined the mechanism for allocating resources between processes, and the processes themselves implemented the policies for managing those resources. <p> Interfaces and collections of interfaces are protected to allow different extensions to have different views on the set of available services. Unlike other operating systems based on capabilities, which rely on special-purpose hardware [Carter et al. 94], virtual memory mechanisms <ref> [Wulf et al. 81] </ref>, probabilistic protection [Engler et al. 94], or protected message channels [Black et al. 92], SPIN implements capabilities directly using pointers, which are supported by the language. A pointer is a reference to a block of memory whose type is declared within an interface.
Reference: [Young et al. 87] <author> Young, M., Tevanian, A., Rashid, R., Golub, D., Ep-pinger, J., Chew, J., Bolosky, W., Black, D., and Baron, R. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: Other systems have demonstrated significant performance improvements from specialized or tuned memory management policies that are accessible through interfaces exposed by the memory management system. Some of these interfaces have made it possible to manipulate large objects, such as entire address spaces <ref> [Young et al. 87, Kha-lidi & Nelson 93] </ref>, or to direct expensive operations, for example page-out [Harty & Cheriton 91, McNamee & Armstrong 90], entirely from user level. <p> For each new address space, the extension allocates a new context from the translation service. This context is subsequently filled in with virtual and physical address resources obtained from the memory allocation services. Another kernel extension defines a memory management interface supporting Mach's task abstraction <ref> [Young et al. 87] </ref>. Applications may use these interfaces, or they may define their own in terms of the lower-level services. 4.2 Extensible thread management An operating system's thread management system provides applications with interfaces for scheduling, concurrency, and synchronization. <p> In contrast, DEC OSF/1 requires that applications use the UNIX signal and mprotect interfaces to manage virtual memory, and Mach requires that they use the external pager interface <ref> [Young et al. 87] </ref>. Neither signals nor external pagers, though, have especially efficient implementations, as the focus of each is generalized functionality [Thekkath & Levy 94].
Reference: [Yuhara et al. 94] <author> Yuhara, M., Bershad, B. N., Maeda, C., and Moss, J. E. B. </author> <title> Efficient Packet Demultiplexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the 1994 Winter USENIX Conference, </booktitle> <pages> pages 153-165, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: When all 50 guards evaluate to true, latency rises to 637 secs. Presently, we perform no guard-specific optimizations such as evaluating common subexpressions <ref> [Yuhara et al. 94] </ref> or representing guard predicates as decision trees. As the system matures, we plan to apply these optimizations. Impact of automatic storage management An extensible system cannot depend on the correctness of unprivileged clients for its memory integrity.
References-found: 85

