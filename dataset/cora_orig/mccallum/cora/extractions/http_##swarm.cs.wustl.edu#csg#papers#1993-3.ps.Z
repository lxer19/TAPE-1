URL: http://swarm.cs.wustl.edu/csg/papers/1993-3.ps.Z
Refering-URL: http://swarm.cs.wustl.edu/cgi-bin/pubs/papers/
Root-URL: http://www.cs.wustl.edu
Title: 12/11/94 Seeking Concurrency in Rule-based Programming  
Author: Gruia-Catalin Roman Rose F. Gamble William E. Ball 
Date: September 1991  
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Pubnum: WUCS-91-17  
Abstract-found: 0
Intro-found: 1
Reference: [back-sere] <author> R. J. R. Back and K. Sere, </author> <title> "Stepwise Refinement of Parallel Algorithms," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 13, </volume> <month> pp.133-180 </month> <year> (1990). </year>
Reference-contexts: An alternate approach is offered by work on action systems. Back and Sere <ref> [back-sere] </ref> start with an initial (mostly sequential) program and refine it into an efficient concurrent one. In this paper we show that a combination of specification and program refinement may be applied to deriving efficient concurrent rule-based programs.
Reference: [banatre-lemetayer] <author> J. P. Ban---tre and D. Le Mtayer, </author> <title> The GAMMA model and its discipline of programming, </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 15, </volume> <pages> pp. </pages> <month> 55-77 </month> <year> (1990). </year>
Reference-contexts: Notation Swarm [roman-cunningham3] belongs to a class of languages and models that use tuple-based communication. Other languages and models in this class are Linda [carriero-gelernter], Associons 2 [rem], and GAMMA <ref> [banatre-lemetayer] </ref>. In this section we present a brief overview of the Swarm notation and its relation to traditional rule-based programming notation. The dataspace. In Swarm, the entire computation state is captured by a set of tuple-like entities called the dataspace.
Reference: [carriero-gelernter] <author> N. Carriero and D. Gelernter, </author> <title> Linda in context, </title> <journal> Communication of the ACM, </journal> <volume> Vol. 32, No 4, </volume> <pages> pp. </pages> <month> 444-458 </month> <year> (1989). </year>
Reference-contexts: Section 5 presents a systematic formal derivation of a highly concurrent version of the this program without reliance on traditional conflict resolution. 2. Notation Swarm [roman-cunningham3] belongs to a class of languages and models that use tuple-based communication. Other languages and models in this class are Linda <ref> [carriero-gelernter] </ref>, Associons 2 [rem], and GAMMA [banatre-lemetayer]. In this section we present a brief overview of the Swarm notation and its relation to traditional rule-based programming notation. The dataspace. In Swarm, the entire computation state is captured by a set of tuple-like entities called the dataspace.
Reference: [chandyMisraBook] <author> K. M. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <address> New York (1988). </address>
Reference-contexts: Thanks to work by Dijkstra [dijkstra], Gries [gries], and many others, this approach has reached high degrees of sophistication and formality in the arena of sequential programming. The introduction of similar techniques to the area of concurrent programming is a relatively recent development. Chandy and Misra's work on UNITY <ref> [chandyMisraBook] </ref> advocates an approach in which a formal specification of the problem is gradually refined up to the point when the specification is restrictive enough as to suggest a trivial translation into a concurrent program. An alternate approach is offered by work on action systems. <p> The Swarm proof logic follows the notational conventions for UNITY <ref> [chandyMisraBook] </ref>. We use Hoare-style assertions of the form - p - t- q - where p and q are predicates over the combined tuple space and transaction space (i.e., the dataspace) and t is a transaction.
Reference: [cunningham] <author> H. C. Cunningham and G.-C. Roman, </author> <title> A UNITY-Style Programming Logic for a Shared Dataspace Language, </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 1, No.3, </volume> <month> pp.365-376 </month> <year> (1990). </year>
Reference-contexts: Swarm is uniquely appropriate for this task. Its proof logic <ref> [cunningham] </ref> is a direct extension of the UNITY proof logic. Consequently, specification refinement techniques used in UNITY are also applicable to Swarm. Moreover, the Swarm notation is very close to common rule-based languages, such as OPS5 [forgy]. <p> Section 2 gave an overview of the Swarm notation that is used to describe the structure and behavior of rule-based programs resulting from the application of our method. Safety and progress properties of programs are specified and verified using the Swarm proof logic <ref> [cunningham] </ref> summarized in this section. The same proof logic is used to define an initial program specification.
Reference: [dijkstra] <author> E. D. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1976). </address>
Reference-contexts: Program derivation refers to a systematic formal process of constructing correct programs from their specifications, typically through some form of stepwise refinement. Thanks to work by Dijkstra <ref> [dijkstra] </ref>, Gries [gries], and many others, this approach has reached high degrees of sophistication and formality in the arena of sequential programming. The introduction of similar techniques to the area of concurrent programming is a relatively recent development.
Reference: [forgy] <author> C. L. Forgy, </author> <title> OPS5 Users Manual, </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie-Mellon University (1981). </institution>
Reference-contexts: Swarm is uniquely appropriate for this task. Its proof logic [cunningham] is a direct extension of the UNITY proof logic. Consequently, specification refinement techniques used in UNITY are also applicable to Swarm. Moreover, the Swarm notation is very close to common rule-based languages, such as OPS5 <ref> [forgy] </ref>. This facilitates easy integration of techniques used in concurrent programming into the rule-based programming arena. The remainder of the paper consists of four main parts followed by a discussion and conclusions. Section 2 introduces Swarm and programming notation used throughout the paper.
Reference: [gamble1] <author> R. F. Gamble, G.-C. Roman, and W. E. Ball, </author> <title> Formal Verification of Rule-Based Programs, </title> <booktitle> Proceeding of the Ninth National Conference on Artificial Intelligence (AAAI-91).(1991). </booktitle>
Reference: [gries] <editor> D. Gries, </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1987). </address>
Reference-contexts: Program derivation refers to a systematic formal process of constructing correct programs from their specifications, typically through some form of stepwise refinement. Thanks to work by Dijkstra [dijkstra], Gries <ref> [gries] </ref>, and many others, this approach has reached high degrees of sophistication and formality in the arena of sequential programming. The introduction of similar techniques to the area of concurrent programming is a relatively recent development.
Reference: [gupta] <author> A. Gupta, </author> <title> Parallelism in Production Systems, </title> <publisher> Pitman Publishing, </publisher> <address> London, England (1987). </address>
Reference-contexts: and GPOST is stable. 5 . 2 . 3 Refinement 3: reducing query complexity It is a well-known fact within the expert system community that the pattern matching phase involved in query evaluation consumes a large portion of the total time needed to execute one cycle in a rule-based program <ref> [gupta] </ref>. Nevertheless, our program derivation process often used complex queries, whose evaluation is likely to burden even the fastest matching algorithm. The goal of this refinement step is to reduce the complexity of these queries, thus yielding a more efficient program.
Reference: [ishida-stolfo] <author> T. Ishida and S. J. Stolfo, </author> <title> Towards the Parallel Execution of Rules in Production System Programs, </title> <booktitle> Proceeding of the IEEE International Conference on Parallel Processing, </booktitle> <pages> pp. 568-575, </pages> <year> (1985). </year>
Reference-contexts: The published programming solution [winston] relies on conflict resolution for tasking and rule-ordering, and no speedup would be gained if executed in parallel on available parallel productions system models, such as those proposed by Ishida and Stolfo <ref> [ishida-stolfo] </ref>, and Schmolze [schmolze-goel]. Section 5 presents a systematic formal derivation of a highly concurrent version of the this program without reliance on traditional conflict resolution. 2. Notation Swarm [roman-cunningham3] belongs to a class of languages and models that use tuple-based communication.
Reference: [miranker-kuo2] <author> D. P. Miranker, C. M. Kuo, and J. C. Browne, </author> <title> Parallel Compilation of Rule-based Programs, </title> <booktitle> Proceedings of 1990 International Conference on Parallel Processing, </booktitle> <pages> pp. 247-251, </pages> <year> (1990) </year> <month> 21 </month>
Reference: [pasik-stolfo] <author> A. Pasik and S. J. Stolfo, </author> <title> Improving Production System Performance on Parallel Architectures by Creating Constrained Copies of Rules, </title> <type> Technical Report, </type> <institution> Columbia University (1987). </institution>
Reference-contexts: The replaced variable must range over a finite set. Thus, the transaction space contains a new transaction for each possible instantiation of the variable. The technique is similar to constrained copying of rules used in some parallel implementations of rule-based programs <ref> [pasik-stolfo] </ref> to improve runtime performance. Its use in program derivation shares the same general goal but in a very distinct context. The resulting program automatically satisfies the specification. The assertions that are part of the specification make no explicit references to the transaction space.
Reference: [rem] <author> M. Rem, Associons: </author> <title> A program Notation with Tuples Instead of Variables, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol 3, No 3, </volume> <pages> pp 251-262 (1981). </pages>
Reference-contexts: Notation Swarm [roman-cunningham3] belongs to a class of languages and models that use tuple-based communication. Other languages and models in this class are Linda [carriero-gelernter], Associons 2 <ref> [rem] </ref>, and GAMMA [banatre-lemetayer]. In this section we present a brief overview of the Swarm notation and its relation to traditional rule-based programming notation. The dataspace. In Swarm, the entire computation state is captured by a set of tuple-like entities called the dataspace.
Reference: [roman-cunningham3] <author> G.-C. Roman and H. C. Cunningham, </author> <title> Mixed Programming Metaphors in a Shared Dataspace Model of Concurrency, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. 12,. </volume> <pages> pp 1361-1373 (1990). </pages>
Reference-contexts: We employ specification refinement to generate an initial rule-based program that is later refined into a program that is highly concurrent and efficient. The approach is targeted to rule-based programs that terminate. The program notation and proof logic used in this paper are those of Swarm <ref> [roman-cunningham3] </ref>, a concurrency model in which all the entities that make up the program state have a tuple-like representation and state transitions, called transactions, are described using a rule-like notation. Swarm is uniquely appropriate for this task. Its proof logic [cunningham] is a direct extension of the UNITY proof logic. <p> Section 5 presents a systematic formal derivation of a highly concurrent version of the this program without reliance on traditional conflict resolution. 2. Notation Swarm <ref> [roman-cunningham3] </ref> belongs to a class of languages and models that use tuple-based communication. Other languages and models in this class are Linda [carriero-gelernter], Associons 2 [rem], and GAMMA [banatre-lemetayer]. In this section we present a brief overview of the Swarm notation and its relation to traditional rule-based programming notation.
Reference: [schmolze-goel] <author> J. G. Schmolze and S. Goel, </author> <title> A Parallel Asynchronous Distributed Production System, </title> <booktitle> Proceeding of the 8th National Conference on Artificial Intelligence, </booktitle> <pages> pp. </pages> <month> 65-71 </month> <year> (1990). </year>
Reference-contexts: The published programming solution [winston] relies on conflict resolution for tasking and rule-ordering, and no speedup would be gained if executed in parallel on available parallel productions system models, such as those proposed by Ishida and Stolfo [ishida-stolfo], and Schmolze <ref> [schmolze-goel] </ref>. Section 5 presents a systematic formal derivation of a highly concurrent version of the this program without reliance on traditional conflict resolution. 2. Notation Swarm [roman-cunningham3] belongs to a class of languages and models that use tuple-based communication.
Reference: [winston] <author> P. H. Winston, </author> <booktitle> Artificial Intelligence, 2nd Edition, </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA (1984). </address>
Reference-contexts: Section 2 introduces Swarm and programming notation used throughout the paper. Section 3 summarizes the proof logic for Swarm. The use of assertions to specify rule-based programs is illustrated in Section 4 on a typical artificial intelligence textbook problem, grocery bagging. The published programming solution <ref> [winston] </ref> relies on conflict resolution for tasking and rule-ordering, and no speedup would be gained if executed in parallel on available parallel productions system models, such as those proposed by Ishida and Stolfo [ishida-stolfo], and Schmolze [schmolze-goel]. <p> Figure proof-logic: A subset of the Swarm proof logic. 4 Formal Specification In this section we introduce and give a formal specification of the problem used to illustrate our approach to formal derivation of rule-based programs. Bagger is a rule-based program described by Winston in <ref> [winston] </ref>. It expresses the desired way in which grocery items should be packed into bags. The 7 program must pack all unbagged items according to their weight, with the heavier items preceding the lighter ones in each bag.
References-found: 17

