URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-96-40.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~juergen/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: brauburger@informatik.th-darmstadt.de  
Title: Automatic Termination Analysis for Partial Functions Using Polynomial Orderings  
Author: Jurgen Brauburger 
Address: Alexanderstrae 10, 64283 Darmstadt, Germany  
Affiliation: FB Informatik, TH Darmstadt,  
Abstract: We present a method for automatically determining the input data for which functional programs terminate. In particular, we consider functional programs which do not terminate for each input thus defining partial functions. To characterize the domains of such partial functions, termination predicates have been introduced recently. Termination predicates can be synthesized inductively if suitable well-founded orderings are given. Up to now, these well-founded orderings have to be fixed in advance by a user. In this paper, we enable the automatic generation of well-founded polynomial orderings for termination predicate synthesis. We illustrate the problems that prevent the direct use of known techniques for that task, and we present solutions for overcoming these problems. The proposed method proved to be successful for numerous examples including functional as well as imperative programs.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R.S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19]. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in <ref> [1] </ref> the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. Only the method by Giesl [6, 7] automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings.
Reference: 2. <author> J. Brauburger. </author> <title> Computing the domains of partial functions. </title> <type> Technical Report IBN-97-44, </type> <institution> Darmstadt University of Technology, </institution> <year> 1997. </year>
Reference-contexts: However, sometimes it is necessary to respect , too, since otherwise no polynomial ordering exists satisfying any subset of inequalities. For that reason we have extended our method such that also the knowledge contained in is exploited automatically <ref> [2] </ref>. The presented approach proved to be successful for numerous examples. For instance, exploiting also the premises of the termination hypotheses, for each function f listed in Table 1 (cf. [3]) the termination predicate f could be synthesized without user interaction.
Reference: 3. <author> J. Brauburger and J. Giesl. </author> <title> Termination analysis for partial functions. </title> <booktitle> In Proceedings of 3rd SAS, </booktitle> <volume> LNCS 1145, </volume> <pages> pp. 113-127. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: Only the method by Giesl [6, 7] automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings. However, if a termination proof fails then all these methods provide no means to find a (sub-) domain where termination is provable. This problem is addressed in <ref> [3] </ref> by introducing for each procedure defining a function f a termination predicate f which ? Technical Report IBN-96-40, TH Darmstadt. Extended Version of a paper to be presented at the Fourth International Static Analysis Symposium, Paris, France, 1997. This work was supported by the Deutsche Forschungsgemeinschaft under grant no. <p> Wa 652/7-2 as part of the focus program "Deduktion". specifies the `admissible input' of f , i.e. evaluation of f must terminate for each input admitted by its termination predicate. However, the synthesis method for termination predicates given in <ref> [3] </ref> also requires a user to provide a well-founded ordering for every termination predicate. Our aim is to improve the automatic generation of termination predicates using the synthesis methods for polynomial orderings. <p> In fact, mean (n; m) terminates iff n m ^ even (n m). To represent subsets of inputs where procedures like mean terminate, Brauburger and Giesl introduced termination predicates <ref> [3] </ref>: Given an n-ary function f , an n-ary boolean function f is a termination predicate for f iff f is total and f (x 1 ; : : ; x n ) = true implies that the evaluation of f (x 1 ; : : ; x n ) halts. <p> Our overall goal is the automatic synthesis of functional procedures defining termination predicates. Even if the problem of determining the exact domains of partial functions is undecidable, our aim is to synthesize termination predicates which return true as often as possible. In <ref> [3] </ref>, rules for the synthesis of termination predicates are developed. <p> Here the termination condition fi (b f ) for the body b f - i.e. a boolean term which implies that the evaluation of b f halts is inductively constructed according to the following rules. 5 In <ref> [3] </ref>, measure functions are used to map the arguments to naturals which are compared by &lt; IN . <p> Let each well-founded ordering as well as the boolean functions ^; _; : be defined by absolutely terminating procedures. Then function f (x fl :s fl ): bool ( fi (b f ) defines a termination predicate for f <ref> [3] </ref>. 5 Faulty Transformation of Termination Hypotheses The synthesis of termination predicates described in the previous section requires a user to provide well-founded orderings. Our aim is to get independent from this input by enabling the synthesis of polynomial orderings for termination predicates using the estimation method by Giesl. <p> Furthermore, we have developed algorithms for automating estimation of partial functions. As a result, our method enables termination analysis for numerous partial functions without any user interaction. The synthesis of termination predicates using the generalized estimation technique also works if polymorphic types are considered, cf. <ref> [3, 7] </ref>. Furthermore, it can be applied to mutually recursive functions following the ideas presented in [8]. Besides, our method can be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. [13]. <p> For that reason we have extended our method such that also the knowledge contained in is exploited automatically [2]. The presented approach proved to be successful for numerous examples. For instance, exploiting also the premises of the termination hypotheses, for each function f listed in Table 1 (cf. <ref> [3] </ref>) the termination predicate f could be synthesized without user interaction. Further, for all these examples the synthesized termination predicate is not only sufficient for termination, but also represents the entire domain of the given function.
Reference: 4. <author> G.E. Collins. </author> <title> Quantifier elimination for real closed fields by cylindrical algebraic decomposition. </title> <booktitle> Proc. 2nd GI Conf. on Automata Theory and Formal Languages, </booktitle> <year> 1975. </year>
Reference-contexts: In the area of term rewriting systems, techniques have been developed for generating well-founded polynomial orderings [11] to satisfy a set of ordering constraints, i.e. inequalities of the form t r or t r, cf. <ref> [4, 6] </ref>. A polynomial ordering is defined by a polynomial interpretation that maps each n-ary function symbol f to an n-ary polynomial over the natural numbers.
Reference: 5. <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1, </volume> 2):69-115, 1987. 
Reference-contexts: 1 Introduction Proving the termination of programs is a central problem in the development of correct software. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (cf. <ref> [5, 17] </ref>) and of logic programs (e.g. [12, 14, 15], in this paper functional programs are considered. Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19].
Reference: 6. <author> J. Giesl. Automatisierung von Terminierungsbeweisen fur rekursiv definierte Al-gorithmen. </author> <type> PhD thesis, </type> <institution> Darmstadt University of Technology, </institution> <year> 1995. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. Only the method by Giesl <ref> [6, 7] </ref> automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings. However, if a termination proof fails then all these methods provide no means to find a (sub-) domain where termination is provable. <p> In the area of term rewriting systems, techniques have been developed for generating well-founded polynomial orderings [11] to satisfy a set of ordering constraints, i.e. inequalities of the form t r or t r, cf. <ref> [4, 6] </ref>. A polynomial ordering is defined by a polynomial interpretation that maps each n-ary function symbol f to an n-ary polynomial over the natural numbers. <p> However, since the set of considered inequalities is finite, we can backtrack if the ordering constraints cannot be shown to be polynomially satisfiable. Efficiency can be improved by using the successful heuristic presented in <ref> [6] </ref> which determines "probably polynomially satisfiable" inequalities. The presented approach can be generalized in order to enable the generation of arbitrary orderings on terms. <p> Then we have to extend the estimation rules by another consequence which guarantees, e.g., that t is monotonic in its first argument if pred is estimated in the term t (pred (n); succ (m)), cf. <ref> [6] </ref>. If terms are interpreted as polynomials over natural numbers, monotonicity always holds. Defined function symbols may also be eliminated by replacing a term with a new variable, cf. [7].
Reference: 7. <author> J. Giesl. </author> <title> Termination analysis for functional programs using term orderings. </title> <booktitle> In Proceedings of 2nd SAS, </booktitle> <volume> LNCS 983, </volume> <pages> pp. 154-171. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. Only the method by Giesl <ref> [6, 7] </ref> automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings. However, if a termination proof fails then all these methods provide no means to find a (sub-) domain where termination is provable. <p> Our aim is to improve the automatic generation of termination predicates using the synthesis methods for polynomial orderings. However, even if those techniques can be applied for proving that functional procedures terminate for each input <ref> [7] </ref> they cannot be used directly for generating termination predicates. This paper illustrates the occurring problems and solves them thus enabling termination analysis without user interaction for numerous partial functions. <p> Hence, polynomial orderings cannot be immediately applied to prove the absolute termination of procedures like append if defined function symbols like tail occur in the recursive calls and subsequently in the termination hypotheses. In <ref> [7] </ref>, Giesl solves this problem by a method that transforms termination hypotheses like (2) into a set of ordering constraints without defined function symbols such that the synthesis techniques for polynomial orderings may be applied. <p> For the moment we assume a set E tail of estimation inequalities without defined function symbols and sufficient for tail (l) tail (l) and further a strictness predicate ffi tail : list ! bool such that E tail and ffi tail (l) = true entail tail (l) tail (l), cf. <ref> [7] </ref>. Furthermore, we assume that denotes a still undefined polynomial ordering. Then the following formulas are sufficient for (2). <p> Hence, the set ffi := E tail [ f (4); (5)g is sufficient for (2). In general, we use the following estimation rules to eliminate a defined function symbol g occurring in an inequality t r or t r at occurrence p in t, cf. <ref> [7] </ref>. <p> Up to now, the estimation inequalities E tail and the strictness predicate ffi tail are still unspecified. We obtain the set E tail from the inequality tail (l) tail (l) by the structural case analysis occurring in the procedure of tail, cf. <ref> [7] </ref>. <p> The results of ffi tail are obtained from tail (l) tail (l) analogously to the construction of E tail , cf. <ref> [7] </ref>. function ffi tail (l : list) : bool ( if l = add (m; j) then j tail (add (m; j)) else empty tail (empty) Elimination of Strictness Predicates. <p> In the first step, (2) has been transformed into the set ffi = f (4); (5); (7); (8)g where only (5) contains a defined function symbol, viz. the strictness predicate ffi tail . In <ref> [7] </ref>, two alternative methods are suggested to eliminate such occurrences of strictness predicates. First, in (5) the premise l 6= empty and the disjunct ffi tail (l) containing the strictness predicate may be omitted. <p> For instance, l 6= empty ! ffi tail (l) is entailed by inequality (10) which is the ffi tail -result for the condition l = add (m; j). In <ref> [7] </ref>, the soundness of this transformation step is checked by an induction theorem prover, cf. [18]. <p> An extension of this method to k recursive calls, several defined function symbols with several arguments is straight forward yielding k soundness conditions of the form fl g 1 (: : :) _ : : _ fl g p (: : :), cf. <ref> [7] </ref>. 6 Estimation of Partial Functions Up to now, we have estimated total functions like the selectors tail and pred. However, in general we have to consider partial functions to estimate. Unfortunately, we cannot apply the automatic generation methods for estimation inequalities and strictness predicates developed in [7] to partial functions. <p> : :), cf. <ref> [7] </ref>. 6 Estimation of Partial Functions Up to now, we have estimated total functions like the selectors tail and pred. However, in general we have to consider partial functions to estimate. Unfortunately, we cannot apply the automatic generation methods for estimation inequalities and strictness predicates developed in [7] to partial functions. Hence in this section we generalize the notions of estimation inequalities and strictness predicates thus enabling their automatic generation for partial functions. <p> g (x fl ) ^ ffi g (x fl ) ! g (x fl ) g (x fl ). 2 For a function g (x fl ) with termination predicate g (x fl ) = true - i.e. g is total - Definition 4 reduces to the original definition in <ref> [7] </ref>, cf. Section 3. <p> p (n) : mean (p (n); s (m)) ! mean (p (n); s (m)) mean (n; m) (24) n 6= m ^ :fl p (n) : false ! mean (p (n); s (m)) mean (n; m) (25) 8 In fact, the reason is that mean does not terminate absolutely, cf. <ref> [7] </ref>. 9 To ease readability, henceforth we often write s and p instead of succ and pred, resp. Recall that we have replaced (p (n); s (m)) (n; m) in mean with fl p (n). <p> Furthermore, we have developed algorithms for automating estimation of partial functions. As a result, our method enables termination analysis for numerous partial functions without any user interaction. The synthesis of termination predicates using the generalized estimation technique also works if polymorphic types are considered, cf. <ref> [3, 7] </ref>. Furthermore, it can be applied to mutually recursive functions following the ideas presented in [8]. Besides, our method can be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. [13]. <p> If terms are interpreted as polynomials over natural numbers, monotonicity always holds. Defined function symbols may also be eliminated by replacing a term with a new variable, cf. <ref> [7] </ref>. Using also this technique for transforming termination hypotheses, we may generalize the termination proof method by Giesl, since whenever his method proves a function f to be total, then our method generates a termination predicate procedure that returns true for each input.
Reference: 8. <author> J. Giesl. </author> <title> Termination of nested and mutually recursive algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <note> to appear. </note>
Reference-contexts: The synthesis of termination predicates using the generalized estimation technique also works if polymorphic types are considered, cf. [3, 7]. Furthermore, it can be applied to mutually recursive functions following the ideas presented in <ref> [8] </ref>. Besides, our method can be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. [13].
Reference: 9. <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: Exploiting also the premises of the termination hypotheses we could generate the exact domain in 27 of 45 examples from <ref> [9] </ref>. Acknowledgements. I would like to thank Hesham Khalil, Stefan Gerberding, Jurgen Giesl, Thomas Kolbe, and Christoph Walther for helpful comments.
Reference: 10. <author> P. Henderson. </author> <title> Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1980. </year>
Reference-contexts: Functions and their synthesized termination predicates We applied our approach also to imperative programs which may be translated into equivalent functional programs, where loops are often yield partial functions, cf. e.g. <ref> [10] </ref>. Exploiting also the premises of the termination hypotheses we could generate the exact domain in 27 of 45 examples from [9]. Acknowledgements. I would like to thank Hesham Khalil, Stefan Gerberding, Jurgen Giesl, Thomas Kolbe, and Christoph Walther for helpful comments.
Reference: 11. <author> D.S. Lankford. </author> <title> On proving term rewriting systems are Noetherian. </title> <institution> Memo MTP-3, Mathematics Department, Louisiana Technical University, Ruston, USA, </institution> <year> 1979. </year>
Reference-contexts: In the area of term rewriting systems, techniques have been developed for generating well-founded polynomial orderings <ref> [11] </ref> to satisfy a set of ordering constraints, i.e. inequalities of the form t r or t r, cf. [4, 6]. A polynomial ordering is defined by a polynomial interpretation that maps each n-ary function symbol f to an n-ary polynomial over the natural numbers.
Reference: 12. <author> M. Muller, T. Gla, and K. Stroetmann. </author> <title> Automated modular termination proofs for real prolog programs. </title> <booktitle> In Proc. of 3rd SAS, </booktitle> <volume> LNCS 1145, </volume> <pages> pp. 220-237. </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction Proving the termination of programs is a central problem in the development of correct software. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (cf. [5, 17]) and of logic programs (e.g. <ref> [12, 14, 15] </ref>, in this paper functional programs are considered. Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19]. The invention of well-founded orderings is crucial for the automation of such termination proofs.
Reference: 13. <author> F. Nielson and H.R. Nielson. </author> <title> Operational semantics of termination types. </title> <journal> Nordic Journal of Computing, </journal> <volume> 3(2) </volume> <pages> 144-187, </pages> <year> 1996. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in <ref> [13, 16, 19] </ref> use one fixed ordering or lexicographic combinations of it. Only the method by Giesl [6, 7] automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings. <p> Furthermore, it can be applied to mutually recursive functions following the ideas presented in [8]. Besides, our method can be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. <ref> [13] </ref>. Our method has a choice point when searching for a polynomially satisfiable set of ordering constraints since a subset of the inequalities occurring in the transformed termination hypotheses or in the strictness predicate procedures must be chosen.
Reference: 14. <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs. </title> <publisher> LNAI 446. Springer, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Proving the termination of programs is a central problem in the development of correct software. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (cf. [5, 17]) and of logic programs (e.g. <ref> [12, 14, 15] </ref>, in this paper functional programs are considered. Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19]. The invention of well-founded orderings is crucial for the automation of such termination proofs.
Reference: 15. <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: The never-ending story. </title> <journal> Journal of Logic Programming, </journal> 19/20:199-260, 1994. 
Reference-contexts: 1 Introduction Proving the termination of programs is a central problem in the development of correct software. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (cf. [5, 17]) and of logic programs (e.g. <ref> [12, 14, 15] </ref>, in this paper functional programs are considered. Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19]. The invention of well-founded orderings is crucial for the automation of such termination proofs.
Reference: 16. <author> C. Sengler. </author> <title> Termination of algorithms over non-freely generated data types. </title> <booktitle> In Proceedings of 13th CADE, LNAI 1104, </booktitle> <pages> pp. 121-136. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in <ref> [13, 16, 19] </ref> use one fixed ordering or lexicographic combinations of it. Only the method by Giesl [6, 7] automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings.
Reference: 17. <author> J. Steinbach. </author> <title> Simplification orderings: History of results. </title> <journal> Fundamenta Informati-cae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Proving the termination of programs is a central problem in the development of correct software. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (cf. <ref> [5, 17] </ref>) and of logic programs (e.g. [12, 14, 15], in this paper functional programs are considered. Several methods have been developed for proving that a functional program terminates for each input, e.g. [1, 6, 7, 13, 16, 19].
Reference: 18. <author> C. Walther. </author> <title> Mathematical induction. </title> <booktitle> In Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> vol. 2, </volume> <pages> pp. 127-227, </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: The transformation is sound, i.e. we have j= ffi j= ! t (t fl ) t (x fl ): (3) Here j= denotes inductive entailment where the semantics of the defined functions is respected, cf. <ref> [18] </ref>. We sketch the method transforming (2) into the polynomially satisfiable set of ordering constraints := f (4); (7); (8); (10)g. Estimation of Defined Functions. <p> For instance, l 6= empty ! ffi tail (l) is entailed by inequality (10) which is the ffi tail -result for the condition l = add (m; j). In [7], the soundness of this transformation step is checked by an induction theorem prover, cf. <ref> [18] </ref>. The resulting ordering constraints := f (4); (7); (8); (10)g are polynomially satisfied, for instance, by the polynomial interpretation = fempty 7! 0; add (m; j) 7! j + 1; tail (l) 7! l; t (l; k) 7! lg.
Reference: 19. <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: Several methods have been developed for proving that a functional program terminates for each input, e.g. <ref> [1, 6, 7, 13, 16, 19] </ref>. The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in [13, 16, 19] use one fixed ordering or lexicographic combinations of it. <p> The invention of well-founded orderings is crucial for the automation of such termination proofs. While in [1] the main characteristics of well-founded orderings are given by a user, the methods in <ref> [13, 16, 19] </ref> use one fixed ordering or lexicographic combinations of it. Only the method by Giesl [6, 7] automates invention of well-founded orderings as it incorporates synthesis techniques for polynomial orderings.
References-found: 19

