URL: http://www.cs.utexas.edu/users/marco/podc96.ps
Refering-URL: http://www.cs.utexas.edu/users/marco/
Root-URL: 
Title: Memory Requirements for Silent Stabilization (Extended Abstract)  
Author: Shlomi Dolev Mohamed G. Gouda Marco Schneider 
Abstract: In this work we show that no constant memory silent self-stabilizing algorithms exist for identification of the centers of a graph, leader election, and spanning tree construction. Lower bounds of (log n) bits per communication register are obtained for each of the above tasks. The existence of a silent legitimate global state that uses less than log n bits per register is assumed. This legitimate global state is used to construct a silent global state that is illegitimate. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Abello and Shlomi Dolev, </author> <title> "On the Computational Power of Self-Stabilizing Systems," </title> <journal> Journal of Computing and Information, </journal> <volume> Vol. 1, No. 1, </volume> <booktitle> Special Issue: Proceedings of the 6th International Conference on Computing and Information, </booktitle> <pages> pp. </pages> <address> 585-603 (B10), </address> <year> 1994. </year>
Reference-contexts: In this way the communication bandwidth usage can be dramatically reduced. The interest in distributed and parallel systems of (identical) processors with small memory size is motivated by current microprocessor technology (See e.g. <ref> [1] </ref>). The mass production of microprocessors motivates multiprocessing systems in which each processor is equipped with a small amount of memory. In another context, microprocessors are used in switches of high-speed networks to support the distributed coordination (See e.g. [19]).
Reference: [2] <author> Anish Arora and Mohamed Gouda, </author> <title> "Distributed Reset", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 43, No. 9, </volume> <year> 1994. </year>
Reference-contexts: Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], <ref> [2] </ref> and [11, 12]. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. <p> Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], <ref> [2] </ref> and [11, 12]. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d).
Reference: [3] <author> Baruch Awerbuch and Rafail Ostrovsky, </author> <title> "Memory-Efficient and Self-Stabilizing Network RESET", </title> <booktitle> Proc. of the 13th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 254-263, </pages> <year> 1994. </year>
Reference-contexts: Our first result shows that at least (log n) bits per a communication register (and hence per processor) are required by any silent self-stabilizing algorithm to find the centers of a graph. Recently, relatively intricate randomized algorithms for leader election with a small amount of memory were proposed by <ref> [3] </ref> and [16]. Our research shows that every silent leader election algorithm for arbitrary graphs requires (log n) bits per a communication register. The result is also applicable to an id-based system where processors are augmented with unique identifiers.
Reference: [4] <author> Zeev Collin, and Shlomi Dolev, </author> <title> "Self-Stabilizing Depth First Search," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 49, </volume> <pages> pp. 297-301, </pages> <year> 1994. </year>
Reference-contexts: For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d). All three algorithms (as well as the algorithms in e.g. <ref> [6, 4, 7] </ref>) benefit from the silence property: following the convergence, no change to the value of the communication registers takes place. A relatively intricate deterministic algorithm for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [13].
Reference: [5] <author> Edsger W. Dijkstra, </author> <title> "Self-Stabilizing Systems in Spite of Distributed Control", </title> <booktitle> Communications of the ACM 17,11 (1974), </booktitle> <pages> pp. 643-644. </pages>
Reference-contexts: Email: dolev@cs.bgu.ac.il. y Department of Computer Science, The University of Texas at Austin, Austin, Texas 78712-1188, USA, Email: fgouda,marcog@cs.utexas.edu. desirable property is automatic recovery following the occurrence of faults. Automatic recovery is guaranteed when the system is designed to be self-stabilizing <ref> [5, 21] </ref>. A self-stabilizing distributed system converges to a desired behavior starting from any state. In this research we define and investigate a specific class of self-stabilizing algorithms, namely silent self-stabilizing algorithms. <p> The means by which the silent legitimate global state is reached are not utilized in our proofs. Thus, our lower bound results apply to deterministic, nondeterministic and randomized self-stabilizing algorithms for synchronous systems, asynchronous systems and systems that are controlled by a central-demon (See e.g. <ref> [5] </ref>). We consider uniform, id-based and semi-uniform systems as we now define. In a uniform system all the processors are identical, in id-based system processors have distinct identifiers and in semi-uniform all the processors are identical except for a single distinguished processor. <p> The algorithm in [17] assumes that the activities in the system are controlled by a central demon <ref> [5] </ref>. The central demon activates a single processor at a time. Note that the algorithm of [17] cannot be applied to synchronous system wherein processors simultaneously execute a step, since symmetry cannot be broken. Our lower bounds can be applied to the central demon model as well. <p> Our results are also applicable to the case where processors can read the entire state of their neighbors as proposed in <ref> [5] </ref>. In such a setting once the system reaches a silent (safe) configuration no processor changes its state.
Reference: [6] <author> Shlomi Dolev, </author> <title> "Optimal Time Self Stabilization in Dynamic Systems," </title> <booktitle> Proc. of the 7th International Workshop on Distributed Algorithms, </booktitle> <pages> pp. 160-173, </pages> <year> 1993. </year>
Reference-contexts: For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d). All three algorithms (as well as the algorithms in e.g. <ref> [6, 4, 7] </ref>) benefit from the silence property: following the convergence, no change to the value of the communication registers takes place. A relatively intricate deterministic algorithm for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [13].
Reference: [7] <author> Shlomi Dolev and Ted Herman, </author> <title> "SuperStabiliz-ing Protocols for Dynamic Distributed Systems," </title> <booktitle> Proc. of the Second Workshop on Self-Stabilizing Systems,UNLV, </booktitle> <pages> pp. </pages> <address> 3.1-3.15, </address> <year> 1995. </year> <title> Short abstract in Proc. </title> <booktitle> of the 14th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <address> p. 255, </address> <year> 1995. </year>
Reference-contexts: For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d). All three algorithms (as well as the algorithms in e.g. <ref> [6, 4, 7] </ref>) benefit from the silence property: following the convergence, no change to the value of the communication registers takes place. A relatively intricate deterministic algorithm for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in [13]. <p> There are silent self-stabilizing algorithms that require a constant number of bits per register, one such example is the graph coloring algorithm of <ref> [7] </ref>. The classification of tasks according to their memory requirements for silence configuration may identify the level of locality of the task.
Reference: [8] <author> Shlomi Dolev, Amos Israeli and Shlomo Moran, </author> <title> "Resource Bounds for Self Stabilizing Message Driven Protocols", </title> <booktitle> Proc. of the 10th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 281-293, </pages> <year> 1991. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference-contexts: Moreover, when message passing is used to deliver the value of the communication registers (port buffers) as described in <ref> [8] </ref> it would be enough to send some encrypted proof that the value is not changed. At each delivery a key is chosen randomly and the checksum relatively to this key is sent together with the key. In this way the communication bandwidth usage can be dramatically reduced.
Reference: [9] <author> Shlomi Dolev, Amos Israeli, and Shlomo Moran, </author> <title> "Self Stabilization of Dynamic Systems Assuming Only Read Write Atomicity", </title> <journal> Distributed Computing, </journal> <volume> Vol. 7, </volume> <pages> pp. 3-16, </pages> <year> 1993. </year>
Reference-contexts: Note that there is a class of tasks that are inherently non silent. An example of such a task is mutual-exclusion or token passing where the contents of the communication registers must be changed over time e.g. <ref> [9, 10, 15, 20] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 . <p> Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. <ref> [9] </ref>, [2] and [11, 12]. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires <p> Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. <ref> [9] </ref>, [2] and [11, 12]. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an <p> e.g. <ref> [9] </ref>, [2] and [11, 12]. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d). All three algorithms (as well as the algorithms in e.g. [6, 4, 7]) benefit from the silence property: following the convergence, no change to the value of the communication registers takes place. <p> Such a silent configuration will include z + 1 leaders. We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 5 Tree Construction A silent self-stabilizing algorithm for tree construction appears in <ref> [9] </ref> and uses fi (log n) bits per a register. The algorithm of [9] is designed for semi-uniform system. In this Section we prove that there is no silent self-stabilizing algorithm for tree construction in a semi-uniform id-based system that uses o (log n) bits per register. <p> We have proved our contradiction, since for infinitely many values of z the above silent configuration represents a ring with a prime number of processors. 5 Tree Construction A silent self-stabilizing algorithm for tree construction appears in <ref> [9] </ref> and uses fi (log n) bits per a register. The algorithm of [9] is designed for semi-uniform system. In this Section we prove that there is no silent self-stabilizing algorithm for tree construction in a semi-uniform id-based system that uses o (log n) bits per register. Hence we prove that the algorithm in [9] is optimal in its memory requirements. <p> The algorithm of <ref> [9] </ref> is designed for semi-uniform system. In this Section we prove that there is no silent self-stabilizing algorithm for tree construction in a semi-uniform id-based system that uses o (log n) bits per register. Hence we prove that the algorithm in [9] is optimal in its memory requirements. The lower bound is proven for a special graph this graph is a combination of triangles such that two triangles are connected by a link, see Figure 1.
Reference: [10] <author> Mohamed G. Gouda and Furman Haddix, </author> <title> "Stabilizing Token Rings in Three Bits", </title> <journal> Journal of Parallel and Distributed Computing, </journal> <note> to appear 1996. </note>
Reference-contexts: Note that there is a class of tasks that are inherently non silent. An example of such a task is mutual-exclusion or token passing where the contents of the communication registers must be changed over time e.g. <ref> [9, 10, 15, 20] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 .
Reference: [11] <author> Mohamed G. Gouda and Marco Schneider, </author> <title> "Stabilization of Maximum Flow Trees". Invited talk: </title> <booktitle> Proceedings of the Third Annual Joint Conference on Information Sciences, </booktitle> <month> November </month> <year> 1994. </year> <note> A full version is in preparation for submission to IEEE Transactions on Parallel and Distributed Systems. </note>
Reference-contexts: Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], [2] and <ref> [11, 12] </ref>. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. <p> Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], [2] and <ref> [11, 12] </ref>. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d).
Reference: [12] <author> Mohamed G. Gouda and Marco Schneider, </author> <title> "Maximum Flow Routing". </title> <booktitle> Proc. of The Second Workshop on Self-Stabilizing Systems, UNLV, </booktitle> <pages> pp. </pages> <address> 2.1 - 2.13, </address> <year> 1995. </year>
Reference-contexts: Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], [2] and <ref> [11, 12] </ref>. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. <p> Constructing a spanning tree of the communication graph in a self-stabilizing distributed fashion is addressed in e.g. [9], [2] and <ref> [11, 12] </ref>. The constructed trees are used in [9] for achieving mutual-exclusion, in [2] for performing distributed reset, and in [11, 12] for routing virtual circuits with maximum bandwidth. For a communication graph of diameter d, the self-stabilizing spanning tree construction for semi-uniform systems, presented in [9] requires fi (log d) bits of memory (note that n is an upper bound for d).
Reference: [13] <author> Colette Johnen and Joffroy Beauquier, </author> <title> "Space-Efficient Distributed Self-Stabilizing Depth-First Token Circulation", </title> <booktitle> Proc. of the Second Workshop on Self-Stabilizing Systems, UNLV, </booktitle> <pages> pp. </pages> <address> 4.1-4.15, </address> <year> 1995. </year>
Reference-contexts: A relatively intricate deterministic algorithm for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in <ref> [13] </ref>. The algorithm of [13] is not silent. Our results show that at least (log n) bits per a processor are required for any silent self-stabilizing spanning tree construction algorithm. The reminder of the paper is organized as follows. In the next section we formalize the assumption on distributed system. <p> A relatively intricate deterministic algorithm for constructing a spanning tree in a semi-uniform system using constant size communication registers was presented in <ref> [13] </ref>. The algorithm of [13] is not silent. Our results show that at least (log n) bits per a processor are required for any silent self-stabilizing spanning tree construction algorithm. The reminder of the paper is organized as follows. In the next section we formalize the assumption on distributed system.
Reference: [14] <author> Hua Loo Keng, </author> <title> "Introduction to Number Theory", </title> <publisher> Springer-Verlag, </publisher> <editor> p. </editor> <volume> 243, </volume> <year> 1982. </year>
Reference-contexts: Page 4 Theorem 4.2 There is no silent self-stabilizing leader election algorithm for prime sized uniform rings with constant number of bits per a register. Proof: Let p 1 and p 2 be the number of processors in two rings R1 and R2, respectively. Dirichlet's Theorem (See e.g. <ref> [14] </ref>) states that any arithmetic progression a+ bn with gcd (a,b) = 1 contains infinitely many primes. Thus for infinitely many z, p 1 + zp 2 is prime.
Reference: [15] <author> Amos Israeli and Marc Jalfon, </author> <title> "Token Management Schemes and Random Walks Yield Self Stabilizing Mutual Exclusion", </title> <booktitle> Proc. of the 9th Annual Page 6 ACM Symp. on Principles of Distributed Comput--ing, </booktitle> <pages> pp. 119-131, </pages> <year> 1990. </year>
Reference-contexts: Note that there is a class of tasks that are inherently non silent. An example of such a task is mutual-exclusion or token passing where the contents of the communication registers must be changed over time e.g. <ref> [9, 10, 15, 20] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 . <p> Our research shows that every silent leader election algorithm for arbitrary graphs requires (log n) bits per a communication register. The result is also applicable to an id-based system where processors are augmented with unique identifiers. Note 1 A similar approach has been proposed by <ref> [15] </ref> for proving the memory required to avoid silence (deadlock in the case of mutual exclusion). that in the id-based system processors have at least log n bits for the representation of their identifier.
Reference: [16] <author> Gene Itkis and Leonid Levin, </author> <title> "Fast and lean self-stabilizing asynchronous protocol", </title> <booktitle> Proc. of the 36th Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: Recently, relatively intricate randomized algorithms for leader election with a small amount of memory were proposed by [3] and <ref> [16] </ref>. Our research shows that every silent leader election algorithm for arbitrary graphs requires (log n) bits per a communication register. The result is also applicable to an id-based system where processors are augmented with unique identifiers.
Reference: [17] <author> Gene Itkis, Chengdian Lin and Janos Simon, </author> <title> "Deterministic, Constant Space, Self-Stabilizing Leader Election on Uniform Rings", </title> <booktitle> Proc. of the 9th Workshop on Distributed Algorithms, </booktitle> <year> 1995. </year>
Reference-contexts: To apply the arguments of Theorem 3.1 we choose c out those system configurations in which the special processor is the left most processor in the chain. 4 Leader Election Self-stabilizing leader election algorithms for prime sized uniform rings with constant memory per processor are presented in <ref> [17] </ref>. The algorithm in [17] assumes that the activities in the system are controlled by a central demon [5]. The central demon activates a single processor at a time. Note that the algorithm of [17] cannot be applied to synchronous system wherein processors simultaneously execute a step, since symmetry cannot be <p> apply the arguments of Theorem 3.1 we choose c out those system configurations in which the special processor is the left most processor in the chain. 4 Leader Election Self-stabilizing leader election algorithms for prime sized uniform rings with constant memory per processor are presented in <ref> [17] </ref>. The algorithm in [17] assumes that the activities in the system are controlled by a central demon [5]. The central demon activates a single processor at a time. Note that the algorithm of [17] cannot be applied to synchronous system wherein processors simultaneously execute a step, since symmetry cannot be broken. <p> leader election algorithms for prime sized uniform rings with constant memory per processor are presented in <ref> [17] </ref>. The algorithm in [17] assumes that the activities in the system are controlled by a central demon [5]. The central demon activates a single processor at a time. Note that the algorithm of [17] cannot be applied to synchronous system wherein processors simultaneously execute a step, since symmetry cannot be broken. Our lower bounds can be applied to the central demon model as well. <p> Otherwise, c 0 is a silent configuration with no leader. We can apply our proof to a system with k &lt; n 1=2 . Thus, the at least (log n) bits per register are required for any silent self-stabilizing leader election algorithm. The result in <ref> [17] </ref> is for rings with a prime number of processors. In Theorem 4.1 we have used one silent legal configuration to construct another illegal silent configuration for a ring of a different (smaller) number of processors. <p> If the constructed configuration represents a ring with a composite number of processors then the result of Theorem 4.1 is not applicable to the algorithm presented in <ref> [17] </ref>. For the sake of completeness, we prove in the next Theorem that there is no constant size self-stabilizing silent algorithm for the restricted case of prime sized uniform rings.
Reference: [18] <author> Mehmet Hakan Karaata, Sriram V. Pemmaraju, Steven C. Bruell and Sukumar Ghosh, </author> <title> "Self-Stabilizing Algorithms for Finding Centers and Medians of Trees", </title> <booktitle> Proc. of the 13th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 374, </pages> <year> 1994. </year>
Reference-contexts: The eccentricity of a node in a communication graph is the largest distance from the node to any other node in the graph. A node with minimum eccentricity is called a center of the graph. A simple silent self-stabilizing algorithm for finding the centers of trees is presented in <ref> [18] </ref>. The algorithm uses fi (log n) memory per processor. Our first result shows that at least (log n) bits per a communication register (and hence per processor) are required by any silent self-stabilizing algorithm to find the centers of a graph. <p> A silent system configuration is a configuration such that any run that starts in this configuration is silent 2 . 3 Centers of a Graph A simple silent self-stabilizing algorithm for finding the centers of trees is presented in <ref> [18] </ref>. The algorithm is designed for uniform systems and uses fi (log n) memory bits per a processor. In this section we present a tight lower bound for such an algorithm.
Reference: [19] <author> A. Mayer, Y. Ofek, R. Ostrovsky and M. Yung, </author> <title> "Self-Stabilizing Symmetry Breaking in Constant-Space," </title> <booktitle> Proc. 24th ACM Symp. on Theory of Computing pp. </booktitle> <pages> 378-382, </pages> <year> 1992. </year>
Reference-contexts: The mass production of microprocessors motivates multiprocessing systems in which each processor is equipped with a small amount of memory. In another context, microprocessors are used in switches of high-speed networks to support the distributed coordination (See e.g. <ref> [19] </ref>). Ideally, the amount of memory that such microprocessors is equipped with, is small. This research examines the memory requirements of Page 1 silent self-stabilizing protocols to achieve several funda-mental tasks, including finding the centers of a graph, leader election, and spanning tree construction.
Reference: [20] <author> G. Parlati and M. Yung, </author> <title> "Non-Exploratory Self-Stabilization for Constant-Space Symmetry-Breaking", </title> <booktitle> Proc. 2nd Annual European Symposium on Algorithms, ESA, </booktitle> <pages> pp. 183-201, </pages> <year> 1994. </year>
Reference-contexts: Note that there is a class of tasks that are inherently non silent. An example of such a task is mutual-exclusion or token passing where the contents of the communication registers must be changed over time e.g. <ref> [9, 10, 15, 20] </ref>. In order to prove our lower bounds we assume the existence of a silent legitimate global state and use this state to construct a silent global state that is illegitimate 1 .
Reference: [21] <author> Marco Schneider, </author> <title> "Self-Stabilization", </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 25, No. 1, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: Email: dolev@cs.bgu.ac.il. y Department of Computer Science, The University of Texas at Austin, Austin, Texas 78712-1188, USA, Email: fgouda,marcog@cs.utexas.edu. desirable property is automatic recovery following the occurrence of faults. Automatic recovery is guaranteed when the system is designed to be self-stabilizing <ref> [5, 21] </ref>. A self-stabilizing distributed system converges to a desired behavior starting from any state. In this research we define and investigate a specific class of self-stabilizing algorithms, namely silent self-stabilizing algorithms.
Reference: [22] <author> Marco Schneider, </author> <title> "Flow Routing in Computer Networks", </title> <type> Ph.D. Dissertation, </type> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <note> in preparation, </note> <year> 1996. </year> <title> Page 7 . . . . Non-tree with special processor Non-tree without special processor . . . . . . . . . . . . . . Tree Graph a i a i a k b i a k a k a k e j Page 8 </title>
References-found: 22

