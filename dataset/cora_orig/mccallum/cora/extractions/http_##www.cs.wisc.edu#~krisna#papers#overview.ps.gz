URL: http://www.cs.wisc.edu/~krisna/papers/overview.ps.gz
Refering-URL: http://www.cs.wisc.edu/~krisna/papers/papers.html
Root-URL: 
Email: -bart,markc,jon,rbi,karavan,krishna,newhall-@cs.wisc.edu hollings@cs.umd.edu  
Title: The Paradyn Parallel Performance Measurement Tools system, hardware, and application specific performance data. Paradyn also
Author: Barton P. Miller Mark D. Callaghan Jonathan M. Cargille Jeffrey K. Hollingsworth R. Bruce Irvin Karen L. Karavanic Krishna Kunchithapadam Tia Newhall 
Note: Paradyn's instrumentation can easily be configured to accept new operating  these systems. Current address:  1  
Address: 1210 W. Dayton Street Madison, WI 53706  College Park, MD 20742  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  Computer Science Department, University of Maryland,  
Abstract: Paradyn is based on a dynamic notion of performance instrumentation and measurement. Application programs are placed into execution and then performance instrumentation is inserted into the running programs and modified during execution. Paradyn's Performance Consultant module automatically directs the placement of instrumentation. The Performance Consultant has a well-defined notion of performance bottlenecks and program structure, so that it can associate bottlenecks with specific causes and specific parts of a program. Paradyn controls its instrumentation overhead by monitoring the cost of its data collection, limiting its instrumentation to a (user controllable) threshold. This work is supported in part by Wright Laboratory Avionics Directorate, Air Force Material Command, USAF, under grant F33615-94-1-1525 (ARPA order no. B550), NSF Grants CCR-9100968 and CDA-9024618, Department of Energy Grant DE-FG02-93ER25176, and Office of Naval Research Grant N00014-89-J-1222. Hollingsworth was supported in part by an ARPA Graduate Fellowship in High Performance Computing. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Wright Laboratory Avionics Directorate or the U.S. Government 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. T. Heath and J. A. Etheridge, </author> <title> "Visualizing Performance of Parallel Programs", </title> <booktitle> IEEE Software 8, </booktitle> <month> 5 (Sept </month> <year> 1991), </year> . 
Reference-contexts: Based on our experiences building visi's, we believe that it would not be difficult to build a visi that would provide data to commercial data visualization packages such as AVS [9], or incorporate the visualization displays of systems such as Paragraph <ref> [1] </ref> or Pablo [8]. - 15 - - -- Paradyn's visualization interface is flexible and has been used for other purposes besides visualization, such as evaluating performance predicates for application steering or logging performance data for experiment management.
Reference: 2. <author> J. K. Hollingsworth, B. P. Miller and J. Cargille, </author> <title> "Dynamic Program Instrumentation for Scalable Performance Tools", </title> <booktitle> 1994 Scalable High-Performance Computing Conf., </booktitle> <address> Knoxville, Tenn., </address> <year> 1994. </year>
Reference-contexts: Users can also create an application-specific PCL file that describes details of an application and how it is run. 3. DYNAMIC INSTRUMENTATION Paradyn uses dynamic instrumentation to instrument only those parts of the program relevant to finding the current performance problem <ref> [2] </ref>. Dynamic instrumentation defers instrumenting the program until it is in execution and dynamically inserts, alters, and deletes instrumentation during program execution. This section describes the dynamic instrumentation interface and implementation, how dynamic instrumentation collects mapping information for high-level language views, and how users may describe their own metrics.
Reference: 3. <author> J. K. Hollingsworth and B. P. Miller, </author> <title> "Dynamic Control of Performance Monitoring on Large Scale Parallel Systems", </title> <booktitle> 7th ACM International Conf. on Supercomputing, </booktitle> <address> Tokyo, </address> <month> July </month> <year> 1993, </year> <pages> pp. 185-194. </pages>
Reference-contexts: A single execution of a program may contain several problems. To assist in finding performance problems, Paradyn has a well-defined model, called the W 3 Search Model <ref> [3] </ref>, that organizes information about a program's performance. Paradyn's Performance Consultant module employs the W 3 Search Model to automate the identification of performance problems by using data gathered via dynamic instrumentation. - 11 - - -- 4.1.
Reference: 4. <author> J. K. Hollingsworth, R. B. Irvin and B. P. Miller, </author> <title> "The Integration of Application and System Based Metrics in A Parallel Program Performance Tool", </title> <booktitle> 1991 ACM SIGPLAN Notices Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991, </year> <pages> pp. 189-200. </pages>
Reference-contexts: The Performance Consultant and visualizations receive performance data by specifying one or more metric-focus grids. Paradyn stores performance data internally in a data structure called a time histogram <ref> [4] </ref>. A time histogram (also known as a time-series or time-array) is a fixed-size array whose elements (buckets) store values of a metric for successive time intervals. Two parameters determine the granularity of the data stored in time histograms: initial bucket width (time interval) and number of buckets.
Reference: 5. <author> J. R. Larus and T. Ball, </author> <title> "Rewriting Executable Files to Measure Program Behavior", </title> <journal> SoftwarePractice & Experience 24, </journal> <month> 2 (Feb, </month> <year> 1994), </year> <pages> pp. 197-218. </pages>
Reference-contexts: Instrumentation to precisely count and time events is inserted by dynamically modifying the binary program. A more static approach is a technique that reads an executable file and then generates a modified one with tracing inserted. This technique is used in tools such as Quantify [7] and qpt <ref> [5] </ref>. Quantify and qpt operate on static binaries whereas Dynamic Instrumentation modifies binaries on-the-fly. Several trace-based tools have been designed for performance tuning parallel applications, such as Pablo [8], AIMS [11], and IPS-2 [6].
Reference: 6. <author> B. P. Miller, M. Clark, J. Hollingsworth, S. Kierstead, S. Lim and T. Torzewski, "IPS-2: </author> <title> The Second Generation of a Parallel Program Measurement System", </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 2 (April </month> <year> 1990), </year> <pages> pp. 206-217. </pages>
Reference-contexts: This technique is used in tools such as Quantify [7] and qpt [5]. Quantify and qpt operate on static binaries whereas Dynamic Instrumentation modifies binaries on-the-fly. Several trace-based tools have been designed for performance tuning parallel applications, such as Pablo [8], AIMS [11], and IPS-2 <ref> [6] </ref>. These systems require an application to be re-compiled, then run while trace data is gathered for the entire application, then analyzed post-mortem using the trace data. Such trace-based approaches may have problems with the amount of trace data needed to analyze a single large, long-running application.
Reference: 7. <institution> Quantify User's Guide, Pure Software Inc., </institution> <year> 1993. </year>
Reference-contexts: Instrumentation to precisely count and time events is inserted by dynamically modifying the binary program. A more static approach is a technique that reads an executable file and then generates a modified one with tracing inserted. This technique is used in tools such as Quantify <ref> [7] </ref> and qpt [5]. Quantify and qpt operate on static binaries whereas Dynamic Instrumentation modifies binaries on-the-fly. Several trace-based tools have been designed for performance tuning parallel applications, such as Pablo [8], AIMS [11], and IPS-2 [6].
Reference: 8. <author> D. A. Reed, R. A. Aydt, R. J. Noe, P. C. Roth, K. A. Shields, B. W. Schwartz and L. F. Tavera, </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment, in Scalable Parallel Libraries Conference, </title> <editor> A. Skjellum (editor), </editor> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: This technique is used in tools such as Quantify [7] and qpt [5]. Quantify and qpt operate on static binaries whereas Dynamic Instrumentation modifies binaries on-the-fly. Several trace-based tools have been designed for performance tuning parallel applications, such as Pablo <ref> [8] </ref>, AIMS [11], and IPS-2 [6]. These systems require an application to be re-compiled, then run while trace data is gathered for the entire application, then analyzed post-mortem using the trace data. <p> Based on our experiences building visi's, we believe that it would not be difficult to build a visi that would provide data to commercial data visualization packages such as AVS [9], or incorporate the visualization displays of systems such as Paragraph [1] or Pablo <ref> [8] </ref>. - 15 - - -- Paradyn's visualization interface is flexible and has been used for other purposes besides visualization, such as evaluating performance predicates for application steering or logging performance data for experiment management.
Reference: 9. <author> C. Upson, T. F. Jr., D. Kamins, D. Laidlaw, D. Schlegel, J. Vroom, R. Gurwitz and A. Dam, </author> <title> "The Application Visualization System: A Computational Environment for Scientific Visualization", </title> <booktitle> IEEE Computer Graphics and Application 9, </booktitle> <month> 4 (July </month> <year> 1989), </year> . 
Reference-contexts: Based on our experiences building visi's, we believe that it would not be difficult to build a visi that would provide data to commercial data visualization packages such as AVS <ref> [9] </ref>, or incorporate the visualization displays of systems such as Paragraph [1] or Pablo [8]. - 15 - - -- Paradyn's visualization interface is flexible and has been used for other purposes besides visualization, such as evaluating performance predicates for application steering or logging performance data for experiment management.
Reference: 10. <author> W. Williams, T. Hoel and D. Pase, </author> <title> The MPP Apprentice Performance Tool: Delivering the Performance of the Cray T3D, in Programming Environments for Massively Parallel Distributed Systems, </title> <editor> K. M. Decker and R. M. Rehmann (editors), </editor> <publisher> Birkaeuser Verlag, </publisher> <address> Basel, </address> <year> 1994. </year>
Reference-contexts: These systems require an application to be re-compiled, then run while trace data is gathered for the entire application, then analyzed post-mortem using the trace data. Such trace-based approaches may have problems with the amount of trace data needed to analyze a single large, long-running application. MPP Apprentice <ref> [10] </ref>, a performance tool designed for the Cray T3D, avoids the scaling problem of trace-based tools by using static counters and timers, but does require recompilation of the application to be tuned.

References-found: 10

