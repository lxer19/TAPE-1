URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/papers/kurshan.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/abstract/kurshan.html
Root-URL: http://www.cs.berkeley.edu
Email: k@research.bell-labs.com  
Title: Formal Verification In a Commercial Setting what are they doing? how are they doing it?
Author: R. P. Kurshan 
Keyword: why do formal verification?  
Note: who is doing it today?  
Address: Murray Hill, NJ 07974  
Affiliation: Bell Laboratories  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, R. P. Kurshan, </author> <title> Timing Analysis in COSPAN, </title> <publisher> Springer LNCS 1066 (1996) 220-231. </publisher>
Reference-contexts: Intel (naturally!) has embraced this new technology and reportedly is using it in its current suite of verification tools. Timing verification <ref> [1] </ref> is an area in which the technology has advanced well beyond current practice. However, with a renewed interest in asynchronous design, applications may soon be found.
Reference: [2] <author> B. Brock, M. Kaufmann, J S. Moore, </author> <title> ACL2 Theorems about Commercial Microprocessors, </title> <editor> in M. Srivas and A. </editor> <booktitle> Camilleri (eds) Proceedings of Formal Methods in Computer-Aided Design (FMCAD'96), </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Paradigms Formal verification, even verification applied in commercial projects spans a spectrum from the highly expressive but not-so-automated automated theorem-provers, to the significantly restricted but highly automated model-checkers <ref> [2, 5] </ref>. The theorem-provers have been around for over 35 years, and definitely have their staunch adherents. They have been used extensively in government pilot projects, notably in NASA using SRI's PVS system, but even much earlier with famous theorem-provers like Gypsy.
Reference: [3] <author> J. R. Burch, E. M. Clarke, D. Long, K. L. McMillan, D. L. Dill, </author> <title> Symbolic Model Checking for Sequential Circuit Verification, </title> <journal> IEEE Trans. Computer Aided Design, </journal> <month> 13 </month> <year> (1994) </year> <month> 401-424. </month>
Reference-contexts: The signal came not as a seminal event, but a course of events. Equivalence-checkers had paved a path, showing the utility of even this weak form of model-checking. Bugs were becoming news items even before the notorious Pentium bug. Computers ever faster, memory ever larger and BDD-based algorithms <ref> [3, 9] </ref> made the application of verification technology simpler and simpler: what needed days and advanced techniques only a few years earlier, now could be done automatically in a few hours. The race was on. The what, the how and the future are the subjects of the following sections.
Reference: [4] <author> E. M. Clarke, E. A. Emerson, A. P. Sistla, </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications, </title> <journal> ACM Trans. Prog. Lang. Syst. </journal> <volume> 8, </volume> <year> 1986, </year> <pages> 244-263. </pages>
Reference-contexts: Within model-checking, there are two main approaches: logic-based, and more recently, automaton-based. These two are not at all orthogonal and each can be described in terms of the other. However, the primary logic-based paradigm, based on the logic CTL <ref> [4] </ref> and the primary automaton-based paradigm, based on !- automata [8], are to a large extent incompatible with one another, and their differences are important and fundamental.
Reference: [5] <author> E. M. Clarke, R. P. Kurshan, </author> <title> Computer-Aided Verification, </title> <journal> IEEE Spectrum, </journal> <month> June </month> <year> 1996, </year> <pages> 61-67. </pages>
Reference-contexts: Paradigms Formal verification, even verification applied in commercial projects spans a spectrum from the highly expressive but not-so-automated automated theorem-provers, to the significantly restricted but highly automated model-checkers <ref> [2, 5] </ref>. The theorem-provers have been around for over 35 years, and definitely have their staunch adherents. They have been used extensively in government pilot projects, notably in NASA using SRI's PVS system, but even much earlier with famous theorem-provers like Gypsy. <p> An abstract verified design may be implemented into several different instantiations, saving not the coding time, but the verification time to check the design. In the outward direction, strides already have been made at CMU in word-level model-checking <ref> [5] </ref>, permitting the verification of arithmetic units long thought to be beyond the reach of model-checking. Intel (naturally!) has embraced this new technology and reportedly is using it in its current suite of verification tools.
Reference: [6] <author> R. H. Hardin, Z. Har'El, R. P. Kurshan, COSPAN, </author> <note> Springer LNCS 1102 (1996) 423-427. </note>
Reference-contexts: Most of the reductions tend to be property-dependent localization reductions [8], in which the parts of the design model which are irrelevant to the property being checked, are (automatically) abstracted away. In COSPAN <ref> [6] </ref>, the verification engine of For-malCheck, localization reduction is applied dynamically as illustrated in Fig. 1.
Reference: [7] <author> G. J. Holzmann, </author> <title> Design and Validation of Computer Protocols, </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: There also is a small industrial effort focused on software verification, notably Telelogic's SDT/SDL tool for the protocol specification language SDL. This involves a different execution semantics than is used with hardware (an asynchronous interleaving of local events) <ref> [7] </ref>, which I will not address further.
Reference: [8] <author> R. P. Kurshan, </author> <title> Computer-Aided Verification of Coordinating Processes, </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: Within model-checking, there are two main approaches: logic-based, and more recently, automaton-based. These two are not at all orthogonal and each can be described in terms of the other. However, the primary logic-based paradigm, based on the logic CTL [4] and the primary automaton-based paradigm, based on !- automata <ref> [8] </ref>, are to a large extent incompatible with one another, and their differences are important and fundamental. <p> Since these utilities determine the extent to which a tool will be able to check a range of designs, they could be considered the most critical aspect of a model-checking tool. Most of the reductions tend to be property-dependent localization reductions <ref> [8] </ref>, in which the parts of the design model which are irrelevant to the property being checked, are (automatically) abstracted away. In COSPAN [6], the verification engine of For-malCheck, localization reduction is applied dynamically as illustrated in Fig. 1. <p> In COSPAN [6], the verification engine of For-malCheck, localization reduction is applied dynamically as illustrated in Fig. 1. At each step of the algorithm, the model is adjusted by advancing its free fence of induced primary inputs, in order to discard spurious counterexamples to the stated query <ref> [8] </ref>. which a design model is reduced dynamically, relative to the query being checked. Interfaces A vital part of any commercial verification tool is its user interface. <p> Today, behavioral tends to mean RTL. However, there is a strong movement toward more abstract designs. For now, these too can be represented in VHDL or even Verilog, with the addition of nondeterminism as an abstraction mechanism <ref> [8] </ref>. There are several ways to introduce nondeterminism, but the most direct may be through an added primary input (which then implements a nondeterministic choice operator). <p> The upward direction embraces not only abstraction and top-down (object-oriented of course!) design development as described in the previous section, but also a new notion of code reuse: at the design level <ref> [8] </ref>. An abstract verified design may be implemented into several different instantiations, saving not the coding time, but the verification time to check the design.
Reference: [9] <author> K. L. McMillan, </author> <title> Symbolic Model Checking, </title> <publisher> Kluwer, </publisher> <year> 1993. </year> <note> [10] http://dimacs.rutgers.edu/Workshops/SYLA-Tutorials/program.html </note>
Reference-contexts: The signal came not as a seminal event, but a course of events. Equivalence-checkers had paved a path, showing the utility of even this weak form of model-checking. Bugs were becoming news items even before the notorious Pentium bug. Computers ever faster, memory ever larger and BDD-based algorithms <ref> [3, 9] </ref> made the application of verification technology simpler and simpler: what needed days and advanced techniques only a few years earlier, now could be done automatically in a few hours. The race was on. The what, the how and the future are the subjects of the following sections.
References-found: 9

