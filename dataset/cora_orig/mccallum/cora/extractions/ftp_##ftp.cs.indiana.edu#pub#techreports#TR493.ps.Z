URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR493.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: pierce@cs.indiana.edu  dnt@an-teallach.com  
Title: Local Type Inference  
Author: Benjamin C. Pierce David N. Turner 
Date: November 12, 1997  
Note: An Teallach  
Address: Lindley Hall 215 Bloomington, IN 47405, USA  King's Buildings Edinburgh, EH9 3JL, UK  
Affiliation: Computer Science Department Indiana University  Limited Technology Transfer Center  Indiana University  
Pubnum: CSCI Technical Report #493  
Abstract: We study two partial type inference methods for a language combining subtyping and impredicative poly-morphism. Both methods are local in the sense that missing annotations are recovered using only information from adjacent nodes in the syntax tree, without long-distance constraints such as unification variables. One method infers type arguments in polymorphic applications using a local constraint solver. The other infers annotations on bound variables in function abstractions by propagating type constraints downward from enclosing application nodes. We motivate our design choices by a statistical analysis of the uses of type inference in a sizable body of existing ML code. 
Abstract-found: 1
Intro-found: 1
Reference: [AN91] <author> Shail Aditya and Rishiyur S. Nikhil. </author> <title> Incremental polymorphism. </title> <booktitle> In Functional Programming Languages and Computer Architecture, number 523 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year> <note> Also available as MIT CSG Memo 329, </note> <month> June </month> <year> 1991. </year>
Reference-contexts: The basic idea of bidirectional checking is well known as folklore. Similar ideas have been used, for example, in ML compilers and typecheckers based on attribute-grammars. However, this technique has usually been combined with ML-style type inference (see, e.g., <ref> [AN91] </ref>); it is surprisingly powerful when used by itself as a local type inference method.
Reference: [AW93] <author> Alexander Aiken and Edward L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41. </pages> <publisher> ACM press, </publisher> <year> 1993. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [Boe85] <author> Hans-J. Boehm. </author> <title> Partial polymorphic type inference is undecidable. </title> <booktitle> In 26th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 339-345. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1985. </year>
Reference-contexts: One line of work has been explored by Pfenning [Pfe88, Pfe93], following earlier work of Boehm <ref> [Boe85, Boe89] </ref>. Interestingly, the key algorithm here comes from a proof of undecidability of a certain style of partial type inference, where occurrences of type application must be marked but the type argument itself need not be supplied, and where all other type annotations may be omitted.
Reference: [Boe89] <author> Hans-J. Boehm. </author> <title> Type inference in the presence of type abstraction. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-206, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: One line of work has been explored by Pfenning [Pfe88, Pfe93], following earlier work of Boehm <ref> [Boe85, Boe89] </ref>. Interestingly, the key algorithm here comes from a proof of undecidability of a certain style of partial type inference, where occurrences of type application must be marked but the type argument itself need not be supplied, and where all other type annotations may be omitted.
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant.
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: Our goal is to develop simple, well-behaved type inference techniques for new language designs in the style of Quest <ref> [Car91] </ref>, Pizza [OW97], or ML2000|designs supporting both object-oriented programming idioms and the characteristic coding styles of languages such as ML and Haskell. It has recently become fashionable to refer to these languages as HOT ("higher-order, typed").
Reference: [Car93] <author> Luca Cardelli. </author> <title> An implementation of F &lt;: </title> . <type> Research report 97, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: We know of only one partial type inference scheme that works in the presence of both impredicative polymorphism and subtyping: Cardelli's "greedy type inference algorithm" for F <ref> [Car93] </ref>. The idea here is that any type annotation may be omitted by the programmer: a fresh unification variable ff will be generated for each one by the parser.
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods.
Reference: [CL91] <author> Luca Cardelli and Giuseppe Longo. </author> <title> A semantic basis for Quest. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 417-458, </pages> <month> October </month> <year> 1991. </year> <title> Preliminary version in ACM Conference on Lisp and Functional Program ming, </title> <month> June </month> <year> 1990. </year> <note> Also available as DEC SRC Research Report 55, </note> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant.
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods.
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Decidability of higher-order subtyping with intersection types. </title> <booktitle> In Computer Science Logic, </booktitle> <month> September </month> <year> 1994. </year> <title> Kazimierz, </title> <booktitle> Poland. Springer Lecture Notes in Computer Science 933, </booktitle> <month> June </month> <year> 1995. </year> <note> Also available as University of Edinburgh, LFCS technical report ECS-LFCS-94-281, titled "Subtyping in F ! ^ is decidable". </note>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant. <p> The necessary extension of F ! with polarized type operators is significantly more complex than the form in which F ! is usually studied <ref> [PS94, Com94] </ref>, and its meta-theoretic properties are a matter of current investigation [Ste97]. We are experimenting with strategies for simplifying the system and have achieved some promising preliminary results. Another important avenue for further investigation is the possibility of combining these type inference techniques with overloading.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods. <p> extended to deal with bounded quantifiers (see Section 5 and [PT97a]), but the simple language presented here is enough to show all of the essential ideas and the technical development is easier to follow. 2.1 Syntax Besides the restriction to unbounded quantifiers, we modify the usual definition of System F <ref> [CW85] </ref> in two significant ways. First, we add a minimal type Bot. As we shall see in Section 3, our type inference algorithm keeps track of various type constraints by calculating the least upper bound and greatest lower bound of pairs of types. <p> unsatisfiable; otherwise we arbitrarily choose the lower bound as the value for each variable. 5 Extensions In [PT97a], we show how to extend the local type argument synthesis technique described in Section 3 to an internal language where bounded quantification is allowed (specifically, we treat Cardelli and Wegner's Kernel Fun <ref> [CW85] </ref> extended with Bot).
Reference: [DHKP96] <author> Gilles Dowek, Therese Hardin, Claude Kirchner, and Frank Pfenning. </author> <title> Unification via explicit substitutions: The case of higher-order patterns. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 259-273, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Conversely, Huet's earlier work on efficient semi-algorithms for higher-order unification [Hue75] led directly to a useful semi-algorithm for partial type inference [Pfe88]. Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving <ref> [DHKP96] </ref>, eliminating the troublesome possibilities of nontermination or generation of non-unique solutions. Experience with related algorithms in languages such as LEAP [PL91], Elf [Pfe89], and FX [JG89] has shown them to be quite well behaved in practice.
Reference: [EST95] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proceedings of the 1995 Mathematical Foundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [FF97] <author> Cormac Flanagan and Matthias Felleisen. </author> <title> Componential set-based analysis. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 32(5) </volume> <pages> 235-248, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: and at a fairly fine grain (for individual function definitions rather than whole modules); and (3) "pure" data structures are used instead of mutable state, whenever possible. 1 2 In particular, we are concerned with languages whose type-theoretic core combines subtyping and im-predicative polymorphism in the style of System F <ref> [Gir72, Rey74] </ref>.
Reference: [GP97] <author> Giorgio Ghelli and Benjamin Pierce. </author> <title> Bounded existentials and minimal typing. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: + V Top (VD-Top) X 2 V (VD-Var-1) X + V X S * V U T + V V (VD-Fun) It is easy to check that * V and + V are total functions, for any given set V . (These functions are similar to the ones used in <ref> [GP97] </ref>, but somewhat simpler because of the presence of Bot in our type system.) 3.2.1 Lemma [Soundness]: 1. If S * V T then FV (T) " V = ; and S &lt;: T. 2.
Reference: [GR97] <author> Jaques Garrigue and Didier Remy. </author> <title> Extending ML with semi-explicit polymorphism. </title> <editor> In Martn Abadi and Takayasu Ito, editors, </editor> <booktitle> International Symposium on Theoretical Aspects of Computer Software (TACS), Sendai, Japan, </booktitle> <pages> pages 20-46. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1997. </year> <month> 20 </month>
Reference-contexts: This idea was extended to include first-class (impredicative) universal quantifiers by Remy [Rem94]. Other, more recent, proposals by Odersky and Laufer [OL96] and Remy and Garrigue <ref> [GR97] </ref> conservatively extend ML-style type inference by allowing programmers to explicitly annotate function arguments with types, which may (unlike the annotations that can be inferred automatically) contain embedded universal quantifiers, thus partly bridging the gap between ML and System F.
Reference: [HP95] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year> <note> Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant.
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Boehm showed that this form of type inference was just as hard as higher-order unification, hence undecidable. Conversely, Huet's earlier work on efficient semi-algorithms for higher-order unification <ref> [Hue75] </ref> led directly to a useful semi-algorithm for partial type inference [Pfe88]. Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving [DHKP96], eliminating the troublesome possibilities of nontermination or generation of non-unique solutions.
Reference: [JG89] <author> James W. O'Toole Jr. and David K. Gifford. </author> <title> Type reconstruction with first-class polymorphic values. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, Portland, Oregon, </booktitle> <pages> pages 207-217. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving [DHKP96], eliminating the troublesome possibilities of nontermination or generation of non-unique solutions. Experience with related algorithms in languages such as LEAP [PL91], Elf [Pfe89], and FX <ref> [JG89] </ref> has shown them to be quite well behaved in practice. A different approach to partial type inference (still without subtyping) was initiated by Laufer and Odersky [LO94], sparked by Perry's observation that first-class existential types can be added to ML by integrating them with the datatype mechanism [Per90].
Reference: [JW95] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proceedings of the Second International Static Analysis Symposium, volume 983 of LNCS, </booktitle> <pages> pages 207-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [LO94] <author> Konstantin Laufer and Martin Odersky. </author> <title> Polymorphic type inference and abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 16(5) </volume> <pages> 1411-1430, </pages> <month> September </month> <year> 1994. </year> <note> An earlier version appeared in the Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </note> <year> 1992, </year> <title> under the title "An Extension of ML with First-Class Abstract Types". </title>
Reference-contexts: Experience with related algorithms in languages such as LEAP [PL91], Elf [Pfe89], and FX [JG89] has shown them to be quite well behaved in practice. A different approach to partial type inference (still without subtyping) was initiated by Laufer and Odersky <ref> [LO94] </ref>, sparked by Perry's observation that first-class existential types can be added to ML by integrating them with the datatype mechanism [Per90].
Reference: [Mil92] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14(4) </volume> <pages> 321-358, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The set V allows us to avoid generating nonsensical constraint sets in which bound variables are mentioned outside their scopes (this part of the constraint generation problem is similar to mixed-prefix unification <ref> [Mil92] </ref>). For example, if we are interested in constraining X so that All (Y)()!(Y!Y) is a subtype of All (Y)()!X, we should not return the constraint set fY!Y &lt;: X &lt;: Topg, since Y would be out of scope.
Reference: [OL96] <author> Martin Odersky and Konstantin Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Conference Record of POPL '96: the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 54-67, </pages> <address> St. Petersburg, Florida, </address> <month> January 21-24, </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: This idea was extended to include first-class (impredicative) universal quantifiers by Remy [Rem94]. Other, more recent, proposals by Odersky and Laufer <ref> [OL96] </ref> and Remy and Garrigue [GR97] conservatively extend ML-style type inference by allowing programmers to explicitly annotate function arguments with types, which may (unlike the annotations that can be inferred automatically) contain embedded universal quantifiers, thus partly bridging the gap between ML and System F.
Reference: [OW97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Principles of Programming Languages (POPL), </booktitle> <year> 1997. </year> <note> A preliminary version appeared as Technical Report, 26/96, </note> <institution> University of Karlsruhe, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Our goal is to develop simple, well-behaved type inference techniques for new language designs in the style of Quest [Car91], Pizza <ref> [OW97] </ref>, or ML2000|designs supporting both object-oriented programming idioms and the characteristic coding styles of languages such as ML and Haskell. It has recently become fashionable to refer to these languages as HOT ("higher-order, typed").
Reference: [Per90] <author> Nigel Perry. </author> <title> The Implementation of Practical Functional Programming Languages. </title> <type> PhD thesis, </type> <institution> Imperial College, </institution> <year> 1990. </year>
Reference-contexts: A different approach to partial type inference (still without subtyping) was initiated by Laufer and Odersky [LO94], sparked by Perry's observation that first-class existential types can be added to ML by integrating them with the datatype mechanism <ref> [Per90] </ref>. In essence, datatype constructors and destructors can be regarded as explicit type annotations, marking where values must be injected into and projected from disjoint union types, where recursive types must be folded and unfolded, and (when existentials are added) where packing and unpacking must occur.
Reference: [Pfe88] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, Snowbird, Utah, </booktitle> <pages> pages 153-163. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1988. </year> <note> Also available as Ergo Report 88-048, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: One line of work has been explored by Pfenning <ref> [Pfe88, Pfe93] </ref>, following earlier work of Boehm [Boe85, Boe89]. <p> Boehm showed that this form of type inference was just as hard as higher-order unification, hence undecidable. Conversely, Huet's earlier work on efficient semi-algorithms for higher-order unification [Hue75] led directly to a useful semi-algorithm for partial type inference <ref> [Pfe88] </ref>. Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving [DHKP96], eliminating the troublesome possibilities of nontermination or generation of non-unique solutions.
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322, </pages> <address> Pacific Grove, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving [DHKP96], eliminating the troublesome possibilities of nontermination or generation of non-unique solutions. Experience with related algorithms in languages such as LEAP [PL91], Elf <ref> [Pfe89] </ref>, and FX [JG89] has shown them to be quite well behaved in practice.
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> On the undecidability of partial polymorphic type reconstruction. </title> <note> Fundamenta In-formaticae, 19(1,2):185-199, 1993. Preliminary version available as Technical Report CMU-CS-92-105, </note> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: One line of work has been explored by Pfenning <ref> [Pfe88, Pfe93] </ref>, following earlier work of Boehm [Boe85, Boe89].
Reference: [Pie97] <author> Benjamin C. Pierce. </author> <title> Bounded quantification with bottom. </title> <type> Technical Report 492, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year>
Reference-contexts: All the properties presented here continue to hold for the extended system (including the combination with the bidirectional propagation technique), but the algorithms involved in generating constraint sets become somewhat more subtle, due principally to some surprising interactions between bounded quantifiers and the Bot type <ref> [Pie97] </ref>. (In particular, the intuitive property that "a type variable has no subtypes except itself and Bot" fails to hold; for example, if the context contains X&lt;:Bot, then we have X &lt;: Y for any variable Y.) Moreover, we impose a slight restriction on the types of polymorphic functions for which
Reference: [PL91] <author> Frank Pfenning and Peter Lee. </author> <title> Metacircularity in the polymorphic -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 89(1) </volume> <pages> 137-159, </pages> <month> 21 October </month> <year> 1991. </year> <title> A preliminary version appeared in TAPSOFT '89, </title> <booktitle> Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 345-359, </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: Later improvements in this line of development have included using a more refined algorithm for higher-order constraint solving [DHKP96], eliminating the troublesome possibilities of nontermination or generation of non-unique solutions. Experience with related algorithms in languages such as LEAP <ref> [PL91] </ref>, Elf [Pfe89], and FX [JG89] has shown them to be quite well behaved in practice.
Reference: [Pot97] <author> Francois Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the International Conference on Functional Programming (ICFP), </booktitle> <year> 1997. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [PS94] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> In IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), </booktitle> <year> 1994. </year> <note> Full version in Theoretical Computer Science, </note> <editor> vol. </editor> <volume> 176, no. </volume> <pages> 1-2, pp. 235-282, </pages> <year> 1997. </year>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant. <p> The necessary extension of F ! with polarized type operators is significantly more complex than the form in which F ! is usually studied <ref> [PS94, Com94] </ref>, and its meta-theoretic properties are a matter of current investigation [Ste97]. We are experimenting with strategies for simplifying the system and have achieved some promising preliminary results. Another important avenue for further investigation is the possibility of combining these type inference techniques with overloading.
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in [PT97a] is that Pict includes type operators| formally, it is based on the higher-order extension F ! <ref> [Car90, CL91, PT94, HP95, PS94, Com94] </ref>. Our type argument synthesis technique depends on the fact that type operators like List are covariant in the subtype relation; in the case of F ! , we must also recognize when user-defined type operators are co- or contra-variant.
Reference: [PT97a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Local type argument synthesis with bounded quantification. </title> <type> Technical Report 495, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <month> 21 </month>
Reference-contexts: We consider here a simplified fragment of the full system, in which variables are all unbounded (i.e., all quantifiers are of the form All (X)T, not All (X&lt;:S)T). The treatment here here can be extended to deal with bounded quantifiers (see Section 5 and <ref> [PT97a] </ref>), but the simple language presented here is enough to show all of the essential ideas and the technical development is easier to follow. 2.1 Syntax Besides the restriction to unbounded quantifiers, we modify the usual definition of System F [CW85] in two significant ways. <p> If the condition S &lt;: T fails for any constraint S &lt;: X i &lt;: T, then the constraint set is unsatisfiable; otherwise we arbitrarily choose the lower bound as the value for each variable. 5 Extensions In <ref> [PT97a] </ref>, we show how to extend the local type argument synthesis technique described in Section 3 to an internal language where bounded quantification is allowed (specifically, we treat Cardelli and Wegner's Kernel Fun [CW85] extended with Bot). <p> However, one important set of issues remains incompletely resolved. A significant difference between Pict's type system and the variants of F studied here and in <ref> [PT97a] </ref> is that Pict includes type operators| formally, it is based on the higher-order extension F ! [Car90, CL91, PT94, HP95, PS94, Com94].
Reference: [PT97b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <type> Technical Report CSCI 476, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <title> To appear in Proof, Language and Interaction: Essays in Honour of Robin Milner, </title> <editor> Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, </editor> <publisher> MIT Press. </publisher>
Reference-contexts: It appears that this restriction could be relaxed if a more clever constraint solver were employed, but we do not see how to remove it completely. We have experimented with these and similar type inference techniques in our compiler for the Pict language <ref> [PT97b] </ref>. <p> to T may not be the best possible choice, and this may cause later subtype-checks for types involving ff to fail when a different choice would have allowed them to succeed; but, again, practical experience with this algorithm in Cardelli's implementation and in an early version of the Pict language <ref> [PT97b] </ref> shows that the algorithm's greedy choice is correct in nearly all cases. Unfortunately, there are some situations in which the greedy algorithm is almost guaranteed to guess wrong.
Reference: [Rem89] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, Austin, </booktitle> <pages> pages 242-249. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The most successful design to date is Objective Caml, an object-oriented dialect of ML now in use in a number of software projects worldwide [RV97]. A crucial design choice in Objective Caml is the use of row-variable polymorphism <ref> [Wan87, Wan88, Rem89, Wan94] </ref> instead of subsumption for the typing of objects and classes.
Reference: [Rem94] <author> Didier Remy. </author> <title> Programming objects with ML-ART: An extension to ML with abstract and record types. </title> <editor> In Masami Hagiya and John C. Mitchell, editors, </editor> <booktitle> International Symposium on Theoretical Aspects of Computer Software (TACS), </booktitle> <pages> pages 321-346, </pages> <address> Sendai, Japan, April 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This idea was extended to include first-class (impredicative) universal quantifiers by Remy <ref> [Rem94] </ref>.
Reference: [Rey74] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: and at a fairly fine grain (for individual function definitions rather than whole modules); and (3) "pure" data structures are used instead of mutable state, whenever possible. 1 2 In particular, we are concerned with languages whose type-theoretic core combines subtyping and im-predicative polymorphism in the style of System F <ref> [Gir72, Rey74] </ref>.
Reference: [RV97] <author> Didier Remy and Jerome Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In Conference Record of POPL '97: the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 40-53, </pages> <address> Paris, France, </address> <month> January 15-17, </month> <year> 1997. </year> <note> ACM Press. Full version to appear in Theory and Practice of Object Systems, </note> <year> 1998. </year>
Reference-contexts: The most successful design to date is Objective Caml, an object-oriented dialect of ML now in use in a number of software projects worldwide <ref> [RV97] </ref>. A crucial design choice in Objective Caml is the use of row-variable polymorphism [Wan87, Wan88, Rem89, Wan94] instead of subsumption for the typing of objects and classes.
Reference: [SOW97] <author> Martin Sulzmann, Martin Odersky, and Martin Wehr. </author> <title> Type inference with constrained types. </title> <booktitle> In Fourth International Workshop on Foundations of Object-Oriented Programming (FOOL 4), </booktitle> <month> January </month> <year> 1997. </year> <note> Full version to appear in Theory and Practice of Object Systems, </note> <year> 1998. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [Ste97] <author> Martin Steffen. </author> <type> PhD thesis, </type> <institution> Universitat Erlangen-Nurnberg, </institution> <year> 1997. </year> <type> Forthcoming Ph.D. thesis. </type>
Reference-contexts: The necessary extension of F ! with polarized type operators is significantly more complex than the form in which F ! is usually studied [PS94, Com94], and its meta-theoretic properties are a matter of current investigation <ref> [Ste97] </ref>. We are experimenting with strategies for simplifying the system and have achieved some promising preliminary results. Another important avenue for further investigation is the possibility of combining these type inference techniques with overloading.
Reference: [TS96] <author> Valery Trifonov and Scott Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proceedings of the Third International Static Analysis Symposium, volume 1145 of LNCS, </booktitle> <pages> pages 349-365. </pages> <publisher> Springer Verlag, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable [Wel94], and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported <ref> [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.] </ref>, but practical checkers based on these results have yet to see widespread use.) How Much Inference Is Enough? The job of a partial type inference algorithm should be to eliminate especially those type annotations that are both common and silly|i.e., those that can
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The most successful design to date is Objective Caml, an object-oriented dialect of ML now in use in a number of software projects worldwide [RV97]. A crucial design choice in Objective Caml is the use of row-variable polymorphism <ref> [Wan87, Wan88, Rem89, Wan94] </ref> instead of subsumption for the typing of objects and classes.
Reference: [Wan88] <author> Mitchell Wand. </author> <title> Corrigendum: Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: The most successful design to date is Objective Caml, an object-oriented dialect of ML now in use in a number of software projects worldwide [RV97]. A crucial design choice in Objective Caml is the use of row-variable polymorphism <ref> [Wan87, Wan88, Rem89, Wan94] </ref> instead of subsumption for the typing of objects and classes.
Reference: [Wan94] <author> Mitchell Wand. </author> <title> Type inference for objects with instance variables and inheritance. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design, </booktitle> <pages> pages 97-120. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The most successful design to date is Objective Caml, an object-oriented dialect of ML now in use in a number of software projects worldwide [RV97]. A crucial design choice in Objective Caml is the use of row-variable polymorphism <ref> [Wan87, Wan88, Rem89, Wan94] </ref> instead of subsumption for the typing of objects and classes.
Reference: [Wel94] <author> J. B. Wells. </author> <title> Typability and type checking in the second-order -calculus are equivalent and undecidable. </title> <booktitle> In Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science (LICS), </booktitle> <pages> pages 176-185, </pages> <year> 1994. </year>
Reference-contexts: This combination of features places us in the realm of partial type inference methods, since complete type inference for impredicative polymorphism alone is already known to be undecidable <ref> [Wel94] </ref>, and the addition of subtyping does not seem to make the problem any easier. (For the combination of subtyping with Hindley/Milner-style polymorphic type inference, promising results have recently been reported [AW93, EST95, JW95, TS96, SOW97, FF97, Pot97, etc.], but practical checkers based on these results have yet to see widespread
References-found: 48

