URL: http://polaris.cs.uiuc.edu/reports/1447.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Title: THE POLARIS INTERNAL REPRESENTATION  
Author: BY KEITH AARON FAIGIN B.A., Williams 
Degree: 1992 THESIS Submitted in partial fulfillment of the requirements for the degree of Master of Science in Computer Science in the Graduate College of the  
Address: 1994 Urbana, Illinois  
Affiliation: College,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F. Bodin, P. Beckman, D. Gannon, S. Narayana, and S. Srinivas. Sage++: </author> <title> A Class Library for Building Fortran 90 and C++ Restructuring Tools. </title> <note> Drafter version 0.1. </note>
Reference-contexts: We then, in chapter 5, explore some simple examples which demonstrate the use of Polaris. In chapter 6, Inter-compiler communication is discussed and more detail of the Delta system is given. 1 Another object-oriented transformation system is the Sage++ system <ref> [1] </ref>.
Reference: [2] <author> Rudolf Eigenmann, Jay Hoeflinger, Greg Jaxon, Zhiyuan Li, and David Padua. </author> <title> Restructuring Fortran Programs for Cedar. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 5(7) </volume> <pages> 553-5737, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION The goal of the Polaris system is to provide a new parallelizing compiler that is able to efficiently parallelize Fortran programs for a variety of machines, including massively parallel systems and parallel workstations [6]. Polaris is based on our past experiences with the Cedar Fortran project <ref> [2] </ref>. This project showed us that real programs can be parallelized efficiently and that the techniques needed to achieve good performance are natural extensions of technology available in current parallelizing compilers.
Reference: [3] <author> Keith A. Faigin, Jay P. Hoeflinger, David A. Padua, Paul M. Petersen, and Stephen A. Weatherford. </author> <title> The polaris internal representation. </title> <note> Submitted for publication. </note>
Reference: [4] <author> Kuck and Inc. Associates. </author> <title> KAP for SPARC Fortran User's Guide, </title> <note> beta version 1.0, document 9308006 edition, </note> <year> 1993. </year>
Reference-contexts: Through an intermediate communication language, Polaris can capitalize on the strengths of other systems, such as Delta and KAP <ref> [4] </ref>. Polaris has been used, so far, to implement passes for array privatization, induction variable substitution, forward substitution and inlining. Also, we are close to the completion of FORBOL which is a C ++ extension built on top of our IR which allows complex pattern matching within Polaris.
Reference: [5] <author> P. Lucas and K. </author> <title> Walk. </title> <booktitle> On the formal description of pl/i. Annual Review in Automatic Programming, </booktitle> <volume> 6, Part 3, </volume> <year> 1969. </year>
Reference-contexts: Delta's IR is based loosely on the VDL <ref> [5] </ref> and is represented using labeled arcs. Statements, expressions and symbols are each given distinct labels and stored in maps. Each of these structures are, themselves, maps of sub-structures. Delta is described in more detail in chapter 6.
Reference: [6] <author> D. Padua, R. Eigenmann, J. Hoeflinger, P. Petersen, Peng Tu, S. Weatherford, and K. Faigin. </author> <title> Polaris: A new generation parallelizing compiler for mpps. </title> <type> Technical report, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> June, </month> <year> 1993. </year> <type> CSRD Report 808. </type>
Reference-contexts: INTRODUCTION The goal of the Polaris system is to provide a new parallelizing compiler that is able to efficiently parallelize Fortran programs for a variety of machines, including massively parallel systems and parallel workstations <ref> [6] </ref>. Polaris is based on our past experiences with the Cedar Fortran project [2]. This project showed us that real programs can be parallelized efficiently and that the techniques needed to achieve good performance are natural extensions of technology available in current parallelizing compilers.
Reference: [7] <author> David Padua. </author> <title> The Delta Program Manipulation System. Preliminary Design. </title> <type> Technical report, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> June </month> <year> 1989. </year> <type> CSRD Report 880. </type>
Reference-contexts: Therefore, we decided to use a traditional internal structure for our new compiler enhanced with some features that make it easy to extend and experiment with transformation techniques. This allows us to capitalize on our previous experiences with the KAP/Cedar parallelizing compiler and the Delta program manipulation system (Delta) <ref> [7] </ref>. The implementation of Polaris is based on Delta which was created as an "open experimental laboratory" [8] in which to prototype, develop and test new source-to-source transformations for Fortran 77 parallelizing compilers.
Reference: [8] <author> Paul M. Petersen, Greg P. Jaxon, and David A. Padua. </author> <title> A Gentle Introduction to Delta. </title> <institution> University of Illinois at Urbana-Champaign, Center for Supercomp. Res. & Dev., </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This allows us to capitalize on our previous experiences with the KAP/Cedar parallelizing compiler and the Delta program manipulation system (Delta) [7]. The implementation of Polaris is based on Delta which was created as an "open experimental laboratory" <ref> [8] </ref> in which to prototype, develop and test new source-to-source transformations for Fortran 77 parallelizing compilers.
Reference: [9] <author> J.T. Schwartz, R.B.K. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to Setl. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: On top of this simple structure, however, we can build layers of functionality which allow the IR to emulate more complex forms. Specifically, such forms could include the constructs we found most useful in Delta and the language we used, SETL <ref> [9] </ref>. Delta, as an open system, provided the user with complete access to the internal representation. This was because the SETL implementation we used did not have a good data-abstraction mechanism.
References-found: 9

