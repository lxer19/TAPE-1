URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/SRC-118.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: 118 Conjoining Specifications  
Author: Martn Abadi and Leslie Lamport 
Address: 130 Lytton Avenue Palo Alto, California 94301  
Affiliation: Systems Research Center  
Date: December 7, 1993  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic. Still later, it was noticed that the formula 999 999x : S specifies the same system as S except with the variable x hidden <ref> [1, 13] </ref>, and variable hiding became logical quantification. The idea of composition as conjunction has also been suggested [4, 5, 21], but our method for reducing composition to conjunction is new. To deduce useful properties of a component, we must specify its environment. <p> Under reasonable assumptions, such a refinement mapping exists when M l ) 999 999 x : c M is valid <ref> [1] </ref>. As an example, we show that the system composed of two queues in series, shown in Figure 7, implements a single larger queue. We first specify the composite queue. <p> For example, if Get is defined as in Figure 6, then Get [z=i] equals Ack (o) ^ (z 0 = z). For any formula F , let F <ref> [1] </ref> = F [z=i; q 2 =q] In Figure 8, the specification CDQ of the complete system, consisting of the double queue and its environment, is defined in terms of the formulas from 2 Informally, we write hi; o; qi for the concatenation of the tuples i, o, and hqi. 12 <p> qi (Q M ) Complete System Specification ICQ = ^ Init E ^ Init M ^ 2 _ Q E ^ (q 0 = q) # ^ ICL 13 - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ = ^ Init E ^ Init <ref> [1] </ref> M ^ Init [2] ^ 2 6 6 _ Q E ^ hq 1 ; q 2 ; zi 0 = hq 1 ; q 2 ; zi [1] _ Q M ^ hq 1 ; ii 0 = hq 1 ; ii 7 7 hi; o; z; q 1 <p> - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ = ^ Init E ^ Init <ref> [1] </ref> M ^ Init [2] ^ 2 6 6 _ Q E ^ hq 1 ; q 2 ; zi 0 = hq 1 ; q 2 ; zi [1] _ Q M ^ hq 1 ; ii 0 = hq 1 ; ii 7 7 hi; o; z; q 1 ; q 2 i CDQ = 999 999 q 1 ; q 2 : ICDQ the environment and the two queues. <p> Formally, this means that the closure of Init ^ 2 [N ] v ^ L should be Init ^ 2 [N ] v . A pair of properties (P; L) is called machine closed iff C (P ^ L) equals P <ref> [1] </ref>. (We often say informally that P ^ L is machine closed.) Proposition 1 below, which is proved in [2], shows that we can use fairness properties to write machine-closed specifications. <p> As another example of decomposition, we consider the system of Figure 7, consisting of two queues in series together with an environment. This system can be decomposed into three components with the following speci fications. 1st queue: 999 999 q 1 : Init <ref> [1] </ref> [1] 2nd queue: 999 999 q 2 : Init [2] [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] <p> As another example of decomposition, we consider the system of Figure 7, consisting of two queues in series together with an environment. This system can be decomposed into three components with the following speci fications. 1st queue: 999 999 q 1 : Init <ref> [1] </ref> [1] 2nd queue: 999 999 q 2 : Init [2] [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] M <p> fications. 1st queue: 999 999 q 1 : Init <ref> [1] </ref> [1] 2nd queue: 999 999 q 2 : Init [2] [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] M does not mention o. Similarly, we have conjoined i 0 = i to the second queue's next-state action, and z 0 = z to the environment's. <p> <ref> [1] </ref> [1] 2nd queue: 999 999 q 2 : Init [2] [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] M does not mention o. Similarly, we have conjoined i 0 = i to the second queue's next-state action, and z 0 = z to the environment's. <p> QM , where QM and QE are defined in (7) and (8) of Section 4.1. We now compose two queues, as shown in Figure 7. The specifications of these queues are obtained from QE + . QM by substitution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . <p> QM , where QM and QE are defined in (7) and (8) of Section 4.1. We now compose two queues, as shown in Figure 7. The specifications of these queues are obtained from QE + . QM by substitution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . <p> QM by substitution; they are QE <ref> [1] </ref> + . QM [1] and QE [2] + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . QM [2] ) ) (QE [dbl] + We could prove this had we used a noninterleaving representation of the queue. However, (13) is not valid for an interleaving representation, for the following reason. <p> This solution cannot be used if we want to compose preexisting specifications without modifying them. In this case, we prove that the composition implements the larger queue under the assumption that the 30 outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE <ref> [1] </ref> + . QM [1] ) ^ (QE [2] + . QM [2] ) ) (QE [dbl] + . <p> In this case, we prove that the composition implements the larger queue under the assumption that the 30 outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE <ref> [1] </ref> + . QM [1] ) ^ (QE [2] + . QM [2] ) ) (QE [dbl] + . <p> Stark [20] also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work [3] was semantic, in a more complicated model with agents. It lacked 31 1. C (QE [dbl] ) ^ C (G) ^ C (QM <ref> [1] </ref> ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> Our earlier work [3] was semantic, in a more complicated model with agents. It lacked 31 1. C (QE [dbl] ) ^ C (G) ^ C (QM <ref> [1] </ref> ) ^ C (QM [2] ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> The resulting formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q <p> formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. <p> internal state visible) together with the environment, implements QE <ref> [1] </ref> and QE [2] . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M <p> C (QE [dbl] ) +hi; o; zi ^ C (QM <ref> [1] </ref> ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). <p> C (IQM <ref> [1] </ref> ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. <p> (IQM <ref> [1] </ref> ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 5 (since disjoint ness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C <p> 2 : Init <ref> [1] </ref> M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 5 (since disjoint ness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) C (QM [dbl] ) Proof: We use Propositions 2 and 1 to remove the quantifiers and closures from the formula. The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 4. 3. <p> The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 4. 3. QE [dbl] ^ G ^ QM <ref> [1] </ref> ^ QM [2] ) QM [dbl] Proof: A direct calculation shows that the left-hand side of the implication implies CDQ, the complete-system specification of the double queue. We already observed in Section 3.2 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. <p> We already observed in Section 3.2 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM <ref> [1] </ref> M 3 QM [2] M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] 32 practical proof rules for handling fairness and hiding. Collette [8] adapted this work to Unity. <p> We already observed in Section 3.2 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM <ref> [1] </ref> M 3 QM [2] M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] 32 practical proof rules for handling fairness and hiding. Collette [8] adapted this work to Unity. Abadi and Plotkin [4] used a propositional logic with agents, and considered only safety properties.
Reference: [2] <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <type> Research Report 91, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1992. </year> <title> An earlier version, without proofs, </title> <booktitle> appeared in [9, </booktitle> <pages> pages 1-27]. </pages>
Reference-contexts: Complete System Specification ICQ = ^ Init E ^ Init M ^ 2 _ Q E ^ (q 0 = q) # ^ ICL 13 - i.snd -z.snd Queue1 S n e - o.snd Queue2 R c i e ICDQ = ^ Init E ^ Init [1] M ^ Init <ref> [2] </ref> ^ 2 6 6 _ Q E ^ hq 1 ; q 2 ; zi 0 = hq 1 ; q 2 ; zi [1] _ Q M ^ hq 1 ; ii 0 = hq 1 ; ii 7 7 hi; o; z; q 1 ; q 2 i <p> A pair of properties (P; L) is called machine closed iff C (P ^ L) equals P [1]. (We often say informally that P ^ L is machine closed.) Proposition 1 below, which is proved in <ref> [2] </ref>, shows that we can use fairness properties to write machine-closed specifications. <p> This system can be decomposed into three components with the following speci fications. 1st queue: 999 999 q 1 : Init [1] [1] 2nd queue: 999 999 q 2 : Init <ref> [2] </ref> [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] M does not mention o. <p> This system can be decomposed into three components with the following speci fications. 1st queue: 999 999 q 1 : Init [1] [1] 2nd queue: 999 999 q 2 : Init <ref> [2] </ref> [2] environment: Init E ^ 2 [Q E ^ (z 0 = z)] hi:snd; o:ack i To obtain an interleaving representation, we have conjoined o 0 = o to Q [1] in the first queue's next-state action, because Q [1] M does not mention o. <p> We can apply Proposition 1 to show that the resulting specification is machine closed because, if (P; L) is machine closed and L implies R, then (P; R) is also machine closed <ref> [2, Proposition 3] </ref>. 5.2 The Composition Theorem Suppose we are given n devices, each with an assumption/guarantee specification E j + . M j . To verify that the composition of these devices implements a higher-level assumption/guarantee specification E + . M , we must prove V n + . <p> QM , where QM and QE are defined in (7) and (8) of Section 4.1. We now compose two queues, as shown in Figure 7. The specifications of these queues are obtained from QE + . QM by substitution; they are QE [1] + . QM [1] and QE <ref> [2] </ref> + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . QM [2] ) ) (QE [dbl] + We could prove this had <p> We now compose two queues, as shown in Figure 7. The specifications of these queues are obtained from QE + . QM by substitution; they are QE [1] + . QM [1] and QE <ref> [2] </ref> + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . QM [2] ) ) (QE [dbl] + We could prove this had we used a noninterleaving <p> QM [1] and QE <ref> [2] </ref> + . QM [2] . We want to show that their composition implements the (2N +1)-element queue specified by QE [dbl] + . QM [dbl] . The obvious thing to try to prove is (QE [1] + . QM [2] ) ) (QE [dbl] + We could prove this had we used a noninterleaving representation of the queue. However, (13) is not valid for an interleaving representation, for the following reason. <p> However, a step that changes both z.snd and o.ack violates the second component queue's environment assumption QE <ref> [2] </ref> , permitting the component queue to make arbitrary changes to o.snd in the next step. A similar problem is caused by simultaneous changes to i.snd and z.ack . <p> In this case, we prove that the composition implements the larger queue under the assumption that the 30 outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [1] ) ^ (QE <ref> [2] </ref> + . QM [2] ) ) (QE [dbl] + . <p> In this case, we prove that the composition implements the larger queue under the assumption that the 30 outputs of two different components do not change simultaneously. Thus, we prove G ^ (QE [1] + . QM [1] ) ^ (QE <ref> [2] </ref> + . QM [2] ) ) (QE [dbl] + . <p> Stark [20] also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work [3] was semantic, in a more complicated model with agents. It lacked 31 1. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM <ref> [2] </ref> ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> Our earlier work [3] was semantic, in a more complicated model with agents. It lacked 31 1. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM <ref> [2] </ref> ) ) QE [1] ^ QE [2] Proof: We use Propositions 2 and 1 to remove the quantifiers and closure operators from the left-hand side of the implication. <p> The resulting formula then asserts that a complete system, consisting of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q <p> of the safety parts of the two queues (with their internal state visible) together with the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) <p> the environment, implements QE [1] and QE <ref> [2] </ref> . The proof of this formula is straightforward. 2. C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM [2] ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 <p> C (QE [dbl] ) +hi; o; zi ^ C (QM [1] ) ^ C (G) ^ C (QM <ref> [2] </ref> ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. <p> C (QM <ref> [2] </ref> ) ) C (QM [dbl] ) 2.1.1. C (IQM [1] ) ^ C (IQM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 5 (since disjoint ness is a safety property). 2.2. <p> C (IQM <ref> [2] </ref> ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: Follows easily from Proposition 1 and the definitions. 2.1.2. C (QM [1] ) ^ C (QM [2] ) ) 9 q 1 ; q 2 : Init [1] M ^ Init [2] Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 5 (since disjoint ness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) <p> ^ Init <ref> [2] </ref> Proof: 2.1.1 and Proposition 2 (since any predicate is a safety prop erty). 2.1.3. Q.E.D. Proof: 2.1.2, the definition of G, and Proposition 5 (since disjoint ness is a safety property). 2.2. C (QE [dbl] ) ^ C (G) ^ C (QM [1] ) ^ C (QM [2] ) ) C (QM [dbl] ) Proof: We use Propositions 2 and 1 to remove the quantifiers and closures from the formula. The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 4. 3. <p> The resulting formula is proved when proving the safety part of step 3. 2.3. Q.E.D. Proof: 2.1, 2.2, and Proposition 4. 3. QE [dbl] ^ G ^ QM [1] ^ QM <ref> [2] </ref> ) QM [dbl] Proof: A direct calculation shows that the left-hand side of the implication implies CDQ, the complete-system specification of the double queue. We already observed in Section 3.2 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. <p> We already observed in Section 3.2 that CDQ implements CQ [dbl] , which equals QE [dbl] ^ QM [dbl] . 4. Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM [1] M 3 QM <ref> [2] </ref> M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] 32 practical proof rules for handling fairness and hiding. Collette [8] adapted this work to Unity. Abadi and Plotkin [4] used a propositional logic with agents, and considered only safety properties. <p> Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM [1] M 3 QM <ref> [2] </ref> M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] 32 practical proof rules for handling fairness and hiding. Collette [8] adapted this work to Unity. Abadi and Plotkin [4] used a propositional logic with agents, and considered only safety properties. <p> Our proofs employ many lemmas. We omit the proofs of some of the simpler ones. We also omit the proof of Proposition 1, which is given in <ref> [2] </ref>. A.2.1 Properties of . and + . The proofs of most of these properties are straightforward and are omitted. Some of the basic arguments about . can be found in [4]. Lemma 1 If P , Q, and R are safety properties, then 1. P .
Reference: [3] <author> Martn Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Because E + . M is equivalent to C (E) + . (C (M ) ^ (E ) M )), we can in principle convert any assumption/guarantee specification to one whose assumption is a safety property. (A similar observation appears as Theorem 1 of <ref> [3] </ref>.) However, this equivalence is of intellectual interest only. <p> To handle liveness, he wrote assumption/guarantee specifications with implication instead of + ., so he did not obtain a strong composition theorem. Stark [20] also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work <ref> [3] </ref> was semantic, in a more complicated model with agents. It lacked 31 1.
Reference: [4] <author> Martn Abadi and Gordon Plotkin. </author> <title> A logical view of composition and refinement. </title> <journal> Theoretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 3-30, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Still later, it was noticed that the formula 999 999x : S specifies the same system as S except with the variable x hidden [1, 13], and variable hiding became logical quantification. The idea of composition as conjunction has also been suggested <ref> [4, 5, 21] </ref>, but our method for reducing composition to conjunction is new. To deduce useful properties of a component, we must specify its environment. No component will exhibit its intended behavior in the presence of a sufficiently hostile environment. <p> Proposition 4 below provides a way of proving these hypotheses for interleaving specifications without having to calculate E +v . 3.5.2 . For temporal formulas E and M , the formula E . M asserts that M holds at least as long as E does <ref> [4] </ref>. More precisely E . M is true of a behavior iff E ) M is true of and of every finite prefix of . Thus, E . M equals (C (E) . C (M )) ^ (E ) M ). The operator . acts much like ordinary implication. <p> Collette [8] adapted this work to Unity. Abadi and Plotkin <ref> [4] </ref> used a propositional logic with agents, and considered only safety properties. Most previous papers were concerned only with composition of assumption/guarantee specifications, and lacked an analog of our Decomposition Theorem. <p> We also omit the proof of Proposition 1, which is given in [2]. A.2.1 Properties of . and + . The proofs of most of these properties are straightforward and are omitted. Some of the basic arguments about . can be found in <ref> [4] </ref>. Lemma 1 If P , Q, and R are safety properties, then 1. P . Q and P + . Q are safety properties. 2. j= P ) (Q . R) if and only if j= P ^ Q ) R.
Reference: [5] <author> S. Abramsky and R. Jagadeesan. </author> <title> Games and full completeness for multiplicative linear logic. </title> <type> Technical Report DoC 92/24, </type> <institution> Department of Computing, Imperial College of Science, Technology, and Medicine, </institution> <year> 1992. </year>
Reference-contexts: Still later, it was noticed that the formula 999 999x : S specifies the same system as S except with the variable x hidden [1, 13], and variable hiding became logical quantification. The idea of composition as conjunction has also been suggested <ref> [4, 5, 21] </ref>, but our method for reducing composition to conjunction is new. To deduce useful properties of a component, we must specify its environment. No component will exhibit its intended behavior in the presence of a sufficiently hostile environment.
Reference: [6] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: This argument does not apply to the second example, because violating M 1 c and M 1 7 are sins of omission that do not occur at any particular instant. A property that can be made false only by being violated at some instant is called a safety property <ref> [6] </ref>. As the examples suggest, reasoning about the composition of assumption/guarantee specifications is easiest when assumptions are safety properties. <p> For convenience, we say that the empty sequence h i satisfies every formula. A safety property is a formula that is satisfied by an infinite behavior iff it is satisfied by every prefix of <ref> [6] </ref>. For any predicate Init, action 15 N , and state function v, the formula Init ^ 2 [N ] v is a safety property.
Reference: [7] <author> Christian Berthet and Eduard Cerny. </author> <title> An algebraic model for asynchronous circuits verification. </title> <journal> IEEE Transactions On Computers, </journal> <volume> 37(7) </volume> <pages> 835-847, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Abadi and Plotkin [4] used a propositional logic with agents, and considered only safety properties. Most previous papers were concerned only with composition of assumption/guarantee specifications, and lacked an analog of our Decomposition Theorem. An exception is the work of Berthet and Cerny <ref> [7] </ref>, who used decomposition in proving safety properties for finite-state automata. So far, we have applied our Composition Theorem only to toy examples. Formal reasoning about systems is still rare, and it generally occurs on a case-by-case basis.
Reference: [8] <author> Pierre Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, TAP-SOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 230-242, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Q.E.D. Proof: 1-3 and the Composition Theorem, substituting M 1 G M 2 QM [1] M 3 QM [2] M QM [dbl] E 1 true E 2 QE [1] E 3 QE [2] E QE [dbl] 32 practical proof rules for handling fairness and hiding. Collette <ref> [8] </ref> adapted this work to Unity. Abadi and Plotkin [4] used a propositional logic with agents, and considered only safety properties. Most previous papers were concerned only with composition of assumption/guarantee specifications, and lacked an analog of our Decomposition Theorem.
Reference: [9] <editor> J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <title> Proceedings of a REX Real-Time Workshop, held in The Netherlands in June, </title> <year> 1991. </year>
Reference: [10] <author> Cliff B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of 59 the IFIP 9th World Congress, </booktitle> <pages> pages 321-332. </pages> <publisher> IFIP, North-Holland, </publisher> <month> September </month> <year> 1983. </year>
Reference-contexts: When specifying a reusable component, without knowing precisely where it will be used, we must make explicit what it assumes of its environment. We therefore assert that the component satisfies a guarantee M only as long as its environment satisfies an assumption E. This assumption/guarantee property <ref> [10] </ref> is denoted E + . M . To show that a composition of reusable components satisfies a specification S, we must prove a formula of the form (E 1 + . M n ) ) S, where S may again be an assumption/guarantee property.
Reference: [11] <author> R. P. Kurshan and Leslie Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. In Costas Courcoubetis, editor, Computer-Aided Verification, </title> <booktitle> volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 166-179, </pages> <address> Berlin, </address> <month> June </month> <year> 1993. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fifth International Conference, </booktitle> <address> CAV'93. </address>
Reference-contexts: It reduces the verification of a complex, low-level system to proving properties of a higher-level specification and properties of one low-level component at a time. Decomposing proofs in this way allows us to apply decision procedures to verifications that hitherto required completely hand-guided proofs <ref> [11] </ref>. When specifying a reusable component, without knowing precisely where it will be used, we must make explicit what it assumes of its environment. We therefore assert that the component satisfies a guarantee M only as long as its environment satisfies an assumption E. <p> The General Decomposition Theorem has been applied to the verification of an inductively-defined multiplier circuit <ref> [11] </ref>. It can be shown that both versions of our decomposition theorem provide complete rules for verifying that one composition implies another. However, this result is of no significance. <p> This approach is currently being pursued in one substantial example: the mechanical verification of a multiplier circuit using a combination of TLA reasoning and mechanical verification with COSPAN <ref> [11] </ref>. Because it eliminates reasoning about the complete low-level system, the Decomposition Theorem is the key to this division of labor. Acknowledgements Yuan Yu provided helpful comments on an earlier version. 33 34 A Appendix We now prove our propositions and theorems.
Reference: [12] <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference-contexts: The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli [18]. It was later observed that, if specifications allow "stuttering" steps that leave the state unchanged, then S l ) S h asserts that S l implements S h <ref> [12] </ref>. Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic.
Reference: [13] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic. Still later, it was noticed that the formula 999 999x : S specifies the same system as S except with the variable x hidden <ref> [1, 13] </ref>, and variable hiding became logical quantification. The idea of composition as conjunction has also been suggested [4, 5, 21], but our method for reducing composition to conjunction is new. To deduce useful properties of a component, we must specify its environment.
Reference: [14] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year> <note> To appear in Transactions on Programming Languages and Systems. </note>
Reference-contexts: It does not require a conventional programming language for describing systems. We find it most convenient to regard programs and circuit descriptions as low-level specifications, and to represent them in the same logic used for higher-level specifications. The logic we use is TLA, the Temporal Logic of Actions <ref> [14] </ref>. We do not discuss here the important problem of translating from a low-level TLA specification to an implementation in a conventional language. The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli [18]. <p> The formula M l ) M is proved by applying a handful of simple rules <ref> [14] </ref>. <p> by showing ICDQ ) ICQ [dbl] , with the refinement mapping defined by q = if z :sig = z :ack then q 1 ffi q 2 else q 1 ffi hz :vali ffi q 2 The formula ICDQ ) ICQ [dbl] can be proved by standard TLA reason ing <ref> [14] </ref>. 3.3 Conditional Implementation Instead of proving that a specification M l implements a specification M , we sometimes want to prove the weaker condition that M l implements M assuming a formula G.
Reference: [15] <author> Carver Mead and Lynn Conway. </author> <title> Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1980. </year>
Reference-contexts: consider systems that communicate by using a standard 4 initial state 37 sent 37 acked 4 sent 4 acked 19 sent c.ack : 0 0 1 1 0 0 : : : c.val : 37 37 4 4 19 : : : - i.snd - o.snd Queue two-phase handshake protocol <ref> [15] </ref> to send values over channels. The state of a channel c is described by three components: the value c.val that is being sent, and two bits c.sig and c.ack used for synchronization. We let c:snd denote the pair hc:sig; c:vali. <p> This problem is not an artifact of our particular representation of the queue; actual hardware implementations of a queue can enter metastable states, consequently producing bizarre, unpredictable behavior, if their inputs are changed when they are not supposed to be <ref> [15] </ref>. A specification of the queue should allow executions in which the queue performs correctly; it should not rule out bad behavior of the queue caused by the environment performing incorrectly.
Reference: [16] <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(4):417-426, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: Like ours, most previous composition theorems were strong, in the sense that they could handle circularities for safety properties. Our approach differs from earlier ones in its general treatment of fairness and hiding. The first strong composition theorem we know is that of Misra and Chandy <ref> [16] </ref>, who considered safety properties of processes communicating by means of CSP primitives. They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph [17] extended this approach to handle some liveness properties. Pnueli [19] was the first to use temporal logic to write assumption/guarantee specifications.
Reference: [17] <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logic|a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference-contexts: The first strong composition theorem we know is that of Misra and Chandy [16], who considered safety properties of processes communicating by means of CSP primitives. They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph <ref> [17] </ref> extended this approach to handle some liveness properties. Pnueli [19] was the first to use temporal logic to write assumption/guarantee specifications. He had a strong composition theorem for safety properties with no hiding.
Reference: [18] <author> Amir Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-80, </pages> <year> 1981. </year>
Reference-contexts: We do not discuss here the important problem of translating from a low-level TLA specification to an implementation in a conventional language. The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli <ref> [18] </ref>. It was later observed that, if specifications allow "stuttering" steps that leave the state unchanged, then S l ) S h asserts that S l implements S h [12]. Hence, proving that a lower-level specification implements a higher-level one was reduced to proving a formula in the logic.
Reference: [19] <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI Series, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1984. </year>
Reference-contexts: They wrote assumption/guarantee specifications as Hoare triples containing assertions about history variables. Pandya and Joseph [17] extended this approach to handle some liveness properties. Pnueli <ref> [19] </ref> was the first to use temporal logic to write assumption/guarantee specifications. He had a strong composition theorem for safety properties with no hiding. To handle liveness, he wrote assumption/guarantee specifications with implication instead of + ., so he did not obtain a strong composition theorem.
Reference: [20] <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> Foundations of Software Technology and The 60 oretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391, </pages> <address> Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Pnueli [19] was the first to use temporal logic to write assumption/guarantee specifications. He had a strong composition theorem for safety properties with no hiding. To handle liveness, he wrote assumption/guarantee specifications with implication instead of + ., so he did not obtain a strong composition theorem. Stark <ref> [20] </ref> also wrote assumption/guarantee specifications as implications of temporal formulas and required that circularity be avoided. Our earlier work [3] was semantic, in a more complicated model with agents. It lacked 31 1.

References-found: 20

