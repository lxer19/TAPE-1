URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers/intensional/tr.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Compiling Polymorphism Using Intensional Type Analysis  
Author: Robert Harper Greg Morrisett 
Note: Also published as Fox Memorandum CMU-CS-FOX-94-07 This research was sponsored by the Defense Advanced Research Projects Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: September 2, 1994  
Pubnum: CMU-CS-94-185  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin. </address> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: term level. (The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction [9, 22].) At the term level typerec may be thought of as a generalization of the typecase operation associated with the type dynamic <ref> [1] </ref> that provides for the definition of a term by induction on the structure of a monotype. At the constructor level Typerec provides a similar ability to define a constructor by induction on the structure of a monotype. <p> e ) ( 0 ; flt::: e 0 ) ` e [] ) v (trec-int) ` e i ) v ` typerec [t:](; e i ; e fi ; e ! ) ) v (NF () = Int) (trec-pair) ` @ [ 2 =t] (@ [ 1 =t] (e fi <ref> [ 1 ] </ref>[ 2 ]) (typerec [t:]( 1 ; e i ; e fi ; e ! )))(typerec [t:]( 1 ; e i ; e fi ; e ! )) ) v ` typerec [t:](; e i ; e fi ; e ! ) ) v (NF () = fi ( <p> )))(typerec [t:]( 1 ; e i ; e fi ; e ! )) ) v ` typerec [t:](; e i ; e fi ; e ! ) ) v (NF () = fi ( 1 ; 2 )) (trec-fn) ` @ [ 2 =t] (@ [ 1 =t] (e ! <ref> [ 1 ] </ref>[ 2 ]) (typerec [t:]( 1 ; e i ; e fi ; e ! )))(typerec [t:]( 1 ; e i ; e fi ; e ! )) ) v ` typerec [t:](; e i ; e fi ; e ! ) ) v (NF () = !( 1 <p> To simplify the presentation we usually define terms such as zero and sizeof using recursion equations, rather than as a typerec expression. The definitions of zero and sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof <ref> [ 1 ] </ref> + sizeof [ 2 ] sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever <p> sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof <ref> [ 1 ] </ref> + sizeof [ 2 ] sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 3 Flattening We consider the "flat" representation of Mini-ML tuples in which <p> In particular, access to components is not constant time, given a standard implementation of the pairing and projection operations. This may be overcome by extending ML i with n-tuples (tuples of variable arity), and modifying the interpretation of the product type as follows: Prod <ref> [ 1 ] </ref>[ 2 ] = Append [Tuple (ToList 1 )][Tuple (ToList 1 )] The Tuple constructor has kind ? ! , where ? is the kind of lists whose elements are constructors of kind . <p> fi t 2 j t = Prod [Box [jt 1 j t ]][Box [jt 2 j t ]] jt 1 fi [ t 2 j t = Prod [jt 1 j t ][jt 2 j t ] 12 The constructor Prod is extended to treat boxed types atomically: Prod [Box <ref> [ 1 ] </ref>][ 2 ] = fi (Box [ 1 ]; 2 ) Through the use of boxing we may control the trade-off between time and layout constraints. The interpretation of the boxing and unboxing primitives is left unspecified. <p> [jt 1 j t ]][Box [jt 2 j t ]] jt 1 fi [ t 2 j t = Prod [jt 1 j t ][jt 2 j t ] 12 The constructor Prod is extended to treat boxed types atomically: Prod [Box <ref> [ 1 ] </ref>][ 2 ] = fi (Box [ 1 ]; 2 ) Through the use of boxing we may control the trade-off between time and layout constraints. The interpretation of the boxing and unboxing primitives is left unspecified. The simplest interpretation is heap allocation | values of type boxed () are pointers to values of type . <p> The "recursive" wrap and unwrap operations considered by Leroy may be defined as follows: wrap [Int] = box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] <p> The "recursive" wrap and unwrap operations considered by Leroy may be defined as follows: wrap [Int] = box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; <p> follows: wrap [Int] = box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ <p> = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 <p> [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and <p> <ref> [ 1 ] </ref>; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). <p> 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap <ref> [ 1 ] </ref> fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). <p> identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap <ref> [ 1 ] </ref> fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). These definitions can be encoded in a single typerec that returns a pair consisting of the two functions. <p> These definitions can be encoded in a single typerec that returns a pair consisting of the two functions. The constructor Wrap :: ! is defined as follows: Wrap [Int] = Box [Int] Wrap [Box []] = Box [] Wrap [fi ( 1 ; 2 )] = fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ]) Wrap [!( 1 ; 2 )] = !(Wrap [ 1 ]; Wrap [ 2 ]) With this definition in mind, it is easy to check that wrap : 8t:::T (t) ! T (Wrap [t]) unwrap : 8t:::T (Wrap [t]) ! T (t) 5 Marshalling <p> The constructor Wrap :: ! is defined as follows: Wrap [Int] = Box [Int] Wrap [Box []] = Box [] Wrap [fi ( 1 ; 2 )] = fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ]) Wrap [!( 1 ; 2 )] = !(Wrap [ 1 ]; Wrap [ 2 ]) With this definition in mind, it is easy to check that wrap : 8t:::T (t) ! T (Wrap [t]) unwrap : 8t:::T (Wrap [t]) ! T (t) 5 Marshalling Ohori and Kato give an extension of ML with primitives for distributed computing in a <p> The name newid stems from the representation scheme, which is defined as follows: Trans [Int] = Int Trans [!( 1 ; 2 )] = Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])] Trans [fi ( 1 ; 2 )] = fi (Trans [ 1 ]; Trans [ 2 ]) Trans [Id []] = Id [] A value of type T (Trans []) has no arrow types. <p> The name newid stems from the representation scheme, which is defined as follows: Trans [Int] = Int Trans [!( 1 ; 2 )] = Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])] Trans [fi ( 1 ; 2 )] = fi (Trans [ 1 ]; Trans [ 2 ]) Trans [Id []] = Id [] A value of type T (Trans []) has no arrow types. Instead, !( 1 ; 2 ) is replaced with an Id [] constructor. <p> These are defined simultaneously as follows using the unofficial syntax: M : 8t :: :T (t) ! T (Trans [t]) M [Int] = x : int:x M [!( 1 ; 2 )] = f : T (!( 1 ; 2 )):newid <ref> [ 1 ] </ref>[ 2 ](x : T (Trans [ 1 ]): M [ 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; <p> These are defined simultaneously as follows using the unofficial syntax: M : 8t :: :T (t) ! T (Trans [t]) M [Int] = x : int:x M [!( 1 ; 2 )] = f : T (!( 1 ; 2 )):newid <ref> [ 1 ] </ref>[ 2 ](x : T (Trans [ 1 ]): M [ 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans <p> the unofficial syntax: M : 8t :: :T (t) ! T (Trans [t]) M [Int] = x : int:x M [!( 1 ; 2 )] = f : T (!( 1 ; 2 )):newid <ref> [ 1 ] </ref>[ 2 ](x : T (Trans [ 1 ]): M [ 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans [ 2 ])]): x <p> :: :T (t) ! T (Trans [t]) M [Int] = x : int:x M [!( 1 ; 2 )] = f : T (!( 1 ; 2 )):newid <ref> [ 1 ] </ref>[ 2 ](x : T (Trans [ 1 ]): M [ 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans [ 2 ])]): x : T ( 1 ): U <p> 1 ]): M [ 2 ](f (U <ref> [ 1 ] </ref> x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans [ 2 ])]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( <p> x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x <p> 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x At arrow types, M converts the function <p> ; 2 )] = f : T (Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with <p> (Id [!(Trans <ref> [ 1 ] </ref>; Trans [ 2 ])]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> Definitional equality can be used to determine membership in the class. For example, the class of types that admit equality can be defined using Typerec as follows: Eq :: ! Eq [Bool] = Bool Eq [fi ( 1 ; 2 )] = fi (Eq <ref> [ 1 ] </ref>; Eq [ 2 ]) Eq [!( 1 ; 2 )] = Void Eq [Void] = Void Here, Eq serves as a predicate on types in the sense that a non-Void constructor is definitionally equal to Eq [] only if is a constructor that does not contain the constructor
Reference: [2] <author> Martn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> April </month> <year> 1991. </year> <note> Revised version of [1]. </note>
Reference-contexts: ; ] fx : 8t 1 ; : : : ; t n :t 0 g . e : t given below: (kinds) ::= j 1 ! 2 (con's) ::= t j Int j !( 1 ; 2 ) j fi ( 1 ; 2 ) j t::: j 1 <ref> [ 2 ] </ref> j Typerec (; i ; fi ; ! ) (types) ::= T () j int j 1 ! 2 j 1 fi 2 j 8t::: (terms) e ::= x j n j he 1 ; e 2 i 1 ; 2 j 1 ; 2 1 ; 2 <p> Int :: . !( 1 ; 2 ) :: . fi ( 1 ; 2 ) :: . t :: 1 : :: 1 ! 2 . 1 <ref> [ 2 ] </ref> :: . ! :: ! ! ! ! . Typerec (; i ; fi ; ! ) :: ] ft :: 0 g . 1 :: . 2 :: 0 . i :: . fi :: ! ! ! ! . <p> The definitions of zero and sizeof are given in this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in <p> this form as follows: sizeof [Int] = 1 sizeof [fi ( 1 ; 2 )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 3 Flattening We consider the "flat" representation of Mini-ML tuples in which nested tuples are represented <p> )] = sizeof [ 1 ] + sizeof <ref> [ 2 ] </ref> sizeof [!( 1 ; 2 )] = 1 zero [Int] = 0 zero [fi ( 1 ; 2 )] = hzero [ 1 ]; zero [ 2 ]i zero [!( 1 ; 2 )] = x:T ( 1 ):zero [ 2 ] Whenever a definition is presented in this form we tacitly assert that it can be formalized using typerec. 3 Flattening We consider the "flat" representation of Mini-ML tuples in which nested tuples are represented by a sequence of "atomic" values (for the present purposes, any non-tuple is regarded <p> Otherwise the ordinary 11 pair (i.e., 2-tuple) of the types is formed. The constructors Append and ToList are defined using Typerec and Listrec as follows: Append [Nil][] = Append [Cons ( 1 ; 2 )][] = Cons ( 1 ; Append <ref> [ 2 ] </ref>[]) ToList [Int] = Cons (Int; Nil) ToList [!( 1 ; 2 )] = Cons (!( 1 ; 2 ); Nil) ToList [Tuple ()] = A rigorous formulation of the target language extended with n-tuples is tedious, but appears to be straightforward. 4 Boxing When type arguments to polymorphic <p> The "recursive" wrap and unwrap operations considered by Leroy may be defined as follows: wrap [Int] = box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] <p> "recursive" wrap and unwrap operations considered by Leroy may be defined as follows: wrap [Int] = box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ <p> box [Int] wrap [Box []] = identity [Box []] wrap [fi ( 1 ; 2 )] = box [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ <p> [fi ( 1 ; 2 )] = box [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] ffi (wrap [ 1 ] fi wrap [ 2 ]) wrap [!( 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap [ 2 ])] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap <p> 1 ; 2 )] = box [!(Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are <p> <ref> [ 2 ] </ref>)] ffi (unwrap [ 1 ] ! wrap [ 2 ]) unwrap [Int] = unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap [ 2 ]) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). <p> unbox [Int] unwrap [Box []] = identity [Box []] unwrap [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap <ref> [ 2 ] </ref>) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). These definitions can be encoded in a single typerec that returns a pair consisting of the two functions. <p> [fi ( 1 ; 2 )] = (unwrap [ 1 ] fi unwrap <ref> [ 2 ] </ref>) ffi unbox [fi (Wrap [ 1 ]; Wrap [ 2 ])] unwrap [!( 1 ; 2 )] = (wrap [ 1 ] ! unwrap [ 2 ]) ffi unbox [!(Wrap [ 1 ]; Wrap [ 2 ])] (where ffi is function composition and product and function spaces are extended to functions in the usual way). These definitions can be encoded in a single typerec that returns a pair consisting of the two functions. <p> The constructor Wrap :: ! is defined as follows: Wrap [Int] = Box [Int] Wrap [Box []] = Box [] Wrap [fi ( 1 ; 2 )] = fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>) Wrap [!( 1 ; 2 )] = !(Wrap [ 1 ]; Wrap [ 2 ]) With this definition in mind, it is easy to check that wrap : 8t:::T (t) ! T (Wrap [t]) unwrap : 8t:::T (Wrap [t]) ! T (t) 5 Marshalling Ohori and Kato give <p> The constructor Wrap :: ! is defined as follows: Wrap [Int] = Box [Int] Wrap [Box []] = Box [] Wrap [fi ( 1 ; 2 )] = fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>) Wrap [!( 1 ; 2 )] = !(Wrap [ 1 ]; Wrap [ 2 ]) With this definition in mind, it is easy to check that wrap : 8t:::T (t) ! T (Wrap [t]) unwrap : 8t:::T (Wrap [t]) ! T (t) 5 Marshalling Ohori and Kato give an extension of ML with primitives for distributed computing in a hetrogenous environment [42]. <p> The name newid stems from the representation scheme, which is defined as follows: Trans [Int] = Int Trans [!( 1 ; 2 )] = Id [!(Trans [ 1 ]; Trans <ref> [ 2 ] </ref>)] Trans [fi ( 1 ; 2 )] = fi (Trans [ 1 ]; Trans [ 2 ]) Trans [Id []] = Id [] A value of type T (Trans []) has no arrow types. Instead, !( 1 ; 2 ) is replaced with an Id [] constructor. <p> The name newid stems from the representation scheme, which is defined as follows: Trans [Int] = Int Trans [!( 1 ; 2 )] = Id [!(Trans [ 1 ]; Trans <ref> [ 2 ] </ref>)] Trans [fi ( 1 ; 2 )] = fi (Trans [ 1 ]; Trans [ 2 ]) Trans [Id []] = Id [] A value of type T (Trans []) has no arrow types. Instead, !( 1 ; 2 ) is replaced with an Id [] constructor. It is easy to check that Trans is a constructor of kind ! . <p> simultaneously as follows using the unofficial syntax: M : 8t :: :T (t) ! T (Trans [t]) M [Int] = x : int:x M [!( 1 ; 2 )] = f : T (!( 1 ; 2 )):newid [ 1 ]<ref> [ 2 ] </ref>(x : T (Trans [ 1 ]): M [ 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans <p> 2 ](f (U [ 1 ] x))) M [Id [ 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans <ref> [ 2 ] </ref>)]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ <p> 1 ]] = x : T (Id []):x U : 8t :: :T (Trans [t]) ! T (t) U [Int] = x : int:x U [!( 1 ; 2 )] = f : T (Id [!(Trans [ 1 ]; Trans <ref> [ 2 ] </ref>)]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : <p> f : T (Id [!(Trans [ 1 ]; Trans <ref> [ 2 ] </ref>)]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> <ref> [ 2 ] </ref>)]): x : T ( 1 ): U [ 2 ](rpc [ 1 ][ 2 ] f (M [ 1 ] x)) U [fi ( 1 ; 2 )] = x : T (fi (Trans [ 1 ]; Trans [ 2 ])):hU [ 1 ]( 1 x); U [ 2 ]( 2 x)i U [Id []] = x : T (Id []):x At arrow types, M converts the function to one that takes and returns transmissible types and then allocates and associates a new identifier with this function via newid. <p> Definitional equality can be used to determine membership in the class. For example, the class of types that admit equality can be defined using Typerec as follows: Eq :: ! Eq [Bool] = Bool Eq [fi ( 1 ; 2 )] = fi (Eq [ 1 ]; Eq <ref> [ 2 ] </ref>) Eq [!( 1 ; 2 )] = Void Eq [Void] = Void Here, Eq serves as a predicate on types in the sense that a non-Void constructor is definitionally equal to Eq [] only if is a constructor that does not contain the constructor !(; ). <p> ft::g . . :: ; . pack e with as 9t::: : 9t::: . ; . e 1 : 9t::: 0 ; . abstype e 1 is t::; x: 0 in e 2 end : 6.2 Dynamics In the presence of intensional polymorphism a predicative form of the type dynamic <ref> [2] </ref> may be defined to be the existential type 9t:::T (t). Under this interpretation the introductory form dynamic [t ](e) stands for pack e with t as 9t:::T (t). <p> An empirical study of the relative performance of the two approaches is currently planned by the second author, and will be reported elsewhere. 18 The combination of intensional polymorphism and existential types [38] raises some interesting questions. On the one hand, the type dynamic <ref> [2] </ref> may be defined in terms of existentials. On the other hand, data abstraction may be violated since a "client" of an abstraction may perform intensional analysis on the abstract type, which is replaced at run-time by the implementation type of the abstraction.
Reference: [3] <author> A. Aiken, E. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Of a broadly similar nature is the work on "soft" type systems <ref> [3, 11, 23, 48, 53] </ref> which seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [4] <author> Stuart F. Allen, Robert L. Constable, Douglas J. Howe, and William E. Aitken. </author> <title> The semantics of reflected proof. </title> <booktitle> In Fifth Symposium on Logic in Computer Science, </booktitle> <pages> pages 95-106, </pages> <address> Philadelphia, PA, </address> <month> June </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: In this way parametricity and representation independence can be enforced by restricting the use of type analysis. The idea of intensional analysis of types bears some resemblance to the notion of reflection <ref> [46, 4] </ref> | we may think of type-passing as a "reification" of the meta-level notion of types. It is interesting to speculate that the type theory proposed here is but a special case of a fully reflective type theory.
Reference: [5] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed <ref> [5] </ref>; later implementations [31, 32, 30, 24, 43] seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types. <p> Despite these recent improvements, current implementations still resort to pointer representations for unknown types. Furthermore, current implementations make use of tag bits on values to assist garbage collection <ref> [5] </ref> and to define polymorphic equality [5, 6, 18]. Thus representations are further compromised by making it impossible to have 32-bit integers or tag-free tuples with contiguous layout of components. <p> Despite these recent improvements, current implementations still resort to pointer representations for unknown types. Furthermore, current implementations make use of tag bits on values to assist garbage collection [5] and to define polymorphic equality <ref> [5, 6, 18] </ref>. Thus representations are further compromised by making it impossible to have 32-bit integers or tag-free tuples with contiguous layout of components. In this paper we introduce a new compilation method for polymorphic languages that avoids the difficulties introduced by boxing and tagging techniques. <p> Compiling polymorphism using intensional type analysis enables data representations that are impossible using type-free techniques. Setting aside the additional expressiveness of the present approach, it is interesting to consider the performance of a type-passing implementation of ML as compared to the type-free approach adopted in SML/NJ <ref> [5] </ref>. As pointed out by Tolmach [50], a type-passing implementation need not maintain tag bits on values for the sake of garbage collection. The only remaining use of tag bits in SML/NJ is for polymorphic equality, which can readily be implemented using intensional type analysis.
Reference: [6] <author> Andrew W. Appel. </author> <title> A critique of Standard ML. </title> <type> Technical Report CS-TR-364-92, </type> <institution> Princeton University, Princeton, NJ, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Despite these recent improvements, current implementations still resort to pointer representations for unknown types. Furthermore, current implementations make use of tag bits on values to assist garbage collection [5] and to define polymorphic equality <ref> [5, 6, 18] </ref>. Thus representations are further compromised by making it impossible to have 32-bit integers or tag-free tuples with contiguous layout of components. In this paper we introduce a new compilation method for polymorphic languages that avoids the difficulties introduced by boxing and tagging techniques.
Reference: [7] <author> Lennart Augustsson. </author> <title> Implementing Haskell overloading. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, Denmark, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The reader is encouraged to consult Ohori and Kato's paper [42] for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See <ref> [51, 27, 49, 7] </ref> for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML [36]). Consider adding a distinguished type void (with associated constructor Void) in such a way that void is "empty".
Reference: [8] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year> <month> 19 </month>
Reference-contexts: However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [8, 29, 21] </ref>. 1 Our translations will have the property that jj; jj ` e t : jt j is derivable in ML i for a suitable translation of contexts and types into ML i .
Reference: [9] <author> Luca Cardelli. </author> <title> Phase distinctions in type theory. </title> <type> unpublished manuscript. </type>
Reference-contexts: depend upon the range type, but our presentation is simplified greatly by restricting the dependency to the domain type. 4 the constructor and term level. (The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [9, 22] </ref>.) At the term level typerec may be thought of as a generalization of the typecase operation associated with the type dynamic [1] that provides for the definition of a term by induction on the structure of a monotype.
Reference: [10] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: However, in general, we lose termination, which presents problems not only for optimization but also for type checking (since Typerec would no longer terminate). The restriction to predicative polymorphism is sufficient for compiling ML programs. More recent languages such as Quest <ref> [10] </ref> extend the expressive power to admit impredicative polymor-phism, in which quantified types may be instantiated by quantified types. (Both Girard's [15] and Reynolds's [44] calculi exhibit this kind of poylmorphism.) It is natural to consider whether the methods proposed here may be extended to the impredicative case.
Reference: [11] <author> Robert Cartwright and Michael Fagan. </author> <title> Soft typing. </title> <booktitle> In Proc. SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Of a broadly similar nature is the work on "soft" type systems <ref> [3, 11, 23, 48, 53] </ref> which seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [12] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In 1986 ACM Conference on LISP and Functional Programming, </booktitle> <year> 1986. </year>
Reference-contexts: The source language is based on Mini-ML <ref> [12] </ref>, which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [22], a predicative variant of Girard's F ! [15, 16], enriched with primitives for intensional type analysis. <p> and type instantiation explicit, and to exploit this type-passing interpretation through the use of intensional type analysis in both types and terms. 1 We omit explicit consideration of the coherence of our translations here. 2 2.1 Source Language: Mini-ML The source language for our translations is a variant of Mini-ML <ref> [12] </ref>.
Reference: [13] <author> Robert L. Constable. </author> <title> Intensional analysis of functions and types. </title> <type> Technical Report CSR-118-82, </type> <institution> Computer Science Department, University of Edinburgh, </institution> <month> June </month> <year> 1982. </year>
Reference-contexts: By "predicative" we mean that mono--types and polytypes are separated, with quantifiers ranging only over monotypes. By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case [45], but rather can significantly affect the course of computation. Following Constable <ref> [13, 14] </ref> we consider primitive operations for performing intensional type analysis [13, 14] in the form of structural recursion on types at both the term and the type level. <p> By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case [45], but rather can significantly affect the course of computation. Following Constable <ref> [13, 14] </ref> we consider primitive operations for performing intensional type analysis [13, 14] in the form of structural recursion on types at both the term and the type level. Intensional type analysis is required at the type, as well as the term, level in order to track the type of intensionally polymorphic operations. <p> This type theory was subsequently refined by Harper, Mitchell, and Moggi [22], and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable <ref> [14, 13] </ref>, from which the term "intensional analysis" is taken. The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable).
Reference: [14] <author> Robert L. Constable and Daniel R. Zlatin. </author> <title> The type theory of PL/CV3. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 72-93, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: By "predicative" we mean that mono--types and polytypes are separated, with quantifiers ranging only over monotypes. By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case [45], but rather can significantly affect the course of computation. Following Constable <ref> [13, 14] </ref> we consider primitive operations for performing intensional type analysis [13, 14] in the form of structural recursion on types at both the term and the type level. <p> By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case [45], but rather can significantly affect the course of computation. Following Constable <ref> [13, 14] </ref> we consider primitive operations for performing intensional type analysis [13, 14] in the form of structural recursion on types at both the term and the type level. Intensional type analysis is required at the type, as well as the term, level in order to track the type of intensionally polymorphic operations. <p> This type theory was subsequently refined by Harper, Mitchell, and Moggi [22], and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable <ref> [14, 13] </ref>, from which the term "intensional analysis" is taken. The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable).
Reference: [15] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scanindavian Logic Symposium, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: The source language is based on Mini-ML [12], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [22], a predicative variant of Girard's F ! <ref> [15, 16] </ref>, enriched with primitives for intensional type analysis. <p> Wright has determined empirically that the value restriction does not affect the vast majority of ML programs [52]. 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [21], a predicative variant of Girard's F ! <ref> [15, 16, 44] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> fi ; e ! )))(typerec [t:]( 1 ; e i ; e fi ; e ! )) ) v ` typerec [t:](; e i ; e fi ; e ! ) ) v (NF () = !( 1 ; 2 )) i As another example, Girard's formulation of System F <ref> [15] </ref> includes a distinguished constant 0 t of type t for each type t (including variable types). <p> The restriction to predicative polymorphism is sufficient for compiling ML programs. More recent languages such as Quest [10] extend the expressive power to admit impredicative polymor-phism, in which quantified types may be instantiated by quantified types. (Both Girard's <ref> [15] </ref> and Reynolds's [44] calculi exhibit this kind of poylmorphism.) It is natural to consider whether the methods proposed here may be extended to the impredicative case.
Reference: [16] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The source language is based on Mini-ML [12], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML [22], a predicative variant of Girard's F ! <ref> [15, 16] </ref>, enriched with primitives for intensional type analysis. <p> Wright has determined empirically that the value restriction does not affect the vast majority of ML programs [52]. 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [21], a predicative variant of Girard's F ! <ref> [15, 16, 44] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types.
Reference: [17] <author> Kurt Godel. </author> <title> Uber eine bisher noch nicht benutzte Erweiterung des finiten Standpunktes. </title> <journal> Dialectica, </journal> <volume> 12 </volume> <pages> 280-287, </pages> <year> 1958. </year>
Reference-contexts: The constructor equivalence rules (Figure 3) axioma-tize definitional equality [47, 34] of constructors to consist of fi-conversion together with recursion equations governing the Typerec form. The level of constructors and kinds is a variation of Godel's T <ref> [17] </ref>. Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 3 [47]. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47].
Reference: [18] <editor> Carl A. Gunter, Elsa L. Gunter, and David B. MacQueen. </editor> <title> Computing ML equality kinds using abstract interpretation. </title> <journal> Information and Computation, </journal> <volume> 107(2) </volume> <pages> 303-323, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Despite these recent improvements, current implementations still resort to pointer representations for unknown types. Furthermore, current implementations make use of tag bits on values to assist garbage collection [5] and to define polymorphic equality <ref> [5, 6, 18] </ref>. Thus representations are further compromised by making it impossible to have 32-bit integers or tag-free tuples with contiguous layout of components. In this paper we introduce a new compilation method for polymorphic languages that avoids the difficulties introduced by boxing and tagging techniques. <p> This requires a type-passing interpretation of polymorphism (as suggested by Harper and Mitchell [21]), together with suitable operations for performing code selection based on type parameters. Our approach is formalized as a translation into an explicitly-typed, predicative polymorphic 1 -calculus with intensional or structural <ref> [18] </ref> polymorphism. By "predicative" we mean that mono--types and polytypes are separated, with quantifiers ranging only over monotypes. By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case [45], but rather can significantly affect the course of computation. <p> This calculus is sufficient for the interpretation of ML-style polymorphism (see Harper and Mitchell [21] for further discussion of this point.) The language ML i extends ML with intensional (or structural <ref> [18] </ref>) polymorphism, that allows non-parametric functions to be defined by intensional analysis of types.
Reference: [19] <author> Robert Harper and Mark Lillibridge. </author> <title> Polymorphic type assignment and CPS conversion. </title> <editor> In Olivier Danvy and Carolyn Talcott, editors, </editor> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Continuations CW92, </booktitle> <pages> pages 13-22, </pages> <address> Stanford, CA 94305, </address> <month> June </month> <year> 1992. </year> <institution> Department of Computer Science, Stanford University. </institution> <note> Published as technical report STAN-CS-92-1426. </note>
Reference: [20] <author> Robert Harper and Mark Lillibridge. </author> <title> Polymorphic type assignment and CPS conversion. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 6(4) </volume> <pages> 361-380, </pages> <month> November </month> <year> 1993. </year> <note> (See also [19].). </note>
Reference-contexts: Second, the variable x must be bound to a value, v, instead of an arbitrary expression. This "value restriction" on polymorphism <ref> [20, 33, 52] </ref> is needed for our translation.
Reference: [21] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year> <note> (See also [37].). </note>
Reference-contexts: We propose instead to defer code selection to link- or even run-time when the types of x and y are known. This requires a type-passing interpretation of polymorphism (as suggested by Harper and Mitchell <ref> [21] </ref>), together with suitable operations for performing code selection based on type parameters. Our approach is formalized as a translation into an explicitly-typed, predicative polymorphic 1 -calculus with intensional or structural [18] polymorphism. By "predicative" we mean that mono--types and polytypes are separated, with quantifiers ranging only over monotypes. <p> 8 we summarize and suggest directions for future research. 2 Type-Directed Compilation In order to take full advantage of type information during compilation we consider translations of typing derivations from the implicitly-typed ML core language to an explicitly-typed intermediate language, following the interpretation of polymorphism suggested by Harper and Mitchell <ref> [21] </ref>. The source language is based on Mini-ML [12], which captures many of the essential features of the ML core language. <p> However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [8, 29, 21] </ref>. 1 Our translations will have the property that jj; jj ` e t : jt j is derivable in ML i for a suitable translation of contexts and types into ML i . <p> This "value restriction" on polymorphism [20, 33, 52] is needed for our translation. Wright has determined empirically that the value restriction does not affect the vast majority of ML programs [52]. 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML <ref> [21] </ref>, a predicative variant of Girard's F ! [15, 16, 44]. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. This calculus is sufficient for the interpretation of ML-style polymorphism (see Harper and Mitchell <ref> [21] </ref> for further discussion of this point.) The language ML i extends ML with intensional (or structural [18]) polymorphism, that allows non-parametric functions to be defined by intensional analysis of types. <p> In their study of the type theory of Standard ML Harper and Mitchell <ref> [21] </ref> argued that an explicitly-typed interpretation of ML poly-morphism has better semantic properties and scales more easily to cover the full language.
Reference: [22] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The source language is based on Mini-ML [12], which captures many of the essential features of the ML core language. The target language, ML i , is an extension of ML , also known as XML <ref> [22] </ref>, a predicative variant of Girard's F ! [15, 16], enriched with primitives for intensional type analysis. <p> depend upon the range type, but our presentation is simplified greatly by restricting the dependency to the domain type. 4 the constructor and term level. (The introductory forms are the constructors of kind ; there are no introductory forms at the term level in order to preserve the phase distinction <ref> [9, 22] </ref>.) At the term level typerec may be thought of as a generalization of the typecase operation associated with the type dynamic [1] that provides for the definition of a term by induction on the structure of a monotype. <p> Harper and Mitchell formulated a predicative type theory, XML, a theory of dependent types augmented with a universe of small types, adequate for capturing many aspects of Standard ML. This type theory was subsequently refined by Harper, Mitchell, and Moggi <ref> [22] </ref>, and provides the basis for this work. The idea of intensional type analysis exploited here was inspired by the work of Constable [14, 13], from which the term "intensional analysis" is taken.
Reference: [23] <author> Nevin Heintze. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proc. 1994 ACM Conf. on LISP and Functional Programming, </booktitle> <pages> pages 306-317, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Of a broadly similar nature is the work on "soft" type systems <ref> [3, 11, 23, 48, 53] </ref> which seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [24] <author> Fritz Henglein and Jesper Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-226, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed [5]; later implementations <ref> [31, 32, 30, 24, 43] </ref> seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types. <p> A number of authors have considered problems pertaining to representation analysis in the presence of poylmorphism. The boxing interpretation of polymorphism has been studied by Peyton Jones & Launchbury [30], by Leroy [32], by Poulsen [43], and by Henglein & Jtrgensen <ref> [24] </ref>, with the goal of minimizing the overhead of boxing and unboxing at run time. Of a broadly similar nature is the work on "soft" type systems [3, 11, 23, 48, 53] which seek to improve data representations through global analysis techniques.
Reference: [25] <editor> Paul Hudak, Simon L. Peyton Jones, and Philip Wadler. </editor> <title> Report on the programming language Haskell, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: The reader is encouraged to consult Ohori and Kato's paper [42] for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell <ref> [25] </ref> provides the ability to define a class of types with associated operations called methods. (See [51, 27, 49, 7] for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML [36]).
Reference: [26] <author> Mark P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> July </month> <year> 1992. </year> <note> Currently available as Technical Monograph PRG-106, </note> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <address> 11 Keble Road, Oxford OX1 3QD, U.K. email: library@comlab.ox.ac.uk. </address>
Reference-contexts: Ohori's solution is ad hoc in the sense that no general type theoretic framework is proposed, but many of the key ideas in his work are present here. Jones <ref> [26] </ref> has proposed a general framework for passing data derived from types to "qualified" polymorphic operations, called evidence passing.
Reference: [27] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copen-hagen, Denmark, June 1993. </address> <publisher> ACM Press. </publisher> <pages> 20 </pages>
Reference-contexts: The reader is encouraged to consult Ohori and Kato's paper [42] for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See <ref> [51, 27, 49, 7] </ref> for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML [36]). Consider adding a distinguished type void (with associated constructor Void) in such a way that void is "empty". <p> It is important to investigate further the relationship between intensional polymorphism and type classes <ref> [51, 27] </ref>. The primary difference between the two approaches appears to be a tradeoff between passing types, from which methods can be chosen based on intensional type analysis, and passing the methods themselves.
Reference: [28] <author> Mark P. Jones. </author> <title> ML typing, explicit polymorphism and qualified types. </title> <booktitle> In TACS '94: Conference on theoretical aspects of computer software, Sendai, </booktitle> <address> Japan, </address> <month> April </month> <year> 1994. </year> <note> Springer-Verlag. Lecture Notes in Computer Science, to appear. </note>
Reference-contexts: Intensional type analysis is required at the type, as well as the term, level in order to track the type of intensionally polymorphic operations. This feature distinguishes our approach from other approaches based on typecase <ref> [49, 28] </ref>. The form of intensional analysis that we provide is sufficiently strong to perform non-trivial type-based code selection, but it is sufficiently weak that termination of operations that analyze types is assured.
Reference: [29] <author> M.P. Jones. </author> <title> Coherence for qualified types. </title> <institution> Research Report YALEU/DCS/RR-989, Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: However, all of the translation schemes we consider are coherent in the sense that any two typing derivations produce observationally equivalent translations <ref> [8, 29, 21] </ref>. 1 Our translations will have the property that jj; jj ` e t : jt j is derivable in ML i for a suitable translation of contexts and types into ML i .
Reference: [30] <author> Simon Peyton Jones and John Launchbury. </author> <title> Unboxed values as first-class citizens. </title> <booktitle> In Proc. Conf. on Functional Programming and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 636-666. </pages> <publisher> ACM, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed [5]; later implementations <ref> [31, 32, 30, 24, 43] </ref> seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types. <p> It would seem, then, that the type-passing interpretation of polymorphism is more costly than the boxing interpretation for some applications. Fortunately, boxing is not incompatible with type-passing. In particular, we can make boxing explicit in the source and/or target languages (as suggested by Peyton Jones and Launchbury <ref> [30] </ref> and Leroy [32]). This allows the programmer (or compiler) to make controlled use of boxing to satisfy either layout requirements (at the cost of certain operations being more expensive) or access requirements (at the cost of introducing indirections). <p> A number of authors have considered problems pertaining to representation analysis in the presence of poylmorphism. The boxing interpretation of polymorphism has been studied by Peyton Jones & Launchbury <ref> [30] </ref>, by Leroy [32], by Poulsen [43], and by Henglein & Jtrgensen [24], with the goal of minimizing the overhead of boxing and unboxing at run time.
Reference: [31] <author> Xavier Leroy. </author> <title> The ZINC experiment: an economical implementation of the ML language. </title> <type> Technical Report 117, </type> <institution> INRIA, </institution> <year> 1990. </year>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed [5]; later implementations <ref> [31, 32, 30, 24, 43] </ref> seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types.
Reference: [32] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Albuquerque, </booktitle> <pages> pages 177-188. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed [5]; later implementations <ref> [31, 32, 30, 24, 43] </ref> seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types. <p> Fortunately, boxing is not incompatible with type-passing. In particular, we can make boxing explicit in the source and/or target languages (as suggested by Peyton Jones and Launchbury [30] and Leroy <ref> [32] </ref>). This allows the programmer (or compiler) to make controlled use of boxing to satisfy either layout requirements (at the cost of certain operations being more expensive) or access requirements (at the cost of introducing indirections). <p> The interpretation of the boxing and unboxing primitives is left unspecified. The simplest interpretation is heap allocation | values of type boxed () are pointers to values of type . As pointed out by Leroy <ref> [32, Section 4] </ref>, this simple interpretation is not always adequate. <p> A number of authors have considered problems pertaining to representation analysis in the presence of poylmorphism. The boxing interpretation of polymorphism has been studied by Peyton Jones & Launchbury [30], by Leroy <ref> [32] </ref>, by Poulsen [43], and by Henglein & Jtrgensen [24], with the goal of minimizing the overhead of boxing and unboxing at run time.
Reference: [33] <author> Xavier Leroy. </author> <title> Polymorphism by name. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Second, the variable x must be bound to a value, v, instead of an arbitrary expression. This "value restriction" on polymorphism <ref> [20, 33, 52] </ref> is needed for our translation.
Reference: [34] <author> Per Martin-Lof. </author> <title> About models for intuitionistic type theories and the notion of definitional equality. </title> <editor> In S. Kanger, editor, </editor> <booktitle> Proceedings of the Third Scandinavian Logic Symposium, Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 81-109. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: The constructor Typerec (; i ; fi ; ! ) has kind if is of kind (i.e., a monotype), i is of kind , and ! and fi are each of kind ! ! ! ! . The constructor equivalence rules (Figure 3) axioma-tize definitional equality <ref> [47, 34] </ref> of constructors to consist of fi-conversion together with recursion equations governing the Typerec form. The level of constructors and kinds is a variation of Godel's T [17].
Reference: [35] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: of complex data structures, capturing some of the expressiveness of C casts without sacrificing type safety. 16 7 Related Work There has traditionally been two interpretations of polymorphism, the explicit style (due to Reynolds [44]), in which types are passed to polymorphic operations, and the implicit style (due to Milner <ref> [35] </ref>), in which types are erased prior to execution. In their study of the type theory of Standard ML Harper and Mitchell [21] argued that an explicitly-typed interpretation of ML poly-morphism has better semantic properties and scales more easily to cover the full language.
Reference: [36] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See [51, 27, 49, 7] for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML <ref> [36] </ref>). Consider adding a distinguished type void (with associated constructor Void) in such a way that void is "empty". By empty, we mean that no closed value has type void.
Reference: [37] <author> John Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference: [38] <author> John C. Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: An empirical study of the relative performance of the two approaches is currently planned by the second author, and will be reported elsewhere. 18 The combination of intensional polymorphism and existential types <ref> [38] </ref> raises some interesting questions. On the one hand, the type dynamic [2] may be defined in terms of existentials.
Reference: [39] <author> Greg Morrisett, Matthias Felleisen, and Robert Harper. </author> <title> Abstract models of memory management. </title> <note> (Submitted for publication, POPL '95), </note> <month> July </month> <year> 1994. </year>
Reference-contexts: Tolmach's results demonstrate that it is feasible to build a run-time system for ML in which no type information is associated with data in the heap 3 . Morrisett, Harper, and Felleisen <ref> [39] </ref> give a semantic framework for discussing garbage collection, and provide a proof of correctness of Tolmach's algorithm. 3 However, types are passed indpendently as data and associated with code. 17 8 Directions for Future Research We have presented a type-theoretic framework for expressing computations that analyze types at run time.
Reference: [40] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The rules for typerec, and the need for Typerec, are derived from the "universe elimination" rules in NuPRL (described only in unpublished work of Constable). The idea of passing types to polymorphic functions is exploited by Morrison et al. <ref> [40] </ref> in the implementation of Napier '88. Types are used at run time to specialize data representations in roughly the manner described here. The authors do not, however, provide a rigorous account of the type theory underlying their implementation technique.
Reference: [41] <author> Atsushi Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-165, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Types are used at run time to specialize data representations in roughly the manner described here. The authors do not, however, provide a rigorous account of the type theory underlying their implementation technique. Ohori's work on compiling record operations <ref> [41] </ref> is similarly based on a type-passing interpretation of polymorphism, and was an inspiration for the present work. Ohori's solution is ad hoc in the sense that no general type theoretic framework is proposed, but many of the key ideas in his work are present here.
Reference: [42] <author> Atsushi Ohori and Kazuhiko Kato. </author> <title> Semantics for communication primitives in a polymorphic language. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 99-112, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: We illustrate the use of intensional polymorphism by considering a "flattening" translation for tuples and a "marshalling" operation for distributed computing (based on Ohori and Kato <ref> [42] </ref>). This paper is organized as follows. In Section 2 we describe our approach to compilation as a type-based translation from the source language, Mini-ML, to the target language, ML i . The basic properties of ML i are stated, and a few illustrative examples are given. <p> Wrap [ 2 ]) With this definition in mind, it is easy to check that wrap : 8t:::T (t) ! T (Wrap [t]) unwrap : 8t:::T (Wrap [t]) ! T (t) 5 Marshalling Ohori and Kato give an extension of ML with primitives for distributed computing in a hetrogenous environment <ref> [42] </ref>. Their extension has two essential features: One is a mechanism for generating globally unique names ("handles" or "capabilities") that are used as proxies for functions provided by servers. The other is a method for representing arbitrary values in a form suitable for transmission through a network. <p> The M and U functions are used in the translation of client phrases that import a server's function and in the translation of server phrases that export functions. The reader is encouraged to consult Ohori and Kato's paper <ref> [42] </ref> for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See [51, 27, 49, 7] for various papers related to type classes.)
Reference: [43] <author> Eigil Rosager Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Technical report, </type> <institution> Department of Computer Science (DIKU), University of Copenhagen, </institution> <month> April </month> <year> 1993. </year> <note> Master Dissertation. </note>
Reference-contexts: Most implementations of ML impose a similar restriction, requiring that values of unknown type be "boxed" (stored on the heap and represented by a pointer). Early implementations used a LISP-like representation in which all values are boxed [5]; later implementations <ref> [31, 32, 30, 24, 43] </ref> seek to minimize boxing by taking advantage of whatever type information is manifest in the program. Despite these recent improvements, current implementations still resort to pointer representations for unknown types. <p> A number of authors have considered problems pertaining to representation analysis in the presence of poylmorphism. The boxing interpretation of polymorphism has been studied by Peyton Jones & Launchbury [30], by Leroy [32], by Poulsen <ref> [43] </ref>, and by Henglein & Jtrgensen [24], with the goal of minimizing the overhead of boxing and unboxing at run time. Of a broadly similar nature is the work on "soft" type systems [3, 11, 23, 48, 53] which seek to improve data representations through global analysis techniques.
Reference: [44] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloq. sur la Programmation, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Wright has determined empirically that the value restriction does not affect the vast majority of ML programs [52]. 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [21], a predicative variant of Girard's F ! <ref> [15, 16, 44] </ref>. The essential departure from the impredicative systems of Girard and Reynolds is that the quantifier 8t: ranges only over "small" types, or "monotypes", which do not include the quantified types. <p> This means that we may freely intermingle updates with views of complex data structures, capturing some of the expressiveness of C casts without sacrificing type safety. 16 7 Related Work There has traditionally been two interpretations of polymorphism, the explicit style (due to Reynolds <ref> [44] </ref>), in which types are passed to polymorphic operations, and the implicit style (due to Milner [35]), in which types are erased prior to execution. <p> The restriction to predicative polymorphism is sufficient for compiling ML programs. More recent languages such as Quest [10] extend the expressive power to admit impredicative polymor-phism, in which quantified types may be instantiated by quantified types. (Both Girard's [15] and Reynolds's <ref> [44] </ref> calculi exhibit this kind of poylmorphism.) It is natural to consider whether the methods proposed here may be extended to the impredicative case. Since the universal quantifier may be viewed as a constant of kind ( ! ) ! , similar problems arise as for recursive types.
Reference: [45] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1983. </year>
Reference-contexts: By "predicative" we mean that mono--types and polytypes are separated, with quantifiers ranging only over monotypes. By "intensional polymorphism" we mean that type parameters are not necessarily treated uniformly, as in the parametric case <ref> [45] </ref>, but rather can significantly affect the course of computation. Following Constable [13, 14] we consider primitive operations for performing intensional type analysis [13, 14] in the form of structural recursion on types at both the term and the type level.
Reference: [46] <author> Brian C. Smith. </author> <title> Reflection and semantics in LISP. </title> <booktitle> In Eleventh ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 23-35, </pages> <year> 1984. </year> <month> 21 </month>
Reference-contexts: In this way parametricity and representation independence can be enforced by restricting the use of type analysis. The idea of intensional analysis of types bears some resemblance to the notion of reflection <ref> [46, 4] </ref> | we may think of type-passing as a "reification" of the meta-level notion of types. It is interesting to speculate that the type theory proposed here is but a special case of a fully reflective type theory.
Reference: [47] <author> Soren Stenlund. </author> <title> Combinators, -terms and Proof Theory. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1972. </year>
Reference-contexts: The constructor Typerec (; i ; fi ; ! ) has kind if is of kind (i.e., a monotype), i is of kind , and ! and fi are each of kind ! ! ! ! . The constructor equivalence rules (Figure 3) axioma-tize definitional equality <ref> [47, 34] </ref> of constructors to consist of fi-conversion together with recursion equations governing the Typerec form. The level of constructors and kinds is a variation of Godel's T [17]. <p> The level of constructors and kinds is a variation of Godel's T [17]. Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 3 <ref> [47] </ref>. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47]. The type formation and equivalence rules for ML i are given in Figure 4. The rules of type equivalence define the interpretation T () of the constructor as a type. <p> Every constructor, , has a unique normal form, NF (), with respect to the obvious notion of reduction derived from the equivalence rules of Figure 3 <ref> [47] </ref>. This reduction relation is confluent, from which it follows that constructor equivalence is decidable [47]. The type formation and equivalence rules for ML i are given in Figure 4. The rules of type equivalence define the interpretation T () of the constructor as a type.
Reference: [48] <author> Satish R. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Of a broadly similar nature is the work on "soft" type systems <ref> [3, 11, 23, 48, 53] </ref> which seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
Reference: [49] <author> Satish R. Thatte. </author> <title> Semantics of type classes revisited. </title> <booktitle> In Proc. 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 208-219, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Intensional type analysis is required at the type, as well as the term, level in order to track the type of intensionally polymorphic operations. This feature distinguishes our approach from other approaches based on typecase <ref> [49, 28] </ref>. The form of intensional analysis that we provide is sufficiently strong to perform non-trivial type-based code selection, but it is sufficiently weak that termination of operations that analyze types is assured. <p> The reader is encouraged to consult Ohori and Kato's paper [42] for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See <ref> [51, 27, 49, 7] </ref> for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML [36]). Consider adding a distinguished type void (with associated constructor Void) in such a way that void is "empty". <p> From a practical point of view it appears that both mechanisms can be used to solve similar problems, but it is not clear what is the exact relationship between the two approaches. Recently Thatte <ref> [49] </ref> has suggested a semantics for type classes that is similar in spirit to the present proposal, but lacks the capability to perform intensional type analysis at the constructor level, a crucial feature for tracking the typing properties of intensionally polymorphic operations.
Reference: [50] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Many (including the soft type systems, but not Leroy's system) rely on global analysis for their effectiveness. In contrast we propose a new approach to compiling polymorphism that affords control over data representation without compromising modularity. Finally, a type-passing interpretation of polymorphism is exploited by Tolmach <ref> [50] </ref> in his implementation of a tag-free garbage collection algorithm. Tolmach's results demonstrate that it is feasible to build a run-time system for ML in which no type information is associated with data in the heap 3 . <p> Setting aside the additional expressiveness of the present approach, it is interesting to consider the performance of a type-passing implementation of ML as compared to the type-free approach adopted in SML/NJ [5]. As pointed out by Tolmach <ref> [50] </ref>, a type-passing implementation need not maintain tag bits on values for the sake of garbage collection. The only remaining use of tag bits in SML/NJ is for polymorphic equality, which can readily be implemented using intensional type analysis.
Reference: [51] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad hoc polymorphism less ad hoc. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: The reader is encouraged to consult Ohori and Kato's paper [42] for further details. 6 Other Applications In this section, we sketch several other applications of intensional polymorphism. 6.1 Type Classes The language Haskell [25] provides the ability to define a class of types with associated operations called methods. (See <ref> [51, 27, 49, 7] </ref> for various papers related to type classes.) The canonical example is the class of types that admit equality (also known as equality types in SML [36]). Consider adding a distinguished type void (with associated constructor Void) in such a way that void is "empty". <p> It is important to investigate further the relationship between intensional polymorphism and type classes <ref> [51, 27] </ref>. The primary difference between the two approaches appears to be a tradeoff between passing types, from which methods can be chosen based on intensional type analysis, and passing the methods themselves.
Reference: [52] <author> Andrew K. Wright. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Technical Report TR93-200, </type> <institution> Department of Computer Science, Rice University, Houston, TX, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Second, the variable x must be bound to a value, v, instead of an arbitrary expression. This "value restriction" on polymorphism <ref> [20, 33, 52] </ref> is needed for our translation. <p> Second, the variable x must be bound to a value, v, instead of an arbitrary expression. This "value restriction" on polymorphism [20, 33, 52] is needed for our translation. Wright has determined empirically that the value restriction does not affect the vast majority of ML programs <ref> [52] </ref>. 2.2 Target Language: ML i The target language of our translations, ML i , is based on ML [21], a predicative variant of Girard's F ! [15, 16, 44].
Reference: [53] <author> Andrew K. Wright and Robert Cartwright. </author> <title> A practical soft type system for scheme. </title> <booktitle> In Proc 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 250-262, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <journal> ACM. </journal> <volume> 22 </volume>
Reference-contexts: Of a broadly similar nature is the work on "soft" type systems <ref> [3, 11, 23, 48, 53] </ref> which seek to improve data representations through global analysis techniques. All of these methods are based on the use of program analysis techniques to reduce the overhead of box and tag manipulation incurred by the standard compilation method for polymorphic languages.
References-found: 53

