URL: http://www.win.tue.nl/win/cs/csr/csr93/93.01.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Title: Deriving the Aho-Corasick Algorithms: A Case Study into the Synergy of Programming Methods  
Author: Rik van Geldrop 
Date: 15 January 1993  
Abstract: Imperative programs can be derived using methods like stepwise refinement, but they do not lend themselves very well to transformational programming. The Bird-Meertens approach offers a powerful transformation calculus for functional programs, but it pays little or no attention to imperative algorithms. In this paper we will show how the two approaches can be combined by giving a transformational derivation of some efficient and practical imperative programs, viz. the Aho-Corasick string pattern matching algorithms 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V.Aho and M.J.Corasick. </author> <title> Efficient String Matching: An Aid to Bibliographic Search. </title> <journal> Communications of the ACM, </journal> <volume> 18(6) </volume> <pages> 333-340, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: To aid the understanding of this swap, we developed some conversions from functional to imperative level. We will illustrate the cooperative action of methods in a derivation for the pattern matching algorithms of Aho-Corasick. More precisely, we will derive two algorithms which occur in <ref> [1] </ref>: Algorithm 1 and its adaption as outlined there in chapter 6. (In the sequel, we shall refer to these Aho-Corasick algorithms as AC-FAIL and AC-OPT respectively.) The paper is organized as follows. <p> i.e. ffi : Q fi V ! Q is such that ffi (q,a) = " s / (suff (qa) " Q) output : Q ! P (V*) is such that output (q) = suff (q) " P With this representation choice for the precomputation, AC-OPT, the adapted algorithm 1 of <ref> [1] </ref>, is obtained from scheme 7: O, s, q := (f"g " P) fi f"g, ", "; r := S ! a := first (r); r := tail (r) ; q := ffi (q, a) (4.2.2) ; O 1 := output (q) fi fsag ; O, s := O [ O <p> In <ref> [1] </ref>, ffi is considered as the transition function on a deterministic finite automaton. 3. It is not quite true that (4.2.2) is AC-OPT, there is one small difference. <p> Adding the realization of ffi to the precomputation, we arrive at AC-FAIL (algorithm 1 in <ref> [1] </ref>).
Reference: [2] <author> R. Backhouse. </author> <title> A relational theory of datatypes. </title> <booktitle> Lecture Notes, International Summer School on Constructive Algorithmics, </booktitle> <volume> vol. 3, </volume> <year> 1992. </year>
Reference-contexts: Languages have a rather rich structure. Although it is not a model for the spec algebra of Backhouse et all, <ref> [2] </ref>, a main part of the spec axioms is satisfied by languages and a reader familiar with the spec calculus may recognize several of its notions, properties and calculation techniques in the sequel. The essential part of the language structure is recapitulated now, more can be found in [15]. <p> Definition 3.1.2 f Left factor L=M g Let L, M 2 P (V*), then the left factor L=M is defined by X.M L j X L=M for each X 2 P (V*) 2 Since .M distributes universally over [, L=M is uniquely determined. See also <ref> [2] </ref>. The advantage of definitions via Galois connections is that they encapsulate a lot of properties which can easily picked out by instantiations. E.g. Properties 3.1.3 a. L=M prefs (L) b. z.M L j z 2 L=M Proof. All properties follow from substitutions in definition 3.1.2.
Reference: [3] <author> R.S.Bird. </author> <title> An introduction to the theory of lists. </title> <editor> in M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <booktitle> NATO ASI Series, </booktitle> <volume> vol. </volume> <month> F36. </month>
Reference-contexts: For a transformational approach to programming however, the method is less appropriate because the programs are not (yet) equipped with a sufficiently rich algebraic structure fit for manipulation. The Bird-Meertens formalism (BMF) is a method for functional programming <ref> [4, 3, 17] </ref>. In this method based on equational reasoning within manipulatively attractive algebraic structures functional expressions are transformed into efficient deterministic programs over a restricted class of datatypes. The main objective of BMF is to develop theorems about solutions of several problem classes.
Reference: [4] <author> R.S.Bird. </author> <title> Lectures on constructive functional programming. </title> <editor> In M.Broy, editor, </editor> <booktitle> Constructive Methods in Computing Science, </booktitle> <pages> pages 151-216. </pages> <address> Pringer-Verlag, </address> <year> 1989. </year> <booktitle> NATO ASI Series, </booktitle> <volume> vol. </volume> <month> F55. </month>
Reference-contexts: For a transformational approach to programming however, the method is less appropriate because the programs are not (yet) equipped with a sufficiently rich algebraic structure fit for manipulation. The Bird-Meertens formalism (BMF) is a method for functional programming <ref> [4, 3, 17] </ref>. In this method based on equational reasoning within manipulatively attractive algebraic structures functional expressions are transformed into efficient deterministic programs over a restricted class of datatypes. The main objective of BMF is to develop theorems about solutions of several problem classes.
Reference: [5] <author> R.S.Bird. </author> <title> Tabulation techniques for recursive programs. </title> <booktitle> ACM Computing Surveys 12(4) 403-417 (1980). </booktitle>
Reference-contexts: A first start for such an extension can be found in <ref> [5] </ref>. imperative programming can profit from the BMF laws in correctness proofs for program transformations. With respect to the Aho-Corasick derivation, we may conclude that it provides insight in the structure of algorithms. relations between algorithms are exposed.
Reference: [6] <author> R.S.Bird, J.Gibbons and G.Jones. </author> <title> Formal derivation of a Pattern Matching Algorithm. </title> <booktitle> Science of Computer Programming, </booktitle> <pages> 12(1989) 93-104. </pages>
Reference-contexts: The Knuth-Morris-Pratt (KMP) algorithm can also be derived from scheme 8. It is omitted here because of its length: a state-space transformation is needed to translate the imperative environment over lists into an environment over naturals. In the KMP derivation in <ref> [6] </ref>, this domain transformation is just a simple bijection. One could object that the derivation given in section 4 is incomplete because precompu-tations are not elaborated. That is true, indeed, but we prefer to consider the precompu-tations as independent problems because their elaboration obscures the global structure of the solution.
Reference: [7] <author> R.S.Bird and O.de Moor. </author> <title> Between Dynamic Programming and Greedy: Data Compression. </title> <booktitle> Lecture Notes, International Summer School on Constructive Algorithmics, </booktitle> <volume> vol. 2, </volume> <year> 1992. </year>
Reference-contexts: concrete solution of the problem is available, abstracting from implementation details may yield a suitable algebraic modelling of the problem. the BMF derivation could have been carried out to a further point if the method was extended with tools to reason about implementation details (a possibility which is suggested in <ref> [7] </ref>). A first start for such an extension can be found in [5]. imperative programming can profit from the BMF laws in correctness proofs for program transformations. With respect to the Aho-Corasick derivation, we may conclude that it provides insight in the structure of algorithms. relations between algorithms are exposed.
Reference: [8] <author> J.H.Conway. </author> <title> Regular algebra and finite machines. </title> <publisher> Chapman and Hall, </publisher> <address> London, </address> <year> 1971. </year>
Reference-contexts: If R 2 P (V n ) or P [ Q P (V n ), then (P " Q).R = P.R " Q.R From now on we will identify singleton languages with their unique word. A useful concept is the left factor, see also <ref> [8] </ref>, which can be defined elegantly via Galois connections.
Reference: [9] <author> E.W.Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976 </year>
Reference-contexts: 1. Introduction In Hoare's "An axiomatic basis for computer programming", [13], and Dijkstra's "A Discipline of Programming", <ref> [9] </ref>, the basis is laid for a dominant method in imperative programming, see also [10, 14]. This method with a strong heuristic component based on Hoare logic and stepwise refinement is directed towards the derivation of efficient nondeterministic programs over an arbitrary datatype.
Reference: [10] <author> E.W.Dijkstra and W.H.J.Feijen. </author> <title> Een Methode van Programmeren. </title> <publisher> Academic Service, </publisher> <address> Den Haag, </address> <year> 1984. </year>
Reference-contexts: 1. Introduction In Hoare's "An axiomatic basis for computer programming", [13], and Dijkstra's "A Discipline of Programming", [9], the basis is laid for a dominant method in imperative programming, see also <ref> [10, 14] </ref>. This method with a strong heuristic component based on Hoare logic and stepwise refinement is directed towards the derivation of efficient nondeterministic programs over an arbitrary datatype.
Reference: [11] <author> H.P.J. van Geldrop-van Eijk. </author> <title> Comparing two programming methodologies: Bird-Meertens and Method of Programming. </title> <type> Master's thesis, </type> <institution> University of Utrecht, </institution> <year> 1989. </year>
Reference: [12] <author> H.P.J. van Geldrop-van Eijk. </author> <title> Definitions, laws and proofs for pattern matching. </title> <type> Draft report, </type> <institution> Eindhoven University of Technology, </institution> <year> 1992. </year>
Reference-contexts: Since the Aho-Corasick algorithms scan the text from left to right, their implementation environment can be viewed as a cons-list one and in this environment left-reduces can be efficiently implemented by iterative programs (see <ref> [12] </ref>). To emphasize the fact that the derivation is divided over two different levels we construct its first part on the functional level in section 4.1.
Reference: [13] <author> C.A.R.Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-580, </pages> <month> Oct. </month> <year> 1969. </year>
Reference-contexts: 1. Introduction In Hoare's "An axiomatic basis for computer programming", <ref> [13] </ref>, and Dijkstra's "A Discipline of Programming", [9], the basis is laid for a dominant method in imperative programming, see also [10, 14]. This method with a strong heuristic component based on Hoare logic and stepwise refinement is directed towards the derivation of efficient nondeterministic programs over an arbitrary datatype.
Reference: [14] <author> A.Kaldewaij. </author> <title> Programming: The Derivation of Algorithms. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction In Hoare's "An axiomatic basis for computer programming", [13], and Dijkstra's "A Discipline of Programming", [9], the basis is laid for a dominant method in imperative programming, see also <ref> [10, 14] </ref>. This method with a strong heuristic component based on Hoare logic and stepwise refinement is directed towards the derivation of efficient nondeterministic programs over an arbitrary datatype.
Reference: [15] <author> H.R.Lewis and C.H.Papadimitriou. </author> <title> Elements of the theory of Computation. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year> <month> 28 </month>
Reference-contexts: The essential part of the language structure is recapitulated now, more can be found in <ref> [15] </ref>. Being sets over a fixed universe, V*, languages form a complete distributive and complemented lattice under the inclusion order .
Reference: [16] <author> L. Meertens. </author> <title> Algorithms, towards programming as a mathematical activity. </title> <booktitle> Proc. CWI Symp. on Mathematics and Computer Science. CWI Monographs Vol. </booktitle> <volume> 1. </volume> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: In this sense one can speak of: each (primitive recursive) function over an initial datatype gives rise to a functional program via catamorphisms. The relative costs of functional programs can be calculated, if the existence of some set of atomic operators for the type is assumed. BMF <ref> [16] </ref> takes this view on efficiency by stating that the efficiency of a catamorphism is determined by the operators involved in the constructions of its definition. (Evidently, replacing operators by cheaper ones is one of their improving strategies.) From the previous it will be clear that many (deterministic) problems over an
Reference: [17] <author> L. Meertens. </author> <title> Constructing a calculus of programs. </title> <editor> In J.L.A. van de Snepscheut, editor, </editor> <booktitle> Conference on the Mathematics of Program Construction, </booktitle> <pages> pages 66-90. </pages> <publisher> Springer-Verlag LNCS 375, </publisher> <year> 1989. </year>
Reference-contexts: For a transformational approach to programming however, the method is less appropriate because the programs are not (yet) equipped with a sufficiently rich algebraic structure fit for manipulation. The Bird-Meertens formalism (BMF) is a method for functional programming <ref> [4, 3, 17] </ref>. In this method based on equational reasoning within manipulatively attractive algebraic structures functional expressions are transformed into efficient deterministic programs over a restricted class of datatypes. The main objective of BMF is to develop theorems about solutions of several problem classes.
Reference: [18] <author> L.Meertens. </author> <title> Paramorphisms. </title> <journal> Formal Aspects of Computing, </journal> <volume> (1992) 4 </volume> <pages> 413-424. </pages>
Reference-contexts: Typically, catamorphisms are functions which may occur in (the definition part of) functional programs. One speaks of: catamorphisms are programs. Not every function over an initial datatype is a catamorphism, but there is a uniform way to extend a function to a catamorphic form: tupling with the identity function, <ref> [18] </ref>. In this sense one can speak of: each (primitive recursive) function over an initial datatype gives rise to a functional program via catamorphisms. The relative costs of functional programs can be calculated, if the existence of some set of atomic operators for the type is assumed.

References-found: 18

