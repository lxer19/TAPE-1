URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/smrc-96.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Email: freinwald,toby,piraheshg@almaden.ibm.com  vibby@watson.ibm.com  
Title: C++ Objects in DB2  
Author: Berthold Reinwald, Toby Lehman, Hamid Pirahesh Vibby Gottemukkala 
Note: To appear in IBM Systems Journal, Volume 35, Number 2, 1996.  
Date: Revised 15 January, 1996  
Address: 650 Harry Road (k55-B1), San Jose, CA 95120  P.O. Box 704, Yorktown Heights, NY 10598  
Affiliation: IBM Almaden Research Center  IBM T.J. Watson Research Center  
Abstract: In today's heterogeneous development environments, application programmers have the responsibility to segment their application data and store relational data in RDBMSs, C++ objects in OODBMSs, SOM objects in OMG persistent stores, and OpenDoc or OLE compound documents in document files. In addition, they must deal with multiple server systems with different query languages as well as large amounts of heterogeneous data. This paper describes SMRC, 1 an RDBMS extender that provides the ability to store objects created in external type systems like C++ or SOM in a relational database, co-resident with existing relational or other heterogeneous data. Using SMRC, applications can store and retrieve objects via standard SQL query language and invoke methods on the objects, without requiring any modifications to the original object definitions. Furthermore, the stored objects fully participate in all the characteristic features of the underlying relational database, e.g., transactions, backup, and authorization. SMRC is implemented on top of IBM's DB2 Common Server for AIX relational database system and heavily exploits its User-Defined Types (UDTs), User-Defined Functions (UDFs), and Large Objects (LOBs) technology. In this paper, the C++ type system is used as a sample external type system to exemplify the SMRC approach, i.e., C++ objects are stored in relational databases. Similar efforts are required for SOM or OLE objects. 1 SMRC stands for Shared Memory-Resident Cache; we pronounce it[smarc]. SMRC is available on CompuServe under the 
Abstract-found: 1
Intro-found: 1
Reference: [AGK + 93] <author> R. Ananthanarayanan, V. Gottemukkala, W. Kafer, T. Lehman, and H. Pirahesh. </author> <title> Using the coexistence approach to achieve combined functionality of object-oriented and relational systems. </title> <booktitle> In Proc. of the SIGMOD Int. Conf. on Management of Data (Washington D.C.), </booktitle> <pages> pages 109-118. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper describes the SMRC prototype implementation at the IBM Almaden Research Center to store C++ objects in an RDBMS like DB2 Common Server for AIX by exploiting its UDT, UDF and LOB technology <ref> [AGK + 93, RDC + 95] </ref>.
Reference: [And90] <author> T. Andrews. </author> <title> The Vbase object database environment. </title> <editor> In A. Cardenas and D. McLeod, editors, </editor> <booktitle> Research Foundations in Object-Oriented and Semantic Database Systems. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year>
Reference-contexts: This approach is similar to the ObjectStore approach [LLOW91], that maintains a hash table mapping type names into vtable addresses. The table is created during ObjectStore's internal schema generation time at application startup time. Ontos' approach (Vbase), making the vtables persistent as well, does not seem to be appropriate <ref> [And90] </ref>. A constructor approach is exploited by O++ (Ode [DAG93]), that introduces a "faked" new operator (does not allocate memory). The new operator triggers the execution of a constructor which fixes all the hidden pointers.
Reference: [BDG93] <author> A. Biliris, S. Dar, and N. Gehani. </author> <title> Making C++ objects persistent: the hidden pointers. </title> <journal> Software Practice and Experience, </journal> <volume> 23 </volume> <pages> 1285-1303, </pages> <year> 1993. </year> <month> 26 </month>
Reference-contexts: Unfortunately, C++ sets the hidden pointers only when an object is created with the new operator as part of the constructor execution and does not export a callable "swizzle" function. A thorough discussion of the whole hidden pointers issue can be found in <ref> [BDG93] </ref>. SMRC swizzles the vtable pointers by allocating dummy objects with a correct vtable pointer (one that was created in the current instance of the application) and "steals" the correct value of the vtable pointer. The SMRC schema compiler provides the location of the vtable pointer in an object.
Reference: [Cat91a] <author> R. Cattel. </author> <title> Editor of special section on next-generation database sytems. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 30-120, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: It is the growing interest in OO applications, coupled with the attractive features of RDBMSs, that led to the advent of extended RDBMSs, e.g., systems like Postgres and Starburst, as well as OODBMSs, e.g., systems like ObjectStore, O 2 , GemStone, and Versant <ref> [Cat91b, Cat91a, KM94] </ref>. Since then, OODBMSs have matured significantly, established market presence and increased market share. At the same time, RDBMS vendors saw some of the same OO trends and subsequently developed object-relational DBMSs (ORDBMS), e.g., systems like UniSQL ([Kim94]), Illustra ([Ill94]), and DB2 ([Cha96]).
Reference: [Cat91b] <author> R. Cattell. </author> <title> Object Data Management: Object-oriented and Extended Relational Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: It is the growing interest in OO applications, coupled with the attractive features of RDBMSs, that led to the advent of extended RDBMSs, e.g., systems like Postgres and Starburst, as well as OODBMSs, e.g., systems like ObjectStore, O 2 , GemStone, and Versant <ref> [Cat91b, Cat91a, KM94] </ref>. Since then, OODBMSs have matured significantly, established market presence and increased market share. At the same time, RDBMS vendors saw some of the same OO trends and subsequently developed object-relational DBMSs (ORDBMS), e.g., systems like UniSQL ([Kim94]), Illustra ([Ill94]), and DB2 ([Cha96]).
Reference: [Cat94] <author> R. Cattell. </author> <title> The Object Database Standard: </title> <publisher> ODMG|93. Morgan-Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: SMRC supports two different approaches to "declare" external pointers, and the application programmer can opt between the two choices as appropriate. * Template-based Approach: An external pointer is declared within the C++ class definition via a SMRC provided Ref template. This approach is like the ODMG-93 C++ language binding <ref> [Cat94] </ref>. class shipment - ... Ref&lt;package&gt; pkg; -; * Flagging-based Approach: An external pointer is flagged via a SMRC macro in the application schema source file. void dummy () - ...
Reference: [Cha96] <author> D. Chamberlin. </author> <title> Using the New DB2: IBM's Object-Relational Database System. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference: [DAG93] <author> S. Dar, R. Agrawal, and N. Gehani. </author> <title> The O++ database programming language: implementation and experience. </title> <booktitle> In Proc. of the Int. Conf. on Data Engineering (Vienna). IEEE Computer Society, </booktitle> <year> 1993. </year>
Reference-contexts: The table is created during ObjectStore's internal schema generation time at application startup time. Ontos' approach (Vbase), making the vtables persistent as well, does not seem to be appropriate [And90]. A constructor approach is exploited by O++ (Ode <ref> [DAG93] </ref>), that introduces a "faked" new operator (does not allocate memory). The new operator triggers the execution of a constructor which fixes all the hidden pointers.
Reference: [Dat95] <author> C. Date. </author> <title> An Introduction to Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, 6th edition, </address> <year> 1995. </year>
Reference-contexts: In this section, we first show why these approaches are inadequate, and then we present the approach pursued by SMRC. 2.1 Traditional approach and related work Data to be stored in a relational database system must first be normalized, following the well-known relational normalization rules <ref> [Dat95] </ref>. Normalization typically results in a corresponding table per object type, with a corresponding column per data member [Loo93]. Most existing database applications are designed in this way. However, this approach poses some problems when applied to class definitions that involve additional language concepts like encapsulation, inheritance and substitutability.
Reference: [DCL + 93] <author> L. DeMichiel, D. Chamberlin, B. Lindsay, R. Agrawal, and M. Arya. Polyglot: </author> <title> Extensions to relational databases for sharable types and functions in a multi-language environment. </title> <booktitle> In Proc. of the Int. Conf. on Data Engineering (Vienna), </booktitle> <pages> pages 651-661. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: Some of the above problems may remain even if OO features are added to existing RDBMSs. For instance, systems such as Polyglot <ref> [DCL + 93] </ref> and others [PM91] introduce their own type systems with their own notions of encapsulation, inheritance, and substitutability.
Reference: [ES90] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: the referenced package object, swizzle the retrieved object, and install it in main memory so that the object can be referenced by C++. 8 In C++, a similar concept to external pointers is called "smart pointers", because they behave more intelligently and perform additional work compared to normal C++ pointers <ref> [ES90] </ref>. 15 The assignment of external pointers is different from internal pointers as additional information is re-quired, such as the table and column in which an application stored the referenced object. This information is provided in an assignment method. <p> The swizzling of vtable pointers (the same approach is applied for function pointers) is described in the next section. [RDC + 95] elaborates on the incorporation of user-provided functions to swizzle unions and dynamic arrays. 4.4 Hidden pointers C++ compilers implement dynamic dispatching and substitutability <ref> [ES90] </ref> via two types of the so-called "hidden" pointers: vtable pointers and virtual base offset pointers. Figure 4 shows the object layout of the shipping class hierarchy introduced in Figure 1 (a) and highlights the compiler-introduced vtable and virtual base offset pointers.
Reference: [HM93a] <author> A. Hosking and E. Moss. </author> <title> Object fault handling for persistent programming languages: A performance evaluation. </title> <booktitle> In Proc. of the Int. Conf. on Object-Oriented Programming Systems, Languages, and Applications (Washington DC), </booktitle> <pages> pages 288-303. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: On the other hand, fielding a page protection trap from the operating system is an expensive operation. Studies by Hosking and Moss <ref> [HM93b, HM93a] </ref> show that software solutions can be more efficient. Detailed performance comparisons and a discussion of the tradeoffs between software dereferencing and memory-mapped storage systems with page protection traps (E versus QuickStore) can be found in [WD94].
Reference: [HM93b] <author> A. Hosking and E. Moss. </author> <title> Protection traps and alternatives for memory management of an object-oriented language. </title> <booktitle> In Proc. of the 14th Symposium on Operating Systems Principles (Asheville, NC), </booktitle> <pages> pages 106-119. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: On the other hand, fielding a page protection trap from the operating system is an expensive operation. Studies by Hosking and Moss <ref> [HM93b, HM93a] </ref> show that software solutions can be more efficient. Detailed performance comparisons and a discussion of the tradeoffs between software dereferencing and memory-mapped storage systems with page protection traps (E versus QuickStore) can be found in [WD94].
Reference: [HSS95] <author> A. Van Hoff, S. Shaio, and O. Starbuck. </author> <title> Hooked on Java. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: SOM supports the building and packaging of binary class libraries, so that object classes produced by one C++ compiler can be used from C++ programs (or even other languages) built with another compiler. An interpreted language, such as Java <ref> [HSS95] </ref>, might also be able to solve the heterogeneity problem. 10 SMRC tracks type and relocation information for pointer swizzling purposes. The type information provides the pointer offsets to achieve addressability of the pointer data members in the objects. <p> Furthermore, SMRC requires a homogeneous client/server platform for the object format. Unfortunately, the problem of building a general-purpose object translator (including the translation of the method code) across multiple platforms is extremely difficult. Interestingly, the solution may lie in a different language such as Java <ref> [HSS95] </ref>, a new programming language offered by SUN Microsystems. Java, an interpreted language, is machine independent. Java methods can easily be moved across platforms to any machine that has a Java interpreter. We are exploring this possibility. A secondary issue is the implementation of external references.
Reference: [IBM93a] <author> IBM Corp. </author> <title> AIX General Programming Concepts, </title> <address> 3.2 edition, </address> <year> 1993. </year>
Reference-contexts: are only used for page protection traps and the protected pages can serve many different external pointers. 10 Many operating systems provide primitives for memory mapping, manipulation of page protection, and setting up of signal handlers to be invoked in the event of an access violation: mmap, mprotect, and sigaction <ref> [IBM93a] </ref>. In this way, the paging hardware's ability to trap on access violation can be exploited by systems like SMRC. 22 5 Performance We evaluated the performance of SMRC through experiments that were implemented on an RS/6000 with 128 MB main memory running AIX 3.2.5 and DB2 Version 2.1.
Reference: [IBM93b] <institution> IBM Corp. C Set ++ for AIX/6000, </institution> <note> User's Guide, 2.1 edition, </note> <year> 1993. </year>
Reference-contexts: A persistence schema is compiler-specific due to the compiler-specific allocation of the hidden pointers within the objects, but not machine-dependent, as the persistence schema uses only symbolic information. 6 The current SMRC implementation uses IBM's C Set ++ compiler <ref> [IBM93b] </ref>. The following application schema source file shows the flagging of the shipping application in Figure 1 (a).
Reference: [IBM93c] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit, User's Guide, 2.0 edition, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: They offer method APIs for their own generic storage libraries and, for portability reasons, link in appropriate SQL runtime libraries provided by the RDBMS vendors. Market acceptance as well as performance are critical issues for these approaches. Persistence frameworks like PSOM <ref> [IBM93c, Lau94] </ref>, OMG Persistence Service [Ses94] and Taligent provide an object-oriented infrastructure to make objects persistent. Framework classes can be sub-classed by the user in order to customize how and where objects should be stored. The application program must use a framework's infrastructure and API to achieve persistence. <p> section we describe the SMRC ADT mapping API, and employ a more comprehensive version of the previously introduced shipping application to demonstrate the use of the API. 6 Object-level incompatibility is created by competing compiler vendors, and could be solved by language neutral development environments like SOM (System Object Model <ref> [IBM93c, Lau94] </ref>). SOM supports the building and packaging of binary class libraries, so that object classes produced by one C++ compiler can be used from C++ programs (or even other languages) built with another compiler.
Reference: [Ill94] <institution> Illustra Information Technologies Inc. </institution> <note> Illustra Users Guide, Illustra Server, 2.1 edition, </note> <month> June </month> <year> 1994. </year>
Reference: [JR91] <author> R. Johnson and V. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Techn. Report UIUCDCS 91-1696, </type> <institution> University of Illinois, </institution> <year> 1991. </year>
Reference: [Kim94] <author> W. Kim. </author> <title> UniSQL/X unified relational and object-oriented database system. </title> <booktitle> In Proc. of the SIGMOD Int. Conf. on Management of Data (Minneapolis), </booktitle> <pages> page 481. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference: [KM94] <author> A. Kemper and G. Moerkotte. </author> <title> Object-oriented Database Management: </title> <booktitle> Applications in Engineering and Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1994. </year>
Reference-contexts: It is the growing interest in OO applications, coupled with the attractive features of RDBMSs, that led to the advent of extended RDBMSs, e.g., systems like Postgres and Starburst, as well as OODBMSs, e.g., systems like ObjectStore, O 2 , GemStone, and Versant <ref> [Cat91b, Cat91a, KM94] </ref>. Since then, OODBMSs have matured significantly, established market presence and increased market share. At the same time, RDBMS vendors saw some of the same OO trends and subsequently developed object-relational DBMSs (ORDBMS), e.g., systems like UniSQL ([Kim94]), Illustra ([Ill94]), and DB2 ([Cha96]).
Reference: [Lau94] <author> C. Lau. </author> <title> Object-Oriented Programming Using SOM and DSOM. </title> <publisher> Van Nostrand Reinhold, Thomson Publ. Company, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: They offer method APIs for their own generic storage libraries and, for portability reasons, link in appropriate SQL runtime libraries provided by the RDBMS vendors. Market acceptance as well as performance are critical issues for these approaches. Persistence frameworks like PSOM <ref> [IBM93c, Lau94] </ref>, OMG Persistence Service [Ses94] and Taligent provide an object-oriented infrastructure to make objects persistent. Framework classes can be sub-classed by the user in order to customize how and where objects should be stored. The application program must use a framework's infrastructure and API to achieve persistence. <p> section we describe the SMRC ADT mapping API, and employ a more comprehensive version of the previously introduced shipping application to demonstrate the use of the API. 6 Object-level incompatibility is created by competing compiler vendors, and could be solved by language neutral development environments like SOM (System Object Model <ref> [IBM93c, Lau94] </ref>). SOM supports the building and packaging of binary class libraries, so that object classes produced by one C++ compiler can be used from C++ programs (or even other languages) built with another compiler.
Reference: [LG96] <author> T. Lehman and P. Gainer. </author> <title> DB2 Lobs: The teenage years. </title> <booktitle> In Proc. of the Int. Conf. on Data Engineering (New Orleans). IEEE Computer Society, </booktitle> <year> 1996. </year>
Reference-contexts: The BLOB type is a special form of LOB. In DB2, it can contain up to two gigabytes of binary data <ref> [LG96] </ref>. 6 just C++ pointers and are treated separately. We implemented two different approaches for external pointers, one of which is compatible with pre-existing class libraries.
Reference: [Lin95] <author> D. Linthicum. Rethinking C++. </author> <title> DBMS Magazine, </title> <type> 8(5), </type> <month> May </month> <year> 1995. </year>
Reference-contexts: In contrast, SMRC concentrates on new OO data that was created in an OO application and then is stored in an RDBMS. Other kinds of products provide portable C++ class library interfaces to relational databases. For instance, the class library from Rogue Wave Software <ref> [Lin95] </ref> contains classes like column, row, cursor, table, etc., to communicate with an RDBMS under the cover.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <year> 1991. </year>
Reference-contexts: The SMRC schema compiler provides the location of the vtable pointer in an object. This approach is similar to the ObjectStore approach <ref> [LLOW91] </ref>, that maintains a hash table mapping type names into vtable addresses. The table is created during ObjectStore's internal schema generation time at application startup time. Ontos' approach (Vbase), making the vtables persistent as well, does not seem to be appropriate [And90]. <p> At object load time, SMRC swizzles an external pointer to a protected page and installs a signal handler to catch the segmentation violation at dereference time (page protection traps). 10 Similar page protection approaches are implemented in ObjectStore <ref> [LLOW91] </ref>, Texas Persistent Store [WK92], and QuickStore [WD94].
Reference: [Loo93] <author> M. Loomis. </author> <title> Object and relational technologies. </title> <journal> Object Magazine, </journal> <pages> pages 35-43, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Normalization typically results in a corresponding table per object type, with a corresponding column per data member <ref> [Loo93] </ref>. Most existing database applications are designed in this way. However, this approach poses some problems when applied to class definitions that involve additional language concepts like encapsulation, inheritance and substitutability.
Reference: [Lot95] <author> Lotus Notes, </author> <title> Cambridge, MA. Application Program Interface (API) User Guide Release 4.0, </title> <year> 1995. </year>
Reference-contexts: However, certain parts of the container, which are accessed frequently or must be indexable, can always be stored separately in addition to the container. Technology like Notes/FX (Field eXchange) is available to automatically synchronize the values in the container and the separately stored values <ref> [Lot95] </ref>.
Reference: [Mel94] <editor> J. Melton, editor. </editor> <title> Database Language SQL3. </title> <institution> American National Standards Institute (ANSI) Database Committee (X3H2), </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: As a result, there is constant pressure on RDBMSs vendors to provide additional functionality for storing objects that were created in the external type system of an OO programming language. This functionality goes beyond UDTs, UDFs, and LOBs in SQL3 <ref> [Mel94] </ref>. UDTs extend the relational type system with new data types, based on the relational built-in data types. The UDF mechanism provides a way to add functions to the existing base of relational built-in functions. <p> A distinct type essentially is a renamed built-in database type <ref> [Mel94] </ref>. The size of the distinct type is the size of the largest class in the class hierarchy (plus 4 bytes for the type tag).
Reference: [Mos92] <author> J. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <year> 1992. </year>
Reference-contexts: In the template-based approach, SMRC pursues "swizzling on discovery" <ref> [WD92, Mos92] </ref>. Un-swizzled pointers in loaded objects are swizzled as soon as they are discovered, i.e., during assignment or pointer dereferencing. For this purpose, the Ref template implements overloaded assignment and dereference operators. The approach avoids having un-swizzled pointers in local variables and unnecessary object loading.
Reference: [OHE94] <author> R. Orfali, D. Harkey, and J. Edwards. </author> <title> Essential Client/Server Survival Guide. </title> <publisher> Van Nostrand Reinhold, Thomson Publ. Company, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: We do not impose any additional restrictions on such statements. These statements can be dynamic, or static for better performance, and can flow across any supported API, such as DRDA [Zim94], ODBC <ref> [OHE94] </ref>, etc. They can also be interactive or embedded in applications. 7 Typically, users store many columns with one SQL insert statement, including the C++ object column. This is important for performance.
Reference: [Per93] <institution> Persistence Software Inc., </institution> <address> San Mateo, CA. </address> <booktitle> Persistence User Manual, </booktitle> <address> 1.2 edition, </address> <year> 1993. </year>
Reference-contexts: However, this approach poses some problems when applied to class definitions that involve additional language concepts like encapsulation, inheritance and substitutability. Nevertheless, some schema-mapper products available in the market place support a (semi-)automatic mapping of class definitions to relational schemata, e.g., Persistence <ref> [Per93] </ref> and Subtleware [Sub94]. In these products class definitions are mapped to tables, exposing data members (even the private ones) and spreading nested data structures across tables. Class hierarchies are mapped either in a collection of tables or a super table.
Reference: [PM91] <author> H. Pirahesh and C. Mohan. </author> <title> Evolution of relational DBMSs toward object support: A practical viewpoint. </title> <institution> Research Report RJ8324, IBM Almaden Research Center, </institution> <year> 1991. </year>
Reference-contexts: Some of the above problems may remain even if OO features are added to existing RDBMSs. For instance, systems such as Polyglot [DCL + 93] and others <ref> [PM91] </ref> introduce their own type systems with their own notions of encapsulation, inheritance, and substitutability.
Reference: [RDC + 95] <author> B. Reinwald, S. Dessloch, M. Carey, T. Lehman, H. Pirahesh, and V. Srinivasan. </author> <title> Making real data persistent: Initial experiences with SMRC. </title> <editor> In M. Atkinson, D. Maier, and Veronique Benzaken, editors, </editor> <booktitle> Proc. of the Int. Workshop on Persistent Object Systems (Tarascon, France, 1994), Workshops in Computing, </booktitle> <pages> pages 202-216, </pages> <address> Berlin, 1995. </address> <publisher> Springer-Verlag. </publisher> <pages> 28 </pages>
Reference-contexts: This paper describes the SMRC prototype implementation at the IBM Almaden Research Center to store C++ objects in an RDBMS like DB2 Common Server for AIX by exploiting its UDT, UDF and LOB technology <ref> [AGK + 93, RDC + 95] </ref>. <p> The figure shows C++ objects of three PERT charts allocated in so-called SMRC heaps, which are mapped into the schedule column of table projects. The implementation of a "real" BLOB mapping application (and the related experiences) using SMRC is described in an earlier paper <ref> [RDC + 95] </ref>. SMRC supports additional functionality for external pointers (as opposed to internal pointers.) An external pointer contains all the information required to retrieve the referenced object from the database. SMRC is able to fault in the referenced object from the database automatically when the external pointer is dereferenced. <p> Similar approaches to capture C++ class information are pursued by OODBMSs. The use of additional flagging macros in an application schema source file provides a way for users to plug in user-provided functions for unions, or repeating functions for dynamic arrays. The overall schema compilation process is described in <ref> [RDC + 95] </ref>. #include "smrc_macros.h" #include "shipping.h" void dummy () - SMRC_TYPE (shipment); SMRC_TYPE (overseas); -; 3.3 Application programming interface for ADT mapping In this section we describe the SMRC ADT mapping API, and employ a more comprehensive version of the previously introduced shipping application to demonstrate the use of the <p> An application can allocate objects directly in the SMRC heap, via the SMRC overloaded new operator, or it can alternatively create C++ objects in its own heap and then later call the SMRC "deep object copy" routine, which copies a complex network of referenced objects into a SMRC heap (see <ref> [RDC + 95] </ref> for details). Each SMRC heap has a root object (or, potentially multiple root objects) that gives the application an entry point to the network of objects within a heap. The entire heap of objects is stored in binary format in a relational table. <p> Details on swizzling external pointers are described in Section 4.6. The previously described pointer swizzling approaches are used for user-defined pointers. The swizzling of vtable pointers (the same approach is applied for function pointers) is described in the next section. <ref> [RDC + 95] </ref> elaborates on the incorporation of user-provided functions to swizzle unions and dynamic arrays. 4.4 Hidden pointers C++ compilers implement dynamic dispatching and substitutability [ES90] via two types of the so-called "hidden" pointers: vtable pointers and virtual base offset pointers.
Reference: [Ses94] <author> R. </author> <title> Sessions. Object Persistence The OMG standard. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1994. </year> <month> pre-print. </month>
Reference-contexts: They offer method APIs for their own generic storage libraries and, for portability reasons, link in appropriate SQL runtime libraries provided by the RDBMS vendors. Market acceptance as well as performance are critical issues for these approaches. Persistence frameworks like PSOM [IBM93c, Lau94], OMG Persistence Service <ref> [Ses94] </ref> and Taligent provide an object-oriented infrastructure to make objects persistent. Framework classes can be sub-classed by the user in order to customize how and where objects should be stored. The application program must use a framework's infrastructure and API to achieve persistence.
Reference: [Sub94] <author> Subtle Software Inc., Billerica, MA. </author> <title> Subtleware for C++/SQL: Product Concepts and Overview, </title> <year> 1994. </year>
Reference-contexts: However, this approach poses some problems when applied to class definitions that involve additional language concepts like encapsulation, inheritance and substitutability. Nevertheless, some schema-mapper products available in the market place support a (semi-)automatic mapping of class definitions to relational schemata, e.g., Persistence [Per93] and Subtleware <ref> [Sub94] </ref>. In these products class definitions are mapped to tables, exposing data members (even the private ones) and spreading nested data structures across tables. Class hierarchies are mapped either in a collection of tables or a super table.
Reference: [WD92] <author> S. White and D. Dewitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB) (Vancouver, Canada), </booktitle> <pages> pages 419-431, </pages> <year> 1992. </year>
Reference-contexts: Saving the previous load address of a heap is the more efficient swizzle approach for the BLOB mapping than traversing and de-swizzling all the objects in a heap. This approach is similar to the memory-mapped segments in ObjectStore <ref> [WD92] </ref>, of course without doing memory-mapping. In ObjectStore, the pointers in the pages of a segment are swizzled on the basis of the relocation of the segment. <p> In the template-based approach, SMRC pursues "swizzling on discovery" <ref> [WD92, Mos92] </ref>. Un-swizzled pointers in loaded objects are swizzled as soon as they are discovered, i.e., during assignment or pointer dereferencing. For this purpose, the Ref template implements overloaded assignment and dereference operators. The approach avoids having un-swizzled pointers in local variables and unnecessary object loading.
Reference: [WD94] <author> S. White and D. DeWitt. </author> <title> QuickStore: A high performance mapped object store. </title> <booktitle> In Proc. of the SIGMOD Int. Conf. on Management of Data (Minneapolis), </booktitle> <pages> pages 395-406. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: At object load time, SMRC swizzles an external pointer to a protected page and installs a signal handler to catch the segmentation violation at dereference time (page protection traps). 10 Similar page protection approaches are implemented in ObjectStore [LLOW91], Texas Persistent Store [WK92], and QuickStore <ref> [WD94] </ref>. <p> Studies by Hosking and Moss [HM93b, HM93a] show that software solutions can be more efficient. Detailed performance comparisons and a discussion of the tradeoffs between software dereferencing and memory-mapped storage systems with page protection traps (E versus QuickStore) can be found in <ref> [WD94] </ref>.
Reference: [WK92] <author> P. R. Wilson and S. V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proc. of the Int. Workshop on Object Orientation in Operating Systems (Paris, France), </booktitle> <pages> pages 364-377. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1992. </year>
Reference-contexts: At object load time, SMRC swizzles an external pointer to a protected page and installs a signal handler to catch the segmentation violation at dereference time (page protection traps). 10 Similar page protection approaches are implemented in ObjectStore [LLOW91], Texas Persistent Store <ref> [WK92] </ref>, and QuickStore [WD94].

References-found: 38

