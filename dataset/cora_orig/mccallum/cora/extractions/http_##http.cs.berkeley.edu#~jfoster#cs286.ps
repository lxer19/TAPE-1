URL: http://http.cs.berkeley.edu/~jfoster/cs286.ps
Refering-URL: http://http.cs.berkeley.edu/~jfoster/
Root-URL: 
Email: jfoster@cs.berkeley.edu  mct@cs.berkeley.edu  
Title: Indexing for String Queries using Generalized Search Trees  
Author: Jeff Foster Megan Thomas 
Abstract: We present five index trees designed for supporting string searches. We discuss Counted Trees, Substring Trees, and Regular Expression Trees, all of which suffer the same problem - their attempts at approximating a large set of data lead to an almost complete lack of information in the interior nodes. A variant of B-Trees, called a Prefix-Suffix Tree, avoids this difficulty by severely restricting the form of queries. Finally, we show that very high redundancy also avoids this pitfall, using a Suffix B-Tree. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho90] <author> A. V. Aho. </author> <title> Algorithms for Finding Patterns in Strings. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 257-300. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Thus, compact disk representations increase fan-out. In our experiments, we assume a page size of 8KB. For a full description of GiST, see [HNP95]. 1.2 Related Work There is an extensive literature on string searching. A good general introduction is <ref> [Aho90] </ref>. One of the earliest indexing techniques for fast substring searches is the suffix tree, which is a compact representation that encodes every possible suffix of the dataset [McC76].
Reference: [BJEG95] <author> A. Brazma, I. Jonassen, I. Eidham-mer, and D. Gilbert. </author> <title> Approaches to the automatic discovery of patterns in biosequences. </title> <type> Technical Report Report No 113, </type> <institution> Department of Infor-matics, University of Bergen, Bergen, Norway, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Thus, we want to find patterns in the strings. Learning patterns from sets of strings is an essential task in the world of genetic databases. See <ref> [BJEG95] </ref> for a good survey of this area. In this situation, it is often the case that approximate matching is good enough; [WM92] is a description of the agrep tool, which allows approximate searches for regular expressions. See [KM95] for a much more theoretical treatment of approximate matching.
Reference: [BYG89] <author> R. Baeza-Yates and G. Gonnet. </author> <title> Fast Text Searching for Regular Expressions or Automaton Searching on Tries. </title> <editor> In G. Ausiello, M. Dezani-Ciancaglini, and S. Ronchi Della Rocca, editors, </editor> <booktitle> ICALP '89, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 46-62. </pages> <address> Springer-Verag, Stresa, Italy, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: Krish-nan, Vitter, and Iyer have shown how to use a pruned suffix tree to estimate selectivity of sub-string searches, though not how to do the actual searches [KVI96]. By combining suffix trees with other data structures, Baeza-Yates and Gonnet allow arbitrary regular expression searching in a relatively compact space <ref> [BYG89] </ref>. Unfortunately, though that work is designed for a very large dataset, the Oxford English Dictionary, it does not support transactional semantics. The OED does not often change.
Reference: [CLR90] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> McGraw Hill, </publisher> <year> 1990. </year>
Reference-contexts: One possible definition of LCS (x; y) would be a string z such that x = ffzfi and y = flzffi, where Greek letters stand for arbitrary strings. However, that definition seems overly restrictive. Instead, we use the longest common subsequence definition from <ref> [CLR90] </ref>. Rather than restating this formally, we shall just say that LCS (x; y) is z where all the letters of z appear in sequence in both x and y, except that an arbitrary number of other letters are allowed in between. <p> Our algorithm for computing this information is a straightforward modification of the one given in <ref> [CLR90] </ref>. We write an LCS as a pair (x; d), where x contains the letters of the longest common subsequence and d contains the distances between the letters, e.g. LCS (joe; jef f ) = (je; (0; 1; 2)).
Reference: [Com79] <author> D. Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1979. </year>
Reference-contexts: The topmost DFA has perfect information, but by the time only 64 strings have been thrown in, the union method started making large approximations. By the time we get to 128 strings, the DFA contains no information. 6 Prefix-Suffix Trees A B-Tree <ref> [Com79] </ref> can efficiently support prefix queries on strings.
Reference: [GNU94] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about Strings in Databases. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 303-314, </pages> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: See [KM95] for a much more theoretical treatment of approximate matching. Of course, searching for substrings and regular expressions is not all there is to textual databases. [Loe94] provides a fairly general overview of some techniques that treat data as structured text, rather than as byte strings. <ref> [GNU94] </ref> describes a framework adding string searching and manipulation primitives as part of database queries.
Reference: [Gut84] <author> A. Gutman. R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching. </title> <booktitle> In Proc. 1984 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Boston, MA, </address> <year> 1984. </year>
Reference-contexts: k 2 ) is just jj (k 1 [ k 2 ) k 2 jj 1 , i.e. how much the sum of all the counts stored in e will increase by adding k 2 . * PickSplit uses Guttman's quadratic split algorithm, with the penalty metric as stated above <ref> [Gut84] </ref>. Let P = fk 1 ; k 2 ; : : : ; k n g be a set of keys, and let P 1 and P 2 be the output of PickSplit.
Reference: [HKP97] <author> J. Hellerstein, E. Koutsoupias, and C. Papadimitriou. </author> <title> On the Analysis of Indexing Schemes. </title> <booktitle> In PODS '97, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Given the theoretical inefficiency of such a workload, as documented in <ref> [HKP97] </ref>, we knew from the beginning that this probably would not work. One potential saving grace might be that n, the size of , is fixed, and thus the argument in [HKP97] about subset queries does not directly apply. <p> Given the theoretical inefficiency of such a workload, as documented in <ref> [HKP97] </ref>, we knew from the beginning that this probably would not work. One potential saving grace might be that n, the size of , is fixed, and thus the argument in [HKP97] about subset queries does not directly apply. Unfortunately, it still fails to be efficient in much the same cases. The only time an interior node contains any useful information is when a string with an infrequent letter appears below that node. <p> The height of the tree will also increase by a corresponding amount. In general this is unacceptable for large values of l, though for a small, fixed l it works wonderfully. 8 Future Work In <ref> [HKP97] </ref>, it has been shown that set inclusion workloads have potentially the worst possible access overhead, while B-Trees have the best.
Reference: [HNP95] <author> J. Hellerstein, J. Naughton, and A. Pfeffer. </author> <title> Generalized Search Trees for Database Systems. </title> <booktitle> In Proceedings fo the 21st VLDB Conference, </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: Although we will skip them, they are important in practice, because 1 the fanout of a GiST is determined by the disk's page size. Thus, compact disk representations increase fan-out. In our experiments, we assume a page size of 8KB. For a full description of GiST, see <ref> [HNP95] </ref>. 1.2 Related Work There is an extensive literature on string searching. A good general introduction is [Aho90]. One of the earliest indexing techniques for fast substring searches is the suffix tree, which is a compact representation that encodes every possible suffix of the dataset [McC76]. <p> A more thorough description of an implementation of B-Trees with GiST appears in <ref> [HNP95] </ref>. The Consistent method for this tree takes a key k and a query of the form x ( fl )y. Strings x and y are folded together, and Consistent returns true if the folded string is a prefix of k.
Reference: [HU79] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In this case, loading the data yielded no substrings longer than one letter at the root. 5 Regular Expression Trees The most general string searches commonly available use regular expressions as patterns. The properties of regular expressions and their correspondence with deterministic finite automata (DFAs) are well known <ref> [HU79] </ref>. Within the GiST framework, using DFAs as keys struck us as being a natural technique for indexing both general regular expression and substring queries. A Regular Expression Tree is a tree whose keys contain DFAs. <p> The easiest way to generate such a DFA is to use the standard union algorithm <ref> [HU79] </ref> and then minimize the result. If we apply only this algorithm the becomes an equality. Unfortunately, recall that the fanout of GiST trees is determined by the number of keys that can fit on a disk page. Even compactly represented DFAs tend to be bulky.
Reference: [KM95] <author> J. Knight and E. Myers. </author> <title> Approximate Regular Expression Pattern Matching with Concave Gap Penalties. </title> <journal> Algo-rithmica, </journal> <volume> 14(1) </volume> <pages> 85-121, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: See [BJEG95] for a good survey of this area. In this situation, it is often the case that approximate matching is good enough; [WM92] is a description of the agrep tool, which allows approximate searches for regular expressions. See <ref> [KM95] </ref> for a much more theoretical treatment of approximate matching.
Reference: [KVI96] <author> P. Krishnan, J. Vitter, and B. Iyer. </author> <title> Estimating Alphanumeric Selectivity in the Presence of Wildcards. </title> <booktitle> In Proceedings of the 1996 ACM SIGMOD Internaional Conference on Management of Data (SIGMOD '96), </booktitle> <pages> pages 282-293, </pages> <address> Montreal, Canada, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Krish-nan, Vitter, and Iyer have shown how to use a pruned suffix tree to estimate selectivity of sub-string searches, though not how to do the actual searches <ref> [KVI96] </ref>. By combining suffix trees with other data structures, Baeza-Yates and Gonnet allow arbitrary regular expression searching in a relatively compact space [BYG89]. Unfortunately, though that work is designed for a very large dataset, the Oxford English Dictionary, it does not support transactional semantics. The OED does not often change.
Reference: [Loe94] <author> A. Loeffen. </author> <title> Text Databases: A Survey of Text Models and Systems. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1), </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: See [KM95] for a much more theoretical treatment of approximate matching. Of course, searching for substrings and regular expressions is not all there is to textual databases. <ref> [Loe94] </ref> provides a fairly general overview of some techniques that treat data as structured text, rather than as byte strings. [GNU94] describes a framework adding string searching and manipulation primitives as part of database queries.
Reference: [McC76] <author> E. M. McCreight. </author> <title> A Space-Economical Suffix Tree Construction. </title> <editor> J. </editor> <booktitle> of the ACM 23, </booktitle> <pages> pages 262-272, </pages> <year> 1976. </year>
Reference-contexts: A good general introduction is [Aho90]. One of the earliest indexing techniques for fast substring searches is the suffix tree, which is a compact representation that encodes every possible suffix of the dataset <ref> [McC76] </ref>. Krish-nan, Vitter, and Iyer have shown how to use a pruned suffix tree to estimate selectivity of sub-string searches, though not how to do the actual searches [KVI96].
Reference: [Tra96] <institution> Transaction Processing Performance Council, </institution> <address> San Jose, CA. </address> <booktitle> TPC Benchmark D Standard Specification, 1996. Revision 1.2.2. </booktitle>
Reference-contexts: 1 Introduction Modern benchmarks such as TPC-D <ref> [Tra96] </ref> contain many "like" queries, a restricted form of string pattern matching. However, current databases only index for prefix and suffix searches. As more users want to ask substring and possibly even regular expression queries, it is becoming important to index for these as well. <p> Considering that the average word length in this file is eight letters, having substring searches of fewer than five letters descend every path from the root is unacceptable. The results were even worse when we tried a data file from the TPC-D benchmark <ref> [Tra96] </ref> with longer strings the average length in this dataset was 19 letters. In this case, loading the data yielded no substrings longer than one letter at the root. 5 Regular Expression Trees The most general string searches commonly available use regular expressions as patterns.
Reference: [WM92] <author> S. Wu and U. Manber. </author> <title> Fast Text Searching Allowing Errors. </title> <journal> Communications of the ACM, </journal> <volume> 35(10) </volume> <pages> 83-91, </pages> <month> October </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Thus, we want to find patterns in the strings. Learning patterns from sets of strings is an essential task in the world of genetic databases. See [BJEG95] for a good survey of this area. In this situation, it is often the case that approximate matching is good enough; <ref> [WM92] </ref> is a description of the agrep tool, which allows approximate searches for regular expressions. See [KM95] for a much more theoretical treatment of approximate matching.
References-found: 16

