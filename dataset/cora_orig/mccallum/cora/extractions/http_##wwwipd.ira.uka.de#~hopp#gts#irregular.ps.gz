URL: http://wwwipd.ira.uka.de/~hopp/gts/irregular.ps.gz
Refering-URL: http://wwwipd.ira.uka.de/~hopp/gts/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fhopp,sandersg@ira.uka.de  
Title: Parallel Game Tree Search on SIMD Machines  
Author: Holger Hopp and Peter Sanders 
Keyword: Parallel game tree search, load balancing, program transformations for SIMD.  
Address: 76128 Karlsruhe, Germany  
Affiliation: University of Karlsruhe,  
Abstract: We describe an approach to the parallelization of game tree search on SIMD machines. It turns out that the single-instruction restriction of SIMD-machines is not a big obstacle for achieving efficiency. We achieve speedups up to 5850 on a 16K processor MasPar MP-1 if the search trees are sufficiently large and if there are no strong move ordering heuristics. To our best knowledge, the largest speedups previously reported (usually on MIMD machines) are more than an order of magnitude smaller.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. D. Blumofe and C. E. Leiserson. </author> <title> Scheduling multithreaded computations by work stealing. </title> <booktitle> In Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: This optimization is even more important if a real game is implemented using iterative deepening techniques. The later phases of search contain enough parallelism to be load balanced using standard methods like random polling which are also used in other circumstances <ref> [18, 1, 12] </ref>. Using SIMD machines for parallel game tree search turned out to be not so much different from using MIMD machines. The negamax variant of fffi-search can be broken down into few simple operations.
Reference: 2. <author> V. Cung and L. Gotte. </author> <title> A first step towards the massively parallel game-tree search. </title> <booktitle> In International Workshop on Parallel Processing for Artificial Intelligence, </booktitle> <pages> pages 88-93, </pages> <address> Chambery, 1993. </address> <publisher> Elsevier. </publisher>
Reference-contexts: However, a lot of special tuning appears to be necessary such that it is not clear how far the current techniques will lead. Using even larger scale parallelism as available on SIMD-machines has largely failed so far <ref> [2] </ref>. A principal objective of the work described here is to investigate how game tree search can be parallelized on even larger numbers of PEs. In addition, we use fffi-search as a case study how algorithms with relatively complex control flow can be implemented by an efficient data parallel program.
Reference: 3. <author> O. I. El-Dessouki and W. H. Huen. </author> <title> Distributed enumeration on between comput-ers. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-29(9):818-825, </volume> <month> September </month> <year> 1980. </year>
Reference-contexts: The right minimal tree can be distributed quickly, without communication. Each PE generates the subtree for which it is responsible using only the root node and its PE number <ref> [3] </ref>. The root's negamax value is evaluated in several sequential phases, one phase for each synchronization node (bottom-up, shown in figure 3). Parallelism is only used within the phases. A preceding phase has evaluated the negamax value of the preceding synchronization node.
Reference: 4. <author> R. Feldmann. </author> <title> Game Tree Search on Massively Parallel Systems. </title> <type> PhD thesis, </type> <institution> Uni-versitat Paderborn, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Early work on parallel game tree search was therefore not able to achieve speedups above 5-10 (e.g. [6]). More recent work is able to exploit todays MIMD machines with up to 1024 processor elements (PEs) <ref> [4, 9] </ref>. However, a lot of special tuning appears to be necessary such that it is not clear how far the current techniques will lead. Using even larger scale parallelism as available on SIMD-machines has largely failed so far [2]. <p> node) in parallel with a search window (1; 1) will effectively change this node to a type-1-node, and it also changes all (indirect) successor node types accordingly. 3.1 The Young Brothers Wait Concept In order to decrease the search overhead, we adopt the Young Brothers Wait Concept (YBWC) introduced in <ref> [4, 5] </ref>: A successor v:J of a node v must not be expanded before the leftmost brother v:1 is completely evaluated. The YBWC significantly reduces the search overhead, but it decreases the available parallelism. Fig. 2. <p> When the minimax value of a type-1-node is evaluated, only one PE is active. These nodes are called synchronization nodes. Other nodes produce weaker synchronizations, resulting in an overall utilization curve like figure 2 a). The second approach in <ref> [4] </ref>, the YBWC-1-2, slightly relaxes YBWC. It only delays the parallel expansion at type-1, type-2 and some type-undefined nodes. This increases the average processor utilization, but it also increases search overhead. YBWC-1-2 does not avoid synchronization nodes. <p> Using less than 16K PEs leads to speedups comparable with speedups achieved on MIMD machines. Even for the difficult geometrically distributed trees (w7d13, p = 0:9) we achieved a speedup of 141 on 1024 PEs, ignoring the SIMD effects this is comparable with MIMD results <ref> [4] </ref>. 5 Conclusions The YBWC as an approach to parallel game tree search does have the potential for large scale parallelism. But the game trees have to be very large if redundant Table 1. <p> For real games, additional problems are likely to occur due to hard to parallelize heuristics. For example, transposition tables are so communication intensive that they can only be used in the upper levels of the search trees <ref> [4, 9] </ref>. A not so severe problem is keeping the PEs busy. The first phases of the search which contain little parallelism due to synchronization nodes can be accelerated using the specialized distribution methods described in section 3.2.
Reference: 5. <author> R. Feldmann, P. Mysliwietz, and B. Monien. </author> <title> Studying overheads in massively parallel min/max-tree evaluation. </title> <booktitle> In ACM Symposium on Parallel Architectures and Algorithms, </booktitle> <pages> pages 94-103, </pages> <year> 1994. </year>
Reference-contexts: node) in parallel with a search window (1; 1) will effectively change this node to a type-1-node, and it also changes all (indirect) successor node types accordingly. 3.1 The Young Brothers Wait Concept In order to decrease the search overhead, we adopt the Young Brothers Wait Concept (YBWC) introduced in <ref> [4, 5] </ref>: A successor v:J of a node v must not be expanded before the leftmost brother v:1 is completely evaluated. The YBWC significantly reduces the search overhead, but it decreases the available parallelism. Fig. 2.
Reference: 6. <author> R. Finkel and J. Fishburn. </author> <title> Parallelism in alpha-beta search. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 89-106, </pages> <year> 1982. </year>
Reference-contexts: The main challenge for parallelization is that the strong tree pruning heuristics like fffi-search used in the sequential case produce very irregular search trees with little or no immediately available parallelism. Early work on parallel game tree search was therefore not able to achieve speedups above 5-10 (e.g. <ref> [6] </ref>). More recent work is able to exploit todays MIMD machines with up to 1024 processor elements (PEs) [4, 9]. However, a lot of special tuning appears to be necessary such that it is not clear how far the current techniques will lead.
Reference: 7. <author> W. D. Hillis. </author> <title> The Connection Machine. </title> <booktitle> Series in Artificial Inteligence. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: Shifts can be routed more efficiently than general permutations on the MasPar. Rendezvous Distribution The masters and slaves are matched using the rendezvous method introduced in <ref> [7] </ref> and improved in [16, 10]. The slaves (= idle PEs) are enumerated, yielding an index i, then each slave sends its processor ID to PE i. These IDs are read by the masters to get a definite slave.
Reference: 8. <editor> H. Hopp. Parallele Spielbaumsuche auf SIMD-Rechnern. Diplomarbeit, </editor> <address> Univer-sitat Karlsruhe, </address> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: In intermediate phases we can at least distribute the right minimal tree. Later, we distribute the right minimal tree up to a certain depth. The complete algorithm is more complex, for a more detailed description refer to <ref> [8] </ref>. The faster distribution at synchronization nodes has reduced the number of iterations in the example in figure 2 from 14144 to 8487. The average processor utilization increased from 18.8% to 34.7%. <p> All potential masters are sorted by "urgency" of the subtrees which can be delivered to slaves. To decrease the cost of the sorting procedure it is useful to sort in a small range, such that a bucket sort algorithm can be used <ref> [8] </ref>. Random Polling consumes less time than rendezvous distribution, because it rarely achieves a processor utilization of 100% and it is not sensitive to the urgency of the transmitted subtree. <p> For a more detailed description of these algorithms refer to <ref> [8] </ref>. The elementary operation "passing ff,fi-values" sends new ff,fi-values to slave PEs. This makes more cutoffs possible and frees PEs working on pruned subtrees. For all but very small game trees this operation decreases the runtime. The second improvement is only rarely useful. <p> YBWC cannot decrease the search overhead as effectively as for uniformly distributed trees. But without YBWC the search overhead is up to 160! We adopt the performance measures introduced in [16] to split the losses of performance into four ratios, which multiplied together yield the efficiency (details in <ref> [8] </ref>). The four performance ratios (in a range [0..1]) are fraction of time working The PEs must suspend searching while doing load balancing and other management operations.
Reference: 9. <author> C. F. Joerg and B. C. Kuszmaul. </author> <title> Massively parallel chess. </title> <booktitle> In Third DIMACS parallel implementation challenge workshop, </booktitle> <pages> pages 299-308. </pages> <institution> Rutgers University, </institution> <year> 1994. </year>
Reference-contexts: Early work on parallel game tree search was therefore not able to achieve speedups above 5-10 (e.g. [6]). More recent work is able to exploit todays MIMD machines with up to 1024 processor elements (PEs) <ref> [4, 9] </ref>. However, a lot of special tuning appears to be necessary such that it is not clear how far the current techniques will lead. Using even larger scale parallelism as available on SIMD-machines has largely failed so far [2]. <p> For real games, additional problems are likely to occur due to hard to parallelize heuristics. For example, transposition tables are so communication intensive that they can only be used in the upper levels of the search trees <ref> [4, 9] </ref>. A not so severe problem is keeping the PEs busy. The first phases of the search which contain little parallelism due to synchronization nodes can be accelerated using the specialized distribution methods described in section 3.2.
Reference: 10. <author> G. Karypis and V. Kumar. </author> <title> Unstructured tree search on SIMD parallel computers. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(10) </volume> <pages> 1057-1072, </pages> <year> 1994. </year>
Reference-contexts: Shifts can be routed more efficiently than general permutations on the MasPar. Rendezvous Distribution The masters and slaves are matched using the rendezvous method introduced in [7] and improved in <ref> [16, 10] </ref>. The slaves (= idle PEs) are enumerated, yielding an index i, then each slave sends its processor ID to PE i. These IDs are read by the masters to get a definite slave. <p> The YBWC-blocking and deblocking demands a frequent load balancing. In our experiments it was a good choice to call the LB operation every 1-5 basic sequences (BS), depending on the game tree size and shape. This is such a high frequency, that more adaptive strategies for triggering <ref> [16, 10] </ref> are not worth the additional expense for counting active PEs. The PV and SM operations should be tested more rarely.
Reference: 11. <author> D. Knuth and W. Moore. </author> <title> An analysis of alpha-beta pruning. </title> <journal> Artificial Intelligence, </journal> <volume> 6(4) </volume> <pages> 293-326, </pages> <year> 1975. </year>
Reference-contexts: If the parallel expansion of right subtrees begins too early, they are searched with the completely open search window (1; 1). In the sequential fffi-algorithm these subtrees are searched with a smaller fi-value, which allows more cutoffs. This can be explained with Knuth and Moore's node types <ref> [11] </ref>: Definition 1.
Reference: 12. <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis. </author> <title> Introduction to Parallel Computing. Design and Analysis of Algorithms. </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: This optimization is even more important if a real game is implemented using iterative deepening techniques. The later phases of search contain enough parallelism to be load balanced using standard methods like random polling which are also used in other circumstances <ref> [18, 1, 12] </ref>. Using SIMD machines for parallel game tree search turned out to be not so much different from using MIMD machines. The negamax variant of fffi-search can be broken down into few simple operations.
Reference: 13. <author> T. A. Marsland and M. Campbell. </author> <title> Parallel search of strongly ordered game trees. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(4) </volume> <pages> 533-551, </pages> <month> Dec. </month> <year> 1982. </year>
Reference-contexts: The higher p, the higher the quality of ordering. Minimal trees are generated with p = 1:0. These synthetic game trees are slightly more ordered than p-ordered trees [17] or strongly ordered trees <ref> [13] </ref>, but the performance results are similar. We used algorithms similar to those in [17] to generate these synthetic game trees. Speedup and efficiency are measured in relation to the sequential fffi-algorithm on the MasPar.
Reference: 14. <author> MasPar Corporation. </author> <title> MasPar System Overview, </title> <month> July </month> <year> 1992. </year>
Reference-contexts: The PEs are interconnected by a router which is able to route arbitrary permutations, a 2D-mesh and a broadcast bus. In addition, the system programming language MPL (an extension of ANSI-C) offers micro-coded primitives for collective operations like reductions and (segmented) prefix operations <ref> [14, 15] </ref>. We use a configuration with 16384 PEs with 16 KB of memory each. FUNCTION fffi (position J; integer ff,fi): integer; VAR j,w,value: integer; BEGIN determine successors J.1 ...
Reference: 15. <institution> MasPar Corporation. </institution> <note> MPL Reference Manual, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: The PEs are interconnected by a router which is able to route arbitrary permutations, a 2D-mesh and a broadcast bus. In addition, the system programming language MPL (an extension of ANSI-C) offers micro-coded primitives for collective operations like reductions and (segmented) prefix operations <ref> [14, 15] </ref>. We use a configuration with 16384 PEs with 16 KB of memory each. FUNCTION fffi (position J; integer ff,fi): integer; VAR j,w,value: integer; BEGIN determine successors J.1 ...
Reference: 16. <author> C. Powley, C. Ferguson, and R. E. Korf. </author> <title> Depth-fist heuristic search on a SIMD machine. </title> <journal> Artificial Intelligence, </journal> <volume> 60 </volume> <pages> 199-242, </pages> <year> 1993. </year>
Reference-contexts: Shifts can be routed more efficiently than general permutations on the MasPar. Rendezvous Distribution The masters and slaves are matched using the rendezvous method introduced in [7] and improved in <ref> [16, 10] </ref>. The slaves (= idle PEs) are enumerated, yielding an index i, then each slave sends its processor ID to PE i. These IDs are read by the masters to get a definite slave. <p> The YBWC-blocking and deblocking demands a frequent load balancing. In our experiments it was a good choice to call the LB operation every 1-5 basic sequences (BS), depending on the game tree size and shape. This is such a high frequency, that more adaptive strategies for triggering <ref> [16, 10] </ref> are not worth the additional expense for counting active PEs. The PV and SM operations should be tested more rarely. <p> The reason is the high search overhead of 5-6 shown in figure 5. YBWC cannot decrease the search overhead as effectively as for uniformly distributed trees. But without YBWC the search overhead is up to 160! We adopt the performance measures introduced in <ref> [16] </ref> to split the losses of performance into four ratios, which multiplied together yield the efficiency (details in [8]). The four performance ratios (in a range [0..1]) are fraction of time working The PEs must suspend searching while doing load balancing and other management operations.
Reference: 17. <author> A. Reinefeld. Spielbaum-Suchverfahren. Informatik-Fachberichte, </author> <title> Band 200. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: w = 0 THEN RETURN g (J); (* leaf evaluation *) END ; value := ff; FOR j:=1 TO w DO value := max (value, -fffi (J.j, -fi, -value)); IF value fi THEN RETURN value; (* cut *) END ; RETURN value; END ; Fig. 1. fffi-algorithm (negamax-variant) (closely following <ref> [17] </ref>). Inputs are a position in the game and a range of results (ff; fi) (search window) which can still influence the overall result (Initially (1; 1)). Output is the quality of the position (Its value). <p> We look at regular trees with fixed depth d and width w for every node. This model is frequently used in the literature <ref> [17] </ref>. The leaf value distribution should simulate successor ordering heuristics with different strength. Two leaf value distributions are used here: Uniformly distributed trees simulate game trees without heuristics for ordering successor nodes. <p> The higher p, the higher the quality of ordering. Minimal trees are generated with p = 1:0. These synthetic game trees are slightly more ordered than p-ordered trees <ref> [17] </ref> or strongly ordered trees [13], but the performance results are similar. We used algorithms similar to those in [17] to generate these synthetic game trees. Speedup and efficiency are measured in relation to the sequential fffi-algorithm on the MasPar. <p> The higher p, the higher the quality of ordering. Minimal trees are generated with p = 1:0. These synthetic game trees are slightly more ordered than p-ordered trees <ref> [17] </ref> or strongly ordered trees [13], but the performance results are similar. We used algorithms similar to those in [17] to generate these synthetic game trees. Speedup and efficiency are measured in relation to the sequential fffi-algorithm on the MasPar. The sequential execution times for larger trees are extrapolated from sequential times on a fast sequential machine.
Reference: 18. <author> P. Sanders. </author> <title> A detailed analysis of random polling dynamic load balancing. </title> <booktitle> In International Symposium on Parallel Architectures Algorithms and Networks, </booktitle> <pages> pages 382-389, </pages> <address> Kanazawa, Japan, 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: A master-slave connection is established, if the master has work available for the slave, and the slave is idle. As shown in <ref> [18] </ref>, a random shift, i. e. connecting PE i with PE i + k mod P guarantees a very effective load distribution. Shifts can be routed more efficiently than general permutations on the MasPar. <p> This optimization is even more important if a real game is implemented using iterative deepening techniques. The later phases of search contain enough parallelism to be load balanced using standard methods like random polling which are also used in other circumstances <ref> [18, 1, 12] </ref>. Using SIMD machines for parallel game tree search turned out to be not so much different from using MIMD machines. The negamax variant of fffi-search can be broken down into few simple operations.
Reference: 19. <author> P. Sanders. </author> <title> Efficient emulation of MIMD behavior on SIMD machines. </title> <type> Technical Report IB 29/95, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, </institution> <year> 1995. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Additionally, we are free to choose any sequence of tests and we can test cheap or important operations more frequently. It turns out that carefully scheduling the test loop makes it possible to considerably reduce SIMD overhead. For a general discussion of this technique refer to <ref> [19] </ref>.
References-found: 19

