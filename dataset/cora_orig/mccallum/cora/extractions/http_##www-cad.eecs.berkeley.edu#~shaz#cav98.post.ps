URL: http://www-cad.eecs.berkeley.edu/~shaz/cav98.post.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~shaz/recent.html
Root-URL: 
Email: Email:ftah,orna,shazg@eecs.berkeley.edu  
Title: From Pre-historic to Post-modern Symbolic Model Checking  
Author: Thomas A. Henzinger Orna Kupferman Shaz Qadeer 
Address: Berkeley, CA 94720-1770, USA  
Affiliation: Department of EECS, University of California at  
Abstract: Symbolic model checking, which enables the automatic verification of large systems, proceeds by calculating with expressions that represent state sets. Traditionally, symbolic model-checking tools are based on backward state traversal; their basic operation is the function pre , which given a set of states, returns the set of all predecessor states. This is because specifiers usually employ formalisms with future-time modalities, which are naturally evaluated by iterating applications of pre. It has been recently shown experimentally that symbolic model checking can perform significantly better if it is based, instead, on forward state traversal; in this case, the basic operation is the function post , which given a set of states, returns the set of all successor states. This is because forward state traversal can ensure that only those parts of the state space are explored which are reachable from an initial state and relevant for satisfaction or violation of the specification; that is, errors can be detected as soon as possible. In this paper, we investigate which specifications can be checked by symbolic forward state traversal. We formulate the problems of symbolic backward and forward model checking by means of two -calculi. The pre- calculus is based on the pre operation; the post-calculus, on the post operation. These two -calculi induce query logics, which augment fixpoint expressions with a boolean emptiness query. Using query logics, we are able to relate and compare the symbolic backward and forward approaches. In particular, we prove that all !-regular (linear-time) specifications can be expressed as post- queries, and therefore checked using symbolic forward state traversal. On the other hand, we show that there are simple branching-time specifications that cannot be checked in this way.
Abstract-found: 1
Intro-found: 1
Reference: [BCG88] <author> M.C. Browne, E.M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propo-sitional temporal logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 59:115131, </address> <year> 1988. </year>
Reference-contexts: The relation fi W fi W 0 is a post-bisimulation (resp. init-post-bisimulation) between K and K 0 if fi is a pre-bisimulation (resp. init-pre-bisimulation) between K 1 and K 01 . The following is an easy extension of a well-known result for pre- <ref> [BCG88] </ref>. Proposition 1. Let K and K 0 be two Kripke structures. There is an init-pre-bisimulation (resp. init-post-bisimulation) between K and K 0 iff for all sentences of pre- (resp. post), we have K j= iff K 0 j= .
Reference: [BCM + 92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. Information and Computation, </title> <address> 98(2):142170, </address> <year> 1992. </year>
Reference-contexts: Commercial model-checking tools need to cope with the exceedingly large state spaces that are present in real-life examples, making the so-called state-explosion problem perhaps the most challenging issue in computer-aided verification. One of the important developments in this area is the discovery of symbolic model-checking methods <ref> [BCM + 92] </ref>. In particular, use of BDDs [Bry86] for model representation has yielded model-checking tools that can handle very large state spaces [CGL93]. Traditional symbolic model-checking tools have been based on backward state traversal [McM93,BHSV + 96].
Reference: [BHSV + 96] <author> R.K. Brayton, G.D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, T. Kukimoto, A. Pardo, S. Qadeer, R.K. Ranjan, S. Sarwary, T.R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: a system for verification and synthesis. </title> <booktitle> In CAV 96: Computer Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pp. 428432, </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: We note that this sentence cannot be handled by the methods presented in [INH96,IN97]. In the table below we list the running times (in seconds) for different values of WINSIZE for checking using VIS <ref> [BHSV + 96] </ref> for both symbolic forward and backward state traversal. The quantity within the parentheses is the number of boolean variables used to encode the state space of the protocol.
Reference: [Bry86] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean-function manipulation. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: One of the important developments in this area is the discovery of symbolic model-checking methods [BCM + 92]. In particular, use of BDDs <ref> [Bry86] </ref> for model representation has yielded model-checking tools that can handle very large state spaces [CGL93]. Traditional symbolic model-checking tools have been based on backward state traversal [McM93,BHSV + 96].
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <publisher> LNCS 354, </publisher> <pages> pp. 428437, </pages> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: i; X 1 i with B 1 = h-; fX 1 = X 2 ^ 9 X 1 gi and B 2 = h; fX 2 = p _ 9 X 2 gi, which is equivalent to the CTL sentence 9293p, and which is not equivalent to any LTL sentence <ref> [CD88] </ref>, does have an equivalent query in post;.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, </booktitle> <volume> LNCS 131, </volume> <pages> pp. 5271, </pages> <publisher> Springer, </publisher> <year> 1981. </year>
Reference: [CGH94] <author> E.M. Clarke, O. Grumberg, and K. Hamaguchi. </author> <title> Another look at LTL model checking. </title> <booktitle> In CAV 94: Computer Aided Verification, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 415 427, </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <booktitle> In Decade of Concurrency Reflections and Perspectives (Proc. REX School), </booktitle> <volume> LNCS 803, </volume> <pages> pp. 124175, </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: One of the important developments in this area is the discovery of symbolic model-checking methods [BCM + 92]. In particular, use of BDDs [Bry86] for model representation has yielded model-checking tools that can handle very large state spaces <ref> [CGL93] </ref>. Traditional symbolic model-checking tools have been based on backward state traversal [McM93,BHSV + 96].
Reference: [CS91] <author> R. Cleaveland and B. Steffen. </author> <title> A linear-time model-checking algorithm for the alternation-free modal -calculus. </title> <booktitle> In CAV 91: Computer Aided Verification, </booktitle> <volume> LNCS 575, </volume> <pages> pp. 4858, </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: The pre-sentence = hB; X 0 i is alternation-free if the dependency relation on the blocks of B is acyclic (i.e., its transitive closure is asymmetric). The model-checking problem for the alternation-free fragment of pre- can be solved in linear time <ref> [CS91] </ref>.
Reference: [Dam94] <author> M. Dam. </author> <title> CTL ? and ECTL ? as fragments of the modal -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 126:7796, </address> <year> 1994. </year>
Reference: [Dil96] <author> David L. Dill. </author> <title> The Mur Verification System. </title> <booktitle> In CAV 96: Computer Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pp. 390393, </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference: [EL86] <author> E.A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the propositional -calculus. </title> <booktitle> In Proc. 1st Symposium on Logic in Computer Science, </booktitle> <pages> pp. 267278, </pages> <year> 1986. </year>
Reference-contexts: Theorem 2. For every B uchi automaton, an equivalent post; query of alternation depth two can be constructed in linear time. In particular, since all sentences of the linear temporal logic LTL can be translated to Buchi automata [VW94], Theorem 2, together with <ref> [EL86] </ref>, implies that all LTL sentences lie in the intersection pre;" post;. Hence, LTL model checking can proceed by symbolic forward state traversal. Since the translation from LTL to Buchi automata involves an exponential blowup, the translation from LTL to post; is also exponential.
Reference: [GK94] <author> O. Grumberg and R.P. Kurshan. </author> <title> How linear can branching-time be. </title> <booktitle> In Proc. 1st International Conference on Temporal Logic, LNAI 827, </booktitle> <pages> pp. 180194, </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Furthermore, every query that can be specified in both pre; and post; cannot distinguish between structures that are both pre-bisimilar and post-bisimilar. Yet the exact characterization of the intersection pre;" post; remains open. In <ref> [GK94] </ref>, the authors identified a set of temporal-logic sentences called equi-linear. In particular, a pre-sentence is equi-linear if it cannot distinguish between two Kripke structures with the same language (i.e., observation sequences that correspond to initialized paths). Clearly, all LTL sentences are equi-linear. <p> Clearly, all LTL sentences are equi-linear. However, some CTL sentences that have no equivalent LTL sentence are also equi-linear. For example, it is shown in <ref> [GK94] </ref> that while the CTL sentence 929 p is not equi-linear, the CTL sentence 9293p is equi-linear. Motivated by the examples from Section 3.2, we conjecture that equi-linearity precisely characterizes the properties that can be model checked using both symbolic forward and backward state traversal.
Reference: [GPVW95] <author> R. Gerth, D. Peled, M.Y. Vardi, and P. Wolper. </author> <title> Simple on-the-fly automatic verification of linear temporal logic. In Protocol Specification, Testing, </title> <booktitle> and Verification, </booktitle> <pages> pp. 318, </pages> <publisher> Chapman, </publisher> <year> 1995. </year>
Reference-contexts: Forward state traversal has several obvious advantages over backward state traversal. First, for operational system models, successor states are often easier to compute than predecessor states. Second, only the reachable part of the state space is traversed. Third, optimizations such as on-the-fly <ref> [GPVW95] </ref> and partial-order [Pel94] methods can be incorporated naturally. For example, in on-the-fly model checking, only those parts of the state space are traversed which are relevant for satisfying (or violating) the given specification. Some of the advantages of forward state traversal can be easily incorporated into symbolic methods.
Reference: [Hol97] <author> G.J. Holzmann. </author> <title> The model checker SPIN. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 23(5):279295, </volume> <year> 1997. </year>
Reference: [IN97] <author> H. Iwashita and T. Nakata. </author> <title> Forward model checking techniques oriented to buggy designs. </title> <booktitle> In Proc. IEEE/ACM International Conference on Computer Aided Design, </booktitle> <pages> pp. 400404, </pages> <year> 1997. </year>
Reference: [INH96] <author> H. Iwashita, T. Nakata, and F. Hirose. </author> <title> CTL model checking based on forward state traversal. </title> <booktitle> In Proc. IEEE/ACM International Conference on Computer Aided Design, </booktitle> <pages> pp. 8287, </pages> <year> 1996. </year>
Reference-contexts: WINSIZE Forward Backward Reach-optimized backward 2 (30) 18 222 91 4 (50) 5231 - Acknowledgments We thank Rajeev Alur, Bob Brayton, Ed Clarke, Allen Emerson, and Orna Grumberg for helpful discussions, and Carl Pixley for drawing the authors' attention to <ref> [INH96] </ref>.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 27:333354, </address> <year> 1983. </year>
Reference-contexts: For this purpose, we define post, a fixpoint calculus that is based on post operations in the same way in which the traditional -calculus, here called pre, is based on pre operations <ref> [Koz83] </ref>. While pre- expressions refer to the future of a given state in a model, post- expressions refer to its past. <p> Finally, in Section 5 we put our results in perspective and report on some experimental evidence for the value of symbolic forward model checking. 2 Definition of Pre and Post Logics 2.1 Pre and post -calculi The -calculus is a modal logic augmented with least and greatest fixpoint operators <ref> [Koz83] </ref>. In this paper, we use the equational form of the propositional -calculus, as in [BC96]. The modalities of the -calculus relate a set of states to a subset of its predecessor states. Therefore, we refer to the -calculus by pre.
Reference: [KP95] <author> O. Kupferman and A. Pnueli. </author> <title> Once and for all. </title> <booktitle> In Proc. 10th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 2535, </pages> <year> 1995. </year>
Reference-contexts: For example, the sentence 82 (grant ! (:init )8 f Wreq), where f W is a past version of the weak-until operator [MP92], specifies that grants are given only upon request. Assuming a branching interpretation for past temporal operators <ref> [KP95] </ref>, this sentence has an equivalent post; query, but no equivalent pre- E query; that is, it can be model checked by symbolic forward state traversal but not by symbolic backward state traversal.
Reference: [KV98] <author> O. Kupferman and M.Y. Vardi. </author> <title> Freedom, weakness, and determinism: from linear-time to branching-time. </title> <booktitle> In Proc. 13th IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1998. </year>
Reference-contexts: Since the translation from LTL to Buchi automata involves an exponential blowup, the translation from LTL to post; is also exponential. Co-B uchi automata Recall that the translation from Theorem 2 results in formulas of alternation depth two. It has been recently argued <ref> [KV98] </ref> that a linear property given by a co-B uchi automaton can be translated into an alternation-free pre; query. 3 Consequently, the model checking of linear properties that are specified by co-Buchi automata requires time that is only linear in the size of the Kripke structure. <p> A co-B uchi automaton A is a finite automaton such that a path of 3 The results in <ref> [KV98] </ref> refer to sentences of the form 8A, for deterministic Buchi automata A. Since an !- regular language can be specified by a deterministic Buchi automaton iff its complement can be specified by a co-Buchi automaton, the corresponding result for 9A, for co-Buchi automata A, follows by duality.
Reference: [LPZ85] <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. In Logics of Programs, </title> <publisher> LNCS 193, </publisher> <pages> pp. </pages> <address> 196218, </address> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: Furthermore, we have focused on specification languages that contain only future temporal operators. Since LTL with past temporal operators is no more expressive than LTL without past operators <ref> [LPZ85] </ref>, every LTL+past sentence can also be translated into an equivalent post; query. In addition, post- also permits the easy evaluation of branching past temporal operators that cannot be evaluated using pre.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: In addition, post- also permits the easy evaluation of branching past temporal operators that cannot be evaluated using pre. For example, the sentence 82 (grant ! (:init )8 f Wreq), where f W is a past version of the weak-until operator <ref> [MP92] </ref>, specifies that grants are given only upon request. Assuming a branching interpretation for past temporal operators [KP95], this sentence has an equivalent post; query, but no equivalent pre- E query; that is, it can be model checked by symbolic forward state traversal but not by symbolic backward state traversal.
Reference: [Pel94] <author> D. Peled. </author> <title> Combining partial order reductions with on-the-fly model-checking. </title> <booktitle> In CAV 94: Computer Aided Verification, </booktitle> <volume> LNCS 818, </volume> <pages> pp. 377390, </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Forward state traversal has several obvious advantages over backward state traversal. First, for operational system models, successor states are often easier to compute than predecessor states. Second, only the reachable part of the state space is traversed. Third, optimizations such as on-the-fly [GPVW95] and partial-order <ref> [Pel94] </ref> methods can be incorporated naturally. For example, in on-the-fly model checking, only those parts of the state space are traversed which are relevant for satisfying (or violating) the given specification. Some of the advantages of forward state traversal can be easily incorporated into symbolic methods.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> LNCS 137, </volume> <pages> pp. 337351, </pages> <publisher> Springer, </publisher> <year> 1981. </year>
Reference: [Var98] <author> M.Y. Vardi. </author> <title> Reasoning about the past with two-way automata. </title> <booktitle> In Proc. 25th International Coll. on Automata, Languages, and Programming, </booktitle> <publisher> LNCS, Springer, </publisher> <year> 1998. </year>
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. Information and Computation, </title> <address> 115(1):137, </address> <year> 1994. </year>
Reference-contexts: Theorem 2. For every B uchi automaton, an equivalent post; query of alternation depth two can be constructed in linear time. In particular, since all sentences of the linear temporal logic LTL can be translated to Buchi automata <ref> [VW94] </ref>, Theorem 2, together with [EL86], implies that all LTL sentences lie in the intersection pre;" post;. Hence, LTL model checking can proceed by symbolic forward state traversal. Since the translation from LTL to Buchi automata involves an exponential blowup, the translation from LTL to post; is also exponential.
References-found: 27

