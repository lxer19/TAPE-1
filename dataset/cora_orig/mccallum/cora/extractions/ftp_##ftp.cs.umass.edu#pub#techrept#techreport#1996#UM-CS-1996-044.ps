URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-044.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/96-044.html
Root-URL: 
Title: A Model for Compound Type Changes Encountered in Schema Evolution  
Author: Barbara Staudt Lerner 
Date: June 12, 1996  
Address: Amherst  
Affiliation: Computer Science Department University of Massachusetts,  
Abstract: Schema evolution is a problem that is faced by long-lived data. When a schema changes, existing persistent data can become inaccessible unless the database system provides mechanisms to access data created with previous versions of the schema. Existing systems that support schema evolution focus on changes local to individual types within the schema, thereby limiting the changes that the database maintainer can perform. We have developed a model of type changes incorporating changes local to individual types as well as compound changes involving multiple types. The model describes both type changes and their impact on data by defining derivation rules to initialize new data based on the existing data. The derivation rules can describe local and non-local changes to types to capture the intent of a large class of type change operations. We have built a system called Tess (Type Evolution Software System) that uses this model to recognize type changes by comparing schemas and then produces a transformer that can update data in a database to correspond to a newer version of the schema. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, W.P. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4), </volume> <year> 1983. </year> <note> Also published in Readings in Object-Oriented Database Systems, </note> <editor> Stanley B. Zdonik and David Maier, eds., </editor> <publisher> Morgan Kauf-man, </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: The transient types can be changed without impacting the persistent data. With persistent programming languages, there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4):575631, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: If type definitions are recursive, as with linked lists for example, recursive comparison of field types leads to an infinite loop. To avoid this, we use an algorithm similar to the one used by Amadio and Cardelli to check subtyping of recursive types <ref> [AC93] </ref>, which limits the recursion performed when comparing recursive types. We cache the results of type comparisons in a matrix so that we can look up the results of previous comparisons instead of repeating them.
Reference: [BFK95] <author> Philippe Breche, Fabrizio Ferrandina, and Martin Kuklok. </author> <title> Simulation of schema change using views. </title> <booktitle> In Proceedings of the 6th International Conference on Database and Expert Systems Applications, </booktitle> <address> London, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: To preserve the data, the maintainer must develop code to move the data explicitly. In GemStone the maintainer directly extends the transformer, while in Orion the maintainer must develop and execute programs to move the data prior to deleting the instance variables containing the data. O 2 <ref> [BFK95] </ref> is another object-oriented database system that supports evolution through the use of operations. In addition to primitives similar to those of Orion and GemStone, O 2 provides high-level operations to manipulate the class hierarchy. These high-level operations are defined as a composition of primitive operations.
Reference: [BKKK87] <author> Jay Banerjee, Won Kim, Hyoung-Joo Kim, and Henry F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD 1987 Annual Conference, </booktitle> <pages> pages 311322, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion <ref> [BKKK87, KK88] </ref> and GemStone [PS87] are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive operations that change individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables. <p> Our derivation rules can be used with his algorithms. 9.5.2 Screening With screening, information is never deleted from objects. Instead the accessing functions hide the appropriate information based upon the version of the code that is accessing the object. Orion <ref> [BKKK87, KK88] </ref> uses screening to evolve its objects. To do so, it uses a clever object representation that allows fast access to objects even after the object's type has been changed. It also restricts the kinds of changes to a subset of our local change model.
Reference: [Bra92] <author> S.E. Bratsberg. </author> <title> Unified class evolution by object-oriented views. </title> <booktitle> In Proceedings of the 11th International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 423439, </pages> <address> Karlsruhe, Ger-many, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the simultaneous maintenance of multiple versions of types and data <ref> [SZ86, Cla94, Bra92, MS92b, TS92] </ref>. With these approaches, multiple versions of the same type exist within a single database. The advantage is that old and new code can operate on old and new data without requiring either to be changed.
Reference: [Cas90] <author> Eduardo Casais. </author> <title> Managing class evolution in object-oriented systems. </title> <editor> In Dennis Tsichritzis, editor, </editor> <booktitle> Object Management, </booktitle> <pages> pages 133195. </pages> <institution> Universite de Geneve, Switzerland, </institution> <year> 1990. </year> <month> 30 </month>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [Cla94] <author> Stewart M. Clamen. </author> <title> Schema evolution and integration. Distributed and Parallel Databases: </title> <note> An International Journal, 2:101126, </note> <year> 1994. </year>
Reference-contexts: Another approach to schema evolution relies on the simultaneous maintenance of multiple versions of types and data <ref> [SZ86, Cla94, Bra92, MS92b, TS92] </ref>. With these approaches, multiple versions of the same type exist within a single database. The advantage is that old and new code can operate on old and new data without requiring either to be changed.
Reference: [DCBM89] <author> Alan Dearle, Richard Connor, Fred Brown, and Ron Morrison. </author> <booktitle> Napier88a database programming language? In Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <pages> pages 179195. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: The transient types can be changed without impacting the persistent data. With persistent programming languages, there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [Fab76] <author> R. Fabry. </author> <title> How to design a system in which modules can be changed on the fly. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <pages> pages 470476, </pages> <address> Los Alamitos, CA, </address> <year> 1976. </year>
Reference-contexts: Type change is also an issue for dynamic module replacement systems whose goal is to replace program components without stopping execution of a program. In this case there is existing data that may need to be transformed even though it is not necessarily persistent data. Existing systems (such as <ref> [Fab76, FS91] </ref>) recognize the need for such transformation functions, but leave the development of those functions to the maintainer. Tess's comparison algorithms could be used to generate these transformation functions. Another situation in which type comparison may be applicable is schema integration.
Reference: [FMZ94] <author> Fabrizio Ferrandina, Thorsten Meyer, and Roberto Zicari. </author> <title> Implementing lazy database updates for an object database system. </title> <booktitle> In Proceedings of the 20th International Conference on Very Large Databases, </booktitle> <pages> pages 261272, </pages> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: For example, in small databases that may belong to an individual user, we can make the database unavailable temporarily and transform all data in the database at once. For large, shared databases, we can employ more sophisticated algorithms such as those developed by Ferrandina <ref> [FMZ94] </ref> to transform individual objects as they are accessed in order to maintain high availability. In situations where the data is shared by many programs, schema changes may also impact a great deal of code. <p> If the database is large or high availability is required, it may not be feasible to take the database off-line. In these cases, lazy conversion can be done as in O 2 <ref> [FMZ94] </ref>. With lazy conversion individual objects are converted as they are accessed. To work with conversion, we would apply a derivation rule locally, but would only convert components of structured objects as they were accessed.
Reference: [FS91] <author> O. Frieder and M. Segal. </author> <title> On dynamically updating a computer program: From concept to prototype. </title> <journal> Journal of Systems and Software, </journal> <pages> pages 111128, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Type change is also an issue for dynamic module replacement systems whose goal is to replace program components without stopping execution of a program. In this case there is existing data that may need to be transformed even though it is not necessarily persistent data. Existing systems (such as <ref> [Fab76, FS91] </ref>) recognize the need for such transformation functions, but leave the development of those functions to the maintainer. Tess's comparison algorithms could be used to generate these transformation functions. Another situation in which type comparison may be applicable is schema integration.
Reference: [GKL94] <author> David Garlan, Charles W. Krueger, and Barbara Staudt Lerner. TransformGen: </author> <title> Automating the maintenance of structure-oriented environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3):727774, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: It aggravates the evolution problem, however, because every type potentially has persistent data associated with it. Modifying any type definition can make some persistent data inaccessible. Unfortunately, there is little published data <ref> [GKL94, Sj93] </ref> about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a]. <p> Odberg [Odb94] extends the versioning approach to the entire schema, which is versioned when a type is modified. This allows the description of changes that simultaneously affect multiple types, but still requires the maintainer to define the translation routines between versions. TransformGen <ref> [GKL94] </ref> is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments [HN86, HGN91].
Reference: [HGN91] <author> Nico Habermann, David Garlan, and David Notkin. </author> <title> Generation of integrated task-specific software environments. </title> <editor> In Richard F. Rashid, editor, </editor> <booktitle> CMU Computer Science: A 25th Anniversary Commemorative, Anthology Series, chapter 4, </booktitle> <pages> pages 6997. </pages> <publisher> ACM Press, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: This allows the description of changes that simultaneously affect multiple types, but still requires the maintainer to define the translation routines between versions. TransformGen [GKL94] is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments <ref> [HN86, HGN91] </ref>.
Reference: [HN86] <author> A. Nico Habermann and David Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):11171127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: This allows the description of changes that simultaneously affect multiple types, but still requires the maintainer to define the translation routines between versions. TransformGen [GKL94] is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments <ref> [HN86, HGN91] </ref>.
Reference: [JO93] <author> Ralph E. Johnson and William F. Opdyke. </author> <title> Refactoring and aggregation. </title> <booktitle> In Proceedings of ISO-TAS '93: International Symposium on Object TEchnologies for Advanced Software, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [KK88] <author> Hyoung-Joo Kim and Henry F. Korth. </author> <title> Schema versions and DAG rearrangement views in object-oriented databases. </title> <type> Technical Report TR-88-05, </type> <institution> University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion <ref> [BKKK87, KK88] </ref> and GemStone [PS87] are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive operations that change individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables. <p> Our derivation rules can be used with his algorithms. 9.5.2 Screening With screening, information is never deleted from objects. Instead the accessing functions hide the appropriate information based upon the version of the code that is accessing the object. Orion <ref> [BKKK87, KK88] </ref> uses screening to evolve its objects. To do so, it uses a clever object representation that allows fast access to objects even after the object's type has been changed. It also restricts the kinds of changes to a subset of our local change model.
Reference: [LBSL91] <author> Karl J. Lieberherr, Paul Bergstein, and Ignacio Silva-Lepe. </author> <title> Abstraction of object-oriented data models. </title> <editor> In H. Kangassalo, editor, </editor> <booktitle> Entity-Relationship Approach: The Core of Conceptual Modelling, </booktitle> <pages> pages 89102. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1991. </year> <title> Similar to Johnson and Opdyke work on refactoring. </title>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [LH90] <author> Barbara Staudt Lerner and A. Nico Habermann. </author> <title> Beyond schema evolution to database reorganization. </title> <booktitle> In Proceedings of the Joint ACM OOPSLA/ECOOP '90 Conference on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 6776, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: While the maintainer can extend the transformer, there is little guidance in identifying the limits of the generation process and the situations that require extension. OTGen <ref> [LH90] </ref> is a system designed using the concepts developed in TransformGen to support flexible transformation of object-oriented databases.
Reference: [MS92a] <author> S. Mellor and S. Shlaer. </author> <title> Object Lifecycles: Modeling the World in States. </title> <publisher> Yourdon Press Computing Series. PTR Prentice-Hall, </publisher> <year> 1992. </year> <month> 31 </month>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [MS92b] <author> S. Monk and I. Sommerville. </author> <title> A model for versioning classes in object-oriented databases. </title> <booktitle> In Proceedings of the Tenth British National Conference on Databases, </booktitle> <address> Aberdeen, Scotland, </address> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the simultaneous maintenance of multiple versions of types and data <ref> [SZ86, Cla94, Bra92, MS92b, TS92] </ref>. With these approaches, multiple versions of the same type exist within a single database. The advantage is that old and new code can operate on old and new data without requiring either to be changed.
Reference: [Nav80] <author> Shamkant B. Navathe. </author> <title> Schema analysis for database restructuring. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2):157184, </volume> <month> June </month> <year> 1980. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, 4 only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the main-tainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [Odb94] <author> Erik Odberg. MultiPerspectives: </author> <title> The classification dimension of schema modification management for object-oriented databases. </title> <booktitle> In Proceedings of TOOLS-USA '94, </booktitle> <address> Santa Barbara, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This approach admits more general changes, but it still limits changes to be isolated to individual types. It also results in significant overhead (in both space and time) for maintaining and accessing multiple type and data versions. Odberg <ref> [Odb94] </ref> extends the versioning approach to the entire schema, which is versioned when a type is modified. This allows the description of changes that simultaneously affect multiple types, but still requires the maintainer to define the translation routines between versions.
Reference: [OJ90] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Refactoring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> In Proceedings of 1990 Symposium of Object-Oriented Programming Emphasizing Practical Applications, </booktitle> <year> 1990. </year>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [OJ93] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Creating abstract superclasses by refactoring. </title> <booktitle> In Proceedings of CSC '93: The ACM 1993 Computer Science Conference, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: Unfortunately, there is little published data [GKL94, Sj93] about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities <ref> [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a] </ref>. One can expect, however, that maintainers are reluctant to make radical changes to an object-oriented hierarchy or any other persistent type or schema definitions if those changes make it difficult or impossible to access existing data.
Reference: [PS87] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented DBMS. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 111117, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion [BKKK87, KK88] and GemStone <ref> [PS87] </ref> are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive operations that change individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables.
Reference: [Ric93] <author> Debra J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis (ISSTA) '94. </booktitle> <publisher> ACM Press, </publisher> <month> June 28-30 </month> <year> 1993. </year>
Reference-contexts: In this section, we provide an example of a real schema evolution and describe how it fits into the compound type change model. testing tool <ref> [Ric93] </ref>. In this example, we see three modified types and four new types.
Reference: [SHL75] <author> Nan C. Shu, Barron C. Housel, and Vincent Y. Lum. </author> <title> CONVERT: A high level translation definition language for data conversion. </title> <journal> Communications of the ACM, </journal> <volume> 18(10):557567, </volume> <month> October </month> <year> 1975. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, 4 only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the main-tainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [Sj93] <author> D. I. K. Sjberg. </author> <title> Thesaurus-Based Methodologies and Tools for Maintaining Persistent Application Systems. </title> <type> PhD thesis, </type> <institution> University of Glasgow, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: It aggravates the evolution problem, however, because every type potentially has persistent data associated with it. Modifying any type definition can make some persistent data inaccessible. Unfortunately, there is little published data <ref> [GKL94, Sj93] </ref> about how persistent or transient types change during maintenance. Researchers studying maintenance of object-oriented hierarchies, which are not necessarily persistent, cite modifying types in the hierarchy and reorganizing the hierarchy as frequently desirable activities [JO93, OJ93, LBSL91, OJ90, Cas90, MS92a].
Reference: [ST82] <author> Ben Shneiderman and Glenn Thomas. </author> <title> An architecture for automatic relational database system conversion. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2):235257, </volume> <month> June </month> <year> 1982. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, 4 only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the main-tainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [SZ86] <author> Andrea H. Skarra and Stanley B. Zdonik. </author> <title> The management of changing types in an object-oriented database. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 483495, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Another approach to schema evolution relies on the simultaneous maintenance of multiple versions of types and data <ref> [SZ86, Cla94, Bra92, MS92b, TS92] </ref>. With these approaches, multiple versions of the same type exist within a single database. The advantage is that old and new code can operate on old and new data without requiring either to be changed. <p> Additionally, we must be careful to not delete objects that contain data that serves as the source of a data movement operation. 9.5.3 Versioning In a versioning backend, such as Encore <ref> [SZ86] </ref> provides, multiple versions of an object may exist at one time. The runtime system compares the version of code accessing an object with the versions available so that the correct version can be returned.
Reference: [TC93] <author> Peri Tarr and Lori A. Clarke. Pleiades: </author> <title> An object management system for software engineering environments. </title> <booktitle> In Proceedings of ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The transient types can be changed without impacting the persistent data. With persistent programming languages, there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [TS92] <author> Markus Tresch and Marc H. Scholl. </author> <title> Meta object management and its application to database evolution. </title> <booktitle> In Proceedings of the 11th International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 299321, </pages> <address> Karlsruhe, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the simultaneous maintenance of multiple versions of types and data <ref> [SZ86, Cla94, Bra92, MS92b, TS92] </ref>. With these approaches, multiple versions of the same type exist within a single database. The advantage is that old and new code can operate on old and new data without requiring either to be changed.
Reference: [WWFT88] <author> Jack C. Wileden, Alexander L. Wolf, Charles D. Fisher, and Peri L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent typed object management. </title> <booktitle> In Proceedings 3rd Software Development Environments Conference, </booktitle> <pages> pages 130142, </pages> <month> December </month> <year> 1988. </year> <month> 32 </month>
Reference-contexts: The transient types can be changed without impacting the persistent data. With persistent programming languages, there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [ZW95a] <author> Amy Moorman Zaremski and Jeannette M. Wing. </author> <title> Signature matching: A tool for using soft-ware libraries. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(2):146170, </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Zaremski and Wing have demonstrated the use of type comparison to locate components in a library for reuse <ref> [ZW95a, ZW95b] </ref>. The type comparison algorithms that they use rely on type signatures and formal specifications. Since signatures and formal specifications generally change less frequently than representations, incorporating these algorithms into Tess may improve Tess's ability to find matching types in old and new versions of a system.
Reference: [ZW95b] <author> Amy Moorman Zaremski and Jeannette M. Wing. </author> <title> Specification matching of software compo. </title> <booktitle> In Proceedings of SIGSOFT '95: 3rd ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1995. </year> <month> 33 </month>
Reference-contexts: Zaremski and Wing have demonstrated the use of type comparison to locate components in a library for reuse <ref> [ZW95a, ZW95b] </ref>. The type comparison algorithms that they use rely on type signatures and formal specifications. Since signatures and formal specifications generally change less frequently than representations, incorporating these algorithms into Tess may improve Tess's ability to find matching types in old and new versions of a system.
References-found: 35

