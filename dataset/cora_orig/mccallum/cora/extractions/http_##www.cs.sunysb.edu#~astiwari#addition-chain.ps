URL: http://www.cs.sunysb.edu/~astiwari/addition-chain.ps
Refering-URL: http://www.cs.sunysb.edu/~astiwari/
Root-URL: http://www.cs.sunysb.edu
Title: RSA Public Key Cryptosystem  
Author: Zhong Li Ashish Tiwari 
Date: December 2, 1998  
Abstract: This report describes briefly the current research in both hardware and software for fast evaluation of RSA, which consists of computing powers modulo a large number n. The two aspects namely trying to increase the speed of multiplications and reducing the number of multiplications are considered. We discuss heuristics in literature to reduce the number of multiplications for the computation of a given power and then present a heuristic that most of the times performs better than the best known so far. The second part is a survey on hardware implementations to make multiplications faster. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Bos and M.Coster, </author> <title> Addition Chain Heuristics, </title> <booktitle> Advances in Cryptology Proceedings of Crypto '89 (G. </booktitle> <editor> Brassard. ed.), LNCS, </editor> <volume> vol 435, </volume> <pages> pp 400-407. </pages>
Reference-contexts: Naturally we are interested in addition chains with as small a length as possible. Our proposed method produces addition chains with lengths as good as the best known heuristics, and at times it does better. 2 3 Related Work Computing the shortest addition chain is an NP-complete problem [9]. <ref> [1] </ref> was the first attempt to give a heuristic for addition chains. In [1], the author has given a strong heuristic, that still remains the best possible to date, for finding the smallest addition chain for a given number n. <p> Our proposed method produces addition chains with lengths as good as the best known heuristics, and at times it does better. 2 3 Related Work Computing the shortest addition chain is an NP-complete problem [9]. <ref> [1] </ref> was the first attempt to give a heuristic for addition chains. In [1], the author has given a strong heuristic, that still remains the best possible to date, for finding the smallest addition chain for a given number n. The heuristic achieves results quite close to the lower bound (Details excluded).
Reference: [2] <author> Peter de Rooij, </author> <title> Efficient Exponentiation using Precomputation and Vector Chain Additions, </title> <booktitle> Advances in Cryptology - Eurocrypt '94, </booktitle> <publisher> LNCS. </publisher>
Reference: [3] <editor> E.F. Brickell, D.M. Gordon, </editor> <title> K.S. McCurley, D.B. Wilson, Fast Exponentiation with Precomputation, </title> <booktitle> Advances in Cryptology Proceedings of Eurocrypt '92, LNCS, </booktitle> <volume> vol 658, </volume> <year> 1993, </year> <pages> pp 200-207. </pages>
Reference: [4] <author> Hikaru Morita, </author> <title> A Fast Modular-multiplication Algorithm based on a Higher Radix, </title> <booktitle> Advances in Cryptology Proceedings of Crypto '89 (G. </booktitle> <editor> Brassard. ed.), LNCS, </editor> <volume> vol 435, </volume> <pages> pp 387-399. </pages>
Reference-contexts: Overlapping the multiplication and the modular reduction opera tion. * Multiplication is implemented as a series of addition. In the recent years the focus has been on making modular multiplication faster rather than reducing the number of multiplications itself <ref> [4] </ref>. There is a lot of work going on in this area. For a survey, see [7]. The essential idea to note is that the operations in the RSA encryption and decryption algorithm 5 can be very deeply pipelined. <p> For more details, see <ref> [4] </ref>. 7 Summary We have presented an heuristic algorithm for solving the addition chain problem that does as well as the best ones available in the literature. In the second part, there is a survey on developing specialized hardware for making modular multiplication faster.
Reference: [5] <author> P.A.Findlay and B.A.Johnson, </author> <title> Modular Exponentiation Using Recursive Sums of Residues, </title> <booktitle> Advances in Cryptology Proceedings of Crypto '89 (G. </booktitle> <editor> Brassard. ed.), LNCS, </editor> <volume> vol 435, </volume> <pages> pp 371-386. </pages>
Reference-contexts: Now, the special property that is exploited is that in RSA, the N does not change. In <ref> [5] </ref>, the authors describe an approach to do modular multiplication in which the multiplication and reduction are separate tasks, the output of first feeding into the input of second. <p> One simple idea that comes to mind is that of storing the moduli of all powers of 2 (modulo N ). But the data paths for the lookup table would be very wide. So, in <ref> [5] </ref> the authors give a way to calculate these values while doing the other addition operations, using the following formula, r i = 2r i1 iff (2r i1 N ) &lt; 0 By storing the result of the comparison, the r i can be calculated while performing other operations. <p> The different pipelined units work on different bits in any one clock cycle. For details, see <ref> [5] </ref>. Since we can get rid of all bit testing and conditional branches, the algorithm runs extremely efficiently on highly pipelined processors, or RISC machines, since no instruction queue flushing would be required. The authors expect an improvement of approximately 50%. The work in [5] is the subject of a patent <p> For details, see <ref> [5] </ref>. Since we can get rid of all bit testing and conditional branches, the algorithm runs extremely efficiently on highly pipelined processors, or RISC machines, since no instruction queue flushing would be required. The authors expect an improvement of approximately 50%. The work in [5] is the subject of a patent application. The other prevalent approach to perform fast modular multiplication is based on combining multiplication and residue calculation.
Reference: [6] <author> Y. Yacobi, </author> <title> Exponentiating Faster With Addition Chains, </title> <booktitle> Advances in Cryptology Proceedings of Eurocrypt '90 (I.B. </booktitle> <editor> Damgard ed.), LNCS, </editor> <volume> vol 473, </volume> <pages> pp 222-229. 7 </pages>
Reference-contexts: If each window is taken to be of size 1, we get the naive BSM (Binary Square and Multiply) algorithm. Therefore, for 711 we need 5 + 7 = 12 multiplications. In 1990, Yacobi <ref> [6] </ref> used ideas from data-compression to form appropriate windows. In particular he used the Lempel-Ziv algorithm starting from the least significant bit. For the same example as above, he would get 4 windows, which are 1, 011, 11 and 1 (left to right). <p> In the following results, the column marked "SUF" contains the results for the first algorithm and the one marked "OSUF" has results for the second optimized version of the first algorithm. 4 5 Results The algorithm in <ref> [6] </ref> was implemented. Along with it we also implemented the naive BSM method and two very simple heuristics. All of these algorithms were run on 10 random 512-bit numbers. The results are shown below.
Reference: [7] <editor> Ernest F. Brickell, </editor> <title> A Survey of Hardware Implemetations of RSA, </title> <booktitle> Ad--vances in Cryptology Proceedings of Crypto '89 (G. </booktitle> <editor> Brassard. ed.), LNCS, </editor> <volume> vol 435, </volume> <pages> pp 368-370. </pages>
Reference-contexts: In the recent years the focus has been on making modular multiplication faster rather than reducing the number of multiplications itself [4]. There is a lot of work going on in this area. For a survey, see <ref> [7] </ref>. The essential idea to note is that the operations in the RSA encryption and decryption algorithm 5 can be very deeply pipelined. Different papers try to achieve the same goal of building a good pipelined architecture in different ways.
Reference: [8] <author> Knuth, D.E., </author> <booktitle> The art of computer programming, </booktitle> <volume> Vol. 2, </volume> <booktitle> Seminumerical algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> (1969), </year> [[. <pages> 398-419. </pages>
Reference-contexts: We view such a sequence as a series of exponents used to do an exponentiation. The length of an addition chain or sequence is the number of elements in the chain, apart from the initial one. For example, the standard (binary) addition chain <ref> [8] </ref> for the number 15 has length 6: 1; 2; 3; 6; 7; 14; 15 There is, however, a chain of length 5 that produces 15: 1; 2; 3; 6; 12; 15 This means that one can compute x 15 from x in 5 multiplications.
Reference: [9] <author> Downey P., Leony B. and Sethi R, </author> <title> Computing sequences with addition chains, </title> <journal> Siam Journal of Computing 3 (1981), </journal> <pages> 638-696. </pages>
Reference-contexts: Naturally we are interested in addition chains with as small a length as possible. Our proposed method produces addition chains with lengths as good as the best known heuristics, and at times it does better. 2 3 Related Work Computing the shortest addition chain is an NP-complete problem <ref> [9] </ref>. [1] was the first attempt to give a heuristic for addition chains. In [1], the author has given a strong heuristic, that still remains the best possible to date, for finding the smallest addition chain for a given number n.
References-found: 9

