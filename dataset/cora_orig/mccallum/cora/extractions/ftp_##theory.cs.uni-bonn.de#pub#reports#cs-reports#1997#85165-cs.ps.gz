URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1997/85165-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1997-en.html
Root-URL: http://cs.uni-bonn.de
Email: email: carsten@cs.uni-bonn.de  email: wirtgen@cs.uni-bonn.de  
Title: Once again: Finding simple cycles in graphs  
Author: Carsten Dorgerloh Jurgen Wirtgen 
Address: Bonn, Romerstr. 164, D-53117 Bonn, Germany,  Bonn, Romerstr. 164, D-53117 Bonn, Germany,  
Affiliation: Institut fur Informatik V, Universitat  -Institut fur Informatik V, Universitat  
Date: January 21, 1997  
Abstract: We present a randomized algorithm that computes a simple cycle of length k in general graphs, where k is a fixed integer, in O(maxfm; n log ng) expected time. This algorithm can be deran-domized with only a small loss in efficiency, yielding a deterministic algorithm for this task which runs in O(maxfm log n; n log ng) worst-case time. We show that the randomized algorithm may be parallelized. These algorithms improve upon previous results of many authors. Furthermore, we answer the question of [AYZ 94], whether deciding if a given graph contains a triangle is as difficult as boolean multiplication of two n by n matrices, in the negative. 
Abstract-found: 1
Intro-found: 1
Reference: [AYZ 94] <author> Alon, N., Yuster, R., Zwick, U., </author> <title> Finding and counting given length cyles, </title> <booktitle> Proc. 2 nd European Symposium on Algorithms (1994), </booktitle> <pages> pp. 354-364. </pages>
Reference-contexts: a graph G on n vertices, a simple cycle of length k in G, if one exists, may be computed in O (log n) expected time by a randomized EREW-PRAM using O (n + m) processors. 5 Open problems As mentioned before, we answer by our results the question of <ref> [AYZ 94] </ref>, whether solving the decision Problem "Does a given graph contain a triangle?" is as difficult as boolean multiplication of two n by n matrices, in the negative in the sense that this decision Problem may be solved substantially faster than the matrix multiplication by the currently best known algorithm
Reference: [AYZ 95] <author> Alon, N., Yuster, R., Zwick, U., Color-coding, </author> <booktitle> Proc. 42 nd Journal of the ACM (1995), </booktitle> <pages> pp. 844-856. </pages>
Reference-contexts: The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96]. Alon, Yuster and Zwick <ref> [AYZ 95] </ref> presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication. Our algorithms for that problem, while using ideas from [AYZ 95], takes advantage of techniques <p> Alon, Yuster and Zwick <ref> [AYZ 95] </ref> presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication. Our algorithms for that problem, while using ideas from [AYZ 95], takes advantage of techniques from [GK 87]. To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently <p> Our algorithms for that problem, while using ideas from <ref> [AYZ 95] </ref>, takes advantage of techniques from [GK 87]. To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently in parallel (see also [KR 97]). <p> We improve an O (nm) worst-case time bound of [Mo 85] (in many cases), and upon the results of <ref> [AYZ 95] </ref>. Furthermore, our results generalizes a result of [DW 96]. We achieve a randomized algorithm which runs in O (maxfm; n log ng) expected time and a deterministic algorithm which runs in O (maxfm log n; n log ng) worst-case time. <p> Hence lines (21)-(35) take O (m) time. The algorithm finds C with a probabil-ity of at least 2=k k1 . By rerunning the algorithm, in case of failure, we obtain an O (maxfk k1 m; n log ng) expected time algorithm. The following lemma is implicitly in <ref> [AYZ 95] </ref>. Using this lemma, the above algorithm can be derandomized with only a small loss of efficiency.
Reference: [CW 87] <author> Coppersmith, D., Winograd, S., </author> <title> Matrix multiplication via arithmetic progressions, </title> <booktitle> Proc. 19 th ACM STOC (1987), </booktitle> <pages> pp. 1-6. </pages>
Reference-contexts: a given graph contain a triangle?" is as difficult as boolean multiplication of two n by n matrices, in the negative in the sense that this decision Problem may be solved substantially faster than the matrix multiplication by the currently best known algorithm with a running time of n 2:376 <ref> [CW 87] </ref>. While answering this question, several other problems remain open.
Reference: [Do 96] <author> Dorgerloh, C. F., </author> <title> A Fast Randomized Parallel Algorithm for Finding Simple Cycles in Planar Graphs, </title> <institution> Research Report 85150-CS, Institut fur Informatik der Universitat Bonn, </institution> <year> 1996. </year>
Reference-contexts: The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], [RL 85], [Ri 86], [YZ 94], <ref> [Do 96] </ref>, [DW 96]. Alon, Yuster and Zwick [AYZ 95] presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication. <p> This generalizes a previous result for planar graphs of [DW 96]. Some techniques which are useful to to obtain this result can be found in <ref> [Do 96] </ref>. Theorem 4 Let k 3 be a fixed integer.
Reference: [DW 96] <author> Dorgerloh, C., Wirtgen, J., </author> <title> A note on improving the running time of a class of parallel algorithms using randomization, </title> <institution> Research Report 85159-CS, Institut fur Informatik der Universitat Bonn, </institution> <year> 1996. </year>
Reference-contexts: The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], <ref> [DW 96] </ref>. Alon, Yuster and Zwick [AYZ 95] presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication. <p> We improve an O (nm) worst-case time bound of [Mo 85] (in many cases), and upon the results of [AYZ 95]. Furthermore, our results generalizes a result of <ref> [DW 96] </ref>. We achieve a randomized algorithm which runs in O (maxfm; n log ng) expected time and a deterministic algorithm which runs in O (maxfm log n; n log ng) worst-case time. We show that our randomized method can be parallelized, yielding an efficient EREW-PRAM algorithm. <p> This generalizes a previous result for planar graphs of <ref> [DW 96] </ref>. Some techniques which are useful to to obtain this result can be found in [Do 96]. Theorem 4 Let k 3 be a fixed integer.
Reference: [Ev 79] <author> Even, S., </author> <title> Graph Algorithms, </title> <publisher> Computer Science Press, </publisher> <year> 1979. </year>
Reference-contexts: In section 3 we present the sequential algorithms for finding simple cycles in graphs and in section 4 we show that there exists an efficient parallel algorithm for this problem. 2 Notations and definitions The terminology used in this paper follows that of Even <ref> [Ev 79] </ref>. Let G = (V; E) be a graph. For each vertex v, N (v) denotes the set of neighbours of v.
Reference: [GJ 79] <author> Garey, M. R., Johnson, D. S., Computers and Intractability, W. H. Freeman and Company, </author> <year> 1979. </year>
Reference-contexts: 1 Introduction It is well known that finding the longest cycle in a graph is a hard problem, since finding a hamiltonian cycle is N P -complete <ref> [GJ 79] </ref>. Hence finding a simple cycle of lenght k, for an arbitrary k, is N P -complete. This remains true if G is planar and under other restrictions. However, we are concerned only with the problem of finding simple cycles of a given length.
Reference: [GK 87] <author> Grigoriev, D. Y., Karpinski, M., </author> <title> The Matching Problem for Bipartite Graphs with Polynomially Bounded Permanents is in NC, </title> <booktitle> Proc. 28 th IEEE FOCS (1987), </booktitle> <pages> pp. 166-172. </pages>
Reference-contexts: Our algorithms for that problem, while using ideas from [AYZ 95], takes advantage of techniques from <ref> [GK 87] </ref>. To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently in parallel (see also [KR 97]). <p> Our algorithms for that problem, while using ideas from [AYZ 95], takes advantage of techniques from <ref> [GK 87] </ref>. To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently in parallel (see also [KR 97]). We improve an O (nm) worst-case time bound of [Mo 85] (in many cases), and upon the results of [AYZ 95]. <p> Our algorithms for that problem, while using ideas from [AYZ 95], takes advantage of techniques from <ref> [GK 87] </ref>. To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently in parallel (see also [KR 97]). We improve an O (nm) worst-case time bound of [Mo 85] (in many cases), and upon the results of [AYZ 95]. Furthermore, our results generalizes a result of [DW 96].
Reference: [KR 88] <author> Karp, R. M., Ramachandran, V., </author> <title> A Survey of Parallel Algorithms for Shared-Memory Machines, </title> <note> Research Report UCB/CSD 88/408, </note> <institution> University of Califor-nia, Berkeley, </institution> <year> 1988. </year>
Reference-contexts: Furthermore, each processor has access to a random number generator which returns random numbers of log n bits in constant time. More details of the PRAM models can be found in the survey by Karp and Ramachandran <ref> [KR 88] </ref>. 3 The Algorithm Before we explain the technical details of the algorithm, we give our special view on the data structures which allows us to implement the algorithms efficiently.
Reference: [KR 97] <author> Karpinski, M., Rytter, W., </author> <title> Fast Parallel Algorithms for Graph Matching Problems, </title> <publisher> Oxford University Press, </publisher> <year> 1997. </year>
Reference-contexts: To be more precise, we combine the color-coding method of [AYZ 95] with the idea of Grigoriev and Karpinski [GK 87] to utilize the nice properties of prime numbers. [GK 87] make use of this properties to solve some matching problems efficiently in parallel (see also <ref> [KR 97] </ref>). We improve an O (nm) worst-case time bound of [Mo 85] (in many cases), and upon the results of [AYZ 95]. Furthermore, our results generalizes a result of [DW 96].
Reference: [Le 90] <author> Leeuwen, J. v., </author> <title> Graph Algorithms. </title> <booktitle> Handbook of Theoretical Computer Science, Volume A, Algorithms and Comlexity, chapter 10, </booktitle> <pages> pp. 525-631, </pages> <publisher> Elsevier and The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This remains true if G is planar and under other restrictions. However, we are concerned only with the problem of finding simple cycles of a given length. The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems <ref> [Le 90] </ref> and was considered by many researchers, e.g. by [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96].
Reference: [Mo 85] <author> Monien, B., </author> <title> How to find long paths efficiently, </title> <booktitle> Annals of Discrete Mathematics 25 (1985), </booktitle> <pages> pp. 239-254. </pages>
Reference-contexts: However, we are concerned only with the problem of finding simple cycles of a given length. The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by <ref> [Mo 85] </ref>, [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96]. <p> We improve an O (nm) worst-case time bound of <ref> [Mo 85] </ref> (in many cases), and upon the results of [AYZ 95]. Furthermore, our results generalizes a result of [DW 96].
Reference: [Pr 87] <author> Pritchard, P., </author> <title> Linear prime-number sieves: A familiy tree, </title> <booktitle> Science of Computer Programming 9 (1987), </booktitle> <pages> pp. 17-35. </pages>
Reference-contexts: Thus we add x to C and delete all other vertices with color k together with all incident edges. The correctness of the other phases follows by induction. The first n prime numbers may be computed by the sieve of Pritchard <ref> [Pr 87] </ref> in O (n log n) time. It is easy to see that lines (02)-(20) take O (m) time. By taking care in the implementation of the for-loop in lines (26)-(33) each edge (u; w) is processed at most 4 once. Hence lines (21)-(35) take O (m) time.
Reference: [Ri 86] <author> Richards, D., </author> <title> Finding short cycles in a planar graph using seperators, </title> <booktitle> Journal of Algorithms 7 (1986), </booktitle> <pages> pp. 382-394. </pages>
Reference-contexts: However, we are concerned only with the problem of finding simple cycles of a given length. The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], [RL 85], <ref> [Ri 86] </ref>, [YZ 94], [Do 96], [DW 96]. Alon, Yuster and Zwick [AYZ 95] presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication.
Reference: [RL 85] <author> Richards, D., Liestman, A. L., </author> <title> Finding cycles of a given length, </title> <booktitle> Annals of Discrete Mathematics 27 (1985), </booktitle> <pages> pp. 249-256. </pages>
Reference-contexts: However, we are concerned only with the problem of finding simple cycles of a given length. The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], <ref> [RL 85] </ref>, [Ri 86], [YZ 94], [Do 96], [DW 96]. Alon, Yuster and Zwick [AYZ 95] presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication.
Reference: [YZ 94] <author> Yuster, R., Zwick, U., </author> <title> Finding even cycles even faster, </title> <booktitle> Proc. 21 st International Colloquium on Automata, Languages and Programming (1994), </booktitle> <pages> pp. 532-543. 6 </pages>
Reference-contexts: The problem of finding given length simple cycles is one of the basic and natural algorithmic graph problems [Le 90] and was considered by many researchers, e.g. by [Mo 85], [RL 85], [Ri 86], <ref> [YZ 94] </ref>, [Do 96], [DW 96]. Alon, Yuster and Zwick [AYZ 95] presented algorithms for this task which runs either in O (M (n)) expected time or O (M (n) log n) worst-case time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication.
References-found: 16

