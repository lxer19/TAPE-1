URL: ftp://ftp.csd.uu.se/pub/papers/reports/0087.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Simple and Efficient Copying Garbage Collector for Prolog  
Author: Johan Bevemyr Thomas Lindgren 
Address: 311, S-751 05 Uppsala, Sweden  
Affiliation: Box  
Note: A  
Abstract: UPMAIL Technical Report No. 87 August 1994 ISSN 1100-0686 Abstract We show how to implement efficient copying garbage collection for Prolog. We measure the efficiency of the collector compared to a standard mark-sweep algorithm on several programs. We then show how to acco-modate generational garbage collection and Prolog primitives that make the implementation more difficult. The resulting algorithms are simpler and more efficient than the standard mark-sweep method on a range of benchmarks. The total execution times of the benchmark programs are reduced by 4 to 11 percent. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. Appleby, M. Carlsson, S. Haridi, and D. Sahlin, </author> <title> Garbage Collection for Prolog Based on WAM, </title> <journal> Communications of the ACM, </journal> <volume> 31(6) </volume> <pages> 719-741, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Memory allocation can then be resumed. RELATED WORK Prolog implementations such as SICStus Prolog use a mark-sweep algorithm that first marks the live data, then compacts the heap. We take the implementation of Appleby et al. <ref> [1] </ref> as typical. This algorithm works in four steps and is based on the Deutsch-Schorr-Waite [12, 7] algorithm for marking and on Morris' algorithm [9, 7] for compacting. 1. <p> However, his collector relies on assignments being infrequent. In Prolog, variable binding is assignment in this sense. Our algorithm handles frequent assignments efficiently. Sahlin [11] has developed a method that makes the execution time of the Ap-pleby et al. <ref> [1] </ref> algorithm proportional to the size of the live data. The main drawback of Sahlin's algorithm is that implementing the mark-sweep algorithm becomes more difficult, not to mention guaranteeing that there are no programming errors in its implementation. To our knowledge it has never been implemented. <p> This result in a runtime cost for using generational garbage collection. In Prolog this overhead is already present in the form of trail tests and there is no extra runtime penalty for using generational collection. EVALUATION We have implemented a standard mark-sweep algorithm <ref> [1] </ref> and compared it to our copying algorithms. All garbage collection algorithms have been implemented in the same system, a sequential version of Reform Prolog. All algorithms implement early reset. The TSP program implements an approximation algorithm for the Travel references are recorded on the trail.
Reference: 2. <author> A.W. Appel, </author> <title> A runtime system, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(4), </volume> <year> 1990. </year>
Reference-contexts: In contrast, our algorithm only supports partial reclamation of memory by backtracking. Our measurements indicate that this is sufficient: the copying algorithms we describe do not reclaim appreciably less memory on backtracking than the standard mark-sweep algorithm on the measured benchmarks. Appel <ref> [2, 3] </ref> describes a simple generational garbage collector for Standard ML. The collector uses Cheney's garbage collection algorithm, which is the basis of our algorithm as well. However, his collector relies on assignments being infrequent. In Prolog, variable binding is assignment in this sense. Our algorithm handles frequent assignments efficiently.
Reference: 3. <author> A.W. Appel, </author> <title> Simple generational garbage collection and fast allocation, </title> <editor> Software|Practice and Experience,19(2):171-183, </editor> <year> 1989. </year>
Reference-contexts: In contrast, our algorithm only supports partial reclamation of memory by backtracking. Our measurements indicate that this is sufficient: the copying algorithms we describe do not reclaim appreciably less memory on backtracking than the standard mark-sweep algorithm on the measured benchmarks. Appel <ref> [2, 3] </ref> describes a simple generational garbage collector for Standard ML. The collector uses Cheney's garbage collection algorithm, which is the basis of our algorithm as well. However, his collector relies on assignments being infrequent. In Prolog, variable binding is assignment in this sense. Our algorithm handles frequent assignments efficiently. <p> Naturally, if most of the live unbound variables have been compared in this way, the collector will have to spend more time in compacting the cv-stack. We believe this situation to be rare. INTRODUCING GENERATIONAL GARBAGE COLLECTION Generational garbage collection <ref> [8, 3] </ref> relies on the observation that newly created objects tend to be short-lived. Thus, garbage collection should concentrate on recently created data. The heap is split into two or more generations, and the most recent generation is collected most frequently.
Reference: 4. <author> J. Barklund, H. Millroth, </author> <title> Garbage cut for garbage collection of iterative Prolog programs, </title> <booktitle> 3rd Symposium on Logic Programming, </booktitle> <address> Salt Lake City, </address> <month> September </month> <year> 1986, </year> <note> IEEE. </note>
Reference-contexts: For the older generation they use a mark-sweep algorithm. The technique is similar to that described by Barklund and Millroth <ref> [4] </ref> and later by Older and Rummell [10]. We show how a simpler copying collector can be implemented, how the troublesome primitives can be accomodated better and how generational collection can be done in a simple and intuitive way. However, our view is also more radical than theirs.
Reference: 5. <author> Y. Bekkers, O. Ridoux and L. Ungaro, </author> <title> Dynamic Memory Management for Sequential Logic Programming Languages, </title> <booktitle> Proceedings of the International Workshop on Memory Management 92, </booktitle> <publisher> LNCS 637, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: We show below that memory recovery by backtracking is still possible, and that the new approach in practice recovers approximately as much garbage by backtracking as the conventional approach. Bekkers, Ridoux and Ungaro <ref> [5] </ref> describe an algorithm for copying garbage collector for Prolog. They observe that it is possible to reclaim garbage collected data on backtracking if copying starts at the oldest choice point (bottom-to-top).
Reference: 6. <author> C.J. </author> <title> Cheney, A nonrecursive list compacting algorithm, </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: Garbage collection is done by starting at a set of root pointers, such as registers and the local stack, and discovering what data are reachable from these pointers, or live. Memory is reclaimed by compacting the live data [9], copying them to a new area <ref> [6] </ref> or putting the dead data on a free list. Memory allocation can then be resumed. RELATED WORK Prolog implementations such as SICStus Prolog use a mark-sweep algorithm that first marks the live data, then compacts the heap. We take the implementation of Appleby et al. [1] as typical. <p> Bindings to the surviving variables from the topmost heap segment will be trailed unnecessarily (as compared to the compacting approach), but other bindings will not be affected. The unnecessary trail entries are deleted by the next collection. Mark-and-copy The copying collector is a straightforward adaption of Cheney's algorithm <ref> [6] </ref> and works in three phases. The algorithm allows the standard optimizations of early reset. The old data reside in fromspace and are evacuated into tospace. 1. Mark the live data. When a structure is encountered, mark the functor cell and all internal cells.
Reference: 7. <author> J. Cohen, </author> <title> Garbage Collection of Linked Data Structure, </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: RELATED WORK Prolog implementations such as SICStus Prolog use a mark-sweep algorithm that first marks the live data, then compacts the heap. We take the implementation of Appleby et al. [1] as typical. This algorithm works in four steps and is based on the Deutsch-Schorr-Waite <ref> [12, 7] </ref> algorithm for marking and on Morris' algorithm [9, 7] for compacting. 1. All live data are marked through roots found in registers, choice points, environments, and value trail entries (entries in the trail where the old value have been recorded, e.g., as a result of using setarg/3). <p> We take the implementation of Appleby et al. [1] as typical. This algorithm works in four steps and is based on the Deutsch-Schorr-Waite [12, 7] algorithm for marking and on Morris' algorithm <ref> [9, 7] </ref> for compacting. 1. All live data are marked through roots found in registers, choice points, environments, and value trail entries (entries in the trail where the old value have been recorded, e.g., as a result of using setarg/3).
Reference: 8. <author> H. Lieberman, C. Hewitt, </author> <title> A real-time garbage collector based on the life-times of objects, </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Naturally, if most of the live unbound variables have been compared in this way, the collector will have to spend more time in compacting the cv-stack. We believe this situation to be rare. INTRODUCING GENERATIONAL GARBAGE COLLECTION Generational garbage collection <ref> [8, 3] </ref> relies on the observation that newly created objects tend to be short-lived. Thus, garbage collection should concentrate on recently created data. The heap is split into two or more generations, and the most recent generation is collected most frequently.
Reference: 9. <author> F. Morris, </author> <title> A Time- and Space- Efficient Compaction Algorithm, </title> <journal> Communications of the ACM, </journal> <volume> 12(9) </volume> <pages> 662-665, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Garbage collection is done by starting at a set of root pointers, such as registers and the local stack, and discovering what data are reachable from these pointers, or live. Memory is reclaimed by compacting the live data <ref> [9] </ref>, copying them to a new area [6] or putting the dead data on a free list. Memory allocation can then be resumed. RELATED WORK Prolog implementations such as SICStus Prolog use a mark-sweep algorithm that first marks the live data, then compacts the heap. <p> We take the implementation of Appleby et al. [1] as typical. This algorithm works in four steps and is based on the Deutsch-Schorr-Waite [12, 7] algorithm for marking and on Morris' algorithm <ref> [9, 7] </ref> for compacting. 1. All live data are marked through roots found in registers, choice points, environments, and value trail entries (entries in the trail where the old value have been recorded, e.g., as a result of using setarg/3).
Reference: 10. <author> W.J. Older and J.A. Rummell, </author> <title> An Incremental Garbage Collector for WAM-Based Prolog, </title> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: For the older generation they use a mark-sweep algorithm. The technique is similar to that described by Barklund and Millroth [4] and later by Older and Rummell <ref> [10] </ref>. We show how a simpler copying collector can be implemented, how the troublesome primitives can be accomodated better and how generational collection can be done in a simple and intuitive way. However, our view is also more radical than theirs.
Reference: 11. <author> D. Sahlin, </author> <title> Making garbage collection independent of the amount of garbage, </title> <institution> Research Report R87008, Swedish Institute of Computer Science, </institution> <year> 1987. </year>
Reference-contexts: The collector uses Cheney's garbage collection algorithm, which is the basis of our algorithm as well. However, his collector relies on assignments being infrequent. In Prolog, variable binding is assignment in this sense. Our algorithm handles frequent assignments efficiently. Sahlin <ref> [11] </ref> has developed a method that makes the execution time of the Ap-pleby et al. [1] algorithm proportional to the size of the live data.
Reference: 12. <author> H. Schorr and W.M. Waite, </author> <title> An Efficient Machine-Independent Procedure for Garbage Collection in Various List Structures, </title> <journal> Communications of the ACM, </journal> <volume> 10(8) </volume> <pages> 501-506, </pages> <month> August </month> <year> 1967. </year>
Reference-contexts: RELATED WORK Prolog implementations such as SICStus Prolog use a mark-sweep algorithm that first marks the live data, then compacts the heap. We take the implementation of Appleby et al. [1] as typical. This algorithm works in four steps and is based on the Deutsch-Schorr-Waite <ref> [12, 7] </ref> algorithm for marking and on Morris' algorithm [9, 7] for compacting. 1. All live data are marked through roots found in registers, choice points, environments, and value trail entries (entries in the trail where the old value have been recorded, e.g., as a result of using setarg/3).
Reference: 13. <author> H. Touati, T. Hama, </author> <title> A light-weight prolog garbage collector, </title> <booktitle> Proceedings of the International Conference on Fifth Generation Computing Systems, </booktitle> <year> 1988. </year>
Reference-contexts: All references to a moved object are found through the reallocation chains and updated. All references downward are also put into reallocation chains so that they may be updated when the object further down the heap is moved. Touati and Hama <ref> [13] </ref> developed a generational copying garbage collector. The heap is split into an old and a new generation.
Reference: 14. <author> D.H.D. Warren, </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI International, Menlo Park, Calif., USA, </institution> <year> 1983. </year>
Reference-contexts: INTRODUCTION Automated storage reclamation for Prolog based on Warren's Abstract Machine (WAM) <ref> [14] </ref> has several difficulties. Let us consider the architecture of a typical WAM: most data are stored on a global stack (also called the heap), while choice points and environments are stored on a local stack (also referred to as the stack). <p> Since our algorithm is almost 70 % faster than the Appleby algorithm even when the heap is filled with live data, it is unlikely that Sahlin's algorithm will be more efficient than ours. ALGORITHM We assume the standard term representation of WAM <ref> [14] </ref>. Our algorithm requires the existence of two tag bits for each cell on the heap, reserved for the use of the garbage collector. These tag bits may either be stored in each cell or in some separate area.
References-found: 14

