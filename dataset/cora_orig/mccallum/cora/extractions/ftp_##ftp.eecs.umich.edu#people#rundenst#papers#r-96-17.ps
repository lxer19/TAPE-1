URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-96-17.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: fviviane,amyleeg@eecs.umich.edu rundenst@eecs.umich.edu  
Title: Sustaining Software Interoperability Via Shared, Evolving Object Repositories: System Optimization and Evaluation  
Author: Viviane M. Crestana, Amy J. Lee Elke A. Rundensteiner 
Note: While this work was done, the author was at the  
Address: 1301 Beal Avenue 100 Institute Road Ann Arbor, MI 48109-2122 Worcester, MA 01609  
Affiliation: Dept. of Elect. Eng. and Computer Science Computer Science Department University of Michigan Worcester Polytechnic Institute  University of Michigan.  
Abstract: Powerful interoperability-enabling solutions for software application integration must allow applications to evolve and data requirements to change, while minimizing such changes on other integrated applications. Thus, we have developed the transparent schema evolution (TSE) system that accomplishes evolution by generating a new object-oriented view schema to capture the changes desired by the user, while preserving existing view schemas for old applications. This generation of a potentially large number of schema versions over time results in an excessive build-up of classes and underlying object instances some of which may no longer be in use. The presence of no-longer-utilized view schemas will result in storage overhead costs and a degradation of system performance due to the update propagation of our materialized view foundation. In this paper, we address this problem using consistent schema removal techniques. Our solution is based on a formal model of capturing all dependencies between classes as logic clauses and of manipulating them to make decisions on class deletions and nondeletions while guaranteeing the consistency of the schema. Based on this formal model, we have developed and proven consistent a dependency graph (DG) representation and associated set of rules for DG generation, reduction, and transformation. The later has been successfully implemented in our TSE optimizer tool. To address the problem that view schema removal is sensitive to fl This work was supportedin part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program. We would also like to thank our industrial sponsors, in particular, AT&T, Illustra, IBM, and Intel. Viviane Crestana is also grateful for support for her graduate studies from the Conselho Nacional de Pesquisa CNPq and from IBM Toronto Lab, The Center for Advanced Studies. the order in which individual classes are processed, we present a cost model for evaluating alternative removal patterns on DG. We also report our preliminary experimental studies that validate our approach and demonstrate its impact on the performance of the TSE system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Report on the Object-Oriented Database Workshop: </editor> <title> Panel on Schema Evolution and Version Management. </title> <booktitle> In SIGMOD Records, </booktitle> <volume> Vol 18, No.3, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: In systems where the virtual classes are integrated in the global schema [2, 18, 20], code-reuse as well as sharing of data is assured. Our work addresses the removal of such integrated virtual classes. In systems using conventional version-ing rather than object-oriented view mechanisms <ref> [1] </ref>, schema removal is likely to be less of an issue. These versioning systems typically create complete copies of class versions without integrating them into one global schema; resulting in a duplication of methods and thus no true interdependencies such as we have in our case.
Reference: [2] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: This approach, while avoiding the integration, and therefore further removal consistency problems, has the serious drawback of 2 duplication of information. In systems where the virtual classes are integrated in the global schema <ref> [2, 18, 20] </ref>, code-reuse as well as sharing of data is assured. Our work addresses the removal of such integrated virtual classes. In systems using conventional version-ing rather than object-oriented view mechanisms [1], schema removal is likely to be less of an issue.
Reference: [3] <author> E. Bertino. </author> <title> Integration of heterogeneous data repositories by using object-oriented views. </title> <booktitle> International Workshop on Interoperability in Multidatabase Systems, </booktitle> <pages> pages 22-29, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Finally, we report our evaluation studies that validate our approach and demonstrate its impact on the performance of the TSE system. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature <ref> [3, 4] </ref>. However, none have considered the schema removal problem as characterized in this paper. Like other view systems presented in the literature [19], in the formal model of views described in [8], the virtual classes are not integrated in the global schema.
Reference: [4] <author> Svein Erik Bratsberg. </author> <title> Unified class evolution by object-oriented views. </title> <booktitle> In Proc. 12th Intl. Conf. on the Entity-Relationship Approach, </booktitle> <pages> pages 423-439, </pages> <year> 1992. </year>
Reference-contexts: Finally, we report our evaluation studies that validate our approach and demonstrate its impact on the performance of the TSE system. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature <ref> [3, 4] </ref>. However, none have considered the schema removal problem as characterized in this paper. Like other view systems presented in the literature [19], in the formal model of views described in [8], the virtual classes are not integrated in the global schema.
Reference: [5] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> SIGMOD, </booktitle> <year> 1993. </year>
Reference-contexts: Our test cases are built upon the small OO7 benchmark <ref> [5] </ref>, which we have extended with virtual classes as there is currently no available OO benchmarking testbed for object-oriented views [11]. As depicted in Figure 6 (a), the AtomicP art and Document classes from the OO7 benchmark contain 10,000 and 500 object instances, respectively.
Reference: [6] <author> V. Crestana and E. A. Rundensteiner. </author> <title> Consistent view removal in transparent schema evolution systems. </title> <type> Technical Report report in progress, </type> <institution> University of Michigan, </institution> <year> 1995. </year> <month> 13 </month>
Reference-contexts: The solution we propose is to delete the class C as long as there exists another class C' in GS that could become the source for VC to allow for transparent redefinition of VC. For this, we have de 4 veloped a theorem <ref> [6] </ref> about how and where to find alternative classes as potential new source classes for a given derived class whose original source class is being removed. If this redefinition of affected derived classes cannot be accomplished, then the delete operation must be rejected. <p> If this redefinition of affected derived classes cannot be accomplished, then the delete operation must be rejected. We explain the derived class redefinition process using the example in Figure 3 (a formal treatment can be found in <ref> [6] </ref>). <p> For this purpose, we have developed a formal model <ref> [6] </ref> based on Boolean logic, where each dependency is represented by a clause. Each clause consists of literals corresponding to characteristics of a class (for example, if the class can be deleted or not), and the conjunction and disjunction operators (^; _, respectively). <p> we do not describe the complete formal model due to space limitations (see <ref> [6] </ref>for more details). We have developed and implemented a hypergraph which graphically represents 5 this formal model, called the Dependency Graph (DG), that allows us to represent the dependencies between classes using different types of dependency edges [6]. 6.1 The Dependency Graph Model We approach the search order problem by first explicitly encoding all the information from type-effect and derivation-dependency constraints in a hypergraph called the dependency graph - DG. The DG is then analyzed to determine the best classes to delete. <p> There are seven different types of links, each one representing one type of dependency. Two of them relate to the derivation-dependency problem, and the other five relate to the type-effect problem <ref> [6] </ref>. 6.2 The DG Generation Rules We now describe which types of edges are constructed to capture the derivation-dependency constraints in DG. <p> equivalent to: (D 1 ) D 2 _ D 3 _ _ D n ) or equivalently (D 1 _ D 2 _ D 3 _ _ D n ) 6 Due to space constraints, we omit the DG de-pendencies for the type-effect problem, and instead refer the reader to <ref> [6] </ref>. 6.3 Preprocessing Phase: Reducing the Dependency Graph Once we have all the dependencies between classes in the schema encoded in DG, we need to determine a safe way to delete classes that do not violate the consistency of the schema, i.e., that don't violate any of the requirements represented in <p> Below we list a subset of the transformation rules for the links discussed in this paper while a complete set can be found elsewhere <ref> [6] </ref>. 1. <p> i . (P M jji is needed to calculate P I k and P D k for a derived class C k , assuming C i and C j are its source classes.) These parameters are assumed to be given for based classes and are computed for derived classes (see <ref> [6] </ref> for details). 11 8 Experimental Evaluation In this section, we discuss preliminary experimental results evaluating our TSE optimization tool. <p> Note in Figure 6 (b), AP Sel2 is redefined with the name AP Sel2fl when its original source class, AP Sel1, is removed from GS1. AtomicP art is its new source, as determined by our virtual class redefinition strategy <ref> [6] </ref>. Next, we remove DocSel, and again measure the run time for the same set of update operations for the resulting GS3 (Figure 6 (c)). GS1 GS2 GS3 Num of classes 6 5 4 Running time (msec) 22566.7 6799.5 6406.2 run times measured in milliseconds.
Reference: [7] <author> V. Crestana and E. A. Rundensteiner. </author> <title> Consis--tent view removal in transparent schema evolution systems. </title> <booktitle> Sixth Int. Workshop on Research Issues on Data Eng., Interop. of Nontraditional DBMSs, (RIDE'96, IEEE), </booktitle> <year> 1996. </year>
Reference-contexts: We have developed solutions for the potential schema consistency problems caused by removal of a single virtual class, and demonstrated view schema removal to be sensitive to the order in which classes are processed <ref> [7] </ref>. In this paper, we go beyond previous work by developing a formal model of capturing all dependencies between class deletions and nondeletions as logic clauses. The consistency of the resulting schema can then be guaran teed as long as at least one valid variable assignment exists for all clauses. <p> Furthermore, the resulting global schema must remain consistent after the removal. Two key problems of single class removal, namely the type-effect and the derivation-dependency problems, are reviewed below <ref> [7] </ref>. The type-effect problem refers to the problem that the removal of a class C having locally defined properties may cause as a side-effect the change of other classes' type. <p> To avoid this problem, the locally defined properties of C have to be migrated to its subclasses before the removal is permitted. However, this property migration might violate the single source consistency invariant of the Multi-View model <ref> [7] </ref>, which requires that each property is defined exactly once in GS.
Reference: [8] <author> J. Garcia-Molina E. Bertino, B. Catania and G. Guerrini. </author> <title> A formal model of views for object-oriented database systems. </title> <type> (unpublished), </type> <year> 1996. </year>
Reference-contexts: However, none have considered the schema removal problem as characterized in this paper. Like other view systems presented in the literature [19], in the formal model of views described in <ref> [8] </ref>, the virtual classes are not integrated in the global schema. Therefore, removal of a virtual class in such a system does not impose any constraints regarding consistency of the global schema, since the view schema and the global base schema are not integrated. In the approach described in [8], a <p> in <ref> [8] </ref>, the virtual classes are not integrated in the global schema. Therefore, removal of a virtual class in such a system does not impose any constraints regarding consistency of the global schema, since the view schema and the global base schema are not integrated. In the approach described in [8], a view schema is composed of only virtual classes, and therefore, in order to have a base class in a view schema, they provide a identity virtual class that has the same type and extent as the base class.
Reference: [9] <author> W. Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Given a schema change request, TSE computes a new view schema with the desired semantics; while preserv ing all existing view schemas (and thus old applica tions) 1 . While the TSE approach offers numerous ad vantages over traditional schema versioning sys tems <ref> [9, 10] </ref>, it may result over its lifetime in an ex cessive generation and revision of view schemas.
Reference: [10] <author> W. Kim and H. Chou. </author> <title> Versions of schema for OODBs. </title> <booktitle> In Proc. 14th VLDB, </booktitle> <pages> pages 148-159, </pages> <year> 1988. </year>
Reference-contexts: Given a schema change request, TSE computes a new view schema with the desired semantics; while preserv ing all existing view schemas (and thus old applica tions) 1 . While the TSE approach offers numerous ad vantages over traditional schema versioning sys tems <ref> [9, 10] </ref>, it may result over its lifetime in an ex cessive generation and revision of view schemas.
Reference: [11] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> New benchmark issues for object-oriented view systems. </title> <booktitle> In OOPSLA Workshop on Object-Oriented Database Benchmarking, </booktitle> <month> October </month> <year> 1995. </year> <editor> Kuno and E. A. </editor> <title> Rundensteiner. The MultiView OODB view system: Design and implementation. </title> <editor> In Harold Ossher and William Harri-son, editors, </editor> <booktitle> Accepted by Theory and Practice of Object Systems (TAPOS), Special Issue on Subjectivity in Object-Oriented Systems. </booktitle> <publisher> John Wiley New York, </publisher> <year> 1996. </year>
Reference-contexts: Our test cases are built upon the small OO7 benchmark [5], which we have extended with virtual classes as there is currently no available OO benchmarking testbed for object-oriented views <ref> [11] </ref>. As depicted in Figure 6 (a), the AtomicP art and Document classes from the OO7 benchmark contain 10,000 and 500 object instances, respectively. For each experiment, we run the same set of update operations ten times on the global schema and report the average run time.
Reference: [13] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Using object-oriented principles to optimize update propagation to materialized views. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 310-317, </pages> <year> 1996. </year>
Reference-contexts: The TSE system is built on top of the Multi-View system [18, 12] which is one of the first fully implemented object-oriented view systems to provide updatable and incrementally maintained mate rialized object-oriented views <ref> [12, 13] </ref>. MultiView includes the incorporation of virtual classes into the global schema as first-class database citizens, assuring that properties shared among base and virtual classes are defined exactly once in the global schema. <p> Since the focus of this paper is on materialized view sys tems, we consider the view maintenance costs of a global schema only, but not the retrieval costs 2 . Since our MultiView system utilizes materialized virtual classes <ref> [13, 12] </ref>, updates on base or virtual classes have to be propagated to all dependent derived classes in order to keep the materialized view classes consistent In this paper, we consider insert, delete, and change-attribute operations on base classes 3 .
Reference: [14] <author> M. A. Morsi, S. B. Navathe, and H. J. Kim. </author> <title> A schema management and prototyping interface for an object-oriented database environment. </title> <editor> In F. Van Assche, B. Moulin, and C. Rolland, editors, </editor> <booktitle> Object-Oriented Approach in Information Systems, </booktitle> <pages> pages 157-180. </pages> <publisher> Elsevier Science Publishers B. V. (North Holland), </publisher> <year> 1991. </year>
Reference-contexts: Some versioning systems however provide code reuse and sharing of data. In the work by <ref> [14] </ref>, class versions are placed in one global schema, where versions of a particular class forms a sub-hierachy in the global schema, enabling the sharing of object instances among different versions. In such an approach, removal of class versions has side-effects on the remaining schema and should be done carefully. <p> In such an approach, removal of class versions has side-effects on the remaining schema and should be done carefully. The issues of removal have not been considered in the context of <ref> [14] </ref>. 3 Background: The TSE and MultiView Systems In the TSE system [16, 15], each developer defines his own customized interface of the shared database implemented as a materialized object-oriented view schema in the underlying MultiView system [18, 12].
Reference: [15] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: These mech anisms must allow applications to evolve and flexi bly change their data requirements, while minimiz ing or even eliminating the impact of such change on other integrated applications. In this vein, we are developing a Transparent Schema Evolution sys tem called TSE <ref> [15, 16] </ref> that simulates schema evo lution (SE) using object-oriented views. Given a schema change request, TSE computes a new view schema with the desired semantics; while preserv ing all existing view schemas (and thus old applica tions) 1 . <p> Based on these concepts, we have implemented a first prototype of the TSE optimizer tool on top of TSE/GemStone <ref> [15, 16] </ref>. Finally, we report our evaluation studies that validate our approach and demonstrate its impact on the performance of the TSE system. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature [3, 4]. <p> In such an approach, removal of class versions has side-effects on the remaining schema and should be done carefully. The issues of removal have not been considered in the context of [14]. 3 Background: The TSE and MultiView Systems In the TSE system <ref> [16, 15] </ref>, each developer defines his own customized interface of the shared database implemented as a materialized object-oriented view schema in the underlying MultiView system [18, 12]. <p> Results of this work should improve the efficiency of transparent schema evolution systems such as TSE <ref> [15] </ref>, and thus increase their utility as mechanisms for enabling interoperability. In this paper, we address this problem using effective and consistent schema removal techniques. Our solution to this problem is based on a formal model of capturing all dependencies between class deletions and nondeletions as logic clauses.
Reference: [16] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent schema evolution system based on object-oriented view technology. </title> <note> In to appear in IEEE Trans. on Knowledge and Data Engineering, </note> <year> 1996. </year>
Reference-contexts: These mech anisms must allow applications to evolve and flexi bly change their data requirements, while minimiz ing or even eliminating the impact of such change on other integrated applications. In this vein, we are developing a Transparent Schema Evolution sys tem called TSE <ref> [15, 16] </ref> that simulates schema evo lution (SE) using object-oriented views. Given a schema change request, TSE computes a new view schema with the desired semantics; while preserv ing all existing view schemas (and thus old applica tions) 1 . <p> Based on these concepts, we have implemented a first prototype of the TSE optimizer tool on top of TSE/GemStone <ref> [15, 16] </ref>. Finally, we report our evaluation studies that validate our approach and demonstrate its impact on the performance of the TSE system. 2 Related Work Several other approaches towards transparent schema evolution using views have been recently presented in the literature [3, 4]. <p> In such an approach, removal of class versions has side-effects on the remaining schema and should be done carefully. The issues of removal have not been considered in the context of [14]. 3 Background: The TSE and MultiView Systems In the TSE system <ref> [16, 15] </ref>, each developer defines his own customized interface of the shared database implemented as a materialized object-oriented view schema in the underlying MultiView system [18, 12].
Reference: [17] <author> E. Rundensteiner, H. A. Kuno, Y.-G. Ra, M. C. Jones, V. Crestana, and P. J. Marron. </author> <title> The multiview project: Object-oriented view technology and applications. </title> <booktitle> SIGMOD, </booktitle> <pages> page 555, </pages> <year> 1996. </year>
Reference-contexts: When a new view schema is computed, it might add some new customized virtual classes necessary for this view (and this may cause the global schema and with it the set of underlying object instance rep 1 The MultiView and TSE Systems have been demonstrated at CASCON'95 and at SIGMOD'96 <ref> [17] </ref>. 1 resentations to become larger and larger). In this sense, information is never deleted from the global schema. However, over time, old view interfaces may become obsolete for various reasons. One reason may be that we have successfully migrated all application code to a newer view.
Reference: [18] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction One primary goal of our MultiView project is to ex ploit object-oriented view mechanisms as powerful interoperability-enabling solutions for the integra tion of software applications <ref> [12, 18] </ref>. These mech anisms must allow applications to evolve and flexi bly change their data requirements, while minimiz ing or even eliminating the impact of such change on other integrated applications. <p> The difficulty here is caused by the fact that all view classes (whether base or virtual) from different view schemas are integrated into a unified global schema in our view system to support full-fledged inheritance between base and virtual classes <ref> [18] </ref>. In fact, virtual classes in TSE can independently define additional attributes and methods. Given that they are capacity-augmenting views, we must assure that such information is not lost for other classes during view schema removal. <p> This approach, while avoiding the integration, and therefore further removal consistency problems, has the serious drawback of 2 duplication of information. In systems where the virtual classes are integrated in the global schema <ref> [2, 18, 20] </ref>, code-reuse as well as sharing of data is assured. Our work addresses the removal of such integrated virtual classes. In systems using conventional version-ing rather than object-oriented view mechanisms [1], schema removal is likely to be less of an issue. <p> The issues of removal have not been considered in the context of [14]. 3 Background: The TSE and MultiView Systems In the TSE system [16, 15], each developer defines his own customized interface of the shared database implemented as a materialized object-oriented view schema in the underlying MultiView system <ref> [18, 12] </ref>. All the schema change requests are made by the developer against the customized view schema to which the developer has access (Figure 1 (a)). <p> This approach allows old application programs (program1) to continue to run against the schema they were designed for (VS1). The TSE system is built on top of the Multi-View system <ref> [18, 12] </ref> which is one of the first fully implemented object-oriented view systems to provide updatable and incrementally maintained mate rialized object-oriented views [12, 13]. <p> MultiView supports a full range of virtual classes defined by a single object algebra operator, such as select, hide, union, etc. <ref> [18] </ref>. MultiView's materialized views [12] allow for fast retrieval of all instances from TSE, regardless whether the class we are retrieving the instance from is a base or virtual class. This shields users from the overhead of interoperating via an object repository potentially shared by many other users.
Reference: [19] <author> C. Souza dos Santos, S. Abiteboul, and C. De-lobel. </author> <title> Virtual schemas and bases. </title> <booktitle> In International Conference on Extending Database Technology (EDBT), </booktitle> <year> 1994. </year>
Reference-contexts: However, none have considered the schema removal problem as characterized in this paper. Like other view systems presented in the literature <ref> [19] </ref>, in the formal model of views described in [8], the virtual classes are not integrated in the global schema.
Reference: [20] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Up-datable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: This approach, while avoiding the integration, and therefore further removal consistency problems, has the serious drawback of 2 duplication of information. In systems where the virtual classes are integrated in the global schema <ref> [2, 18, 20] </ref>, code-reuse as well as sharing of data is assured. Our work addresses the removal of such integrated virtual classes. In systems using conventional version-ing rather than object-oriented view mechanisms [1], schema removal is likely to be less of an issue.
References-found: 19

