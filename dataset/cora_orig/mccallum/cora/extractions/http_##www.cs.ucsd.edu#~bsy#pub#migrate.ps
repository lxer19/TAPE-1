URL: http://www.cs.ucsd.edu/~bsy/pub/migrate.ps
Refering-URL: http://www.cs.ucsd.edu/~bsy/
Root-URL: http://www.cs.ucsd.edu
Title: How to Migrate Agents  
Author: Matthew Hohlfeld Bennet Yee 
Date: August 14, 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Stephane Belmon and Bennet Yee. </author> <title> Mobile agents and intellectual property protection. </title> <booktitle> In Proceedings of the Second International Workshop on Mobile Agents 98, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection <ref> [1] </ref>, fault tolerance [16, 18], scalability, to AI metaphors [19, 21]. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [2] <author> Nick Benton, Andrew Kennedy, and George Russell. </author> <title> The MLJ User Guide. Persimmon IT, </title> <publisher> Inc, </publisher> <address> Cam-bridge, UK, </address> <month> May </month> <year> 1998. </year>
Reference-contexts: A pre-compiler transforms such programs into an equivalent program in Java that contains inserted code to perform thread-state migration. Our pre-compiler differ from other projects such as <ref> [2, 5, 9] </ref> that use Java or Java bytecodes as the target language of compilers in that we largely preserve the original code's structure | our transformations are purely syntactic. Throughout this paper, our transformations will be described in terms of writing agents in the Java language.
Reference: [3] <author> Hans Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, number 28, 6 in SIGPLAN Notices, </booktitle> <pages> pages 197-206, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: For weakly typed languages such as C or C++, applying our techniques directly is impossible. This is the same problem faced by conservative garbage collectors for C and C++ <ref> [3, 4] </ref>, except that conservatism forces us send the entire heap. Furthermore, because we cannot distinguish pointers and integers that happen to have the same value, we must ensure that all objects in the heap reside in the same locations before and after migration.
Reference: [4] <author> Hans Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <pages> pages 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: For weakly typed languages such as C or C++, applying our techniques directly is impossible. This is the same problem faced by conservative garbage collectors for C and C++ <ref> [3, 4] </ref>, except that conservatism forces us send the entire heap. Furthermore, because we cannot distinguish pointers and integers that happen to have the same value, we must ensure that all objects in the heap reside in the same locations before and after migration.
Reference: [5] <author> Per Bothner. </author> <title> Kawa | compiling dynamic languages to the java vm. </title> <booktitle> In Proceedings of the USENIX 1998 Technical Conference, FREENIX Track, </booktitle> <address> New Orleans, LA, June 1998. </address> <publisher> USENIX. </publisher>
Reference-contexts: A pre-compiler transforms such programs into an equivalent program in Java that contains inserted code to perform thread-state migration. Our pre-compiler differ from other projects such as <ref> [2, 5, 9] </ref> that use Java or Java bytecodes as the target language of compilers in that we largely preserve the original code's structure | our transformations are purely syntactic. Throughout this paper, our transformations will be described in terms of writing agents in the Java language. <p> Thus, our transformational approach is largely orthogonal to optimizations, with the minor caveat that the transformations might make the compiler less effective in applying optimizations. Optimizing compilers 17 class C f retType thrower (int [] array) throws tooStingyForMeException f retType result; if (array <ref> [5] </ref> == 5) f throw new tooStingyForMeException (targetHost); g /* result gets initialized in elided code */ return result; g retType caller (int [] in array) f retType result; int k = 0; try f result = thrower (in array); /* Elided code */ g catch (tooStingyForMeException bad val) f k <p> elided code */ return result; g retType caller (int [] in array) f retType result; int k = 0; try f result = thrower (in array); /* Elided code */ g catch (tooStingyForMeException bad val) f k = migrate (bad val.targetHost); g finally f System.out.println ("Value: " + in array <ref> [5] </ref> + "k: " + k); g return result; g can make control flow recovery and analysis for bytecode translators more difficult, and the result of the interaction of these components on performance is less clear. <p> We omit the initial transformation that moves all variable declarations before executable statements, and the final transformation that adds flags and converts the goto statements into goto-free "structured" code. 18 class C f retType thrower (int [] array) throws tooStingyForMeException f retType result; if (array <ref> [5] </ref> == 5) f throw new tooStingyForMeException (targetHost); g /* result gets initialized in elided code */ return result; g retType caller (int [] in array) throws Throwable f Throwable currThrow = null; tooStingyForMeException bad val; retType result; int k = 0; try f result = thrower (in array); /* Elided <p> 0; try f result = thrower (in array); /* Elided code */ g catch (tooStingyForMeException t) f currThrow = null; bad val = t; k = migrate (bad val.targetHost); t = null; g g catch (Throwable t) f currThrow = t; g finally f System.out.println ("Value: " + in array <ref> [5] </ref> + "k: " + k); if (currThrow != null) f throw currThrow; g /* no break or continue */ g return result; g class capture throwable retType2 implements Serializable f /* thrower */ int migrateLocation; int migrateStatus; Vector migrationFrames; /* migration return */ int frameIndex; hostInfo targetHost; Throwable currThrow; /* <p> captureReturn.frameIndex = 0; captureReturn.migrationFrames.setElementAt (captureReturn,0); return captureReturn; CaptureLabel2: ; bad val = null; /* bad val goes out of scope */ g g catch (Throwable generic throwable) f currThrow = generic throwable; g finally f if (captureReturn == null jj captureReturn.migrationLocation == 0) f System.out.println ("Value: " + in array <ref> [5] </ref> + "k: " + k); if (captureReturn == null) f if (currThrow != null) f /* re-throw to any enclosing catch */ throw currThrow; g /* no breaks or continues */ g g captureReturn = new capture throwable retType (); captureReturn.returnedValue = result; captureReturn.migrateLocation = 0; return captureReturn; g 21
Reference: [6] <editor> William Clinger and Jonathan Rees, eds. </editor> <title> Revised 4 report on the algorithmic language scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: For languages such as Scheme <ref> [6] </ref> with first class functions, deriving an external representation of the functional objects is possible.
Reference: [7] <author> General Magic, Inc. </author> <title> Introduction to the Odyssey API. </title> <address> 20 North Mary Avenue, Sunnyvale, CA 94086. </address> <note> Manual published as http://www.generalmagic.com/agents/odysseyIntro.pdf. </note>
Reference-contexts: Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl [13], and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. Other systems such as TACOMA [11], Mole [17], Odyssey <ref> [7] </ref>, and Aglets [12] provide "migration" by a specialized remote execution mechanism: they finesse the migration issue by automatically migrating the code but not the current execution state. <p> The programmer is required to explicitly write code to record any partial results in the initialization messages so the new incarnation of the program does not have to repeat work. This is the type of migration provided by mobile agent systems like Odyssey <ref> [7] </ref>, TACOMA [11], and Aglets [12]. Agent systems are arguably served most appropriately by thread-state migration, since explicitness of the execution location is often a goal of these systems. It is also beneficial that transparency with respect to the program's internal state makes writing agents easier.
Reference: [8] <author> General Magic, Inc. </author> <title> An introduction to safety and security in Telescript, </title> <note> 1995. White paper published as http://www.generalmagic.com/Telescript/security.html. </note>
Reference-contexts: Furthermore, transparent migration can be built on top of a basic, explicit agent migration infrastructure. Existing agent systems provide migration in one of two ways. Systems such as Telescript <ref> [8] </ref>, 2 Agent Tcl [13], and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. <p> The program's internal state is migrated, i.e., variables and call stacks. External name spaces, however, are allowed to change. This is the type of migration provided by systems like ARA [15], Agent Tcl [13], and Telescript <ref> [8] </ref>. 3. code-only migration. The program is "restarted" at a remote site, possibly with initializing data in a message provided by the previous run of the program.
Reference: [9] <author> Jonathan C. Hardwick and Jay Sipelstein. </author> <title> Java as an intermediate language. </title> <type> Technical Report CMU-CS-96-161, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: A pre-compiler transforms such programs into an equivalent program in Java that contains inserted code to perform thread-state migration. Our pre-compiler differ from other projects such as <ref> [2, 5, 9] </ref> that use Java or Java bytecodes as the target language of compilers in that we largely preserve the original code's structure | our transformations are purely syntactic. Throughout this paper, our transformations will be described in terms of writing agents in the Java language.
Reference: [10] <author> Colin G. Harrison, David M. Chess, and Aaron Kershenbaum. </author> <title> Mobile agents: Are they a good idea? Lecture Notes in Computer Science, </title> <booktitle> 1222 </booktitle> <pages> 25-47, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction The idea of migrating processes is not new; implementations date back to the 1980s [20]. The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme <ref> [10] </ref>. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance [16, 18], scalability, to AI metaphors [19, 21]. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [11] <author> Dag Johansen, Fred B. Schneider, and Robbert van Renesse. </author> <title> What TACOMA taught us. </title> <editor> In Dejan Milo-jicic, Frederick Douglis, and Richard Wheeler, editors, </editor> <title> Mobility, Mobile Agents and Process Migration | An edited Collection. </title> <publisher> Addison Wesley, </publisher> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl [13], and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. Other systems such as TACOMA <ref> [11] </ref>, Mole [17], Odyssey [7], and Aglets [12] provide "migration" by a specialized remote execution mechanism: they finesse the migration issue by automatically migrating the code but not the current execution state. <p> The programmer is required to explicitly write code to record any partial results in the initialization messages so the new incarnation of the program does not have to repeat work. This is the type of migration provided by mobile agent systems like Odyssey [7], TACOMA <ref> [11] </ref>, and Aglets [12]. Agent systems are arguably served most appropriately by thread-state migration, since explicitness of the execution location is often a goal of these systems. It is also beneficial that transparency with respect to the program's internal state makes writing agents easier.
Reference: [12] <author> Danny B. Lange and Daniel T. Chang. </author> <title> IBM Aglets workbench. </title> <note> IBM Tokyo Research White paper at http://www.trl.ibm.co.jp/aglets/whitepaper.htm, September 1996. </note>
Reference-contexts: Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl [13], and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. Other systems such as TACOMA [11], Mole [17], Odyssey [7], and Aglets <ref> [12] </ref> provide "migration" by a specialized remote execution mechanism: they finesse the migration issue by automatically migrating the code but not the current execution state. <p> The programmer is required to explicitly write code to record any partial results in the initialization messages so the new incarnation of the program does not have to repeat work. This is the type of migration provided by mobile agent systems like Odyssey [7], TACOMA [11], and Aglets <ref> [12] </ref>. Agent systems are arguably served most appropriately by thread-state migration, since explicitness of the execution location is often a goal of these systems. It is also beneficial that transparency with respect to the program's internal state makes writing agents easier.
Reference: [13] <author> Jacob Y. Levy and John K. Ousterhout. </author> <title> A safe Tcl toolkit for electronic meeting places (extended abstract). </title> <booktitle> In Proceedings of the First USENIX Workshop in Electronic Commerce, </booktitle> <pages> pages 133-135, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Furthermore, transparent migration can be built on top of a basic, explicit agent migration infrastructure. Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl <ref> [13] </ref>, and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. <p> This is the type of migration provided by the LOCUS [20] operating system. 2. thread-state migration. The program's internal state is migrated, i.e., variables and call stacks. External name spaces, however, are allowed to change. This is the type of migration provided by systems like ARA [15], Agent Tcl <ref> [13] </ref>, and Telescript [8]. 3. code-only migration. The program is "restarted" at a remote site, possibly with initializing data in a message provided by the previous run of the program.
Reference: [14] <author> James O'Toole, Scott Nettles, and David Gifford. </author> <title> Concurrent compacting garbage collection of a persistent heap. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 161-174, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: For objects such as functions, continuations, and closures, creating an external representation is still possible, as we will see below. For languages without object serialization or reflection that use garbage collection, object serialization can be achieved by extending the garbage collector. In <ref> [14] </ref>, this technique is used to provide persistence to ML. Since persistent data is placed in stable storage, this data is already serialized and compact after log truncation; it is just not directly accessible to the programmer.
Reference: [15] <author> Holger Peine and Torsten Stolpmann. </author> <title> The architecture of the ARA platform for mobile agents. </title> <editor> In Kurt Rothermel and Radu Popescu-Zeletin, editors, </editor> <booktitle> Proceedings of the First International Workshop on Mobile Agents, volume 1219 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year> <note> ISBN 3-540-62803-7. 22 </note>
Reference-contexts: Furthermore, transparent migration can be built on top of a basic, explicit agent migration infrastructure. Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl [13], and ARA <ref> [15] </ref> provide migration by using a specialized language interpreter to capture the process's state. <p> This is the type of migration provided by the LOCUS [20] operating system. 2. thread-state migration. The program's internal state is migrated, i.e., variables and call stacks. External name spaces, however, are allowed to change. This is the type of migration provided by systems like ARA <ref> [15] </ref>, Agent Tcl [13], and Telescript [8]. 3. code-only migration. The program is "restarted" at a remote site, possibly with initializing data in a message provided by the previous run of the program.
Reference: [16] <author> Fred B. Schneider. </author> <title> Towards fault-tolerant and secure agentry. </title> <booktitle> In Proceedings of the 11th International Workshop on Distributed Algorithms, </booktitle> <address> Saarbucken, Germany, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance <ref> [16, 18] </ref>, scalability, to AI metaphors [19, 21]. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [17] <author> Markus Straer, Joachim Baumann, and Fritz Hohl. </author> <title> Mole | a Java based agent system. </title> <booktitle> In Proceedings of the ECOOP '96 Workshop on Mobile Object System, </booktitle> <year> 1996. </year>
Reference-contexts: Existing agent systems provide migration in one of two ways. Systems such as Telescript [8], 2 Agent Tcl [13], and ARA [15] provide migration by using a specialized language interpreter to capture the process's state. Other systems such as TACOMA [11], Mole <ref> [17] </ref>, Odyssey [7], and Aglets [12] provide "migration" by a specialized remote execution mechanism: they finesse the migration issue by automatically migrating the code but not the current execution state.
Reference: [18] <author> David L. Tennenhouse, Jonathan M. Smith, W. David Sincoskie, David J. Wetherall, and Gary J. Minden. </author> <title> A survey of active network research. </title> <journal> IEEE Communications Magazine, </journal> <pages> pages 80-86, </pages> <month> Jan </month> <year> 1997. </year>
Reference-contexts: The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance <ref> [16, 18] </ref>, scalability, to AI metaphors [19, 21]. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [19] <author> Chelliah Thirunavukkarasu, Tim Finin, and James Mayfield. </author> <title> Secret agents | a security architecture for the kqml agent communication language. </title> <booktitle> In Proceedings of the CIKM '95 Intelligent Information Agents Workshop, </booktitle> <address> Baltimore, MA, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance [16, 18], scalability, to AI metaphors <ref> [19, 21] </ref>. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [20] <author> B. Walker, G. Popek, R. English, C. Kline, and G. Thiel. </author> <title> The LOCUS distributed operating system. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 49-70. </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: 1 Introduction The idea of migrating processes is not new; implementations date back to the 1980s <ref> [20] </ref>. The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance [16, 18], scalability, to AI metaphors [19, 21]. <p> The goal of using agent architectures varies from intellectual property protection [1], fault tolerance [16, 18], scalability, to AI metaphors [19, 21]. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS <ref> [20] </ref> provided process migration with full kernel support. To do this, these systems take a snapshot of the process's state, transfer it to another machine, and provide transparency for all system accesses. <p> All of the running program's state is migrated. This includes all threads' call stacks, kernel-mediated name spaces such as I/O descriptors, file-system names, etc., and other kernel-mediated state such as alarm timers, so that the migration is completely transparent. This is the type of migration provided by the LOCUS <ref> [20] </ref> operating system. 2. thread-state migration. The program's internal state is migrated, i.e., variables and call stacks. External name spaces, however, are allowed to change. This is the type of migration provided by systems like ARA [15], Agent Tcl [13], and Telescript [8]. 3. code-only migration.
Reference: [21] <author> J. E. White. </author> <title> Mobile agents. </title> <editor> In J. Bradshaw, editor, </editor> <booktitle> Software Agents. </booktitle> <publisher> AAAI Press and MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The early motivations for migrating processes were load balancing 1 and improved fault tolerance. Migrating autonomous agents is a more recent variation on this theme [10]. The goal of using agent architectures varies from intellectual property protection [1], fault tolerance [16, 18], scalability, to AI metaphors <ref> [19, 21] </ref>. This paper describes a novel mechanism for migrating programs in agent systems. Previous systems such as LOCUS [20] provided process migration with full kernel support.
Reference: [22] <author> Bennet S. Yee. </author> <title> The portable save world process checkpointing package, </title> <note> 1986. Software package available from http://www.cs.ucsd.edu/~bsy/pub/save world.tar. </note>
Reference-contexts: In these cases, the pre-compiler techniques presented here are entirely inappropriate, and other process state capture mechanisms should be used <ref> [22] </ref>. Thread-state migration would only possible if "dangerous" language features such as type casts are avoided.
Reference: [23] <author> Bennet S. Yee. </author> <title> A sanctuary for mobile agents. </title> <booktitle> In Proceedings of the DARPA Workshop on Foundations for Secure Mobile Code, </booktitle> <month> March </month> <year> 1997. </year> <month> 23 </month>
Reference-contexts: We were motivated to look at mobile agents because of the security problems inherent in this style of distributed computation <ref> [23] </ref>. By using a pre-compiler to implement migration, we reduce the amount of code in the trusted computing base. This has two important effects: the likelihood of an error in the trusted computing base is smaller, and upgrades of the migration mechanism do not affect the trusted computing base.
References-found: 23

