URL: http://www.cs.wisc.edu/~fischer/cs701/pldi95.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/cs701/readings.html
Root-URL: 
Email: knoop@fmi.uni-passau.de  or@informatik.uni-kiel.d400.de  steffen@fmi.uni-passau.de  
Title: The Power of Assignment Motion  
Author: Jens Knoop Oliver Ruthing Bernhard Steffen 
Keyword: Topics: data flow analysis, program optimization, partially redundant assignment and expression elimination, code motion, assignment motion, bit-vector data flow analyses.  
Date: (1995), 233 245.  
Note: In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation (PLDI'95), La Jolla, California, SIGPLAN Notices 30 6  
Address: Passau  Kiel  Passau  Pas-sau, Innstrae 33, D-94032 Passau, Germany.  Christian-Albrechts-Universitat, Preuerstrae 1-9, D-24105 Kiel, Germany.  
Affiliation: Universitat  CAU  Universitat  Fakultat fur Mathematik und Informatik, Universitat  Institut fur Informatik und Praktische Mathematik,  
Abstract: Assignment motion (AM) and expression motion (EM) are the basis of powerful and at the first sight incomparable techniques for removing partially redundant code from a program. Whereas AM aims at the elimination of complete assignments, a transformation which is always desirable, the more flexible EM requires temporaries to remove partial redundancies. Based on the observation that a simple program transformation enhances AM to subsume EM, we develop an algorithm that for the first time captures all second order effects between AM and EM transformations. Under usual structural restrictions, the worst case time complexity of our algorithm is essentially quadratic, a fact which explains the promising experience with our implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: In the following we discuss these procedures in more detail. 4.3.1 Redundant Assignment Elimination The elimination of redundant assignments is based on a forwards directed bit-vector data flow analysis <ref> [1, 13] </ref>, which is specified in Table 2, where N-REDUNDANT (ff) (or X-REDUNDANT (ff)) means that assignment pattern ff is redundant at the entry (or exit) of instruction .
Reference: [2] <author> P. Briggs and K. D. Cooper. </author> <title> Effective partial redundancy elimination. </title> <booktitle> In Proc. ACM SIG-PLAN Conference on Programming Language Design and Implementation'94, volume 29,6 of ACM SIGPLAN Notices, </booktitle> <pages> pages 159 - 170, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Our algorithm works for arbitrary control flow structures and elegantly solves the problem of distinguishing between profitable code motion across loop structures and fatal code motion into loops (cf. <ref> [2] </ref>). This is illustrated in the example of Figure 7 (a), which contains two loop constructs, one of which is even irreducible. node 6. Thereby, the assignment of node 11 is moved across the irreducible loop construct. <p> Though this assumption is uncritical in that all assignments can be canonically decomposed into sequences of assignments of this form along the inductive structure of terms (cf. [18]) or a special naming discipline <ref> [2] </ref>, this decomposition may block subsequent transformations. This is illustrated in Figure 18 (a) displaying a program whose 3-address decomposition is shown in Figure 18 (b).
Reference: [3] <author> R. Cytron, A. Lowry, and F. K. Zadeck. </author> <title> Code motion of control structures in high-level languages. </title> <booktitle> In Conf. Record of the 13 th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 70 - 85, </pages> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: would require to move x := y + z into the first loop, which would dramatically impair some program executions. 1.4 Related Work In contrast to EM, which has thoroughly been studied in program optimization (cf. [2, 4, 8, 9, 10, 11, 16, 2 A similar step was suggested in <ref> [3] </ref> in order to separate the effects of moving stores from the effects of moving expressions. 18, 20]), AM has yet been investigated rarely. The most relevant papers on this subject are by Dhamd-here [5, 6, 7].
Reference: [4] <author> D. M. Dhamdhere. </author> <title> A fast algorithm for code movement optimization. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(10):172 - 180, </volume> <year> 1988. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]). <p> of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1.
Reference: [5] <author> D. M. Dhamdhere. </author> <title> Register assignment using code placement techniques. </title> <journal> Journal of Computer Languages, </journal> <volume> 13(2):75 - 93, </volume> <year> 1988. </year>
Reference-contexts: The most relevant papers on this subject are by Dhamd-here <ref> [5, 6, 7] </ref>. Most similar to the assignment motion step of our algorithm is the algorithm of [7], where an extension of EM to AM is presented. <p> In contrast, after suspending the blockade of x := y + z by hoisting the assignment of a := x+y to node 2 and 3, which is displayed in Figure 9 (a), our algorithm yields the result of Figure 9 (b). In <ref> [5, 6] </ref> Dhamdhere presents an application of assignment hoisting and sinking techniques to register assignment . This, however, does not contribute to the general problem of eliminating partially redundant assignments.
Reference: [6] <author> D. M. Dhamdhere. </author> <title> A usually linear algorithm for register assignment using edge placement of load and store instructions. </title> <journal> Journal of Computer Languages, </journal> <volume> 15(2):83 - 94, </volume> <year> 1990. </year>
Reference-contexts: The most relevant papers on this subject are by Dhamd-here <ref> [5, 6, 7] </ref>. Most similar to the assignment motion step of our algorithm is the algorithm of [7], where an extension of EM to AM is presented. <p> In contrast, after suspending the blockade of x := y + z by hoisting the assignment of a := x+y to node 2 and 3, which is displayed in Figure 9 (a), our algorithm yields the result of Figure 9 (b). In <ref> [5, 6] </ref> Dhamdhere presents an application of assignment hoisting and sinking techniques to register assignment . This, however, does not contribute to the general problem of eliminating partially redundant assignments.
Reference: [7] <author> D. M. Dhamdhere. </author> <title> Practical adaptation of the global optimization algorithm of Morel and Ren-voise. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2):291 - 294, </volume> <year> 1991. </year> <type> Technical Correspondence. </type>
Reference-contexts: In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. <ref> [7] </ref>). Note that the program transformations of Figure 1 and 2 are incomparable. However, after the simple program transformation illustrated in Figure 3 (a), AM subsumes EM. <p> The most relevant papers on this subject are by Dhamd-here <ref> [5, 6, 7] </ref>. Most similar to the assignment motion step of our algorithm is the algorithm of [7], where an extension of EM to AM is presented. <p> The most relevant papers on this subject are by Dhamd-here [5, 6, 7]. Most similar to the assignment motion step of our algorithm is the algorithm of <ref> [7] </ref>, where an extension of EM to AM is presented. In contrast to our approach, however, Dhamdhere's algorithm heuristically restricts assignment hoistings to `immediately profitable' ones, i.e., to hoistings which eliminate a partially redundant assignment. This restriction prohibits optimal transformation results.
Reference: [8] <author> D. M. Dhamdhere and H. Patil. </author> <title> An elimination algorithm for bidirectional data flow problems using edge placement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2):312 - 336, </volume> <month> April </month> <year> 1993. </year>
Reference: [9] <author> D. M. Dhamdhere, B. K. Rosen, and F. K. Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation'92, volume 27,7 of ACM SIGPLAN Notices, </booktitle> <pages> pages 212 - 223, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]). <p> of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1. <p> Usually, this problem is dealt with by interleaving EM with copy propagation (CP) (cf. <ref> [9] </ref>). This results in the program of Figure 20 (a). In contrast, the final flush phase of our algorithm guarantees the result dis played in Figure 20 (b), which is better than the programs given in Figures 19 (a) and 20 (a).
Reference: [10] <author> K.-H. Drechsler and M. P. Stadel. </author> <title> A solution to a problem with Morel and Renvoise's "Global optimization by suppression of partial redundancies". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4):635 - 640, </volume> <year> 1988. </year> <type> Technical Correspondence. </type>
Reference: [11] <author> K.-H. Drechsler and M. P. Stadel. </author> <title> A variation of Knoop, Ruthing and Steffen's lazy code motion. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(5):29 - 38, </volume> <year> 1993. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]).
Reference: [12] <author> L. Feigen, D. Klappholz, R. Casazza, and X. Xue. </author> <title> The revival transformation. </title> <booktitle> In Conf. Record of the 21 nd ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 421 - 434, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: It is worth noting that admissible assignment hoist-ings and redundant assignment eliminations preserve the program semantics. This is in contrast to assignment eliminations based on dead code elimination (cf. <ref> [12, 19] </ref>).
Reference: [13] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier, North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: In the following we discuss these procedures in more detail. 4.3.1 Redundant Assignment Elimination The elimination of redundant assignments is based on a forwards directed bit-vector data flow analysis <ref> [1, 13] </ref>, which is specified in Table 2, where N-REDUNDANT (ff) (or X-REDUNDANT (ff)) means that assignment pattern ff is redundant at the entry (or exit) of instruction .
Reference: [14] <author> J. B. Kam and J. D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1):158 - 171, </volume> <year> 1976. </year>
Reference-contexts: The complexity of the initialization phase is trivially linear in the program size. For structured programs the final flush phase is almost linear in the program size, since the efficient bitvector techniques of <ref> [14, 15, 21] </ref> become applicable for solving the uni-directional data flow analyses the lcm-transformation is based on. In the unstructured case, it is quadratic. The same estimation holds for a single application of the assignment hoisting and elimination procedure of the assignment motion phase.
Reference: [15] <author> K. Kennedy. </author> <title> Node listings applied to data flow analysis. </title> <booktitle> In Conf. Record of the 2 nd ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 10 - 21, </pages> <address> Palo Alto, CA, </address> <year> 1975. </year>
Reference-contexts: The complexity of the initialization phase is trivially linear in the program size. For structured programs the final flush phase is almost linear in the program size, since the efficient bitvector techniques of <ref> [14, 15, 21] </ref> become applicable for solving the uni-directional data flow analyses the lcm-transformation is based on. In the unstructured case, it is quadratic. The same estimation holds for a single application of the assignment hoisting and elimination procedure of the assignment motion phase.
Reference: [16] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Lazy code motion. </title> <booktitle> In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation'92, volume 27,7 of ACM SIGPLAN Notices, </booktitle> <pages> pages 224 - 234, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]). <p> This optimization is achieved by our algorithm in the 1 Expression optimality is called computational optimality in <ref> [16, 18] </ref>. following steps: It eliminates the assignment y := c + d in node 3, which is redundant with respect to the corresponding assignment of node 1. <p> This maximizes the potential of redundant assignments, which are subsequently eliminated. The third step is a transformation in the spirit of the lazy code motion (lcm) transformation of <ref> [16, 18] </ref>. Essentially, it flushes all assignments to temporaries introduced in the first step that do not contribute to the elimination of a partial redundancy. <p> of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1. <p> This guaranty is a central feature of the lazy code motion procedure of <ref> [16, 18] </ref>, which distinguishes it from all previous algorithms for EM. This property carries over to the final flush phase of our algorithm, which is realized by a variant of the lazy code motion procedure of [18], a straightforward adaption of the original procedure to our current situation. <p> This analysis replaces the less intuitive isolation analysis of <ref> [16, 18] </ref>. the program invariant. In the case of totally redundant assignment elimination this simply means that no further assignments are eliminated, and in the case of assignment hoisting this holds, if every basic block n satisfies N-INSERT n = LOC-HOISTABLE n and X-INSERT n = false.
Reference: [17] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Lazy strength reduction. </title> <journal> Journal of Programming Languages, </journal> <volume> 1(1) </volume> <pages> 71-91, </pages> <year> 1993. </year>
Reference-contexts: of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1.
Reference: [18] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Optimal code motion: </title> <journal> Theory and practice. ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1117-1155, </pages> <year> 1994. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]). <p> This optimization is achieved by our algorithm in the 1 Expression optimality is called computational optimality in <ref> [16, 18] </ref>. following steps: It eliminates the assignment y := c + d in node 3, which is redundant with respect to the corresponding assignment of node 1. <p> This maximizes the potential of redundant assignments, which are subsequently eliminated. The third step is a transformation in the spirit of the lazy code motion (lcm) transformation of <ref> [16, 18] </ref>. Essentially, it flushes all assignments to temporaries introduced in the first step that do not contribute to the elimination of a partial redundancy. <p> of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1. <p> of admissible assignment hoistings and redundant assignment eliminations. 3.1 The Universe In the following we will write G ` EM G 0 or G ` AM G 0 if the flow graph G 0 results from G from applying an expression motion transformation (see Figure 1 for illustration, and e.g. <ref> [18] </ref> for details), or from applying an assignment motion transformation, i.e., from applying an admissible assignment hoisting or redundant assignment elimination, respectively (see Figure 2 for illustration). Moreover, let ` = df ` EM [ ` AM . <p> See <ref> [18] </ref> for details. * a procedure lcm for the elimination of unnecessary assignments to temporaries which are organized in three phases: 1. Initialization: Introducing temporaries 2. Assignment Motion: Eliminating partially redun dant assignments 3. <p> The assignment motion phase, subsequently, which is the main phase of our global algorithm, is composed of the rae- and aht-procedure, which are applied until the program stabilizes. The concluding final flush phase is an application of essentially the lcm-procedure of <ref> [18] </ref>, and eliminates all unnecessary assignments to temporaries introduced in the initialization phase. <p> The following lemma states three important properties of this transformation. First, it stays within the program universe G. Second, it guarantees relative temporary-optimality, which can be proved along the lines of the `lifetime optimality' Theorem of <ref> [18] </ref>, and third it preserves the optimization of the assignment motion phase. Lemma 4.4 (Final Flush Phase Lemma) 7 Due to edge splitting there are no insertions at the entry of join nodes. 1. G GlobAlg 2 G 2. <p> This guaranty is a central feature of the lazy code motion procedure of <ref> [16, 18] </ref>, which distinguishes it from all previous algorithms for EM. This property carries over to the final flush phase of our algorithm, which is realized by a variant of the lazy code motion procedure of [18], a straightforward adaption of the original procedure to our current situation. <p> This guaranty is a central feature of the lazy code motion procedure of [16, 18], which distinguishes it from all previous algorithms for EM. This property carries over to the final flush phase of our algorithm, which is realized by a variant of the lazy code motion procedure of <ref> [18] </ref>, a straightforward adaption of the original procedure to our current situation. Similar to the original procedure it is based on two uni-directional bitvector data flow analyses computing delayable program points, where an initialization is usable 8 (cf. Table 3). <p> This analysis replaces the less intuitive isolation analysis of <ref> [16, 18] </ref>. the program invariant. In the case of totally redundant assignment elimination this simply means that no further assignments are eliminated, and in the case of assignment hoisting this holds, if every basic block n satisfies N-INSERT n = LOC-HOISTABLE n and X-INSERT n = false. <p> Though this assumption is uncritical in that all assignments can be canonically decomposed into sequences of assignments of this form along the inductive structure of terms (cf. <ref> [18] </ref>) or a special naming discipline [2], this decomposition may block subsequent transformations. This is illustrated in Figure 18 (a) displaying a program whose 3-address decomposition is shown in Figure 18 (b).
Reference: [19] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Partial dead code elimination. </title> <booktitle> In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation'94, volume 29,6 of ACM SIGPLAN Notices, </booktitle> <pages> pages 147 - 158, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: of occurrences of the pattern on p in G. 2.1 Critical Edges It is well-known that code motion transformations can be blocked by critical edges of a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [4, 9, 16, 17, 18, 19] </ref>). In Figure 10 (a) the assignment x := a + b at node 3 is partially redundant with respect to the assignment at node 1. <p> It is worth noting that admissible assignment hoist-ings and redundant assignment eliminations preserve the program semantics. This is in contrast to assignment eliminations based on dead code elimination (cf. <ref> [12, 19] </ref>). <p> In fact, this analysis is dual to the delayability analysis of the partial dead code elimination algorithm of <ref> [19] </ref>, which was designed to determine how far an assignment can be sunk from its original location to later program points, while maintaining the program semantics. Table 1 presents the hoistability analysis in a bit-vector format, where each bit corresponds to an assignment pattern occurring in the program. <p> In the unstructured case, it is quadratic. The same estimation holds for a single application of the assignment hoisting and elimination procedure of the assignment motion phase. As for the partial dead code elimination algorithm of <ref> [19] </ref>, the number of applications of these procedures is at most quadratic in the program size, but linear for realistic programs. <p> Proof: The relative expression-optimality of G GlobAlg is already guaranteed by Lemma 4.4 (3b) and Corollary 4.3. Moreover, according to Lemma 4.4 (3b), it suffices to prove the `full' expression-optimality of G AssMot to complete the proof. This can be done along the lines of <ref> [19] </ref>. The point is that ` contains &lt; ~ exp -improving transformations only, i.e. G 0 ` G 00 ) G 0 &lt; Together with the local confluence of ` (cp. Lemma 3.6), we easily conclude that different relatively expression-optimal programs in G are equivalent up to ~ exp .
Reference: [20] <author> E. Morel and C. </author> <title> Renvoise. Global optimization by suppression of partial redundancies. </title> <journal> Communications of the ACM, </journal> <volume> 22(2):96 - 103, </volume> <year> 1979. </year>
Reference-contexts: This is known as partially redundant expression elimination (PREE) or as expression motion (EM) for short (cf. <ref> [4, 9, 11, 16, 18, 20] </ref>). the occurrences of x := a+b in node 2 and 3 to node 1. In analogy to PREE this technique is called partially redundant assignment elimination (PRAE) or simply assignment motion (AM) (cf. [7]). <p> An assignment (expression) pattern ff (") is a string of the form v := t (t). As usual (cf. <ref> [20] </ref>), we assume that t contains at most one operator symbol. The reasonability of this assumption, which simplifies the presentation of our algorithm, is discussed in more detail in Section 6.

References-found: 20

