URL: http://www.cs.wisc.edu/~musicant/effstor.ps
Refering-URL: http://www.cs.wisc.edu/~musicant/
Root-URL: 
Title: Efficient Storage of Temporal Data in a Data Warehousing Context  
Author: Dave Musicant and Mihaela Patricia Dabu 
Date: December 1, 1997  
Affiliation: Computer Sciences Department University of Wisconsin|Madison  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Gupta and I. Singh Mumick, </author> <title> "Maintenance of Materialized Views: Problems and Techniques and Applications", </title> <journal> Bell Laboratories, Data Engineering Bulletin, </journal> <month> June, </month> <year> 1995. </year>
Reference-contexts: As such, we now look at previous research in this area. 7 2.2 Materialized Views The concept of materialized view has received a lot of attention from researchers over the last decade, especially connected to applications like data warehousing, replication servers, data recording systems, data visualization and mobile systems <ref> [1] </ref>. Materialized views are used in environments where the query rate is high and views are complicated to recompute on a frequent basis. One of the main problems with materialized views is their maintenance. Of course, for static databases, this problem is not encountered. <p> In most cases it is wasteful to entirely recompute a view every time its base relations are updated. There have been developed algorithms that compute changes to the views as a consequence of the updates to the base relations. These algorithms are called incremental view maintenance algorithms <ref> [1] </ref>. Some of these algorithms try to discover which updates to the base relations are relevant or irrelevant to the materialized view. It is very important to know that some updates to the base relations have no effect on the state of the view. J.
Reference: [2] <author> Jose A. Blakeley, Per-Ake Larson and Frank Wm. Tompa, </author> <title> "Efficiently Updating Materialized Views", </title> <booktitle> "Proceeding of ACM-SIGMOD Conference on Management of Data", </booktitle> <pages> pp. 61-71, </pages> <year> 1986." </year>
Reference-contexts: Some of these algorithms try to discover which updates to the base relations are relevant or irrelevant to the materialized view. It is very important to know that some updates to the base relations have no effect on the state of the view. J. Blakeley et al. in <ref> [2] </ref> describe an algorithm that detects "relevant updates" (i.e., updates that influence the view). A mechanism based on Boolean expressions is used to derive necessary and sufficient conditions for detecting of relevant database updates. <p> C (Y ) can be evaluated by replacing its variables with the values of the tuples to be modified. If the result of this evaluation is True, it means that inserting/deleting that tuple in/from the base relation is relevant to the view <ref> [2] </ref>. Although in general the decid-ability of the satisfiability of Boolean expressions is N P -complete, there still exists a large class of Boolean expressions for which satisfiability can be decided efficiently [2]. <p> evaluation is True, it means that inserting/deleting that tuple in/from the base relation is relevant to the view <ref> [2] </ref>. Although in general the decid-ability of the satisfiability of Boolean expressions is N P -complete, there still exists a large class of Boolean expressions for which satisfiability can be decided efficiently [2]. This class contains expressions which have atomic formulae with one of the following operators: =; &lt;; &gt;; ; . Efficiency arises from the avoidance of the 6= operator. <p> This could have significant implications for our work, as we will be considering incremental methods of storing old relations. As incremental methods are applied to our relations, we will want to consider how to do so efficiently. Blakeley <ref> [2] </ref> also describes an algorithm for differential re-evaluation of views. There has been tremendous amount of work put into the development of differential update algorithms. D. Vista in [3] presents briefly some of the research in incremental algorithms done by Koening, Blakeley, Ceri, Gupta, Dong, and Urpi. <p> Blakeley considers the view updating for selection, projection, join and select-project-join views separately, underlining the problems for each of them and providing alternatives to solve them. Selection views are the simplest to be updated. Projection views introduce difficulties when the base relations are updated through deletion operations <ref> [2] </ref>. Two alternative solutions are presented for this problem, one involving a multiplicity counter for each view tuple, recording the number of operand tuples that contribute to it. The tuple is deleted only when its attached counter reaches the value zero. <p> The other solution of Blakeley is to have in the view the key field of the underlying relation. In this last case insertion and deletions are handled efficiently and correctly, but this imposes more re strictions on the views <ref> [2] </ref>. 8 Binary tables are used for the computations of differential updates to the join-views. The tuples are "tagged" as old, insert, delete in order for the algorithm to know how to treat them.
Reference: [3] <author> Dimitra Vista, </author> <title> "View Maintenance in Relational and Deductive Databases by Incremental Query Evaluation", </title> <booktitle> Proceedings of CASCON Conference (CD-ROM), </booktitle> <year> 1994. </year>
Reference-contexts: As incremental methods are applied to our relations, we will want to consider how to do so efficiently. Blakeley [2] also describes an algorithm for differential re-evaluation of views. There has been tremendous amount of work put into the development of differential update algorithms. D. Vista in <ref> [3] </ref> presents briefly some of the research in incremental algorithms done by Koening, Blakeley, Ceri, Gupta, Dong, and Urpi. Blakeley considers the view updating for selection, projection, join and select-project-join views separately, underlining the problems for each of them and providing alternatives to solve them.
Reference: [4] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, J. Widom, </author> <title> "View Maintenance in a Warehousing Environment", </title> <booktitle> Proceedings of SIGMOD Conference, </booktitle> <pages> pp. 316-327, </pages> <year> 1995. </year>
Reference-contexts: Thus they provide a smooth integration of such adaptation techniques into the framework of current relational database systems [35]. Our model also concerns itself with changing views, as fields may be added or removed from our views. Y. Zhuge et al. in <ref> [4] </ref> directed their research to solving the view maintenance problem for warehousing, where the view definition and the base data are decoupled (distributed). This fact can introduce anomalies when the traditional algorithms are applied. <p> Performance evaluation of the ECA and its two derivatives, ECA K and ECA L are also presented, showing that ECA is more efficient than periodically recomputing the warehouse view from scratch <ref> [4] </ref>. Again, this algorithm works in real-time, a case which does not interest us in particular. Their idea, however, is interesting to us from another perspective: they have considered in detail the idea of recording changes to one relation for purposes of updating another relation at a later time.
Reference: [5] <author> B. Lindsay, L Haas, C. Mohan, H. Pirahesh and P. Wilms, </author> <title> "A Snapshot Differential Refresh Algorithm", </title> <booktitle> Proceedings of SIGMOD Conference, </booktitle> <pages> pp. </pages> <month> 53-60 </month> <year> 1986. </year>
Reference-contexts: Snapshots are useful in distributed systems, as a cost-effective substitution for replicated data. B. Lindsay et al. developed an algorithm that determines the changes to the base relations that need to be applied to the snapshots at the "refresh" time, when snapshots are derived from a single base relation <ref> [5] </ref>. We have used a similar idea in our algorithm. In their differential refresh algorithm both the base relation and the snapshot keep some time information plus other useful fields.
Reference: [6] <author> W.J. Labio, H. Garcia-Molina, </author> <title> "Efficient Snapshot Differential Algorithms for Data Warehousing", </title> <booktitle> VLDB, </booktitle> <pages> pp. 63-74, </pages> <year> 1996. </year>
Reference-contexts: If the timestamp of a base relation tuple is greater than the time the snapshot was last refreshed, then that tuple must be transmitted to the snapshot. An analysis of the differential algorithm concludes the paper. W.J. Labio et al. looked at how to extract modifications to information sources <ref> [6] </ref>. Modifications at the sources are inferred by comparing a current source snapshot with an earlier one. This approach is defined as the snapshot differential problem. The authors state that this approach does not scale well as the volume of data increases, bigger comparisons are needed.
Reference: [7] <author> M. Adiba, </author> <title> "Derived Relations: A Unified Mechanism for Views, Snapshots and Distributed Data", </title> <publisher> IEEE, </publisher> <year> 1981. </year>
Reference: [8] <author> J.J. Lu, G. Moerkotte, J. Schue and V.S. Subrahmanian, </author> <title> "Efficient Maintenance of Materialized Mediated Views", </title> <booktitle> SIGMOD '95. </booktitle>
Reference: [9] <author> M.E. Adiba and B.G. Lindsay, </author> <title> "Database Snapshots", </title> <publisher> IEEE, </publisher> <year> 1980. </year>
Reference: [10] <author> R. Snodgrass and I. Ahn, </author> <title> "Temporal Databases", </title> <month> September, </month> <year> 1986. </year>
Reference-contexts: There has been much research into the question of how to represent time information in databases. Unfortunately, the nomenclature gets quite confusing. Snodgrass and Ahn's work <ref> [10] </ref> in 1986 introduced much of the terminology used today. However, some terms "stuck" better than others, leading to some confusion. Jensen [42] has published more current glossaries, and maintains a web page [43] containing terminology that might be considered more precise. <p> Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension <ref> [10] </ref>, [12], [15], [44], [45], [46]. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on.
Reference: [11] <author> R. Snodgrass and I. Ahn, </author> <title> "A Taxonomy of Time in Databases", </title> <publisher> ACM, </publisher> <month> March, </month> <year> 1985. </year> <month> 30 </month>
Reference-contexts: However, the question "What would the result of this query look like if I had asked it three months ago?" cannot be answered. We will refer to such a query as a rollback query, as it reflects some the flavor of rollback databases <ref> [11] </ref>. A query on old data today will return a different result than a rollback query would on the same old data, due to historical revision. This sort of query suggested above has significant applications for industry. <p> Its importance here is only in that it can generate confusion, and should be ignored for our discussion. A snapshot database <ref> [11] </ref>, [43], also referred to as a static database [11] is one in which each relation represents only the most current point in time. As updates are made to the database, no history of its past form are maintained. This is exactly the situation we have described in our example. <p> Its importance here is only in that it can generate confusion, and should be ignored for our discussion. A snapshot database <ref> [11] </ref>, [43], also referred to as a static database [11] is one in which each relation represents only the most current point in time. As updates are made to the database, no history of its past form are maintained. This is exactly the situation we have described in our example. <p> Most works refer to a temporal database as one in which some aspect of time (other than user-defined) is implemented [34], [41]. Others are more specific and define a temporal database to be one which supports both valid time and transaction time <ref> [11] </ref>. Those in the first camp refer to these as bitemporal databases. We will follow the first convention, as the nomenclature bitemporal database clearly illustrates its nature as both a rollback database and a historical database.
Reference: [12] <author> R. Snodgrass, </author> <title> "Temporal Databases Status and Research Directions",SIGMOD RECORD, </title> <journal> Vol. </journal> <volume> 19, No. 4, </volume> <month> December, </month> <year> 1990. </year>
Reference-contexts: As updates are made to the database, no history of its past form are maintained. This is exactly the situation we have described in our example. We will choose to use the phrase snapshot database throughout this paper. A rollback database <ref> [12] </ref>, also referred to as a transaction time database [43] or a static rollback database [12], is an extension to a snapshot database. Instead of just being able to see a given relation in its present form, it can be viewed as it existed at any point in the past. <p> This is exactly the situation we have described in our example. We will choose to use the phrase snapshot database throughout this paper. A rollback database <ref> [12] </ref>, also referred to as a transaction time database [43] or a static rollback database [12], is an extension to a snapshot database. Instead of just being able to see a given relation in its present form, it can be viewed as it existed at any point in the past. A relation can be thought of as a cube, where the third dimension represents time. <p> A view of a relation at any point in time would then be a slice from this cube. Such a slice is usually referred to as a snapshot [34], but also called a timeslice [34] or a rollback <ref> [12] </ref>. The rollback database is the system that supports such structures. Note that since we are interested in determining what the database looked like at a given point in time, transaction time is the time representation which must be used. <p> We will choose to use the phrase rollback database throughout this paper. Apparently one of the first rollback databases was Egyptian grain histories <ref> [12] </ref>. A historical database [12], or a valid time database [34], is another extension to a snapshot 4 database, but with a different purpose than that of the transaction time database. The historical database is based on valid time instead of transaction time. <p> We will choose to use the phrase rollback database throughout this paper. Apparently one of the first rollback databases was Egyptian grain histories <ref> [12] </ref>. A historical database [12], or a valid time database [34], is another extension to a snapshot 4 database, but with a different purpose than that of the transaction time database. The historical database is based on valid time instead of transaction time. <p> We will choose to use the phrase historical database throughout this paper. An early example of a historical database is Homer's Iliad <ref> [12] </ref>. The term temporal database seems to take on two different meanings, depending on the author. Most works refer to a temporal database as one in which some aspect of time (other than user-defined) is implemented [34], [41]. <p> Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], <ref> [12] </ref>, [15], [44], [45], [46]. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on.
Reference: [13] <author> R. Maiocchi and B. Pernici, </author> <title> "Temporal Data Management Systems: A Comparative View", </title> <journal> IEEE Transaction on Knowledge and Data Engineering, </journal> <volume> Vol. 3, No. 4, </volume> <month> December, </month> <year> 1991. </year>
Reference-contexts: Finally, the arrows indicating "historical revision" show how a data value from January was updated during the month of June. There are a number of more specific time representation issues which can be addressed <ref> [13] </ref>. These notions are useful in distinguishing one temporal database implementation from another. * The primitive time entity reflects whether time is ultimately stored as a time point or a time interval. For our application, time is represented in point values. <p> Some temporal databases make this much more complicated; they may actually measure days, weeks, and months (for example) as different granulari ties. In designing a temporal database, one also needs to consider a number of time reasoning is sues <ref> [13] </ref>: * A designer should specify mechanisms for deriving additional information from the data stored in the database. We do not specify any such mechanisms for our warehouse, as they are not particularly relevant. Such mechanisms are mostly used for situations where incomplete temporal data is available. <p> It is clear that these mechanisms are vital for successful 6 functioning of the warehouse. Commercial DBMSs have been slow to integrate transaction and valid time into their systems. A number of good reasons have been suggested for this <ref> [13] </ref>, [14]. What does this mean for the recommendations we make in this paper? Any capable decision support system already contains the tools necessary to adapt the basics of our ideas. The optimizations may require some additional support; but the basic rollback capabilities we introduce can be implemented.
Reference: [14] <author> I. Ahn, </author> <title> "Towards An Implementation of Database Management Systems with Temporal Support", </title> <booktitle> Proceedings of the International Conference on Data Engineering, </booktitle> <month> February, </month> <year> 1986. </year>
Reference-contexts: It is clear that these mechanisms are vital for successful 6 functioning of the warehouse. Commercial DBMSs have been slow to integrate transaction and valid time into their systems. A number of good reasons have been suggested for this [13], <ref> [14] </ref>. What does this mean for the recommendations we make in this paper? Any capable decision support system already contains the tools necessary to adapt the basics of our ideas. The optimizations may require some additional support; but the basic rollback capabilities we introduce can be implemented.
Reference: [15] <author> G. Ariav, </author> <title> "A Temporally Oriented Data Model", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 11, No.4, </volume> <month> December </month> <year> 1986, </year> <pages> pp. 499-527. </pages>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], <ref> [15] </ref>, [44], [45], [46]. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on.
Reference: [16] <author> M.A. Bassiouni and M.J. Llewellyn, </author> <title> "A Relational-Calculus Query Language for Historical Databases", </title> <journal> Comput. Lang., Vol.17, </journal> <volume> No. 3, </volume> <pages> pp. 185-197, </pages> <year> 1992. </year>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time <ref> [16] </ref>, [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], [45], [46]. <p> Essentially, they incorporate into the query language all the capabilities one would wish to have when using a temporal database. Time related queries can actually become quite intricate <ref> [16] </ref>. For example, consider selecting employees who have taken long vacations and who have received health care benefits.
Reference: [17] <author> M.A. Nascimento and M.H. Eich, </author> <title> "An Introductory Survey to Indexing Techniques for Temporal Databases", </title> <type> Technical Report, </type> <institution> Southern Methodist University, </institution> <month> February, </month> <year> 1995. </year>
Reference-contexts: Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) <ref> [17] </ref>, [29], [30], [31], [33], [41]. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on.
Reference: [18] <author> N. Kline, </author> <title> "An Update of the Temporal Database Bibliography", </title> <institution> University of Arizona. </institution>
Reference: [19] <author> S. Abiteboul, L. Herr and Jan Van den Bussche, </author> <title> "Temporal versus First-Order Logic to Query Temporal Databases", </title> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], <ref> [19] </ref>, [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], [45], [46].
Reference: [20] <author> M. Staudt and M. Jarke, </author> <title> "Incremental Maintenance of Externally Materialized Views", </title> <booktitle> Proceedings of the 22-nd VLDB Conference Mum-bai, </booktitle> <address> India, </address> <year> 1996. </year>
Reference: [21] <author> Y. Zhuge, H. Garcia-Molina and J.L. Wiener, </author> <title> "The Strobe Algorithms for Multi-Source Warehouse Consistency", </title> <month> PDIS </month> <year> 1996. </year>
Reference: [22] <author> A. Segev and J. Park, </author> <title> "Updating Distributed Materialized Views", </title> <booktitle> IEEE 1989. </booktitle>
Reference: [23] <author> G. Bhargava and S.K. Gadia, </author> <title> "Relational Database Systems with Zero Information Loss", </title> <journal> IEEE Transaction on Knowledge and Data Engineering, </journal> <volume> Vol. 5, No. </volume> <month> 1 ,February </month> <year> 1993. </year>
Reference-contexts: Attribute versioning, on the other hand, allows a single field within a tuple to change over a period of time. Our solution takes on aspects of both ideas. Attribute versioning was seriously considered with the Zero Information Loss Model <ref> [23] </ref>, which proposes storing relations with attribute version-ing (referred to as the data history store.) In addition, a history of changes is kept in the update environment store. This store enables a user to query who made changes to a relation, and perhaps why.
Reference: [24] <author> A.U. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, R. Snodgrass, </author> <title> "Temporal Databases: Theory, Design, and Implementation", </title> <publisher> Benjamin/Cummings Publishing Co, INC, </publisher> <year> 1993. </year> <title> [25] "Temporal Aspects in Information Systems", </title> <publisher> Elsevier Science Publishers B.V., </publisher> <address> The Netherlands, </address> <year> 1987. </year>
Reference: [26] <author> H. Gunadhi and A. Segev, </author> <title> "A Framework for Query Optimization in Temporal Databses", </title> <booktitle> International Conference on Statistical and Scientific Database Management, </booktitle> <year> 1990. </year>
Reference-contexts: Our warehouse has a very strict sense of what time period has been captured, and the user is only permitted to access this data in a relatively small number of discrete snapshots. As such, access structures are not necessary. Query optimization in temporal databases is another area of concern <ref> [26] </ref>, [27], [28], [34], [40]. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." [39]. We will not consider these ideas here.
Reference: [27] <author> H. Gunadhi and A. Segev, </author> <title> "Query Processing Algorithms for Temporal Intersection Joins", </title> <booktitle> Proceedings of the International Conference on Data Engineerin, </booktitle> <year> 1991. </year>
Reference-contexts: As such, access structures are not necessary. Query optimization in temporal databases is another area of concern [26], <ref> [27] </ref>, [28], [34], [40]. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." [39]. We will not consider these ideas here.
Reference: [28] <author> T.Y. Cliff Leung and R.R. Muntz, </author> <title> "Query Processing for Temporal Databases", </title> <booktitle> Preceedings of the International Conference on Data Engineering, </booktitle> <year> 1990. </year>
Reference-contexts: As such, access structures are not necessary. Query optimization in temporal databases is another area of concern [26], [27], <ref> [28] </ref>, [34], [40]. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." [39]. We will not consider these ideas here.
Reference: [29] <author> R. Elmasri, G.T.J. Wuu and Y.J. Kim, </author> <title> "The Time Index: An Access Structure for Temporal Data", </title> <booktitle> Preceedings of the 16-th VLDB Conference, </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) [17], <ref> [29] </ref>, [30], [31], [33], [41]. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on.
Reference: [30] <author> D. Lomet and B. Salzberg, </author> <title> "Access Methods for Multiversion Data", </title> <booktitle> Proceedings of SIG-MOD Conference, </booktitle> <pages> pp. </pages> <month> 315-324 </month> <year> 1989. </year>
Reference-contexts: Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) [17], [29], <ref> [30] </ref>, [31], [33], [41]. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on.
Reference: [31] <author> D. Lomet and B. Salzberg, </author> <title> "The Performance of a Multiversion Access Method", </title> <month> SIG-MOD </month> <year> 1990. </year>
Reference-contexts: Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) [17], [29], [30], <ref> [31] </ref>, [33], [41]. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on.
Reference: [32] <author> P. McBrien, </author> <title> "Principles of Implementing Historical Databases in RDBMS", </title> <booktitle> Proceedings of the British National Conference on Databases, </booktitle> <pages> pp. 220-237, </pages> <year> 1993. </year> . 
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], <ref> [32] </ref>, [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], [45], [46].
Reference: [33] <author> T. Dean, </author> <title> "Using Temporal Hierarchies to Efficiently Maintain Large Temporal Databases", </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 36, No. 4, </volume> <month> October </month> <year> 1989, </year> <month> pp.687-718. </month>
Reference-contexts: Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) [17], [29], [30], [31], <ref> [33] </ref>, [41]. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on.
Reference: [34] <author> C.S. Jensen. L. Mark, N. Roussopou-los, and T. Sellis, </author> <title> "Using Differential Techniques to Efficiently Support Transaction Time", </title> <journal> VLDB Journal, </journal> <volume> 2, pp.75-111, </volume> <year> 1992. </year>
Reference-contexts: A relation can be thought of as a cube, where the third dimension represents time. A view of a relation at any point in time would then be a slice from this cube. Such a slice is usually referred to as a snapshot <ref> [34] </ref>, but also called a timeslice [34] or a rollback [12]. The rollback database is the system that supports such structures. Note that since we are interested in determining what the database looked like at a given point in time, transaction time is the time representation which must be used. <p> A relation can be thought of as a cube, where the third dimension represents time. A view of a relation at any point in time would then be a slice from this cube. Such a slice is usually referred to as a snapshot <ref> [34] </ref>, but also called a timeslice [34] or a rollback [12]. The rollback database is the system that supports such structures. Note that since we are interested in determining what the database looked like at a given point in time, transaction time is the time representation which must be used. <p> We will choose to use the phrase rollback database throughout this paper. Apparently one of the first rollback databases was Egyptian grain histories [12]. A historical database [12], or a valid time database <ref> [34] </ref>, is another extension to a snapshot 4 database, but with a different purpose than that of the transaction time database. The historical database is based on valid time instead of transaction time. <p> An early example of a historical database is Homer's Iliad [12]. The term temporal database seems to take on two different meanings, depending on the author. Most works refer to a temporal database as one in which some aspect of time (other than user-defined) is implemented <ref> [34] </ref>, [41]. Others are more specific and define a temporal database to be one which supports both valid time and transaction time [11]. Those in the first camp refer to these as bitemporal databases. <p> As such, access structures are not necessary. Query optimization in temporal databases is another area of concern [26], [27], [28], <ref> [34] </ref>, [40]. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." [39]. We will not consider these ideas here. One way of interpreting a snapshot is as a materialized view. <p> These snapshot algorithms are similar in spirit to many of the ideas we develop in this paper. A potential solution to our warehousing problem has been put forth by Jensen in his work on rollback databases <ref> [34] </ref>, [40]. We now discuss Jensen's solution in detail, and point out areas where our assumptions will lead us to a different model. <p> We then consider the implications of these differences on such issues as implementation and query optimization. 3 Contrast to Related Work A solution with many ideas applicable to our problem has been proposed with the temporal data model DM/T and its associated implementation model IM/T <ref> [34] </ref>. This approach is the paradigmatic example of using differential files in association with temporal databases [41]. We will first discuss the DM/T - IM/T solution in detail, insofar as it relates to our warehousing problem. <p> Note that we assume the number of pages in R (new) and R (old) to be approximately equal. The IM/T work suggests that an optimization can be made by only reading those pages in R (new) which correspond to keys in the differential files <ref> [34] </ref>. While it is true that those pages are the ones which change, all the other pages still need to be copied to create the relation R (old). This therefore only provides a minor CPU optimization, which is negligible in I/O costs calculations. <p> We do not consider this case here, as it deserves a full section of work in and of itself. 5.3.3 Materialized view of R (new) 1 S (new) present Here again we consider the case of how to rollback the results of a completed query. The IM/T work <ref> [34] </ref> demonstrates how this query can be evaluated. In order to incorporate our modification differential file, we will first describe the IM/T method in detail. We then follow with our modifications. The IM/T system does not allow differential modifications; everything is maintained as an insertion or a deletion.
Reference: [35] <author> A. Gupta, I.S. Mumick, and K.A. Ross, </author> <title> "Adapting Materialized Views after Redefinitions", </title> <booktitle> Proceedings of SIGMOD Conference, </booktitle> <pages> pp. 211-222, </pages> <year> 1995. </year>
Reference-contexts: This assumption differs from our assumption presented in the Introduction section of this paper. We are developing an algorithm for differentially updating a snapshot infrequently so for one update we will have many modifications. A. Gupta et al. in <ref> [35] </ref> analyze the process of updating the view definition in the context of dynamic queries, where the user can change queries dynamically and see the changes in the results fast. <p> The idea is to express the adaptation as queries on the base relations, and as updates to the old view. Thus they provide a smooth integration of such adaptation techniques into the framework of current relational database systems <ref> [35] </ref>. Our model also concerns itself with changing views, as fields may be added or removed from our views. Y. Zhuge et al. in [4] directed their research to solving the view maintenance problem for warehousing, where the view definition and the base data are decoupled (distributed).
Reference: [36] <author> S. Chaudhuri, R. Krishnamurthy, S. Potamianos, and K. Shim, </author> <title> "Optimizing Queries with Materialized Views", </title> <publisher> IEEE, </publisher> <year> 1995. </year>
Reference-contexts: Their idea, however, is interesting to us from another perspective: they have considered in detail the idea of recording changes to one relation for purposes of updating another relation at a later time. Query optimization in a materialized view environment is thoroughly considered by S. Chaud-huri et al. in <ref> [36] </ref>. The authors developed a rule-based mechanism to optimize queries. Sometimes it is more cost efficient to go to the base relations than to use the view. J. Yang et al. look at optimizing queries on materialized views in a distributed data warehouse Multiple View Processing Plan [37].
Reference: [37] <author> J. Yang, K. Karlapalem, and Q. Li, </author> <title> "A Framework for Designing Materialized Views in Data Warehousing Environment", </title> <publisher> IEEE, </publisher> <year> 1997. </year>
Reference-contexts: The authors developed a rule-based mechanism to optimize queries. Sometimes it is more cost efficient to go to the base relations than to use the view. J. Yang et al. look at optimizing queries on materialized views in a distributed data warehouse Multiple View Processing Plan <ref> [37] </ref>. Their approach considers which nodes of a global query access plan should be materialized so that both query and view maintenance costs are minimal. 2.3 Snapshot Databases We have already considered the idea of snapshots in the context of temporal databases.
Reference: [38] <author> D. Gabbay and P. McBrien, </author> <title> "Temporal Logic and Historical Databases", </title> <booktitle> Proceedings of the 17-th International Conference on VLDB, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], <ref> [38] </ref>. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], [45], [46].
Reference: [39] <author> J.M.V. de Castilho, M.A. Casanova, and A.L. Furtado, </author> <title> "A Temporal Framework for Database Specifications", </title> <booktitle> Preceedings of the 8-th International Conference on VLDB, </booktitle> <address> Mexico City, </address> <month> September, </month> <pages> pp. 280-291, </pages> <year> 1982. </year>
Reference-contexts: Query optimization in temporal databases is another area of concern [26], [27], [28], [34], [40]. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." <ref> [39] </ref>. We will not consider these ideas here. One way of interpreting a snapshot is as a materialized view.
Reference: [40] <author> C.S. Jensen, L. Mark, and N. Roussopou-los, </author> <title> "Incremental Implementation Model for Relational Databases with Transaction Time", </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> Vol. 3, No. 4, </volume> <month> December, </month> <year> 1991. </year>
Reference-contexts: As such, access structures are not necessary. Query optimization in temporal databases is another area of concern [26], [27], [28], [34], <ref> [40] </ref>. We will consider this issue somewhat on presentation of our method. Other work has looked at how to impose constraints on a temporal database, e.g. "salaries must never decrease." [39]. We will not consider these ideas here. One way of interpreting a snapshot is as a materialized view. <p> These snapshot algorithms are similar in spirit to many of the ideas we develop in this paper. A potential solution to our warehousing problem has been put forth by Jensen in his work on rollback databases [34], <ref> [40] </ref>. We now discuss Jensen's solution in detail, and point out areas where our assumptions will lead us to a different model.
Reference: [41] <author> B. Salzberg and V.J. Tsotras, </author> <title> "A Com-parision of Access Methods for Temporal Data", </title> <type> TimeCenter Technical Report, </type> <month> June, </month> <year> 1997. </year>
Reference-contexts: An early example of a historical database is Homer's Iliad [12]. The term temporal database seems to take on two different meanings, depending on the author. Most works refer to a temporal database as one in which some aspect of time (other than user-defined) is implemented [34], <ref> [41] </ref>. Others are more specific and define a temporal database to be one which supports both valid time and transaction time [11]. Those in the first camp refer to these as bitemporal databases. <p> Many researchers have considered the question of what kinds of access structures can be utilized to make temporal database information retrieval more efficient (e.g. indices, trees, etc.) [17], [29], [30], [31], [33], <ref> [41] </ref>. These ideas are significantly important for temporal databases that contain time-intervals, tuples in the same relation for varying times, and so on. <p> This approach is the paradigmatic example of using differential files in association with temporal databases <ref> [41] </ref>. We will first discuss the DM/T - IM/T solution in detail, insofar as it relates to our warehousing problem.
Reference: [42] <author> C.S. Jensen, J. Clifford, R. Elmasri, S.K. Gadia, P. Hayes, and S. Jajodia: </author> <title> "A Consensus Glossary of Temporal Database Concepts", </title> <booktitle> SIG-MOD Record 23(1), </booktitle> <pages> pp. 52-64, </pages> <year> 1994. </year>
Reference-contexts: There has been much research into the question of how to represent time information in databases. Unfortunately, the nomenclature gets quite confusing. Snodgrass and Ahn's work [10] in 1986 introduced much of the terminology used today. However, some terms "stuck" better than others, leading to some confusion. Jensen <ref> [42] </ref> has published more current glossaries, and maintains a web page [43] containing terminology that might be considered more precise. However, the literature has not entirely embraced Jensen's terminology. Therefore, we present alternative phrasings in our definitions below, then specify which terminology we choose to use.
Reference: [43] <author> C.S. Jensen. </author> <title> "A Consensus Glossary of Temporal Database Concepts", URL "//http://www.cs.auc.dk/~csj/Glossary", World Wide Web. </title>
Reference-contexts: Unfortunately, the nomenclature gets quite confusing. Snodgrass and Ahn's work [10] in 1986 introduced much of the terminology used today. However, some terms "stuck" better than others, leading to some confusion. Jensen [42] has published more current glossaries, and maintains a web page <ref> [43] </ref> containing terminology that might be considered more precise. However, the literature has not entirely embraced Jensen's terminology. Therefore, we present alternative phrasings in our definitions below, then specify which terminology we choose to use. <p> Its importance here is only in that it can generate confusion, and should be ignored for our discussion. A snapshot database [11], <ref> [43] </ref>, also referred to as a static database [11] is one in which each relation represents only the most current point in time. As updates are made to the database, no history of its past form are maintained. This is exactly the situation we have described in our example. <p> This is exactly the situation we have described in our example. We will choose to use the phrase snapshot database throughout this paper. A rollback database [12], also referred to as a transaction time database <ref> [43] </ref> or a static rollback database [12], is an extension to a snapshot database. Instead of just being able to see a given relation in its present form, it can be viewed as it existed at any point in the past.
Reference: [44] <author> S.B. Navathe and R. Ahmed, "TSQL: </author> <title> A Language Interface for History Databases", in "Temporal Aspects in Information Systems", </title> <publisher> El-sevier Science Publishers B.V., </publisher> <address> The Netherlands, </address> <year> 1987. </year>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], <ref> [44] </ref>, [45], [46]. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on.
Reference: [45] <author> R. Snodgrass, </author> <title> "An Overview of TQuel", in "Temporal Aspects in Information Systems", </title> <publisher> El-sevier Science Publishers B.V., </publisher> <address> The Netherlands, </address> <year> 1987. </year>
Reference-contexts: Considerable research has been done in developing temporal query languages. Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], <ref> [45] </ref>, [46]. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on.
Reference: [46] <author> N.L. Sarda, "HSQL: </author> <title> A Historical Query Language", in "Temporal Aspects in Information Systems", </title> <publisher> Elsevier Science Publishers B.V., </publisher> <address> The Netherlands, </address> <year> 1987. </year>
Reference-contexts: Much theoretical work has considered the viability of extending query languages to deal with time [16], [19], [32], [38]. Other works have actually developed exten sions to SQL or Quel to handle the time dimension [10], [12], [15], [44], [45], <ref> [46] </ref>. Much of the added functionality allows users to query over a range of time, make historical revisions, rollback the database to a certain point in time, and so on. Essentially, they incorporate into the query language all the capabilities one would wish to have when using a temporal database.
Reference: [47] <author> N. Roussopoulos, </author> <title> "An Incremental Access Method for ViewCache: Concept, Algorithms, and Cost Analysis." </title> <journal> TODS 16(3), </journal> <pages> pp. 535-563, </pages> <year> 1991. </year>
Reference-contexts: As rollbacks of relations are formed, it may be efficient to maintain views of these rollback relations for further querying later. These views can be represented as either materialized views, or as pointers which refer back to base relations. The pointer approach is addressed extensively within the ViewCache method <ref> [47] </ref>. When a user poses a query, how is the cache utilized? An index to all cached views, referred to as the Extended Logical Access Path (ELAP) is maintained. The ELAP finds the cached query which is "closest" to the query which the user wants. <p> We then make an exception to our prior assumption of sort-merge-join, and consider a join methodology that can take advantage of these indices. The IM/T papers refer to the ViewCache system for algorithmic detail <ref> [47] </ref>, where precisely these assumptions are made. How do we make this IM/T method work for our system? Rather than develop more complicated methods with questionable payoff, we re build our differential files to look like the IM/T differential files.
References-found: 46

