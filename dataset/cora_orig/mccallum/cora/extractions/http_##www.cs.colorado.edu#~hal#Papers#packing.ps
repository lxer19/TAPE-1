URL: http://www.cs.colorado.edu/~hal/Papers/packing.ps
Refering-URL: http://www.cs.colorado.edu/~hal/Home.html
Root-URL: http://www.cs.colorado.edu
Title: Packing Algorithms for Arborescences (and Spanning Trees) in Capacitated Graphs  
Author: Harold N. Gabow* and K.S. Manu* 
Address: Boulder, Boulder, CO 80309  
Affiliation: Department of Computer Science, University of Colorado at  
Abstract: In a digraph with real-valued edge capacities, we pack the greatest number of arborescences in time O(n 3 m log (n 2 =m)); the packing uses at most m distinct arborescences. Here n and m denote the number of vertices and edges in the given graph, respectively. Similar results hold for integral packing: we pack the greatest number of arborescences in time O(minfn; log N gn 2 m log (n 2 =m)) using at most m + n 2 distinct arborescences; here N denotes the largest (integral) capacity of an edge. These results improve the best previous bounds for capacitated digraphs. The algorithm extends to several related problems, including packing spanning trees in an undirected capacitated graph, and covering such graphs by forests. The algorithm provides a new proof of Edmonds' theorem for arborescence packing, for both integral and real capacities, based on a laminar family of sets derived from the packing. Keywords: packing, covering, arborescences, spanning trees, laminar family, Newton's method.
Abstract-found: 1
Intro-found: 1
Reference: [B] <author> F. Barahona: </author> <title> Packing spanning trees. </title> <institution> Mathematics of Operations Research 20,1, </institution> <year> 1995, </year> <pages> pp. 104-115 </pages>
Reference-contexts: The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations. We improve this by the same factor as given above for Pevzner's algorithm. Barahona <ref> [B] </ref> gives an algorithm for packing in capacitated graphs, running in the time for O (n 2 ) network flow computations.
Reference: [E65] <author> J. Edmonds: </author> <title> Minimum partition of a matroid into independent subsets. </title> <journal> Journal of Research of the National Bureau of Standards 69B, </journal> <year> 1965, </year> <pages> pp. 67-72 </pages>
Reference-contexts: Minimax formulas for root-constrained packing are given in [F78, Mao]. The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property <ref> [E65] </ref>. Efficient algorithms are given in [G95b, GW, I, RT] for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows.
Reference: [E72] <author> J. Edmonds: Edge-disjoint branchings. </author> <title> In: Combinatorial Algorithms, </title> <editor> R. Rustin, Ed., </editor> <publisher> Algorithmics Press, </publisher> <address> New York, </address> <year> 1972, </year> <pages> pp. 91-96 </pages>
Reference-contexts: A bound involving N assumes that all given capacities are integers (between 0 and N ) and so is a weak-polynomial bound. The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing <ref> [E72] </ref> (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in [F79, G95a, L, Mad, TL]. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. <p> The two algorithms provide independent proofs of the real and integral cases of Edmonds' theorem respectively <ref> [E72] </ref>. The proof differs from previous ones in that it is based on maintaining a laminar family of sets. Our fractional packing algorithm runs in time O (n 3 m log (n 2 =m)). <p> Let (G) denote the minimum in-degree of an a-set, i.e., (G) = minf G (X) : ; 6= X V ag. Edmonds' Arborescence Packing Theorem states that in any digraph with integral capacities, a maximum integral packing A has total multiplicity (G) <ref> [E72] </ref>. (When we write (G) the choice of root vertex a will be clear from context. Usually the root is named a.) 2 Greedy Fractional Packing This section discusses the greedy approach to fractional packing. <p> Since f enters Z we can map e to f . It is clear that e is the only edge that gets mapped to f . ut The theorem gives an independent proof of the real-valued case of Edmonds' Arborescence Packing Theorem <ref> [E72] </ref>: Any digraph with real capacities has a fractional packing of a-arborescences of total multiplicity (G). 8 The theorem also implies our claim for the greedy algorithm, i.e., it finds a maximum packing, and this packing contains at most m distinct arborescences A. <p> Since Y 2 F this implies GA (Y ) = 1 by (4). Now Lemma 4.1 gives the desired equation.) The last two properties of Y " U contradict the minimality of U . ut The theorem gives an independent proof of Edmonds' Arborescence Packing Theorem <ref> [E72] </ref>, i.e., any digraph with integral capacities has a packing of (G) a-arborescences.
Reference: [F78] <author> A. Frank: </author> <title> On disjoint trees and arborescences. In: Algebraic Methods in Graph Theory, </title> <editor> L. Lovasz and V.T. Sos, Eds., </editor> <title> Colloquia Mathematica Societatis Janos Bolyai 18, </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1978, </year> <pages> pp. 159-169 </pages>
Reference-contexts: The second is finding a maximum root-constrained packing of arborescences. In this problem lower and upper bounds are given for the number of times each vertex can be the root of a spanning arborescence. Minimax formulas for root-constrained packing are given in <ref> [F78, Mao] </ref>. The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. <p> It is then a simple matter to find the desired root-constrained packing using our a-arborescence packing algorithm. Our algorithm is based on minimax formulas due to Frank <ref> [F78] </ref> (which treats the case of upper bounds only) and Mao-Cheng [Mao] (which treats the case of lower bounds only). In fact our algorithm is similar to the proof of [F78]. <p> Our algorithm is based on minimax formulas due to Frank <ref> [F78] </ref> (which treats the case of upper bounds only) and Mao-Cheng [Mao] (which treats the case of lower bounds only). In fact our algorithm is similar to the proof of [F78].
Reference: [F79] <author> A. Frank: </author> <title> Kernel systems of directed graphs. </title> <journal> Acta Scientiarum Mathematicarum (Szeged) 41, </journal> <year> 1979, </year> <pages> pp. 63-76 </pages>
Reference-contexts: The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in <ref> [F79, G95a, L, Mad, TL] </ref>. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a].
Reference: [FT] <author> A. Frank, E. Tardos: </author> <title> Generalized polymatroids and submodular flows. </title> <journal> Mathematical Programming, </journal> <volume> 42, </volume> <year> 1988, </year> <pages> pp. 489-563 </pages>
Reference-contexts: Our algorithm is based on minimax formulas due to Frank [F78] (which treats the case of upper bounds only) and Mao-Cheng [Mao] (which treats the case of lower bounds only). In fact our algorithm is similar to the proof of [F78]. Frank and Tardos <ref> [FT] </ref> showed that these two minimax formulas can be combined to give the following theorem: A digraph has k edge-disjoint spanning arborescences such that `(v) r (v) u (v) for every vertex v if and only if these two conditions hold: G (S) + u (S) k for every nonempty set
Reference: [G95a] <author> H.N. Gabow: </author> <title> A matroid approach to finding edge connectivity and packing arborescences. </title> <journal> Journal of Computer and System Sciences 50, </journal> <volume> 2, </volume> <year> 1995, </year> <pages> pp. 259-273 </pages>
Reference-contexts: The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in <ref> [F79, G95a, L, Mad, TL] </ref>. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. <p> Other proofs are in [F79, G95a, L, Mad, TL]. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) <ref> [G95a] </ref>. Algorithms for packing arborescences in capacitated graphs are given in [GLS, Mad]. The most efficient algorithm for capacitated graphs is due to Pevzner, using the time for O (n 3 ) maximum flow computations. This paper presents two related algorithms for packing arborescences in capacitated graphs. <p> Procedure one-by-one pack can be efficiently implemented on a graph where all edges have unit capacity (parallel edges are allowed): We use the matroid techniques of <ref> [G95a] </ref> to check condition (3) and to find the set U when (3) fails. This implementation of one-by-one pack achieves the same asymptotic time bound as the packing algorithm of [G95a]: if G has kn edges and (G) = k, it finds a packing of k arborescences in time O ((kn) <p> implemented on a graph where all edges have unit capacity (parallel edges are allowed): We use the matroid techniques of <ref> [G95a] </ref> to check condition (3) and to find the set U when (3) fails. This implementation of one-by-one pack achieves the same asymptotic time bound as the packing algorithm of [G95a]: if G has kn edges and (G) = k, it finds a packing of k arborescences in time O ((kn) 2 ). In practice one-by-one pack may be faster than 14 [G95a], since it may be easier to maintain F than to do the graph contraction operations needed in the <p> This implementation of one-by-one pack achieves the same asymptotic time bound as the packing algorithm of <ref> [G95a] </ref>: if G has kn edges and (G) = k, it finds a packing of k arborescences in time O ((kn) 2 ). In practice one-by-one pack may be faster than 14 [G95a], since it may be easier to maintain F than to do the graph contraction operations needed in the packing algorithm of [G95a]. <p> In practice one-by-one pack may be faster than 14 <ref> [G95a] </ref>, since it may be easier to maintain F than to do the graph contraction operations needed in the packing algorithm of [G95a]. We conclude this section by presenting the more efficient version of procedure grow that we use in the algorithms of this paper (mainly the integral packing algorithm integral pack of Section 5). The idea is to gain efficiency by not checking condition (3) for every edge e.
Reference: [G95b] <author> H.N. Gabow: </author> <title> Algorithms for graphic polymatroids and parametric s-sets. </title> <booktitle> Proceedings of the 6th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1995, </year> <pages> pp. </pages> <note> 88-97; Journal of Algorithms, to appear. </note>
Reference-contexts: The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in <ref> [G95b, GW, I, RT] </ref> for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations. <p> Also we improve the number of distinct spanning trees from O (n 2 ) to O (m). Our algorithms for undirected problems are based on the reduction in <ref> [G95b] </ref> of undirected packing and covering to the directed case. The paper is organized as follows. Section 2 discusses the greedy algorithm for fractional arborescence packing. It proves the fractional case of Edmonds' Arborescence Packing Theorem. <p> Thus some set S 23 has either entered or left T . Each S 2 F enters or leaves T at most once. Since jF j = O (n) (by laminarity) this occurs O (n) times. ut Our efficient implementation of find roots uses the parametric s-set algorithm of <ref> [G95b] </ref>. This algorithm is also used in Section 7. We now summarize the parametric s-set problem, the algorithm of [G95b] that solves it, and all properties of this algorithm that are needed in Sections 6 and 7. We use graphs that have a parametrized capacity function. <p> Since jF j = O (n) (by laminarity) this occurs O (n) times. ut Our efficient implementation of find roots uses the parametric s-set algorithm of <ref> [G95b] </ref>. This algorithm is also used in Section 7. We now summarize the parametric s-set problem, the algorithm of [G95b] that solves it, and all properties of this algorithm that are needed in Sections 6 and 7. We use graphs that have a parametrized capacity function. <p> Given p and an edge e we can compute c p (e) in O (1) time. In all other respects the capacities can take on arbitrary nonnegative real values. Under these assumptions the algorithm of <ref> [G95b] </ref> solves the parametric s-set problem in time O (nm log (n 2 =m)) and space O (m). The overall organization of the algorithm is to increase the parameter p, starting at p = d and stopping when p reaches its desired value. <p> For integral packing the time is the same as Corollary 5.1, using at most m + 2n 3 distinct arborescences. Proof. First consider the efficiency of find roots. Each execution of the parametric s-set algorithm uses time O (nm log (n 2 =m) <ref> [G95b] </ref> and enlarges the family F. Since jFj = O (n) (Lemma 6.2) the parametric s-set algorithm is executed O (n) times, as desired. The remaining time amounts to O (1) executions of the Hao-Orlin algorithm per iteration of find roots. There are O (n) iterations (Lemma 6.2). <p> We also discuss the problem of covering the edges by forests. The forest cover number and a minimum forest cover are defined analogously. We consider the fractional and integral versions of the packing and covering problems. Our approach is based on a reduction presented in <ref> [G95b] </ref>. We summarize the resulting procedure here and refer the reader to that paper for more details of the reduction. The main step of the reduction is as follows. <p> The main step of the reduction is as follows. Consider a graph H having a capacity function, that can be partitioned into k forests. (For fractional packing and covering introduce multiplicities in the obvious way.) <ref> [G95b] </ref> shows how to construct a digraph D from H for which a maximum packing of a-arborescences has total multiplicity k, and furthermore such a packing is easily converted to a partition of H into k forests. (We sketch the construction below.) Our covering algorithm works as follows. <p> First calculate the (integral or fractional) forest cover number k, using the algorithm given in <ref> [G95b] </ref> for this task. Form the corresponding digraph D (using the graph G and the value k). Use the algorithm of Section 2 or 5 to find a maximum packing of a-arborescences in D. Finally convert this packing to the desired minimum forest cover. Our packing algorithm works as follows. <p> Finally convert this packing to the desired minimum forest cover. Our packing algorithm works as follows. As before start by calculating the (integral or fractional) spanning tree packing number k, using the algorithm of <ref> [G95b] </ref>. The next step is to find a subgraph H of G that is the union of k disjoint spanning trees, i.e., we wish to calculate the capacities of the edges of G in a maximum spanning tree packing. <p> A base b of the graphic polymatroid P (kr) (where r denotes the graphic matroid rank function, see <ref> [G95b] </ref> for definitions) gives these 28 capacities, i.e., b (e) is the desired capacity of edge e of G. Use the algorithm of [G95b] to find a base of P (kr). <p> A base b of the graphic polymatroid P (kr) (where r denotes the graphic matroid rank function, see <ref> [G95b] </ref> for definitions) gives these 28 capacities, i.e., b (e) is the desired capacity of edge e of G. Use the algorithm of [G95b] to find a base of P (kr). Now proceed as in our covering algorithm, using these capacities to form D, finding a maximum packing of a-arborescences, and converting it to a maximum spanning tree packing. We next sketch how the digraph D is constructed from H. <p> We next sketch how the digraph D is constructed from H. We give enough detail to calculate the size of D. D is called the k-equivalent graph in <ref> [G95b] </ref>. To form D replace each edge vw of H by directed edges vw and wv, and add a new vertex a plus an edge av for every v 2 V . <p> The capacity function on D is derived from a maximum flow computation (on another graph, called G fl in <ref> [G95b] </ref>). Corollary 3.1 of [G95b] proves that in D, a maximum packing of a-arborescences has total multiplicity k; furthermore deleting a from these arborescences and ignoring edge directions gives the set of k forests that partition the edges of H. We make two remarks on this construction. <p> The capacity function on D is derived from a maximum flow computation (on another graph, called G fl in <ref> [G95b] </ref>). Corollary 3.1 of [G95b] proves that in D, a maximum packing of a-arborescences has total multiplicity k; furthermore deleting a from these arborescences and ignoring edge directions gives the set of k forests that partition the edges of H. We make two remarks on this construction. <p> We make two remarks on this construction. First for integral covering and packing on G, D has integral capacities, and we use an integral arborescence packing on D. Second, the algorithms of <ref> [G95b] </ref> used in our covering algorithm take time O (nm log (n 2 =m)), and those used in our packing algorithm take time O (n 2 m log (n 2 =m)). Theorem 7.2. Consider a capacitated undirected graph. <p> Now apply Theorems 2.1, 5.1 and their Corollaries. Note there are at most 2m + n (2m + 2n 1) distinct forests or spanning trees in our fractional (integral) cover or packing. Note also that the time for the algorithms of <ref> [G95b] </ref> is dominated by the time bounds of the theorem. ut The bounds on number of distinct forests and trees can be reduced to m + O (n). <p> This results from the fact that the capacity function on D is derived from a maximum flow computation, and we can choose the maximum flow to limit the number of edges in D. The details depend on the exact definition of D; see <ref> [G95b] </ref>. We also note that when the given undirected graph has an edge cost function, a maximum spanning tree packing having smallest possible cost can be found in the bounds of Theorem 7.2. 29 This holds because the algorithm of [G95b] finds the subgraph H consisting of the edges in the <p> The details depend on the exact definition of D; see <ref> [G95b] </ref>. We also note that when the given undirected graph has an edge cost function, a maximum spanning tree packing having smallest possible cost can be found in the bounds of Theorem 7.2. 29 This holds because the algorithm of [G95b] finds the subgraph H consisting of the edges in the desired packing, in the same time bound. Acknowledgments The first author wishes to pay tribute to Gene Lawler, who provided help and inspiration for many years.
Reference: [GLS] <author> M. Grotschel, L. Lovasz, A. Schrijver: </author> <title> Geometric Algorithms and Combinatorial Optimization, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988 </year>
Reference-contexts: Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. Algorithms for packing arborescences in capacitated graphs are given in <ref> [GLS, Mad] </ref>. The most efficient algorithm for capacitated graphs is due to Pevzner, using the time for O (n 3 ) maximum flow computations. This paper presents two related algorithms for packing arborescences in capacitated graphs. The first finds a maximum packing in a digraph with arbitrary real-valued capacities. <p> They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in [G95b, GW, I, RT] for (unit capacity) graphs and <ref> [GLS, PW] </ref> for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations. We improve this by the same factor as given above for Pevzner's algorithm.
Reference: [GW] <author> H.N. Gabow, H.H. Westermann: </author> <title> Forests, frames and games: Algorithms for matroid sums and applications. </title> <type> Algorithmica 7, </type> <year> 1992, </year> <pages> pp. 465-497 </pages>
Reference-contexts: The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in <ref> [G95b, GW, I, RT] </ref> for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations.
Reference: [HO] <author> J. Hao, J.B. Orlin: </author> <title> A faster algorithm for finding the minimum cut in a directed graph. </title> <journal> Journal of Algorithms 17, </journal> <volume> 3, </volume> <year> 1994, </year> <pages> pp. 424-446 </pages>
Reference-contexts: If ff (A) = G (A) the time is O (nm log (n 2 =m)). Proof. We check the termination condition of the loop and find the set U using the global minimum cut algorithm of Hao and Orlin <ref> [HO] </ref>. This gives time O (nm log (n 2 =m)) for one iteration. As shown above there are at most jAj = n 1 iterations. This implies the first time bound. If ff (A) = (A) there is only one iteration. <p> We now give the implementation details of fast grow, and show that the total time for all calls to fast grow from integral pack is O (n 2 m log (n 2 =m) log n): We check that A satisfies (3) using the minimum cut algorithm of Hao and Orlin <ref> [HO] </ref>. This uses time O (nm log (n 2 =m)). If (3) fails we find the desired edge e using a binary search. The search maintains an interval of edges that were added consecutively to A and contains e. <p> Since jAj n the time to construct A (in the repeat loop) is O (nm). We now consider two cases depending on whether or not A is valid. Consider the iterations that have A valid. Validity is checked using the Hao-Orlin minimum cut algorithm <ref> [HO] </ref>. Thus the time for such an iteration is O (nm log (n 2 =m)). Hence it suffices to show there are n such iterations.
Reference: [I] <author> H. Imai: </author> <title> Network-flow algorithms for lower-truncated transversal polymatroids. </title> <journal> Journal of the Operations Research Society of Japan 26, </journal> <volume> 3, </volume> <year> 1983, </year> <pages> pp. 186-210 </pages>
Reference-contexts: The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in <ref> [G95b, GW, I, RT] </ref> for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations.
Reference: [KRT] <author> V. King, S. Rao, R. Tarjan: </author> <title> A faster deterministic maximum flow algorithm. </title> <journal> Journal of Algorithms 17, </journal> <volume> 3, </volume> <year> 1994, </year> <pages> pp. 447-474 </pages>
Reference-contexts: Our integral packing algorithm has a slightly better time bound, O (minfn; log N gn 2 m log (n 2 =m)). This improves [P] by a factor maxf1; n= log N gn= log (n 2 =m). (Here we assume the algorithm of <ref> [KRT] </ref> is used to compute a maximum flow in [P] and runs in time O (nm). This is true if m = (n 1+* ) for some positive constant *.
Reference: [L] <author> L. Lovasz: </author> <title> On two minimax theorems in graph theory. </title> <journal> Journal of Combinatorial Theory, B, </journal> <volume> 21, </volume> <year> 1976, </year> <pages> pp. 96-103 </pages>
Reference-contexts: The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in <ref> [F79, G95a, L, Mad, TL] </ref>. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a].
Reference: [Mad] <author> W. Mader: </author> <note> On n-edge-connected digraphs. Annals of Discrete Mathematics 17, </note> <year> 1983, </year> <pages> pp. 439-441 </pages>
Reference-contexts: The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in <ref> [F79, G95a, L, Mad, TL] </ref>. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. <p> Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. Algorithms for packing arborescences in capacitated graphs are given in <ref> [GLS, Mad] </ref>. The most efficient algorithm for capacitated graphs is due to Pevzner, using the time for O (n 3 ) maximum flow computations. This paper presents two related algorithms for packing arborescences in capacitated graphs. The first finds a maximum packing in a digraph with arbitrary real-valued capacities. <p> The algorithm of [P] uses O (nm) distinct arborescences. (We note that Mader's approach to packing by splitting off edges <ref> [Mad] </ref> can be implemented efficiently using the ideas of this paper. However the best bound on the number of distinct arborescences that we can prove for this approach is O (n 2 ).) We present four applications of the packing algorithms.
Reference: [Mao] <author> C. Mao-cheng: </author> <title> Arc-disjoint arborescences of digraphs. </title> <journal> Journal of Graph Theory 7, </journal> <year> 1983, </year> <pages> pp. 235-240 </pages>
Reference-contexts: The second is finding a maximum root-constrained packing of arborescences. In this problem lower and upper bounds are given for the number of times each vertex can be the root of a spanning arborescence. Minimax formulas for root-constrained packing are given in <ref> [F78, Mao] </ref>. The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. <p> It is then a simple matter to find the desired root-constrained packing using our a-arborescence packing algorithm. Our algorithm is based on minimax formulas due to Frank [F78] (which treats the case of upper bounds only) and Mao-Cheng <ref> [Mao] </ref> (which treats the case of lower bounds only). In fact our algorithm is similar to the proof of [F78].
Reference: [P] <author> P.A. Pevzner: </author> <title> Branching packing in weighted graphs. </title> <journal> American Mathematical Society Translations 158, </journal> <volume> 2, </volume> <year> 1994, </year> <pages> pp. 185-200 </pages>
Reference-contexts: Our fractional packing algorithm runs in time O (n 3 m log (n 2 =m)). Our integral packing algorithm has a slightly better time bound, O (minfn; log N gn 2 m log (n 2 =m)). This improves <ref> [P] </ref> by a factor maxf1; n= log N gn= log (n 2 =m). (Here we assume the algorithm of [KRT] is used to compute a maximum flow in [P] and runs in time O (nm). This is true if m = (n 1+* ) for some positive constant *. <p> This improves <ref> [P] </ref> by a factor maxf1; n= log N gn= log (n 2 =m). (Here we assume the algorithm of [KRT] is used to compute a maximum flow in [P] and runs in time O (nm). This is true if m = (n 1+* ) for some positive constant *. <p> The algorithm of <ref> [P] </ref> uses O (nm) distinct arborescences. (We note that Mader's approach to packing by splitting off edges [Mad] can be implemented efficiently using the ideas of this paper.
Reference: [PW] <author> M.W. Padberg, L.A. Wolsey: </author> <title> Fractional covers for forests and matchings. </title> <booktitle> Mathematical Programming 29, </booktitle> <year> 1984, </year> <pages> pp. 1-14 </pages>
Reference-contexts: The first finds a maximum packing in a digraph with arbitrary real-valued capacities. We call this a fractional packing a given arborescence can be used ff times, for any nonnegative real value ff. (This type of packing is needed for the problems of <ref> [PW] </ref>, see below.) The second algorithm finds a maximum integral packing in a digraph with integral capacities. The two algorithms provide independent proofs of the real and integral cases of Edmonds' theorem respectively [E72]. <p> They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in [G95b, GW, I, RT] for (unit capacity) graphs and <ref> [GLS, PW] </ref> for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations. We improve this by the same factor as given above for Pevzner's algorithm.
Reference: [R] <author> T. Radzik: </author> <title> Newton's method for fractional combinatorial optimization. </title> <booktitle> Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> pp. 659-669 </pages>
Reference-contexts: We will not use this fact but we summarize the proof: We need only show there are O ( log (nN )) iterations. But this bound holds for any implementation of the Newton-Dinkelbach method for finding the minimum of a function u (x)=v (x) <ref> [R] </ref>. It is straightforward to check that our algorithm is an implementation of this method. A similar (slightly better) time bound can be achieved by binary search. By definition bff (A)c is the largest integer value ff G (A) having (G ffA) = (G) ff.
Reference: [RT] <author> J. Roskind, R.E. Tarjan: </author> <title> A note on finding minimum-cost edge-disjoint spanning trees. </title> <journal> Mathematics of Operations Research 10, </journal> <volume> 4, </volume> <year> 1985, </year> <pages> pp. 701-708 </pages>
Reference-contexts: The two other applications are for capacitated undirected graphs. They are finding a maximum packing of spanning trees, and finding a minimum covering by forests. Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in <ref> [G95b, GW, I, RT] </ref> for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows. Trubin [Tru91] gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations.
Reference: [S] <author> Y. Shiloach: </author> <title> Edge-disjoint branchings in directed multigraphs. </title> <journal> Information Processing Letters 8, </journal> <volume> 2, </volume> <year> 1979, </year> <pages> pp. 24-27 </pages>
Reference-contexts: Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in [F79, G95a, L, Mad, TL]. Algorithms for packing arborescences in (unit capacity) graphs are presented in <ref> [Ta, S, TL] </ref>. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. Algorithms for packing arborescences in capacitated graphs are given in [GLS, Mad].
Reference: [Ta] <author> R.E. Tarjan: </author> <title> A good algorithm for edge-disjoint branching. </title> <journal> Information Processing Letters 3, </journal> <volume> 2, </volume> <year> 1974, </year> <pages> pp. 51-53 </pages>
Reference-contexts: Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in [F79, G95a, L, Mad, TL]. Algorithms for packing arborescences in (unit capacity) graphs are presented in <ref> [Ta, S, TL] </ref>. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. Algorithms for packing arborescences in capacitated graphs are given in [GLS, Mad].
Reference: [Tro] <author> L.E. Trotter, Jr.: </author> <title> Discrete packing and covering. In: Combinatorial Optimization: Annotated Bibliographies, </title> <editor> M. O'hEigeartaigh, J.K. Lenstra and A.H.G. Rinnooy Kan, Eds., </editor> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1985, </year> <pages> pp. 21-31 </pages>
Reference-contexts: 1 Introduction Packing arborescences and spanning trees are among the most basic packing problems. They probably provide the best-known examples of the so-called strong integrality and integer rounding properties of packing, respectively <ref> [Tro] </ref>. (Suppose a packing problem, or more generally a linear program, is specified by integral data. Strong integrality guarantees the problem has an integral optimum solution.
Reference: [Tru91] <author> V.A. Trubin: </author> <title> Strength and reinforcement of a network and tree packing. </title> <type> Kibernetika 2, </type> <year> 1991, </year> <pages> pp. 67-75 </pages>
Reference-contexts: Edmonds gave the first polynomial-time algorithms for these problems, establishing the integer rounding property [E65]. Efficient algorithms are given in [G95b, GW, I, RT] for (unit capacity) graphs and [GLS, PW] for capacitated graphs. The most efficient algorithms are as follows. Trubin <ref> [Tru91] </ref> gives algorithms for both packing and covering in capacitated graphs, running in the time for O (n 3 ) network flow computations. We improve this by the same factor as given above for Pevzner's algorithm.
Reference: [Tru93] <author> V.A. Trubin: </author> <title> Strength of a graph and packing of trees and branchings. </title> <journal> Kibernetika i Sistemnyi Analiz 3, </journal> <year> 1993, </year> <pages> pp. 94-99 </pages>
Reference: [TL] <author> P. Tong, E.L. Lawler: </author> <title> A faster algorithm for finding edge-disjoint branchings. </title> <journal> Information Processing Letters 17, </journal> <volume> 2, </volume> <year> 1983, </year> <pages> pp. 73-76 31 </pages>
Reference-contexts: The bulk of this paper is devoted to packing arborescences (more precisely a-arborescences). Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in <ref> [F79, G95a, L, Mad, TL] </ref>. Algorithms for packing arborescences in (unit capacity) graphs are presented in [Ta, S, TL]. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. <p> Edmonds proved the strong integrality property for arborescence packing [E72] (stated precisely * Research supported in part by NSF Grant No. CCR-9215199. 1 at the end of this section). Other proofs are in [F79, G95a, L, Mad, TL]. Algorithms for packing arborescences in (unit capacity) graphs are presented in <ref> [Ta, S, TL] </ref>. The most efficient algorithm for general unit capacity graphs finds k edge-disjoint arborescences in time O ((kn) 2 ) [G95a]. Algorithms for packing arborescences in capacitated graphs are given in [GLS, Mad].
References-found: 26

