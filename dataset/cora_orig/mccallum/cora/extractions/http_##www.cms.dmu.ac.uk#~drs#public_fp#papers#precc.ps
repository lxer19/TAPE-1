URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/precc.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: fPeter.Breuer,Jonathan.Boweng@comlab.ox.ac.uk  
Title: The PRECC Compiler Compiler  
Author: Peter T. Breuer Jonathan P. Bowen 
Address: 11 Keble Road, Oxford OX1 3QD.  
Affiliation: Oxford University Computing Laboratory  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.Y. Aho, </author> <title> The theory of parsing, translation, compiling, New Jersey, </title> <journal> USA, </journal> <volume> Vol. 1 & 2, </volume> <pages> 1972-73. </pages>
Reference: [2] <author> A.V. Aho and J.D. Ullman, </author> <title> Principles of compiler design, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1977. </year>
Reference: [3] <author> J.P. Bowen, </author> <title> From programs to object code using logic and logic programming, </title> <editor> in R. Giegerich and S.L. Graham (eds.), </editor> <title> Code Generation Concepts, Tools, Techniques, </title> <booktitle> Proc. International Workshop on Code Generation, </booktitle> <address> Dagstuhl, Germany, </address> <month> 20-24 May </month> <year> 1991. </year> <title> Springer-Verlag, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pp. 173-192, </pages> <year> 1992. </year>
Reference-contexts: Indeed the op (. . . ) pseudo-clause of Prolog allows enough flexibility in the definition of pre/in/post-fix operators, together with their associativity and precedence, for an abstract tree input to a compiler to be sufficiently readable that it is usable directly, at least for rapid-prototyping purposes <ref> [3] </ref>. Unfortunately, higher order language suites usually compile into native machine code, with a consequent lack of portability between different architectures, and usually carry the considerable overhead of at least some part of the development environment with them into the final product.
Reference: [4] <author> J.P. Bowen and P.T. Breuer, </author> <title> Occam's Razor: the cutting edge of parser technology, </title> <booktitle> in Proc. TOULOUSE 92: Fifth International Conference on Software Engineering and its Applications, </booktitle> <address> Toulouse, France, </address> <month> 7-11 December </month> <year> 1992. </year>
Reference-contexts: The space overhead claimed by PRECC is not even very great: 32KBytes of call stack is required to process 40-deep nested constructions in Occam 2 <ref> [4] </ref> (and 40-deep is the maximum in Occam because there are eighty characters to a line, and each nesting must be indented by at least two characters from the last), corresponding to about 2,500 stacked function calls from the kernel. <p> The memory required should not ordinarily be greater than about 64K bytes of stack per 80 (uncut) tokens parsed. Figures much better than this have been achieved for practical PRECC parsers <ref> [4] </ref>. It is true that an infinitely recursing parser will draw on all the memory available before halting, however, and this is a problem, because specifications that give rise to such recursions cannot in general be detected algorithmically, because of the power of PRECC's descriptive language. <p> The utility has been used to generate parsers and compilers for both commercially available (COBOL [16] and Occam <ref> [4] </ref>) and experimental (Uniform [18]) languages. A comparative study with YACC [7] and GNU's BISON clone has been undertaken using Oberon-2 [14] as the input grammar. PRECC also uses itself to parse its own input specification and compile its own code.
Reference: [5] <author> P.T. Breuer and J.P. Bowen, A PREttier Compiler-Compiler: </author> <title> Generating higher order parsers in C, </title> <institution> Programming Research Group Technical Report PRG-TR-20-92, Oxford University Computing Laboratory, UK, </institution> <year> 1992. </year> <month> 16 </month>
Reference-contexts: Scripts may in any case be divided up into independent modules, and compiled separately and linked together independently in order to cater for improved change management. PRECC has a formal basis that is fully investigated in <ref> [5] </ref> for those who wish to find out more about foundations of the tool.
Reference: [6] <author> J. Fairbairn, </author> <title> Making form follow function: An exercise in func tional programming style, </title> <journal> Software|Practice and Experience, </journal> <volume> 17(6), </volume> <pages> pp. 379-386, </pages> <year> 1987. </year>
Reference-contexts: PRECC has been designed to implement just enough of a (compiled) functional language in order to be able to handle parsing and no more. The `secret' (though hardly a secret to many functional programmers) behind all declarative compilers and parsers is top-down recursive descent parsing <ref> [6] </ref> and LL (1) infinite look-ahead technology. Heavily recursive in execution, the parser definitions can nevertheless be made as elegant as one cares to make them. <p> This method is set out with memorable clarity by Jon Fairbairn in <ref> [6] </ref>, but runtime considerations do not figure heavily in the account. The functional method turns out to transfer quite easily and naturally to C, and the generated C code follows the form of the intended grammar closely, providing a natural modularity.
Reference: [7] <author> S.C. Johnson and M.E. Lesk, </author> <title> Language development tools, </title> <journal> The Bell System Technical Journal 57(6), </journal> <volume> part 2, </volume> <pages> pp. 2155-2175, </pages> <month> July/August </month> <year> 1978. </year>
Reference-contexts: 1 Introduction YACC <ref> [7] </ref> is well established as a general purpose compiler-compiler, almost invariably still the tool of choice in the development under UNIX systems of off-line applications with complex input formats, but it is beginning to show its age. <p> PRECC also provides a simple hook for tokenizing pre-filters such as the UNIX LEX <ref> [7] </ref> utility, to which it presents an interface that is intended to be `plug compatible' with YACC's. Most lexers aimed at a YACC should be usable as they stand with PRECC, because PRECC calls a lexer called yylex () each time it wants a new token, just as YACC does. <p> The utility has been used to generate parsers and compilers for both commercially available (COBOL [16] and Occam [4]) and experimental (Uniform [18]) languages. A comparative study with YACC <ref> [7] </ref> and GNU's BISON clone has been undertaken using Oberon-2 [14] as the input grammar. PRECC also uses itself to parse its own input specification and compile its own code.
Reference: [8] <author> S.C. Johnson, </author> <title> Yacc meets C++, in UNIX around the World, </title> <booktitle> Proc. Spring 1988 EUUG Conference, </booktitle> <pages> pp. 53-57, </pages> <year> 1988. </year>
Reference-contexts: This is the approach taken in [13] in order to handle C++ [19] adequately, by allowing dynamic stack allocation, but it is not very elegant. Even the original author of YACC has produced a prototype tool, Y++, to handle C++, using the notion of attribute grammars <ref> [8] </ref>. Another approach, as described in this paper, is to produce a considerably more versatile tool from scratch, and design it to accept higher level grammar descriptions.
Reference: [9] <author> B.W. Kernighan and D.M. Ritchie, </author> <title> The C programming lan guage, </title> <booktitle> 2nd edition, Prentice-Hall Software Series, </booktitle> <year> 1988. </year>
Reference-contexts: Nevertheless, on the face of it, YACC offers some attractive programming options. It accepts a semantically complete variety of the BNF grammar specification language, and compiles the high level definition scripts into a C program <ref> [9] </ref>, which is a very portable approach. In practice, however, the drawbacks may be more apparent.
Reference: [10] <author> D.E. Knuth, </author> <title> Literate programming, </title> <journal> The Computer Journal, </journal> <volume> 27(2), </volume> <pages> pp. 97-111, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: In general, PRECC scripts are literate programs in the sense of 12 Knuth <ref> [10] </ref>, in that only certain parts of the script are visible to the utility itself (those lines beginning with an `@'), and these can therefore be embedded in ordinary text (i.e., literate prose) or other computer language instructions, typically C function definitions and preprocessor directives.
Reference: [11] <author> B.B. Kristensen and O.L. Madsen, </author> <title> Methods for computing LALR(K) lookahead, </title> <journal> ACM TOPLAS, </journal> <volume> 3(1), </volume> <pages> pp. 60-82, </pages> <year> 1981. </year>
Reference: [12] <author> J.L. Lewi, K. de Blaminck, I. van Horebeek and E. Steegmans, </author> <title> Software development by LL(1) syntax description, </title> <publisher> John Wiley & Sons Ltd, </publisher> <year> 1992. </year>
Reference: [13] <author> G.H. Merrill, </author> <title> Parsing non-LR(k) grammars with yacc, SAS In stitute Inc., SAS Campus Drive, Cary, </title> <address> NC 27513, USA, </address> <year> 1992. </year> <note> Submitted to Software|Practice and Experience. </note>
Reference-contexts: One approach to improving on YACC to parse the non-LR (k) grammars (which require infinite-lookahead) would be to modify YACC itself. This is the approach taken in <ref> [13] </ref> in order to handle C++ [19] adequately, by allowing dynamic stack allocation, but it is not very elegant. Even the original author of YACC has produced a prototype tool, Y++, to handle C++, using the notion of attribute grammars [8].
Reference: [14] <author> H. Mossenbock and N. Wirth, </author> <title> The programming language Oberon-2, </title> <institution> Institut fur Computersysteme, ETH Zurich, Swit-zerland, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: A parser for the Oberon-2 language was compiled by all the compiler-compilers, using as a basis a YACC specification 1 following the definition given in <ref> [14] </ref>. Although many other languages have been treated by PRECC, they have for the most part been without YACC specifications, and Oberon-2 is the first complete language for which an existing (and working) YACC specification has been used as a basis for a PRECC specification. <p> The utility has been used to generate parsers and compilers for both commercially available (COBOL [16] and Occam [4]) and experimental (Uniform [18]) languages. A comparative study with YACC [7] and GNU's BISON clone has been undertaken using Oberon-2 <ref> [14] </ref> as the input grammar. PRECC also uses itself to parse its own input specification and compile its own code. PRECC has been designed to lift some of the programming and implementational restrictions imposed by compiler-compilers in the style of the UNIX YACC utility.
Reference: [15] <author> J.C.H. Park and K.M. Choe, </author> <title> Remarks on recent algorithms for LALR lookahead sets, </title> <journal> ACM Sigplan Notices, </journal> <volume> 22(4), </volume> <pages> pp. 30-32, </pages> <month> April </month> <year> 1987. </year>
Reference: [16] <author> A. Parkin, </author> <title> COBOL for students, </title> <publisher> Edward Arnold, </publisher> <address> London, </address> <year> 1984. </year>
Reference-contexts: Firstly, and notably, both LEX and YACC-generated C code is monolithic, and a large language description, like that for COBOL <ref> [16] </ref>, with over two hundred keywords, generates such a large virtual automaton that swapping problems may occur at runtime even on modern workstations. <p> In this respect, PRECC fulfils one of its design goals. But quite apart from questions of expressive power, its time and space complexity is still low enough that it has been successfully used to make full scale parsers and scanners for COBOL 74 <ref> [16] </ref>, and to implement the programming language Uniform [18]. The definition scripts for these languages comprise between one and two thousand lines, involving between one and two hundred parser definitions. <p> The utility has been used to generate parsers and compilers for both commercially available (COBOL <ref> [16] </ref> and Occam [4]) and experimental (Uniform [18]) languages. A comparative study with YACC [7] and GNU's BISON clone has been undertaken using Oberon-2 [14] as the input grammar. PRECC also uses itself to parse its own input specification and compile its own code.
Reference: [17] <author> S. Sippo, </author> <title> Parsing theory, </title> <booktitle> Vol. 15, EATCS Monographs on The oretical Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: 1; 1; 2; 3; 5; 8; 13; 21; 34; 51; 85; :: (line 2 error) failed parse : probable error at hi1; 85; :: 3 more modern implementations of YACC and also BISON (a similar, widely distributed utility available from the GNU Software Foundation, which use improved internal algorithms (see <ref> [17] </ref>, for example) but possess essentially the same scripting language and functionality. It is also the case that BNF on its own is simply not expressive enough to capture the syntax of many programming languages.
Reference: [18] <author> C. Stanley-Smith and A. Cahill, </author> <title> UNIFORM: A language geared to system description and transformation, </title> <institution> University of Limerick, </institution> <address> Ireland, </address> <year> 1990. </year>
Reference-contexts: But quite apart from questions of expressive power, its time and space complexity is still low enough that it has been successfully used to make full scale parsers and scanners for COBOL 74 [16], and to implement the programming language Uniform <ref> [18] </ref>. The definition scripts for these languages comprise between one and two thousand lines, involving between one and two hundred parser definitions. <p> The utility has been used to generate parsers and compilers for both commercially available (COBOL [16] and Occam [4]) and experimental (Uniform <ref> [18] </ref>) languages. A comparative study with YACC [7] and GNU's BISON clone has been undertaken using Oberon-2 [14] as the input grammar. PRECC also uses itself to parse its own input specification and compile its own code.
Reference: [19] <author> B. Stroustrup, </author> <title> The C++ programming language, 2nd edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year> <month> 17 </month>
Reference-contexts: One approach to improving on YACC to parse the non-LR (k) grammars (which require infinite-lookahead) would be to modify YACC itself. This is the approach taken in [13] in order to handle C++ <ref> [19] </ref> adequately, by allowing dynamic stack allocation, but it is not very elegant. Even the original author of YACC has produced a prototype tool, Y++, to handle C++, using the notion of attribute grammars [8].
References-found: 19

