URL: http://www.csl.sri.com/reports/postscript/cav-cade96.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Automated Deduction and Formal Methods  
Author: John Rushby 
Address: Menlo Park, CA 94025, USA  
Affiliation: Computer Science Laboratory, SRI International,  
Date: 169-183, July 1996  
Note: Invited paper presented to joint session of CAV and CADE '96. Appears in proceedings of CAV '96, Springer Verlag LNCS 1102, pp.  
Abstract: The automated deduction and model checking communities have developed techniques that are impressively effective when applied to suitable problems. However, these problems seldom coincide exactly with those that arise in formal methods. Using small but realistic examples for illustration, I will argue that effective deductive support for formal methods requires cooperation among different techniques and an integrated approach to language, deduction, and supporting capabilities such as simulation and the construction of invariants and abstractions. Successful application of automated deduction to formal methods will enrich both fields, providing new opportunities for research and use of automated deduction, and making formal methods a truly useful and practical tool.
Abstract-found: 1
Intro-found: 1
Reference: <institution> Papers by SRI authors can generally be retrieved from http://www.csl.sri. com/fm.html. </institution>
Reference: [1] <editor> Rajeev Alur and Thomas A. Henzinger, editors. </editor> <booktitle> Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [2] <author> Saddek Bensalem, Yassine Lakhnech, and Hassen Sadi. </author> <title> Powerful techniques for the automatic generation of invariants. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 323-335. </pages>
Reference-contexts: This experience highlights another very fruitful area for research: systematic and automated methods for developing finite-state abstractions. Good results are already known for some special cases <ref> [2] </ref> and I speculate that integration of these methods with model checking will eventually provide an efficient way to verify properties of infinite-state systems. There were interesting differences between the "reduced" finite-state description checked with Mur and the "abstracted" version that was model checked.
Reference: [3] <author> R. S. Boyer and J S. Moore. </author> <title> Integrating decision procedures into heuristic theorem provers: A case study with linear arithmetic. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> volume 11. </volume> <publisher> Oxford University Press, </publisher> <year> 1986. </year>
Reference-contexts: Specialized methods include those for conditional rewriting in the presence of decided theories|the close integration of rewriting with linear arithmetic is the source for much of the effectiveness of Boyer and Moore's provers <ref> [3] </ref>, and similar capabilities are required in any system intended to support formal methods. Matching techniques similar to those used in rewriting can also provide heuristic instantiation for general formulas.
Reference: [4] <author> David Cyrluk, Patrick Lincoln, and N. Shankar. </author> <title> On Shostak's decision procedure for combinations of theories. </title> <editor> In M. A. McRobbie and J. K. Slaney, editors, </editor> <booktitle> Automated Deduction|CADE-13, number 1104 in Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 463-477, </pages> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This will allow us to restrict the arithmetic decision procedures to just the ground case|where the combination of linear arithmetic with uninterpreted function symbols is decidable <ref> [4] </ref>. My experience with formal methods applications is that this tradeoff in favor of deciding ground theories is always worthwhile, since it allows the different decision procedures to be combined. <p> larger procedures, even linear speedups in the performance of decision procedures can have a dramatic impact on overall efficiency; more needs to be known about the relative practical performance of various decision procedures for the same problem, which anecdotal evidence indicates can differ by an order of magnitude or more <ref> [4] </ref>.
Reference: [5] <author> David L. Dill. </author> <title> The Mur verification system. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 390-393. </pages>
Reference-contexts: Havelund and Shankar began by reducing the protocol to finite state (by manually assigning explicit small integers as the upper bound on the size of certain data structures) and checking certain safety properties with the Mur explicit state exploration system <ref> [5] </ref>. They next verified these properties for the full protocol by theorem proving in PVS using a traditional invariance argument, but found in the process that the desired invariant had to be strengthened by the addition of many additional conjuncts.
Reference: [6] <author> David Hamilton, Rick Covington, and John Kelly. </author> <title> Experiences in applying formal methods to the analysis of software and system requirements. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <pages> pages 30-43, </pages> <address> Boca Raton, FL, 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: To achieve acceptance, it therefore seems necessary that automated deduction should be harnessed to rather rich notations. To suggest some of the capabilities desired, I outline a typical "requirements specification" for a function in the Space Shuttle's control system called "Jet-Select" <ref> [6] </ref>. This function is responsible for selecting which of the Shuttle's Reaction Control System (RCS) jets (or thrusters) should be fired in order to accomplish a given translational or rotational acceleration. <p> In the case of Jet-Select, for example, our formalization revealed that certain interactions between error reporting and optimization allowed the possibility of firing a failed jet <ref> [6] </ref>. Examples of the latter often concern algorithms for concurrent, real time, or fault-tolerant behavior (e.g., cache-coherence or clock-synchronization)|where, again, it is difficult to anticipate all possible interactions|or highly optimized calculations whose correctness rests on a long or complex argument (e.g., SRT division and other efficient floating point algorithms).
Reference: [7] <author> Klaus Havelund and N. Shankar. </author> <title> Experiments in theorem proving and model checking for protocol verification. </title> <booktitle> In Formal Methods Europe FME '96, number 1051 in Lecture Notes in Computer Science, </booktitle> <pages> pages 662-681, </pages> <address> Oxford, UK, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For my next example, I describe an experiment undertaken by my colleagues Klaus Havelund and Shankar <ref> [7] </ref>, who applied a combination of finite state exploration, theorem proving, and model checking approaches to a simple protocol.
Reference: [8] <author> C. B. Jones, K. D. Jones, P. A. Lindsay, and R. Moore. </author> <title> mural: A formal Development Support System. </title> <publisher> Springer-Verlag, </publisher> <address> London, UK, </address> <year> 1991. </year>
Reference-contexts: These make few concessions to the needs of efficient automated deduction and the tools that have been developed for them provide little more than interactive proof checking unsupported by significant automation (e.g., <ref> [8, 10] </ref>).
Reference: [9] <author> L. Lamport and P. M. Melliar-Smith. </author> <title> Synchronizing clocks in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 52-78, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: For illustration, I will use a verification of the Interactive Convergence Algorithm for Byzantine fault-tolerant clock synchronization <ref> [9] </ref> that Friedrich von Henke and I performed some years ago [15].
Reference: [10] <author> Mogens Nielsen, Klaus Havelund, Kim Ritter Wagner, and Chris George. </author> <title> The RAISE language, method and tools. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(1) </volume> <pages> 85-114, </pages> <month> January-March </month> <year> 1989. </year>
Reference-contexts: These make few concessions to the needs of efficient automated deduction and the tools that have been developed for them provide little more than interactive proof checking unsupported by significant automation (e.g., <ref> [8, 10] </ref>).
Reference: [11] <author> Sam Owre, John Rushby, and Natarajan Shankar. </author> <title> Analyzing tabular and state-transition specifications in PVS. </title> <type> Technical Report SRI-CSL-95-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> July </month> <year> 1995. </year> <title> Available, with specification files, </title> <note> from http://www.csl.sri.com/csl-95-12.html. 14 </note>
Reference-contexts: For example, a tabular specification construct was recently added to PVS; this was then used to formalize a requirements methodology known as SCR, and model checking was then immediately available for SCR specifications <ref> [11] </ref>. Interesting challenges for the future are to integrate other highly efficient but narrow procedures into a general purpose framework.
Reference: [12] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Rather than being a limitation on specification language design, I believe that closer integration of language and automated deduction can have a liberating effect|because it makes it possible to contemplate design choices that require theorem proving in typechecking. We have exploited this opportunity to some extent in PVS <ref> [12] </ref> (where subtyping, for example, can generate proof obligations) but many further opportunities remain. It is not necessary that the logic supported by a theorem prover should be a full specification language, but there must be some translation from the latter to the former.
Reference: [13] <author> John Rushby. </author> <title> A formally verified algorithm for clock synchronization under a hybrid fault model. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 304-313, </pages> <address> Los Angeles, CA, </address> <month> August </month> <year> 1994. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: times: to improve the proof, to eliminate assumptions, to change the specification so that it connects better with the formalization of another part of the overall fault tolerant architecture, to tighten the bound on synchronization achieved, and to change from a Byzantine fault model to a more complex "hybrid" model <ref> [13] </ref>. The fact that formal analysis will be repeated many times as a specification is first debugged and then refined has consequences for automated deduction.
Reference: [14] <author> John Rushby. </author> <title> Mechanizing formal methods: Opportunities and challenges. </title> <editor> In Jonathan P. Bowen and Michael G. Hinchey, editors, </editor> <booktitle> ZUM '95: The Z Formal Specification Notation; 9th International Conference of Z Users, volume 967 of Lecture Notes in Computer Science, </booktitle> <pages> pages 105-113, </pages> <address> Limerick, Ireland, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: These make few concessions to the needs of efficient automated deduction and the tools that have been developed for them provide little more than interactive proof checking unsupported by significant automation (e.g., [8, 10]). I have argued elsewhere <ref> [14] </ref> that choices made in the designs of these languages (e.g., in the case of Z, set theory with partial functions, and no notion of definition) are inimical to automated deduction, and that really efficient deductive support is therefore unlikely to be forthcoming for them.
Reference: [15] <author> John Rushby and Friedrich von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: For illustration, I will use a verification of the Interactive Convergence Algorithm for Byzantine fault-tolerant clock synchronization [9] that Friedrich von Henke and I performed some years ago <ref> [15] </ref>.
Reference: [16] <author> Robert E. Shostak. </author> <title> On the SUP-INF method for proving Presburger formulas. </title> <journal> Journal of the ACM, </journal> <volume> 24(4) </volume> <pages> 529-543, </pages> <month> October </month> <year> 1977. </year>
Reference-contexts: Important requirements for such decision procedures are the following. They must work cooperatively to decide the combination of their theories. They must deal gracefully with terms outside the decided theory. For example, the theory decided by the SUP-INF <ref> [16] </ref> and similar procedures is ground linear arithmetic, but several of the formulas used in clock synchronization contain nonlinear terms (and division).
Reference: [17] <author> Mandayam K. Srivas and Steven P. Miller. </author> <title> Formal verification of the AAMP5 microprocessor. </title> <editor> In Michael G. Hinchey and Jonathan P. Bowen, editors, </editor> <booktitle> Applications of Formal Methods, Prentice Hall International Series in Computer Science, chapter 7, </booktitle> <pages> pages 125-180. </pages> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1995. </year>
Reference-contexts: Decision procedures for additional theories may be highly advantageous for particular classes of applications. For example, our experience with processor verification <ref> [17] </ref> has shown that the (large) library of rewrite rules used for the theory of bitvectors is the main impediment to effective automation, and we conjecture that a decision procedure for bitvectors would have a dramatic benefit.
Reference: [18] <author> Gunnar M. N. St-almarck. </author> <title> System for determining propositional logic theorems by applying values and rules to triplets that are generated from Boolean formula. </title> <institution> United States Patent 5,276,897, </institution> <month> January 4, </month> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 15 </title>
Reference-contexts: This is also known as function updating or overriding. 5 It goes without saying that propositional reasoning must be implemented very efficiently. Ordered binary decision diagrams (OBDDs) are the natural choice, but the Davis-Putnam procedure and the patented algorithm of St-almarck <ref> [18] </ref> may be superior in some applications. 7 Expressions that cannot be decided should be simplified. Especially in an interactive environment, it is important that the information presented to the user should be as brief and as simple as possible.
References-found: 19

