URL: http://www.cs.mtu.edu/~shene/edu/os.ps
Refering-URL: http://www.cs.mtu.edu/~shene/NSF-3/
Root-URL: http://www.cs.mtu.edu
Email: Email: shene@mtu.edu  
Title: Multithreaded Programming in an Introduction to Operating Systems Course  
Author: Ching-Kuang Shene 
Address: Houghton, MI 49931-1295  
Affiliation: Department of Computer Science, Michigan Technological University,  
Abstract: This paper presents a way of teaching multithreaded programming as a component in an introduction to operating systems course. Topics include programming assignments, term projects, and experiences. This paper also suggests future work for overcoming a bottleneck that occurs in the current version of this course. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Toby S. </author> <title> Berk, A Simple Student Environment for Lightweight Process Concurrent Programming under SunOS, </title> <booktitle> ACM Twenty-Seventh SIGCSE Technical Symposium on Computer Science Education, </booktitle> <address> Philadelphia, </address> <month> February 15-18, </month> <year> 1996, </year> <pages> pp. 165-169. </pages>
Reference-contexts: The SunOS lightweight process library was chosen, because it is a good user-level thread library with a simple API. To further reduce students' load, Berk's simplified ST_threads <ref> [1] </ref> was used. The following summarizes our effort of using mul-tithreaded programming for students' lab work. Section 2 details the programming assignments, Section 3 discusses a term project, and Section 4 describes some of our findings. Section 5 suggests some future work to improve this course.
Reference: [2] <author> Alan Burns and Geoff Davies, </author> <title> Concurrent Programming, </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: To this end, a programming system must be selected. Pascal-FC <ref> [2] </ref> was used previously, but was not well-received. We also seriously considered SR [6]. Since its syntax and semantics are different from that of C/C++ and since we do not have enough time to cover another programming language, SR was rejected.
Reference: [3] <author> Wentong Cai, Wendy J. Milne and Stephen J. Turner, </author> <title> Graphical Views of the Behavior of Parallel Programs, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 18 (1993), </volume> <pages> pp. 223-230. </pages>
Reference-contexts: Postmortem detection is a possibility; but, it could be too late because the user program has already been involved in some problems. Animating the execution of a multithreaded program is very helpful. There have been some progress during the past few years <ref> [3, 10, 11] </ref>. Animation can be real-time or postmortem. The main drawback of a postmortem system is that it generates large amount of output, usually several megabytes.
Reference: [4] <author> Stephen Crane, </author> <title> The REX Lightweight Process Library, </title> <address> March 7, </address> <year> 1996. </year> <note> Available by anonymous ftp from dse.doc.ic.ac.uk in directory /pub/rex. </note>
Reference-contexts: Second, a more flexible stack allocation scheme is possible. All thread control blocks and stack areas can be dynamically allocated; but, some assembly language is required making the system machine dependent. This does not complicate the system very much as has been shown in REX <ref> [4] </ref> and several public domain implementations of Pthreads. REX is particularly interesting, because it is small and clean and may serve as a model if this change must be made. For a MS-DOS environment, English [5] has a simple and interesting system, with source code available.
Reference: [5] <author> John English, </author> <title> Multithreading in C++, </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> Vol. 30 (1995), No. 4, </volume> <pages> pp. 21-28. </pages>
Reference-contexts: This does not complicate the system very much as has been shown in REX [4] and several public domain implementations of Pthreads. REX is particularly interesting, because it is small and clean and may serve as a model if this change must be made. For a MS-DOS environment, English <ref> [5] </ref> has a simple and interesting system, with source code available. Third, by modifying the thread initialization part and the scheduler, this system is capable of self-scheduling and is more natural.
Reference: [6] <author> Stephen J. </author> <title> Hartley, Operating Systems Programming, </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: To this end, a programming system must be selected. Pascal-FC [2] was used previously, but was not well-received. We also seriously considered SR <ref> [6] </ref>. Since its syntax and semantics are different from that of C/C++ and since we do not have enough time to cover another programming language, SR was rejected. The SunOS lightweight process library was chosen, because it is a good user-level thread library with a simple API.
Reference: [7] <author> Stig Kofoed, </author> <title> Portable Multitasking in C++, </title> <journal> Dr. Dobb's Journal, </journal> <volume> No. </volume> <month> 226 (Nov), </month> <year> 1995, </year> <pages> pp. 70-78. </pages>
Reference-contexts: We used a scheme proposed by Kofoed <ref> [7] </ref>. A large enough block is reserved for main () before starting any thread. For each thread, the remaining stack space is searched for a large enough block with the first-fit algorithm. <p> They may be used in the future. 3.6 Possible Improvements This term project is not very realistic, because the scheduler is non-preemptive and is not self-scheduling (i.e., the system requires a driver statement that repeatedly activates the next thread in the ready queue <ref> [7] </ref>). However, it is platform independent since it is completely written in C/C++ without any UNIX system calls. Moreover, it is simple and deterministic and students can easily trace their programs with a debugger. There are four possible improvements without adding too much burden to students.
Reference: [8] <author> Stephen P. Masticola, </author> <title> Static Infinite Wait Anomaly Detection in Polynomial Time, </title> <institution> LCSR-TR-114, Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1990. </year>
Reference-contexts: To help our students learn multithreaded programming effectively, we intend to design some pedagogical tools. This is not an easy job, since statically detecting race conditions and deadlocks are NP-complete and NP-hard, respectively <ref> [9, 8] </ref>. On-the-fly detection of deadlocks is a textbook topic; but, on-the-fly detection of race conditions is infeasible. Postmortem detection is a possibility; but, it could be too late because the user program has already been involved in some problems. Animating the execution of a multithreaded program is very helpful.
Reference: [9] <author> Robert H. B. Netzer and Barton P. Miller, </author> <title> On the Complexity of Event Ordering for Shared-Memory Parallel Program Executions, </title> <booktitle> International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990, </year> <pages> pp. </pages> <month> II93-II97. </month>
Reference-contexts: To help our students learn multithreaded programming effectively, we intend to design some pedagogical tools. This is not an easy job, since statically detecting race conditions and deadlocks are NP-complete and NP-hard, respectively <ref> [9, 8] </ref>. On-the-fly detection of deadlocks is a textbook topic; but, on-the-fly detection of race conditions is infeasible. Postmortem detection is a possibility; but, it could be too late because the user program has already been involved in some problems. Animating the execution of a multithreaded program is very helpful.
Reference: [10] <author> John T. Stasko, </author> <title> The PARADE Environment for Visualizing Parallel Program Executions: A Progress Report, </title> <type> Technical Report GIT-GVU-95-03, </type> <institution> College of Computing, George Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Postmortem detection is a possibility; but, it could be too late because the user program has already been involved in some problems. Animating the execution of a multithreaded program is very helpful. There have been some progress during the past few years <ref> [3, 10, 11] </ref>. Animation can be real-time or postmortem. The main drawback of a postmortem system is that it generates large amount of output, usually several megabytes.
Reference: [11] <author> Qiang A. Zhao and John T. Stasko, </author> <title> Visualizing the Execution of Threads-based Parallel Programs, </title> <type> Technical Report GIT-GVU-95-01, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: Postmortem detection is a possibility; but, it could be too late because the user program has already been involved in some problems. Animating the execution of a multithreaded program is very helpful. There have been some progress during the past few years <ref> [3, 10, 11] </ref>. Animation can be real-time or postmortem. The main drawback of a postmortem system is that it generates large amount of output, usually several megabytes.
References-found: 11

