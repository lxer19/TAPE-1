URL: http://www.cs.washington.edu/homes/yasushi/pubs/trans.ps
Refering-URL: http://www.cs.washington.edu/homes/yasushi/pubs/
Root-URL: 
Email: fyasushi,bershadg@cs.washington.edu  
Title: A Transactional Memory Service in an Extensible Operating System  
Author: Yasushi Saito and Brian Bershad 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: This paper describes Rhino, a transactional memory service implemented on top of the SPIN operating system. Rhino is implemented as an extension that runs in SPIN kernel's address space. We discuss how the extension structure of Rhino can solve performance problems previously unavoidable in traditional systems, and we quantify its benefits. We also introduce three alternative buffer management schemes and study their performance under various workloads. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian N. Bershad, Thomas E. Anderson, Ed-ward D. Lazowska, and Henry M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM TOCS, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: IPC performance becomes more critical in a transactional memory services where clients and the server exchange data pages, than in relational database systems where only queries and answers are exchanged. Although fast IPC mechanisms have been studied extensively <ref> [1, 11] </ref>, they have not made their way into mainstream operating systems. Thus, IPC in existing operating systems is slow, and it often becomes the bottleneck in transactional memory implementations. 1.2.3 Buffer Management A transactional memory service must often handle databases whose size exceeds that of main memory.
Reference: [2] <author> Brian N. Bershad, Stefan Savage, Przemyslaw Pardyak, Emin Gun Sirer, Marc Fiuczynski, David Becker, Susan Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In ACM SOSP--15, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: 1 Introduction This paper describes Rhino, a transactional memory service that lets applications perform transactions on a virtual memory through ordinary loads and stores. Rhino runs on the SPIN operating system, which lets user applications modify and augment the kernel by safely downloading code (extensions) into the kernel address space <ref> [2] </ref>. Rhino is implemented as an extension. Extensions can efficiently manipulate kernel resources such as virtual memory pages and files, and can thus avoid the performance bottlenecks that plague traditional systems. We have developed several versions of Rhino as our understanding of SPIN and its target applications grew. <p> Rhino's performance is contrasted with UNIX implementations in Section 5. Section 6 examines works related to ours. We summarize our findings in Section 7. 2 Overview of SPIN SPIN is an extensible operating system. Applications can safely extend the kernel functionality by downloading code into the kernel address space <ref> [2] </ref>. The SPIN operating system consists of the kernel, which provides basic services such as CPU scheduling and device management, and extensions, which are downloaded into the kernel address space after the kernel boots.
Reference: [3] <author> Michael J. Carey, David J. DeWitt, and Jef-frey F. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> In SIGMOD Conference Proceedings, </booktitle> <pages> pages 12-21, </pages> <address> Washington D.C., </address> <month> June </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: It implements no-steal, no-force buffer management and page grain logging. Object-Store is included to compare Rhino against a state-of-the-art, object-oriented database system. We first present the micro-benchmarks that show the latency of the critical paths. Next, we present results from two benchmarks, RVM [17] and OO7 <ref> [3] </ref>. The RVM benchmark typifies small update transactions, while OO7 typifies graphical CAD database operations. 5.1 Micro-benchmarks This section compares the micro-benchmark performance of SPIN-based Rhino and Digital UNIX-based Rhino to show how the extension architecture of SPIN improves the performance of critical functions. <p> ObjectStore fares badly in this benchmark. Since it performs page grain logging, whole page contents must be communicated to the server via IPC. Thus, it is not suited to small transactions. 5.3 The OO7 Benchmark OO7 is the standard benchmark for object-oriented databases <ref> [3] </ref>. <p> Thus, only the total elapsed times are shown. a single transaction is shown for each system. various types connected in a tree structure (Figure 7). We used the small, medium-3, and medium-9 configurations described in <ref> [3] </ref> (numbers in the medium configurations show the density of internal connections). The total database sizes are about 10MB for the small, 60MB for the medium-3, and 100MB for the medium-9. We ran three types of traversals, T1, T2A, and T2C.
Reference: [4] <author> Albert Chang and Mark F. Mergen. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM TOCS, </journal> <volume> 6(1) </volume> <pages> 28-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Rio makes all updates to the buffer permanent immediately by recovering buffer contents during the system reboot. Thus, Vista transactions are orders of magnitude faster than transactions based on disk-logging. Finally, there are systems that implement transactions inside the kernel. IBM CPR <ref> [4] </ref> and Pilot [15] support transactional updates of memory-mapped files. These systems solve problems found in other systems. However, most applications do not use transactions frequently enough to afford the complexity introduced by embedding transaction support in the kernel, making this approach uneconom-ical.
Reference: [5] <author> Khien-Mien Chew and Avi Silberschatz. </author> <title> Toward Operating System Support for Recoverable-persistent Main Memory Database Systems. </title> <type> Technical Report CS-TR-92-05, </type> <institution> University of Texas at Austin, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Some systems try to solve the double paging problem by using memory-mapped files and a special system call that lets user programs control the way pages are evicted. RPVM <ref> [5] </ref> adds a system call that dictates the order of page eviction. By telling the kernel to purge a buffer page after it purges log pages that record updates to that page, write ahead logging (WAL) can be implemented.
Reference: [6] <author> Wolfgang Effelsberg and Theo Haerder. </author> <title> Principles of Database Buffer Management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4) </volume> <pages> 560-595, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: file onto caller's address space trans munmap (addr, length ) Unmaps the file trans id = trans begin () Begins a transaction trans commit (trans id ) Commits the transaction trans abort (trans id ) Aborts the transaction and rolls back its effect Table 1: Rhino API no-steal, no-force policy <ref> [6] </ref>. Update detection using setrange was first implemented in RVM [17]. 4.3.2 Page Grain Logging Instead of relying on system calls from applications, page grain logging version uses MMU protection to detect writes. Database contents are stored in a memory object, as in the setrange version.
Reference: [7] <author> Jeffrey Eppinger, Lily B. Mummert, and Al-fred Z. </author> <title> Spector, </title> <editor> editors. Camelot and Avalon. </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year>
Reference-contexts: This scheme is essentially the same as that used in systems such as ObjectStore [10] and QuickStore [22]. Other locking approaches are possible, such as requiring applications to issue a system call to lock a region <ref> [7] </ref>. However, we decided on the MMU-based automatic locking approach to make the programming interface as simple as possible. A shortcoming of this approach is that multiple threads in a single process cannot execute transactions simultaneously on the same database. <p> RPVM [5] adds a system call that dictates the order of page eviction. By telling the kernel to purge a buffer page after it purges log pages that record updates to that page, write ahead logging (WAL) can be implemented. Cam-elot <ref> [7] </ref> and Cricket [19] use the Mach external pager mechanism [23] to implement WAL. One difference between these systems and Rhino is that the former are user-space applications. Thus, they cannot avoid overhead due to a large number of user-kernel crossings.
Reference: [8] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1993. </year>
Reference-contexts: also show how SPIN's extension architecture enhances the performance of Rhino by comparing Rhino with its user-space, UNIX-based implementation. 1.1 Transactional Memory Require ments Transactional memory service allows applications to access a database file mapped onto virtual memory regions in an atomic, isolated, and durable (also known as ACID) manner <ref> [8] </ref>. It is used as a runtime engine for managing persistent, pointer-rich data structures, such as graphic design databases, project management databases, and directory services. Transactional memory is similar to a memory-mapped file, but the ACID property requires additional operating system support. <p> It also manages buffers using memory objects. * The log manager manages the log device, which is a sequential-write, random-read persistent device <ref> [8] </ref>. It is used by the storage manager to guarantee database durability and atomicity. The log manager also coordinates crash recov ery when Rhino is installed. * The lock manager manages locks on regions. It also detects deadlocks. Rhino uses several standard extensions to carry out operations. <p> It then calls trans_mmap to map the file onto a virtual address space region (that must be MMU-page aligned). After setup of the transactional memory region, the application need 1 Note that our use of the term "storage manager" differs from that in other database literature <ref> [8] </ref>. "Storage manager" commonly refers to the code that manages raw disk I/O. In our system, the storage manager is a resource manager specialized for file manipulation. <p> Buffering is the key to high performance. Locking and write detection are needed to ensure the ACID property <ref> [8] </ref>. 4.1 Buffering Rhino stores database contents in memory-mapped files; in other words, the database is buffered on pages that are mapped directly onto an application's address space. Memory-mapped files thus avoid the double paging problem even if there is memory competition. <p> Memory-mapped files thus avoid the double paging problem even if there is memory competition. Efficient buffering must comply with the write ahead logging (WAL) rule, which dictates that whenever a page is to be evicted, its log records (undo records) must be flushed to the log device <ref> [8, 13] </ref>. Rhino ensures WAL by implementing its own pageout procedure. Whenever the kernel chooses a page for purging, the Rhino pageout module is called to flush the log into the log device. 4.2 Locking Rhino lets multiple applications access a database concurrently. <p> not a unit of protection in most operating systems including SPIN; protecting database accesses by threads does not provide much help to programmers. 4.3 Write Detection Transactional memory service must detect and log all writes to the persistent region, permitting changes to the database to be undone or redone atomically <ref> [8] </ref>. We implemented three versions of write detection in Rhino to study their performance trade-offs under various workloads. They are setrange, page grain logging, and page diff-ing. Setrange requires applications to issue a trans_setrange system call before modifying the database. <p> First, it generates undo and redo records for the whole page even if only a single byte is modified on the page. Second, page grain logging blindly generates undo records even for transactions small enough not to require paging, in which case undo records are not needed <ref> [8] </ref>. Page diffing combines the advantages of setrange and page grain logging. It shares all the advantages of page grain logging. In addition, it can minimize log size by computing page diffs. However, page diffing introduces overhead that did not exist in earlier versions.
Reference: [9] <author> Maurice Herlihy and J. Eliot B. Moss. </author> <title> Transactional Memory: Architectural Support for Lock-Free Data Structures. </title> <booktitle> In ICSA. ACM, </booktitle> <year> 1993. </year>
Reference-contexts: However, most applications do not use transactions frequently enough to afford the complexity introduced by embedding transaction support in the kernel, making this approach uneconom-ical. Herlihy and Moss proposed a transactional memory that is a CPU instruction set designed to support atomic memory updates <ref> [9] </ref>. Our use of the term is not related to theirs. 7 Conclusions This paper described the implementation and performance of Rhino, a transactional memory implemented on the SPIN operating system.
Reference: [10] <institution> Object Design Inc. home page. </institution> <note> http://www.odi.com. </note>
Reference-contexts: For ease of use and understanding, we use C nomenclature to present interfaces accessed by user-space applications. Table 1 shows the system calls supported by Rhino. The system call interface resembles those found in other systems <ref> [17, 10, 20] </ref>. Figure 4 shows a simple application that writes "z"s onto the region that extends from byte 256 to byte 384 in the file "/efs/test". To access a database file, the application first calls trans_open to get a handle to the file. <p> The page fault handler in the Rhino extension obtains either a read or a write lock on the page, depending on whether the access is load or store. This scheme is essentially the same as that used in systems such as ObjectStore <ref> [10] </ref> and QuickStore [22]. Other locking approaches are possible, such as requiring applications to issue a system call to lock a region [7]. However, we decided on the MMU-based automatic locking approach to make the programming interface as simple as possible. <p> Next, it writes the contents of the storage page into the database file. Finally, it removes the page from the memory object. Thus, this version implements a steal, no-force buffer management. Variations of page grain logging can be found in many transactional memory systems, including ObjectStore <ref> [10] </ref>. 4.3.3 Page Diffing Page diffing resembles page grain logging. However, it tries to reduce the size of the log by computing differences between old and new page contents. When a database file is opened, the storage manager creates two memory objects. <p> We compared five systems: the three versions of 3 When the page is purged and later brought in again, Rhino takes a page fault again. Rhino running on SPIN, the page diffing version of Rhino running on Digital UNIX 3.2, and Object-Store 4.0 running on Digital UNIX 3.2 <ref> [10] </ref>. Rhino on Digital UNIX uses the same page diffing code to detect modifications, but buffers are on ordinary virtual memory pages instead of a memory-mapped file, and page faults are detected using UNIX signals. <p> The RVM and OO7 results also show that SPIN-based Rhino outperforms user-space transactional memory implementations. 6 Related Work This section reviews systems related to Rhino. We include in our review object-oriented databases and persistent languages, since they are closely related to transactional memory. ObjectStore <ref> [10] </ref>, QuickStore [22], and QuickSilver [18] are client-server systems in which a server process manages transactions, and clients perform IPC to the server to access database contents. The advantage of this approach is that servers can transparently support clients running on different hosts.
Reference: [11] <author> Jochen Liedtke. </author> <title> On Micro-Kernel Construction. </title> <booktitle> In ACM SOSP-15, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: IPC performance becomes more critical in a transactional memory services where clients and the server exchange data pages, than in relational database systems where only queries and answers are exchanged. Although fast IPC mechanisms have been studied extensively <ref> [1, 11] </ref>, they have not made their way into mainstream operating systems. Thus, IPC in existing operating systems is slow, and it often becomes the bottleneck in transactional memory implementations. 1.2.3 Buffer Management A transactional memory service must often handle databases whose size exceeds that of main memory.
Reference: [12] <author> David E. Lowell and Peter M. Chen. </author> <title> Free Transactions with Rio Vista. </title> <booktitle> In ACM SOSP-16, </booktitle> <year> 1997. </year> <note> See also http://www.eecs.umich.edu/~pmchen/. </note>
Reference-contexts: When a transaction makes many trans - setrange calls, call overhead becomes sizeable. Note that this problem is less serious in systems like RVM [17] and Vista <ref> [12] </ref>, which implement setrange as a library. * Memory overhead increases in large transac tions. The biggest problem with setrange is that each setrange region must be recorded until the transaction terminates. Thus, we cannot limit the amount of memory required to keep track of a transaction. <p> Cam-elot [7] and Cricket [19] use the Mach external pager mechanism [23] to implement WAL. One difference between these systems and Rhino is that the former are user-space applications. Thus, they cannot avoid overhead due to a large number of user-kernel crossings. Vista <ref> [12] </ref> uses Rio, a non-volatile file buffer, to implement transactions. Rio makes all updates to the buffer permanent immediately by recovering buffer contents during the system reboot. Thus, Vista transactions are orders of magnitude faster than transactions based on disk-logging. Finally, there are systems that implement transactions inside the kernel.
Reference: [13] <author> Dylan McNamee. </author> <title> Virtual Memory Alternatives for Transaction Buffer Management in a Single-Level Store. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: When a database buffer page held on ordinary virtual memory is evicted, extra disk accesses are required to swap out and later swap in the page. Straightforward implementations have been unable to address this problem, called double paging <ref> [13] </ref>. 1.2.4 Organization of the Paper Section 2 introduces the SPIN operating system. Section 3 reviews SPIN's Rhino extension. In Section 4, we discuss implementation issues and describe the advantages and disadvantages of three alternative buffer management schemes. Rhino's performance is contrasted with UNIX implementations in Section 5. <p> Memory-mapped files thus avoid the double paging problem even if there is memory competition. Efficient buffering must comply with the write ahead logging (WAL) rule, which dictates that whenever a page is to be evicted, its log records (undo records) must be flushed to the log device <ref> [8, 13] </ref>. Rhino ensures WAL by implementing its own pageout procedure. Whenever the kernel chooses a page for purging, the Rhino pageout module is called to flush the log into the log device. 4.2 Locking Rhino lets multiple applications access a database concurrently.
Reference: [14] <author> Greg Nelson, </author> <title> editor. Systems Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Extensions efficiently communicate and share resources with the kernel and other extensions; from a performance viewpoint, they resemble dynamically linked modules. The SPIN kernel and extensions are written in Modula-3 <ref> [14] </ref>, a general purpose, typesafe language.
Reference: [15] <author> David D. Redell, Yogen K. Dalal, Thomas R. Horsley, Hugh C. Lauer, William C. Lynch, Paul R. McJones, Hal G. Murray, and Stephen C. Purcell. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> CACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Rio makes all updates to the buffer permanent immediately by recovering buffer contents during the system reboot. Thus, Vista transactions are orders of magnitude faster than transactions based on disk-logging. Finally, there are systems that implement transactions inside the kernel. IBM CPR [4] and Pilot <ref> [15] </ref> support transactional updates of memory-mapped files. These systems solve problems found in other systems. However, most applications do not use transactions frequently enough to afford the complexity introduced by embedding transaction support in the kernel, making this approach uneconom-ical.
Reference: [16] <author> Yasushi Saito and Brian Bershad. </author> <title> System Call Support in an Extensible System. </title> <note> See http://www.cs.washington.edu/- homes/yasushi, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: SPIN also supports user-space applications. Although the SPIN kernel does not support native system calls, it provides mechanisms that allow extensions to catch events from user-space applications, such as system calls and page faults. The UNIX emulation extension uses these mechanisms to provide the UNIX API for user-space applications <ref> [16] </ref>. Rhino is another extension that implements a transactional memory service for user-space applications. Note that unlike extensions, user-space applications can be written in any language. <p> Null call indicates a null system call overhead (on Digital UNIX, we measured the latency of getpid). SPIN is slower than Digital UNIX, because the implementation of system call in SPIN requires the use of additional mechanisms to protect the kernel from the runtime failure of an extension <ref> [16] </ref>. Begin shows the latency of trans_begin. Commit (ro) is the time to commit a read-only transaction. Commit (8byte) is the time to commit a transaction that modified 8 bytes on a single page. Page diffing is used during commits.
Reference: [17] <author> M. Satyanarayanan, Henry Mashburn, Pun-eet Kumar, David Steere, and James Kist-ler. </author> <title> Lightweight Recoverable Virtual Memory. </title> <journal> ACM TOCS, </journal> <volume> 12(1) </volume> <pages> 33-57, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: For ease of use and understanding, we use C nomenclature to present interfaces accessed by user-space applications. Table 1 shows the system calls supported by Rhino. The system call interface resembles those found in other systems <ref> [17, 10, 20] </ref>. Figure 4 shows a simple application that writes "z"s onto the region that extends from byte 256 to byte 384 in the file "/efs/test". To access a database file, the application first calls trans_open to get a handle to the file. <p> Update detection using setrange was first implemented in RVM <ref> [17] </ref>. 4.3.2 Page Grain Logging Instead of relying on system calls from applications, page grain logging version uses MMU protection to detect writes. Database contents are stored in a memory object, as in the setrange version. All virtual memory mappings for the memory object are invalid before a transaction starts. <p> When a transaction makes many trans - setrange calls, call overhead becomes sizeable. Note that this problem is less serious in systems like RVM <ref> [17] </ref> and Vista [12], which implement setrange as a library. * Memory overhead increases in large transac tions. The biggest problem with setrange is that each setrange region must be recorded until the transaction terminates. Thus, we cannot limit the amount of memory required to keep track of a transaction. <p> It implements no-steal, no-force buffer management and page grain logging. Object-Store is included to compare Rhino against a state-of-the-art, object-oriented database system. We first present the micro-benchmarks that show the latency of the critical paths. Next, we present results from two benchmarks, RVM <ref> [17] </ref> and OO7 [3]. The RVM benchmark typifies small update transactions, while OO7 typifies graphical CAD database operations. 5.1 Micro-benchmarks This section compares the micro-benchmark performance of SPIN-based Rhino and Digital UNIX-based Rhino to show how the extension architecture of SPIN improves the performance of critical functions. <p> On the other hand, mprotect requires more work, because it must manipulate the memory object map data structure to make its effect persist regardless of paging activity. 5.2 RVM Benchmark The RVM benchmark is a program developed by the authors of RVM <ref> [17] </ref>. Each transaction reads and updates three 128-byte blocks and appends one 64-byte block to the end of the database. One 128-byte block is chosen randomly from the entire database; the other two 128-byte blocks are chosen from a narrow region. Thus, this benchmark measures the performance of small transactions. <p> The advantage of this approach is that servers can transparently support clients running on different hosts. However, this approach also means that even local clients must communicate through a slow IPC channel, thus creating performance problems. RVM <ref> [17] </ref> and Texas [20] are implemented as a library that is linked into user-space applications. Since they have no IPC overhead, unlike client-server systems, they can be fast. However, they are inherently single-user database systems, because there is no single authority that allows safe data sharing.
Reference: [18] <author> Frank Schmuck and Jim Wyllie. </author> <title> Experience with Transactions in QuickSilver. </title> <booktitle> In SOSP-13, </booktitle> <pages> pages 239-253, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The RVM and OO7 results also show that SPIN-based Rhino outperforms user-space transactional memory implementations. 6 Related Work This section reviews systems related to Rhino. We include in our review object-oriented databases and persistent languages, since they are closely related to transactional memory. ObjectStore [10], QuickStore [22], and QuickSilver <ref> [18] </ref> are client-server systems in which a server process manages transactions, and clients perform IPC to the server to access database contents. The advantage of this approach is that servers can transparently support clients running on different hosts.
Reference: [19] <author> Eugene Shekita and Michael Zwillling. </author> <month> Cricket </month> : 
Reference-contexts: RPVM [5] adds a system call that dictates the order of page eviction. By telling the kernel to purge a buffer page after it purges log pages that record updates to that page, write ahead logging (WAL) can be implemented. Cam-elot [7] and Cricket <ref> [19] </ref> use the Mach external pager mechanism [23] to implement WAL. One difference between these systems and Rhino is that the former are user-space applications. Thus, they cannot avoid overhead due to a large number of user-kernel crossings. Vista [12] uses Rio, a non-volatile file buffer, to implement transactions.
References-found: 19

