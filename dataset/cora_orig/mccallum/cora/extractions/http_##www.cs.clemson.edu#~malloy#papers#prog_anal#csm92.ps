URL: http://www.cs.clemson.edu/~malloy/papers/prog_anal/csm92.ps
Refering-URL: http://www.cs.clemson.edu/~malloy/prog_anal_papers.html
Root-URL: http://www.cs.clemson.edu
Title: A Unified Interprocedural Program Representation for a Maintenance Environment  
Author: Mary Jean Harrold Brian Malloy 
Address: Clemson, SC 29634-1906  
Affiliation: Department of Computer Science Clemson University  
Abstract: Modifying and then validating a program with many interacting modules, such as procedures, is an expensive and complex task. Thus, a maintenance environment containing an efficient program representation and tools that access that representation to assist the user in understanding, modifying, analyzing, testing and debugging a program is needed. This paper presents our unified interprocedural graph, UIG, that combines the features of existing program representations to permit access to information for maintenance tasks. The main benefit of this approach is the reduction in storage space for the individual representations since redundant information is eliminated. Another important benefit is the savings in access time to the various graphs since all algorithms access the UIG. A single program representation also assists in program understanding since relationships among program elements are incorporated into one graph. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> F. E. Allen, M. Burke, P. Charles, R. Cytron, and J. Ferrante, </author> <title> ``An overview of the PTRAN analysis system for multiprocessing,'' </title> <booktitle> Proceedings of the First International Conference on Supercomputing, </booktitle> <pages> pp. </pages> <address> 194-211 , Athens, Greece , June 1987. </address>
Reference-contexts: A call graph is also useful for interproce-dural data ow analysis. Interprocedural data ow analysis algorithms that use a call graph are ow-insensitive since they do not consider the control ow of individual procedures <ref> [1, 3, 17, 20] </ref>. However, ow-insensitive inter-procedural data ow analysis algorithms can determine whether an actual reference parameter may be defined or used by a call to a procedure.
Reference: 2. <author> D. Callahan, </author> <title> ``The program summary graph and ow-sensitive interprocedural data ow analysis,'' </title> <booktitle> Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 47-56, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: To determine whether iterations of a loop containing a call statement can be executed in parallel, information about the effects of the call on reference parameters and global variables can be computed <ref> [2] </ref>. This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies [7, 15, 18] and incremental testing techniques [6, 8, 14, 19] can assist in regression testing. <p> The algorithms that use these graphs to gather the interprocedural information are described but details are omitted from this presentation. More detailed discussions can be found in Ryder [16], Callahan <ref> [2] </ref>, Harrold and Soffa [7] and Horwitz, Reps and Binkley [9]. We present the details for handling reference parameters; global variables can be handled similarly. In Section 3, the UIG is presented, including details of its construction and adaptations of the existing interprocedural algorithms. <p> Uses reachable across procedure boundaries are listed to the right of the graph and reachable use sets are attached to call and exit nodes. ___________________________________________________________________________________________________ used as an actual parameter. Other reaching edges are (7,8), (13,15), (16,14), and (12,6). Iterative algorithms <ref> [2] </ref> use the PSG to determine information such as whether the values of actual reference parameters may-be-preserved over a call site. The value of a variable may-be-preserved over a procedure call if there is some execution path through the procedure where it is not redefined.
Reference: 3. <author> K. Cooper and K. Kennedy, </author> <title> ``Fast interprocedural alias analysis,'' </title> <booktitle> Proceedings of Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 49-59, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: A call graph is also useful for interproce-dural data ow analysis. Interprocedural data ow analysis algorithms that use a call graph are ow-insensitive since they do not consider the control ow of individual procedures <ref> [1, 3, 17, 20] </ref>. However, ow-insensitive inter-procedural data ow analysis algorithms can determine whether an actual reference parameter may be defined or used by a call to a procedure.
Reference: 4. <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren, </author> <title> ``The program dependence graph and its use in optimization,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Such information is required for debugging and identifying the statements that can execute in parallel. A variation of the call graph that models a program's control dependencies is the system dependence graph [9]. The system dependence graph combines the dependence graphs for the individual procedures <ref> [4] </ref> with additional nodes and edges to permit the computing of an interprocedural slice of the program.
Reference: 5. <author> P. G. Frankl and E. J. Weyuker, </author> <title> ``An applicable family of data ow testing criteria,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-14, no. 10, </volume> <pages> pp. 1483-1498, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Other uses that can be reached over procedure boundaries are attached to call and exit nodes. Use sets are also computed for entry and return nodes, but are omitted from and use pairs for testing. For data ow testing <ref> [5, 11, 13] </ref>, the definition and use pairs are computed using the IFG and propagation algorithm described above [8]. Then, test cases are generated to traverse subpaths from the definitions to the uses during program execution. A subpath must contain no redefinition of the variable.
Reference: 6. <author> M. J. Harrold, </author> <title> ``An approach to incremental testing,'' </title> <institution> Technical Report 89-1 Department of Computer Science, </institution> <type> Ph.D. Thesis, </type> <institution> University of Pittsburgh, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies [7, 15, 18] and incremental testing techniques <ref> [6, 8, 14, 19] </ref> can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information.
Reference: 7. <author> M. J. Harrold and M. L. Soffa, </author> <title> ``Computation of interprocedural definition and use dependencies,'' </title> <booktitle> Proceedings of IEEE Computer Society 1990 International Conference on Computer Languages, </booktitle> <pages> pp. 297-306, </pages> <address> New Orleans, LA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Currently, techniques do exist to assist in intrapro-cedural and interprocedural activities during maintenance. A program can be modified by incrementally updating its representation to reect the program changes so that complete reanalysis of the source code is avoided <ref> [7, 15, 18] </ref>. For program understanding and assistance in locating the sources of errors, existing techniques can identify all statements in a program, including those that reach across procedure boundaries, that affect a given statement [9, 10]. <p> This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies <ref> [7, 15, 18] </ref> and incremental testing techniques [6, 8, 14, 19] can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information. <p> The algorithms that use these graphs to gather the interprocedural information are described but details are omitted from this presentation. More detailed discussions can be found in Ryder [16], Callahan [2], Harrold and Soffa <ref> [7] </ref> and Horwitz, Reps and Binkley [9]. We present the details for handling reference parameters; global variables can be handled similarly. In Section 3, the UIG is presented, including details of its construction and adaptations of the existing interprocedural algorithms. Con cluding remarks are given in Section 4. 2. <p> For example, the PSG cannot be used directly to determine the locations of uses of actual parameter sum that can be reached from the call site in line 6 of program Sums. However, a variation of the PSG, the interprocedural ow graph (IFG) and its associated data ow algorithm <ref> [7] </ref>, provides information at each node about the locations of uses of reference parameters and global variables that can be reached across procedure boundaries.
Reference: 8. <author> M. J. Harrold and M. L. Soffa, </author> <title> ``Selecting Data for Integration Testing,'' </title> <journal> IEEE Software, special issue on testing and debugging, </journal> <month> March </month> <year> 1991. </year> <title> rrrrrrrrrrrrrrrrrr Copyright (C) 1987, 1989 Free Software Foundation, </title> <publisher> Inc, </publisher> <address> 675 Mass Avenue, Cambridge, MA 02139. </address>
Reference-contexts: This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies [7, 15, 18] and incremental testing techniques <ref> [6, 8, 14, 19] </ref> can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information. <p> Use sets are also computed for entry and return nodes, but are omitted from and use pairs for testing. For data ow testing [5, 11, 13], the definition and use pairs are computed using the IFG and propagation algorithm described above <ref> [8] </ref>. Then, test cases are generated to traverse subpaths from the definitions to the uses during program execution. A subpath must contain no redefinition of the variable.
Reference: 9. <author> S. Horwitz, T. Reps, and D. Binkley, </author> <title> ``Interprocedural slicing using dependence graphs,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 26-60, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: For program understanding and assistance in locating the sources of errors, existing techniques can identify all statements in a program, including those that reach across procedure boundaries, that affect a given statement <ref> [9, 10] </ref>. This subset of all program statements is also used to identify those statements that can be scheduled in parallel [12] and may assist in the generation of test cases. <p> The algorithms that use these graphs to gather the interprocedural information are described but details are omitted from this presentation. More detailed discussions can be found in Ryder [16], Callahan [2], Harrold and Soffa [7] and Horwitz, Reps and Binkley <ref> [9] </ref>. We present the details for handling reference parameters; global variables can be handled similarly. In Section 3, the UIG is presented, including details of its construction and adaptations of the existing interprocedural algorithms. Con cluding remarks are given in Section 4. 2. <p> Such information is required for debugging and identifying the statements that can execute in parallel. A variation of the call graph that models a program's control dependencies is the system dependence graph <ref> [9] </ref>. The system dependence graph combines the dependence graphs for the individual procedures [4] with additional nodes and edges to permit the computing of an interprocedural slice of the program. <p> A slice of a program with respect to program point p and variable x consists of all statements and predicates of the program that might affect the value of x at point p <ref> [9] </ref>. To construct the system dependence graph, nodes are added to a procedure's dependence graph to model parameter passing. Parameter passing is represented by a call-site node and by four types of parameter nodes: actual-in, actual-out, formal-in and formal-out. <p> The use of y in line 13 of Sums, U 1 , is the only nonempty use set and is attached to node 3. ___________________________________________________________________________________________________ formal and actual parameters. The interprocedural control information at call sites is determined using an algorithm by Horwitz, Reps and Binkley <ref> [9] </ref> and used to create the inter-control edges.
Reference: 10. <author> J. C. Hwang, M. W. Du, and C. R. Chou, </author> <title> ``Finding program slices for recursive procedures,'' </title> <booktitle> Proceedings of IEEE COMPSAC 88, </booktitle> <month> October </month> <year> 1988. </year>
Reference-contexts: For program understanding and assistance in locating the sources of errors, existing techniques can identify all statements in a program, including those that reach across procedure boundaries, that affect a given statement <ref> [9, 10] </ref>. This subset of all program statements is also used to identify those statements that can be scheduled in parallel [12] and may assist in the generation of test cases.
Reference: 11. <author> B. Korel and J. Laski, </author> <title> ``A tool for data ow oriented program testing,'' </title> <booktitle> ACM Softfair Proceedings, </booktitle> <pages> pp. 35-37, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Other uses that can be reached over procedure boundaries are attached to call and exit nodes. Use sets are also computed for entry and return nodes, but are omitted from and use pairs for testing. For data ow testing <ref> [5, 11, 13] </ref>, the definition and use pairs are computed using the IFG and propagation algorithm described above [8]. Then, test cases are generated to traverse subpaths from the definitions to the uses during program execution. A subpath must contain no redefinition of the variable.
Reference: 12. <author> B. Malloy, </author> <title> A fine grained approach to scheduling asynchronous multiprocessors , Ph.D. </title> <type> Thesis, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: This subset of all program statements is also used to identify those statements that can be scheduled in parallel <ref> [12] </ref> and may assist in the generation of test cases. To determine whether iterations of a loop containing a call statement can be executed in parallel, information about the effects of the call on reference parameters and global variables can be computed [2].
Reference: 13. <author> S. C. Ntafos, </author> <title> ``An evaluation of required element testing strategies,'' </title> <booktitle> Proceedings of the 7th International Conference on Software Engineering, </booktitle> <pages> pp. 250-256, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: Other uses that can be reached over procedure boundaries are attached to call and exit nodes. Use sets are also computed for entry and return nodes, but are omitted from and use pairs for testing. For data ow testing <ref> [5, 11, 13] </ref>, the definition and use pairs are computed using the IFG and propagation algorithm described above [8]. Then, test cases are generated to traverse subpaths from the definitions to the uses during program execution. A subpath must contain no redefinition of the variable.
Reference: 14. <author> T. J. Ostrand and E. J. Weyuker, </author> <title> ``Using data ow analysis for regression testing,'' </title> <booktitle> Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pp. 58-71, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies [7, 15, 18] and incremental testing techniques <ref> [6, 8, 14, 19] </ref> can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information.
Reference: 15. <author> L. L. Pollock and M. L. Soffa, </author> <title> ``An incremental version of iterative data ow analysis,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-11, no. 12, </volume> <pages> pp. 1537-1549, </pages> <month> December, </month> <year> 1989. </year>
Reference-contexts: Currently, techniques do exist to assist in intrapro-cedural and interprocedural activities during maintenance. A program can be modified by incrementally updating its representation to reect the program changes so that complete reanalysis of the source code is avoided <ref> [7, 15, 18] </ref>. For program understanding and assistance in locating the sources of errors, existing techniques can identify all statements in a program, including those that reach across procedure boundaries, that affect a given statement [9, 10]. <p> This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies <ref> [7, 15, 18] </ref> and incremental testing techniques [6, 8, 14, 19] can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information.
Reference: 16. <author> B. G. Ryder, </author> <title> ``Constructing the call graph of a program,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-5, no. 3, </volume> <pages> pp. 216-225, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: The algorithms that use these graphs to gather the interprocedural information are described but details are omitted from this presentation. More detailed discussions can be found in Ryder <ref> [16] </ref>, Callahan [2], Harrold and Soffa [7] and Horwitz, Reps and Binkley [9]. We present the details for handling reference parameters; global variables can be handled similarly. In Section 3, the UIG is presented, including details of its construction and adaptations of the existing interprocedural algorithms. <p> Edge (Sums,Acc), labeled with actual parameters, sum and i, represents the call to procedure Acc at line 6. Other call sites are represented by edges (Acc,Inc), (Acc,Add) and (Inc,Add) and correspond to lines 14, 15 and 19 respectively. A program's call graph can be constructed efficiently <ref> [16] </ref> and used for many different applications. Since a call graph represents the procedural structure of a program and illustrates the calling relationships among procedures, it is useful during maintenance for program understanding. A call graph is also useful for interproce-dural data ow analysis.
Reference: 17. <author> B. G. Ryder, </author> <title> ``An application of static program analysis to software maintenance,'' </title> <booktitle> Proceedings of the 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pp. 82-91, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A call graph is also useful for interproce-dural data ow analysis. Interprocedural data ow analysis algorithms that use a call graph are ow-insensitive since they do not consider the control ow of individual procedures <ref> [1, 3, 17, 20] </ref>. However, ow-insensitive inter-procedural data ow analysis algorithms can determine whether an actual reference parameter may be defined or used by a call to a procedure.
Reference: 18. <author> B. G. Ryder and M. C. Paull, </author> <title> ``Incremental data-ow analysis,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Currently, techniques do exist to assist in intrapro-cedural and interprocedural activities during maintenance. A program can be modified by incrementally updating its representation to reect the program changes so that complete reanalysis of the source code is avoided <ref> [7, 15, 18] </ref>. For program understanding and assistance in locating the sources of errors, existing techniques can identify all statements in a program, including those that reach across procedure boundaries, that affect a given statement [9, 10]. <p> This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies <ref> [7, 15, 18] </ref> and incremental testing techniques [6, 8, 14, 19] can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information.
Reference: 19. <author> A. M. Taha, S. M. Thebut, and S. S. Liu, </author> <title> ``An approach to software fault localization and revalidation based on incremental data ow analysis,'' </title> <booktitle> Proceedings of COMPSAC 89 , pp. </booktitle> <pages> 527-534, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This information permits an existing program to be adapted for parallel processing. For testing the individual procedures or the interfaces among interacting procedures, incremental data ow analysis techniques can identify the data dependencies [7, 15, 18] and incremental testing techniques <ref> [6, 8, 14, 19] </ref> can assist in regression testing. Although these techniques facilitate modifying, analyzing, understanding, testing and debugging programs with many modules, each technique requires a different program representation along with algorithms that use the representation to compute the desired information.
Reference: 20. <author> L. Torczan and K. Kennedy, </author> <title> ``Efficient computation of ow insensitive interprocedural summary information,'' </title> <booktitle> Proceedings SIGPLAN '84 Symposium on Compiler Construction, SIGPLAN Notices, </booktitle> <volume> vol. 19, no. 6, </volume> <month> June </month> <year> 1984. </year>
Reference-contexts: A call graph is also useful for interproce-dural data ow analysis. Interprocedural data ow analysis algorithms that use a call graph are ow-insensitive since they do not consider the control ow of individual procedures <ref> [1, 3, 17, 20] </ref>. However, ow-insensitive inter-procedural data ow analysis algorithms can determine whether an actual reference parameter may be defined or used by a call to a procedure.
References-found: 20

