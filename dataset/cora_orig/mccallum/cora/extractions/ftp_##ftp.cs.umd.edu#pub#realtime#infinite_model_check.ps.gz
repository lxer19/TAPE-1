URL: ftp://ftp.cs.umd.edu/pub/realtime/infinite_model_check.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Title: Symbolic Model Checking of Infinite State Systems Using Presburger Arithmetic 1  
Author: Tevfik Bultan, Richard Gerber and William Pugh 
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science University of Maryland,  
Abstract: Model checking is a powerful technique for analyzing large, finite-state systems. In an infinite transition system, however, many basic properties are undecidable. In this paper we present a new symbolic model checker which conservatively evaluates safety and liveness properties on infinite-state programs. We use Presburger formulas to symbolically encode a program's transition system, as well as its model-checking computations. All fixpoint calculations are executed symbolically, and their convergence is guaranteed by using approximation techniques. We demonstrate the promise of this technology on some well-known infinite-state concurrency problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: Since our basic temporal operators require similar computations, we were able to successfully use this method in conjunction with the Omega library. Finally, our encoding of program states is similar to that used by Alur et al. in verifying hybrid systems <ref> [1, 2] </ref>. A hybrid system is a discrete control automaton, which interacts with continuously-changing, external parameters.
Reference: [2] <author> R. Alur, T. A. Henzinger, and P. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Transactions on Software Engineering 22(3), </journal> <month> March </month> <year> 1996. </year>
Reference-contexts: Since our basic temporal operators require similar computations, we were able to successfully use this method in conjunction with the Omega library. Finally, our encoding of program states is similar to that used by Alur et al. in verifying hybrid systems <ref> [1, 2] </ref>. A hybrid system is a discrete control automaton, which interacts with continuously-changing, external parameters.
Reference: [3] <author> G. R. Andrews. </author> <title> Concurrent Programming, </title> <booktitle> Principles and Practice. 1991, </booktitle> <publisher> The Benjamin/Cummings Publishing Company. </publisher>
Reference-contexts: But perhaps more importantly, one may wish to analyze an algorithm as an abstraction, and prove its correctness in a general sense, for any implementation of integers. In this paper we demonstrate our model checker's effectiveness on some classical infinite-state programs, taken from the concurrency literature <ref> [3, 23] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. <p> Each event is represented with an enabling condition and an action, where the enabling condition constrains the states in which the event can occur, and the action defines a transformation on the variables of the program. Consider the concurrent program shown in Figure 1, which implements the bakery algorithm <ref> [3] </ref> to achieve mutual exclusion between two processes. <p> 2 = W 2 ^ b s action: pc 0 2 = C 2 e C 2 enabled: pc 2 = C 2 action: pc 0 2 = T 2 ^ s 0 = s + 1 Indeed, our exact analyzer diverged when we fed it the so-called ticket algorithm <ref> [3] </ref>, along with its related mutual exclusion property. The program text is presented in Figure 3. In particular, note its similarity to the bakery algorithm.
Reference: [4] <author> A. Arnold. </author> <title> Finite Transition Systems: Semantics of Communicating Systems. </title> <address> New Jersey, 1994, </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Unlike Clarke et al. [8], we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths <ref> [4] </ref> (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: [5] <author> R. E. Bryant. </author> <title> Symbolic Boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 19] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 16]).
Reference: [6] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite-state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [6, 8] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 19]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, <p> Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 19] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 16]). <p> Of course, in any computer system variables are eventually mapped to finite representations. Thus it might be argued that integer variables can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [6, 19] </ref>. For two reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis.
Reference: [7] <author> T. Bultan, J. Fischer, and R. Gerber. </author> <title> Compositional verification by model checking for counter-examples. </title> <booktitle> In Proc. of ACM Sigsoft ISSTA'96, </booktitle> <pages> pages 224-238, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 19]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 16] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: [8] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> (April </month> <year> 1986). </year>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite-state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [6, 8] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 19]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, <p> A path (s 0 ; s 1 ; s 2 ; : : :) is a (finite or infinite) sequence of states, such that for each successive pair of states (s i ; s i+1 ) 2 X. Unlike Clarke et al. <ref> [8] </ref>, we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths [4] (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: [9] <author> E. M. Clarke, O. Grumberg, D. E. </author> <title> Long Model checking and abstraction. </title> <booktitle> In Proc. of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. In <ref> [9] </ref>, Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g. via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction.
Reference: [10] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proc. of the 4th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 19]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 16] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: [11] <author> D. C. Cooper. </author> <title> Programs for mechanical program verification. </title> <booktitle> In Machine Intelligence 6, </booktitle> <editor> B. Meltzer and D. Michie, editors, </editor> <address> pages 43-59, New York, 1971, </address> <publisher> American Elsevier. </publisher>
Reference-contexts: There may be cases where abstraction methods can vastly reduce the size of the state space without achieving a finite representation. In these cases our model checker can be used on the infinite abstract models. Our work has some historical antecedents. Cooper <ref> [11] </ref> developed a technique which encodes transition relations as sets of Presburger formulas, and then converts queries about a program's properties to validity checks in Presburger arithmetic.
Reference: [12] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: Hence, we have found it more beneficial to use model checking as our primary technology, and use a Presburger solver for some subservient set-theoretic computations. Our work was also influenced by known techniques from abstract interpretation <ref> [12, 13] </ref>; specifically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Thus the fixpoint of the ^ Q i 's is an upper approximation to the least fixpoint of the Q i 's. To generate the ^ Q i 's, we currently adopt a method developed by Cousot and Cousot, within the framework of abstract interpretation <ref> [12] </ref>. That is, we define an operator called widening, or "5", which majorizes the union computation as follows: For any pair of sets P; P 0 , P [ P 0 P 5 P 0 .
Reference: [13] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, 1978, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Hence, we have found it more beneficial to use model checking as our primary technology, and use a Presburger solver for some subservient set-theoretic computations. Our work was also influenced by known techniques from abstract interpretation <ref> [12, 13] </ref>; specifically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Our goal is to find a widening operator which (1) yields a suitable (i.e., reasonably tight) upper bound for union, and (2) forces the ^ Q i sequences to converge. In defining our widening operator, we generalized a technique used by Cousot and Halbwachs in <ref> [13] </ref>. The idea is to "guess" the direction of growth in the model-checker's Q i iterates, and to extend the successive iterates in these directions. Cousot and Halbwachs' widening operator b 5 does this for convex polyhedra - i.e., regions formed by a conjunction of affine constraints.
Reference: [14] <author> J. Dingel, and T. Filkorn. </author> <title> Model checking for infinite state systems using data abstraction, assumption-commitment style reasoning and theorem proving. </title> <booktitle> Proceedings of CAV'95, LNCS 939, </booktitle> <year> 1995. </year>
Reference-contexts: In [9], Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g. via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction. In <ref> [14] </ref>, Dingel and Filkorn extend this method using "assumption-commitment" style reasoning and theorem proving. While these techniques require the user to find the appropriate abstractions and hence are not completely automatable we see them as being orthogonal to our approach.
Reference: [15] <author> M. J. Fischer and M. O. Rabin. </author> <title> Super-Exponential Complexity of Presburger Arithmetic. </title> <booktitle> SIAM-AMS Proceedings, </booktitle> <volume> Volume 7, </volume> <pages> pages 27-41, </pages> <year> 1974. </year>
Reference-contexts: In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive, with a deterministic upper bound of 2 2 2 pn (for some constant p &gt; 1) [20], and a nondeterministic lower bound of 2 2 cn (for some constant c &gt; 0) <ref> [15] </ref>, where n denotes the length of the formula. Yet we have found that the Omega library [17, 21] is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers.
Reference: [16] <author> P. Godefroid. </author> <title> Partial-order methods for the verification of concurrent systems: An approach to the state-explosion problem. </title> <type> Ph.D. Thesis, </type> <institution> Universite De Liege, </institution> <year> 1994. </year>
Reference-contexts: [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [5, 6, 19]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [7, 10, 16] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: [17] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Wonnacott. </author> <title> The Omega Library (version 1.00) interface guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: model checker to attack this problem, which is based on the following key concepts: * Symbolically encoding transition relations and sets of states using affine constraints on integer variables, logical connectives and quantifiers (i.e., Presburger formulas). * Efficiently manipulating these formulas (via a fast Presburger solver called the Omega library <ref> [17, 21] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. * Using conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. Of course, in any computer system variables are eventually mapped to finite representations. <p> Yet we have found that the Omega library <ref> [17, 21] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> After partitioning of the state space, we use the Omega library <ref> [17] </ref> to help symbolically compute the truth sets for the temporal properties at hand.
Reference: [18] <author> W. Kelly, and W. Pugh. </author> <title> Using affine closure to find legal reordering transformations. </title> <journal> International Journal of Parallel Programming, </journal> <year> 1995. </year>
Reference-contexts: The Omega library includes a large collection of object classes to efficiently manipulate Presburger formulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [18, 21, 22] </ref>. The particular Omega functions we use are shown in Figure 2. These functions take symbolic representations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output. <p> While our multiple-polyhedra widening approximation helped solve two of the problems in this paper, it can often be rather coarse. In general it sacrifices precision for finite termination. We are currently developing more precise methods for reachability properties using transitive closure computation techniques for Presburger formulas <ref> [18] </ref>. As we acquire more experience with both types of approximations, we hope to determine which techniques work best for different classes of programs, and why. We are also working on developing better state partitioning techniques.
Reference: [19] <author> K. L. McMillan. </author> <title> Symbolic model checking. </title> <address> Massachusetts, 1993, </address> <publisher> Kluwer Academic Publishers. </publisher>
Reference-contexts: Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [6, 8]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [5, 6, 19] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [7, 10, 16]). <p> Of course, in any computer system variables are eventually mapped to finite representations. Thus it might be argued that integer variables can be given a finite range, and programs can then be analyzed as finite-state machines for example, using BDD's <ref> [6, 19] </ref>. For two reasons, however, this may not always be the best way to proceed. First, mapping integer variables and operations to their binary implementations may lead to highly inefficient static analysis. <p> So when these monotonically increasing sequences reach a fixpoint, we know that it is the least fixpoint <ref> [19] </ref>. These methods lead directly to the semi-decision procedure shown in Figure 2 (B).
Reference: [20] <author> D. C. Oppen. </author> <title> A 2 2 2 pn upper bound on the complexity of Presburger arithmetic. </title> <journal> Journal of Computer and System Sciences 16 </journal> <pages> 323-332, </pages> <year> (1978). </year>
Reference-contexts: An important property of Presburger arithmetic is that validity is decidable. In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive, with a deterministic upper bound of 2 2 2 pn (for some constant p &gt; 1) <ref> [20] </ref>, and a nondeterministic lower bound of 2 2 cn (for some constant c &gt; 0) [15], where n denotes the length of the formula.
Reference: [21] <author> W. Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-104, </pages> <month> (August </month> <year> 1992). </year>
Reference-contexts: model checker to attack this problem, which is based on the following key concepts: * Symbolically encoding transition relations and sets of states using affine constraints on integer variables, logical connectives and quantifiers (i.e., Presburger formulas). * Efficiently manipulating these formulas (via a fast Presburger solver called the Omega library <ref> [17, 21] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. * Using conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. Of course, in any computer system variables are eventually mapped to finite representations. <p> Yet we have found that the Omega library <ref> [17, 21] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> The Omega library includes a large collection of object classes to efficiently manipulate Presburger formulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [18, 21, 22] </ref>. The particular Omega functions we use are shown in Figure 2. These functions take symbolic representations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output.
Reference: [22] <author> W. Pugh and D. Wonnacott. </author> <title> Static analysis of upper and lower bounds on dependences and parallelism. </title> <journal> ACM Transac tions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 1248-1278, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The Omega library includes a large collection of object classes to efficiently manipulate Presburger formulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [18, 21, 22] </ref>. The particular Omega functions we use are shown in Figure 2. These functions take symbolic representations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output.
Reference: [23] <author> A. Udaya Shankar. </author> <title> An introduction to assertional reasoning for concurrent systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(3):225 262, </volume> <month> (September </month> <year> 1993). </year> <month> 10 </month>
Reference-contexts: But perhaps more importantly, one may wish to analyze an algorithm as an abstraction, and prove its correctness in a general sense, for any implementation of integers. In this paper we demonstrate our model checker's effectiveness on some classical infinite-state programs, taken from the concurrency literature <ref> [3, 23] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. <p> After formally defining conservative approximations, we discuss the specific approximation techniques for computing upper and lower bounds of fixpoints. Finally, we conclude with some discussion on our results. 2 Representation of Programs and Properties We use the event-action language from <ref> [23] </ref> as our syntax for concurrent programs, with a semantics defined in terms of infinite transition systems. <p> Most importantly, we can also use this technique when we compute approximate backward fixpoints, as defined above. We demonstrate this method on a bounded-buffer producer-consumer problem adapted from an example in <ref> [23] </ref>, as shown in Figure 4. This program implements an instance of the problem with one producer and two consumers. We wish to prove that 82 (0 p (c 1 + c 2 ) s) holds, i.e., that the bounded buffer properties are satisfied.
References-found: 23

