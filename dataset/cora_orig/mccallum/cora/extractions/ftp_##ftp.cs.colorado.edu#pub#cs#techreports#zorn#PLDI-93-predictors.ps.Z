URL: ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/PLDI-93-predictors.ps.Z
Refering-URL: 
Root-URL: 
Title: Using Lifetime Predictors to Improve Memory Allocation Performance  
Author: David A. Barrett and Benjamin G. Zorn 
Address: Campus Box #430  Boulder 80309-0430  
Affiliation: Department of Computer Science  University of Colorado,  
Abstract: Dynamic storage allocation is used heavily in many application areas including interpreters, simulators, optimizers, and translators. We describe research that can improve all aspects of the performance of dynamic storage allocation by predicting the lifetimes of short-lived objects when they are allocated. Using five significant, allocation-intensive C programs, we show that a great fraction of all bytes allocated are short-lived (&gt; 90% in all cases). Furthermore, we describe an algorithm for lifetime prediction that accurately predicts the lifetimes of 42-99% of all objects allocated. We describe and simulate a storage allocator that takes advantage of lifetime prediction of short-lived objects and show that it can significantly improve a program's memory overhead and reference locality, and even, at times, improve CPU performance as well. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Table 9 shows the average number of instructions to allocate and free objects in four allocation algorithms. The numbers for the first two algorithms (BSD and First-fit) were computed directly from actual implementations using the QP <ref> [1] </ref> instruction profiling tool. The numbers for the Arena algorithms were computed using operation counts (e.g., allocations, frees, etc), multiplying them by the estimated cost per operation.
Reference: [2] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> SoftwarePractice and Experience, </journal> <pages> pages 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Our approach can improve the performance of generational collectors by predicting object lifetimes when they are born. Object size information has also been used to improve allocator performance. The conservative garbage collector described by Boehm and Weiser <ref> [2] </ref> uses size to segregate objects but does not attempt to predict object lifetimes. They mention, however, that memory overhead would be improved if living objects were seg-regated from dead objects.
Reference: [3] <author> Larry Carter. </author> <title> Discussion of efficient encoding of call-chain information. </title> <type> Personal communication, </type> <month> September </month> <year> 1992. </year>
Reference-contexts: We propose two alternatives to determining the allocation site. The measurements in Table 6 suggest that exclusive-ORing the size with the last four return addresses should yield results comparable to using the entire call-chain. As an alternative to calculating the callers at each allocation, Carter <ref> [3] </ref> suggests the following approach 1 Objects larger than a specific size are allocated by the general purpose allocator.
Reference: [4] <author> Alan Demers, Mark Weiser, Barry Hayes, Hans Boehm, Daniel Bo-brow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The conservative garbage collector described by Boehm and Weiser [2] uses size to segregate objects but does not attempt to predict object lifetimes. They mention, however, that memory overhead would be improved if living objects were seg-regated from dead objects. In later related work, Demers et al <ref> [4] </ref> use an object's allocation site (based on the current stack pointer) to predict object lifetimes. Our work expands upon theirs and presents detailed measurements of the effectiveness of the lifetime prediction approach.
Reference: [5] <author> John DeTreville. </author> <title> Experience with concurrent garbage collectors for modula-2+. </title> <type> Technical Report 64, </type> <institution> Digital Equipment Corporation System Research Center, </institution> <address> Palo Alto, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: The allocation site specifies where the object was created in the control sequence of the program and the size specifies how much memory is required by that object. When available, the object's type or class can also be used <ref> [5, 6] </ref>, but we chose to only use the allocation site and size because the type of an object is not directly available at C birth events.
Reference: [6] <author> A. Diwan, E. Moss, and R. Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <volume> volume 27, </volume> <pages> pages 273-282, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The allocation site specifies where the object was created in the control sequence of the program and the size specifies how much memory is required by that object. When available, the object's type or class can also be used <ref> [5, 6] </ref>, but we chose to only use the allocation site and size because the type of an object is not directly available at C birth events.
Reference: [7] <author> Joseph A. Fisher and Stefan M.Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 85-95, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Most recently, Fisher and Freudenberger report considerable success in using previous runs of a program to perform branch-prediction optimizations in large C and Fortran programs <ref> [7] </ref>. Grunwald and Zorn [9] describe a tool called CUSTOMALLOC that performs profile-based optimization of DSA algorithms. In their work, information collected from previous program executions is used to automatically generate high-speed explicit alloca-tors. However, no optimization based upon predicted lifetimes is performed in their work.
Reference: [8] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: Because recursive calls add no additional information, we chose to prune out all recursive loops in the definition of the call-chain. Users of the gprof execution profiler will be familiar with this approach of collapsing cycles in the dynamic call graph <ref> [8] </ref>. In our studies, we consider the entire call-chain to see how much information would be available in the ideal case, and sub-chains of the complete call-chain as well. In practice, the sequence of calls in the call-chain may be very deep.
Reference: [9] <author> Dirk Grunwald and Benjamin Zorn. </author> <title> CUSTOMALLOC: Efficient synthesized memory allocators. </title> <type> Technical Report CU-CS-602-92, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Most recently, Fisher and Freudenberger report considerable success in using previous runs of a program to perform branch-prediction optimizations in large C and Fortran programs [7]. Grunwald and Zorn <ref> [9] </ref> describe a tool called CUSTOMALLOC that performs profile-based optimization of DSA algorithms. In their work, information collected from previous program executions is used to automatically generate high-speed explicit alloca-tors. However, no optimization based upon predicted lifetimes is performed in their work. This paper has the following organization.
Reference: [10] <author> David R. Hanson. </author> <title> Fast allocation and deallcoation of memory based on object lifetimes. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 20(1) </volume> <pages> 5-12, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In related work, Hanson describes the advantages of segregating short-lived objects, in his case by having the programmer explicitly specify what is short-lived <ref> [10] </ref>. Our work automates Hanson's algorithm by using the allocation site (an abstraction of the call-stack) and object size to identify and segregate short-lived objects. Using five significant, allocation-intensive C programs, we show that a great fraction of all bytes allocated are short-lived. <p> In later related work, Demers et al [4] use an object's allocation site (based on the current stack pointer) to predict object lifetimes. Our work expands upon theirs and presents detailed measurements of the effectiveness of the lifetime prediction approach. In work that is closely related to ours, Hanson <ref> [10] </ref> describes how segregating objects by lifetime improves the performance of DSA algorithms. His results show that segregation can dramatically reduce the cost of allocation and deallocation of short-lived objects. <p> For the purpose of improving a memory allocation system, we would like to group objects with similar lifetimes together. One method is to find especially short-lived objects and place them into a segregated area of memory or arena (after Hanson <ref> [10] </ref>). To predict that a particular allocation site will allocate short-lived objects, we look at the quantile histogram for that site. If a large percentage of the objects allocated at that site are short-lived, we consider that site to be an excellent predictor of short-lived objects. <p> When an object is allocated, the allocation system uses this database of allocation sites to select one of two strategies: one specific to the short-lived allocation sites, and a general one for all others. The short-lived objects are allocated using an algorithm very similar to Hanson's <ref> [10] </ref>. Each short-lived arena has a fixed size that is relatively small (8-32 kilobytes) 1 . In addition to the objects, each arena contains one pointer (alloc) and a count field that identifies how many objects in the arena are currently alive.
Reference: [11] <author> Barry Hayes. </author> <title> Using key object opportunism to collect old objects. </title> <booktitle> In OOPSLA'91 Conference Proceedings, </booktitle> <pages> pages 33-46, </pages> <address> Phoenix, AZ, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: We enhance Hanson's algorithm by using the behavior of previous program executions to automatically generate an allocator customized for short-lived objects. Our work uses the state of the dynamic call-stack to predict object lifetimes. Other researchers have used the call-stack as a predictor as well. In particular, Hayes <ref> [11] </ref> and Wilson [21] use stack deallocation events to detect clustering of object deaths and trigger garbage collections. Their work uses the heuristic that a small call-stack predicts there will be more garbage available for collection and hence collection algorithms should be invoked if possible when the stack is low. <p> The demands placed upon the allocator are directly proportional to the rate of these events rather than elapsed time. Two time measurements based on allocations are easily available: the number of allocation events or the number of bytes allocated <ref> [11] </ref>. We chose the latter because it more closely reflects the demands placed upon the memory system. The call-chain of an event corresponds to an abstraction of the program's call-stack at the time that the event occurred.
Reference: [12] <author> Raj Jain and Imrich Chlamtac. </author> <title> The P2 algorithm for dynamic calculation of quantiles and histograms without storing observations. </title> <journal> Communications of the ACM, </journal> <volume> 28(10) </volume> <pages> 1076-1085, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: A given allocation site creates many objects of varying lifetimes. We measure the associated lifetime distribution of each allocation site using Jain's quantile histogram algorithm <ref> [12] </ref>, which generates approximations of a set of quantiles for a distribution. We use Jain's algorithm because it allows us to compute the quantiles with minimal storage requirements.
Reference: [13] <author> Donald E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming, chapter 2, </booktitle> <pages> pages 435-451. </pages> <publisher> Addison Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1973. </year>
Reference-contexts: The output of the simulator gives operation counts, information about the fraction of objects and bytes allocated in arenas, heap size, and fragmentation measurements. In our experiments, we compare the performance of a lifetime predicting arena-allocator with a relatively simple first-fit algorithm with enhancements described by Knuth <ref> [13] </ref>. We chose to compare the arena allocator with the first-fit algorithm for two reasons. First, the first-fit allocator often has relatively good memory utilization characteristics, and as such serves as a fair baseline for comparing the memory usage of the arena allocator.
Reference: [14] <author> James R. Larus. </author> <title> Abstract execution: A technique for efficiently tracing programs. </title> <journal> Software Practice and Experience, </journal> 20(12) 1241-1258, December 1990. 
Reference-contexts: We measured the allocation behavior of each of these programs by instrumenting them with Larus' AE trace generation tool <ref> [14] </ref>. Table 1 describes the programs and their input sets and Table 2 summarizes the execution behavior of these programs.
Reference: [15] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Other researchers have designed memory allocation systems based upon various characteristics of object allocation behavior. For example, generational garbage collectors exploit the general observation that objects tend to be short-lived <ref> [15, 18, 16] </ref>. Our approach can improve the performance of generational collectors by predicting object lifetimes when they are born. Object size information has also been used to improve allocator performance.
Reference: [16] <author> David A. Moon. </author> <title> Garbage collection in a large Lisp system. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 235-246, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: Other researchers have designed memory allocation systems based upon various characteristics of object allocation behavior. For example, generational garbage collectors exploit the general observation that objects tend to be short-lived <ref> [15, 18, 16] </ref>. Our approach can improve the performance of generational collectors by predicting object lifetimes when they are born. Object size information has also been used to improve allocator performance.
Reference: [17] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Series in Computer Science. Addison-Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1991. </year>
Reference-contexts: Furthermore, object-oriented programming languages, such as C++, encourage a programming style that uses more dynamic memory allocation than their predecessors. But dynamic storage allocation has been criticized because it is not as efficient as static allocation <ref> [17, p. 465] </ref>. Indeed, programmers frequently write their own domain-specific allocation routines to attempt to increase the performance of their programs [22].
Reference: [18] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In SIGSOFT/SIGPLAN Practical Programming Environments Conference, </booktitle> <pages> pages 157-167, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Other researchers have designed memory allocation systems based upon various characteristics of object allocation behavior. For example, generational garbage collectors exploit the general observation that objects tend to be short-lived <ref> [15, 18, 16] </ref>. Our approach can improve the performance of generational collectors by predicting object lifetimes when they are born. Object size information has also been used to improve allocator performance.
Reference: [19] <author> David Ungar and Frank Jackson. </author> <title> An adaptive tenuring policy for generation scavengers. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 1-27, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: This result confirms a similar observation made by Ungar and Jackson about the correlation of size and lifetime in Smalltalk programs <ref> [19] </ref>. Another way to reduce the cost of lifetime prediction is to use less than the complete call-chain to predict lifetimes. To determine the effect of reduced information, we examined what happened to the predictions if the complete call-chain in the allocation site length was restricted to a length-N sub-chain.
Reference: [20] <author> David W. Wall. </author> <title> Predicting program behavior using real or estimated profiles. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <volume> volume 26, </volume> <pages> pages 59-70, </pages> <address> Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: However, we use the contents of the stack and not just the size. There has also been a recent flurry of research in the area of profile-based optimization. Wall has investigated the problem of determining how well execution profiles predict actual behavior <ref> [20] </ref>. He concludes that profile-based optimization is more accurate than static attempts to determine where programs spend time and what global variables are used most often.
Reference: [21] <author> Paul R. Wilson. </author> <title> Opportunistic garbage collection. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(12) </volume> <pages> 98-102, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Our work uses the state of the dynamic call-stack to predict object lifetimes. Other researchers have used the call-stack as a predictor as well. In particular, Hayes [11] and Wilson <ref> [21] </ref> use stack deallocation events to detect clustering of object deaths and trigger garbage collections. Their work uses the heuristic that a small call-stack predicts there will be more garbage available for collection and hence collection algorithms should be invoked if possible when the stack is low.
Reference: [22] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> SoftwarePractice and Experience, </journal> <note> 1993. To appear. </note>
Reference-contexts: But dynamic storage allocation has been criticized because it is not as efficient as static allocation [17, p. 465]. Indeed, programmers frequently write their own domain-specific allocation routines to attempt to increase the performance of their programs <ref> [22] </ref>. In this paper we describe and investigate a method for improving the performance of dynamic storage allocation that automates the process that programmers currently use to increase allocation performance: tune the allocation strategy to the behavior of the program.
Reference: [23] <author> Benjamin Zorn and Dirk Grunwald. </author> <title> Empirical measurements of six allocation-intensive C programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(12) </volume> <pages> 71-80, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: CFRAC shows what happens to this algorithm if too many long-lived objects are erroneously predicted to be short-lived. Recall that 3.65% of the objects in CFRAC were incorrectly predicted as short-lived. Furthermore, empirical measurements of CFRAC show that the object lifetime distribution is very highly skewed <ref> [23] </ref>. That is, while the vast majority of objects allocated by CFRAC are very short-lived, some objects it allocates are extremely long-lived. Therefore, objects incorrectly predicted as short-lived may actually be very long-lived.
References-found: 23

