URL: http://www-lsr.imag.fr/users/Didier.Bert/Papers/ilps95.ps.gz
Refering-URL: http://www-lsr.imag.fr/Les.Groupes/scop/f-publi.html
Root-URL: http://www.imag.fr
Email: fbert,echahedg@imag.fr  
Title: Abstraction of Conditional Term Rewriting Systems  
Author: Didier Bert and Rachid Echahed 
Address: BP 53 F-38041 Grenoble cedex 9, France  
Affiliation: IMAG-LGI,  
Abstract: This paper introduces the notion of abstract domains for constructor-based conditional term rewriting systems and defines the notion of abstract term rewriting systems (abstract TRS) over these domains. These new term rewriting systems are mainly used to determine or to approximate the normal forms of ground instances of concrete terms (with variables). We propose a method to compute such an abstract TRS as the least fixed point of a transformation over abstract TRS's. The computed abstract TRS allows to determine efficiently an approximation of any concrete term. Among the possible applications of the introduced concepts, we quote: improvement of the implementation of functional-logic programming languages, E-unification, satisfiability, proofs by induction, etc. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alpuente, M. Falaschi, M. J. Ramis, and G. Vidal. </author> <title> Narrowing approximations as an optimization for equational logic programs. </title> <booktitle> In Proceedings of the 5th Int. Symp. on Programming Language Implementation and Logic Programming, PLILP-93, number 714 in Lecture Notes in Computer Science, </booktitle> <pages> pages 391-409. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In [5], Chabin and Rety improve the previous method by taking into account terms and subterms rather than top operators. The work of <ref> [1] </ref> considers conditional term rewriting systems. <p> If applied to the following example (given in the Section 1) R = fp (0) ! 0; p (s (x)) ! x; x 0 ! x; x s (y) ! p (x y)g The "abstraction" in the sense of <ref> [1] </ref> of the rewriting system R is R A;nat = fp (0) ! 0; p (s (x)) ! x; x 0 ! x; x s (y) ! p (?)g But, for the goal p (s (0) j) = s (0) the abstract narrowing does not detect its unsatisfiability.
Reference: [2] <author> Didier Bert and Rachid Echahed. </author> <title> Abstraction of conditional term rewriting systems. </title> <type> Technical report RR942.I., </type> <institution> IMAG-LGI, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: At last, we compare our work with other approaches and we show some possible applications in the concluding section 5. Due to lack of space, the proofs have been omitted. They may be consulted in <ref> [2] </ref>. 2 Preliminaries We start by giving some basic definitions needed for the understanding of the paper. Concepts not defined here can be found for example in [7], [13] or [9]. <p> Coming back to term t, we have t rewrites into t 00 = head (t 0 ) = s a (&gt; nat ). From the definition of R up , the following properties can be easily shown <ref> [2] </ref>. Theorem 3.11 (Properties of R up ) Let SP be a constructor-based specifi cation SP = (; R), up a finite upper closure. Then 1. <p> ! ? bool ? bool f alse a f alse a f alse a s a (&gt; nat ) a s a (&gt; nat ) ! ? bool ? bool ? bool &gt; bool &gt; bool From the definition of R up c , we can show the following properties <ref> [2] </ref>. The last property states the soundness of the computed abstract rewriting system R up Theorem 4.4 Let SP = (; R) be a constructor-based specification, up a finite upper closure, R up the up-abstract rewrite system and R up c the computed abstract rewriting system. Then 1.
Reference: [3] <author> Didier Bert, Rachid Echahed, and Bjarte M. Ostvold. </author> <title> Abstract rewriting. </title> <booktitle> In Proceedings of the 3rd International Workshop on Static Analysis, WSA'93, number 724 in Lecture Notes in Computer Science, </booktitle> <pages> pages 178-192. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Moreover their abstraction strategy depends not only on the CTRS but also on the goal. Much work must be done to determine more precisely the respective capabilities of each technique. Finally, the results presented in this paper generalize those of <ref> [3] </ref> in several respects. We have introduced a general framework for the construction of abstract domains of rewriting whereas the one presented in [3] is very limited and does not allow to capture the unsatisfiability or the validity of many trivial examples. <p> Much work must be done to determine more precisely the respective capabilities of each technique. Finally, the results presented in this paper generalize those of <ref> [3] </ref> in several respects. We have introduced a general framework for the construction of abstract domains of rewriting whereas the one presented in [3] is very limited and does not allow to capture the unsatisfiability or the validity of many trivial examples. The main advantage of these new abtract domains amounts to the possibility of tuning the approximation of rewriting as much as needed.
Reference: [4] <author> R. M. Burstall and J. A. Goguen. </author> <title> The semantics of clear, a specification language. </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Abstract Software Specification, Proc. of the Copenhagen Winter School, 1979, number 86 in Lecture Notes in Computer Science, </booktitle> <pages> pages 292-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: It can be built from any term algebra over a signature as a free extension along a "specification morphism". As presented in <ref> [4] </ref> such a morphism is composed of a signature morphism and a set of axioms. Here, the signature morphism introduces the operators needed for abstract computations, whereas the new axioms give the properties of these operators. Definition 3.1 (Herbrand abstract specification) Let be a constructor-based signature where = (S; ).
Reference: [5] <author> J. Chabin and P. Rety. </author> <title> Narrowing directed by a graph of terms. </title> <booktitle> In Proceedings of the 4th International Conference on Rewriting Techniques and Applications, RTA'91, Como, Italy, number 488 in Lecture Notes in Computer Science, </booktitle> <pages> pages 112-123. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1987. </year>
Reference-contexts: Obviously, we can also apply a same kind of reasoning as sketched above in order to improve the resolution of goals of the form t 1 6= t 2 . Several authors have defined techniques to prune the search tree of narrowing. Works [8], <ref> [5] </ref> are based on the inspection of concrete rewrite rules. In [8], the idea is to analyze how the operators at the top of the left-hand sides are replaced by operators on the top of the right-hand sides ; and then compute the set of possible head-constructors of a term. <p> In [8], the idea is to analyze how the operators at the top of the left-hand sides are replaced by operators on the top of the right-hand sides ; and then compute the set of possible head-constructors of a term. In <ref> [5] </ref>, Chabin and Rety improve the previous method by taking into account terms and subterms rather than top operators. The work of [1] considers conditional term rewriting systems.
Reference: [6] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation : A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of the 4th Annual ACM Symposium on Principles of Programming Languages, POPL'77, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: That is to say, a method that helps to stop the E-unification process. Approximation can be done by abstract interpretation. Abstract interpretation is a theory that allows to extract relevant information from programs without considering all the details given by the standard semantics <ref> [6] </ref>. This theory has been applied successfully to several areas [12]. In this paper, we propose a framework that defines abstract interpretation of (conditional) term rewriting systems. We mainly define the notions of abstract domains of terms, abstract rewriting systems and abstract rewriting calculus.
Reference: [7] <author> N. Dershowitz and J. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B: Formal Methods and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Due to lack of space, the proofs have been omitted. They may be consulted in [2]. 2 Preliminaries We start by giving some basic definitions needed for the understanding of the paper. Concepts not defined here can be found for example in <ref> [7] </ref>, [13] or [9].
Reference: [8] <author> Nachum Dershowitz and G. Sivakumar. </author> <title> Solving goals in equational languages. </title> <booktitle> In Proceedings of the 1st International Conference on Conditional Term Rewriting Systems, CTRS'87, Orsay, France, number 308 in Lecture Notes in Computer Science, </booktitle> <pages> pages 45-55. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1987. </year>
Reference-contexts: Obviously, we can also apply a same kind of reasoning as sketched above in order to improve the resolution of goals of the form t 1 6= t 2 . Several authors have defined techniques to prune the search tree of narrowing. Works <ref> [8] </ref>, [5] are based on the inspection of concrete rewrite rules. In [8], the idea is to analyze how the operators at the top of the left-hand sides are replaced by operators on the top of the right-hand sides ; and then compute the set of possible head-constructors of a term. <p> Several authors have defined techniques to prune the search tree of narrowing. Works <ref> [8] </ref>, [5] are based on the inspection of concrete rewrite rules. In [8], the idea is to analyze how the operators at the top of the left-hand sides are replaced by operators on the top of the right-hand sides ; and then compute the set of possible head-constructors of a term.
Reference: [9] <author> Harmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Due to lack of space, the proofs have been omitted. They may be consulted in [2]. 2 Preliminaries We start by giving some basic definitions needed for the understanding of the paper. Concepts not defined here can be found for example in [7], [13] or <ref> [9] </ref>.
Reference: [10] <author> M. Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> Journal of Logic Programming, </journal> 19&20:583-628, 1994. 
Reference-contexts: 1 Introduction During the last few years, many languages have been proposed to combine functional and logic programming paradigms, see for instance <ref> [10] </ref> for a recent survey. The operational semantics of these languages is mainly based on E-unification algorithms using the narrowing relation [11]. This algorithm is very powerful and much work has been done to improve the solving strategies.
Reference: [11] <author> J.-M. Hullot. </author> <title> Canonical forms and unification. </title> <booktitle> In Proc. 5th Conference on Automated Deduction, number 87 in Lecture Notes in Computer Science, </booktitle> <pages> pages 318-334. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: 1 Introduction During the last few years, many languages have been proposed to combine functional and logic programming paradigms, see for instance [10] for a recent survey. The operational semantics of these languages is mainly based on E-unification algorithms using the narrowing relation <ref> [11] </ref>. This algorithm is very powerful and much work has been done to improve the solving strategies. Unfortunately, the search space is often too large and solvers often explore useless branches without realizing, for example, that some goals are unsatisfiable.
Reference: [12] <author> Neil D. Jones and Flemming Nielson. </author> <title> Abstract interpretation: a semantics-based tool for program analysis. </title> <booktitle> In Handbook of Logic in Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <pages> 121 pages. </pages>
Reference-contexts: Approximation can be done by abstract interpretation. Abstract interpretation is a theory that allows to extract relevant information from programs without considering all the details given by the standard semantics [6]. This theory has been applied successfully to several areas <ref> [12] </ref>. In this paper, we propose a framework that defines abstract interpretation of (conditional) term rewriting systems. We mainly define the notions of abstract domains of terms, abstract rewriting systems and abstract rewriting calculus.
Reference: [13] <author> J. W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Vol. II, </volume> <pages> pages 1-112. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year> <title> Previous version: Term rewriting systems, </title> <type> Technical Report CS-R9073, </type> <institution> Stichting Mathematisch Centrum, </institution> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Due to lack of space, the proofs have been omitted. They may be consulted in [2]. 2 Preliminaries We start by giving some basic definitions needed for the understanding of the paper. Concepts not defined here can be found for example in [7], <ref> [13] </ref> or [9].
References-found: 13

