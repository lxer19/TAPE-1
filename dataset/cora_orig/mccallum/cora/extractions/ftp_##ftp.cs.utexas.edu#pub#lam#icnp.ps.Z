URL: ftp://ftp.cs.utexas.edu/pub/lam/icnp.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/lam/NRL/network_security.html
Root-URL: 
Title: Verifying Authentication Protocols: Methodology and Example  
Author: Thomas Y.C. Woo Simon S. Lam 
Address: Austin, Texas 78712-1188  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: We present a new approach to the analysis of authentication protocols. The approach consists of several elements: a specification language for formally specifying authentication protocols, a semantic model for characterizing protocol executions, an assertion language for stating secrecy and correspondence properties, and procedures for verifying these properties. The main emphasis of this paper is on the assertion language, its semantics, and verification procedures. In particular, we present a set of proof rules. We also present an example to illustrate our approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> The Computer Security Foundations Workshop, </institution> <address> Fran-conia, New Hampshire, June 12-14 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [2] <author> M. Abadi and M.R. Tuttle. </author> <title> A semantics for a logic of authentication (extended abstract). </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 201-216, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The informal explanation was widely misunderstood and led directly to the criticism by Nessett in [14]. In fact, the precise meaning of "P k $ Q" only became clear with the publication of a new semantics for BAN logic in <ref> [2] </ref>. Fourth, the analysis in certain approaches is conducted at a very high level of abstraction. The results obtained from such analysis can be easily misinterpreted when trying to relate them to protocol executions. Examples include most of the modal logical approaches [4, 6, 10, 15].
Reference: [3] <author> R.K. Bauer, T.A. Berson, and R.J. Feiertag. </author> <title> A key distribution protocol using event markers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 249-255, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: The design of authentication protocols is highly error-prone, even more so than communication protocols. Indeed, many authentication protocols have been proposed and later found to contain subtle weaknesses or flaws <ref> [3, 6, 8, 12, 13] </ref>. Various formal methods have fl Research supported in part by NSA Computer Security University Research Program under contracts no. MDA 904-91-C7046 and MDA 904-93-C4089, and in part by National Science Foundation grant no. NCR-9004464.
Reference: [4] <author> P. Bieber. </author> <title> A logic of communication in hostile environment. </title> <booktitle> In Proceedings of the The Computer Security Foundations Workshop III [1], </booktitle> <pages> pages 14-22. </pages>
Reference-contexts: In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> Fourth, the analysis in certain approaches is conducted at a very high level of abstraction. The results obtained from such analysis can be easily misinterpreted when trying to relate them to protocol executions. Examples include most of the modal logical approaches <ref> [4, 6, 10, 15] </ref>. We stress, however, that these approaches are certainly useful in their own right. But we also believe that it is important to be able to analyze a protocol at different levels of abstraction.
Reference: [5] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A logic of authentication. </title> <type> Technical Report 39, </type> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <note> February 28 1989. Revised February 22, 1990. An abbreviated version appears in [6]. </note>
Reference-contexts: Such imprecision can lead to difficulties in protocol analysis. In the extreme case, it can allow an intuitively flawed authentication protocol to be proved "correct." A good example of this is the BAN logic construct "P k whose meaning is only informally explained in <ref> [5] </ref>. The informal explanation was widely misunderstood and led directly to the criticism by Nessett in [14]. In fact, the precise meaning of "P k $ Q" only became clear with the publication of a new semantics for BAN logic in [2].
Reference: [6] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A logic of authentication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The design of authentication protocols is highly error-prone, even more so than communication protocols. Indeed, many authentication protocols have been proposed and later found to contain subtle weaknesses or flaws <ref> [3, 6, 8, 12, 13] </ref>. Various formal methods have fl Research supported in part by NSA Computer Security University Research Program under contracts no. MDA 904-91-C7046 and MDA 904-93-C4089, and in part by National Science Foundation grant no. NCR-9004464. <p> In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> Second, the notion of correctness adopted is often limited and does not adequately capture the entire intuitive notion of correctness an authentication protocol designer has in mind. For example, the proposals in [9, 11] adopt secrecy as their main correctness crite-rion; while others <ref> [6, 10] </ref> specify correctness in terms of state of belief and make implicit the secrecy concerns. This discrepancy can lead to potential misinterpretations. Third, the supposedly "formal" notion of correctness is often not sufficiently formalized. Such imprecision can lead to difficulties in protocol analysis. <p> Fourth, the analysis in certain approaches is conducted at a very high level of abstraction. The results obtained from such analysis can be easily misinterpreted when trying to relate them to protocol executions. Examples include most of the modal logical approaches <ref> [4, 6, 10, 15] </ref>. We stress, however, that these approaches are certainly useful in their own right. But we also believe that it is important to be able to analyze a protocol at different levels of abstraction. <p> In this sense, our approach is similar to the BAN logic approach <ref> [6] </ref> and to conventional program verification [7]. We have also successfully used our approach to uncover errors in some protocols that we thought were correct. Typically, this arises in an attempted verification of an assertion. The failed proof usually suggests a counterexample. Our approach is not amenable to full automation.
Reference: [7] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1988. </year>
Reference-contexts: In this sense, our approach is similar to the BAN logic approach [6] and to conventional program verification <ref> [7] </ref>. We have also successfully used our approach to uncover errors in some protocols that we thought were correct. Typically, this arises in an attempted verification of an assertion. The failed proof usually suggests a counterexample. Our approach is not amenable to full automation.
Reference: [8] <author> D.E. Denning and G.M. Sacco. </author> <title> Timestamps in key distribution protocols. </title> <journal> Communications of the ACM, </journal> <volume> 24(8) </volume> <pages> 533-536, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: The design of authentication protocols is highly error-prone, even more so than communication protocols. Indeed, many authentication protocols have been proposed and later found to contain subtle weaknesses or flaws <ref> [3, 6, 8, 12, 13] </ref>. Various formal methods have fl Research supported in part by NSA Computer Security University Research Program under contracts no. MDA 904-91-C7046 and MDA 904-93-C4089, and in part by National Science Foundation grant no. NCR-9004464.
Reference: [9] <author> D. Dolev and A.C. Yao. </author> <title> On the security of public key protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29(2):198-208, </volume> <month> March </month> <year> 1983. </year>
Reference-contexts: In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> In particular, correctness is a specification problem while verification is a procedure problem. Second, the notion of correctness adopted is often limited and does not adequately capture the entire intuitive notion of correctness an authentication protocol designer has in mind. For example, the proposals in <ref> [9, 11] </ref> adopt secrecy as their main correctness crite-rion; while others [6, 10] specify correctness in terms of state of belief and make implicit the secrecy concerns. This discrepancy can lead to potential misinterpretations. Third, the supposedly "formal" notion of correctness is often not sufficiently formalized.
Reference: [10] <author> L. Gong, R.M. Needham, and R. Yahalom. </author> <title> Reasoning about belief in cryptographic protocols. </title> <booktitle> In Proceedings of the 11th IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 234-248, </pages> <address> Oakland, Cali-fornia, May 7-9 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> Second, the notion of correctness adopted is often limited and does not adequately capture the entire intuitive notion of correctness an authentication protocol designer has in mind. For example, the proposals in [9, 11] adopt secrecy as their main correctness crite-rion; while others <ref> [6, 10] </ref> specify correctness in terms of state of belief and make implicit the secrecy concerns. This discrepancy can lead to potential misinterpretations. Third, the supposedly "formal" notion of correctness is often not sufficiently formalized. Such imprecision can lead to difficulties in protocol analysis. <p> Fourth, the analysis in certain approaches is conducted at a very high level of abstraction. The results obtained from such analysis can be easily misinterpreted when trying to relate them to protocol executions. Examples include most of the modal logical approaches <ref> [4, 6, 10, 15] </ref>. We stress, however, that these approaches are certainly useful in their own right. But we also believe that it is important to be able to analyze a protocol at different levels of abstraction.
Reference: [11] <author> R.A. Kemmerer. </author> <title> Analyzing encryption protocols using formal techniques. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(4) </volume> <pages> 448-457, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> In particular, correctness is a specification problem while verification is a procedure problem. Second, the notion of correctness adopted is often limited and does not adequately capture the entire intuitive notion of correctness an authentication protocol designer has in mind. For example, the proposals in <ref> [9, 11] </ref> adopt secrecy as their main correctness crite-rion; while others [6, 10] specify correctness in terms of state of belief and make implicit the secrecy concerns. This discrepancy can lead to potential misinterpretations. Third, the supposedly "formal" notion of correctness is often not sufficiently formalized.
Reference: [12] <author> C. Meadows. </author> <title> Applying formal methods to the analysis of a key management protocol. </title> <journal> Journal of Computer Security, </journal> <volume> 1(1) </volume> <pages> 5-35, </pages> <year> 1992. </year>
Reference-contexts: The design of authentication protocols is highly error-prone, even more so than communication protocols. Indeed, many authentication protocols have been proposed and later found to contain subtle weaknesses or flaws <ref> [3, 6, 8, 12, 13] </ref>. Various formal methods have fl Research supported in part by NSA Computer Security University Research Program under contracts no. MDA 904-91-C7046 and MDA 904-93-C4089, and in part by National Science Foundation grant no. NCR-9004464. <p> In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure.
Reference: [13] <author> R.M. Needham and M.D. Schroeder. </author> <title> Authentication revisited. </title> <journal> ACM Operating Systems Review, </journal> <volume> 21(1):7, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: The design of authentication protocols is highly error-prone, even more so than communication protocols. Indeed, many authentication protocols have been proposed and later found to contain subtle weaknesses or flaws <ref> [3, 6, 8, 12, 13] </ref>. Various formal methods have fl Research supported in part by NSA Computer Security University Research Program under contracts no. MDA 904-91-C7046 and MDA 904-93-C4089, and in part by National Science Foundation grant no. NCR-9004464.
Reference: [14] <author> D. Nessett. </author> <title> A critique of the Burrows, Abadi and Needham logic. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(2) </volume> <pages> 35-38, </pages> <month> April </month> <year> 1990. </year> <month> 10 </month>
Reference-contexts: The informal explanation was widely misunderstood and led directly to the criticism by Nessett in <ref> [14] </ref>. In fact, the precise meaning of "P k $ Q" only became clear with the publication of a new semantics for BAN logic in [2]. Fourth, the analysis in certain approaches is conducted at a very high level of abstraction.
Reference: [15] <author> P. Syverson. </author> <title> Formal semantics for logics of crypto-graphic protocols. </title> <booktitle> In Proceedings of the The Computer Security Foundations Workshop III [1], </booktitle> <pages> pages 32-41. </pages>
Reference-contexts: In our view, security is no more than a specialized notion of correctness, and verification of security is simply verification of this specialized notion of correctness. Problems with Existing Approaches Many approaches have been proposed for the analysis of authentication protocols <ref> [4, 6, 9, 10, 11, 12, 15] </ref>. However, they are not satisfactory for several reasons. First, most approaches do not clearly separate correctness and verification concerns. That is, the precise notion of correctness is not independently stated but rather is built into the verification procedure. <p> Fourth, the analysis in certain approaches is conducted at a very high level of abstraction. The results obtained from such analysis can be easily misinterpreted when trying to relate them to protocol executions. Examples include most of the modal logical approaches <ref> [4, 6, 10, 15] </ref>. We stress, however, that these approaches are certainly useful in their own right. But we also believe that it is important to be able to analyze a protocol at different levels of abstraction.
Reference: [16] <author> T.Y.C. Woo and S.S. Lam. </author> <title> A methodology for verifying authentication protocols. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1993. </year> <note> In preparation. </note>
Reference-contexts: We start with a specification of the protocol example; then we present a specification of correctness and finally the key steps in its verification. In Section 6, we conclude the paper with several observations. Proofs can be found in <ref> [16] </ref>. 2 Two Basic Correctness Prop erties In this section, we take an informal look at the two classes of basic correctness properties for authentication protocols. We guide our discussion with a simple authentication protocol. This protocol also serves as the example in Section 5. <p> Thus the correctness specification is (f (C3)g; f (S)g). 5.3 Proof of Correctness We note that the general secrecy condition is vacuously true for P, as it does not generate any new secret. Proof of the secrecy assertion (S) is based on invariance and is omitted for brevity (see <ref> [16] </ref>). To prove correspondence, we first define two sets of terms. These sets would be used in the statement of intermediate assertions that are needed in the proofs. The first set, referred to as L, is defined as follows. <p> Thus, to be more accurate, we will refer to them as L X and L 0 X respectively. For brevity, we present only the key lemmas below. Their proofs are contained in <ref> [16] </ref>. Lemma A. L X = L 0 X . 2 Let L n denote the instantiation of L X with n. Lemma B. The terms in L n are pairwise disjoint. 2 Note that this is not true for L X .
Reference: [17] <author> T.Y.C. Woo and S.S. Lam. </author> <title> A semantic model for authentication protocols. </title> <booktitle> In Proceedings of the 14th IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 178-194, </pages> <address> Oakland, California, May 24-26 1993. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 11 </pages>
Reference-contexts: The formal semantics of this assertion language is specified using a semantic model we have developed for authentication 1 That is, an authentication protocol may satisfy a secrecy property while failing a correspondence property or vice versa. protocols <ref> [17] </ref>. Roughly speaking, the model defines an operational semantics for authentication protocols. In particular, it characterizes all their executions. For the verification problem, we investigate procedures for proving the two classes of properties. It turns out that secrecy properties can be simply viewed as invariance properties. <p> The balance of this paper is organized as follows. In Section 2, we informally discuss the secrecy and correspondence properties. In Section 3, we present the syntax and semantics of our assertion language. The material here is a significant extension of a preliminary version given in <ref> [17] </ref>. For example, the language now includes infinitely disjunctive terms and two new kinds of assertions, namely, restricted correspondence and equivalence. This section makes heavy use of the semantic model developed in [17]. <p> The material here is a significant extension of a preliminary version given in <ref> [17] </ref>. For example, the language now includes infinitely disjunctive terms and two new kinds of assertions, namely, restricted correspondence and equivalence. This section makes heavy use of the semantic model developed in [17]. Due to length limitation, we are not able to include a summary of the model; we refer readers to that paper instead. In Section 4, we describe proof procedures for the correctness properties. <p> We guide our discussion with a simple authentication protocol. This protocol also serves as the example in Section 5. Due to space limitation, our discussion is necessarily brief. We encourage the readers to consult <ref> [17] </ref> for a more detailed discussion. Before we proceed, we first review the notation generally used in the literature for specifying authentication protocols. This notation is sufficient for the informal discussion in this section. <p> Before we proceed, we first review the notation generally used in the literature for specifying authentication protocols. This notation is sufficient for the informal discussion in this section. We adopt a more specialized notation with rigorous syntax in our approach, which was first introduced in <ref> [17] </ref>. Notation. Principals are denoted by upper case letters, e.g., P , Q. The shared key between P and Q is denoted by k P Q . The public and private keys of P are denoted respectively by k P and k 1 P . <p> In this section, we present an assertion language for formally specifying these properties. This section makes heavy use of the notation introduced in <ref> [17] </ref>. We provide a brief summary below. Notation. Given a term fl, we denote by var (fl) the set of variables that occur in fl. <p> The general part consists of a general secrecy condition, saying that the intruder Z cannot discover any secret not intended for it other than those it has successfully compromised using a predefined GetSecret action. We refer readers to its precise formulation in <ref> [17] </ref>. The specific part consists of secrecy assertions. A secrecy assertion is specified using formulas similar to those used for initial conditions (see example in Section 5). The formulas however are interpreted in the final state of an execution, as opposed to the initial state for initial conditions. <p> The formulas however are interpreted in the final state of an execution, as opposed to the initial state for initial conditions. Again, we omit the definitions here and refer readers to <ref> [17] </ref> for the precise syntax and semantics. 5 3.3 Equivalence Many proofs can be simplified if we define an additional class of assertions, namely, equivalence assertion. The general form of an equivalence assertion is j t2T fl t j t2T 0 t Its semantics is as follows. <p> A key principle of our approach is the separation of correctness and verification. We have defined a specification language for formally specifying authentication protocols and an assertion language for stating correctness requirements. The semantics of each language is rigorously defined using the semantic model developed in <ref> [17] </ref>. We have also discussed procedures for verifying the two classes of correctness properties. We have presented an example to illustrate most of the elements in our approach. We start from a protocol specification, and then present a correctness specification and its verification.
References-found: 17

