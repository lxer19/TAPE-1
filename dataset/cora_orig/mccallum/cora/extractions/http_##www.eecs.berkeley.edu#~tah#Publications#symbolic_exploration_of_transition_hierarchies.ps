URL: http://www.eecs.berkeley.edu/~tah/Publications/symbolic_exploration_of_transition_hierarchies.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/symbolic_exploration_of_transition_hierarchies.html
Root-URL: 
Email: alur@cis.upenn.edu  tah@eecs.berkeley.edu  sriramr@eecs.berkeley.edu  
Title: Symbolic Exploration of Transition Hierarchies  
Author: Rajeev Alur Thomas A. Henzinger Sriram K. Rajamani 
Address: Labs,  Berkeley,  Berkeley,  
Affiliation: University of Pennsylvania and Bell  University of California at  University of California at  
Note: This research was supported in part by the Office of Naval Research Young Investigator award N00014-95-1-0520, by the National Science Foundation CAREER award CCR-9501708, by the National Science Foundation grant CCR-9504469, by the Air Force Office of Scientific Research contract F49620-93-1-0056, by the Army Research Office MURI grant DAAH-04-96-1-0341, by the Advanced Research Projects Agency grant NAG2-892, and by the Semiconductor Research Corporation contract 95-DC-324.036.  
Abstract: In formal design verification, successful model checking is typically preceded by a laborious manual process of constructing design abstractions. We present a methodology for partially| and in some cases, fully|bypassing the abstraction process. For this purpose, we provide to the designer abstraction operators which, if used judiciously in the description of a design, structure the corresponding state space hierarchically. This structure can then be exploited by verification tools, and makes possible the automatic and exhaustive exploration of state spaces that would otherwise be out of scope for existing model checkers. Specifically, we present the following contributions: * A temporal abstraction operator that aggregates transitions and hides intermediate steps. Mathematically, our abstraction operator is a function that maps a flat transition system into a two-level hierarchy where each atomic upper-level transition expands into an entire lower-level transition system. For example, an arithmetic operation may expand into a sequence of bit operations. * A BDD-based algorithm for the symbolic exploration of multi-level hierarchies of transition systems. The algorithm traverses a level-n transition by expanding the corresponding level (n 1) transition system on-the-fly. The level-n successors of a state are determined by computing a level-(n 1) reach set, which is then immediately released from memory. In this fashion, we can exhaustively explore hierarchically structured state spaces whose flat counterparts cause memory overflows. * We experimentally demonstrate the efficiency of our method with three examples|a multiplier, a cache coherence protocol, and a multiprocessor system. In the first two examples, we obtain significant improvements in run times and peak BDD sizes over traditional state-space search. The third example cannot be model checked at all using conventional methods (without manual abstractions), but can be analyzed fully automatically using transition hierarchies. fl A preliminary version of this paper appeared in the Proceedings of the Fourth Workshop on Tools and Algorithms for the Construction and Analysis of Systems (TACAS 98), Lecture Notes in Computer Science 1384, Springer-Verlag, 1998, pp. 330-344. 
Abstract-found: 1
Intro-found: 1
Reference: [AH89] <author> L. Aceto and M. Hennessy. </author> <title> Towards action refinement in process algebras. </title> <booktitle> In Proc. of LICS 89: Logic in Computer Science, </booktitle> <pages> pages 138-145. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year> <title> 1 The transition relation for the multiplier module alone, as computed by VIS, has 7586 BDD nodes and is composed of 6 conjunctive components. Even "and"-ing the components together results in memory overflow. </title> <type> 12 </type>
Reference-contexts: Thus, the description of a design using next can eliminate the need for manual abstractions in verification. Related work. The concept of temporal abstraction is inspired by the notion of multiform time in synchronous programming languages [BlGJ91, Hal93], and by the notion of action refinement in algebraic languages <ref> [AH89] </ref>. All of that work, however, concerns only the modeling of systems, and not automatic verification. Temporal abstraction is implicitly present also in the concept of stuttering [Lam83]: a stuttering transition of a system is a transition that leaves all observable variables unchanged.
Reference: [ABH + 97] <author> R. Alur, R.K. Brayton, T.A. Henzinger, S. Qadeer, and S.K. Rajamani. </author> <title> Partial-order reduction in symbolic state-space exploration. </title> <booktitle> In Proc. of CAV 97: Computer-Aided Verification, </booktitle> <volume> LNCS 1254, </volume> <pages> pages 340-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Section 3.1 vs. Section 3.2). Partial-order methods avoid the exploration of unnecessary interleavings between the transitions of component systems. Gains due to partial-order reduction, in space and time, for verification have been reported both in the case of enumerative [HP94] and BDD-based approaches <ref> [ABH + 97] </ref>. By declaring sequences of transitions to be atomic, the next operator also reduces the number of interleavings between concurrent transitions.
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proc. of LICS 96: Logic in Computer Science, </booktitle> <pages> pages 207-218. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: By contrast, most system description languages do not provide operators for defining temporal, type-(2) abstractions. We have introduced such an operator, called next, and shown how it facilitates the description of complex systems, in a language called Reactive Modules <ref> [AH96] </ref>. In this paper, we show how the next operator can be exploited in symbolic state-space exploration to enhance the power of model checking. <p> A formal definition of reactive modules can be found in <ref> [AH96] </ref>; here we give only a brief introduction. <p> Formal definitions of parallel composition and next-abstraction can be found in <ref> [AH96] </ref>. <p> The experimental results are encouraging, giving fully automatic results even on systems that are amenable to existing tools only after manual abstractions. Transition hierarchies can be exploited to give efficiencies in enumerative reachability analysis as well <ref> [AH96] </ref>. We are currently building a formal verification tool for reactive modules, called MOCHA, which will incorporate both symbolic and enumerative hierarchical search as primitives.
Reference: [BlGJ91] <author> A. Benveniste, P. le Guernic, and C. Jacquemot. </author> <title> Synchronous programming with events and relations: The SIGNAL language and its semantics. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 103-149, </pages> <year> 1991. </year>
Reference-contexts: Thus, the description of a design using next can eliminate the need for manual abstractions in verification. Related work. The concept of temporal abstraction is inspired by the notion of multiform time in synchronous programming languages <ref> [BlGJ91, Hal93] </ref>, and by the notion of action refinement in algebraic languages [AH89]. All of that work, however, concerns only the modeling of systems, and not automatic verification.
Reference: [BSVH + 96] <author> R.K. Brayton, A. Sangiovanni-Vincentelli, G.D. Hachtel, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, S. Qadeer, R.K. Ranjan, T.R. Shiple, G. Swamy, T. Villa, A. Pardo, and S. Sarwary. </author> <title> VIS: a system for verification and synthesis. </title> <booktitle> In Proc. of CAV 96: Computer-Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paradigm is called model checking when the analysis is performed automatically by exhaustive state-space exploration. A variety of model checkers, such as COSPAN [HZR96], Mur [Dil96], SMV [CKSVG96], SPIN [HP96], and VIS <ref> [BSVH + 96] </ref> have been proven effective aids in the design of error-prone system components such as cache coherence protocols [CK96]. <p> All experimental results reported in this paper were obtained by modeling the systems in Verilog and using the vl2mv Verilog compiler along with VIS <ref> [BSVH + 96] </ref>. We implemented a new command in VIS, called abstract reach, based on Algorithm 3.2. 4.1 Multiplier We model a word-multiplier that functions by repeated addition, using the word-adder described earlier. With help of the next operator, we can model the multiplier at various levels of temporal detail.
Reference: [CK96] <author> E.M. Clarke and R.P. Kurshan. </author> <title> Computer-aided verification. </title> <journal> IEEE Spectrum, </journal> <volume> 33(6) </volume> <pages> 61-67, </pages> <year> 1996. </year>
Reference-contexts: A variety of model checkers, such as COSPAN [HZR96], Mur [Dil96], SMV [CKSVG96], SPIN [HP96], and VIS [BSVH + 96] have been proven effective aids in the design of error-prone system components such as cache coherence protocols <ref> [CK96] </ref>. As we seek to enhance the applicability of model checking to complex designs, we are faced with the so-called state-explosion problem: the size of the state space grows exponentially with the size of the system description, making exhaustive state-space exploration infeasible.
Reference: [CKSVG96] <author> E.M. Clarke, K.L. McMillan, S. Campos, and V. Hartonas-Garmhausen. </author> <title> Symbolic model checking. </title> <booktitle> In Proc. of CAV 96: Computer-Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 419-422. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paradigm is called model checking when the analysis is performed automatically by exhaustive state-space exploration. A variety of model checkers, such as COSPAN [HZR96], Mur [Dil96], SMV <ref> [CKSVG96] </ref>, SPIN [HP96], and VIS [BSVH + 96] have been proven effective aids in the design of error-prone system components such as cache coherence protocols [CK96].
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: For each atom, the initial values of the variables and their new values in each subsequent (update) round are specified by guarded commands (as in UNITY <ref> [CM88] </ref>). In each round, unprimed symbols, such as x, refer to the latched value of the variable x, and primed symbols, such as x 0 , refer to the new value. An atom reads the variable x if its guarded commands refer to the latched value of x.
Reference: [CPS93] <author> R.J. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench: a semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <year> 1993. </year>
Reference-contexts: This suggests the following approach to model checking: for each component system, compute the appropriate stutter-insensitive equivalence, and before search, replace the component by the smaller quotient space. This approach, which has been implemented in tools such as the Concurrency Workbench <ref> [CPS93] </ref>, requires the manipulation of the transition relations for individual components, and has not been shown competitive with simple search (cf. Section 3.1 vs. Section 3.2). Partial-order methods avoid the exploration of unnecessary interleavings between the transitions of component systems.
Reference: [Dil96] <author> D.L. Dill. </author> <title> The M ur verification system. </title> <booktitle> In Proc. of CAV 96: Computer-Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 390-393. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paradigm is called model checking when the analysis is performed automatically by exhaustive state-space exploration. A variety of model checkers, such as COSPAN [HZR96], Mur <ref> [Dil96] </ref>, SMV [CKSVG96], SPIN [HP96], and VIS [BSVH + 96] have been proven effective aids in the design of error-prone system components such as cache coherence protocols [CK96].
Reference: [Hal93] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Thus, the description of a design using next can eliminate the need for manual abstractions in verification. Related work. The concept of temporal abstraction is inspired by the notion of multiform time in synchronous programming languages <ref> [BlGJ91, Hal93] </ref>, and by the notion of action refinement in algebraic languages [AH89]. All of that work, however, concerns only the modeling of systems, and not automatic verification.
Reference: [HP94] <author> G.J. Holzmann and D.A. Peled. </author> <title> An improvement in formal verification. </title> <booktitle> In Proc. of FORTE 94: Formal Description Techniques, </booktitle> <pages> pages 197-211. </pages> <publisher> Chapman & Hall, </publisher> <year> 1994. </year>
Reference-contexts: Section 3.1 vs. Section 3.2). Partial-order methods avoid the exploration of unnecessary interleavings between the transitions of component systems. Gains due to partial-order reduction, in space and time, for verification have been reported both in the case of enumerative <ref> [HP94] </ref> and BDD-based approaches [ABH + 97]. By declaring sequences of transitions to be atomic, the next operator also reduces the number of interleavings between concurrent transitions.
Reference: [HP96] <author> G.J. Holzmann and D.A. Peled. </author> <title> The state of SPIN. </title> <booktitle> In Proc. of CAV 96: Computer-Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 385-389. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paradigm is called model checking when the analysis is performed automatically by exhaustive state-space exploration. A variety of model checkers, such as COSPAN [HZR96], Mur [Dil96], SMV [CKSVG96], SPIN <ref> [HP96] </ref>, and VIS [BSVH + 96] have been proven effective aids in the design of error-prone system components such as cache coherence protocols [CK96].
Reference: [HZR96] <author> R.H. Hardin, Z. Har'El, and R.P. </author> <title> Kurshan. </title> <booktitle> COSPAN. In Proc. of CAV 96: Computer-Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 423-427. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paradigm is called model checking when the analysis is performed automatically by exhaustive state-space exploration. A variety of model checkers, such as COSPAN <ref> [HZR96] </ref>, Mur [Dil96], SMV [CKSVG96], SPIN [HP96], and VIS [BSVH + 96] have been proven effective aids in the design of error-prone system components such as cache coherence protocols [CK96].
Reference: [Lam83] <author> L. Lamport. </author> <title> What good is temporal logic? In Proc. </title> <booktitle> of Information Processing 83: IFIP World Computer Congress, </booktitle> <pages> pages 657-668. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1983. </year>
Reference-contexts: All of that work, however, concerns only the modeling of systems, and not automatic verification. Temporal abstraction is implicitly present also in the concept of stuttering <ref> [Lam83] </ref>: a stuttering transition of a system is a transition that leaves all observable variables unchanged. Ignoring differences in the number of stuttering transitions leads to various notions of stutter-insensitive equivalences on state spaces (e.g., weak bisimulation).
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: variables are updated by the environment and can be read by the module; the interface variables are updated by the module and can be read by the environment; the private variables are updated by the module and cannot be read by the environment (this distinction is similar to I/O automata <ref> [Lyn96] </ref>). For example, Figure 2 shows a module that adds two words. The environment of the word-adder consists of two modules: a command module, which provides the operands to be added and an instruction that they be added, and a bit-adder, which is called repeatedly by the word-adder.
Reference: [TSL90] <author> H.J. Touati, H. Savoj, B. Lin, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Implicit state enumeration of finite-state machines using BDDs. </title> <booktitle> In Proc. of ICCAD 90: Computer-Aided Design, </booktitle> <pages> pages 130-133. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year> <month> 13 </month>
Reference-contexts: For instance, in symbolic state-space exploration using BDDs, instead of building a single transition relation for the entire system, one typically maintains a set of transition relations, one for each component <ref> [TSL90] </ref>. By contrast, most system description languages do not provide operators for defining temporal, type-(2) abstractions. We have introduced such an operator, called next, and shown how it facilitates the description of complex systems, in a language called Reactive Modules [AH96]. <p> In practice, however, during the construction the intermediate BDDs often blows up and results in memory overflow. For parallel composition, it is a common trick to leave the transition relation conjunctively decomposed and represent it as a set of BDDs, rather than computing their conjunction as a single BDD <ref> [TSL90] </ref>. Early quantification heuristics are then used to efficiently compute the image of a state set under a conjunctively partitioned transition relation.
References-found: 17

