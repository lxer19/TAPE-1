URL: http://pertsserver.cs.uiuc.edu/papers/FeLi94.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Email: ffeng, janeliug@cs.uiuc.edu  
Title: Algorithms for Scheduling Tasks with Input Error and End-to-End Deadlines  
Author: W. Feng and J. W.-S. Liu 
Address: 1304 W. Springfield Ave. Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Note: Submitted to IEEE Transactions on Software Engineering  
Abstract: This paper describes heuristic algorithms for scheduling preemptive, imprecise, composite tasks with input error and end-to-end timing constraints. Each composite task consists of a chain of component tasks, where each component task is made up of a mandatory part and an optional part. Whenever a component task uses imprecise input, the mandatory and optional parts of the component task may be extended in order to compensate for input error. We use a two-level scheduler. At the high level, the scheduler schedules the composite tasks preemptively on one processor, according to an existing algorithm for scheduling simple imprecise tasks. The result is the total amount of time budgeted to each composite task in order for all composite tasks to meet their end-to-end deadlines. The low-level scheduler then distributes the time budgeted for each composite task across its component tasks so as to minimize the output error of each composite task. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. L. Liestman and R. H. Campbell. </author> <title> A fault-tolerant scheduling problem. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(10):1089-1095, </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: Our algorithms work with the trans formed parameters i1 and ! i1 , not the corresponding given parameters. The allowed range of the fraction of discarded work F i1 , based on the computed value ! i1 is <ref> [0; 1] </ref>. Adopting the straight-line segments with finite slopes in this range, we have the following approximate extension functions: H i (F i ) = XF i1 where X and Y are the values defined in Figure 2. Hence, h i = X and k i = Y .
Reference: [2] <author> J. Blazewicz and G. Finke. </author> <title> Minimizing mean weighted execution time loss on identical and uniform processors. </title> <journal> Information Processing Letters, </journal> <volume> 24(3) </volume> <pages> 259-263, </pages> <month> March </month> <year> 1987. </year>
Reference: [3] <author> K.-J. Lin and S. Natarajan. </author> <title> Concord: A system of imprecise computations. </title> <booktitle> In Proceedings of the 1987 IEEE Compsac, </booktitle> <pages> pages 75-81, </pages> <month> October </month> <year> 1987. </year>
Reference: [4] <author> K.-J. Lin, S. Natarajan, and J. W.-S. Liu. </author> <title> Imprecise results: Utilizing partial computations in real-time systems. </title> <booktitle> In Proceedings of 8th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference: [5] <author> J. W.-S. Liu, K.-J. Lin, and S. Natarajan. </author> <title> Scheduling real-time, periodic jobs using imprecise results. </title> <booktitle> In Proceedings of 8th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference: [6] <author> E. K. P. Chong and W. Zhao. </author> <title> Performance evaluation of scheduling algorithms for imprecise computer systems. </title> <type> Technical Report SA-5001, </type> <institution> Department of Computer Science, University of Adelaide, </institution> <month> September </month> <year> 1988. </year> <month> 29 </month>
Reference: [7] <author> J. Y.-T. Leung, T. W. Tam, C. S. Wong, and G. H. Young. </author> <title> Minimizing mean flow time with error constraints. </title> <booktitle> In Proceedings of 10th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 2-11, </pages> <month> December </month> <year> 1989. </year>
Reference: [8] <author> J.-Y. Chung, J. W.-S. Liu, and K.-J. Lin. </author> <title> Scheduling periodic jobs that allow imprecise results. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 19(9) </volume> <pages> 1156-1173, </pages> <month> September </month> <year> 1990. </year>
Reference: [9] <author> J. Y.-T. Leung and C. S. Wong. </author> <title> Minimizing the number of late tasks with error constraints. </title> <booktitle> In Proceedings of 11th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 32-40, </pages> <month> December </month> <year> 1990. </year>
Reference: [10] <author> J. W.-S. Liu, K.-J. Lin, W.-K. Shih, A. C.-S. Yu, J.-Y. Chung, and W. Zhao. </author> <title> Algorithms for scheduling imprecise computations. </title> <journal> IEEE Computer, </journal> <volume> 24(5) </volume> <pages> 58-68, </pages> <month> May </month> <year> 1991. </year>
Reference: [11] <author> W.-K. Shih, J. W.-S. Liu, and J.-Y. Chung. </author> <title> Algorithms for scheduling imprecise computations to minimize total error. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: This optimal off-line algorithm finds preemptive schedules of independent tasks in which the maximum fraction of discarded work among all tasks is as small as possible. This algorithm in turn uses the optimal algorithm, developed earlier by Shih et al <ref> [11] </ref>, for scheduling off-line preemptive tasks with arbitrary ready times and deadlines to minimize the sum of the amounts of discarded work over all tasks. While these algorithms allow tasks to be dependent, the possibility of error propagation across dependent tasks was not considered. <p> Therefore, the problem of scheduling a set of preemptable composite tasks reduces to the problem of scheduling a set of independent preemptable tasks. composite tasks. This algorithm makes use of a modified version of the earliest-deadline-first algorithm (M-EDF), described in <ref> [11] </ref>, and Algorithm G, described in [15]. The M-EDF algorithm treats every composite task as if it were entirely optional and schedules the composite tasks on an earliest-deadline-first basis. It never schedules any composite task after its deadline. <p> It never schedules any composite task after its deadline. In other words, every composite task is terminated at its deadline if it is not completed. It has been shown in <ref> [11] </ref> that the M-EDF algorithm minimizes the total processing time of the unexecuted portions of all tasks. Algorithm G distributes the total available processor time as evenly as possible among the tasks. <p> If Step 1 fails to find a precise schedule of T, no precise schedule of T exists <ref> [11] </ref>. Step 2 then tries to precisely schedule every composite task whose optional processing time ! j is small compared with its maximum extended-mandatory processing time. It does so in Step 2 (a) by reducing the amounts of time assigned to tasks which have relatively large optional processing times.
Reference: [12] <author> W.-K. Shih and J. W.-S. Liu. </author> <title> On-line scheduling of imprecise computations to minimize error. </title> <booktitle> In Proceedings of the 13th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: While these algorithms allow tasks to be dependent, the possibility of error propagation across dependent tasks was not considered. Shih et al <ref> [12] </ref> has since modified this algorithm to schedule on-line tasks optimally in the sense that the sum of the amounts of discarded work of all tasks accepted by the system is minimized.
Reference: [13] <author> I. K. Cheong. </author> <title> Scheduling imprecise hard real-time jobs with cumulative error. </title> <type> Technical Report UIUCDCS-R-92-1758, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1992. </year>
Reference: [14] <author> W. Zhao, J. W.-S. Liu, and S. Vrbsky. </author> <title> Imprecise scheduling in multiprocessor systems. </title> <booktitle> In Proceedings of the 5th IEEE International Conference on Parallel and Distributed Computing Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference: [15] <author> W.-K. Shih and J. W.-S. Liu. </author> <title> Algorithms for scheduling imprecise computations with timing constraints to minimize maximum error. </title> <note> To appear in IEEE Transactions on Computers. </note>
Reference-contexts: The high-level scheduler described later in this paper makes use of Algorithm G described in <ref> [15] </ref>. This optimal off-line algorithm finds preemptive schedules of independent tasks in which the maximum fraction of discarded work among all tasks is as small as possible. <p> Therefore, the problem of scheduling a set of preemptable composite tasks reduces to the problem of scheduling a set of independent preemptable tasks. composite tasks. This algorithm makes use of a modified version of the earliest-deadline-first algorithm (M-EDF), described in [11], and Algorithm G, described in <ref> [15] </ref>. The M-EDF algorithm treats every composite task as if it were entirely optional and schedules the composite tasks on an earliest-deadline-first basis. It never schedules any composite task after its deadline. In other words, every composite task is terminated at its deadline if it is not completed.
Reference: [16] <author> T. Dean and M. Boddy. </author> <title> An analysis of time-dependent planning. </title> <booktitle> In Proceedings of AAAI, </booktitle> <pages> pages 49-54, </pages> <year> 1988. </year>
Reference-contexts: The concept of trading off result quality for timeliness has also been independently studied by the artificial intelligence community. A year after the imprecise computation model was first introduced, Dean and Boddy <ref> [16] </ref> proposed the use of anytime algorithms in the framework of time-dependent planning and decision-making. The execution of an anytime algorithm may be interrupted at any point to return a result whose quality is a function of the execution time.
Reference: [17] <author> S. Zilberstein. </author> <title> Constructing utility-driven real-time systems using anytime algorithms. </title> <booktitle> In Proceedings of the 1st IEEE Workshop on Imprecise and Approximate Computation, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: Therefore, a task based on the anytime algorithm is equivalent to an optional task in the imprecise-computation model; an imprecise computation can model an anytime algorithm by simply letting the execution time of the mandatory part be zero. Zilberstein <ref> [17, 18] </ref> extended the work of Dean and Boddy by introducing the concept of conditional performance profiles.
Reference: [18] <author> S. Zilberstein. </author> <title> Operational Rationality Through Compilation of Anytime Algorithms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of California at Berkeley, </institution> <year> 1993. </year>
Reference-contexts: Therefore, a task based on the anytime algorithm is equivalent to an optional task in the imprecise-computation model; an imprecise computation can model an anytime algorithm by simply letting the execution time of the mandatory part be zero. Zilberstein <ref> [17, 18] </ref> extended the work of Dean and Boddy by introducing the concept of conditional performance profiles.
Reference: [19] <author> D. J. Musliner. </author> <title> CIRCA: The Cooperative Intelligent Real-Time Control Architecture. </title> <type> PhD thesis, </type> <institution> Department of Computer Science and Engineering, University of Michigan, </institution> <year> 1993. </year> <month> 30 </month>
Reference-contexts: In contrast, conditional performance profiles represent result quality as a function of run-time and input quality. The extended imprecise-computation model described in the next section resembles Zilberstein's model in this way. 5 Recently, Musliner <ref> [19] </ref> introduced the concept of any-dimension algorithms | a general class of iterative improvement algorithms. This concept generalizes the anytime algorithm concept by providing guarantees along dimensions other than time.
References-found: 19

