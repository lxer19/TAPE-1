URL: http://www.cms.dmu.ac.uk/~xdl/publication/survey-t.ps.gz
Refering-URL: http://www.cms.dmu.ac.uk/STRL/monographs/mono3.html
Root-URL: 
Title: A SURVEY OF FORMAL METHODS FOR SOFTWARE RE-ENGINEERING  
Author: Xiaodong Liu 
Keyword: formal methods, wide-spectrum language, real-time system development, refinement, re-engineering, logic, reverse engineering.  
Address: England  
Affiliation: Department of Computer Science School of Computing Science De Montfort University  
Email: Email: dongliu@charity.dmu.ac.uk  
Phone: Tel: +44 (0)116 250 6170  
Date: 28 January, 1997  
Abstract: As a consequence, various growing formal methods have been developed in improving normal software development, most of which are focused on forward engineering. In contrast to forward engineering, the issue of applying formal methods in software re-engineering has been rarely explored. Due to the distinct features of formal methods, e.g. rigorousness and automation, we believe that there is a tremendous future in integrating formal methods with software re-engineering technology. In this survey, we investigate the general state of formal technology and software re-engineering, propose a set of criteria of formal methods for software re-engineering. Among the vast world of formal technology, we classify the existent formalisms into five categories, i.e. model-based approaches, logic-based approaches, algebraic approaches, process algebra approaches and net-based approaches. A general introduction of the most popular formalisms in each category is presented, which includes references, a brief description of syntax and semantics, and an assessment. Detailed discussion (which is called sample description) is given to a few formalisms which may be suitable for being the foundation of certain software re-engineering approaches. Based on the proposed criteria, conclusions, including contrasts and comparisons of these formal methods, are made out. Although only a very few formalisms have been applied as the theoretic foundation of re-engineering, some of them already reveal a promising future, such as Z and ITL. We also investigate the current state of the relevant projects in the later section. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aalst, W. M. P. vander, </author> <title> "Timed Coloured Petri Nets and their Application to Logistics", </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology , 1992. </institution>
Reference-contexts: There are no necessary and sufficient conditions for bounded-ness (finiteness of the reachability graph); however, some sufficient conditions have been provided. Perhaps the most general Petri nets available for real-time problems are the ITCPN (Interval Timed Colour Petri Net) <ref> [1] </ref>. These nets are higher level nets, and an interval is used to specify the timing characteristics, by attaching a timestamp to every token. The resulting semantics is quite elegant because both the timing and the colour are attributes of tokens.
Reference: [2] <author> Abrial, J. R., Schuman, S. A. and Meyer, B., </author> <title> Specification Language Z, </title> <publisher> Massachusetts Computer Associates Inc., </publisher> <address> Boston, </address> <year> 1979. </year> <month> 67 </month>
Reference-contexts: In this approach, there is no explicit representation of concurrency. Non-functional requirements (such as temporal requirement) could be expressed in some cases. Z is treated as a sample description. 3.1.1 Z Overview With the first version proposed in 1979 <ref> [2] </ref>, the Z notion [134] is based on predicate calculus and Zermelo Fraenkel set theory. A Z specification is written in terms of `schemas', each of which contains a signature part which declares items of interest and a predicate part which places a logical constraint on them.
Reference: [3] <author> Alur, R., </author> <title> "Techniques for Automatic Verification of Real-Time Systems", </title> <type> PhD Thesis, </type> <institution> Stanford USA, </institution> <year> 1991. </year>
Reference-contexts: In practice, branching time logics are usually used to verify finite state systems by model checking because of the efficiency of the model checking algorithms. Linear time logics usually come with a deductive proof system for dealing with the infinite state systems. 27 In [4] <ref> [3] </ref>, a branching real-time time logic called Timed Computation Tree Logic (TCTL) is proposed. It is based on hidden clock bounded operators. For TCTL, the validity problem for dense time domains is undecidable, yet model-checking is decidable.
Reference: [4] <author> Alur, R., Courcoubetis, C. and Dill, D. L., </author> <title> "Model Checking for Real-Time Systems", </title> <booktitle> Proceedings of 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: In practice, branching time logics are usually used to verify finite state systems by model checking because of the efficiency of the model checking algorithms. Linear time logics usually come with a deductive proof system for dealing with the infinite state systems. 27 In <ref> [4] </ref> [3], a branching real-time time logic called Timed Computation Tree Logic (TCTL) is proposed. It is based on hidden clock bounded operators. For TCTL, the validity problem for dense time domains is undecidable, yet model-checking is decidable.
Reference: [5] <author> Alur, R. and Dill, D. L., </author> <title> "Automata for Modeling Real-Time Systems", In M.S. </title> <editor> Paterson editor, </editor> <booktitle> ICALP 90: Automata, Languages and Programming, Lecture Notes in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Nets need to be complete before any properties are proven, or reachability graphs drawn. 3.5.3 Statecharts Overview Statecharts [76] provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "State-mate" <ref> [5] </ref> exists to implement the formalism. Methods similar to that of Statecharts may be found in [57].
Reference: [6] <author> Alur, R. and Henzinger, T., </author> <title> "Real-Time Logics: Complexity and Expressiveness", </title> <booktitle> Proceedings of 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Other Varieties of RTTL 26 There are several varieties of RTTL, which are restricted to finite state and propo- sitional temporal properties. Here, we give a short introduction to them. * Metric Temporal Logic (MTL) [85] <ref> [6] </ref>. MTL is a discrete time propositional version of the bounded operator logic. It is a variety of RTTL in which references to time are restricted to bounds on the temporal operators. <p> XCTL restricts the quantification level. It allows only one outermost level of quantification over rigid time variables. The quantification is therefore never explicitly displayed. On the other hand, it allows general arithmetic timing expressions, including addition and subtraction of variables and constants. * TPTL <ref> [6] </ref>. It is a discrete time propositional logic whose timing constraints allow comparison and addition (but only of integer constants, i.e. no variables).
Reference: [7] <author> Alur, R., Henzinger, T. and Feder, T., </author> <title> "The Benefits of Relaxing Punctuality", </title> <booktitle> Proceedings of 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1991. </year>
Reference-contexts: For example, the formula A ) 3 5 B means that if A occurs then eventually within 5 time units B must occur. No references to an explicit clock are allowed and hence MTL is called a hidden clock bounded temporal operator logic. * XCTL <ref> [7] </ref>. It is a discrete time propositional explicit clock logic. The atomic timing constraints allows the primitives of comparison and addition. XCTL restricts the quantification level. It allows only one outermost level of quantification over rigid time variables. The quantification is therefore never explicitly displayed.
Reference: [8] <author> Anger, F. D., Rodriguez, R. V. and Yound, M., </author> <title> "Combining Static and Dynamic Analysis of Concurrent Programs", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1994, </booktitle> <month> September, </month> <year> 1995. </year>
Reference-contexts: This is the most important method in reverse design. Concrete transformation rules and inference algorithms are defined according to concrete source code language. By these rules and certain form of knowledge & data bases, source code can be transformed into a higher level of abstraction [90] <ref> [8] </ref> [32] [34]. * Data Centred Program Understanding. Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships [80] [142]. * Program Slicing.
Reference: [9] <author> Arango, G., Baxter, I., Freeman, P. and Pidgeon, C., </author> <title> "TMM: Software Maintenance by Transformation", </title> <journal> IEEE Software, </journal> <month> May, </month> <year> 1986. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering <ref> [9] </ref> [26] [46] [106] [114] [99]. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [10] <author> Arnold, R., </author> <title> Software Reengineering, </title> <year> 1992. </year>
Reference-contexts: Large systems are so complex that it is impossible for a single individual to build and maintain all aspects of its design. A major goal of software engineering is to enable developers to construct systems that operate reliably despite this complexity [35] [11] <ref> [10] </ref> [83]. One way of achieving this goal is by using formal methods, which are mathematically-based languages, techniques, and tools for specifying and verifying such systems. Use of formal methods does not a priori guarantee correctness. <p> proof, however, the human user often gains invaluable insight into the system or the property being proved. 2.2 Software Re-engineering : Scope and Research Issues 2.2.1 Re-engineering in General: Definitions and Taxonomy The following key terms provide a clear scope and contents of the domain of software re-engineering [35] [11] <ref> [10] </ref> [58]: Forward Engineering is the traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation 6 of a system.
Reference: [11] <author> Arnold, R. S. and Bohner, S. A., </author> <title> "Impact Analysis-Towards a Framework for Comparison. </title> ", <booktitle> Proceedings of the International Conference on Software Maintenance 1993, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Large systems are so complex that it is impossible for a single individual to build and maintain all aspects of its design. A major goal of software engineering is to enable developers to construct systems that operate reliably despite this complexity [35] <ref> [11] </ref> [10] [83]. One way of achieving this goal is by using formal methods, which are mathematically-based languages, techniques, and tools for specifying and verifying such systems. Use of formal methods does not a priori guarantee correctness. <p> the proof, however, the human user often gains invaluable insight into the system or the property being proved. 2.2 Software Re-engineering : Scope and Research Issues 2.2.1 Re-engineering in General: Definitions and Taxonomy The following key terms provide a clear scope and contents of the domain of software re-engineering [35] <ref> [11] </ref> [10] [58]: Forward Engineering is the traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation 6 of a system.
Reference: [12] <author> Baeten, J. C. M. and Bergstra, J. A., </author> <title> "Real Time Process Algebra", </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 3, </volume> <pages> pp. </pages> <month> 142-188 (Feb </month> <year> 1991). </year>
Reference-contexts: LOTOS has weak data specification mechanisms and cannot express time explicitly. Inheritance representation in LOTOS is not perfect. Polymorphism and inheritance are not supported. It would be much better if LOTOS supported OO constructs directly [25]. 3.4.4 Algebra of Communicating Processes (ACP) Algebra of Communicating Processes (ACP)[16] <ref> [12] </ref>. was proposed by J.A. Bergstra in 1984. Until now, a rather large variety of ACP has been proposed, such as Real Time ACP (ACP ), Discrete Time ACP. ACP is also an action-based process algebra, which may be viewed as a modification of CCS. <p> Since transitions may fire at any time in the allowed interval, states in the reachability graphs may have an unbounded number of successors (if continuous time is used). This adds complexity to the next-state function. Various techniques such as state classes and enumerative analysis techniques <ref> [12] </ref> have been introduced to overcome this problem. There are no necessary and sufficient conditions for bounded-ness (finiteness of the reachability graph); however, some sufficient conditions have been provided. Perhaps the most general Petri nets available for real-time problems are the ITCPN (Interval Timed Colour Petri Net) [1].
Reference: [13] <author> Baeten, J. C. M. and Bergstra, J. A., </author> <title> "Real-Time Process Algebra", </title> <type> Technical Report CS-R9053, </type> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: TPWB Partially supports automatic verification of TPCCS. However, the calculation of probabilities is not mentioned in TPCCS and TPCTL. 3.4.7 Varieties of Timed Process Algebras Untimed process algebras have been extended with timing constructs in several ways including: * ACP (Real-Time ACP) <ref> [13] </ref>. A dense time domain is used. * ATP (Algebra of Timed Processes) [108]. * CCSR (Calculus of Communication Shared Resources based on CCS [63] [62]. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] [126].
Reference: [14] <author> Bennett, K. H., Bull, T. and Yang, H., </author> <title> "A Transformation System for Maintenance | Turning Theory into Practice", </title> <booktitle> IEEE Conference on Software Maintenance-1992, </booktitle> <address> Orlando, Florida, </address> <month> November, </month> <year> 1992. </year>
Reference: [15] <author> Benveniste, A. and Harter, P. K., </author> <title> "Proving Real-Time Properties of Programs with Temporal Logics", </title> <booktitle> Proceedings of ACM SIGOPS 8th annual ACM symposium on Operating systems Principles, </booktitle> <month> December </month> <year> 1981. </year>
Reference-contexts: In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal logics were reported in [112] <ref> [15] </ref>. Since then, real-time logics have been explored in great detail. There is not any application of temporal logic in reverse engineering yet.
Reference: [16] <author> Bergstra, J. A. and Klop, J. W., </author> <title> "Process Algebra for Synchronous Communication", </title> <journal> Information and Control, </journal> <volume> Vol. 60, </volume> <pages> pp. </pages> <month> 109-137 (Jan/Feb/Mar </month> <year> 1984). </year>
Reference: [17] <author> Berthomieu, B. and Diaz, M., </author> <title> "Modeling and Verification of Time Dependent Systems Using Timed Petri Nets", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <pages> pp. </pages> <month> 259-273 (March </month> <year> 1991). </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets [119]. Both have been used extensively [54] <ref> [17] </ref> [19] [89] [120]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [18] <author> Berzins, V., </author> <title> Software Merging and slicing, </title> <publisher> IEEE Computer Society Press, </publisher> <address> ISBN 0 8186-6792-3, </address> <year> 1995. </year>
Reference-contexts: A program slice is a fragment of a program in which some statements are omitted that are not necessary to understand a certain property of the program [58] <ref> [18] </ref>. 2.2.3 Re-engineering Tools Automation is one of the most important features of software re-engineering. Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach.
Reference: [19] <author> Billington, J., Wheeler, G. R. and Wilbur-Ham, M. C., "PROTEAN: </author> <title> a High-level Petri Net Tool for the Specification and Verification of Communication Protocol", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, </volume> <pages> pp. </pages> <month> 301-316 (March </month> <year> 1988). </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets [119]. Both have been used extensively [54] [17] <ref> [19] </ref> [89] [120]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [20] <author> Bjrner, D. and Jones, C. B., </author> <title> Formal Specification and Software Development, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1982. </year>
Reference-contexts: VDM is firstly presented in [81] and <ref> [20] </ref>. It is similar to Z in most aspects. VDM is also a popularly accepted approach to systematic program development, although not so popular as Z. In this survey, we give VDM a rather concise review which is based on a comparison with Z.
Reference: [21] <author> Bolognesi, T. and Lucidi, F., </author> <title> "LOTOS like Process Algebra with Urgent or Timed Interactions", </title> <institution> REX Workshop|Real T ime : T heoryandP ractice; LN CS; 1992: </institution>
Reference-contexts: Discrete or dense time domains can be used. * TPCCS (Timed Probabilistic CCS) [67]. TPCCS adopts a discrete time domain. It will be discussed later. * TPL (Temporal Process Language) [71]. A discrete time domain is used. * U-LOTOS (Urgent LOTOS) <ref> [21] </ref>. Discrete or dense time domains can be used. 48 3.5 Net-based Approach Graphical notations are popular notations for specifying systems as they are easier to comprehend and, hence, more accessible to non-specialists.
Reference: [22] <author> Bowen, J., </author> <title> "Toward Verified Systems", Real-time Safety Critical Systems Series, </title> <booktitle> Vol. </booktitle> <month> 2 </month> <year> (1994). </year>
Reference-contexts: For hardware verification, industry is 4 adopting techniques like model checking and theorem proving to complement the more traditional one of simulation. In both areas, researchers and practitioners are performing more and more industrial-based case studies, and thereby gaining the benefits of using formal methods <ref> [22] </ref>. 2.1.1 Specification Specification is the process of describing a system and its desired properties. Formal specification uses a language with a mathematically-defined syntax and semantics. The kinds of system properties might include functional behaviour, time behaviour, performance characteristics, or internal structure.
Reference: [23] <author> Bryant, R. E., </author> <title> "Graphy-based Algorithms for Boolean Function Manipulation", </title> <journal> IEEE Transaction on Computers, </journal> <volume> Vol. C-35 (8 1986). </volume> <pages> 68 </pages>
Reference-contexts: It can be used to check partial specifications, and so it can provide useful information about a system's correctness even if the system has not been completely specified. The main disadvantage of model checking is the state explosion problem. In 1987 McMillan used Bryant's ordered binary decision diagrams (BDDs) <ref> [23] </ref> to represent state transition systems efficiently, thereby increasing the size of the systems that could be verified. Other promising approaches to alleviating state explosion include the exploitation of partial order information [115], localisation reduction [86], and semantic minimisation [52] to eliminate unnecessary states from a system model.
Reference: [24] <author> Burns, A., </author> <title> "The Application of Utility Functions in Real-Time System Design and Scheduling", </title> <type> Internal Report, </type> <year> 1990. </year>
Reference: [25] <author> Burns, A. and Wellings, A., </author> <title> "HRT HOOD T M : A Structured Design Method for Hard Real-Time Ada System", Real-time Safety Critical Systems Series, </title> <booktitle> Vol. </booktitle> <month> 3 </month> <year> (1995). </year>
Reference-contexts: Modularity could be improved. LOTOS has weak data specification mechanisms and cannot express time explicitly. Inheritance representation in LOTOS is not perfect. Polymorphism and inheritance are not supported. It would be much better if LOTOS supported OO constructs directly <ref> [25] </ref>. 3.4.4 Algebra of Communicating Processes (ACP) Algebra of Communicating Processes (ACP)[16] [12]. was proposed by J.A. Bergstra in 1984. Until now, a rather large variety of ACP has been proposed, such as Real Time ACP (ACP ), Discrete Time ACP.
Reference: [26] <author> Canfora, G., Cimitile, A. and Carlini, U. D., </author> <title> "A Logic Based Approach to Reverse Engineering Tools Production", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1991, </booktitle> <year> 1991. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] <ref> [26] </ref> [46] [106] [114] [99]. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [27] <author> Cau, A. and Zedan, H., </author> <title> "Refining Interval Temporal Logic Specifications", </title> <booktitle> the 4th AMAST Workshop on Real-Time systems, Concurrent, and Distributed Software (ARTS'97), </booktitle> <address> Mallorca, Spain, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura [104], 29 is well developed. Hussein Zedan and Antonio Cau proposed a set of new refinement techniques of ITL <ref> [27] </ref>, which makes ITL more suitable for system development and re-engineering. Syntax and Semantics An interval is considered to be a (in)finite sequence of states 0 1 :::, where a state i is a mapping from the set of variables V ar to the set of values Val. <p> For medium-to-large scale systems such a technique becomes tedious, inapplicable and inappropriate in the presence of concurrency. ITL/Tempura also reveals shortcomings in the formalism in terms of modularity and explicit expressibility of both timing constraints, resource and concurrency. H. Zedan and Antonio Cau propose an extension of ITL <ref> [27] </ref> [131]which deals with ITL shortcomings by providing a timed-communication model allowing explicit representation of concurrency, resource and timing. The proposed model greatly increases the expressibility of ITL. The main extension of ITL includes: * Channel introduction, untimed reading and writing.
Reference: [28] <author> Cau, A., Zedan, H., Coleman, N. and Moszkowski, B., </author> <title> "Using ITL and Tempura for Large Scale Specification and Simulation", </title> <booktitle> Proceedings of 4th EUROMICRO Workshop on Parallel and Distributed Processing, IEEE, </booktitle> <address> Braga, Portugal, </address> <year> 1996. </year>
Reference-contexts: Until now, there is no application of TPCTL in reverse engineering area. 3.2.8 Interval Temporal Logic (ITL) Overview Interval based real-time temporal logic have been developed in <ref> [28] </ref> [107]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. ITL was first proposed by Moszkowski [105].
Reference: [29] <author> Cau, A., </author> <title> "Compositional Verification and Specification of Refinement for Reactive Systems in Dense Time Temporal Logic", </title> <type> Technical Report, </type> <month> Jan </month> <year> 1996. </year>
Reference-contexts: Model checking for branching time logics has therefore been applied more successfully than that of linear time logics, although additional constructs must be employed to deal fairness [43] <ref> [29] </ref>. There is no consensus among researchers as to whether branching time or linear time logics are more suited to verification. In practice, branching time logics are usually used to verify finite state systems by model checking because of the efficiency of the model checking algorithms.
Reference: [30] <author> Chaochen, Z., Hoare, C. A. R. and Ravn, A. P., </author> <title> "A Calculus of Durations", </title> <journal> Information Processing Letters, </journal> <volume> Vol. 40, </volume> <pages> pp. </pages> <month> 269-276 (05 </month> <year> 1991). </year>
Reference-contexts: At present, Interval logics have been used for specification and simulation, but not much work has been done on deductive calculi or model checking for verification. 3.2.9 Duration Calculus (DC) Duration Calculus was introduced in <ref> [30] </ref> [31]. as a logic to specify and reason about requirements for real-time systems. It is an extension of Interval Temporal Logic where one can reason about integrated constraints over time-dependent and Boolean valued states without explicit mention of absolute time.
Reference: [31] <author> Chaochen, Z., Ravn, A. P. and Hansen, M. R., </author> <title> "An Extended Duration Calculus for Hybrid Systems", Hybrid Systems, R.L. </title> <editor> Grossman, A. Nerode, A. P. Ravn. H. Rischel(Eds.), </editor> <year> 1993. </year>
Reference-contexts: At present, Interval logics have been used for specification and simulation, but not much work has been done on deductive calculi or model checking for verification. 3.2.9 Duration Calculus (DC) Duration Calculus was introduced in [30] <ref> [31] </ref>. as a logic to specify and reason about requirements for real-time systems. It is an extension of Interval Temporal Logic where one can reason about integrated constraints over time-dependent and Boolean valued states without explicit mention of absolute time.
Reference: [32] <author> Cheng, B. H. C., </author> <title> "Applying Formal Methods in Automated Software Development", </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> Vol. 2, </volume> <pages> pp. </pages> <month> 137-164 (02 </month> <year> 1994). </year>
Reference-contexts: This is the most important method in reverse design. Concrete transformation rules and inference algorithms are defined according to concrete source code language. By these rules and certain form of knowledge & data bases, source code can be transformed into a higher level of abstraction [90] [8] <ref> [32] </ref> [34]. * Data Centred Program Understanding. Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships [80] [142]. * Program Slicing. <p> Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach. At present, there are already some accomplished re-engineering tools, such as "Maintainer's Assistant" [140], "VIFOR" [118,132], "Rigi" and "AUTOSPEC" [33] [61] <ref> [32] </ref> [60]. Among these tools, we concentrated on two typical ones: Yang's Maintainer's Assistant and Cheng's AUTOSPEC. Generally speaking, each tool and the approach it based on makes progress in certain aspects, while remaining vast areas untouched and invaluable improvements unconsidered. <p> section, we summarise several typical projects to illustrate the current situation. 54 4.2 Reverse Engineering with Formal Methods in MSU In the Software Engineering Research Center (SERC) of the Department of Computer Science, Michigan State University, efforts of using formal methods to reverse engineering and re-engineering have been made [61] <ref> [32] </ref> [33] [60] [59]. The project involves a two-phase approach to reverse engineering that integrate a process for abstracting formal specifications from program code with a technique for identifying candidate objects in program code.
Reference: [33] <author> Cheng, B. H. C. and Gannod, G. C., </author> <title> "Abstraction of Formal Specifications from Program Code", </title> <booktitle> Proceedings for the 3rd International Conference on Tools for Artificial Intelligence, </booktitle> <year> 1991. </year>
Reference-contexts: Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach. At present, there are already some accomplished re-engineering tools, such as "Maintainer's Assistant" [140], "VIFOR" [118,132], "Rigi" and "AUTOSPEC" <ref> [33] </ref> [61] [32] [60]. Among these tools, we concentrated on two typical ones: Yang's Maintainer's Assistant and Cheng's AUTOSPEC. Generally speaking, each tool and the approach it based on makes progress in certain aspects, while remaining vast areas untouched and invaluable improvements unconsidered. <p> These are all positive features that make a formalism suitable for re-engineering field. Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec <ref> [33] </ref> [59]. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed [75]. Hoare Logic is one of the mathematical pillars for program verification and formal methods. <p> By using the semantics of predicate logic and other suitable formal logics, WP-Calculus has been proven to be a formalism suitable for reverse engineering of source code, especially at the lower abstraction levels <ref> [33] </ref> [59]. Since the similarity of WP-Calculus and Hoare Logic in syntax and semantics, please refer to subsection 3.2.1 for syntax and semantic details. 3.2.4 Modal Logic Modal logic [97] [36]is the study of context-dependent properties such as necessity and possibility. <p> we summarise several typical projects to illustrate the current situation. 54 4.2 Reverse Engineering with Formal Methods in MSU In the Software Engineering Research Center (SERC) of the Department of Computer Science, Michigan State University, efforts of using formal methods to reverse engineering and re-engineering have been made [61] [32] <ref> [33] </ref> [60] [59]. The project involves a two-phase approach to reverse engineering that integrate a process for abstracting formal specifications from program code with a technique for identifying candidate objects in program code.
Reference: [34] <author> Cheng, B. H. C. and Jeng, J. J., </author> <title> "Reusing Analogous Components", </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> Nov </month> <year> 1994. </year>
Reference-contexts: This is the most important method in reverse design. Concrete transformation rules and inference algorithms are defined according to concrete source code language. By these rules and certain form of knowledge & data bases, source code can be transformed into a higher level of abstraction [90] [8] [32] <ref> [34] </ref>. * Data Centred Program Understanding. Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships [80] [142]. * Program Slicing.
Reference: [35] <author> Chikofsky, E. J. and II, J. H. C., </author> <title> "Reverse Engineering and Design Recovery: A Taxonomy", </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Large systems are so complex that it is impossible for a single individual to build and maintain all aspects of its design. A major goal of software engineering is to enable developers to construct systems that operate reliably despite this complexity <ref> [35] </ref> [11] [10] [83]. One way of achieving this goal is by using formal methods, which are mathematically-based languages, techniques, and tools for specifying and verifying such systems. Use of formal methods does not a priori guarantee correctness. <p> finding the proof, however, the human user often gains invaluable insight into the system or the property being proved. 2.2 Software Re-engineering : Scope and Research Issues 2.2.1 Re-engineering in General: Definitions and Taxonomy The following key terms provide a clear scope and contents of the domain of software re-engineering <ref> [35] </ref> [11] [10] [58]: Forward Engineering is the traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation 6 of a system.
Reference: [36] <author> Chllas, B. F., </author> <title> Modal Logic: An Introduction, </title> <publisher> Cambridge University Press, </publisher> <year> 1980. </year>
Reference: [37] <author> Chu, W. C. and Yang, H., </author> <title> "A Formal Method for Software Maintenance", </title> <booktitle> IEEE International Conference on Software Maintenance (ICSM'96), </booktitle> <address> Monterey, CA , November 1996. </address>
Reference: [38] <author> Cimitile, A. and Carlini, U. D., </author> <title> "Reverse Engineering: Algorithms for Program Graph Production", </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 21, </volume> <pages> pp. </pages> <month> 519-537 (May </month> <year> 1991). </year>
Reference-contexts: Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] [106] [114] [99]. * Using graphs to represent source code information <ref> [38] </ref> [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [39] <author> Clark, E. M. and Wing, J. M., </author> <title> "Formal Methods: State of the Art and Future", </title> <type> Technical Report, </type> <year> 1996. </year>
Reference-contexts: There were only a few non-trivial case studies and together they still were not convincing enough to the practising software or hardware engineer.Few people had the training to use them effectively on the job <ref> [39] </ref>. Only recently have we begun to see a more promising picture for the future of formal methods. For software specification, industry is open to trying out notions like Z to document a system's properties more rigorously.
Reference: [40] <author> Clarke, E. and Emerson, E. A., </author> <title> "Synthesis of Synchronization Skeletons for Branching Time Temporal Logic", Logic of programs: </title> <booktitle> Workshop, </booktitle> <address> Yorktown Heighs, NY, </address> <month> May 1881, </month> <note> Vol. 131 (1981). </note>
Reference-contexts: Two general approaches to model checking are used in practice today. The first,temporal model checking, is a technique developed independently in the 1980s by Clarke and Emerson <ref> [40] </ref> and by Queille and Sifakis [117]. In this approach specifications are expressed in a temporal logic and systems are modelled as finite state transition systems. 5 An efficient search procedure is used to check whether a given finite state transition system is a model for the specification.
Reference: [41] <author> Clarke, E., Emerson, E. A. and Sistla, A. P., </author> <title> "Automatic Verification of Finite Concurrent Systems Using Temporal Logic Specifications: A Practical Approach", </title> <booktitle> Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: Assessment TPCTL is a logic essentially extending the branching time modalities of CTL <ref> [41] </ref> with time and probabilities. Since formulas are interpreted over TPCCS processes, which are observed through actions that label transitions, the semantics of TPCTL is defined in terms of transitions rather than states. TPCTL is one of the few logics that can express both hard and soft real-time deadlines.
Reference: [42] <author> Clarke, E. and Kurshan, R., </author> <title> "Computer-Aided Verification", </title> <journal> IEEE Spectrum, </journal> <volume> Vol. 33, </volume> <pages> pp. </pages> <month> 61-67 (06 </month> <year> 1996). </year>
Reference-contexts: The technical challenge in model checking is in devising algorithms and data structures that allow us to handle large search space. Model checking has been used primarily in hardware and protocol verification <ref> [42] </ref>; the current trend is to apply this technique to analysing specifications of software systems. Two general approaches to model checking are used in practice today. The first,temporal model checking, is a technique developed independently in the 1980s by Clarke and Emerson [40] and by Queille and Sifakis [117].
Reference: [43] <author> Clarke, E. M., Emerson, E. A. and Sisla, A. P., </author> <title> "Automatic Verification of Finite State Concurrent Systems Using Temporal Logic ", ACM Transactions on Programming Languages and Systems, </title> <journal> Vol. </journal> <volume> 8, </volume> <pages> pp. </pages> <month> 244-263 (April </month> <year> 1986). </year> <month> 69 </month>
Reference-contexts: Model checking for branching time logics has therefore been applied more successfully than that of linear time logics, although additional constructs must be employed to deal fairness <ref> [43] </ref> [29]. There is no consensus among researchers as to whether branching time or linear time logics are more suited to verification. In practice, branching time logics are usually used to verify finite state systems by model checking because of the efficiency of the model checking algorithms.
Reference: [44] <author> Clayton, R. and Rugaber, S., </author> <title> "The Representation Problem in Reverse Engineering", </title> <booktitle> Proceedings of the First Working Conference on Reverse Engineering, </booktitle> <address> Maryland, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Intermediate Representation of Source Code In large programs, it is more efficient to preprocess the source code and store the program information in an intermediate representation that allows fast queries instead of querying the source code directly <ref> [44] </ref>. There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information.
Reference: [45] <author> Cleaveland, R., Parrow, J. and Steffen, B., </author> <title> "The Concurrency Workbench: A Semantics-based tool for the verification of Concurrent Systems", </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 15, </volume> <pages> pp. </pages> <month> 36-72 (Jan </month> <year> 1993). </year>
Reference-contexts: Different notions of conformance have been explored, including language inclusion [69] [86], refinement orderings <ref> [45] </ref> [124], and observational equivalence [45] [56]. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast. <p> Different notions of conformance have been explored, including language inclusion [69] [86], refinement orderings <ref> [45] </ref> [124], and observational equivalence [45] [56]. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast.
Reference: [46] <author> Dietrich, S. W. and Calliss, F. W., </author> <title> "The Application of Deductive Databases to Inter-module Code Analysis", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1991, </booktitle> <year> 1991. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] <ref> [46] </ref> [106] [114] [99]. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [47] <author> Dijkstra, E. W., </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976, </year> <note> ISBN 0-13-215871-X. </note>
Reference-contexts: Relative semantics and proof systems are also dealt with. This extension and its idea are useful when we try to apply Hoare Logic in the re-engineering of real-time systems. 3.2.3 WP-Calculus Weakest Precondition Calculus <ref> [47] </ref> was first proposed by E. W. Dijkstra in 1976. A precondition describes the initial state of a program, and a postcondition describes the final state.
Reference: [48] <author> Dijkstra, E. W. and Scholten, C. S., </author> <title> Predicate Calculus and Program Semantics, </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Examples of these form are TAM [130] and the Refinement Calculus [128]. Hoare Logic, WP-Calculus and ITL are treated as sample descriptions. 20 3.2.1 Hoare Logic Overview Hoare Logic has a long history, it may be viewed as an extension of First-order Predicate Calculus <ref> [48] </ref> that includes inference rules for reasoning about programming language constructs. Hoare Logic can play a special role in the first stage of reverse engineering, i.e. drawing the first or lowest level of abstraction from source code program.
Reference: [49] <author> Duke, R. and al., et., </author> <title> The Object-Z Specification Language: </title> <type> Version 1, </type> <year> 1991. </year>
Reference-contexts: It is one of the few formal methods that has been proved successful in industrial applications. In recent years, some forms of improved Z with new technology such as object-orientation has been developed, for example, Z ++ and Object-Z <ref> [49] </ref> [50]. Generally speaking, Z is suitable for being the formal foundation of certain reverse engineering approaches because it is easy to use, capable of industrial applications and has a good development methodology based on schema hierarchy. Z has already been used in some reverse engineering applications.
Reference: [50] <author> Duke, R. and al., et., </author> <title> The Object-Z: A Specification Language Advocated for the Description of Standards, </title> <type> Technique Report 94-45, </type> <year> 1994. </year>
Reference-contexts: It is one of the few formal methods that has been proved successful in industrial applications. In recent years, some forms of improved Z with new technology such as object-orientation has been developed, for example, Z ++ and Object-Z [49] <ref> [50] </ref>. Generally speaking, Z is suitable for being the formal foundation of certain reverse engineering approaches because it is easy to use, capable of industrial applications and has a good development methodology based on schema hierarchy. Z has already been used in some reverse engineering applications.
Reference: [51] <author> Eijk, P. H. J. van, Vissers, C. A. and Diaz, M., </author> <title> The Formal Description Technique LOTOS, </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: Since LOTOS has an operational semantics, it is possible to implement these semantics in an interpreter. LOTOS has `a number of' various support tools. Although the tools are not mature or narrow-aspected, do have some successful points <ref> [51] </ref>. The development methodology of LOTOS is based on actions. LOTOS is easy to use, and has a rather large number of supporting tools.
Reference: [52] <author> Elseaidy, W., Cleaveland, R. and Baugh, J., </author> <title> "Modeling and Verifying Active Structural Control Systems", </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1996. </year>
Reference-contexts: In 1987 McMillan used Bryant's ordered binary decision diagrams (BDDs) [23] to represent state transition systems efficiently, thereby increasing the size of the systems that could be verified. Other promising approaches to alleviating state explosion include the exploitation of partial order information [115], localisation reduction [86], and semantic minimisation <ref> [52] </ref> to eliminate unnecessary states from a system model. Theorem Proving Theorem proving is a technique where both the system and its desired properties are expressed as formulas in some mathematical logic. It is a process of finding a proof of a property from the axioms of the system.
Reference: [53] <author> Emerson, E. A., Mok, A. K. and Sistla, A. P., </author> <title> "Quantitative Temporal Reasoning", In E.M. </title> <editor> Clarke, A.Pnueli and J. Sifakis, editors, </editor> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, </booktitle> <year> 1989. </year>
Reference-contexts: The complexity of model checking is exponential in the number of clocks (each new process or hardware device needs its own clock), and doubly exponential in the product of the timing constants that appear in the formula. It is linear in the product of program and formula size. In <ref> [53] </ref>, a bounded operator branching time logic called Real-Time Computation Tree Logic (RTCTL) is introduced. The satisfiability problem in this logic is doubly-exponential-time-complete. Model checking has a poly time algorithm. On the basis of TCTL, a branching time logic called TPCTL is introduced in [67].
Reference: [54] <author> Etessami, F. S. and Hura, G. S., </author> <title> "Rule-based Design Methodology for Solving Control Problems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <pages> pp. </pages> <month> 274-282 (March </month> <year> 1991). </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets [119]. Both have been used extensively <ref> [54] </ref> [17] [19] [89] [120]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [55] <author> Fencott, C., </author> <title> Formal Methods for Concurrency, </title> <publisher> International Thomson Publishing Company, </publisher> <address> ISBN 1-85032-173-6, </address> <year> 1996. </year>
Reference-contexts: It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems. At present, several variations of CCS has been developed, which forms a CCS family. CCS family includes CCS, CCS+, CCS*, SCCS, TCCS and TPCCS <ref> [55] </ref>. Syntax and Semantics Two underlying concepts of CCS are agents and actions.
Reference: [56] <author> Fernandez, J., Garavel, C., Kerbrat, A. and Mounier, R., "CADP: </author> <title> A Protocol Validation and Verification Toolbox", </title> <booktitle> Proc. of the 8th Conference on Computer-Aided Verification, </booktitle> <address> New Jersey, USA. </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Different notions of conformance have been explored, including language inclusion [69] [86], refinement orderings [45] [124], and observational equivalence [45] <ref> [56] </ref>. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast.
Reference: [57] <author> Gabrielian, A. and Franklin, M. K., </author> <title> "State-based Specification of Complex Real-time Systems", </title> <booktitle> Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: It represents an improved version of the structured methods. A graphic tool called "State-mate" [5] exists to implement the formalism. Methods similar to that of Statecharts may be found in <ref> [57] </ref>.
Reference: [58] <author> Gallagher, K. B. and Lyle, J. R., </author> <title> "Using Program Slicing in Software Maintenance", </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> August </month> <year> 1991. </year>
Reference-contexts: however, the human user often gains invaluable insight into the system or the property being proved. 2.2 Software Re-engineering : Scope and Research Issues 2.2.1 Re-engineering in General: Definitions and Taxonomy The following key terms provide a clear scope and contents of the domain of software re-engineering [35] [11] [10] <ref> [58] </ref>: Forward Engineering is the traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation 6 of a system. <p> A program slice is a fragment of a program in which some statements are omitted that are not necessary to understand a certain property of the program <ref> [58] </ref> [18]. 2.2.3 Re-engineering Tools Automation is one of the most important features of software re-engineering. Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach.
Reference: [59] <author> Gannod, C. and Cheng, B. H. C., </author> <title> "Strongest Postcondition Semantics as a Basis for Reverse Engineering", </title> <booktitle> Proc. of IEEE Working Conference on Reverse Engineering, </booktitle> , <address> Toronto, Ontario, </address> <month> July, </month> <year> 1995. </year>
Reference-contexts: These are all positive features that make a formalism suitable for re-engineering field. Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec [33] <ref> [59] </ref>. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed [75]. Hoare Logic is one of the mathematical pillars for program verification and formal methods. <p> By using the semantics of predicate logic and other suitable formal logics, WP-Calculus has been proven to be a formalism suitable for reverse engineering of source code, especially at the lower abstraction levels [33] <ref> [59] </ref>. Since the similarity of WP-Calculus and Hoare Logic in syntax and semantics, please refer to subsection 3.2.1 for syntax and semantic details. 3.2.4 Modal Logic Modal logic [97] [36]is the study of context-dependent properties such as necessity and possibility. <p> several typical projects to illustrate the current situation. 54 4.2 Reverse Engineering with Formal Methods in MSU In the Software Engineering Research Center (SERC) of the Department of Computer Science, Michigan State University, efforts of using formal methods to reverse engineering and re-engineering have been made [61] [32] [33] [60] <ref> [59] </ref>. The project involves a two-phase approach to reverse engineering that integrate a process for abstracting formal specifications from program code with a technique for identifying candidate objects in program code.
Reference: [60] <author> Gannod, C. and Cheng, B. H. C., </author> <title> "A Two-Phase Approach to Reverse Engineering using Formal Methods", </title> <booktitle> Proc. of Formal Methods in Programming and Their Applications Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach. At present, there are already some accomplished re-engineering tools, such as "Maintainer's Assistant" [140], "VIFOR" [118,132], "Rigi" and "AUTOSPEC" [33] [61] [32] <ref> [60] </ref>. Among these tools, we concentrated on two typical ones: Yang's Maintainer's Assistant and Cheng's AUTOSPEC. Generally speaking, each tool and the approach it based on makes progress in certain aspects, while remaining vast areas untouched and invaluable improvements unconsidered. <p> summarise several typical projects to illustrate the current situation. 54 4.2 Reverse Engineering with Formal Methods in MSU In the Software Engineering Research Center (SERC) of the Department of Computer Science, Michigan State University, efforts of using formal methods to reverse engineering and re-engineering have been made [61] [32] [33] <ref> [60] </ref> [59]. The project involves a two-phase approach to reverse engineering that integrate a process for abstracting formal specifications from program code with a technique for identifying candidate objects in program code.
Reference: [61] <author> Gannod, G. C. and Cheng, B. H., </author> <title> "Facilitating the Maintenance of Safety-Critical Systems Using Formal Methods", </title> <journal> The International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> Vol. </volume> <month> 4 (Febuary </month> <year> 1994). </year>
Reference-contexts: Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach. At present, there are already some accomplished re-engineering tools, such as "Maintainer's Assistant" [140], "VIFOR" [118,132], "Rigi" and "AUTOSPEC" [33] <ref> [61] </ref> [32] [60]. Among these tools, we concentrated on two typical ones: Yang's Maintainer's Assistant and Cheng's AUTOSPEC. Generally speaking, each tool and the approach it based on makes progress in certain aspects, while remaining vast areas untouched and invaluable improvements unconsidered. <p> this section, we summarise several typical projects to illustrate the current situation. 54 4.2 Reverse Engineering with Formal Methods in MSU In the Software Engineering Research Center (SERC) of the Department of Computer Science, Michigan State University, efforts of using formal methods to reverse engineering and re-engineering have been made <ref> [61] </ref> [32] [33] [60] [59]. The project involves a two-phase approach to reverse engineering that integrate a process for abstracting formal specifications from program code with a technique for identifying candidate objects in program code.
Reference: [62] <author> Gerber, R. and Lee, I., </author> <title> "A Proof System for Communicating Shared Resources", </title> <booktitle> Proceedings of the Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: A dense time domain is used. * ATP (Algebra of Timed Processes) [108]. * CCSR (Calculus of Communication Shared Resources based on CCS [63] <ref> [62] </ref>. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] [126]. A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) [103].
Reference: [63] <author> Gerber, R. and Lee, I., "CCSR: </author> <title> a Calculus for Communicating Shared Resources", </title> <note> In CONCUR'90, LNCS 458, 1990. 70 </note>
Reference-contexts: A dense time domain is used. * ATP (Algebra of Timed Processes) [108]. * CCSR (Calculus of Communication Shared Resources based on CCS <ref> [63] </ref> [62]. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] [126]. A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) [103].
Reference: [64] <author> Ghezzi, C., Mandrioli, D., Morasca, S. and Pezze, M., </author> <title> "A General Way to Put Time into Petri Nets", </title> <journal> CACM, </journal> <year> 1989. </year>
Reference-contexts: The resulting semantics is quite elegant because both the timing and the colour are attributes of tokens. A software tool called ExSpect is available for performing analysis on ITCPNs. TB-Net|A Version of Timed Petri Net 51 In TB-Nets <ref> [64] </ref> the tokens are themselves time stamped with the time at which their creating transition was fired. A function is associated with each other which is parameterised over the time stamps of the tokens in the transition's input places, and defines an interval within which firing may take place.
Reference: [65] <author> Goguen, J. and Tardo, J., </author> <title> "An Introduction to OBJ: A Language for Writing and Testing Software Specifications,", </title> <editor> In Marvin Zelkowitz editor, </editor> <booktitle> Specification of Reliable Software, </booktitle> <year> 1979, </year> <note> Reprinted by Addison Wesley in 1985, `Specification Techniques', p391-420. </note>
Reference-contexts: Similar to the model-based approach, there is no explicit representation of concurrency. 3.3.1 OBJ OBJ <ref> [65] </ref> is a wide spectrum first-order functional language that is rigorously based on equational logic. This semantic basis supports a declarative specification style, facili tates program verification, and allows OBJ to be used as a theorem prover.
Reference: [66] <author> Guttag, J. and Horning, J., </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: One current trend is to integrate different specification languages, each able to handle a different aspect of a system. Another is to handle non-behavioural aspects of a system like its performance, real-time constraints, security policies, and architectural design. Some formal methods such as Z [134], VDM [82] and Larch <ref> [66] </ref> focus on specifying the behaviour of sequential systems. States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. <p> Since OBJ is based on order sorted algebra or order sorted equational logic, which is not suitable to express a system at different abstraction levels, OBJ is not suitable for being the formal foundation of reverse engineering approaches. 3.3.2 LARCH The Larch <ref> [66] </ref> family of algebraic specification languages was developed at MIT and Xerox PARC to support the productive use of formal specifications in programming.
Reference: [67] <author> Hansson, H. A., </author> <title> "Time and Probability in Formal Design of Distributed Systems", Real-Time Safety Critical Systems Series, </title> <booktitle> Vol. </booktitle> <month> 2 </month> <year> (1994). </year>
Reference-contexts: In [53], a bounded operator branching time logic called Real-Time Computation Tree Logic (RTCTL) is introduced. The satisfiability problem in this logic is doubly-exponential-time-complete. Model checking has a poly time algorithm. On the basis of TCTL, a branching time logic called TPCTL is introduced in <ref> [67] </ref>. The logic deals with real-time constraints and reliability. We will mainly discuss it as an example of branching time logic. Overview of TPCTL TPCTL [67] deals with real-time constraints and reliability. Formulas of TPCTL are interpreted over a discrete time extension of Milner's Calculus of Communication Systems called TPCCS. <p> Model checking has a poly time algorithm. On the basis of TCTL, a branching time logic called TPCTL is introduced in <ref> [67] </ref>. The logic deals with real-time constraints and reliability. We will mainly discuss it as an example of branching time logic. Overview of TPCTL TPCTL [67] deals with real-time constraints and reliability. Formulas of TPCTL are interpreted over a discrete time extension of Milner's Calculus of Communication Systems called TPCCS. Probabilities are introduced by allowing two types of transitions, one labeled with actions and the other labeled with probabilities. <p> However, TCSP is not well developed, so we can only say that TCSP has some potential for being the foundation of reverse engineering approaches. Until now there is no application of TCSP in reverse engineering field. 3.4.6 Timed Probabilistic CCS (TPCCS) Overview Timed Probabilistic Calculus of Communicating Systems (TPCCS) <ref> [67] </ref> is essentially an extension of Milner's CCS with discrete time and probabilities. To increase the description ability, a logic named Timed Probabilistic Computation Tree Logic (TPCTL) is proposed to describe the logic of and between TPCCS processes. <p> A verification method for automatically proving that a system described in TPCCS satisfies properties formulated in TPCTL, is also well defined <ref> [67] </ref>. Syntax and Semantics TPCCS introduces the probabilities to CCS by the new probabilistic choice operator . <p> However, until now there is no application of TPCCS in reverse engineering area. A tool named Timing and Probability Workbench (TPWB) has been developed <ref> [67] </ref>. TPWB Partially supports automatic verification of TPCCS. However, the calculation of probabilities is not mentioned in TPCCS and TPCTL. 3.4.7 Varieties of Timed Process Algebras Untimed process algebras have been extended with timing constructs in several ways including: * ACP (Real-Time ACP) [13]. <p> A complete set of axioms is presented for discrete time domains, but the semantics can be given as either discrete or dense. * TCCS (Timed CCS) [138]. Discrete or dense time domains can be used. * TPCCS (Timed Probabilistic CCS) <ref> [67] </ref>. TPCCS adopts a discrete time domain. It will be discussed later. * TPL (Temporal Process Language) [71]. A discrete time domain is used. * U-LOTOS (Urgent LOTOS) [21].
Reference: [68] <author> Harel, D., "Statecharts: </author> <title> A Visual Formalism for Complex Systems", </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 8, </volume> <pages> pp. </pages> <month> 234-274 (February </month> <year> 1987). </year>
Reference-contexts: States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. Other methods such as CSP [72], CCS [102], Statecharts <ref> [68] </ref>, Temporal Logic [95] and I/O automata [92] focus on specifying the behaviour of concurrent systems; states typically range over simple domains like integers or are left uninterpreted, and behaviour is defined in terms of sequences, trees, or partial orders of events.
Reference: [69] <author> Harel, D., </author> <title> "Biting the Silver Bullet: Toward a Brighter Future for System development", </title> <journal> IEEE Computer, </journal> <volume> Vol. 25, </volume> <pages> pp. </pages> <month> 8-20 (Jan </month> <year> 1992). </year>
Reference-contexts: In the second approach, the specification is given as an automation, then the system, also modelled as an automation, is compared to the specification to determine whether or not its behaviour conforms to that of the specification. Different notions of conformance have been explored, including language inclusion <ref> [69] </ref> [86], refinement orderings [45] [124], and observational equivalence [45] [56]. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast.
Reference: [70] <author> Harel, E. and Lichtenstein, O., </author> <title> "Explicit Clock temporal Logic", </title> <booktitle> Proceedings of 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: TPTL uses auxiliary static timing variables to record the value of clock at different states, but replaces the explicit references to the clock itself by a special type of freezing quantification. * MITL <ref> [70] </ref>. MITL employs a dense time domain. It has a bounded-operator syntax, but cannot express punctuality properties.
Reference: [71] <author> Hennessy, M. and Regan, T., </author> <title> "A Process Algebra for Timed Systems", </title> <type> Technical Report5/91, </type> <institution> UK, </institution> <year> 1991. </year>
Reference-contexts: Discrete or dense time domains can be used. * TPCCS (Timed Probabilistic CCS) [67]. TPCCS adopts a discrete time domain. It will be discussed later. * TPL (Temporal Process Language) <ref> [71] </ref>. A discrete time domain is used. * U-LOTOS (Urgent LOTOS) [21]. Discrete or dense time domains can be used. 48 3.5 Net-based Approach Graphical notations are popular notations for specifying systems as they are easier to comprehend and, hence, more accessible to non-specialists.
Reference: [72] <author> Hoare, C. A. R., </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Some formal methods such as Z [134], VDM [82] and Larch [66] focus on specifying the behaviour of sequential systems. States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. Other methods such as CSP <ref> [72] </ref>, CCS [102], Statecharts [68], Temporal Logic [95] and I/O automata [92] focus on specifying the behaviour of concurrent systems; states typically range over simple domains like integers or are left uninterpreted, and behaviour is defined in terms of sequences, trees, or partial orders of events. <p> These systems are more complex for a number of reasons|they are necessarily concurrent, they may utilise a number of different physical or logical clocks, and they need communication mechanisms. Concur-rency is perhaps the smallest problem|the formal representation of concurrency is now a well studied area [100] <ref> [72] </ref>. Multiple clocks remains an area of controversy and there are a number of theoretical issues which affect the intuitive choice of temporal model for such systems. Communications mechanism are most commonly used in concurrent systems, they have been studied in some depth and can be formally represented [145]. <p> Since this original proposal did not include a proof method, a complete version of CSP was proposed in <ref> [72] </ref>. Syntax and Semantics A CSP specification is a hierarchy of processes. A complete specification can be viewed as a single process which is composed of sub-processes, each of which is decomposed into component processes.
Reference: [73] <author> Hoare, C. A. R., </author> <title> "An Axiomatic Basis for Computer Programming", </title> <journal> Communications of ACM , Vol. </journal> <volume> 12, </volume> <pages> pp. </pages> <month> 576-580 (October </month> <year> 1969). </year>
Reference-contexts: Syntax and Semantics Suppose that q1 and q2 are program fragments, and q1; q2 is their composition, and P , Q and R are predicates about the program state. In <ref> [73] </ref> Hoare introduced the notation P fq1gQ to mean that if the predicate P is true of the program state prior to the execution of program fragment q1, then the predicate Q will be true of the program state on the termination of the program fragment q1. <p> P is a program, and q and r are first order predicates <ref> [73] </ref>. Hoare triples can only express partial correctness (properties that hold if the program terminates). This however is not suitable for real-time programs which 22 must deal with non-terminating processes and intensive interaction with the environ-ment. Therefore Hoare triples are extended with a third assertion C called a commitment.
Reference: [74] <author> Hoare, C. A. R., </author> <title> "Communicating Sequential Processes", </title> <journal> Communication of ACM , Vol. </journal> <volume> 21, </volume> <pages> pp. </pages> <month> 666-677 (08 </month> <year> 1978). </year>
Reference-contexts: CCS, CSP and LOTOS will be treated as sample descriptions. 3.4.1 Communicating Sequential Processes (CSP) Overview The Communicating Sequential Processes formal (CSP) specification notation for concurrent systems was first introduced in <ref> [74] </ref>. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [72]. Syntax and Semantics A CSP specification is a hierarchy of processes.
Reference: [75] <author> Hooman, J., </author> <title> "Specification and Compositional Verification of Real-Time Systems", </title> <type> PhD Thesis, </type> <institution> Eindhoven, </institution> <address> the Netherlands, </address> <year> 1991. </year>
Reference-contexts: Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec [33] [59]. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed <ref> [75] </ref>. Hoare Logic is one of the mathematical pillars for program verification and formal methods. Hoare Logic and its variants are used in numerous formal methods tools. 3.2.2 Real-Time Hoare Logic Extensions in Real-Time Hoare Logic In [75] [77], an assertional style of reasoning about real-time systems is introduced, based on <p> A Real-time Hoare Logic has been proposed <ref> [75] </ref>. Hoare Logic is one of the mathematical pillars for program verification and formal methods. Hoare Logic and its variants are used in numerous formal methods tools. 3.2.2 Real-Time Hoare Logic Extensions in Real-Time Hoare Logic In [75] [77], an assertional style of reasoning about real-time systems is introduced, based on classical Hoare triples fqgP frg. P is a program, and q and r are first order predicates [73]. Hoare triples can only express partial correctness (properties that hold if the program terminates).
Reference: [76] <author> Hooman, J., Ramesh, S. and Roever, W. P. de, </author> <title> "A Compositional Semantics for Statecharts", </title> <type> Technical Report, </type> <institution> The Netherland, </institution> <year> 1989. </year>
Reference-contexts: However, Timed Petri Nets suffer from the same disadvantages as all Petri Nets, i.e. a lack of compositionality, both in syntax and semantics. Nets need to be complete before any properties are proven, or reachability graphs drawn. 3.5.3 Statecharts Overview Statecharts <ref> [76] </ref> provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "State-mate" [5] exists to implement the formalism. Methods similar to that of Statecharts may be found in [57].
Reference: [77] <author> Hooman, J. and Roever, W. P. de, </author> <title> "Design and Verification in Real-Time Distributed Computing: an Introduction to Compositional Methods", </title> <booktitle> Proceedings of the 9th International Symposium on Protocol Specification, Testing and Verification, </booktitle> <publisher> North Holland, </publisher> <year> 1989. </year>
Reference-contexts: A Real-time Hoare Logic has been proposed [75]. Hoare Logic is one of the mathematical pillars for program verification and formal methods. Hoare Logic and its variants are used in numerous formal methods tools. 3.2.2 Real-Time Hoare Logic Extensions in Real-Time Hoare Logic In [75] <ref> [77] </ref>, an assertional style of reasoning about real-time systems is introduced, based on classical Hoare triples fqgP frg. P is a program, and q and r are first order predicates [73]. Hoare triples can only express partial correctness (properties that hold if the program terminates).
Reference: [78] <author> ISO, </author> <title> "Information Systems Processing|Open Systems Interconnection|LOTOS", </title> <type> Technical Report, </type> <year> 1987. </year>
Reference-contexts: Still others such as RAISE [109] and LOTOS <ref> [78] </ref> wed two different methods, one for handling rich state spaces and one for handling complexity due to concurrency. Common to all these methods is the use of the mathematical concepts of abstraction and composition. The process of specification is the act of writing things down precisely. <p> CCS also supports modular abstraction based on processes, which gives CCS some advantage in reverse engineering and re-engineering applications. Until now there is no application of CCS in reverse engineering yet. 3.4.3 LOTOS Overview LOTOS <ref> [78] </ref> [91]was developed to define implementation-independent formal standards of OSI services and protocols. LOTOS stands for Language Of Temporal Ordering Specification because it is used to model the order in which the events of a system occurs. LOTOS has two very clearly separated parts. <p> Behavioural aspects of LOTOS are very relevant, even predominant. 43 LOTOS has a formally defined syntax, static semantics and dynamic semantics. The static semantics are defined by an attributed grammar <ref> [78] </ref> and the dynamic semantics are described operationally in terms of inference rules. Since LOTOS has an operational semantics, it is possible to implement these semantics in an interpreter. LOTOS has `a number of' various support tools.
Reference: [79] <author> Jahanian, F. and Mok, A., </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. </volume> <month> 12 (09 </month> <year> 1986). </year>
Reference-contexts: Obviously Duration Calculus has the potential for the applications in re-engineering. However, until now there is not any application of Duration Calculus in reverse engineering. 3.2.10 Real Time Logic (RTL) Overview RTL <ref> [79] </ref> is a real-time logic with four basic concepts: actions which may be composite or primitive, state predicates which provide assertions regarding the physical system 32 state, events which are markers on the (sparse) time line, and timing constraints which provide assertions about the timing of events. <p> Safety and liveness properties are expressed in RTL, and are then proven using a predicate logic proof system. The following example is a fragment from the `Martian Lander' case study presented in <ref> [79] </ref>. The specification asserts that the lander may perform normal landing actions, or be interpreted with error conditions and asked to perform emergency landing actions.
Reference: [80] <author> Joiner, J. K., Tsai, W. T., Chen, X. P. and Subramanian, S., </author> <title> "Data-centered Program Understanding", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1994, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships <ref> [80] </ref> [142]. * Program Slicing. A program slice is a fragment of a program in which some statements are omitted that are not necessary to understand a certain property of the program [58] [18]. 2.2.3 Re-engineering Tools Automation is one of the most important features of software re-engineering.
Reference: [81] <author> Jones, C. B., </author> <title> Software Development: A Rigorous Approach, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1980. </year>
Reference-contexts: VDM is firstly presented in <ref> [81] </ref> and [20]. It is similar to Z in most aspects. VDM is also a popularly accepted approach to systematic program development, although not so popular as Z. In this survey, we give VDM a rather concise review which is based on a comparison with Z.
Reference: [82] <author> Jones, C. B., </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice-Hall International, Inc., </publisher> <address> London, </address> <year> 1986. </year>
Reference-contexts: One current trend is to integrate different specification languages, each able to handle a different aspect of a system. Another is to handle non-behavioural aspects of a system like its performance, real-time constraints, security policies, and architectural design. Some formal methods such as Z [134], VDM <ref> [82] </ref> and Larch [66] focus on specifying the behaviour of sequential systems. States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. <p> Z also has some available automated tools and a rather strong potential for the automation in re-engineering although this is limited to some extent by lacking of a fully complete formal semantics. 3.1.2 VDM Overview VDM (the Vienna Development Method) is a formal method for rigorous computing system development <ref> [82] </ref>. VDM is firstly presented in [81] and [20]. It is similar to Z in most aspects. VDM is also a popularly accepted approach to systematic program development, although not so popular as Z.
Reference: [83] <author> Karlsson, E-A'e, </author> <title> Software Reuse-a Holistic Approach, </title> <publisher> John Wiley Ltd, </publisher> <address> ISBN 0471 95489 6, </address> <year> 1995. </year>
Reference-contexts: Large systems are so complex that it is impossible for a single individual to build and maintain all aspects of its design. A major goal of software engineering is to enable developers to construct systems that operate reliably despite this complexity [35] [11] [10] <ref> [83] </ref>. One way of achieving this goal is by using formal methods, which are mathematically-based languages, techniques, and tools for specifying and verifying such systems. Use of formal methods does not a priori guarantee correctness.
Reference: [84] <author> Kinloch, D. A. and Munro, M., </author> <title> "Understanding C Programs Using the Combined C Graph Representation", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1994, </booktitle> <month> September </month> <year> 1994. </year> <month> 71 </month>
Reference-contexts: Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] [106] [114] [99]. * Using graphs to represent source code information [38] [90] <ref> [84] </ref>. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains. On the one hand, this process must be bottom-up, since the only reliable description of the behaviour of software is its source code.
Reference: [85] <author> Koymans, R., </author> <title> "Specifying Real-Time Properties with Metric Temporal Logic", </title> <journal> Real--Time Systems, </journal> <volume> Vol. 2, </volume> <pages> pp. </pages> <month> 255-299 (November </month> <year> 1990). </year>
Reference-contexts: Other Varieties of RTTL 26 There are several varieties of RTTL, which are restricted to finite state and propo- sitional temporal properties. Here, we give a short introduction to them. * Metric Temporal Logic (MTL) <ref> [85] </ref> [6]. MTL is a discrete time propositional version of the bounded operator logic. It is a variety of RTTL in which references to time are restricted to bounds on the temporal operators.
Reference: [86] <author> Kurshan, R. P., </author> <title> Computer-Aided Verification of Coordinating Processes, </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: In the second approach, the specification is given as an automation, then the system, also modelled as an automation, is compared to the specification to determine whether or not its behaviour conforms to that of the specification. Different notions of conformance have been explored, including language inclusion [69] <ref> [86] </ref>, refinement orderings [45] [124], and observational equivalence [45] [56]. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast. <p> In 1987 McMillan used Bryant's ordered binary decision diagrams (BDDs) [23] to represent state transition systems efficiently, thereby increasing the size of the systems that could be verified. Other promising approaches to alleviating state explosion include the exploitation of partial order information [115], localisation reduction <ref> [86] </ref>, and semantic minimisation [52] to eliminate unnecessary states from a system model. Theorem Proving Theorem proving is a technique where both the system and its desired properties are expressed as formulas in some mathematical logic.
Reference: [87] <author> Lano, K. C. and Haughton, H. P., </author> <title> "Formal Development in B", </title> <journal> Information and Software Technology, </journal> <volume> Vol. 37, </volume> <pages> pp. </pages> <month> 303-316 (June </month> <year> 1995). </year>
Reference-contexts: It has not so many applications and automated tools as Z. No cases of applying VDM in reverse engineering field have been found. However, the similarity between VDM and Z still makes VDM a formalism with the potential for applications in re-engineering field. 3.1.3 B-Method Overview The B-method <ref> [87] </ref> [88] [139]uses the Abstract Machine Notation to support the description of the target systems. The most eminent success of B method is that it already has a strong and quite mature tool|B Toolkit, to support and automate the development of application systems.
Reference: [88] <author> Lano, K., </author> <title> The B Language and Method: A Guide to Practical Formal Development, </title> <publisher> Springer-Verlag, </publisher> <address> ISBN 3-540-76033-4, </address> <year> 1996. </year>
Reference-contexts: It has not so many applications and automated tools as Z. No cases of applying VDM in reverse engineering field have been found. However, the similarity between VDM and Z still makes VDM a formalism with the potential for applications in re-engineering field. 3.1.3 B-Method Overview The B-method [87] <ref> [88] </ref> [139]uses the Abstract Machine Notation to support the description of the target systems. The most eminent success of B method is that it already has a strong and quite mature tool|B Toolkit, to support and automate the development of application systems.
Reference: [89] <author> Leveson, N. G. and stolzy, J. L., </author> <title> "Safety Analysis Using Petri Nets", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 13, </volume> <pages> pp. </pages> <month> 386-397 (March </month> <year> 1987). </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets [119]. Both have been used extensively [54] [17] [19] <ref> [89] </ref> [120]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [90] <author> Livadas, P. E. and Roy, P. K., </author> <title> "Program Dependence Analysis", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1992, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] [106] [114] [99]. * Using graphs to represent source code information [38] <ref> [90] </ref> [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains. On the one hand, this process must be bottom-up, since the only reliable description of the behaviour of software is its source code. <p> This is the most important method in reverse design. Concrete transformation rules and inference algorithms are defined according to concrete source code language. By these rules and certain form of knowledge & data bases, source code can be transformed into a higher level of abstraction <ref> [90] </ref> [8] [32] [34]. * Data Centred Program Understanding. Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships [80] [142]. * Program Slicing.
Reference: [91] <author> Logrippo, L., Melanchuk, T. and Wors, R. J. D., </author> <title> "The Algebraic Specification Language LOTOS: an Industrial Experience", </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 15, </volume> <pages> pp. </pages> <month> 59-66 (04 </month> <year> 1990). </year>
Reference: [92] <author> Lynch, N. and Tuttle, M., </author> <title> "Hierarchical Correctness Proofs for Distributed Algorithms", </title> <type> Technical Report, </type> <address> Cambridge, MA, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. Other methods such as CSP [72], CCS [102], Statecharts [68], Temporal Logic [95] and I/O automata <ref> [92] </ref> focus on specifying the behaviour of concurrent systems; states typically range over simple domains like integers or are left uninterpreted, and behaviour is defined in terms of sequences, trees, or partial orders of events.
Reference: [93] <author> Mahoney, B. P. and Hayes, I. J., </author> <title> "A Case Study in Timed Refinement: A Mine Pump", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 18, </volume> <pages> pp. </pages> <month> 817-825 (09 </month> <year> 1992). </year>
Reference-contexts: Time is not a part of Z notation. When trying to apply Z to real-time domain, novel features have to be added to Z. However, because of the rich expressibility of Z, Z has been used in a number of real-time applications, such as timed Z <ref> [93] </ref>. The main users of Z are found in UK and other European countries. Generally speaking, Z has been applied to a large number of applications, some of which are rather large-scaled. It is one of the few formal methods that has been proved successful in industrial applications.
Reference: [94] <author> Manna, Z., </author> <title> "The Anchored Version of the Temporal Framework", </title> <editor> In J.W. de Bakker, W.P. de Roever and G. Rozenburg, editors, </editor> <title> Models of Concurrency: Linear, Branching and Partial Orders, </title> <year> 1989. </year>
Reference-contexts: In branching time semantics, time has a tree-like nature in which, at each instant, time may split into alternative courses representing different choices made by a system. * Partial order semantics. Partial order semantics has been explored only recently. The reader is referred to <ref> [94] </ref> for further information. Once the type of structure to be used for interpreting temporal formulas is selected, there is still a further decision to be made. How are the structures to represent program executions or computations? There are at least two possibilities: * Maximal parallelism. <p> The number of instructions in concurrent processes that can be executed simultaneously is maximised. Thus, two processes are never both waiting to achieve a shared communication. * Interleaved executions. Concurrent activity of two parallel processes is represented by interleaving their atomic actions <ref> [94] </ref>. Fairness and time bound constraints are then used to exclude inappropriate interleavings (e.g. a sequence in which an enabled action is never executed). 24 The various temporal logics can be used to reason about qualitative temporal prop-erties.
Reference: [95] <author> Manna, Z. and Pnueli, A., </author> <title> The Temporal Logic of Concurrent Systems: Specification, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. Other methods such as CSP [72], CCS [102], Statecharts [68], Temporal Logic <ref> [95] </ref> and I/O automata [92] focus on specifying the behaviour of concurrent systems; states typically range over simple domains like integers or are left uninterpreted, and behaviour is defined in terms of sequences, trees, or partial orders of events.
Reference: [96] <author> Manna, Z. and Pnueli, A., </author> <title> The Temporal Logic of Reactive and Concurrent Systems, </title> <publisher> Springer-Verlag, </publisher> <address> ISBN 0-387-97664-7, </address> , <year> 1996. </year>
Reference-contexts: The new formalism was soon seen as a potentially valuable tool for analysing the topology of time. Various types of semantics can be given to the temporal operators depending on whether time is linear,parallel or branching. Another aspect is whether time is discrete or continuous <ref> [96] </ref>. Temporal logic is state-based. A structure of states is the key concept that makes temporal logic suitable for system specification. Mainly, there are the following different types of temporal semantics [96]: * Interval semantics. <p> Another aspect is whether time is discrete or continuous <ref> [96] </ref>. Temporal logic is state-based. A structure of states is the key concept that makes temporal logic suitable for system specification. Mainly, there are the following different types of temporal semantics [96]: * Interval semantics. The semantics is based on intervals of time, thought of as representing finite chunks of system behaviour.
Reference: [97] <author> Mehmet, A. and Wanli, M., </author> <title> "An Overview of Temporal Logic Programming", </title> <booktitle> First International Conference, ICTL'94, Lecture Notes in AI , Vol. </booktitle> <volume> 827, </volume> <pages> pp. </pages> <month> 445-481 </month> <year> (1994). </year>
Reference-contexts: Since the similarity of WP-Calculus and Hoare Logic in syntax and semantics, please refer to subsection 3.2.1 for syntax and semantic details. 3.2.4 Modal Logic Modal logic <ref> [97] </ref> [36]is the study of context-dependent properties such as necessity and possibility. In modal logic, the meaning of expressions depends on an implicit context, abstracted away from the object language.
Reference: [98] <author> Merlin, P. M. and Segall, A., </author> <title> "Recoverability of Communication Protocols-Implications of a Theoretical Study", </title> <journal> IEEE Transactions on Communications, </journal> <month> September </month> <year> 1976. </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets <ref> [98] </ref> and Timed Petri Nets [119]. Both have been used extensively [54] [17] [19] [89] [120].
Reference: [99] <author> Mili, A., Mili, R. and Mittermeir, R., </author> <title> "Storing and Retrieving Software Components: A Refinement-based System", </title> <booktitle> Proceedings of the 16th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] [106] [114] <ref> [99] </ref>. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [100] <author> Milner, R., </author> <title> "A Calculus of Communicating systems", </title> <publisher> LNCS 90, </publisher> <year> 1980. </year>
Reference-contexts: These systems are more complex for a number of reasons|they are necessarily concurrent, they may utilise a number of different physical or logical clocks, and they need communication mechanisms. Concur-rency is perhaps the smallest problem|the formal representation of concurrency is now a well studied area <ref> [100] </ref> [72]. Multiple clocks remains an area of controversy and there are a number of theoretical issues which affect the intuitive choice of temporal model for such systems. Communications mechanism are most commonly used in concurrent systems, they have been studied in some depth and can be formally represented [145].
Reference: [101] <author> Milner, R., </author> <title> "Some Directions in Concurrency Theory(panel statement)", </title> <booktitle> Proceedings of the international Conference on the fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: Petri nets are treated as a sample description. 3.5.1 Petri Nets Overview Petri Net theory [122] [116]is one of the first formalisms to deal with concurrency, nondeterminism and causal connections between events. According to <ref> [101] </ref> it was the first unified theory, with levels of abstraction, in which to describe and analyse all aspects of the computer in the context of its environment. Petri nets provide a graphic representation with formal semantics of system be-haviour.
Reference: [102] <author> Milner, R., </author> <title> Communication and Concurrency, </title> <publisher> Prentice Hall, </publisher> <address> Hertfordshire, </address> <year> 1989. </year>
Reference-contexts: States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. Other methods such as CSP [72], CCS <ref> [102] </ref>, Statecharts [68], Temporal Logic [95] and I/O automata [92] focus on specifying the behaviour of concurrent systems; states typically range over simple domains like integers or are left uninterpreted, and behaviour is defined in terms of sequences, trees, or partial orders of events. <p> CSP's various semantics models, axiomatic proof system, model-checking and theorem-proving verification methods make it suitable for certain reverse engineering approaches. Until now there is no application of CSP in reverse engineering area yet. 3.4.2 Calculus of Communicating Systems (CCS) Overview Calculus of Communicating Systems (CCS) was proposed in <ref> [102] </ref>. It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems. At present, several variations of CCS has been developed, which forms a CCS family. CCS family includes CCS, CCS+, CCS*, SCCS, TCCS and TPCCS [55].
Reference: [103] <author> Moller, F. and Tofts, C., </author> <title> "A Temporal Calculus of Communicating Systems", </title> <journal> CONCUR'90, </journal> <volume> LNCS 458, </volume> <year> 1990. </year>
Reference-contexts: This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] [126]. A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) <ref> [103] </ref>. A complete set of axioms is presented for discrete time domains, but the semantics can be given as either discrete or dense. * TCCS (Timed CCS) [138]. Discrete or dense time domains can be used. * TPCCS (Timed Probabilistic CCS) [67]. TPCCS adopts a discrete time domain.
Reference: [104] <author> Moszkowski, B., </author> <title> Executing Temporal Logic Programs, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge UK, </address> <year> 1986. </year>
Reference-contexts: The validity of these properties is achieved using the associated axiom system of the used logic. In some cases, a subset of the logic can be executed, for example the Tempura system <ref> [104] </ref>. The executable specification can then be used for simulation and rapid prototyping purposes. Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. <p> ITL was first proposed by Moszkowski [105]. ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura <ref> [104] </ref>, 29 is well developed. Hussein Zedan and Antonio Cau proposed a set of new refinement techniques of ITL [27], which makes ITL more suitable for system development and re-engineering.
Reference: [105] <author> Moszkowski, B., </author> <title> A Temporal Logic for Multilevel Reasoning about Hardware, </title> <publisher> IEEE Computer Society, </publisher> <month> February </month> <year> 1985. </year>
Reference-contexts: This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. ITL was first proposed by Moszkowski <ref> [105] </ref>. ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura [104], 29 is well developed.
Reference: [106] <author> Narat, V., </author> <title> "Using a Relational Database for Software Maintenance: A Case Study", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1993, </booktitle> <year> 1993. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] <ref> [106] </ref> [114] [99]. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [107] <author> Narayana, K. T. and Aaby, A. A., </author> <title> "Specification of Real-Time Systems in Real-Time Temporal Interval Logic", </title> <booktitle> Proceedings of Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Until now, there is no application of TPCTL in reverse engineering area. 3.2.8 Interval Temporal Logic (ITL) Overview Interval based real-time temporal logic have been developed in [28] <ref> [107] </ref>. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. ITL was first proposed by Moszkowski [105].
Reference: [108] <author> Nicollin, X., Richier, J. L., Sifakis, J. and Voiron, J., </author> <title> "ATP: an Algebra for Timed Processes", </title> <booktitle> Proceedings IFIP Working Group Conference on Programming Concepts and Methods, </booktitle> <year> 1990. </year>
Reference-contexts: However, the calculation of probabilities is not mentioned in TPCCS and TPCTL. 3.4.7 Varieties of Timed Process Algebras Untimed process algebras have been extended with timing constructs in several ways including: * ACP (Real-Time ACP) [13]. A dense time domain is used. * ATP (Algebra of Timed Processes) <ref> [108] </ref>. * CCSR (Calculus of Communication Shared Resources based on CCS [63] [62]. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] [126]. A dense time domain is used.
Reference: [109] <author> Nielsen, M., Wagner, K. and George, C., </author> <title> "The RAISE Language, Method and Tools", </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 1, </volume> <pages> pp. </pages> <month> 85-114 </month> <year> (1989). </year>
Reference-contexts: Still others such as RAISE <ref> [109] </ref> and LOTOS [78] wed two different methods, one for handling rich state spaces and one for handling complexity due to concurrency. Common to all these methods is the use of the mathematical concepts of abstraction and composition. The process of specification is the act of writing things down precisely.
Reference: [110] <author> Ostroff, J. S., </author> <title> "Temporal Logic for Real-Time Systems", </title> <booktitle> Advanced Software Development Series, </booktitle> <address> England, </address> <year> 1989. </year>
Reference-contexts: Temporal logic has a strong and flexible description power, especially in real time domain. All these make temporal logic a possible formalism with the potential for being the formal foundation of certain reverse & re- engineering approaches. 3.2.6 Real-Time Temporal Logic (RTTL) Overview RTTL (Real-Time Temporal Logic) <ref> [110] </ref> is a logic for the development of embedded control systems. Such control systems are examples of discrete event processes, and it is for this type of system that the method for RTTL has been designed. <p> A discrete time domain necessarily sacrifices information about precise time. Concise specification language RTTL <ref> [110] </ref> [111]uses a distinguished temporal domain, the ESM (Extended State Machines) state variables, and the set of ESM transitions to form temporal formula. These are then proven using an axiomatisation of the system's ESM trajectories.
Reference: [111] <author> Ostroff, J. S., </author> <title> "Deciding Properties of Timed Transition Models", </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 1, </volume> <pages> pp. </pages> <month> 170-183 (April </month> <year> 1990). </year>
Reference: [112] <author> Ostroff, J. S. and Wonham, W. M., </author> <title> "A Temporal Logic Approach to Real-Time Control", </title> <booktitle> Proceedings of the 24th IEEE Conference on Decision and Control, </booktitle> <address> Florida, </address> <month> December </month> <year> 1985. </year>
Reference-contexts: Various proof systems and decision procedures for finite state systems can be used to check the correctness of a program or system. In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal logics were reported in <ref> [112] </ref> [15]. Since then, real-time logics have been explored in great detail. There is not any application of temporal logic in reverse engineering yet.
Reference: [113] <author> Owicki, S. S. and Gries, D., </author> <title> "Verifying Properties of Parallel Programs: an Axiomatic Approach", </title> <journal> Communication of ACM , Vol. </journal> <month> 19 (May </month> <year> 1976). </year>
Reference-contexts: The first extension of Hoare style reasoning from sequential to qualitative (non real-time) concurrent reasoning is provided in <ref> [113] </ref>, but the proof system required the presence of all the code and hence was not compositional. To aid in the development of proof system, a denotational semantics for Occam is developed. The execution model is based on maximal parallelism and synchronous message passing.
Reference: [114] <author> Paul, S. and Prakash, A., </author> <title> "Querying Source Code Using an Algebraic Query Language", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1994, </booktitle> <year> 1994. </year>
Reference-contexts: There are two main topics in this research direction: * Use of data & knowledge bases to store and retrieve source code information. Relevant artificial intelligence technologies can be used to facilitate and optimise the process of reverse engineering [9] [26] [46] [106] <ref> [114] </ref> [99]. * Using graphs to represent source code information [38] [90] [84]. Reverse Specification Reserve specification is intended to extract a description of what the examined system does. The description is made in terms of application domains.
Reference: [115] <author> Peled, D., </author> <title> "Combining Partial Order Reductions with on-the fly Model-checking", </title> <journal> Journal of Formal Methods in Systems Design, </journal> <volume> Vol. </volume> <month> 1 (Aug </month> <year> 1996). </year>
Reference-contexts: In 1987 McMillan used Bryant's ordered binary decision diagrams (BDDs) [23] to represent state transition systems efficiently, thereby increasing the size of the systems that could be verified. Other promising approaches to alleviating state explosion include the exploitation of partial order information <ref> [115] </ref>, localisation reduction [86], and semantic minimisation [52] to eliminate unnecessary states from a system model. Theorem Proving Theorem proving is a technique where both the system and its desired properties are expressed as formulas in some mathematical logic.
Reference: [116] <author> Peterson, J. L., </author> <title> Petri Net Theory and the Modeling of Systems, </title> <publisher> Prentice-Hall, </publisher> <address> En-glewood Cliffs, NJ, </address> <year> 1981. </year>
Reference: [117] <author> Queille, J. and Sifakis, J., </author> <title> "Specification and Verification of concurrent Systems in C/ESAR", </title> <booktitle> Proc. of Fifth ISP, </booktitle> <year> 1981. </year>
Reference-contexts: Two general approaches to model checking are used in practice today. The first,temporal model checking, is a technique developed independently in the 1980s by Clarke and Emerson [40] and by Queille and Sifakis <ref> [117] </ref>. In this approach specifications are expressed in a temporal logic and systems are modelled as finite state transition systems. 5 An efficient search procedure is used to check whether a given finite state transition system is a model for the specification.
Reference: [118] <author> Rajlich, V., Damaskinos, N. and Khorshid, W., </author> <title> "VIFOR: A Tool for Software Maintenance", </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 20, </volume> <pages> pp. </pages> <month> 67-77 </month> <year> (1990). </year>
Reference: [119] <author> Ramchandani, C., </author> <title> "Analysis of asynchronous concurrent systems by Timed Petri Nets", </title> <type> Technical Report, </type> <month> February </month> <year> 1974. </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets <ref> [119] </ref>. Both have been used extensively [54] [17] [19] [89] [120]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [120] <author> Razouk, R. R. and Phelps, C. V., </author> <title> "Performance Analysis of Timed Petri Nets", </title> <booktitle> Proceedings of 4th International Workshop on Protocol Verification and Testing, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Two basic timed versions of Petri nets has been introduced: Time Petri Nets [98] and Timed Petri Nets [119]. Both have been used extensively [54] [17] [19] [89] <ref> [120] </ref>. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions), and (ii) the type of delay (fixed delays,intervals or stochastic delays).
Reference: [121] <author> Reed, G. M. and Roscoe, A. W., </author> <title> "Timed CSP: Theory and Practice", </title> <booktitle> REX Workshop| Real-Time : Theory and Practice, </booktitle> <year> 1992. </year>
Reference-contexts: Much work need be done before ACP becomes a formalism which is really suitable for reverse engineering applications. Not many applications have been found in traditional forward software engineering, and no cases are found in reverse engineering yet. 44 3.4.5 Timed CSP Overview Timed CSP <ref> [121] </ref> is an extension of Hoare's CSP, with a dense temporal model providing a global clock. A delay operator is included along with some extended parallel operators. There is an assumption of a minimum delay between any two dependent action occurrences, but no minimum delay on any two independent actions. <p> A dense time domain is used. * ATP (Algebra of Timed Processes) [108]. * CCSR (Calculus of Communication Shared Resources based on CCS [63] [62]. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) <ref> [121] </ref> [126]. A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) [103]. A complete set of axioms is presented for discrete time domains, but the semantics can be given as either discrete or dense. * TCCS (Timed CCS) [138].
Reference: [122] <author> Reisig, W., </author> <title> Petri Nets: an Introduction, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: In this subsection, we discuss mainly the family of Petri nets, which includes timed Petri nets, and Statechart. Petri nets are treated as a sample description. 3.5.1 Petri Nets Overview Petri Net theory <ref> [122] </ref> [116]is one of the first formalisms to deal with concurrency, nondeterminism and causal connections between events. According to [101] it was the first unified theory, with levels of abstraction, in which to describe and analyse all aspects of the computer in the context of its environment.
Reference: [123] <author> Rescher, N. and Urquhart, A., </author> <title> "Temporal Logic", Library of Exact Philosophy, </title> <year> 1971. </year>
Reference-contexts: axiomatic proof system, theorem-proving and model checking verification methods, model logic has the potential to be developed into a formalism suitable for certain reverse & re- engineering approaches. 3.2.5 Temporal Logic Temporal logic has its origins in philosophy, where it was used to analyse the structure or topology of time <ref> [123] </ref>. In recent years, it has found a good value in real-time application. In physics and mathematics, time has traditionally been represented as just another variable.
Reference: [124] <editor> Roscoe, A., "Model-checking CSP", In A. Roscoe Ed., </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. </booktitle> <address> Hoare(1994), </address> <year> 1994. </year>
Reference-contexts: Different notions of conformance have been explored, including language inclusion [69] [86], refinement orderings [45] <ref> [124] </ref>, and observational equivalence [45] [56]. Vardi and Wolper [137] showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast.
Reference: [125] <author> Rugaber, S., Ornburn, S. B. and LeBlanc, jr.R. J., </author> <title> "Recognizing Design decisions in Programs", </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: The study of human cognitive processes can show where we can support human understanding effectively. It may, but need not, be a model how automated understanding can work [133] <ref> [125] </ref>. Intermediate Representation of Source Code In large programs, it is more efficient to preprocess the source code and store the program information in an intermediate representation that allows fast queries instead of querying the source code directly [44].
Reference: [126] <author> Schneider, S., </author> <title> "Correctness and Communication in Real-Time Systems", </title> <type> PhD Thesis, </type> <year> 1990. </year>
Reference-contexts: A dense time domain is used. * ATP (Algebra of Timed Processes) [108]. * CCSR (Calculus of Communication Shared Resources based on CCS [63] [62]. This Algebra also provides a proof system for dealing with priority based access to scarce resources. * TCSP (Timed CSP) [121] <ref> [126] </ref>. A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) [103]. A complete set of axioms is presented for discrete time domains, but the semantics can be given as either discrete or dense. * TCCS (Timed CCS) [138].
Reference: [127] <author> Scholefield, D., </author> <title> "The Formal Development of Real-Time Systems: A Review", </title> <type> Technical Report (YCS 145), </type> <year> 1990. </year>
Reference-contexts: In real-time systems, this hypothesis is not supportable. Domain Criteria for Real-Time Systems Based on the distinct features of real-time systems mentioned in the last subsection, we can therefore propose the domain criteria with which we may compare and contrast formal methods for real-time system re-engineering <ref> [127] </ref>. * Temporal Model. Temporal model is the model of time used by the formal methods. A sparse model has discrete instances of time and there is a minimum granularity.
Reference: [128] <author> Scholefield, D., </author> <title> "A Refinement Calculus for Real-Time Systems", </title> <type> PhD thesis, </type> <year> 1992. </year>
Reference-contexts: Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [130] and the Refinement Calculus <ref> [128] </ref>. Hoare Logic, WP-Calculus and ITL are treated as sample descriptions. 20 3.2.1 Hoare Logic Overview Hoare Logic has a long history, it may be viewed as an extension of First-order Predicate Calculus [48] that includes inference rules for reasoning about programming language constructs.
Reference: [129] <author> Scholefield, D. and Zedan, H., "TAM: </author> <title> A Temporal Agent Model For Distributed Real-Time Systems", </title> <booktitle> EUROMICRO`90 Workshop, </booktitle> <publisher> North Holland, </publisher> <month> August </month> <year> 1990. </year>
Reference-contexts: Burns [24]discusses these functions and presents some ideas on formally representing and reasoning about them using an event logic first suggested in <ref> [129] </ref>. In many real-time systems the cost function is implicit (only influential in the formulation of requirements) but it remains an integral part of the system. Real-time systems are often distinguished between hard,firm and soft real-time systems.
Reference: [130] <author> Scholefield, D. and Zedan, H., "TAM: </author> <title> A Formal Framework for the Development of Distributed Real-Time Systems", Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, </title> <address> Nijmegen, Netherland, </address> <month> January </month> <year> 1992. </year> <month> 73 </month>
Reference-contexts: Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM <ref> [130] </ref> and the Refinement Calculus [128]. Hoare Logic, WP-Calculus and ITL are treated as sample descriptions. 20 3.2.1 Hoare Logic Overview Hoare Logic has a long history, it may be viewed as an extension of First-order Predicate Calculus [48] that includes inference rules for reasoning about programming language constructs.
Reference: [131] <author> Scholefield, D., Zedan, H. and He, J., </author> <title> "A Specification-oriented Semantics for the Refinement of Real-Time Systems", </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. </volume> <month> 130 (August </month> <year> 1994). </year>
Reference: [132] <author> Servello, M. A., </author> <title> "LOGISCOPE and the Software Maintenance Crisis", </title> <booktitle> Proceedings of the International Conference on Software Maintenance 1990, </booktitle> <year> 1990. </year>
Reference: [133] <author> Soloway, E. and Ehrlich, K., </author> <title> "Empirical Studies of Programming Knowledge", </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> Vol. SE-10, No. 5, </volume> <pages> pp. </pages> <month> 595-609 (September </month> <year> 1984). </year>
Reference-contexts: The study of human cognitive processes can show where we can support human understanding effectively. It may, but need not, be a model how automated understanding can work <ref> [133] </ref> [125]. Intermediate Representation of Source Code In large programs, it is more efficient to preprocess the source code and store the program information in an intermediate representation that allows fast queries instead of querying the source code directly [44].
Reference: [134] <author> Spivey, J. M., </author> <title> Introducing Z: A Specification Language and its Formal Semantics, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: One current trend is to integrate different specification languages, each able to handle a different aspect of a system. Another is to handle non-behavioural aspects of a system like its performance, real-time constraints, security policies, and architectural design. Some formal methods such as Z <ref> [134] </ref>, VDM [82] and Larch [66] focus on specifying the behaviour of sequential systems. States are described in term of rich mathematical structures like sets, relations and functions; state transitions are given in terms of pre- and post-conditions. <p> In this approach, there is no explicit representation of concurrency. Non-functional requirements (such as temporal requirement) could be expressed in some cases. Z is treated as a sample description. 3.1.1 Z Overview With the first version proposed in 1979 [2], the Z notion <ref> [134] </ref> is based on predicate calculus and Zermelo Fraenkel set theory. A Z specification is written in terms of `schemas', each of which contains a signature part which declares items of interest and a predicate part which places a logical constraint on them.
Reference: [135] <author> Tilborg, A. M. V. and Koob, G. M., </author> <title> Foundations of Real-Time Computing-Formal Specification and Methods, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> ISBN 0-7923-9167-5., </address> <year> 1991. </year>
Reference-contexts: Use of formal methods does not a priori guarantee correctness. However, they can greatly increase our understanding of a system by revealing inconsistencies, ambiguities, and incompletenesses that might otherwise go undetected <ref> [135] </ref>. The maintenance of large-scale computing systems is a crucial aspect of software lifecycle. This is due to the fact that systems are continually evolving.
Reference: [136] <author> Turner, K. J., </author> <title> "DILL-Digital Logic in LOTOS", Formal Description Techniques, FORTE VII, </title> <publisher> North Holland, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: ACT ONE for the data part and CCS/CSP-based language for the control part. LOTOS is able to capture a relatively complex temporal pattern of events, involving nondeterminism, concurrency and synchronisation, by means of small algebraic expression built by using few conceptually simple operators <ref> [136] </ref>. Realistic communication protocol can be described in LOTOS, whereas description in Estelle and SDL proved capable of expressing only a subset of the entities. Behavioural aspects of LOTOS are very relevant, even predominant. 43 LOTOS has a formally defined syntax, static semantics and dynamic semantics.
Reference: [137] <author> Vardi, M. Y. and Wolper, P., </author> <title> "An Automata-theoretic Approach to Automatic Program Verification", </title> <booktitle> Proc. of Logic in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: Different notions of conformance have been explored, including language inclusion [69] [86], refinement orderings [45] [124], and observational equivalence [45] [56]. Vardi and Wolper <ref> [137] </ref> showed how the temporal-logic model-checking problem could be recast in terms of automata, thus relating these two approaches. In contrast to theorem proving, model checking is completely automatic and fast.
Reference: [138] <author> Wang, Y., </author> <title> "CCS + Time = an interleaving model for real time systems", </title> <booktitle> Proceedings of the 18th International Coll. on Automata Languages and Programming(ICALP), Lecture Notes in Computer Science, </booktitle> <volume> Vol. 510, </volume> <pages> pp. </pages> <month> 217-228 </month> <year> (1991). </year>
Reference-contexts: A dense time domain is used. TCSP will be discussed in the next section. * TCCS (Temporal CCS) [103]. A complete set of axioms is presented for discrete time domains, but the semantics can be given as either discrete or dense. * TCCS (Timed CCS) <ref> [138] </ref>. Discrete or dense time domains can be used. * TPCCS (Timed Probabilistic CCS) [67]. TPCCS adopts a discrete time domain. It will be discussed later. * TPL (Temporal Process Language) [71]. A discrete time domain is used. * U-LOTOS (Urgent LOTOS) [21].
Reference: [139] <author> Wordsworth, J., </author> <title> Software Engineering with B, </title> <publisher> Addison Wesley Longman, </publisher> <address> ISBN 0 201-40356-0., </address> <year> 1996. </year>
Reference: [140] <author> Yang, H., </author> <title> "The Supporting Environment for A Reverse Engineering System | The Maintainer's Assistant", </title> <booktitle> IEEE Conference on Software Maintenance-1991, </booktitle> <address> Sorrento, Italy, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Since any automation has to be based on certain tools, re-engineering tools are crucial to any software re-engineering approach. At present, there are already some accomplished re-engineering tools, such as "Maintainer's Assistant" <ref> [140] </ref>, "VIFOR" [118,132], "Rigi" and "AUTOSPEC" [33] [61] [32] [60]. Among these tools, we concentrated on two typical ones: Yang's Maintainer's Assistant and Cheng's AUTOSPEC. Generally speaking, each tool and the approach it based on makes progress in certain aspects, while remaining vast areas untouched and invaluable improvements unconsidered.
Reference: [141] <author> Yang, H. and Bennett, K. H., </author> <title> "Aquairing Entity-Relationship Attribute Diagrams from Code and Data through Program Transformation", </title> <booktitle> IEEE International Conference on Software Maintenance (ICSM '95), </booktitle> <address> Nice, France, </address> <month> October, </month> <year> 1995. </year>
Reference: [142] <author> Yang, H. and Bennett, K. H., </author> <title> "Extension of A Transformation System for Maintenance | Dealing With Data-Intensive Programs", </title> <booktitle> IEEE International Conference on Software Maintenance (ICSM '94), </booktitle> <address> Victoria, Canada, </address> <month> September, </month> <year> 1994. </year>
Reference-contexts: Instead of focusing on the control structure of a program, such as call graphs, control flow graphs and paths, data centred program understanding focuses on data and data relationships [80] <ref> [142] </ref>. * Program Slicing. A program slice is a fragment of a program in which some statements are omitted that are not necessary to understand a certain property of the program [58] [18]. 2.2.3 Re-engineering Tools Automation is one of the most important features of software re-engineering.
Reference: [143] <author> Young, S. J., </author> <title> Real-Time Languages Design and Development, </title> <address> Ellis-Harwood, </address> <year> 1982. </year>
Reference-contexts: It has been argued that all computer systems are in some way real-time: we are always concerned that results are produced , or interactions occur, within a `reasonable' time span. Young <ref> [143] </ref> reinforced this rather general definition with the following assertion: A real-time system is any processing activity or system which has to respond to externally generated input stimuli within a finite and specified time.
Reference: [144] <author> Zedan, H., </author> <title> Research Issues in the Formal Development of Dependable Real-Time Systems, </title> <institution> SERC Centre, De Montfort University, </institution> <year> 1996. </year>
Reference-contexts: The cost function is certainly one way of representing criticality, and in some formal methods it is suggested that criticality may correspond to probability <ref> [144] </ref>. Some real-time systems are also distributed. These systems are more complex for a number of reasons|they are necessarily concurrent, they may utilise a number of different physical or logical clocks, and they need communication mechanisms.
Reference: [145] <author> Zedan, H. and Heping, H., </author> <title> "An Executable Specification Language for Fast Proto-typing Parallel Responsive Systems", </title> <booktitle> Computer Language, </booktitle> <volume> Vol. 22, </volume> <pages> pp. </pages> <month> 1-13 (01 </month> <year> 1996). </year> <month> 74 </month>
Reference-contexts: Multiple clocks remains an area of controversy and there are a number of theoretical issues which affect the intuitive choice of temporal model for such systems. Communications mechanism are most commonly used in concurrent systems, they have been studied in some depth and can be formally represented <ref> [145] </ref>. Because the temporal behaviour of a system is dependent upon the hardware utilised by the system, we need to be able to reason about resources and resource contention. In some formal languages, it is assumed that there are infinitely fast resources, this is termed maximal parallelism hypothesis.
References-found: 145

