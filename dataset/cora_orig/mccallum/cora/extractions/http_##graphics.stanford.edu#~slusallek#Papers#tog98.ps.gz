URL: http://graphics.stanford.edu/~slusallek/Papers/tog98.ps.gz
Refering-URL: http://graphics.stanford.edu/~slusallek/cv.html
Root-URL: http://www.cs.stanford.edu
Email: Email: fheidrich,slusallek,seidelg@informatik.uni-erlangen.de  
Title: Sampling Procedural Shaders Using Affine Arithmetic  
Author: Wolfgang Heidrich, Philipp Slusallek, Hans-Peter Seidel 
Address: Am Weichselgarten 9, D-91058 Erlangen, Germany  
Affiliation: University of Erlangen, Computer Graphics Group  
Abstract: Procedural shaders have become popular tools for describing surface reflectance functions and other material properties. In comparison to fixed resolution textures, they have the advantage of being resolution independent and storage efficient. While procedural shaders provide an interface for evaluating the shader at a single point, it is not easily possible to obtain an average value of the shader together with accurate error bounds over a finite area. Yet the ability to compute such error bounds is crucial for several interesting applications, most notably hierarchical area sampling for global illumination using the finite element approach, and for the generation of textures used in interactive computer graphics. Using affine arithmetic for evaluating the shader over a finite area yields a tight, conservative error interval for the shader function. Compilers can automatically generate code for utilizing affine arithmetic from within shaders implemented in a dedicated language, such as the RenderMan shading language.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alias/Wavefront. OpenAlias Manual, </author> <year> 1996. </year>
Reference-contexts: of noise symbols * i . ^x = x 0 + x 1 * 1 + x 2 * 2 + + x n * n The coefficients x i are known real values, while the values of the noise symbols are unknown, but limited to the interval U := <ref> [1; 1] </ref>. <p> In the following, we will restrict ourselves to the functionality of the RenderMan shading language [11, 23, 31], which is generally agreed to be one of the most flexible languages for procedural shaders. Since its features are a superset of most other shading languages (for example <ref> [1] </ref> and [17]), the described concepts apply to these other languages as well. Shading languages usually introduce a set of specific data types and functions exceeding the functionality of general purpose languages and libraries. <p> d ijk ; i; j; k 2 f0; 1g trilinear interpolation of the f ijk (f x; f y; f z), using wx; wy, and wz as weights. end In this algorithm, smoothstep (x) := 3x 2 2x 3 defines a smooth transition between 0 and 1 over the interval <ref> [0; 1] </ref>. An affine approximation for the noise function over a single lattice cell can be derived quite easily by replacing the real valued versions of smoothstep, the linear functions, and the trilinear interpolation by functions operating on affine forms. <p> More care has to be taken in cases where the ranges of the components only span up to two adjacent cells in either direction. In a hierarchical algorithm, this case will occur now matter how fine the parameter range has been subdivided. If in this case the full interval <ref> [0; 1] </ref> is returned, the shader bounds would not converge around points located on the boundaries of noise grid cells. Therefore, we restrict the range of the point to each of the covered cells, and evaluate noise over the restricted intervals.
Reference: 2. <author> Elliot W. </author> <title> Cheney. Introduction to Approximation Theory. </title> <booktitle> International series in pure and applied mathematics. </booktitle> <publisher> McGraw-Hill, </publisher> <year> 1966. </year>
Reference-contexts: Thus, approximating f fl has been reduced to finding a linear Chebyshev approximation for a univariate function, which is a well understood problem <ref> [2] </ref>. An example for such an approximation is outlined in the appendix. A compilation of affine approximations for common math library functions can be found in [12]. Most multivariate functions can handled by reducing them to a composition of univariate functions.
Reference: 3. <author> Michael F. Cohen and John R Wallace. </author> <title> Radiosity and Realistic Image Synthesis. </title> <publisher> Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction The ability to compute mean reflectance coefficients as well as error bounds for a shader over a finite area of a surface has several interesting applications. For example in radiosity computations <ref> [3] </ref> the mean reflectance of surface patches is required for setting up a linear equation system for the global illumination problem. Hierarchical radiosity [10] adaptively subdivides the patches in order to compute interactions between patches exchanging large quantities of radiosity or energy [16] with higher precision.
Reference: 4. <author> Jo~ao L. D. Comba and Jorge Stolfi. </author> <title> Affine arithmetic and its applications to computer graphics. </title> <booktitle> In Anais do VII Sibgrapi, </booktitle> <pages> pages 9-18, </pages> <year> 1993. </year> <note> Available from http://www.dcc.unicamp.br/stolfi/EXPORT/papers/affine-arith. </note>
Reference-contexts: Using this method, it is possible to apply procedural shaders to the application domains mentioned above. We first give a brief overview of affine arithmetic in general before we describe the details of applying it to procedural shaders. 2 Affine Arithmetic Affine arithmetic (AA), first introduced in <ref> [4] </ref>, is an extension of interval arithmetic [18]. It has been successfully applied to several problems for which interval arithmetic had been used before [19, 28, 29]. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures [6, 7]. <p> It is also possible to keep track of truncation and round-off errors. In contrast to interval arithmetic, AA also maintains dependencies between the sources of error, and thus manages to compute significantly tighter error bounds. Detailed comparisons between interval arithmetic and affine arithmetic can be found in <ref> [4] </ref>, [6], and [7]. <p> the error introduced by the approximation of f fl with f a : z k maxfjf fl (* 1 ; : : : ; * n ) f a (* 1 ; : : : ; * n )j : * i 2 Ug: For example it turns out (see <ref> [4] </ref> for details) that a good approximation for the multiplication of two affine forms ^x and ^y is ^z = x 0 y 0 + (x 0 y 1 + y 0 x 1 )* 1 + + (x 0 y n + y 0 x n )* n + uv* <p> Affine arithmetic keeps track of most of these subtle dependencies, while interval arithmetic ignores them completely. The more complicated functions get, the more dependencies between the sources of error exist, and the bigger the advantage of AA. These results are consistent with prior studies published in <ref> [4] </ref>, [6], and [7]. The bounds of both affine and interval arithmetic can be further improved by finding optimal approximations for larger blocks of code, instead of just library functions. This process, however, requires human intervention and cannot be done automatically.
Reference: 5. <author> David Ebert, Kent Musgrave, Darwyn Peachey, Ken Perlin, and Worley. </author> <title> Texturing and Modeling: A Procedural Approach. </title> <publisher> Academic Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: This function is typically called noise <ref> [5] </ref>. Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice [15], over gradient noise [21, 22], which enforces a pseudo-random gradient at the lattice points, to hybrid methods [32] and sparse convolution noise [15]. <p> In particular the base frequency of the noise influences the size of the features and irregularities on the shader. For proper shader-driven anti-aliasing, this base frequency has to be known to the shader <ref> [5] </ref>. Because most published RenderMan shaders implicitly assume gradient noise as introduced by [22], we decided to use this version of the noise function, too. <p> The eight linear functions corresponding to the vertices next to the sample point are combined using smoothed trilinear interpolation <ref> [5] </ref>: gradientNoise ( x, y, z ) begin ix := floor (x); iy := floor (y); iz := floor (z); f x := x ix; f y := y iy; f z := z iz; wx := smoothstep (f x); wy := smoothstep (f y); wz := smoothstep (f z); look
Reference: 6. <author> Luiz Henrique Figueiredo. </author> <title> Surface intersection using affine arithmetic. </title> <booktitle> In Graphics Interface '96, </booktitle> <pages> pages 168-175, </pages> <year> 1996. </year>
Reference-contexts: It has been successfully applied to several problems for which interval arithmetic had been used before [19, 28, 29]. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures <ref> [6, 7] </ref>. Like interval arithmetic, AA can be used to manipulate imprecise values, and to evaluate functions over intervals. It is also possible to keep track of truncation and round-off errors. <p> It is also possible to keep track of truncation and round-off errors. In contrast to interval arithmetic, AA also maintains dependencies between the sources of error, and thus manages to compute significantly tighter error bounds. Detailed comparisons between interval arithmetic and affine arithmetic can be found in [4], <ref> [6] </ref>, and [7]. <p> Affine arithmetic keeps track of most of these subtle dependencies, while interval arithmetic ignores them completely. The more complicated functions get, the more dependencies between the sources of error exist, and the bigger the advantage of AA. These results are consistent with prior studies published in [4], <ref> [6] </ref>, and [7]. The bounds of both affine and interval arithmetic can be further improved by finding optimal approximations for larger blocks of code, instead of just library functions. This process, however, requires human intervention and cannot be done automatically.
Reference: 7. <author> Luiz Henrique Figueiredo and Jorge Stolfi. </author> <title> Adaptive enumeration of implicit surfaces with affine arithmetic. </title> <journal> Computer Graphics Forum, </journal> <volume> 15(5) </volume> <pages> 287-296, </pages> <year> 1996. </year>
Reference-contexts: It has been successfully applied to several problems for which interval arithmetic had been used before [19, 28, 29]. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures <ref> [6, 7] </ref>. Like interval arithmetic, AA can be used to manipulate imprecise values, and to evaluate functions over intervals. It is also possible to keep track of truncation and round-off errors. <p> In contrast to interval arithmetic, AA also maintains dependencies between the sources of error, and thus manages to compute significantly tighter error bounds. Detailed comparisons between interval arithmetic and affine arithmetic can be found in [4], [6], and <ref> [7] </ref>. <p> Affine arithmetic keeps track of most of these subtle dependencies, while interval arithmetic ignores them completely. The more complicated functions get, the more dependencies between the sources of error exist, and the bigger the advantage of AA. These results are consistent with prior studies published in [4], [6], and <ref> [7] </ref>. The bounds of both affine and interval arithmetic can be further improved by finding optimal approximations for larger blocks of code, instead of just library functions. This process, however, requires human intervention and cannot be done automatically.
Reference: 8. <author> Ned Greene and Michael Kass. </author> <title> Error-bounded antialiased rendering of complex environments. </title> <booktitle> In Computer Graphics (SIGGRAPH '94 Proceedings), </booktitle> <pages> pages 59-66, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: For applications, where truly conservative bounds are required, these methods cannot be used at all. In the past, Greene and Kass <ref> [8] </ref> have used interval arithmetic for anti-aliasing shaders. These shaders are programmed in a visual data-flow language [14], which is then compiled to C++. In this paper we describe a general method for computing tight, conservative error bounds for procedural RenderMan shaders using affine arithmetic.
Reference: 9. <author> Brian Guenter, Todd B. Knoblock, and Erik Ruf. Specializing shaders. </author> <booktitle> In Computer Graphics (SIGGRAPH '95 Proceedings), </booktitle> <pages> pages 343-350, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: This requires the compiler to perform some sort of dependency analysis as discussed, for example, in <ref> [9] </ref>. 4 Results In this paper we use affine arithmetic to obtain conservative bounds for shader values over a parameter range. In principle, we could also use any other range analysis method for this purpose. It is, however, important that the method generates tight, conservative bounds for the shader.
Reference: 10. <author> P. Hanrahan and D. Salzman. </author> <title> A rapid hierarchical radiosity algorithm for un-occluded environments. </title> <booktitle> In Eurographics Workshop on Photosimulation, Realism and Physics in Computer Graphics, </booktitle> <year> 1989. </year>
Reference-contexts: For example in radiosity computations [3] the mean reflectance of surface patches is required for setting up a linear equation system for the global illumination problem. Hierarchical radiosity <ref> [10] </ref> adaptively subdivides the patches in order to compute interactions between patches exchanging large quantities of radiosity or energy [16] with higher precision. The known subdivision criteria assume a constant reflection coefficient for each patch.
Reference: 11. <author> Pat Hanrahan and Jim Lawson. </author> <title> A language for shading and lighting calculations. </title> <booktitle> In Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <pages> pages 289-298, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: In the following, we will restrict ourselves to the functionality of the RenderMan shading language <ref> [11, 23, 31] </ref>, which is generally agreed to be one of the most flexible languages for procedural shaders. Since its features are a superset of most other shading languages (for example [1] and [17]), the described concepts apply to these other languages as well.
Reference: 12. <author> Wolfgang Heidrich. </author> <title> A compilation of affine approximations for math library functions. </title> <type> Technical report, </type> <institution> University of Erlangen Computer Graphics Group, </institution> <year> 1997. </year> <note> In preparation. </note>
Reference-contexts: Thus, approximating f fl has been reduced to finding a linear Chebyshev approximation for a univariate function, which is a well understood problem [2]. An example for such an approximation is outlined in the appendix. A compilation of affine approximations for common math library functions can be found in <ref> [12] </ref>. Most multivariate functions can handled by reducing them to a composition of univariate functions. For example, the maximum of two numbers can be rewritten as max (x; y) = max 0 (x y) + y, with max 0 (z) := max (z; 0).
Reference: 13. <author> Malvin H. Kalos and Paula A. Whitlock. </author> <title> Monte Carlo Methods. </title> <publisher> John Wiley & Sons, </publisher> <year> 1986. </year>
Reference-contexts: However, this method only yields an estimate of the true error bounds, and since Monte Carlo methods only converge with O ( p N ) <ref> [13] </ref>, this process can be very expensive. For applications, where truly conservative bounds are required, these methods cannot be used at all. In the past, Greene and Kass [8] have used interval arithmetic for anti-aliasing shaders.
Reference: 14. <author> Michael Kass. </author> <title> CONDOR: Constraint-based dataflow. </title> <booktitle> In Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <pages> pages 321-330, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: For applications, where truly conservative bounds are required, these methods cannot be used at all. In the past, Greene and Kass [8] have used interval arithmetic for anti-aliasing shaders. These shaders are programmed in a visual data-flow language <ref> [14] </ref>, which is then compiled to C++. In this paper we describe a general method for computing tight, conservative error bounds for procedural RenderMan shaders using affine arithmetic. Using this method, it is possible to apply procedural shaders to the application domains mentioned above.
Reference: 15. <author> John-Peter Lewis. </author> <title> Algorithms for solid noise synthesis. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <pages> pages 263-270, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This function is typically called noise [5]. Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice <ref> [15] </ref>, over gradient noise [21, 22], which enforces a pseudo-random gradient at the lattice points, to hybrid methods [32] and sparse convolution noise [15]. The choice of a specific noise function has a significant impact on the characteristics of the shader. <p> Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice <ref> [15] </ref>, over gradient noise [21, 22], which enforces a pseudo-random gradient at the lattice points, to hybrid methods [32] and sparse convolution noise [15]. The choice of a specific noise function has a significant impact on the characteristics of the shader. In particular the base frequency of the noise influences the size of the features and irregularities on the shader.
Reference: 16. <author> Dani Lischinski, Brian Smits, and Donald P. Greenberg. </author> <title> Bounds and error estimates for radiosity. </title> <booktitle> In Computer Graphics (SIGGRAPH '94 Proceedings), </booktitle> <pages> pages 67-74, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: For example in radiosity computations [3] the mean reflectance of surface patches is required for setting up a linear equation system for the global illumination problem. Hierarchical radiosity [10] adaptively subdivides the patches in order to compute interactions between patches exchanging large quantities of radiosity or energy <ref> [16] </ref> with higher precision. The known subdivision criteria assume a constant reflection coefficient for each patch.
Reference: 17. <author> Steven Molnar, John Eyles, and John Poulton. PixelFlow: </author> <title> High-speed rendering using image composition. </title> <booktitle> In Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <pages> pages 231-240, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In the following, we will restrict ourselves to the functionality of the RenderMan shading language [11, 23, 31], which is generally agreed to be one of the most flexible languages for procedural shaders. Since its features are a superset of most other shading languages (for example [1] and <ref> [17] </ref>), the described concepts apply to these other languages as well. Shading languages usually introduce a set of specific data types and functions exceeding the functionality of general purpose languages and libraries.
Reference: 18. <author> Ramon E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1966. </year>
Reference-contexts: We first give a brief overview of affine arithmetic in general before we describe the details of applying it to procedural shaders. 2 Affine Arithmetic Affine arithmetic (AA), first introduced in [4], is an extension of interval arithmetic <ref> [18] </ref>. It has been successfully applied to several problems for which interval arithmetic had been used before [19, 28, 29]. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures [6, 7].
Reference: 19. <author> F. Kenton Musgrave, Craig E. Kolb, and Robert S. Mace. </author> <title> The synthesis and rendering of eroded fractal terrains. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <pages> pages 41-50, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: It has been successfully applied to several problems for which interval arithmetic had been used before <ref> [19, 28, 29] </ref>. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures [6, 7]. Like interval arithmetic, AA can be used to manipulate imprecise values, and to evaluate functions over intervals.
Reference: 20. <author> Alan Norton, Alyn P. Rockwood, and Philip T. Skolmoski. Clamping: </author> <title> a method of antialiasing textured surfaces by bandwidth limiting in object space. </title> <booktitle> In Computer Graphics (SIGGRAPH '82 Proceedings), </booktitle> <pages> pages 1-8, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Moreover, a few grid cells are usually enough for the noise function to use its full dynamic range. On the other hand, many of the more involved shaders avoid this problem altogether by removing frequencies above the sampling rate using clamping <ref> [20] </ref>. Also, in algorithms that hierarchically subdivide the parameter range, the ranges of all components will eventually span no more than two adjacent grid cells. More care has to be taken in cases where the ranges of the components only span up to two adjacent cells in either direction.
Reference: 21. <author> Ken Perlin. </author> <title> An image synthesizer. </title> <booktitle> In Computer Graphics (SIGGRAPH '85 Proceedings), </booktitle> <pages> pages 287-296, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: This function is typically called noise [5]. Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice [15], over gradient noise <ref> [21, 22] </ref>, which enforces a pseudo-random gradient at the lattice points, to hybrid methods [32] and sparse convolution noise [15]. The choice of a specific noise function has a significant impact on the characteristics of the shader.
Reference: 22. <author> Ken Perlin and Eric M. Hoffert. Hypertexture. </author> <booktitle> In Computer Graphics (SIG-GRAPH '89 Proceedings), </booktitle> <pages> pages 253-262, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This function is typically called noise [5]. Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice [15], over gradient noise <ref> [21, 22] </ref>, which enforces a pseudo-random gradient at the lattice points, to hybrid methods [32] and sparse convolution noise [15]. The choice of a specific noise function has a significant impact on the characteristics of the shader. <p> In particular the base frequency of the noise influences the size of the features and irregularities on the shader. For proper shader-driven anti-aliasing, this base frequency has to be known to the shader [5]. Because most published RenderMan shaders implicitly assume gradient noise as introduced by <ref> [22] </ref>, we decided to use this version of the noise function, too. To evaluate gradient noise at a sample point in 3-dimensional space, first pseudo-random gradient vectors and scalar values are generated in each vertex of an integer lattice.
Reference: 23. <author> Pixar. </author> <title> The RenderMan Interface. </title> <address> Pixar, San Rafael, CA, </address> <month> Sep </month> <year> 1989. </year>
Reference-contexts: In the following, we will restrict ourselves to the functionality of the RenderMan shading language <ref> [11, 23, 31] </ref>, which is generally agreed to be one of the most flexible languages for procedural shaders. Since its features are a superset of most other shading languages (for example [1] and [17]), the described concepts apply to these other languages as well.
Reference: 24. <author> Louis B. Rall. </author> <title> Automatic Differentiation, Techniques and Applications. </title> <booktitle> Number 120 in Lecture notes in computer science. </booktitle> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: Thus, the resulting range for the derivative is [jz k j=du; jz k j=du], which does not, in general, converge to a single scalar value. Another possible algorithm for implementing derivatives is automatic differentiation <ref> [24] </ref>. In contrast to the other two methods, automatic differentiation computes conservative bounds for the derivatives in the mathematical sense. Instead of maintaining ^x u and ^x v , automatic differentiation directly stores the partial derivatives @ ^x=@u and @ ^x=@v of every expression.
Reference: 25. <author> Philipp Slusallek, Thomas Pflaum, and Hans-Peter Seidel. </author> <title> Implementing Ren-derMan practice, problems, and enhancements. </title> <booktitle> In Computer Graphics Forum (EUROGRAPHICS '94 Proceedings), </booktitle> <pages> pages 443-454, </pages> <month> Sep </month> <year> 1994. </year>
Reference-contexts: The RenderMan shading language is particularly flexible with this respect, since it does not in any way limit the kind of expressions that can be derived, nor the location in the shader code, where a derivative can be computed. This can often cause severe problems in implementations <ref> [25] </ref>.
Reference: 26. <author> Philipp Slusallek, Thomas Pflaum, and Hans-Peter Seidel. </author> <title> Using procedural Ren-derMan shaders for global illumination. </title> <booktitle> In Computer Graphics Forum (EURO-GRAPHICS '95 Proceedings), </booktitle> <pages> pages C-311-C-324, </pages> <month> Aug </month> <year> 1995. </year>
Reference: 27. <author> Philipp Slusallek and Hans-Peter Seidel. </author> <title> Vision: An architecture for global illumination calculations. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 1(1) </volume> <pages> 77-96, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: These textures can then be applied, for example with the OpenGL renderer we used to generate the images in this paper. We are currently working on integrating the subdivision scheme into the Vision rendering system <ref> [27] </ref> for supporting finite element based global illumination. The level of subdivision shown in Figure 8 is sufficient for this purpose, but clearly the tolerance has to be decreased for textures directly used in OpenGL renderers. Fig. 8.
Reference: 28. <author> John M. Snyder. </author> <title> Generative Modeling for Computer Graphics and CAD: Symbolic Shape Design Using Interval Analysis. </title> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: It has been successfully applied to several problems for which interval arithmetic had been used before <ref> [19, 28, 29] </ref>. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures [6, 7]. Like interval arithmetic, AA can be used to manipulate imprecise values, and to evaluate functions over intervals.
Reference: 29. <author> John M. Snyder. </author> <title> Interval analysis for computer graphics. </title> <booktitle> In Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <pages> pages 121-130, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: It has been successfully applied to several problems for which interval arithmetic had been used before <ref> [19, 28, 29] </ref>. This includes reliable intersection tests of rays with implicit surfaces, and recursive enumerations of implicit surfaces in quad-tree like structures [6, 7]. Like interval arithmetic, AA can be used to manipulate imprecise values, and to evaluate functions over intervals.
Reference: 30. <author> Marc Stamminger, Philipp Slusallek, and Hans-Peter Seidel. </author> <title> Bounded radiosity - illumination on general surfaces and clusters. </title> <booktitle> In Computer Graphics Forum (Proc. EUROGRAPHICS '97), </booktitle> <year> 1997. </year> <note> Accepted for publication. </note>
Reference-contexts: Fig. 8. The hierarchically subdivided wood shader for a maximum resolution of 256 fi 256. Cells with an error of over 5 percent were subdivided at each level. This resulted in a total number of 19512 samples instead of 65536 for the full resolution (29.8 percent). In <ref> [30] </ref>, an algorithm for bounding form factor and lighting computations is described. This yields conservative bounds for both the geometric and the lighting computations in a radiosity system, but ignores potential variations of surface materials.
Reference: 31. <author> Steve Upstill. </author> <title> The RenderMan Companion. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In the following, we will restrict ourselves to the functionality of the RenderMan shading language <ref> [11, 23, 31] </ref>, which is generally agreed to be one of the most flexible languages for procedural shaders. Since its features are a superset of most other shading languages (for example [1] and [17]), the described concepts apply to these other languages as well. <p> After this replacement, boolean expressions in inequalities can be written as arithmetic expressions. For example, x 1 &lt; y 1 and x 2 &lt; y 2 becomes step (y 1 x 1 )step (y 2 x 2 ). The following example is an excerpt of the "screen" shader <ref> [31] </ref> using an if-statement to compute the opacity value. if ( mod (s, 1.0)&lt; density jj mod (t, 1.0)&lt; density ) Opacity:= 1.0; else Opacity:= 0.0; endif Using the transformations for boolean expressions as described above, the if-statement is translated into the following piece of code. <p> This can lead to some problems when computing derivatives, as will be described in Section 3.3. In shaders without derivatives, we found that this method produces very tight error bounds, as can be seen in Figure 2, where the "wood" shader <ref> [31] </ref> is applied to a sphere. Fig. 2. The wood shader uses the noise function to generate irregularities in the rings. The example again shows that errors only occur in areas of high gradients in the shader function and on the transition from lit to unlit areas. <p> Such a function is given as P m noise (P f m )=f m for some scaling factor f . This function is called fractal noise, or turbulence. One of the shaders using turbulence is the "blue marble" shader <ref> [31] </ref>, which is shown at the top of Figure 3. Fig. 3. Top: the blue marble shader. Bottom: cross sections of the shader sampled at the original sampling rate (left) and twice this sampling rate (right) over the interval u 2 [0; 0:25] with v = 0:3. <p> The method of divided differences works fairly well for relatively simple expressions, but the errors become larger as the complexity of the expressions grows. The quality of the bounds degrades in particular when noise is used at high frequencies like, for example, with the "eroded" shader <ref> [31] </ref>. This is shown in Figure 5. Fig. 5. A sphere with the "eroded" shader applied. It can be seen from the error plot in Figure 5 that large errors occur at the boundaries of noise lattice cells.
Reference: 32. <author> Greg Ward. </author> <title> A recursive implementation of the Perlin noise function. </title> <editor> In James Arvo, editor, </editor> <booktitle> Graphics Gems II, </booktitle> <pages> pages 396-401. </pages> <publisher> AP Professional, </publisher> <year> 1991. </year>
Reference-contexts: Many algorithms for noise functions have been proposed, starting with value noise, which interpolates pseudo-random data values at the grid points of an integer lattice [15], over gradient noise [21, 22], which enforces a pseudo-random gradient at the lattice points, to hybrid methods <ref> [32] </ref> and sparse convolution noise [15]. The choice of a specific noise function has a significant impact on the characteristics of the shader. In particular the base frequency of the noise influences the size of the features and irregularities on the shader.
References-found: 32

