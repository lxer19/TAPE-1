URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3880/3880.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: E-mail: eiter@informatik.uni-giessen.de, eiter@dbai.tuwien.ac.at  E-mail: vs@cs.umd.edu  E-mail: george@cs.umd.edu  
Title: Heterogeneous Active Agents  
Author: Thomas Eiter V.S. Subrahmanian George Pick 
Address: Gieen, Arndtstrae 2, 35392 Gieen, Germany,  Vienna, Austria.  College Park, Maryland 20742.  College Park, Maryland 20742.  
Affiliation: Institut fur Informatik, Universitat  and TU  Institute for Advanced Computer Studies, Institute for Systems Research and Department of Computer Science, Uni versity of Maryland,  Department of Computer Science, University of Maryland,  
Abstract: Over the years, many different agent programming languages have been proposed. In this paper, we propose a concept called Agent Programs using which, the way an agent should act in various situations can be declaratively specified by the creator of that agent. Agent Programs may be built on top of arbitrary pieces of software code and may be used to specify what an agent is obliged to do, what an agent may do, and what an agent may not do. In this paper, we define several successively more sophisticated and epistemically satisfying declarative semantics for agent programs, and study the computation price to be paid (in terms of complexity) for such epistemic desiderata. We further show that agent programs cleanly extend well understood semantics for logic programs, and thus are clearly linked to existing results on logic programming and nonmonotonic reasoning. Last, but not least, we have built a simulation of a Supply Chain application in terms of our theory, building on top of commercial software systems such as Microsoft Access and ESRI's MapObject. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adali, K.S.Candan, Y. Papakonstantinou, </author> <title> and V.S. Subrahmanian. Query Processing in Distributed Mediated Systems. </title> <booktitle> In: Proc. 1996 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Before proceeding to this definition, we need to introduce some syntactic assumptions. The content of Section 3.1 is not new work. It builds upon a previous effort called HERMES by one of the authors on heterogeneous data and software integration <ref> [1, 19, 74, 73, 76] </ref>. The reader familiar with that syntax may skip this section. Suppose we consider a body S = (T S ; F S ) of software code. <p> Then, AS is said to be F -concurrently executable in state O S , if and only if the following holds: 1. For every permutation , AS is -executable. 2. For any two permutations 1 ; 2 of AS, the final states resulting from the executions AS <ref> [ 1 ] </ref> and AS [ 2 ] are identical. <p> Query optimization methods applicable to both TSIMMIS and HERMES were studied in <ref> [1] </ref>. The SIMS system [4] at USC uses a LISP-like syntax to integrate multiple databases as well. It is closely related to the HERMES effort. HERMES used minimalistic versions of logic to integrate data and software, while SIMS used a somewhat richer language. <p> It is closely related to the HERMES effort. HERMES used minimalistic versions of logic to integrate data and software, while SIMS used a somewhat richer language. As a 99 consequence, HERMES was able to take advantage of very efficient caching and query optimization methods <ref> [73, 1] </ref>, but may have not been able to easily express some of the more sophisticated reasoning tasks desired by the authors of SIMS.
Reference: [2] <author> K. Apt. </author> <title> Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 10. </booktitle> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: For every permutation , AS is -executable. 2. For any two permutations 1 ; 2 of AS, the final states resulting from the executions AS [ 1 ] and AS <ref> [ 2 ] </ref> are identical. <p> Observe that this property does not hold for non-positive agent programs in general. It is possible to give a characterization of the unique rational status set in terms of a fixpoint operator, akin to the least fixpoint of logic programs <ref> [70, 2] </ref>. For that, we define for every positive program P and agent state O S an operator T P;O S which maps a status set S to another status set. Definition 5.7 (T P;O S Operator) Suppose P is an agent program and O S an agent state. <p> (S i ) for any chain S 0 S 1 S 2 of status sets, the least fixpoint is given by lfp (T P;O S ) = i=0 P;O S ; where T 0 P;O S = ; and T i+1 P;O S ), for all i 0 (see e.g. <ref> [70, 2] </ref>). We then have the following result. Theorem 5.3 Let P be a positive agent program, and let O S be an agent state. <p> Then, S is feasible by definition of rational status set. By Lemma 5.2, S is a pre-fixpoint of T P;O S . Since T P;O S is monotone, it has by the Knaster-Tarski Theorem a least pre-fixpoint, which coincides with lfp (T P;O S ) (cf. <ref> [2, 70] </ref>). Thus, lfp (T P;O S ) S. Clearly, lfp (T P;O S ) satisfies (S1) and (S3); moreover, lfp (T P;O S ) satisfies (S2), as S satisfies (S2) and this property is hereditary.
Reference: [3] <author> L. Aquist. </author> <title> Deontic Logic. </title> <editor> In D. Gabbay and F. Guenthner, editors, </editor> <booktitle> Handbook of Philosophical Logic, Vol.II, chapter II.11, </booktitle> <pages> pages 605-714. </pages> <address> D. </address> <publisher> Reidel Publishing Company, </publisher> <year> 1984. </year>
Reference-contexts: Notice that the operators P; F; O; and W have been extensively studied in the area of deontic logic <ref> [79, 3] </ref>. Moreover, the operator Do is in the spirit of the praxiological operator E a A [62], which informally means that agent a sees to it that A is the case [79, p.292]. <p> We borrow from the field of deontic logic the syntax of deontic statements; however we do not lay down the semantics of action programs on the basis of one of the numerous deontic logical systems 20 (e.g., Standard Deontic Logic (SDL), which amounts to the modal logic KD <ref> [3, 79] </ref>). We discuss the relationship between our approach and deontic logic in detail in Section 11. <p> This is known as regimentation [65], and reflects the ideal behavior of an agent in a normative system. However, the essence of deontism is in capturing what should be done in a specific situation, rather than what finally is to be done under any circumstances <ref> [3, 79, 54] </ref>. <p> To date, no active database system has provided a formal semantics for obligatory, permitted, and forbidden actions. In this paper, we have done so, building on top of classical deontic logic syntax <ref> [3, 79] </ref>. We have added to deontic logic as well in several ways: first, we have introduced the Do operator which standard deontic logic does not contain.
Reference: [4] <author> Y. Arens, C.Y. Chee, C.-N. Hsu and C. Knoblock. </author> <title> Retrieving and Integrating Data From Multiple Information Sources. </title> <journal> International Journal of Intelligent Cooperative Information Systems, </journal> <volume> 2(2) </volume> <pages> 127-158, </pages> <year> 1993. </year>
Reference-contexts: have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources <ref> [4, 67, 68, 100, 108] </ref>. In the long run, a platform to support the creation and deployment of multiple software agents will need to interoperate with a wide variety of custom-made, as well as legacy software sources. <p> Query optimization methods applicable to both TSIMMIS and HERMES were studied in [1]. The SIMS system <ref> [4] </ref> at USC uses a LISP-like syntax to integrate multiple databases as well. It is closely related to the HERMES effort. HERMES used minimalistic versions of logic to integrate data and software, while SIMS used a somewhat richer language.
Reference: [5] <author> K. Arisha, S. Kraus, F. Ozcan, R. Ross and V.S.Subrahmanian. </author> <title> IMPACT: The Interactive Maryland Platform for Agents Collaborating Together. </title> <note> Submitted for publication, </note> <month> Nov. </month> <year> 1997. </year> <month> 101 </month>
Reference-contexts: A semantic wrapper that contains a wealth of semantic information. Such information in cludes, but is not restricted to the following: (a) A service description expressed in some tightly specified language. While a multiplicity of languages may be used for this purpose, in IMPACT <ref> [5] </ref> we have developed an HTML-like language for creating and manipulating service descriptions. This language has been characterized with a formal declarative semantics, as well as sound and complete algorithms for matching requests for services with an archive of service descriptions. <p> A synchronization layer guarantees that different IMPACT servers will reflect the same state, propagating changes at one server to other mirrored sites. Due to space concerns, the reader interested in details of the IMPACT architecture is referred to <ref> [5] </ref>. <p> These sources can be used by agent A to structure its code call message 10 to agent B. We will not go into the description of the service description component of IMPACT here that is done in a companion paper <ref> [5] </ref>. 3.2 Integrity Constraints In addition to code-calls, each agent also has an associated set of Integrity Constraints. Agent integrity constraints specify properties that states of the agent must satisfy. <p> Kuokka and Harada [66] present the SHADE and COINS systems for matchmaking. Decker, Sycara, and Williamson [30] present matchmakers that store capability advertisements of different agents. Arisha et al. <ref> [5] </ref> present a theoretical foundation for matchmaking as well. This paper, in contrast, merely focuses on how an agent makes decisions, rather than determining how one agent matches up with another. Relationship to Heterogeneous Data Integration in the Database Community.
Reference: [6] <author> M. Baldoni, L. Giordano, A. Martelli and V. Patti. </author> <title> An Abductive Proof Procedure for Reasoning about Actions in Modal Logic Programming . In: </title> <booktitle> Proc. Workshop on Non Monotonic Extensions of Logic Programming at ICLP '96, Lecture Notes in AI 1216, </booktitle> <pages> pp. 132-150, </pages> <publisher> Springer, </publisher> <year> 1998. </year>
Reference-contexts: In this section, we briefly address these, one by one. Gelfond and Lifschitz [42] propose a logic programming language called A using which, users may express knowledge about actions and their effects. This framework was later extended by Baral, Gelfond and others in a series of elegant papers <ref> [9, 10, 6, 7] </ref>. <p> approach, we use the semantics to determine which set of firable actions (in a state) must actually be fired, and this policy of choosing such sets of actions in accordance with the policies expressed in an agent program and the underlying integrity constraints is different from what is done in <ref> [42, 9, 10, 6, 7] </ref>. Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., [26, 60, 64, 87, 107]).
Reference: [7] <author> M. Baldoni, L. Giordano, A. Martelli and V. Patti. </author> <title> A Modal Programming Language for Representing Complex Actions. </title> <type> Manuscript, </type> <year> 1998. </year>
Reference-contexts: In this section, we briefly address these, one by one. Gelfond and Lifschitz [42] propose a logic programming language called A using which, users may express knowledge about actions and their effects. This framework was later extended by Baral, Gelfond and others in a series of elegant papers <ref> [9, 10, 6, 7] </ref>. <p> approach, we use the semantics to determine which set of firable actions (in a state) must actually be fired, and this policy of choosing such sets of actions in accordance with the policies expressed in an agent program and the underlying integrity constraints is different from what is done in <ref> [42, 9, 10, 6, 7] </ref>. Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., [26, 60, 64, 87, 107]).
Reference: [8] <author> C. Baral and M. Gelfond. </author> <title> Representing Concurrent Actions in Extended Logic Programming. </title> <booktitle> In: Proc. 13th Intl. Joint Conf. on Artificial Intelligence, </booktitle> <pages> pp. 866-871, </pages> <year> 1993. </year>
Reference-contexts: Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin [68] develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions. Several works <ref> [42, 8, 9, 10] </ref> have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one.
Reference: [9] <author> C. Baral and M. Gelfond. </author> <title> Logic programming and knowledge representation. </title> <journal> Journal of Logic Programming, </journal> 19/20:73-148, 1994. 
Reference-contexts: Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin [68] develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions. Several works <ref> [42, 8, 9, 10] </ref> have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one. <p> In this section, we briefly address these, one by one. Gelfond and Lifschitz [42] propose a logic programming language called A using which, users may express knowledge about actions and their effects. This framework was later extended by Baral, Gelfond and others in a series of elegant papers <ref> [9, 10, 6, 7] </ref>. <p> approach, we use the semantics to determine which set of firable actions (in a state) must actually be fired, and this policy of choosing such sets of actions in accordance with the policies expressed in an agent program and the underlying integrity constraints is different from what is done in <ref> [42, 9, 10, 6, 7] </ref>. Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., [26, 60, 64, 87, 107]).
Reference: [10] <author> C. Baral, M. Gelfond and A. Provetti. </author> <title> Representing Actions I: Laws, Observations, and Hypothesis. </title> <booktitle> In: Proc. AAAI '95 Spring Symposium on Extending Theories of Action, </booktitle> <year> 1995. </year>
Reference-contexts: Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin [68] develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions. Several works <ref> [42, 8, 9, 10] </ref> have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one. <p> In this section, we briefly address these, one by one. Gelfond and Lifschitz [42] propose a logic programming language called A using which, users may express knowledge about actions and their effects. This framework was later extended by Baral, Gelfond and others in a series of elegant papers <ref> [9, 10, 6, 7] </ref>. <p> approach, we use the semantics to determine which set of firable actions (in a state) must actually be fired, and this policy of choosing such sets of actions in accordance with the policies expressed in an agent program and the underlying integrity constraints is different from what is done in <ref> [42, 9, 10, 6, 7] </ref>. Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., [26, 60, 64, 87, 107]).
Reference: [11] <author> C. Baral and J. Lobo. </author> <title> Formal Characterization of Active Databases. </title> <booktitle> In: Proc. Workshop of Logic on Databases (LID '96), </booktitle> <editor> D. Pedreschi and C. Zaniolo (eds), </editor> <address> San Miniato, Italy, </address> <publisher> LNCS 1154, </publisher> <year> 1996. </year>
Reference-contexts: In most work in AI [82, 44, 90] and logical approaches to action <ref> [11] </ref>, it is assumed that states are sets of ground logical atoms. In the fertile area of active databases, it is assumed that states reflect the content of a relational database.
Reference: [12] <author> R. Bayardo, et. al. </author> <title> Infosleuth: Agent-based Semantic Integration of Information in Open and Dynamic Environments. </title> <booktitle> In: Proc. ACM SIGMOD Conf. on Management of Data, </booktitle> <year> 1997. </year>
Reference-contexts: Other important later directions on mediation include the InfoSleuth effort <ref> [12] </ref> system, at MCC. 12 Conclusions and Future Work In this paper, we have argued the following two simple points: (I) Agents in the real world manipulate not just logical formulas, but complex data types, that vary from one application to another. (II) Agents must be able to act in accordance
Reference: [13] <author> C. Bell, A. Nerode, R. Ng and V.S. Subrahmanian. </author> <title> Mixed Integer Programming Methods for Computing Non-Monotonic Deductive Databases. </title> <journal> Journal of the ACM, </journal> <volume> 41(6) </volume> <pages> 1178-1215, </pages> <year> 1994. </year>
Reference-contexts: semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic [80] (see [41, 78]), as well as numerical reasoning paradigms such as linear programming and integer programming <ref> [13, 14] </ref>. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction.
Reference: [14] <author> C. Bell, A. Nerode, R. Ng and V.S. Subrahmanian. </author> <title> Implementing Deductive Databases by Mixed Integer Programming. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 21(2) </volume> <pages> 238-269, </pages> <year> 1996. </year>
Reference-contexts: semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic [80] (see [41, 78]), as well as numerical reasoning paradigms such as linear programming and integer programming <ref> [13, 14] </ref>. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction.
Reference: [15] <author> R. Ben-Eliyahu and R. Dechter. </author> <title> Propositional Semantics for Disjunctive Logic Programs. </title> <journal> Annals of Mathematics and AI, </journal> <volume> 12 </volume> <pages> 53-87, </pages> <year> 1994. </year>
Reference-contexts: Subrahmanian [77] and Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic programs and appropriate types of expansions of auto-epistemic theories. * Lobo and Subrahmanian [72] prove 1-1 correspondences between minimal models of logic programs, and extensions of prerequisite-free normal default logic theories. * Ben-Eliyahu and Dechter <ref> [15] </ref> have proved that stable models and minimal models of logic programs may be viewed as models of a suitable logical theory.
Reference: [16] <author> W. P. Birmingham, E. H. Durfee, T. Mullen and M. P. Wellman. </author> <title> The Distributed Agent Architecture Of The University of Michigan Digital Library (UMDL). </title> <booktitle> In: Proc. AAAI Spring Symposium Series on Software Agent, </booktitle> <year> 1995. </year>
Reference-contexts: Agent Architectures. For an excellent anthology of classic works on agent systems, see [57]. There have been numerous proposals for agentization in the literature (e.g., <ref> [38, 46, 16] </ref>) which have been broadly classified by Genesereth and Ketchpel [43] into four categories: in the first category, each agent has an associated transducer that converts all incoming messages and requests into a form that is intelligible to the agent.
Reference: [17] <editor> D.J. Bowersox, D.J. Closs and O.K. Helferich. </editor> <title> Logistical Management: A Systems Integration of Physical Distribution, Manufacturing Support, </title> <editor> and Materials Procurement. 3rd ed., </editor> <publisher> Macmillan, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: The second may be used by a tax agency to take relevant actions on which tax returns should be audited, how these audits will be conducted, etc. As we go through the paper, we will revisit these examples many times. 2.1 Supply Chain Example Supply chain management <ref> [17] </ref> is one of the most important activities in any major production company. Most production companies like to keep their production lines busy and on schedule.
Reference: [18] <author> M. Bratman, D. Israel and M. Pollack. </author> <title> Plans and Resource-Bounded Practical Reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 4(4) </volume> <pages> 349-355, </pages> <year> 1988. </year>
Reference-contexts: Rosenschein and Kaelbling [89] extend this framework to provide a basis for such actions in terms of situated automata theory. Bratman et al. <ref> [18] </ref> define the IRMA system which uses similar ideas to generate plans. In their framework, different possible courses of actions (Plans) are generated, based on the agent's intentions. These plans are then evaluated to determine which ones are consistent and optimal with respect to achieving these intentions.
Reference: [19] <author> A. Brink, S. Marcus, </author> <title> and V.S. Subrahmanian. Heterogeneous Multimedia Reasoning. </title> <journal> IEEE Computer, </journal> <volume> 28(9) </volume> <pages> 33-39, </pages> <year> 1995. </year>
Reference-contexts: Before proceeding to this definition, we need to introduce some syntactic assumptions. The content of Section 3.1 is not new work. It builds upon a previous effort called HERMES by one of the authors on heterogeneous data and software integration <ref> [1, 19, 74, 73, 76] </ref>. The reader familiar with that syntax may skip this section. Suppose we consider a body S = (T S ; F S ) of software code. <p> However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in <ref> [19, 74, 74, 100, 76] </ref>. The Stanford TSIMMIS project [22] effort aimed at integrating a wide variety of heterogeneous databases, together with a free text indexing system. <p> The paper [35] will report upon several experiments evaluating the ease of computing the several diverse semantics described in this paper. This implementation builds upon our existing HERMES Heterogeneous Reasoning and Mediator System, reported on in <ref> [19, 76, 100] </ref>. * We are studying the problem of whether all agent programs (under different semantics) can be embedded into logic programs.
Reference: [20] <author> M. Cadoli, </author> <title> The Complexity of Model Checking for Circumscriptive Formulae. </title> <journal> Information Processing Letters, </journal> <volume> 44 </volume> <pages> 113-118, </pages> <year> 1992. </year>
Reference-contexts: This problem corresponds to the task of model checking in the area of knowledge representation and reasoning, which has been addressed e.g. in <ref> [53, 20, 69] </ref>. We note here that for feasible status sets, the recognition problem is tractable under the assumptions that we made; this can be easily seen.
Reference: [21] <editor> R.G.G. Cattell et al. (eds.) </editor> <title> The Object Database Standard: </title> <publisher> ODMG-97. Morgan Kaufmann, </publisher> <year> 1997. </year>
Reference-contexts: In other words, in the strict sense of object systems, S is definable as a collection (or hierarchy) of object classes in any standard object data management language such as ODL <ref> [21] </ref>. Almost all existing servers used in real systems, as well as most commercial packages available on the market are instances of the above definition. For example, consider the well known Oracle DBMS. <p> This characterization of a piece of software code is a well accepted and widely used specification for example, the Object Data Management Group's ODMG standard <ref> [21] </ref> and the CORBA framework existing industry standards that are consistent with this specification. 3.1 Code Calls and Code Call Atoms In this section, we introduce the reader to the important concept of a code call atom this concept forms the basic syntactic object using which we may access multiple heterogeneous
Reference: [22] <author> S. Chawathe, H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. Ullman, and J. Widom. </author> <title> The TSIMMIS Project: Integration of Heterogeneous Information Sources., </title> <booktitle> In: Proc. IPSJ Conference, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1994. </year> <note> (Also available via anonymous FTP from host db.stanford.edu, file /pub/chawathe/1994/tsimmis-overview.ps.) </note>
Reference-contexts: However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76]. The Stanford TSIMMIS project <ref> [22] </ref> effort aimed at integrating a wide variety of heterogeneous databases, together with a free text indexing system.
Reference: [23] <author> Z.-Z. Chen and S. </author> <title> Toda. The Complexity of Selecting Maximal Solutions. </title> <booktitle> In: Proc. 8th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pp. 313-325, </pages> <year> 1993. </year>
Reference-contexts: Proof of these results are not difficult, using the well-known result that inference from a datalog program (Horn logic program) is P-complete, cf. [28]. The entries for the computation problem are the classes FC from the literature considered e.g. in <ref> [83, 23, 24] </ref> (i.e., compute any arbitrary solution to a problem instance; see subsection 6.3 for more details). Unless stated otherwise, they stand for completeness under an appropriate notion of polynomial time reduction as used in [83, 23]. <p> Unless stated otherwise, they stand for completeness under an appropriate notion of polynomial time reduction as used in <ref> [83, 23] </ref>. <p> We finally remark that we have omitted here an analysis of the complexity of optimal status sets as proposed in Section 5.7, in order to avoid an abundance of complexity results. Based on the results presented above, coarse bounds are staightforward. The sources <ref> [23, 24, 59] </ref> and references therein provide suitable complexity classes for a more accurate assessment. 7 Complexity Results and Algorithms for Agent Programs: Basic Re sults This section contains the first part of the derivation of the complexity results which have been presented in Section 6. <p> Hence, it follows that computing a weak rational status set is in FNP//log. It remains to show hardness for this class. For this purpose, we reduce the computation of an X - maximal model <ref> [23, 24] </ref> to this problem. <p> Hardness of this problem for FNP//log is shown in <ref> [23, 24] </ref>. 2 The reduction is as follows. Without loss of generality, we assume that is an M3SAT instance. <p> This proves the result. 2 In fact, the authors use in [24] a slightly stronger form of reduction among maximization problems than in <ref> [23] </ref>, which requires that the transformed instance must always have solutions; our proofs of FNP//log hardness can be easily adapted to this stronger reduction. 65 Like in the case of positive programs, recognition of a weak rational status set S is no harder than computation, even if programs are nonpositive.
Reference: [24] <author> Z.-Z. Chen and S. </author> <title> Toda. The Complexity of Selecting Maximal Solutions. </title> <journal> Information and Computation, </journal> <volume> 119 </volume> <pages> 231-239, </pages> <year> 1995. </year>
Reference-contexts: Proof of these results are not difficult, using the well-known result that inference from a datalog program (Horn logic program) is P-complete, cf. [28]. The entries for the computation problem are the classes FC from the literature considered e.g. in <ref> [83, 23, 24] </ref> (i.e., compute any arbitrary solution to a problem instance; see subsection 6.3 for more details). Unless stated otherwise, they stand for completeness under an appropriate notion of polynomial time reduction as used in [83, 23]. <p> For the decisional classes, the arcs in Figure 4 actually denote inclusions, i.e., the transformation of problems in C 1 to problems in C 2 is by means of the identity. The classes for search problems, which are often also called function classes, can be found in <ref> [83, 24] </ref>. A search problem is a generalization of a decision problem, in which for every instance 50 . . . <p> Thus, the oracle calls are nonadaptive and must essentially take place in parallel; it is commonly believed that this restricts computational power. FNP//log is short for the class FNP//OptP [O (log n)] <ref> [24] </ref>, which is intuitively the class of problems for which a solution can be nondeterministically found in polynomial time for an instance I , if the optimal value opt (I ) of an NP optimization problem on I is known, where opt (I) must have O (log jIj) bits. <p> The computation of s amounts to an NP optimization problem, and thus the overall algorithm places the problem in FNP//log. The class RP FP P k <ref> [24] </ref> contains, intuitively speaking, those problems for which a solution on input I can be found by a random polynomial time algorithm with very high probability, by using a problem in FP P k as single call subroutine. This class is above FP P k . <p> We finally remark that we have omitted here an analysis of the complexity of optimal status sets as proposed in Section 5.7, in order to avoid an abundance of complexity results. Based on the results presented above, coarse bounds are staightforward. The sources <ref> [23, 24, 59] </ref> and references therein provide suitable complexity classes for a more accurate assessment. 7 Complexity Results and Algorithms for Agent Programs: Basic Re sults This section contains the first part of the derivation of the complexity results which have been presented in Section 6. <p> FP NP k -hardness of this problem, even if all clauses in have at most three literals, follows easily from the results in <ref> [24] </ref> (Lemma 4.7). The reduction is an extension of the one in the proof of Theorem 7.11 (note the observations on rational status sets of the program P there, and that a rational status set always exists). <p> In fact, it can be shown that computing a rational status set is polynomial time equivalent to computing a minimal model of a CNF formula, which is not known to be complete for FNP//log, cf. <ref> [24] </ref>. Action reasoning becomes harder in the brave variant if we use rational status sets instead of feasible status sets. The reason is that we have to check groundedness of a status set, which is a source of complexity and adds another level in the polynomial hierarchy. <p> We can improve on this upper bound and give an exact characterization of the problem in terms of the complexity class FNP//log, which comprises computation problems with an adjunct NP optimization problem (see Section 6.3 and <ref> [24] </ref>). In our case, this NP optimization problem consists in the computation of the numbers s and s 0 , respectively. <p> Hence, it follows that computing a weak rational status set is in FNP//log. It remains to show hardness for this class. For this purpose, we reduce the computation of an X - maximal model <ref> [23, 24] </ref> to this problem. <p> Hardness of this problem for FNP//log is shown in <ref> [23, 24] </ref>. 2 The reduction is as follows. Without loss of generality, we assume that is an M3SAT instance. <p> The proof of hardness for computing a weak reasonable status set is similar (use an additional clause Do (set 1 (X )) :Do (set 0 (X )); VAR (X ) ). This proves the result. 2 In fact, the authors use in <ref> [24] </ref> a slightly stronger form of reduction among maximization problems than in [23], which requires that the transformed instance must always have solutions; our proofs of FNP//log hardness can be easily adapted to this stronger reduction. 65 Like in the case of positive programs, recognition of a weak rational status set <p> Membership in FP P 2 was discussed above. Membership in RP FP P k can be established using results from <ref> [24] </ref>. In fact, the computation of a weak rational status set in the most general setting can be easily expressed as a maximization problem (MAXP) as defined in [24], such that the instance-solution relation is co-NP-decidable; for such problems, RP FP P k is an upper bound. <p> Membership in FP P 2 was discussed above. Membership in RP FP P k can be established using results from <ref> [24] </ref>. In fact, the computation of a weak rational status set in the most general setting can be easily expressed as a maximization problem (MAXP) as defined in [24], such that the instance-solution relation is co-NP-decidable; for such problems, RP FP P k is an upper bound. Hardness for F P 2 is immediate from the proof of Theorem 8.4 (existence of a rational status set), since O does not occur in the program constructed. <p> This proves membership in FP P 2 . Membership in RP FP 2 k follows from the fact that computing a F -preferred rational status set can be easily expressed as a maximization problem (MAXP) as defined in <ref> [24] </ref>, whose instance-solution relation is co-NP decidable; as mentioned previously, RP FP P k is an upper bound for such problems.
Reference: [25] <author> P. Cohen and H. Levesque. </author> <title> Intention is Choice with Commitment. </title> <journal> Artificial Intelligence, </journal> <volume> 42 </volume> <pages> 263-310, </pages> <year> 1990. </year>
Reference-contexts: ConGolog [45] is a logic programming language for concurrent execution of actions. ConGolog creates static plans from a set of goals and primitive actions. ConGolog is built on the framework of Cohen and Levesque <ref> [25] </ref> who develop a logic of rational agents based intentionality using speech acts as a starting point. Their work has subsequently been used for a variety of other multiagent frameworks we do not go into these extensions here, as they are not directly related to our effort.
Reference: [26] <author> S.E. Conry, K. Kuwabara, V.R. Lesser and R.A. Meyer. </author> <title> Multistage Negotiation for Distributed Satis--faction, </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, Special Issue on Distributed Artificial Intelligence, </journal> <volume> 21(6) </volume> <pages> 1462-1477, </pages> <year> 1991. </year>
Reference-contexts: Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., <ref> [26, 60, 64, 87, 107] </ref>). As our approach allows 98 arbitrary decisions, and as negotiation is one form of decision making, our work provides a frame-work within which various negotiation strategies described in the literature can be encoded.
Reference: [27] <author> S. Coradeschi and L. Karlsson. </author> <title> A Behavior-based Decision Mechanism for Agents Coordinating using Roles. </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 100-105, </pages> <year> 1997. </year>
Reference-contexts: Sycara and Zeng [101] provide a coordinated search methodology for multiple agents. Haddadi [52] develops a declarative theory of interactions, as do Rao and Georgeff [84], and Coradeschi and Karlson <ref> [27] </ref> who build agents for air traffic simulation. There has been extensive work on negotiation in multiagent systems, based on the initial idea of contract nets, due to Smith and Davis [99].
Reference: [28] <author> E. Dantsin, T. Eiter, G. Gottlob, and A. Voronkov. </author> <title> Complexity and Expressive Power of Logic Programming. </title> <booktitle> In: Proc. Twelfth IEEE International Conference on Computational Complexity (CCC '97), </booktitle> <pages> pp 82-101, </pages> <year> 1997. </year>
Reference-contexts: Proof of these results are not difficult, using the well-known result that inference from a datalog program (Horn logic program) is P-complete, cf. <ref> [28] </ref>. The entries for the computation problem are the classes FC from the literature considered e.g. in [83, 23, 24] (i.e., compute any arbitrary solution to a problem instance; see subsection 6.3 for more details).
Reference: [29] <author> U. Dayal and H. Hwang. </author> <title> View Definition and Generalization for Database Integration in a Multi-Database System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(6):628-644, </volume> <year> 1984. </year>
Reference-contexts: There is now a great deal of work in mediated systems techniques. In this paragraph, we merely explain the relationship between code call conditions and existing work on data and software integration. For example, there have been several efforts to integrate multiple relational DBMSs <ref> [29, 81] </ref> and relational DBMSs, object-oriented DBMSs and/or file systems [39, 63, 95]. However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76].
Reference: [30] <author> K. Decker, K. Sycara and M. Williamson. </author> <title> Middle Agents for the Internet. </title> <booktitle> In: Proc. IJCAI 97, Nagoya, Japan, </booktitle> <pages> pp 578-583, </pages> <year> 1997. </year>
Reference-contexts: Matchmaking. First, there has been substantial work on matchmaking, in which agents advertise their services, and matchmakers match an agent requesting a service with one (or more) that provides it. Kuokka and Harada [66] present the SHADE and COINS systems for matchmaking. Decker, Sycara, and Williamson <ref> [30] </ref> present matchmakers that store capability advertisements of different agents. Arisha et al. [5] present a theoretical foundation for matchmaking as well. This paper, in contrast, merely focuses on how an agent makes decisions, rather than determining how one agent matches up with another.
Reference: [31] <author> F. Dignum and R. Conte. </author> <title> Intentional Agents and Goal Formation, </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 219-231, </pages> <year> 1997. </year>
Reference-contexts: Of this plethora of research, the work reported in this paper is perhaps closest to that of the group in CWI, Amsterdam, working on deontic logics for agent based programming <ref> [55, 31, 56] </ref> Below, we review the work on agents in a variety of arenas. Agent Programming. Shoham [97] was perhaps the first to propose an explicit programming language for agents, based on object oriented concepts, and based on the concept of an agent state. <p> Precisely how various other deontic assumptions can be captured within our semantics remains to be worked out. The approach of Hindriks et al. [55] is based on such logics and has already been discussed earlier. Dignum and Conte <ref> [31] </ref> have used deontic logic extensively to develop methods for goal formation in our framework, goal formation is one of several actions that an agent can take. Thus, we can specifically gain from the work of Dignum and Conte [31], through explicitly plugging-in such a framework as an action called form-goals <p> Dignum and Conte <ref> [31] </ref> have used deontic logic extensively to develop methods for goal formation in our framework, goal formation is one of several actions that an agent can take. Thus, we can specifically gain from the work of Dignum and Conte [31], through explicitly plugging-in such a framework as an action called form-goals implemented through the elegant work they report. Agent Decision Making. There has been a significant amount of work on agent decision making.
Reference: [32] <author> T. Eiter and G. Gottlob. </author> <title> The Complexity of Logic-Based Abduction. </title> <journal> Journal of the ACM, </journal> <volume> 42(1) </volume> <pages> 3-42, </pages> <year> 1995. </year>
Reference: [33] <author> T. Eiter, G. Gottlob, and N. Leone. </author> <title> On the Indiscernibility of Individuals in Logic Programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 7(6) </volume> <pages> 805-824, </pages> <year> 1997. </year>
Reference: [34] <author> T. Eiter, G. Gottlob, and H. Mannila. </author> <title> Disjunctive Datalog. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 22(3) </volume> <pages> 315-363, </pages> <year> 1997. </year>
Reference: [35] <author> T. Eiter, V.S. Subrahmanian, and M. Tikir. </author> <title> Regular Agent Programs and their Implementation, </title> <note> in preparation. </note>
Reference-contexts: More efficient and sophisticated algorithms that we have developed and we are currently implementing in IMPACT will be reported on in a companion paper currently in preparation <ref> [35] </ref>. Section 9 shows the relationship between our semantics and well known semantics in logic programming. <p> P 0 . This means that S is not a rational status set of P 0 , which is the desired contradiction. Thus, (1) and (2) hold, which proves the result. In a follow-up paper <ref> [35] </ref>, we are developing implementation techniques for agent programs that implement a syntactically restricted class of agent programs called regular agent programs that are guaranteed to have at least one reasonable status set. <p> As a consequence, our approach complements the work of [97, 55] where they focus on logical representations of agent state, describing beliefs, capabilities, commitments, and goals. In addition, [97] describes temporal action scheduling which our language does not currently support, though ongoing work will extend it to do so <ref> [35] </ref>. If these modes of reasoning can be expressed as data structures, then the notion of agent proposed in our paper can benefit from the contributions in [97, 55]. <p> All of these modes of reasoning are well recognized in the AI community, and expanding our semantical framework to accommodate these modes of reasoning is an important semantical issue. 100 * We are currently developing a compiler for agent programs in particular, in a future paper <ref> [35] </ref>, we will report upon a class of agent programs called regular agent programs that are guaranteed to possess reasonable status sets regularity of agent programs is a syntactically easily verifiable property, and regular agent programs possess many nice computational properties. The paper [35] will report upon several experiments evaluating the <p> programs in particular, in a future paper <ref> [35] </ref>, we will report upon a class of agent programs called regular agent programs that are guaranteed to possess reasonable status sets regularity of agent programs is a syntactically easily verifiable property, and regular agent programs possess many nice computational properties. The paper [35] will report upon several experiments evaluating the ease of computing the several diverse semantics described in this paper.
Reference: [36] <author> O. Etzioni and D. Weld. </author> <title> A Softbot-Based Interface to the Internet, </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 72-76, </pages> <year> 1994. </year>
Reference-contexts: Applications of such agent technology have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents <ref> [36] </ref>, to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources [4, 67, 68, 100, 108].
Reference: [37] <author> M. Garey and D. S. Johnson. </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: We assume that the reader is familiar with the basic concepts of complexity theory, in particular with NP-completeness and the polynomial hierarchy, and refer to <ref> [37, 61, 83] </ref> for background material on this subject and for concepts and notation that we use in the remainder of this paper. Our aim is a sharp characterization of the complexity of different computational tasks which arise in the context of agent programs. <p> Telling whether a quantified Boolean formula (QBF) 8X 9Y:, where = W m formula of clauses C j = L j;1 _ L j;2 _ L j;3 whose literals L j;k are over propositional variables (atoms) X [ Y , is not true is a well-known P 2 -complete problem <ref> [37] </ref>. This remains true even if each clause C j is either positive or negative (i.e., is a M3SAT instance). <p> Proof. The problem is in NP, since a feasible status set S can be guessed and checked in polynomial time, according to our assumptions (cf. Proposition 7.7). We show the hardness part for the particular restriction by a reduction from the set splitting problem <ref> [37] </ref>. <p> Then, deciding whether S contains some rational status set (resp., S is rational) is co-NP-hard, even if IC contains a single FD. Proof. We prove this by a reduction from the M3DNF problem, which is a restriction of the DNF TAUTOLOGY problem (cf. <ref> [37] </ref>): Given a propositional formula = W m i=1 D i in DNF, where the D i 's are conjunctions of literals on a set of propositional variables X = fx 1 ; : : : ; x n g, decide 74 whether is a tautology.
Reference: [38] <author> L. Gasser and T. Ishida. </author> <title> A Dynamic Organizational Architecture For Adaptive Problem Solving. </title> <booktitle> In: Proc. AAAI '91, </booktitle> <pages> pp 185-190, </pages> <year> 1991. </year>
Reference-contexts: Agent Architectures. For an excellent anthology of classic works on agent systems, see [57]. There have been numerous proposals for agentization in the literature (e.g., <ref> [38, 46, 16] </ref>) which have been broadly classified by Genesereth and Ketchpel [43] into four categories: in the first category, each agent has an associated transducer that converts all incoming messages and requests into a form that is intelligible to the agent.
Reference: [39] <author> N. Gehani, H. Jagadish, and W. Roome. OdeFS: </author> <title> A File System Interface to an Object-Oriented Database. </title> <booktitle> In: Proc. Int'l Conf. on Very Large Databases (VLDB), </booktitle> <pages> pp 249-260, </pages> <year> 1994. </year>
Reference-contexts: In this paragraph, we merely explain the relationship between code call conditions and existing work on data and software integration. For example, there have been several efforts to integrate multiple relational DBMSs [29, 81] and relational DBMSs, object-oriented DBMSs and/or file systems <ref> [39, 63, 95] </ref>. However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76].
Reference: [40] <author> M. Gelfond and V. Lifschitz. </author> <title> The Stable Model Semantics for Logic Programming. </title> <booktitle> In: Logic Programming: Proceedings Fifth Intl Conference and Symposium, </booktitle> <pages> pages 1070-1080, </pages> <address> Cambridge, Mass., 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: These observations led to the well known stable model semantics for logic programs due to Gelfond and Lifschitz <ref> [40] </ref> which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic [80] (see [41, 78]), as well as numerical reasoning paradigms such as linear programming and integer programming [13, 14].
Reference: [41] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical Negation in Logic Programs and Disjunctive Databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: These observations led to the well known stable model semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic [80] (see <ref> [41, 78] </ref>), as well as numerical reasoning paradigms such as linear programming and integer programming [13, 14]. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction.
Reference: [42] <author> M. Gelfond and V. Lifschitz. </author> <title> Representing Actions and Change by Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 17(2-4):301-323, </volume> <year> 1993. </year>
Reference-contexts: Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin [68] develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions. Several works <ref> [42, 8, 9, 10] </ref> have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one. <p> Reasoning About Actions. Several works [42, 8, 9, 10] have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one. Gelfond and Lifschitz <ref> [42] </ref> propose a logic programming language called A using which, users may express knowledge about actions and their effects. This framework was later extended by Baral, Gelfond and others in a series of elegant papers [9, 10, 6, 7]. <p> approach, we use the semantics to determine which set of firable actions (in a state) must actually be fired, and this policy of choosing such sets of actions in accordance with the policies expressed in an agent program and the underlying integrity constraints is different from what is done in <ref> [42, 9, 10, 6, 7] </ref>. Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., [26, 60, 64, 87, 107]).
Reference: [43] <author> M.R. Genesereth and S.P. Ketchpel. </author> <title> Software Agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7), </volume> <year> 1994. </year>
Reference-contexts: Agent Architectures. For an excellent anthology of classic works on agent systems, see [57]. There have been numerous proposals for agentization in the literature (e.g., [38, 46, 16]) which have been broadly classified by Genesereth and Ketchpel <ref> [43] </ref> into four categories: in the first category, each agent has an associated transducer that converts all incoming messages and requests into a form that is intelligible to the agent. This is clearly not what happens in IMPACT as noted in [43], the transducer has to anticipate what other agents will <p> which have been broadly classified by Genesereth and Ketchpel <ref> [43] </ref> into four categories: in the first category, each agent has an associated transducer that converts all incoming messages and requests into a form that is intelligible to the agent. This is clearly not what happens in IMPACT as noted in [43], the transducer has to anticipate what other agents will send us and translate that something which is clearly difficult to do. The second approach is based on wrappers which inject code into a program to allow it to communicate [43, p.51]. <p> The second approach is based on wrappers which inject code into a program to allow it to communicate <ref> [43, p.51] </ref>. The IMPACT architecture provides a language (the service description language) for expressing such wrappers, together with accompanying algorithms. The third approach described in [43] is to completely rewrite the code implementing an agent which is obviously a very expensive alternative. <p> The second approach is based on wrappers which inject code into a program to allow it to communicate [43, p.51]. The IMPACT architecture provides a language (the service description language) for expressing such wrappers, together with accompanying algorithms. The third approach described in <ref> [43] </ref> is to completely rewrite the code implementing an agent which is obviously a very expensive alternative. Last but not least, there is the mediation approach proposed by Wiederhold [108], which assumes that all agents will communicate with a mediator which in turn may send messages to other agents.
Reference: [44] <author> M.R. Genesereth and N.J. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufman Pub., </publisher> <year> 1987. </year>
Reference-contexts: In most work in AI <ref> [82, 44, 90] </ref> and logical approaches to action [11], it is assumed that states are sets of ground logical atoms. In the fertile area of active databases, it is assumed that states reflect the content of a relational database.
Reference: [45] <author> G. De Giacomo, Y. Lesperance and H.J. Levesque. </author> <title> Reasoning about Concurrent Execution, Prioritized Interrupts, </title> <booktitle> and Exogenous Actions in the Situation Calculus. In: Proc. IJCAI 97, </booktitle> <address> Nagoya, Japan, </address> <year> 1997. </year>
Reference-contexts: Such choices are expressed 2 by an agent program developed in a logical agent programming language that we introduce in this paper. We are not the first to propose agent programming paradigms several others, notably <ref> [97, 55, 45] </ref>, have done so before us. Our work builds upon these previous, pioneering efforts, in the following ways: 1. <p> Likewise, practical reasoning rules for us are implemented as methods (or code-calls), but the decision about which of these actions is to be taken is represented through rules. ConGolog <ref> [45] </ref> is a logic programming language for concurrent execution of actions. ConGolog creates static plans from a set of goals and primitive actions. ConGolog is built on the framework of Cohen and Levesque [25] who develop a logic of rational agents based intentionality using speech acts as a starting point.
Reference: [46] <author> L. Glicoe, R. Staats and M. Huhns. </author> <title> A Multi-Agent Environment for Department of Defense Distribution. </title> <booktitle> In: Proc. IJCAI 95 Workshop on Intelligent Systems, </booktitle> <year> 1995. </year> <month> 103 </month>
Reference-contexts: Agent Architectures. For an excellent anthology of classic works on agent systems, see [57]. There have been numerous proposals for agentization in the literature (e.g., <ref> [38, 46, 16] </ref>) which have been broadly classified by Genesereth and Ketchpel [43] into four categories: in the first category, each agent has an associated transducer that converts all incoming messages and requests into a form that is intelligible to the agent.
Reference: [47] <author> G. Gottlob. </author> <title> Complexity Results for Nonmonotonic Logics. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3):397--425, </volume> <year> 1992. </year>
Reference-contexts: This corresponds to what is known as certainty (resp., possibility) reasoning in databases [102], and to cautious (resp., brave) reasoning in the area of knowledge representation <ref> [47] </ref>. In particular, this question is important for an atom Do (ff), since it tells us whether ff is possibly executed by the agent (if (s)he picks nondeterministically some weak rational status set), or executed for sure (regardless of which action set is chosen). Unfortunately, these problems are intractable. <p> It is important to observe that by this correspondence, we obtain alternative proofs for the complexity results on reasonable status sets in the previous section. This is because the complexity results known for non-monotonic logic programs with stable model semantics <ref> [47, 48, 49] </ref> directly imply the above results. 9.4 Discussion Thus far, in this section, we have shown that given any logic program P , we can convert P into an agent program , AG (P ), (together with associated action base and empty sets of integrity constraints and action constraints)
Reference: [48] <author> G. Gottlob. </author> <title> The Complexity of Default Reasoning Under the Stationary Fixed Point Semantics. </title> <journal> Information and Computation, </journal> <volume> 121(1) </volume> <pages> 81-92, </pages> <year> 1995. </year>
Reference-contexts: It is important to observe that by this correspondence, we obtain alternative proofs for the complexity results on reasonable status sets in the previous section. This is because the complexity results known for non-monotonic logic programs with stable model semantics <ref> [47, 48, 49] </ref> directly imply the above results. 9.4 Discussion Thus far, in this section, we have shown that given any logic program P , we can convert P into an agent program , AG (P ), (together with associated action base and empty sets of integrity constraints and action constraints)
Reference: [49] <author> G. Gottlob. </author> <title> Translating default logic into standard autoepistemic logic, </title> <journal> Journal of the ACM, </journal> <volume> 42(4) </volume> <pages> 711-740, </pages> <year> 1995. </year>
Reference-contexts: It is important to observe that by this correspondence, we obtain alternative proofs for the complexity results on reasonable status sets in the previous section. This is because the complexity results known for non-monotonic logic programs with stable model semantics <ref> [47, 48, 49] </ref> directly imply the above results. 9.4 Discussion Thus far, in this section, we have shown that given any logic program P , we can convert P into an agent program , AG (P ), (together with associated action base and empty sets of integrity constraints and action constraints)
Reference: [50] <author> G. Gottlob, N. Leone, and H. Veith. </author> <title> Second-Order Logic and the Weak Exponential Hierarchies. </title> <booktitle> In: Proc. 20th Conference on Mathematical Foundations of Computer Science (MFCS '95), </booktitle> <volume> LNCS 969, </volume> <pages> pages 66-81, </pages> <year> 1995. </year> <note> Full paper CD-TR 95/80, </note> <institution> Christian Doppler Lab for Expert Systems, TU Wien. </institution>
Reference-contexts: This also applies in many cases to the results that we derive below; such results can be established using the complexity upgrading techniques for expression complexity described in <ref> [50] </ref>. Of course, if we use software packages S = (T S ; F S ) with high intrinsic complexity, then the evaluation of agent programs will also be time consuming, and leaves us no chance to build efficient algorithms.
Reference: [51] <author> A. Gupta and I.S. Mumick (eds). </author> <title> Materialized Views. </title> <publisher> MIT Press, </publisher> <year> 1998, </year> <note> to appear. </note>
Reference-contexts: Observe that automatic maintenance of integrity constraints is an ongoing research issues in databases, and a simple, declarative solution to this problem is by no means clear <ref> [51] </ref>. Therefore, we do not delve into the intricated and complex more general problem here. The fact that the program in Example 5.6 always had a unique rational status set in each of the possible scenarios, was not accidental.
Reference: [52] <author> A. Haddadi. </author> <title> Towards a Pragmatic Theory of Interactions, </title> <booktitle> In: Proc. Intl Conf. on Multi-Agent Systems, </booktitle> <pages> pp 133-139, </pages> <year> 1995. </year>
Reference-contexts: This makes our framework somewhat more general than Singh's, instead of explicitly encoding automata (hard to do when an agent has hundreds of ground actions it can take). Sycara and Zeng [101] provide a coordinated search methodology for multiple agents. Haddadi <ref> [52] </ref> develops a declarative theory of interactions, as do Rao and Georgeff [84], and Coradeschi and Karlson [27] who build agents for air traffic simulation. There has been extensive work on negotiation in multiagent systems, based on the initial idea of contract nets, due to Smith and Davis [99].
Reference: [53] <author> J.Y. Halpern and M.Y. Vardi. </author> <title> Model Checking vs. Theorem Proving: A Manifesto. </title> <booktitle> In: Proc. Intl Conf. on Knowledge Representation and Reasoning (KR 91), </booktitle> <pages> pp 325-334, </pages> <year> 1991. </year>
Reference-contexts: This problem corresponds to the task of model checking in the area of knowledge representation and reasoning, which has been addressed e.g. in <ref> [53, 20, 69] </ref>. We note here that for feasible status sets, the recognition problem is tractable under the assumptions that we made; this can be easily seen.
Reference: [54] <author> S. Hansson. </author> <title> Review of Deontic Logic in Computer Science: Normative System Specification. </title> <journal> Bulletin of the IGPL, </journal> <volume> 2(2) </volume> <pages> 249-250, </pages> <year> 1994. </year>
Reference-contexts: This is known as regimentation [65], and reflects the ideal behavior of an agent in a normative system. However, the essence of deontism is in capturing what should be done in a specific situation, rather than what finally is to be done under any circumstances <ref> [3, 79, 54] </ref>.
Reference: [55] <author> K.V. Hindriks, F.S. de Boer, W. van der Hoek and J.-J.Ch. Meyer. </author> <title> Formal Semantics of an Abstract Agent Programming Language. </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 204-218, </pages> <year> 1997. </year>
Reference-contexts: Such choices are expressed 2 by an agent program developed in a logical agent programming language that we introduce in this paper. We are not the first to propose agent programming paradigms several others, notably <ref> [97, 55, 45] </ref>, have done so before us. Our work builds upon these previous, pioneering efforts, in the following ways: 1. <p> Of this plethora of research, the work reported in this paper is perhaps closest to that of the group in CWI, Amsterdam, working on deontic logics for agent based programming <ref> [55, 31, 56] </ref> Below, we review the work on agents in a variety of arenas. Agent Programming. Shoham [97] was perhaps the first to propose an explicit programming language for agents, based on object oriented concepts, and based on the concept of an agent state. <p> Clearly both paradigms are needed for successfully building an agent. Closely related to Shoham's work is that of Hindriks et al. <ref> [55] </ref> where an agent programming language based on BDI-agents is presented (BDI stands for Belief, Desires, Intentionality). They proceed upon the assumptions that an agent language must have the ability for updating beliefs, goals and for practical reasoning. (finding means to achieve goals). Hindriks et al. [55] argue that Now, to <p> of Hindriks et al. <ref> [55] </ref> where an agent programming language based on BDI-agents is presented (BDI stands for Belief, Desires, Intentionality). They proceed upon the assumptions that an agent language must have the ability for updating beliefs, goals and for practical reasoning. (finding means to achieve goals). Hindriks et al. [55] argue that Now, to program an agent is to specify its initial mental state, the semantics of the basic actions the agent can perform, and to write a set of practical reasoning rules [55, p.211]. <p> Hindriks et al. [55] argue that Now, to program an agent is to specify its initial mental state, the semantics of the basic actions the agent can perform, and to write a set of practical reasoning rules <ref> [55, p.211] </ref>. <p> Practical reasoning is achieved in our system because each agent processes an explicit call through a method used to process that call. Hindriks et al. <ref> [55] </ref> argue that Now, to program an agent is to specify its initial mental state, the semantics of the basic actions the agent can perform, and to write a set of practical reasoning rules [55, p.211]. <p> Hindriks et al. [55] argue that Now, to program an agent is to specify its initial mental state, the semantics of the basic actions the agent can perform, and to write a set of practical reasoning rules <ref> [55, p.211] </ref>. In contrast to their framework, for us, an initial state is any set of (instantiated) data types they assume this is a set of logical atoms. <p> Their work has subsequently been used for a variety of other multiagent frameworks we do not go into these extensions here, as they are not directly related to our effort. In general, the approach in this paper builds upon the approaches of [97] and <ref> [55] </ref> in the following sense: first, we agree with these earlier approaches that the behavior of agents should be encoded through an agent program, and second, that actions taken by agents should modify agent states. However, we differ from these approaches in the following sense. <p> However, we differ from these approaches in the following sense. First, our notion of an agent state is built on top of arbitrary data structures, rather than on top of states represented in logic. As a consequence, our approach complements the work of <ref> [97, 55] </ref> where they focus on logical representations of agent state, describing beliefs, capabilities, commitments, and goals. In addition, [97] describes temporal action scheduling which our language does not currently support, though ongoing work will extend it to do so [35]. <p> If these modes of reasoning can be expressed as data structures, then the notion of agent proposed in our paper can benefit from the contributions in <ref> [97, 55] </ref>. Second, we propose a set of increasingly more satisfying declarative (epistemic) formal semantics for our work - [55] proposes an elegant proof theoretic operational semantics. Our semantics has the advantage of being neatly related to existing well-understood semantics for logic programs. <p> If these modes of reasoning can be expressed as data structures, then the notion of agent proposed in our paper can benefit from the contributions in [97, 55]. Second, we propose a set of increasingly more satisfying declarative (epistemic) formal semantics for our work - <ref> [55] </ref> proposes an elegant proof theoretic operational semantics. Our semantics has the advantage of being neatly related to existing well-understood semantics for logic programs. Third, we analyze the tradeoffs between the adopting an epistemically satisfying semantics, and the computational complexity of these semantics. <p> Precisely how various other deontic assumptions can be captured within our semantics remains to be worked out. The approach of Hindriks et al. <ref> [55] </ref> is based on such logics and has already been discussed earlier. Dignum and Conte [31] have used deontic logic extensively to develop methods for goal formation in our framework, goal formation is one of several actions that an agent can take.
Reference: [56] <author> W.van der Hoek, B. van Linder and J.-J.Ch.Meyer. </author> <title> A Logic of Capabilities. </title> <booktitle> In: Proc. 3rd Intl Symposium on the Logical Foundations of Computer Science (LFCS 94), </booktitle> <editor> A. Nerode and Y.V. </editor> <booktitle> Matiyasevich (eds), </booktitle> <pages> pp 366-378, </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Of this plethora of research, the work reported in this paper is perhaps closest to that of the group in CWI, Amsterdam, working on deontic logics for agent based programming <ref> [55, 31, 56] </ref> Below, we review the work on agents in a variety of arenas. Agent Programming. Shoham [97] was perhaps the first to propose an explicit programming language for agents, based on object oriented concepts, and based on the concept of an agent state.
Reference: [57] <editor> M. Huhns and M. Singh (eds). </editor> <booktitle> Readings in Agents. </booktitle> <publisher> Morgan Kaufmann Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Over the last few years, there has been intense work in the area of intelligent agents <ref> [57, 110] </ref>. <p> Agents can collaborate if they wish, but again, collaboration is an explicit action, and the rules governing such collaborations can be encoded as rules within agent programs. Agent Architectures. For an excellent anthology of classic works on agent systems, see <ref> [57] </ref>.
Reference: [58] <author> M. d'Inverno, D. Kinny, M. Luck and M. Wooldridge. </author> <title> A Formal Specification of dMARS. </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 146-166, </pages> <year> 1997. </year>
Reference-contexts: Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers [94, 91, 111]. Determining which agents to team with is a sort of decision making capability. Inverno et al. <ref> [58] </ref> present a framework for dMARS based on the BDI model. Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin [68] develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions.
Reference: [59] <author> B. Jenner and J. Toran. </author> <title> The Complexity of Obtaining Solutions for Problems in NP and NL. </title> <editor> In: A. Selman (ed), </editor> <title> Complexity Theory: A Retrospective II, </title> <note> to appear. </note>
Reference-contexts: Due to its nondeterministic nature, it contains problems which are not known to be solvable in FP NP k . The most prominent of these problems is the computation of an arbitrary model of a propositional formula <ref> [59] </ref>, which is the prototypical problem complete for the class FNP. Few natural FNP//log-complete problems are known to date; our analysis contributes some new such problems, which are from the realm of practice rather than artificially designed. <p> We finally remark that we have omitted here an analysis of the complexity of optimal status sets as proposed in Section 5.7, in order to avoid an abundance of complexity results. Based on the results presented above, coarse bounds are staightforward. The sources <ref> [23, 24, 59] </ref> and references therein provide suitable complexity classes for a more accurate assessment. 7 Complexity Results and Algorithms for Agent Programs: Basic Re sults This section contains the first part of the derivation of the complexity results which have been presented in Section 6.
Reference: [60] <author> N. R. Jennings. </author> <title> Controlling Cooperative Problem Solving in Industrial Multi-Agent Systems Using Joint Intentions. </title> <journal> Artificial Intelligence, </journal> <volume> 75(2) </volume> <pages> 1-46, </pages> <year> 1995. </year>
Reference-contexts: Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., <ref> [26, 60, 64, 87, 107] </ref>). As our approach allows 98 arbitrary decisions, and as negotiation is one form of decision making, our work provides a frame-work within which various negotiation strategies described in the literature can be encoded.
Reference: [61] <author> D. S. Johnson. </author> <title> A Catalog of Complexity Classes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, vol. A, chapter 2. </booktitle> <year> 1990. </year>
Reference-contexts: We assume that the reader is familiar with the basic concepts of complexity theory, in particular with NP-completeness and the polynomial hierarchy, and refer to <ref> [37, 61, 83] </ref> for background material on this subject and for concepts and notation that we use in the remainder of this paper. Our aim is a sharp characterization of the complexity of different computational tasks which arise in the context of agent programs.
Reference: [62] <author> S. Kanger. </author> <title> Law and Logic. </title> <journal> Theoria, </journal> <volume> 38, </volume> <year> 1972. </year>
Reference-contexts: Notice that the operators P; F; O; and W have been extensively studied in the area of deontic logic [79, 3]. Moreover, the operator Do is in the spirit of the praxiological operator E a A <ref> [62] </ref>, which informally means that agent a sees to it that A is the case [79, p.292].
Reference: [63] <author> A. Kemper, C. Kilger, G. Moerkotte. </author> <title> Function Materialization in Object Bases: Design, Realization, and Evaluation. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6(4), </volume> <year> 1994. </year>
Reference-contexts: In this paragraph, we merely explain the relationship between code call conditions and existing work on data and software integration. For example, there have been several efforts to integrate multiple relational DBMSs [29, 81] and relational DBMSs, object-oriented DBMSs and/or file systems <ref> [39, 63, 95] </ref>. However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76].
Reference: [64] <author> S. Kraus. </author> <title> Negotiation and Cooperation in Multi-Agent Environments. </title> <booktitle> Artificial Intelligence, Special Issue on Economic Principles of Multi-Agent Systems. </booktitle> <address> 94(1-2):79-98, </address> <year> 1997. </year>
Reference-contexts: Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., <ref> [26, 60, 64, 87, 107] </ref>). As our approach allows 98 arbitrary decisions, and as negotiation is one form of decision making, our work provides a frame-work within which various negotiation strategies described in the literature can be encoded.
Reference: [65] <author> C. Krogh. </author> <title> Obligations in Multi-Agent Systems. </title> <editor> In: Aamodt, Agnar, and Komorowski (eds), </editor> <booktitle> Proc. Fifth Scandinavian Conference on Artificial Intelligence (SCAI '95), </booktitle> <pages> pp 19-30, </pages> <address> Trondheim, Norway, 1995. </address> <publisher> ISO Press. </publisher>
Reference-contexts: This is known as regimentation <ref> [65] </ref>, and reflects the ideal behavior of an agent in a normative system. However, the essence of deontism is in capturing what should be done in a specific situation, rather than what finally is to be done under any circumstances [3, 79, 54].
Reference: [66] <author> D. Kuokka and L. Harada. </author> <title> Integrating Information via Matchmaking. </title> <journal> Journal of Intelligent Informations Systems, </journal> 6(2/3):261-279, 1996. 
Reference-contexts: Matchmaking. First, there has been substantial work on matchmaking, in which agents advertise their services, and matchmakers match an agent requesting a service with one (or more) that provides it. Kuokka and Harada <ref> [66] </ref> present the SHADE and COINS systems for matchmaking. Decker, Sycara, and Williamson [30] present matchmakers that store capability advertisements of different agents. Arisha et al. [5] present a theoretical foundation for matchmaking as well.
Reference: [67] <author> Y. Labrou and T. Finin. </author> <title> A Semantics Approach for KQML A General Purpose Communications Language for Software Agents. </title> <booktitle> In: Proc,. 1994 Intl Conf. on Information and Knowledge Management, </booktitle> <pages> pp 447-455, </pages> <year> 1994. </year>
Reference-contexts: have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources <ref> [4, 67, 68, 100, 108] </ref>. In the long run, a platform to support the creation and deployment of multiple software agents will need to interoperate with a wide variety of custom-made, as well as legacy software sources.
Reference: [68] <author> Y. Labrou and T. Finin. </author> <title> Semantics for an Agent Communication Language, </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 199-203, </pages> <year> 1997. </year>
Reference-contexts: have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources <ref> [4, 67, 68, 100, 108] </ref>. In the long run, a platform to support the creation and deployment of multiple software agents will need to interoperate with a wide variety of custom-made, as well as legacy software sources. <p> We will assume that the agent has the following functions that are integral in managing this message box. Note that over the years, we expect a wide variety of messaging languages to be developed (examples of such messaging languages include KQML <ref> [68] </ref> at a high level, and remote procedure calls at a much lower level). In order to provide maximal flexibility, we will merely specify below, the core interface functions available on the msgbox type. <p> Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model. Like us, they assume a state space, and the fact that actions cause state transitions. Labrou and Finin <ref> [68] </ref> develop the semantics of KQML, but do not explicitly present an action language. Reasoning About Actions. Several works [42, 8, 9, 10] have addressed the problem of modeling the logic of actions by means of logic programming languages. In this section, we briefly address these, one by one.
Reference: [69] <author> P. Liberatore and M. Schaerf. </author> <title> The Complexity of Model Checking for Belief Revision and Update. Ib: </title> <booktitle> Proc. AAAI-96, </booktitle> <pages> pp 556-561, </pages> <year> 1996. </year>
Reference-contexts: This problem corresponds to the task of model checking in the area of knowledge representation and reasoning, which has been addressed e.g. in <ref> [53, 20, 69] </ref>. We note here that for feasible status sets, the recognition problem is tractable under the assumptions that we made; this can be easily seen.
Reference: [70] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Observe that this property does not hold for non-positive agent programs in general. It is possible to give a characterization of the unique rational status set in terms of a fixpoint operator, akin to the least fixpoint of logic programs <ref> [70, 2] </ref>. For that, we define for every positive program P and agent state O S an operator T P;O S which maps a status set S to another status set. Definition 5.7 (T P;O S Operator) Suppose P is an agent program and O S an agent state. <p> (S i ) for any chain S 0 S 1 S 2 of status sets, the least fixpoint is given by lfp (T P;O S ) = i=0 P;O S ; where T 0 P;O S = ; and T i+1 P;O S ), for all i 0 (see e.g. <ref> [70, 2] </ref>). We then have the following result. Theorem 5.3 Let P be a positive agent program, and let O S be an agent state. <p> Then, S is feasible by definition of rational status set. By Lemma 5.2, S is a pre-fixpoint of T P;O S . Since T P;O S is monotone, it has by the Knaster-Tarski Theorem a least pre-fixpoint, which coincides with lfp (T P;O S ) (cf. <ref> [2, 70] </ref>). Thus, lfp (T P;O S ) S. Clearly, lfp (T P;O S ) satisfies (S1) and (S3); moreover, lfp (T P;O S ) satisfies (S2), as S satisfies (S2) and this property is hereditary. <p> Throughout this section, we assume the reader is familiar with standard logic program terminology as described by Lloyd <ref> [70] </ref> and nonmonotonic logic programming terminology [78]. 9.1 Feasible Status Sets and Models of Logic Programs In this subsection, we describe a transformation AG that takes as input, a logic program P , and pro duces as output: * An action base, all of whose actions have an empty precondition, add
Reference: [71] <author> J. Lobo, J. Minker and A. Rajasekar. </author> <title> Foundations of Disjunctive Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Similar equivalences also exist between rational status sets and disjunctive logic programs <ref> [71] </ref>. * Third, we show that the stable models of P are in a 1-1 correspondence with the reasonable status sets of AG (P ).
Reference: [72] <author> J. Lobo and V.S. Subrahmanian. </author> <title> Relating Minimal Models and Pre-Requisite-Free Normal Defaults. </title> <journal> Information Processing Letters, </journal> <volume> 44 </volume> <pages> 129-133, </pages> <year> 1992. </year>
Reference-contexts: If A is a rational status set of AG (P ), then M A = fa j P (a) 2 A, a occurs in P g is a minimal model of P . When taken in conjunction with results of Lobo and Subrahmanian <ref> [72] </ref>, the above result implies that there exists a translation T (given in [72]) such that the rational status sets of AG (P ) correspond exactly to the extensions of a pre-requisite free normal default theory T (P ). 9.3 Reasonable Status Sets and Stable Semantics In this section, we show <p> When taken in conjunction with results of Lobo and Subrahmanian <ref> [72] </ref>, the above result implies that there exists a translation T (given in [72]) such that the rational status sets of AG (P ) correspond exactly to the extensions of a pre-requisite free normal default theory T (P ). 9.3 Reasonable Status Sets and Stable Semantics In this section, we show that the reasonable status sets of AG (P ) correspond to the stable <p> and Truszczynski [78] prove 1-1 correspondences between stable models of logic pro grams and extensions of default logic theories. * Marek and Subrahmanian [77] and Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic programs and appropriate types of expansions of auto-epistemic theories. * Lobo and Subrahmanian <ref> [72] </ref> prove 1-1 correspondences between minimal models of logic programs, and extensions of prerequisite-free normal default logic theories. * Ben-Eliyahu and Dechter [15] have proved that stable models and minimal models of logic programs may be viewed as models of a suitable logical theory.
Reference: [73] <author> J. Lu, G. Moerkotte, J. Schue, </author> <title> and V.S. Subrahmanian. Efficient Maintenance of Materialized Mediated Views. </title> <booktitle> In: Proc. 1995 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Before proceeding to this definition, we need to introduce some syntactic assumptions. The content of Section 3.1 is not new work. It builds upon a previous effort called HERMES by one of the authors on heterogeneous data and software integration <ref> [1, 19, 74, 73, 76] </ref>. The reader familiar with that syntax may skip this section. Suppose we consider a body S = (T S ; F S ) of software code. <p> It is closely related to the HERMES effort. HERMES used minimalistic versions of logic to integrate data and software, while SIMS used a somewhat richer language. As a 99 consequence, HERMES was able to take advantage of very efficient caching and query optimization methods <ref> [73, 1] </ref>, but may have not been able to easily express some of the more sophisticated reasoning tasks desired by the authors of SIMS.
Reference: [74] <author> J. Lu, A. Nerode and V.S. Subrahmanian. </author> <title> Hybrid Knowledge Bases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 8(5) </volume> <pages> 773-785, </pages> <year> 1996. </year>
Reference-contexts: Before proceeding to this definition, we need to introduce some syntactic assumptions. The content of Section 3.1 is not new work. It builds upon a previous effort called HERMES by one of the authors on heterogeneous data and software integration <ref> [1, 19, 74, 73, 76] </ref>. The reader familiar with that syntax may skip this section. Suppose we consider a body S = (T S ; F S ) of software code. <p> This is somewhat complicated to do because the use of arbitrary agent states over arbitrary data structures means that classical model semantics, minimal model semantics, and stable semantics cannot be used directly. Rather, the notion of models over arbitrary data structures introduced by Lu et al. <ref> [74] </ref> must be used. For this reason, we defer this to further work. <p> However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in <ref> [19, 74, 74, 100, 76] </ref>. The Stanford TSIMMIS project [22] effort aimed at integrating a wide variety of heterogeneous databases, together with a free text indexing system.
Reference: [75] <author> P. Maes. </author> <title> Agents that Reduce Work and Information Overload. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 37(7) </volume> <pages> 31-40, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Over the last few years, there has been intense work in the area of intelligent agents [57, 110]. Applications of such agent technology have ranged from intelligent news and mail filtering programs <ref> [75] </ref>, to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources [4, 67, 68, 100, 108].
Reference: [76] <author> S. Marcus and V.S. Subrahmanian. </author> <title> Foundations of Multimedia Database Systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(3) </volume> <pages> 474-523, </pages> <year> 1996. </year>
Reference-contexts: Before proceeding to this definition, we need to introduce some syntactic assumptions. The content of Section 3.1 is not new work. It builds upon a previous effort called HERMES by one of the authors on heterogeneous data and software integration <ref> [1, 19, 74, 73, 76] </ref>. The reader familiar with that syntax may skip this section. Suppose we consider a body S = (T S ; F S ) of software code. <p> However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in <ref> [19, 74, 74, 100, 76] </ref>. The Stanford TSIMMIS project [22] effort aimed at integrating a wide variety of heterogeneous databases, together with a free text indexing system. <p> The paper [35] will report upon several experiments evaluating the ease of computing the several diverse semantics described in this paper. This implementation builds upon our existing HERMES Heterogeneous Reasoning and Mediator System, reported on in <ref> [19, 76, 100] </ref>. * We are studying the problem of whether all agent programs (under different semantics) can be embedded into logic programs.
Reference: [77] <author> W. Marek and V.S. Subrahmanian. </author> <title> The Relationship Between Stable, Supported, Default and Auto-Epistemic Semantics for General Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 365-386, </pages> <year> 1992. </year>
Reference-contexts: This automatically implies, by results of Marek and Subrah-manian <ref> [77] </ref>, the existence of a 1-1 correspondence between supported models of P , rational status sets of AG (P ), weak extensions of a default theory associated with P as defined by [77], and expansions of an auto-epistemic theory associated with P [77]. <p> This automatically implies, by results of Marek and Subrah-manian <ref> [77] </ref>, the existence of a 1-1 correspondence between supported models of P , rational status sets of AG (P ), weak extensions of a default theory associated with P as defined by [77], and expansions of an auto-epistemic theory associated with P [77]. Similar equivalences also exist between rational status sets and disjunctive logic programs [71]. * Third, we show that the stable models of P are in a 1-1 correspondence with the reasonable status sets of AG (P ). <p> automatically implies, by results of Marek and Subrah-manian <ref> [77] </ref>, the existence of a 1-1 correspondence between supported models of P , rational status sets of AG (P ), weak extensions of a default theory associated with P as defined by [77], and expansions of an auto-epistemic theory associated with P [77]. Similar equivalences also exist between rational status sets and disjunctive logic programs [71]. * Third, we show that the stable models of P are in a 1-1 correspondence with the reasonable status sets of AG (P ). <p> It is straightforward to show that S ? is a stable model of P . But then S ? M , which is a contradiction, as no stable model of any logic program can be a strict subset of another stable model <ref> [77] </ref>. It is important to observe that by this correspondence, we obtain alternative proofs for the complexity results on reasonable status sets in the previous section. <p> For ex ample, the following results are well known: * Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic pro grams and extensions of default logic theories. * Marek and Subrahmanian <ref> [77] </ref> and Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic programs and appropriate types of expansions of auto-epistemic theories. * Lobo and Subrahmanian [72] prove 1-1 correspondences between minimal models of logic programs, and extensions of prerequisite-free normal default logic theories. * Ben-Eliyahu and Dechter [15] have
Reference: [78] <author> W. Marek and M. Truszczynski. </author> <title> Nonmonotonic Logics - Context-Dependent Reasoning. </title> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: These observations led to the well known stable model semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic [80] (see <ref> [41, 78] </ref>), as well as numerical reasoning paradigms such as linear programming and integer programming [13, 14]. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction. <p> Similar equivalences also exist between rational status sets and disjunctive logic programs [71]. * Third, we show that the stable models of P are in a 1-1 correspondence with the reasonable status sets of AG (P ). As a consequence of known results due to Marek and Truszczynski <ref> [78] </ref>, it follows immediately that there is a 1-1 correspondence between reasonable status sets and extensions of default logic theories associated with P . Throughout this section, we assume the reader is familiar with standard logic program terminology as described by Lloyd [70] and nonmonotonic logic programming terminology [78]. 9.1 Feasible <p> and Truszczynski <ref> [78] </ref>, it follows immediately that there is a 1-1 correspondence between reasonable status sets and extensions of default logic theories associated with P . Throughout this section, we assume the reader is familiar with standard logic program terminology as described by Lloyd [70] and nonmonotonic logic programming terminology [78]. 9.1 Feasible Status Sets and Models of Logic Programs In this subsection, we describe a transformation AG that takes as input, a logic program P , and pro duces as output: * An action base, all of whose actions have an empty precondition, add list and delete set, * An <p> The above results, when taken in conjunction with known results linking logic programs and non-monotonic reasoning, provide connections with well known nonmonotonic logics as well. For ex ample, the following results are well known: * Marek and Truszczynski <ref> [78] </ref> prove 1-1 correspondences between stable models of logic pro grams and extensions of default logic theories. * Marek and Subrahmanian [77] and Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic programs and appropriate types of expansions of auto-epistemic theories. * Lobo and Subrahmanian [72] prove 1-1 <p> For ex ample, the following results are well known: * Marek and Truszczynski <ref> [78] </ref> prove 1-1 correspondences between stable models of logic pro grams and extensions of default logic theories. * Marek and Subrahmanian [77] and Marek and Truszczynski [78] prove 1-1 correspondences between stable models of logic programs and appropriate types of expansions of auto-epistemic theories. * Lobo and Subrahmanian [72] prove 1-1 correspondences between minimal models of logic programs, and extensions of prerequisite-free normal default logic theories. * Ben-Eliyahu and Dechter [15] have proved that stable models and
Reference: [79] <editor> J.-J. C. Meyer and R. Wieringa. (eds.) </editor> <booktitle> Deontic Logic in Computer Science. </booktitle> <publisher> Wiley & Sons, </publisher> <address> Chichester et al, </address> <year> 1993. </year>
Reference-contexts: Notice that the operators P; F; O; and W have been extensively studied in the area of deontic logic <ref> [79, 3] </ref>. Moreover, the operator Do is in the spirit of the praxiological operator E a A [62], which informally means that agent a sees to it that A is the case [79, p.292]. <p> Moreover, the operator Do is in the spirit of the praxiological operator E a A [62], which informally means that agent a sees to it that A is the case <ref> [79, p.292] </ref>. <p> We borrow from the field of deontic logic the syntax of deontic statements; however we do not lay down the semantics of action programs on the basis of one of the numerous deontic logical systems 20 (e.g., Standard Deontic Logic (SDL), which amounts to the modal logic KD <ref> [3, 79] </ref>). We discuss the relationship between our approach and deontic logic in detail in Section 11. <p> This is known as regimentation [65], and reflects the ideal behavior of an agent in a normative system. However, the essence of deontism is in capturing what should be done in a specific situation, rather than what finally is to be done under any circumstances <ref> [3, 79, 54] </ref>. <p> To date, no active database system has provided a formal semantics for obligatory, permitted, and forbidden actions. In this paper, we have done so, building on top of classical deontic logic syntax <ref> [3, 79] </ref>. We have added to deontic logic as well in several ways: first, we have introduced the Do operator which standard deontic logic does not contain.
Reference: [80] <author> R. Moore. </author> <title> Semantical Considerations on Nonmonotonic Logics. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: These observations led to the well known stable model semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic [86] and auto-epistemic logic <ref> [80] </ref> (see [41, 78]), as well as numerical reasoning paradigms such as linear programming and integer programming [13, 14]. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction.
Reference: [81] <author> A. Motro. Superviews: </author> <title> Virtual Integration of Multiple Databases. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE 13(7) </volume> <pages> 785-798, </pages> <year> 1987. </year>
Reference-contexts: There is now a great deal of work in mediated systems techniques. In this paragraph, we merely explain the relationship between code call conditions and existing work on data and software integration. For example, there have been several efforts to integrate multiple relational DBMSs <ref> [29, 81] </ref> and relational DBMSs, object-oriented DBMSs and/or file systems [39, 63, 95]. However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76].
Reference: [82] <author> N.J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1980. </year>
Reference-contexts: In most work in AI <ref> [82, 44, 90] </ref> and logical approaches to action [11], it is assumed that states are sets of ground logical atoms. In the fertile area of active databases, it is assumed that states reflect the content of a relational database. <p> A difference between our work and classical AI systems, is that in the latter, change is modeled solely as the insertion and deletion of logical atoms from a state which is a set of logical atoms <ref> [82] </ref>. In the real world, however, states are usually instances of fairly complex data structures. Therefore, in our case, changes affect components of objects in O S where S is the software code manipulated by the agent in question.
Reference: [83] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We assume that the reader is familiar with the basic concepts of complexity theory, in particular with NP-completeness and the polynomial hierarchy, and refer to <ref> [37, 61, 83] </ref> for background material on this subject and for concepts and notation that we use in the remainder of this paper. Our aim is a sharp characterization of the complexity of different computational tasks which arise in the context of agent programs. <p> Proof of these results are not difficult, using the well-known result that inference from a datalog program (Horn logic program) is P-complete, cf. [28]. The entries for the computation problem are the classes FC from the literature considered e.g. in <ref> [83, 23, 24] </ref> (i.e., compute any arbitrary solution to a problem instance; see subsection 6.3 for more details). Unless stated otherwise, they stand for completeness under an appropriate notion of polynomial time reduction as used in [83, 23]. <p> Unless stated otherwise, they stand for completeness under an appropriate notion of polynomial time reduction as used in <ref> [83, 23] </ref>. <p> For the decisional classes, the arcs in Figure 4 actually denote inclusions, i.e., the transformation of problems in C 1 to problems in C 2 is by means of the identity. The classes for search problems, which are often also called function classes, can be found in <ref> [83, 24] </ref>. A search problem is a generalization of a decision problem, in which for every instance 50 . . .
Reference: [84] <author> A.S. Rao and M. Georgeff. </author> <title> Modeling Rational Agents within a BDI-Architecture. </title> <booktitle> In: Proc. Intl Conf. on Knowledge Representation and Reasoning (KR 91), </booktitle> <pages> pp 473-484, </pages> <year> 1991. </year>
Reference-contexts: Sycara and Zeng [101] provide a coordinated search methodology for multiple agents. Haddadi [52] develops a declarative theory of interactions, as do Rao and Georgeff <ref> [84] </ref>, and Coradeschi and Karlson [27] who build agents for air traffic simulation. There has been extensive work on negotiation in multiagent systems, based on the initial idea of contract nets, due to Smith and Davis [99].
Reference: [85] <author> R. Reiter. </author> <title> On Closed-World Databases. </title> <editor> In: H. Gallaire and J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pp 55-76. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: As feasible status sets may allow certain actions to be neither permitted nor forbidden, we introduce the notation of a complete status set in Section 5.6.2. Two policies are allowed one of these policies is akin to the closed world assumption in databases <ref> [85] </ref> (all actions that are not explicitly permitted are forbidden) and the other is akin to the open world assumption (all actions that are not explicitly forbidden are allowed).
Reference: [86] <author> R. Reiter. </author> <title> A Logic for Default Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: These observations led to the well known stable model semantics for logic programs due to Gelfond and Lifschitz [40] which in turn was shown to have strong equivalences with the classical nonmonotonic reasoning paradigms such as default logic <ref> [86] </ref> and auto-epistemic logic [80] (see [41, 78]), as well as numerical reasoning paradigms such as linear programming and integer programming [13, 14]. Second, the presence of derivation by contraposition may have a detrimental effect on the complexity of programs, since it inherently simulates disjunction. <p> Third, our framework also allows nonmonotonic inference through the negation operator in rule bodies this nonmonotonic negation operator does not occur in classical deontic logic model theory. The need for non-monotonic operators has been well argued by Reiter <ref> [86] </ref>. Last, but not least, the semantics of classical deontic logic is given in terms of a classical Hintikka-Kripke style model theory.
Reference: [87] <author> J. S. Rosenschein and G. Zlotkin. </author> <title> Rules of Encounter: Designing Conventions for Automated Negotiation Among Computers. </title> <publisher> MIT Press, </publisher> <address> Boston, </address> <year> 1994. </year>
Reference-contexts: Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., <ref> [26, 60, 64, 87, 107] </ref>). As our approach allows 98 arbitrary decisions, and as negotiation is one form of decision making, our work provides a frame-work within which various negotiation strategies described in the literature can be encoded.
Reference: [88] <author> S.J. Rosenschein. </author> <title> Formal Theories of Knowledge in AI and Robotics. </title> <booktitle> New Generation Computing 3(4) </booktitle> <pages> 345-357, </pages> <year> 1985. </year>
Reference-contexts: Thus, we can specifically gain from the work of Dignum and Conte [31], through explicitly plugging-in such a framework as an action called form-goals implemented through the elegant work they report. Agent Decision Making. There has been a significant amount of work on agent decision making. Rosenschein <ref> [88] </ref> was perhaps the first to say that agents act according to states, and which actions they take are determined by rules of the form When P is true of the state of the environment, then the agent should take action A.
Reference: [89] <author> S.J. </author> <title> Rosenschein and L.P. Kaelbling. A Situated View of Representation and Control. </title> <journal> Artificial Intelligence, </journal> <volume> 73, </volume> <year> 1995. </year>
Reference-contexts: As the reader can easily see, our framework builds upon this intuitive idea, though (i) our notion of state is defined very generally and (ii) agent programs have a richer set of rules than those listed above. Rosenschein and Kaelbling <ref> [89] </ref> extend this framework to provide a basis for such actions in terms of situated automata theory. Bratman et al. [18] define the IRMA system which uses similar ideas to generate plans. In their framework, different possible courses of actions (Plans) are generated, based on the agent's intentions.
Reference: [90] <author> S.J. Russel and P. Norvig. </author> <title> Artificial Intelligence: A Modern Approach. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: In most work in AI <ref> [82, 44, 90] </ref> and logical approaches to action [11], it is assumed that states are sets of ground logical atoms. In the fertile area of active databases, it is assumed that states reflect the content of a relational database.
Reference: [91] <author> T. Sandholm and V. Lesser. </author> <title> Coalition Formation Amongst Bounded Rational Agents. </title> <booktitle> In: Proc. IJCAI 1995, </booktitle> <pages> pp 662-669, </pages> <address> Montreal, Canada, </address> <year> 1995. </year>
Reference-contexts: Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers <ref> [94, 91, 111] </ref>. Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model. Like us, they assume a state space, and the fact that actions cause state transitions.
Reference: [92] <author> M. Schoppers and D. Shapiro. </author> <title> Designing Embedded Agents to Optimize End-User Objectives. </title> <booktitle> In: Proc. 1997 Intl Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 2-12, </pages> <year> 1997. </year> <month> 105 </month>
Reference-contexts: Verharen et al. [105] present a language-action approach to agent decision making, which has some similarities to our effort. However, they do not develop any formal semantics for their work, and their language for agent programs uses a linguistic rather than a logical approach. Schoppers and Shapiro <ref> [92] </ref> describe techniques to design agents that optimize objective functions such objective functions are similar to the cost functions we have described. One effort that is close to ours is Singh's approach [98].
Reference: [93] <author> R. Schwartz and S. Kraus. </author> <title> Bidding Mechanisms for Data Allocation in Multi-Agent Environments, </title> <booktitle> In : Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 56-70, </pages> <year> 1997. </year>
Reference-contexts: In this paradigm, an agent seeking a service invites bids from other agents, and selects the bid that most closely matches its own. Schwartz and Kraus <ref> [93] </ref> present a model of agent decision making where one agent invites bids (this is an action !) and others evaluate the bids (another action) and respond; this kind of behavior is encodable through agent programs together with underlying data structures. <p> of work is complementary to ours: an agent negotiates by taking certain actions in accordance with its negotiation strategy, while we provide the hooks to include such actions within our framework, but do not explicitly study how the negotiation actions are performed, as this has been well done by others <ref> [99, 93] </ref>. Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers [94, 91, 111]. Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model.
Reference: [94] <author> O. Shehory, K. Sycara and S. Jha. </author> <title> Multi-Agent Coordination through Coalition Formation. </title> <booktitle> In: Proc. 1997 Intl. Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 135-146, </pages> <year> 1997. </year>
Reference-contexts: Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers <ref> [94, 91, 111] </ref>. Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model. Like us, they assume a state space, and the fact that actions cause state transitions.
Reference: [95] <author> A. Sheth and J. Larson. </author> <title> Federated Database Systems for Managing Distributed, Heterogeneous and Autonomous Databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <year> 1990. </year>
Reference-contexts: In this paragraph, we merely explain the relationship between code call conditions and existing work on data and software integration. For example, there have been several efforts to integrate multiple relational DBMSs [29, 81] and relational DBMSs, object-oriented DBMSs and/or file systems <ref> [39, 63, 95] </ref>. However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in [19, 74, 74, 100, 76].
Reference: [96] <author> J. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison Wesley, </publisher> <year> 1967. </year>
Reference-contexts: is a code call, and X is either a variable symbol, or an object of the output type of cc, then in (X; cc) is a code call atom. 2 Code call atoms, when evaluated, return boolean values (i.e. they may be thought of as special types of logical atoms <ref> [96] </ref>). Intuitively, a code call atom succeeds just in case X is in the result set returned by cc (when X is an object), or when X can be made to point to one of the objects returned by executing the code call.
Reference: [97] <author> Y. Shoham. </author> <title> Agent Oriented Programming, </title> <journal> Artificial Intelligence, </journal> <volume> 60 </volume> <pages> 51-92, </pages> <year> 1993. </year>
Reference-contexts: Such choices are expressed 2 by an agent program developed in a logical agent programming language that we introduce in this paper. We are not the first to propose agent programming paradigms several others, notably <ref> [97, 55, 45] </ref>, have done so before us. Our work builds upon these previous, pioneering efforts, in the following ways: 1. <p> Of this plethora of research, the work reported in this paper is perhaps closest to that of the group in CWI, Amsterdam, working on deontic logics for agent based programming [55, 31, 56] Below, we review the work on agents in a variety of arenas. Agent Programming. Shoham <ref> [97] </ref> was perhaps the first to propose an explicit programming language for agents, based on object oriented concepts, and based on the concept of an agent state. <p> In Shoham's approach, an agent is an entity whose state is viewed as consisting of mental components such as beliefs, capabilities, choices, and commitments <ref> [97] </ref>. He proposes a language, Agent-0, for agent programming, that provides a mechanism to express actions, time, and obligations. Agent-0 is a simple, yet powerful language. There are several differences between our approach and Shoham's. <p> Their work has subsequently been used for a variety of other multiagent frameworks we do not go into these extensions here, as they are not directly related to our effort. In general, the approach in this paper builds upon the approaches of <ref> [97] </ref> and [55] in the following sense: first, we agree with these earlier approaches that the behavior of agents should be encoded through an agent program, and second, that actions taken by agents should modify agent states. However, we differ from these approaches in the following sense. <p> However, we differ from these approaches in the following sense. First, our notion of an agent state is built on top of arbitrary data structures, rather than on top of states represented in logic. As a consequence, our approach complements the work of <ref> [97, 55] </ref> where they focus on logical representations of agent state, describing beliefs, capabilities, commitments, and goals. In addition, [97] describes temporal action scheduling which our language does not currently support, though ongoing work will extend it to do so [35]. <p> As a consequence, our approach complements the work of [97, 55] where they focus on logical representations of agent state, describing beliefs, capabilities, commitments, and goals. In addition, <ref> [97] </ref> describes temporal action scheduling which our language does not currently support, though ongoing work will extend it to do so [35]. If these modes of reasoning can be expressed as data structures, then the notion of agent proposed in our paper can benefit from the contributions in [97, 55]. <p> If these modes of reasoning can be expressed as data structures, then the notion of agent proposed in our paper can benefit from the contributions in <ref> [97, 55] </ref>. Second, we propose a set of increasingly more satisfying declarative (epistemic) formal semantics for our work - [55] proposes an elegant proof theoretic operational semantics. Our semantics has the advantage of being neatly related to existing well-understood semantics for logic programs.
Reference: [98] <author> M.P. Singh. </author> <title> A Customizable Coordination Service for Autonomous Agents. </title> <booktitle> In: Proc. 1997 Intl Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 86-99, </pages> <year> 1997. </year>
Reference-contexts: Schoppers and Shapiro [92] describe techniques to design agents that optimize objective functions such objective functions are similar to the cost functions we have described. One effort that is close to ours is Singh's approach <ref> [98] </ref>. Like us, he is concerned about hetero 97 geneity in agents, and he develops a theory of agent interactions through workflow diagrams. Intu--itively, in this framework, an agent is viewed as a finite state automaton as is well known, finite state automata can be easily encoded in logic.
Reference: [99] <author> R.G. Smith and R. Davis. </author> <title> Negotiation as a Metaphor for Distributed Problem Solving, </title> <booktitle> Artificial Intelligence 20 </booktitle> <pages> 63-109, </pages> <year> 1983. </year>
Reference-contexts: Haddadi [52] develops a declarative theory of interactions, as do Rao and Georgeff [84], and Coradeschi and Karlson [27] who build agents for air traffic simulation. There has been extensive work on negotiation in multiagent systems, based on the initial idea of contract nets, due to Smith and Davis <ref> [99] </ref>. In this paradigm, an agent seeking a service invites bids from other agents, and selects the bid that most closely matches its own. <p> of work is complementary to ours: an agent negotiates by taking certain actions in accordance with its negotiation strategy, while we provide the hooks to include such actions within our framework, but do not explicitly study how the negotiation actions are performed, as this has been well done by others <ref> [99, 93] </ref>. Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers [94, 91, 111]. Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model.
Reference: [100] <author> V.S. Subrahmanian. </author> <title> Amalgamating Knowledge Bases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(2) </volume> <pages> 291-331, </pages> <year> 1994. </year>
Reference-contexts: have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources <ref> [4, 67, 68, 100, 108] </ref>. In the long run, a platform to support the creation and deployment of multiple software agents will need to interoperate with a wide variety of custom-made, as well as legacy software sources. <p> However, to date, the semantics of mediators that take actions has not been explored. The work in this paper builds upon mediation efforts reported upon in our HERMES effort described previously in <ref> [19, 74, 74, 100, 76] </ref>. The Stanford TSIMMIS project [22] effort aimed at integrating a wide variety of heterogeneous databases, together with a free text indexing system. <p> The paper [35] will report upon several experiments evaluating the ease of computing the several diverse semantics described in this paper. This implementation builds upon our existing HERMES Heterogeneous Reasoning and Mediator System, reported on in <ref> [19, 76, 100] </ref>. * We are studying the problem of whether all agent programs (under different semantics) can be embedded into logic programs.
Reference: [101] <author> K. Sycara and D. Zeng. </author> <title> Multi-Agent Integration of Information Gathering and Decision Support. </title> <booktitle> In: Proc. European Conf. on Artificial Intelligence (ECAI '96), </booktitle> <year> 1996. </year>
Reference-contexts: This makes our framework somewhat more general than Singh's, instead of explicitly encoding automata (hard to do when an agent has hundreds of ground actions it can take). Sycara and Zeng <ref> [101] </ref> provide a coordinated search methodology for multiple agents. Haddadi [52] develops a declarative theory of interactions, as do Rao and Georgeff [84], and Coradeschi and Karlson [27] who build agents for air traffic simulation.
Reference: [102] <author> J.D. </author> <title> Ullman Principles of Database and Knowledge-base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: preceded by a negation sign (:). 2 We require that every root variable which occurs in the head A of a rule r and every root- or path-variable occurring in a negative atom also occurs in some positive atom in the body (this is the well-known safety requirement on rules <ref> [102] </ref>). A rule r is to be understood as being implicitly universally quantified over the variables in it. A rule is called positive, if no negation sign occurs in front of an action status atom in its body. <p> These semantics have a dual computational nature; preference effects minimization of the F-part of the status set, while weakness effects maximization of the Do-part. Presence of integrity constraints, even of the simplest nature which is common in practice (e.g., functional dependencies <ref> [102] </ref> in a database), can have a detrimental effect on (variants of) rational status sets and raises the complexity by one level in the polynomial hierarchy. <p> Since in general, multiple weak rational status sets may exist, it appears important to know whether some action status atom A belongs to all (resp., some) weak rational status set. This corresponds to what is known as certainty (resp., possibility) reasoning in databases <ref> [102] </ref>, and to cautious (resp., brave) reasoning in the area of knowledge representation [47]. <p> Notice that FDs are one of the most basic and important type of dependencies in databases <ref> [102] </ref>. 3 Theorem 8.1 Let P be a fixed agent program, where IC ma y be nonempty. Then, deciding whether P has a feasible status set on a given agent state O S is NP-complete, and computing an arbitrary feasible status set is FNP-complete.
Reference: [103] <author> R. van der Meyden. </author> <title> The Dynamic Logic of Permission. </title> <booktitle> In: Proc. Fifth Annual IEEE Symposium on Logic in Computer Science (LICS `90), </booktitle> <pages> pages 72-78, </pages> <year> 1990. </year>
Reference: [104] <author> M. Vardi. </author> <title> Complexity of Relational Query Languages. </title> <booktitle> In: Proc. 14th ACM Symposium on the Theory of Computing (STOC `82), </booktitle> <pages> pp 137-146, </pages> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: This corresponds to what is commonly called the data complexity of a program <ref> [104] </ref>. If we consider varying programs where the agent state is fixed (resp., varying), we would have expression (or program) complexity and combined complexity, which are 46 typically one exponential higher than data complexity.
Reference: [105] <author> E. Verharen, F. Dignum and S. Bos. </author> <title> Implementation of a Cooperative Agent Architecture Based on the Language-Action Perspective, </title> <booktitle> In: Proc. 1997 Intl Workshop on Agent Theories, Architectures, and Languages, </booktitle> <address> Providence, </address> <publisher> RI, </publisher> <pages> pp 26-39, </pages> <year> 1997. </year>
Reference-contexts: In their framework, different possible courses of actions (Plans) are generated, based on the agent's intentions. These plans are then evaluated to determine which ones are consistent and optimal with respect to achieving these intentions. Verharen et al. <ref> [105] </ref> present a language-action approach to agent decision making, which has some similarities to our effort. However, they do not develop any formal semantics for their work, and their language for agent programs uses a linguistic rather than a logical approach.
Reference: [106] <author> K. Wagner. </author> <title> Bounded Query Classes. </title> <journal> SIAM Journal of Computing, </journal> <volume> 19(5) </volume> <pages> 833-846, </pages> <year> 1990. </year>
Reference: [107] <author> M. Wellman. </author> <title> A Market-Oriented Programming Environment and its Application to Distributed Multi-commodity Flow Problems. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 1 </volume> <pages> 1-23, </pages> <year> 1993. </year>
Reference-contexts: Collaborative Problem Solving. There has also been extensive work on collaborative problem solving and negotiation in multiagent systems (e.g., <ref> [26, 60, 64, 87, 107] </ref>). As our approach allows 98 arbitrary decisions, and as negotiation is one form of decision making, our work provides a frame-work within which various negotiation strategies described in the literature can be encoded.
Reference: [108] <author> G. Wiederhold. </author> <title> Intelligent Integration of Information. </title> <booktitle> In: Proc. 1993 ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pp 434-437, </pages> <year> 1993. </year>
Reference-contexts: have ranged from intelligent news and mail filtering programs [75], to agents that monitor the state of the stock market and detect trends in stock prices, to intelligent web search agents [36], to the digital battlefield where agent technology closely monitors and merges information gathered from multiple heterogeneous information sources <ref> [4, 67, 68, 100, 108] </ref>. In the long run, a platform to support the creation and deployment of multiple software agents will need to interoperate with a wide variety of custom-made, as well as legacy software sources. <p> The third approach described in [43] is to completely rewrite the code implementing an agent which is obviously a very expensive alternative. Last but not least, there is the mediation approach proposed by Wiederhold <ref> [108] </ref>, which assumes that all agents will communicate with a mediator which in turn may send messages to other agents. In contrast, our framework allows point to point communication between agents without having to go through a mediator.
Reference: [109] <author> F. Wilder. </author> <title> A Guide to the TCP/IP Protocol Suite. </title> <publisher> Artech House, </publisher> <year> 1993. </year>
Reference-contexts: The message box is a buffer that may be filled (when it sends a message) or flushed (when it reads the message) by the agent. In addition, we assume the existence of an operating-systems level messaging protocol (e.g. sockets or TCP/IP <ref> [109] </ref>) that can fill in (with incoming messages) or flush (when a message is physically sent off) this buffer. We will assume that the agent has the following functions that are integral in managing this message box.
Reference: [110] <author> M. Wooldridge and N.R. Jennings. </author> <title> Intelligent Agents: </title> <journal> Theory and Practice, Knowledge Engineering Reviews, </journal> <volume> 10(2), </volume> <year> 1995. </year>
Reference-contexts: 1 Introduction Over the last few years, there has been intense work in the area of intelligent agents <ref> [57, 110] </ref>.
Reference: [111] <author> M. Wooldridge and N.R. Jennings. </author> <title> Formalizing the Cooperative Problem Solving Process, </title> <editor> In: M. Huhns and M. Singh (eds.), </editor> <booktitle> Readings in Agents, </booktitle> <pages> pp 430-440. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1997. </year> <month> 106 </month>
Reference-contexts: Coalition formation mechanisms where agents dynamically team up with other agents has been intensely studied by many researchers <ref> [94, 91, 111] </ref>. Determining which agents to team with is a sort of decision making capability. Inverno et al. [58] present a framework for dMARS based on the BDI model. Like us, they assume a state space, and the fact that actions cause state transitions.
References-found: 111

