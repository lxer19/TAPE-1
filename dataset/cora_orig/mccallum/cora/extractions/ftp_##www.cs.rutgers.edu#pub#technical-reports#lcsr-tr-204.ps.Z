URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-204.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: Net Address: minsky@cs.rutgers.edu  
Title: Regularities in Software Systems  
Author: By: Naftaly H. Minsky 
Note: 1 Work supported in part by NSF grant No. CCR-8807803.  
Address: New Brunswick, NJ 08903  
Affiliation: 1 Computer Science Department Rutgers University  
Date: April 1993  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Morris, W. </author> <title> The American Heritage Dictionary of the English Language. </title> <publisher> Houghton Mifflin Company, </publisher> <year> 1981. </year>
Reference-contexts: Many other unsafe features would be subject to control under the planned LGA/C++ interface. 4.2. Token-based Regularities Many useful structures and control mechanisms can be based on the notion of a token -- an item that, by its dictionary definition <ref> [1] </ref>, "tangibly signifies authority and authenticity". One example is the mutual exclusion protocol discussed in the introduction, where the movable but unique token T represents the exclusive authority to perform operation O.
Reference: [2] <author> Brooks, Frederick P. Jr. </author> <title> No Silver Bullet -- the Essence and Accidents of Software Engineering. </title> <journal> IEEEComputer :10-19, </journal> <month> April, </month> <year> 1987. </year>
Reference-contexts: 1. Introduction In his classic paper "No Silver Bullet" <ref> [2] </ref>, Brooks cites complexity as a major reason for the great difficulties we have with large software systems, arguing that "software entities are more complex for their size than perhaps any other human construct", and that their "complexity is an inherent and irreducible property of software systems" [emphasis mine].
Reference: [3] <author> Cardelli, L. Dinahue, J. Glassman, L. Jordan, M. Kalsow, B. and Nelson, G. </author> <type> Modula-3 Report (revised). Technical Report 52, </type> <institution> Digital System Research Center, </institution> <month> November, </month> <year> 1989. </year>
Reference-contexts: Note that the special hardware that supports confinement in operating systems is not available for use inside user-programs outside the kernel. One of the few languages that does allow for some regulation over its unsafe features is Modula-3 <ref> [3] </ref>. This language explicitly characterizes certain of its primitive features as unsafe, allowing them to be used only inside modules that are explicitly declared to be "unsafe". This is a step in the right direction, but it does not go far enough.
Reference: [4] <author> Clocksin, W.F. and Mellish, C.S. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Currently, Darwin has interfaces for two, very different, languages: an interface called LGA/Prolog, for the logic-programming language Prolog <ref> [4] </ref>; and an interface called LGA/Eiffel for the object-oriented language Eiffel [8]; and an interface for C++ is being planned. A language-interface, for a given language, performs two functions.
Reference: [5] <author> Denning, P.J. </author> <title> Fault tolerant operating systems. </title> <journal> Computing Surveys 8(4) </journal> <pages> 359-389, </pages> <month> December, </month> <year> 1976. </year>
Reference-contexts: One example is the mutual exclusion protocol discussed in the introduction, where the movable but unique token T represents the exclusive authority to perform operation O. Another example is the well known capability-based access control mechanism <ref> [5] </ref>, under which operations on objects are authorized by tokens called "capabilities". There are also many real-life processes which are regulated by tokens. <p> While some specific token-based regularities have been built into certain computational platforms (like operating system <ref> [5] </ref>), and into some programming languages [24], none of them provides the means for establishing a broad 13 spectrum of such regularities, of the kind described below.
Reference: [6] <author> Harrison, M. A., Ruzzo, W. L. and Ullman, J. D. </author> <title> Protection in operating systems. </title> <journal> Communications of the ACM 19(8) </journal> <pages> 461-471, </pages> <month> Aug., </month> <year> 1976. </year>
Reference-contexts: The controlled means provided for the creation of tokens, and for their distribution. For example, the ability to move a token from one object to another may be conditioned on the availability of certain other tokens, as proposed in <ref> [6, 9] </ref>. Also, tokens may be allowed to be copied, or just be moved from one place to another. Several examples of laws that impose various types of token-based regularities under LGA are discussed in [13] and in [16]. 4.3.
Reference: [7] <author> Keith Marzullo and Mark D. Wood. </author> <title> Tools for Monitoring and Controlling Distributed Applications. </title> <type> Technical Report TR91-1187, </type> <institution> Cornell University Department of Computer Science, </institution> <month> February, </month> <year> 1991. </year>
Reference-contexts: He built a mechanism that imposes a specified layered module-interconnection structure on a given system, which bears some similarity to our example-law discussed in this section. The Meta system of Marzullo and Wood <ref> [7] </ref> has a global set of "policy rules" about the 10 interaction between nodes in a distributed system.
Reference: [8] <author> Meyer, B. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Currently, Darwin has interfaces for two, very different, languages: an interface called LGA/Prolog, for the logic-programming language Prolog [4]; and an interface called LGA/Eiffel for the object-oriented language Eiffel <ref> [8] </ref>; and an interface for C++ is being planned. A language-interface, for a given language, performs two functions. First, it maps the abstract concepts of this architecture, such as object and interaction between objects, to certain concrete constructs of the language at hand.
Reference: [9] <author> Minsky, </author> <title> N.H. Selective and Locally Controlled Transport of Privileges. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS) 6(4) </journal> <pages> 573-602, </pages> <month> October, </month> <year> 1984. </year>
Reference-contexts: The controlled means provided for the creation of tokens, and for their distribution. For example, the ability to move a token from one object to another may be conditioned on the availability of certain other tokens, as proposed in <ref> [6, 9] </ref>. Also, tokens may be allowed to be copied, or just be moved from one place to another. Several examples of laws that impose various types of token-based regularities under LGA are discussed in [13] and in [16]. 4.3.
Reference: [10] <author> Minsky, N.H. and Rozenshtein, D. </author> <title> Law-Based Approach to Object-Oriented Programming. </title> <booktitle> In Proceedings of the OOPSLA'87 Conference, </booktitle> <pages> pages 482-493. </pages> <month> October, </month> <year> 1987. </year>
Reference-contexts: Many such regimes can be effectively established by law under LGA, and several of them have been experimentally implemented under Darwin. 14 4.4. Regularities in Object-Oriented Systems In a series of previous papers <ref> [10, 22, 11, 12] </ref> we have shown that most of the fundamental structures of object-oriented programming, including inheritance and delegation, and many variations of these structures, are regularities that can be established under LGA by means of explicit laws.
Reference: [11] <author> Rozenshtein, D. and Minsky, </author> <title> N.H. Law-Governed Object-Oriented System. </title> <journal> Journal of Object-Oriented Programming 1(6) </journal> <pages> 14-29, </pages> <address> March/April, </address> <year> 1989. </year>
Reference-contexts: Many such regimes can be effectively established by law under LGA, and several of them have been experimentally implemented under Darwin. 14 4.4. Regularities in Object-Oriented Systems In a series of previous papers <ref> [10, 22, 11, 12] </ref> we have shown that most of the fundamental structures of object-oriented programming, including inheritance and delegation, and many variations of these structures, are regularities that can be established under LGA by means of explicit laws.
Reference: [12] <author> Minsky, N.H. and Rozenshtein, D. </author> <title> Controllable Delegation: An Exercise in Law-Governed Systems. </title> <booktitle> In Proceedings of the OOPSLA'89 Conference, </booktitle> <pages> pages 371-380. </pages> <month> October, </month> <year> 1989. </year>
Reference-contexts: Many such regimes can be effectively established by law under LGA, and several of them have been experimentally implemented under Darwin. 14 4.4. Regularities in Object-Oriented Systems In a series of previous papers <ref> [10, 22, 11, 12] </ref> we have shown that most of the fundamental structures of object-oriented programming, including inheritance and delegation, and many variations of these structures, are regularities that can be established under LGA by means of explicit laws.
Reference: [13] <author> Minsky, </author> <title> N.H. The Imposition of Protocols Over Open Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering , February, </journal> <year> 1991. </year> <month> 17 </month>
Reference-contexts: We will explore here an approach to regularities which greatly simplifies their implementation, making them more easily employable for taming of the complexities of large systems. This approach, which is based on the concept of law-governed architecture (LGA) <ref> [13, 14] </ref>, outlined in Section 3, provides system designers and builders with the means for establishing regularities simply by declaring them formally and explicitly as the law of the system. Once such a law-governed regularity is declared, it is enforced by the environment in which the system is developed. <p> Also, tokens may be allowed to be copied, or just be moved from one place to another. Several examples of laws that impose various types of token-based regularities under LGA are discussed in <ref> [13] </ref> and in [16]. 4.3. Monitoring There are many situations in which one would like to monitor a certain kind of messages by notifying a given object (the "monitor") of their occurrence.
Reference: [14] <author> Minsky, </author> <title> N.H. Law-Governed Systems. </title> <journal> The IEE Software Engineering Journal , September, </journal> <note> 1991. (This is a revision of a similarly entitled 1987 technical report). </note>
Reference-contexts: We will explore here an approach to regularities which greatly simplifies their implementation, making them more easily employable for taming of the complexities of large systems. This approach, which is based on the concept of law-governed architecture (LGA) <ref> [13, 14] </ref>, outlined in Section 3, provides system designers and builders with the means for establishing regularities simply by declaring them formally and explicitly as the law of the system. Once such a law-governed regularity is declared, it is enforced by the environment in which the system is developed. <p> We will consider here an informal example of such an initial law, designed to support the development of layered systems. (For a formal expression of a similar law, see <ref> [14] </ref>. 3.1. A Law of Layered Systems -- an Example The example-law presented here partitions the modules of the system, developed under a project P governed by it, into groups called "layers". <p> This law is presented here, mostly informally, as consisting of four rules (enclosed in boxes) 3 To be precise, this overview is of Darwin/2 [15], which is a major revision of the Darwin/1 environment described in <ref> [14] </ref>. 7 that govern four distinct aspects of the project under its jurisdiction. Only rule r3 is specified formally, for the sake of illustration, but without detailed explanation of the formalism itself, which is described in [16].
Reference: [15] <author> Minsky, N.H. and Rozenshtein, D. </author> <title> Specifications of the Darwin/2 Environment. </title> <type> Technical Report, </type> <institution> Rutgers University, LCSR, </institution> <year> 1991. </year>
Reference-contexts: This law is presented here, mostly informally, as consisting of four rules (enclosed in boxes) 3 To be precise, this overview is of Darwin/2 <ref> [15] </ref>, which is a major revision of the Darwin/1 environment described in [14]. 7 that govern four distinct aspects of the project under its jurisdiction. Only rule r3 is specified formally, for the sake of illustration, but without detailed explanation of the formalism itself, which is described in [16].
Reference: [16] <author> Minsky, </author> <title> N.H. Regularities in Large Systems. </title> <type> Technical Report, </type> <institution> Rutgers University, LCSR, </institution> <year> 1993. </year> <note> (In preparation). </note>
Reference-contexts: Only rule r3 is specified formally, for the sake of illustration, but without detailed explanation of the formalism itself, which is described in <ref> [16] </ref>. <p> Also, tokens may be allowed to be copied, or just be moved from one place to another. Several examples of laws that impose various types of token-based regularities under LGA are discussed in [13] and in <ref> [16] </ref>. 4.3. Monitoring There are many situations in which one would like to monitor a certain kind of messages by notifying a given object (the "monitor") of their occurrence.
Reference: [17] <author> Minsky, N.H. and Pal, P. </author> <title> Imposing Regularities over Object-Oriented Systems. </title> <type> Technical Report, </type> <institution> Rutgers University, LCSR, </institution> <year> 1993. </year> <note> (In preparation). </note>
Reference-contexts: Also, one may want to establish the permissible relationships between a parent and its heirs, e.g., which aspects of the parent can be visible to, redefined by, or renamed by which of its heirs. For farther discussion of such regularities, and their motivation, the reader is referred to <ref> [17] </ref>, which is based on our work with the LGA/Eiffel interface. In the following sub-section we present a detailed example that motivates some of these, and some other regularities in OO-systems. 4.4.1.
Reference: [18] <author> Ossher, H.L. </author> <title> Grids: A New Program Structuring Mechanism Based on Layered Graphs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 11-22. </pages> <month> January, </month> <year> 1984. </year>
Reference-contexts: The following are the main such efforts known to the author: Perhaps the earliest attempt to provide an explicit global law for general software systems (not for some specific kind of systems, like databases) was by Ossher <ref> [18, 19] </ref>. He built a mechanism that imposes a specified layered module-interconnection structure on a given system, which bears some similarity to our example-law discussed in this section.
Reference: [19] <author> Harold L. </author> <note> Ossher. </note>
Reference-contexts: This regularity, frequently employed for large systems, provides a useful framework within which a system can be constructed, managed and understood <ref> [19] </ref>. A single system may have many different regularities, each with its own specific role to play. <p> The following are the main such efforts known to the author: Perhaps the earliest attempt to provide an explicit global law for general software systems (not for some specific kind of systems, like databases) was by Ossher <ref> [18, 19] </ref>. He built a mechanism that imposes a specified layered module-interconnection structure on a given system, which bears some similarity to our example-law discussed in this section.
References-found: 19

