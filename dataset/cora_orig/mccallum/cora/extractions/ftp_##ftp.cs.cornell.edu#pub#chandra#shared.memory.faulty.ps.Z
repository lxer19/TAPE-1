URL: ftp://ftp.cs.cornell.edu/pub/chandra/shared.memory.faulty.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/FaultySharedMemory.html
Root-URL: 
Email: samg@cs.cornell.edu  
Title: Fault-tolerant Wait-free Shared Objects  
Author: Prasad Jayanti Tushar Deepak Chandra Sam Toueg fprasad, chandra, 
Note: A preliminary version of this will appear in the proceedings of the 33rd Annual Symposium on Founda tions of Computer Science,  Research supported by NSF grants CCR-8901780 and CCR-9102231, DARPA/NASA Ames grant NAG 2-593, grants from the IBM Endicott Programming Laboratory. Also supported by an IBM graduate fellowship.  
Date: August 21, 1992  October, 1992.  
Address: Ithaca, New York 14853  
Affiliation: Department of Computer Science Cornell University  
Abstract: A concurrent system consists of processes and shared objects. Previous research focused on the problem of tolerating process failures. We study the complementary problem of tolerating object failures. We divide object failures into two broad classes: responsive and non-responsive. With responsive failures, a faulty object responds to every invocation, but responses may be incorrect. With non-responsive failures, a faulty object may also "hang" without responding. For each class, we consider crash, omission, and arbitrary types of failures. For each type of failure, we are seeking a universal implementation for fault-tolerant wait-free shared objects. We present (deterministic) implementations for all types of responsive failures, including arbitrary failures. In contrast, we show that even the most benign type of non-responsive failures requires the use of randomization. Of special interest is the problem of implementing fault-tolerant objects using only objects of the same type. We present such fault-tolerant self-implementations for many common object types. Graceful degradation is a desirable property of fault-tolerant implementations: the implemented object never fails more severely than the base objects it is derived from, even if all the base objects fail. For several failure models, we show whether this property can be achieved, and, if so, how. In addition to the above possibility/impossibility results, we also consider the resource complexity of fault-tolerant implementations. In many cases, we present lower bounds and give matching algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [AGMT92] <author> Y. Afek, D. Greenberg, M. Merritt, and G. Taubenfeld. </author> <title> Computing with faulty shared memory. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 47-58, </pages> <month> August </month> <year> 1992. </year> <note> A draft of a more complete version of this paper dated Aug 7, 1992 was also privately sent to us. </note>
Reference-contexts: A preliminary version appeared in [JCT92a], and a summary of the results in [JCT92b]. An independent work by Afek, Greenberg, Merritt, and Taubenfeld <ref> [AGMT92] </ref> has the same general goal, but differs in many respects. We present a brief comparison of the two works in Section 8. 1.2 Object failures We divide object failures into two broad classes: responsive and non-responsive. <p> In Section 7, we study graceful degradation for the R-crash and R-omission failure models. We present impossibility results for R-crash and a universality result for R-omission. In Section 8, we present a brief comparison with the results in <ref> [AGMT92] </ref>. In Appendix D, we define the object types that appear in this paper. 2 Informal model A concurrent system consists of processes and shared objects. Associated with each object is a type. The type characterizes the expected behavior of the object. <p> Theorem 7.4 Every N -process object type has a t-tolerant gracefully degrading implementation from any N -universal list of object types for R-omission. 8 Related work In an independent work, Afek et al. consider the problem of coping with shared memory subject to memory failures <ref> [AGMT92] </ref>. Informally, each failure is modeled as a faulty write. The following failure models are considered: 40 A. There is a bound m on the total number of faulty writes. B. <p> A different model is obtained for k = 1. In our terminology, these models are responsive. The second one, with k = 1, corresponds to our R-arbitrary failure model. <ref> [AGMT92] </ref> focuses on fault-tolerant implementations of the following types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). [AGMT92] also gives a universal fault-tolerant implementation from unbounded RMW, based on <p> one, with k = 1, corresponds to our R-arbitrary failure model. <ref> [AGMT92] </ref> focuses on fault-tolerant implementations of the following types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). [AGMT92] also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure model. 2. <p> types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). <ref> [AGMT92] </ref> also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure model. 2. Amongst the responsive failure models, benign ones, such as R-crash and R-omission, are also not considered in [AGMT92]. 3. <p> -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). <ref> [AGMT92] </ref> also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure model. 2. Amongst the responsive failure models, benign ones, such as R-crash and R-omission, are also not considered in [AGMT92]. 3. This paper does not consider models that bound the number of times faulty objects can fail (in [AGMT92] each "faulty write" is counted <p> The main differences between <ref> [AGMT92] </ref> and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure model. 2. Amongst the responsive failure models, benign ones, such as R-crash and R-omission, are also not considered in [AGMT92]. 3. This paper does not consider models that bound the number of times faulty objects can fail (in [AGMT92] each "faulty write" is counted as a failure). 4. The two approaches to modeling failures are fundamentally different. <p> paper are as follows: 1. <ref> [AGMT92] </ref> does not consider any non-responsive failure model. 2. Amongst the responsive failure models, benign ones, such as R-crash and R-omission, are also not considered in [AGMT92]. 3. This paper does not consider models that bound the number of times faulty objects can fail (in [AGMT92] each "faulty write" is counted as a failure). 4. The two approaches to modeling failures are fundamentally different. There is no direct way to model benign failures, such as R-crash and R-omission failures, with "faulty writes". <p> This paper introduces the concept of graceful degradation, and presents several related results, in particular, for R-crash and R-omission failure models. For R-arbitrary failures, graceful degradation reduces to the "strong wait-freedom" concept considered in <ref> [AGMT92] </ref>. 6. The concept of fault-tolerant self-implementation, is a central theme of this paper. Corollary 5.1 states sufficient conditions for their existence, and Corollary 5.2 lists several types that have such implementations. In the Open Problems section of [AGMT92] it is stated: "It would be particularly interesting to implement memory-fault tolerant <p> R-arbitrary failures, graceful degradation reduces to the "strong wait-freedom" concept considered in <ref> [AGMT92] </ref>. 6. The concept of fault-tolerant self-implementation, is a central theme of this paper. Corollary 5.1 states sufficient conditions for their existence, and Corollary 5.2 lists several types that have such implementations. In the Open Problems section of [AGMT92] it is stated: "It would be particularly interesting to implement memory-fault tolerant data objects directly from similar, faulty objects, such as test-and-set from test-and-set, without using atomic registers, or read-modify-write from read modify-write, without using an unbounded universal construction." It is interesting to note that both of these types do <p> For bounded RMW, this is a direct consequence of Corollary 5.1. For N -process test&set, one can combine the fault-tolerant implementation of test&set from test&set and 41 bounded register <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set [Jay93]. 7. The existence of a fault-tolerant self-implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from test&set and bounded register shown in [AGMT92], does not follow from <p> For N -process test&set, one can combine the fault-tolerant implementation of test&set from test&set and 41 bounded register <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set [Jay93]. 7. The existence of a fault-tolerant self-implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from test&set and bounded register shown in [AGMT92], does not follow from our results (when N &gt; 2). Acknowledgement We thank Vassos Hadzilacos for many interesting discussions. His detailed comments on an earlier version helped improve the presentation. <p> and 41 bounded register <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set [Jay93]. 7. The existence of a fault-tolerant self-implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from test&set and bounded register shown in [AGMT92], does not follow from our results (when N &gt; 2). Acknowledgement We thank Vassos Hadzilacos for many interesting discussions. His detailed comments on an earlier version helped improve the presentation.
Reference: [Asp90] <author> J. Aspnes. </author> <title> Time and space efficient randomized consensus. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1990. </year>
Reference-contexts: In contrast, we show that register has a t-tolerant self -implementation even for arbitrary failures. Since randomized implementations of consensus from register are well known (for example, see <ref> [Asp90] </ref>), the above result implies that every object type has a randomized t-tolerant implementation from register even for arbitrary failures. In addition to these universality and impossibility results, this paper contains the following results. Consider a t-tolerant implementation for failure model M. <p> It is easy to verify that the above scheme implements a safe register that is correct even if at most t base registers experience arbitrary failures. 2 Randomized implementations of N-consensus from register are well known (for example, see <ref> [Asp90] </ref>). Together with Theorem 6.3, this implies that randomized t-tolerant implementations of N-consensus from register exist for arbitrary failures.
Reference: [CHP71] <author> P.J. Courtois, F. Heymans, and D.L. Parnas. </author> <title> Concurrent control with readers and writers. </title> <journal> Communications of the ACM, </journal> <volume> 14(10) </volume> <pages> 667-668, </pages> <year> 1971. </year>
Reference-contexts: Even though different processes may concurrently access a shared object, the object must behave as if all these accesses occur in some sequential order. More precisely, the behavior of a shared object must be linearizable [HW90]. One way to ensure linearizability is to implement shared objects using critical sections <ref> [CHP71] </ref>. This approach, however, is not fault-tolerant: The crash of a process while in the critical section of a shared object can permanently prevent the rest of the processes from accessing that object. This lack of fault-tolerance led to the concept of wait-free implementations of shared objects.
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> JACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <year> 1985. </year>
Reference-contexts: failures requires at least 2t + 1 base 3 The impossibility of implementing a fault-tolerant consensus object from any finite list of base objects, one of which may crash, is shown using the impossibility of solving the consensus problem among a finite number of processes, one of which may crash <ref> [FLP85, LAA87] </ref>. 4 objects (this lower bound holds for every deterministic non-trivial type). In some cases, graceful degradation cannot be even achieved. In particular, we show that there is a large class of object types that have no gracefully degrading implementations for R-crash. <p> However, randomization circumvents this impossibility result. Every object type has a t-tolerant randomized implementation from register, even for arbitrary failures. The impossibility results of this section are proved by reducing the consensus problem <ref> [FLP85] </ref> to the problem in question. The consensus problem for a system of N processes is defined as follows. Each process p i has an initial binary input v i . <p> We arrive at a contradiction after a series of claims involving bivalency arguments <ref> [FLP85] </ref> and indistinguishable scenarios. Let O = I (O 1 ; O 2 ; : : : ; O n ), and op; op 0 ; S; u; v; u 0 ; v 0 be as given in the definition of an order-sensitive type.
Reference: [Her91] <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM TOPLAS, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <year> 1991. </year>
Reference-contexts: Thus in a self-implementation fault-tolerance is achieved through replication. 1.4 Results To study whether a general object type has a t-tolerant implementation, we focus on two particular object types: consensus 2 and register. Herlihy <ref> [Her91] </ref> and Plotkin [Plo89] showed that one can implement a wait-free object of any type (for which a sequential implementation exists) using only consensus and register objects. <p> For R-arbitrary failures, our self-implementation is efficient requiring O (t log t) base consensus objects. We also give t-tolerant self-implementations of register for R-crash, R-omission, and R-arbitrary failures. Combining the above results with <ref> [Her91, Plo89] </ref>, we conclude that every object type T has a t-tolerant implementation (from consensus and register) for all responsive models of failures. Moreover, if T implements consensus and register, then T has a t-tolerant self -implementation. <p> Furthermore, a process may crash: i.e., a process may stop at an arbitrary point in an execution and never take any steps thereafter. The concept of wait-freedom was introduced to cope with such processes (for example, see <ref> [Her91] </ref>). An object O is wait-free 6 in an execution E if either (i) E is finite, or (ii) every operation on O invoked by a process that does not crash in E gets a response from O. <p> In Section 5.1.4, we illustrate how this corollary can be applied to construct a t-tolerant self-implementation of consensus for R-arbitrary failures. 5 Tolerating responsive failures Herlihy <ref> [Her91] </ref> and Plotkin [Plo89] showed that one can implement a (wait-free) object of any type using only consensus and register objects. Therefore, if consensus and register have t-tolerant implementations, then every object type has a t-tolerant implementation. <p> The reset operation re-initializes the object so that it may be used for a fresh round of consensus (see Appendix D for a formal specification of this type). Herlihy showed that every finite object type 10 has an implementation from (N-consensus with reset, unbounded register) 11 <ref> [Her91] </ref>. The use of unbounded registers can be replaced by boolean registers [Plo89, JT92]. Using this result, together with Theorems 5.7 and 5.8, we obtain the following corollary. <p> Thus, Corollary 5.1 holds even for an infinite object type T , provided that boolean register is replaced by unbounded register in the statement of the corollary. The types fetch&add, queue, stack, test&set implement 2-consensus, and compare&swap, move, swap implement N-consensus <ref> [Her91] </ref>. It is easy to show that compare&swap, move, swap, test&set implement boolean register, and fetch&add, queue, stack implement unbounded register. Furthermore, all these implementations are gracefully degrading for R-arbitrary failures. <p> From <ref> [Her91] </ref> and this corollary, we conclude that compare&swap, fetch&add, move, queue, stack, sticky-bit, swap, test&set, and several other common types do not have a 1-tolerant implementation for crash or 1-unfairness to a known process. <p> Together with Theorem 6.3, this implies that randomized t-tolerant implementations of N-consensus from register exist for arbitrary failures. Combining this with Theorem 6.3 and the universality results of <ref> [Her91, Plo89] </ref>, we have Theorem 6.4 Every finite object type has a randomized t-tolerant implementation from boolean register for arbitrary failures, and every infinite object type has a randomized t-tolerant implementation from unbounded register for arbitrary failures. <p> In contrast, N-consensus has such an implementation for R-omission (Theorem 5.2 in Section 5). Further, we can show Theorem 7.3 register has a t-tolerant gracefully degrading self-implementation for R-omission. Theorems 5.2 and 7.3 can be combined with the universal constructions in <ref> [Her91, JT92] </ref> to obtain the following result for R-omission. A list L of object types is N -universal if every N -process object type has an implementation from L. An example of a N -universal list is (N-consensus with reset, register).
Reference: [HW90] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM TOPLAS, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: Even though different processes may concurrently access a shared object, the object must behave as if all these accesses occur in some sequential order. More precisely, the behavior of a shared object must be linearizable <ref> [HW90] </ref>. One way to ensure linearizability is to implement shared objects using critical sections [CHP71]. This approach, however, is not fault-tolerant: The crash of a process while in the critical section of a shared object can permanently prevent the rest of the processes from accessing that object. <p> The response for an operation is the value returned by the procedure. The sequential specification of an object O, given by its type, is not sufficient to predict O's behavior in the presence of concurrent operations. To characterize such behavior, we use the concept of linearizability <ref> [HW90, Lam86] </ref>. Roughly speaking, linearizability requires every operation execution to appear to take effect instantaneously at some point in time between its invocation and response. We make it more precise below.
Reference: [Jay93] <author> P. Jayanti. </author> <title> Fault-Tolerant Wait-Free Shared Objects. </title> <type> PhD thesis, </type> <institution> Cornell University, 1993. Dept. of Computer Science, Cornell University, Ithaca, </institution> <note> NY 14853 (In preparation). </note>
Reference-contexts: For bounded RMW, this is a direct consequence of Corollary 5.1. For N -process test&set, one can combine the fault-tolerant implementation of test&set from test&set and 41 bounded register [AGMT92], with the implementation of bounded register from test&set <ref> [Jay93] </ref>. 7. The existence of a fault-tolerant self-implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from test&set and bounded register shown in [AGMT92], does not follow from our results (when N &gt; 2).
Reference: [JCT92a] <author> P. Jayanti, T. D. Chandra, and S. Toueg. </author> <title> Fault-tolerant wait-free shared objects. </title> <type> Technical Report TR 92-1281, </type> <institution> Cornell University, Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY 14853, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: With such objects, the system is guaranteed to make progress despite process crashes and the failures of some underlying objects. (To simplify notation, hereafter "object" denotes a "shared object".) The problem addressed in this paper is novel. A preliminary version appeared in <ref> [JCT92a] </ref>, and a summary of the results in [JCT92b]. An independent work by Afek, Greenberg, Merritt, and Taubenfeld [AGMT92] has the same general goal, but differs in many respects.
Reference: [JCT92b] <author> P. Jayanti, T. D. Chandra, and S. Toueg. </author> <title> Fault-tolerant wait-free shared objects. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1992. </year> <month> 42 </month>
Reference-contexts: A preliminary version appeared in [JCT92a], and a summary of the results in <ref> [JCT92b] </ref>. An independent work by Afek, Greenberg, Merritt, and Taubenfeld [AGMT92] has the same general goal, but differs in many respects. We present a brief comparison of the two works in Section 8. 1.2 Object failures We divide object failures into two broad classes: responsive and non-responsive.
Reference: [JT92] <author> P. Jayanti and S. Toueg. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <booktitle> In Proceedings of the 6th Workshop on Distributed Algorithms, </booktitle> <address> Haifa, Israel, </address> <month> November </month> <year> 1992. </year> <note> (To appear in Lecture Notes in Computer Science, Springer-Verlag). </note>
Reference-contexts: Herlihy showed that every finite object type 10 has an implementation from (N-consensus with reset, unbounded register) 11 [Her91]. The use of unbounded registers can be replaced by boolean registers <ref> [Plo89, JT92] </ref>. Using this result, together with Theorems 5.7 and 5.8, we obtain the following corollary. <p> In contrast, N-consensus has such an implementation for R-omission (Theorem 5.2 in Section 5). Further, we can show Theorem 7.3 register has a t-tolerant gracefully degrading self-implementation for R-omission. Theorems 5.2 and 7.3 can be combined with the universal constructions in <ref> [Her91, JT92] </ref> to obtain the following result for R-omission. A list L of object types is N -universal if every N -process object type has an implementation from L. An example of a N -universal list is (N-consensus with reset, register).
Reference: [LAA87] <author> M.C. Loui and Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <booktitle> Advances in computing research, </booktitle> <volume> 4 </volume> <pages> 163-183, </pages> <year> 1987. </year>
Reference-contexts: failures requires at least 2t + 1 base 3 The impossibility of implementing a fault-tolerant consensus object from any finite list of base objects, one of which may crash, is shown using the impossibility of solving the consensus problem among a finite number of processes, one of which may crash <ref> [FLP85, LAA87] </ref>. 4 objects (this lower bound holds for every deterministic non-trivial type). In some cases, graceful degradation cannot be even achieved. In particular, we show that there is a large class of object types that have no gracefully degrading implementations for R-crash. <p> Since all correct processes periodically check the decision register, they eventually decide v. We showed that we can use I to solve the consensus problem in system S, and this contradicts the impossibility result of Louis and Abu-Amara <ref> [LAA87] </ref>. 2 We can strengthen the above result as follows. Suppose that at most one base object may fail, and it can only do so by being "unfair" (i.e., by not responding) to at most one process. <p> The rest of the proof is as in Theorem 6.1. Again, we have a contradiction to the impossibility result in <ref> [LAA87] </ref>. 2 From the above two theorems we have: 13 Of course, it also continues to read the decision register periodically, and decides if a non? value is found there. 31 Corollary 6.1 If type T implements 2-consensus, then there is no 1-tolerant implemen-tation of T for crash or for 1-unfairness
Reference: [Lam86] <author> L. Lamport. </author> <title> On interprocess communication, parts i and ii. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 77-101, </pages> <year> 1986. </year>
Reference-contexts: The response for an operation is the value returned by the procedure. The sequential specification of an object O, given by its type, is not sufficient to predict O's behavior in the presence of concurrent operations. To characterize such behavior, we use the concept of linearizability <ref> [HW90, Lam86] </ref>. Roughly speaking, linearizability requires every operation execution to appear to take effect instantaneously at some point in time between its invocation and response. We make it more precise below. <p> Thus, by Proposition 5.1, O is correct in E. This completes the proof of Theorem 5.7. 2 5.2 Fault-tolerant implementation of register The register type supports two operations, read and write v. The sequential specification is simple: read returns the value most recently written. In <ref> [Lam86] </ref>, Lamport defined three types of registers: safe, regular, and atomic. Atomic register corresponds to register in our terminology. A safe register is not linearizable, but it satisfies the following: a read operation that does not overlap with a write, returns the latest value written into the register.
Reference: [LT88] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT, MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference: [NT90] <author> G. Neiger and S. Toueg. </author> <title> Automatically increasing the fault-tolerance of distributed algorithms. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 374-419, </pages> <year> 1990. </year>
Reference-contexts: In other words, with R-crash, implementations necessarily amplify failures. In contrast, we prove the following strong possibility result for R-omission: Every object type has a t-tolerant gracefully degrading implementation from consensus and register for R-omission. We study the problem of translating severe failures into more benign failures <ref> [NT90] </ref>. In particular we show that given 3t + 1 (base) consensus objects, at most t of which may experience R-arbitrary failures, we can implement a consensus object that can only fail by R-omission. We prove that this translation from R-arbitrary to R-omission is resource optimal.
Reference: [Plo89] <author> S. Plotkin. </author> <title> Sticky bits and universality of consensus. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 159-175, </pages> <month> August </month> <year> 1989. </year> <month> 43 </month>
Reference-contexts: Thus in a self-implementation fault-tolerance is achieved through replication. 1.4 Results To study whether a general object type has a t-tolerant implementation, we focus on two particular object types: consensus 2 and register. Herlihy [Her91] and Plotkin <ref> [Plo89] </ref> showed that one can implement a wait-free object of any type (for which a sequential implementation exists) using only consensus and register objects. <p> For R-arbitrary failures, our self-implementation is efficient requiring O (t log t) base consensus objects. We also give t-tolerant self-implementations of register for R-crash, R-omission, and R-arbitrary failures. Combining the above results with <ref> [Her91, Plo89] </ref>, we conclude that every object type T has a t-tolerant implementation (from consensus and register) for all responsive models of failures. Moreover, if T implements consensus and register, then T has a t-tolerant self -implementation. <p> In Section 5.1.4, we illustrate how this corollary can be applied to construct a t-tolerant self-implementation of consensus for R-arbitrary failures. 5 Tolerating responsive failures Herlihy [Her91] and Plotkin <ref> [Plo89] </ref> showed that one can implement a (wait-free) object of any type using only consensus and register objects. Therefore, if consensus and register have t-tolerant implementations, then every object type has a t-tolerant implementation. <p> Herlihy showed that every finite object type 10 has an implementation from (N-consensus with reset, unbounded register) 11 [Her91]. The use of unbounded registers can be replaced by boolean registers <ref> [Plo89, JT92] </ref>. Using this result, together with Theorems 5.7 and 5.8, we obtain the following corollary. <p> Together with Theorem 6.3, this implies that randomized t-tolerant implementations of N-consensus from register exist for arbitrary failures. Combining this with Theorem 6.3 and the universality results of <ref> [Her91, Plo89] </ref>, we have Theorem 6.4 Every finite object type has a randomized t-tolerant implementation from boolean register for arbitrary failures, and every infinite object type has a randomized t-tolerant implementation from unbounded register for arbitrary failures. <p> For R-crash, the above theorem shows that this property is often not achievable: implementations necessarily amplify the R-crash failures of base objects. For example, consider a system that supports registers and sticky-bits in "hardware". In such a system, any object can be implemented <ref> [Plo89] </ref>, including (for example) queues. Suppose we are given the following guarantee: if any of the given registers or sticky bits fail, they fail only by R-crash. Can we implement a queue that cannot fail more severely than R-crash? The above theorem shows that this cannot be done.
References-found: 15

