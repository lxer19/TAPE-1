URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-067.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Email: Email: levan@imiucca.csi.unimi.it  
Phone: Phone: +39-2-55006-356, Fax: +39-2-55006-253,  
Title: A Software Reuse System for C Codes  
Author: Le van Huu 
Address: Milano, Via Comelico, 39, I-20135 Milano, Italy,  
Affiliation: Dipartimento di Scienze dell'Informazione, Universita' degli Studi di  
Date: December 2, 1993  
Abstract: This paper presents PRASSY, a hypertext system for the storage and retrieval of procedure source codes, on the basis of the semantics of their comments. The objective of the system is to provide the program developer with the possibility of retrieving and reusing the source code of C subroutines that have been previously built by his colleagues or that are already present in the system. The approach adopted by PRASSY is the analysis of the source code comments and of the specification documents written in natural language, in order to extract indexing information. Such information is organized in a hypertext structure and the browsing mechanism is used by the user to select reusable software components. The system provides a way for measuring the semantic similarity between the user requirements and the candidate node to be selected. The paper describes the system's architecture and functionalities. Some examples of the user interface and the browsing mechanisms are reported. Finally, it describes the algorithm proposed by Aragon-Ramirez and Paice and adopted by PRASSY for defining the semantic similarity among phrases expressed in natural language. KEYWORDS: hypertext, software reuse, semantic phrases similarity 
Abstract-found: 1
Intro-found: 1
Reference: [Krueger92] <author> Krueger Charles W., </author> <title> Software reuse, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol 24, N 2, </volume> <month> June </month> <year> 1992, </year> <pages> pp. 131-183. </pages>
Reference-contexts: An exhausted list of other works can be found in [Tracz90]. Krueger in <ref> [Krueger92] </ref> partitions the approaches to software reuse into eight categories: high-level languages, design and code scavenging, source code components, software schemas, application generators, very high-level languages, transformational systems, and software architectures. We shortly describe those categories that concern our work. <p> On the other hand, in the case of specific domain, e.g., in a mathematical environment, the keywords classification approach, with an informal description in natural language could be sufficient <ref> [Krueger92] </ref>. The strategy adopted by our system is the analysis of the source code comments and of the specification documents written in natural language, in order to extract indexing information.
Reference: [Prieto-Diaz89] <author> Prieto-Diaz Ruben, </author> <title> Classification of Reusable modules, in Software Reusability: Volume I-Concepts and Models, </title> <editor> Biggerstaff, T.J., and Perlis, A. J., Eds. </editor> <publisher> ACM Press, </publisher> <address> New York,1989, </address> <pages> pp. 99-123, </pages> <address> Chap. </address> <month> 4. </month>
Reference-contexts: CATALOG [Frakes87] recognizes indexes contained in C programs headers, coded in natural language; GURU [Maarek91] analyzes phrases contained in the software documentation and the source codes. Moreover, Prieto-Diaz and Freeman <ref> [Prieto-Diaz89] </ref> describe a system based on faceted schema and analyze several program descriptions and source listings to determine relevant attributes that one can use to represent programs. <p> Finally, we must answer the crucial question for any information retrieval application: how can we classify the library components? The classification schema is central to code accessibility, as asserted by Prieto-Diaz and Freeman in <ref> [Prieto-Diaz89] </ref>. For their system, they propose the use of faceted schema. Instead of classifying objects in a hierarchical way, they group the objects into different classes, in according to the syntactic or attribute-level relationships.
Reference: [Luckham84] <author> Luckham D.C., and Von Henke, F.W., </author> <title> An overview of Anna, a specification language for Ada, </title> <booktitle> in 1984 Conference on Ada Applications and Environments, </booktitle> <address> St. Paul, Minn., Oct, </address> <publisher> IEEE Computer Society Press, Los Alamitos, Cal, </publisher> <pages> pp. 116-127. </pages>
Reference-contexts: One approach considers the extension of the programming language to describe the semantic of the component to be classified. It is adopted by Anna (Annotated Ada), a collection of formal annotations for Ada statements <ref> [Luckham84] </ref>. These annotations consist of predicates that describe constraints on Ada constructs. We can find the similar idea in Sather [Omohundro93], the object-oriented-language developed by the International Computer Science Institute (Berkeley, California).
Reference: [Larsen93] <author> Larsen Henrik .L. and Yager Ronald R., </author> <title> The Use of Fuzzy Relational Thesauri for Classificatory Problem Solving in Information Retrieval and Expert Systems, </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> Vol 23, No 1, </volume> <month> Jan/Feb </month> <year> 1993, </year> <pages> pp. 31-39. </pages>
Reference-contexts: In such a graph, the leaves represent facet terms and nodes represent supertypes of terms. Every edge is qualified by a weight value, assigned by the user. Fuzzy set logic, as proposed by Larsen and Yager in <ref> [Larsen93] </ref>, is another approach. They use the fuzzy relational thesauri for representing the fuzzy implication between terms, in order to compute the strength among the query terms and document descriptors. GURU defines an indexing scheme based on lexical affinities of natural language software documentation and comments.
Reference: [Omohundro93] <author> Stephen M.Omohundro, </author> <title> The Sather 1.0 Specification. </title> <type> Technical Report, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> Ca., </address> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: It is adopted by Anna (Annotated Ada), a collection of formal annotations for Ada statements [Luckham84]. These annotations consist of predicates that describe constraints on Ada constructs. We can find the similar idea in Sather <ref> [Omohundro93] </ref>, the object-oriented-language developed by the International Computer Science Institute (Berkeley, California). It consists of the construct assert, which includes a key for a controlled program compilation and a boolean expression. If the key is specified to the compiler, then the boolean expression is evaluated.
Reference: [Katz92] <author> Katz S., Richter,C. A., and The, K., PARIS: </author> <title> A system for reusing partially interpreted schema, in Software Reusability: Volume I-Concepts and Models, </title> <editor> Biggerstaff, T.J., and Perlis, A. J., Eds. </editor> <publisher> ACM Press, </publisher> <address> New York,1989, </address> <pages> pp. 257-274, </pages> <address> Chap. </address> <month> 10. </month>
Reference-contexts: The software schema category emphasizes the reuse of abstract algorithms and data structures rather than source code. An example of this category comes from PARIS <ref> [Katz92] </ref>, a system implemented in LISP for reusing algorithms used in distributed programming. It consists of a library of partially interpreted schemas, that form a program skeleton where some parts remain abstract or undefined. The user query contains specification regarding an entity list, applicability conditions and result assertions.
Reference: [Adams93] <author> Sam Adams, Ed Seidewitz, Brad Balfour, David Wade and Brad Cox, </author> <title> Software Reuse, (Panel Session), </title> <booktitle> in Proc. OOPSLA Eighth Annual Conference, </booktitle> <address> 26 Sept-1 Oct 1993, Washington, DC, </address> <pages> pp. 137-143. </pages>
Reference-contexts: Software reuse, if well applied, could reduce the efforts of people involved in the software development process and determinate a high improvement in productivity (about 35-85 percent [Jones84]). As outlined by Adams in <ref> [Adams93] </ref>, the cost for implementing the successive release of the software after the initial delivery is around 80% of the total cost. The term software reuse, or software reusability, is generally intended as the source code adaptation and interchange between software projects.
Reference: [Bassett87] <author> Paul G. </author> <title> Bassett, </title> <journal> Framed-Based Software Engineering, IEEE Software, </journal> <volume> Vol. 4, No. 4, </volume> <month> July </month> <year> 1987, </year> <month> pp.9-16. </month>
Reference-contexts: 1 Introduction. As Bassett outlined in <ref> [Bassett87] </ref>, it is ironic that software the very engine of our high-tech, automated society is such a low-tech cottage industry. In other words, the software designers often have to reinvent existing solutions or proceed in an expensive way for resolving their problems.
Reference: [Jones84] <author> T.C. Jones, </author> <title> Reusability in Programming: A survey of the State of the Art, </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> Vol. 10, No. 5, </volume> <month> Sept. </month> <year> 1984, </year> <note> pp.499-493. 13 </note>
Reference-contexts: For this reason, for several years researchers have been paid their attention to the possibility of reusing existing software for new projects. Software reuse, if well applied, could reduce the efforts of people involved in the software development process and determinate a high improvement in productivity (about 35-85 percent <ref> [Jones84] </ref>). As outlined by Adams in [Adams93], the cost for implementing the successive release of the software after the initial delivery is around 80% of the total cost. The term software reuse, or software reusability, is generally intended as the source code adaptation and interchange between software projects.
Reference: [Redwine89] <author> Redwine Jr. S. T., W. E. Riddle, </author> <title> Software Reuse Processes, </title> <booktitle> Software En--gineering Notes, ACM SIGSOFT, </booktitle> <volume> Vol. 14, No. 4, </volume> <year> 1989, </year> <month> pp.133-135. </month>
Reference-contexts: The works for an user who intends to utilize the library content could be summarized in: selection of the candidate component, adaptation of the selected component to the new requirements, integration of the modified component to the current project <ref> [Redwine89] </ref>. Moreover, if the user believes that some of his project components can be useful to other software developers, a cataloguing work for increasing the library information is necessary.
Reference: [Kaiser87] <author> Gail E. Kaiser, David Garlan, </author> <title> Melding Software Systems from Reusable Building Blocks, </title> <journal> IEEE Software, </journal> <volume> Vol. 4, No. 4, </volume> <month> July </month> <year> 1987, </year> <month> pp.17-24. </month>
Reference-contexts: There are several proposals for supporting some or all the above activities, such as the Meld declarative language from the Columbia University and the Carnegie Mellon University <ref> [Kaiser87] </ref>, the incremental implementation model proposed by the Software Productivity Consortium [Prieto-Diaz91], and the building blocks approach for systems programming from IBM [Lenz87]. An exhausted list of other works can be found in [Tracz90].
Reference: [Prieto-Diaz91] <author> Ruben Prieto-Diaz, </author> <title> Making Software Reuse Work An Implementation Model, </title> <booktitle> ACM SIGSOFT, Software Engineering Notes, </booktitle> <volume> Vol. 16, </volume> <editor> N. </editor> <volume> 3, </volume> <month> July </month> <year> 1991, </year> <month> pp.61-68. </month>
Reference-contexts: There are several proposals for supporting some or all the above activities, such as the Meld declarative language from the Columbia University and the Carnegie Mellon University [Kaiser87], the incremental implementation model proposed by the Software Productivity Consortium <ref> [Prieto-Diaz91] </ref>, and the building blocks approach for systems programming from IBM [Lenz87]. An exhausted list of other works can be found in [Tracz90].
Reference: [Lenz87] <author> Manfred Lenz, Hans Albrecht Schmid, Peter F. Wolf, </author> <title> Software Reuse through Building Blocks, </title> <journal> IEEE Software, </journal> <volume> Vol. 4, No. 4, </volume> <month> July </month> <year> 1987, </year> <month> pp.34-42. </month>
Reference-contexts: There are several proposals for supporting some or all the above activities, such as the Meld declarative language from the Columbia University and the Carnegie Mellon University [Kaiser87], the incremental implementation model proposed by the Software Productivity Consortium [Prieto-Diaz91], and the building blocks approach for systems programming from IBM <ref> [Lenz87] </ref>. An exhausted list of other works can be found in [Tracz90]. Krueger in [Krueger92] partitions the approaches to software reuse into eight categories: high-level languages, design and code scavenging, source code components, software schemas, application generators, very high-level languages, transformational systems, and software architectures.
Reference: [Tracz90] <author> Will Tracz, </author> <title> Where Does Reuse Start, </title> <booktitle> ACM SIGSOFT, Software Engineering Notes, </booktitle> <volume> Vol. 15, </volume> <editor> N. </editor> <volume> 2, </volume> <month> Apr. </month> <year> 1990, </year> <month> pp.42-46. </month>
Reference-contexts: An exhausted list of other works can be found in <ref> [Tracz90] </ref>. Krueger in [Krueger92] partitions the approaches to software reuse into eight categories: high-level languages, design and code scavenging, source code components, software schemas, application generators, very high-level languages, transformational systems, and software architectures. We shortly describe those categories that concern our work.
Reference: [Maarek91] <author> Yoelle S. Maarek, Daniel M. Berry, Gail E. Kaiser, </author> <title> An Information Retrieval Approach for Automatically Constructing Software Libraries, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <editor> N. </editor> <volume> 8, </volume> <month> Aug. </month> <pages> 1991 pp. 800-813. </pages>
Reference-contexts: Locating useful subroutines in program source codes, on the basis of their functionality, requires an adequate reuse system. To do this, first we must choose the appropriate technique to create the data base of the reusable information. As mentioned in <ref> [Maarek91] </ref>, there are two main approaches: the information retrieval technique (IR), based on the free-text indexing and the Artificial Intelligence technique based on the knowledge on the reused components. The differences between these approaches are well outlined in the cited article. <p> CATALOG [Frakes87] recognizes indexes contained in C programs headers, coded in natural language; GURU <ref> [Maarek91] </ref> analyzes phrases contained in the software documentation and the source codes. Moreover, Prieto-Diaz and Freeman [Prieto-Diaz89] describe a system based on faceted schema and analyze several program descriptions and source listings to determine relevant attributes that one can use to represent programs. <p> Moreover, it uses the browsing mechanism of hypertext technology to search reusable software components. As asserted by Maarek et al., since there is rarely a component of software libraries perfectly matching a user's query, browsing is an adequate operation to single out elements from these libraries <ref> [Maarek91] </ref>. A prototype of PRASSY has been developed and runs on a HP9000/300 workstation with the HP/UX Operating System. This paper presents the system architecture and functionalities of PRASSY with emphasis on the browsing mechanisms. Some examples of the user interface are reported.
Reference: [Burton87] <author> B. A. Burton, R. Wienk Aragon, S.A. Bailey, K.D. Koelher and L.A. Myes, </author> <title> The usable software library, </title> <journal> IEEE Computer, </journal> <volume> Vol. 4, No. 4, </volume> <year> 1987, </year> <pages> pp. 129-137. </pages>
Reference-contexts: The strategy adopted by our system is the analysis of the source code comments and of the specification documents written in natural language, in order to extract indexing information. There are several systems based on this idea, such as RSL <ref> [Burton87] </ref> which 1 UNIX is a registered trademark of Unix Systems Laboratories. 2 X Window System is a trademark of the Massachusetts Institute of Technology. 2 catalogues the software by attributes (e.g., keywords, authors ...) extracted from comments.
Reference: [Frakes87] <author> W.B. Frakes and B.A. Nejmeh, </author> <title> Software reuse through information retrieval, </title> <booktitle> Proc. 20th Ann HICSS, </booktitle> <address> Kona, </address> <month> Jan, </month> <year> 1987, </year> <pages> pp. 530-535. </pages>
Reference-contexts: CATALOG <ref> [Frakes87] </ref> recognizes indexes contained in C programs headers, coded in natural language; GURU [Maarek91] analyzes phrases contained in the software documentation and the source codes.
Reference: [Delisle87] <author> N. M. Delisle, M. D. Schwartz, </author> <title> Contexts- A Partitioning Concept for Hypertext, </title> <journal> ACM Trans. on Office Inf. Sys., </journal> <volume> Vol. 5, </volume> <editor> N. </editor> <volume> 2, </volume> <month> April </month> <year> 1987, </year> <month> pp.168-186. </month>
Reference-contexts: These algorithms are fundamental for the construction of the hypertext and for the retrieval of procedures stored in it. 3 2 PRASSY basic elements. Much work has been done on the hypertext concept. In the area of software engineering, some systems, such as Context <ref> [Delisle87] </ref> and Neptune [Schwartz86], are proposed to support the design and documentation process of large-scale software applications. Moreover, hyperCASE [Cybulski92] is an integrated environment of CASE tools where hypertext technology is used for linking and browsing fragments of any type of information.
Reference: [Schwartz86] <author> M.D. Schwartz and N.M. Delisle, Neptune: </author> <title> A Hypertext System for CAD Applications, </title> <booktitle> Proc. Intern . Conf. on Management of Data, ACM, </booktitle> <address> Wash-ington D.C., New York 1986, pp.132 -143. </address>
Reference-contexts: These algorithms are fundamental for the construction of the hypertext and for the retrieval of procedures stored in it. 3 2 PRASSY basic elements. Much work has been done on the hypertext concept. In the area of software engineering, some systems, such as Context [Delisle87] and Neptune <ref> [Schwartz86] </ref>, are proposed to support the design and documentation process of large-scale software applications. Moreover, hyperCASE [Cybulski92] is an integrated environment of CASE tools where hypertext technology is used for linking and browsing fragments of any type of information.
Reference: [Bernstein90] <author> Mark Bernstein, </author> <title> An Apprentice That Discovers Hypertext Links, </title> <booktitle> Proc. Hypertext Conference 90: Concepts, Systems and Applications, </booktitle> <publisher> Cam-bridge University Press, </publisher> <address> Paris, </address> <month> July </month> <year> 1990, </year> <pages> pp. 213-223. </pages>
Reference-contexts: One technique is the automatic linking by interpreting structural information of the document, e.g., typographic tag elements. Another approach to define link elements is the text semantic analysis. Bern-stein mentions systems called shallow apprentices which are, as defined in <ref> [Bernstein90] </ref>, systems which discover links through superficial textual analysis without attempting to analyze meaning. Principally, the approach adopted by PRASSY to define links could be considered similar to the shallow apprentice technique.
Reference: [Paice85] <author> Paice C. D., Aragon-Ramirez V., </author> <title> The calculation of similarities between multi-word strings using a thesaurus, </title> <booktitle> Proc. </booktitle> <address> RIAO, Grenoble 1985, pp.293-319. </address>
Reference-contexts: The position of a procedure in the PRASSY hypertext depends on the meaning of its descriptor respecting to the other ones. The value of the semantic similarity between descriptor phrases is established on the basis of the algorithm proposed by Aragon-Ramirez and Paice <ref> [Paice85] </ref> (we will abbreviate the author names as "ARP"). This value is a real number R in the range [0.0-1.0]. The semantic of two multiword-phrases S and T are considered perfectly similar when their R (S,T) value is equal to 1.0.
Reference: [Salton89] <author> G. Salton, </author> <title> Automatic text processing, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: We think that in a comment, every phrase usually expresses concepts completely independent from each other. 3 Phrases analysis. Establishing the similarity between phrases in natural language is a difficult task. Salton presents several solutions in <ref> [Salton89] </ref>. As mentioned, the approach adopted by PRASSY derives from the ARP's algorithm. It establishes that the semantic proximity between two phrases depends on the degree of similarity between each word of the first phrase and the possible word of the second phrase associated with it. <p> It also attributes importance to the number of occurrences of these words in the pattern documents. The calculation uses an approach similar to the vector-space model and the Jaccard coefficient <ref> [Salton89] </ref> for normalizing the similarity values in order that they can be inclusive between 0 and 1. A similar technique is used in the GURU system.
Reference: [Brown89] <author> P.J. Brown, </author> <title> Do we need maps to navigate round hypertext documents?, </title> <journal> Electronic Publishing, </journal> <volume> Vol. 2, </volume> <editor> N. </editor> <volume> 2, </volume> <month> July </month> <year> 1989, </year> <note> pp.91-100. 14 </note>
Reference-contexts: The second phase concerns the definition and use of the hypertext (Figure 2) . To resolve the disorientation problem for the user during the browsing <ref> [Brown89] </ref>, the hypertext is designed with the following characteristics: * it corresponds to a simple graph structure (nodes represent similar procedures and links represent the semantic proximity values with neighbour nodes) * it presents information regarding the graph in the textual form * it uses different open windows for representing different
Reference: [Meyer87] <author> Bertrand Meyer, </author> <title> Reusability: The Case for Object-Oriented Design, </title> <journal> IEEE Software, </journal> <volume> Vol. 4, No. 2, </volume> <month> Mar. </month> <year> 1987, </year> <pages> pp. 50-65. </pages>
Reference-contexts: The content of the reusable block is displayed to the user in an appropriate window. It is divided in data structures section and code section. This allows a careful procedure data structure analysis. Researches carried out by Meyer <ref> [Meyer87] </ref> confirm that updating the data structure represents 80% of the work needed to adapt a reusable component to the new programmer's requirements.
Reference: [Cybulski92] <author> Cybulski, Jacob L., Reed, Karl. </author> <title> A hypertext based software engineering environment IEEE Software v9, </title> <type> n2, </type> <month> March, </month> <year> 1992, </year> <pages> pp. 62-68. 15 </pages>
Reference-contexts: Much work has been done on the hypertext concept. In the area of software engineering, some systems, such as Context [Delisle87] and Neptune [Schwartz86], are proposed to support the design and documentation process of large-scale software applications. Moreover, hyperCASE <ref> [Cybulski92] </ref> is an integrated environment of CASE tools where hypertext technology is used for linking and browsing fragments of any type of information. PRASSY is not the complete answer to support the collaboration among software engineering teams.
References-found: 25

