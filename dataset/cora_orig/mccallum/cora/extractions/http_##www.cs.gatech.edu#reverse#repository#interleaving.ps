URL: http://www.cs.gatech.edu/reverse/repository/interleaving.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Email: fspencer, kurt, lindag@cc.gatech.edu  
Title: The Interleaving Problem in Program Understanding  
Author: Spencer Rugaber, Kurt Stirewalt, and Linda M. Wills 
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing, Georgia Institute of Technology  
Abstract: One of the factors that can make a program difficult to understand is that code responsible for accomplishing more than one purpose may be woven together in a single section. We call this interleaving, and it may arise either intentionally for example, in optimizing a program, a programmer may use some intermediate result for several purposes or unintentionally, due to patches, quick fixes, or other hasty maintenance practices. To understand this phenomenon, we have looked at a variety of interleaving instances in actual programs and have distilled characteristic features. If the characterization proves to be robust then it will enable the design of tools for detection of interleav-ings and the extraction of the individual strands of computation. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V.R. Basili and H.D. Mills. </author> <title> Understanding and documenting programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 8(3) </volume> <pages> 270-283, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: The software performs calculations in the domain of solar system geometry. * A program for finding the roots of functions (ZEROIN), presented and analyzed in <ref> [1] </ref> and [22]. The goal of the paper is to characterize the interleaving problem, relating it to existing concepts in the literature, such as delocalized plans [15], coupling [29], and redistribution of intermediate results [8, 9].
Reference: [2] <author> I. Baxter. </author> <title> Design maintenance systems. </title> <journal> Comm. of the ACM, </journal> <volume> 35(4), </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: The converse of interleaving is encapsulation, where a designer intentionally delineates several distinct design elements behind some sort of barrier, such as provided by the PACKAGE mechanism in Ada. The history of the design of a program can be viewed as a network of artifacts <ref> [2] </ref> where a connection between two artifacts indicates that one of them is the refinement of the other that results from one of the kinds of design decisions listed above. In this view, interleaving is indicated by a network node with inputs from two or more other nodes.
Reference: [3] <author> T. Biggerstaff, B. Mitbander, and D. Webster. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-83, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Existing cliche recognition systems tend to deal with interleaving involving data and control mechanisms. Domain-based clustering, as explored by DM-TAO in the DESIRE system <ref> [3] </ref>, focuses on naming mechanisms, by keying in on the patterns of linguistic idioms used in the program, which suggest the manifestations of domain concepts. When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. <p> When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing [27, 17] is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [3, 11, 23, 24] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [4] <author> R. Bowdidge and W. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In Proc. 2nd ACM SIGSOFT Symp. on Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <address> New Orleans, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: These graphs show dependencies among global entities within a single module. Presumably, the independent services reflect separate plans in the code. Research into automating data encapsulation has recently provided mechanisms for hypothesizing possible locations of data plans at the object scope. For example, Bowdidge and Griswold <ref> [4] </ref> use an extended data flow graph representation, called a star diagram, to help human users see all the uses of a particular data structure and to detect frequently occurring computations that are good candidates for abstract functions.
Reference: [5] <author> F. Calliss and B. Cornelius. </author> <title> Potpourri module detection. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1990, </booktitle> <pages> pages 46-51, </pages> <address> San Diego, CA, November 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components. Another technique, called "potpourri module detection" <ref> [5] </ref>, detects modules that provide more than one independent service by looking for multiple proper subgraphs in an entity-to-entity interconnection graph. 3 Recognition as a program understanding technique deals with cliches, not plans in general. Only cliched plans can be recognized, since recognition implies noticing something that is familiar.
Reference: [6] <author> G. Canfora, A. Cimitile, and M. Munro. </author> <title> A reverse engineering method for identifying reusable abstract data types. </title> <booktitle> In Proc. of the First Working Conference on Reverse Engineering, </booktitle> <pages> pages 73-82, </pages> <address> Baltimore, Maryland, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Techniques have also been developed within the RE 2 project <ref> [6, 7] </ref>, for identifying candidate abstract data types and their associated modules, based on the call graph and dominance relations. Further research is required to develop techniques for extracting objects from pieces of data that have not already been aggregated in programmer-defined data structures.
Reference: [7] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Proc. 3rd Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <address> Washington, D.C., Novem-ber 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Techniques have also been developed within the RE 2 project <ref> [6, 7] </ref>, for identifying candidate abstract data types and their associated modules, based on the call graph and dominance relations. Further research is required to develop techniques for extracting objects from pieces of data that have not already been aggregated in programmer-defined data structures.
Reference: [8] <author> R. Hall. </author> <title> Program improvement by automatic redistribution of intermediate results. </title> <type> Technical Report 1251, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> February </month> <year> 1990. </year> <type> PhD. </type>
Reference-contexts: The goal of the paper is to characterize the interleaving problem, relating it to existing concepts in the literature, such as delocalized plans [15], coupling [29], and redistribution of intermediate results <ref> [8, 9] </ref>. The paper presents and categorizes examples of types of interleaving to begin to map out the space of interleaving situations. It also describes how the decision to introduce interleaving into a program interacts with other design decisions. <p> Their implementations overlapping computations. overlap in that a single structural element contributes to multiple goals. The sharing of the results of some subcomputation in the implementation of two distinct higher level operations is termed redistribution of intermediate results by Hall <ref> [8, 9] </ref>. More specifically, redistribution is a class of function sharing optimizations which are implemented simply by tapping into the dataflow from some value producer and feeding it to an additional target consumer, essentially introducing fanout in dataflow.
Reference: [9] <author> R. Hall. </author> <title> Program improvement by automatic redistribution of intermediate results: An overview. </title> <editor> In M. Lowry and R. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <address> Menlo Park, CA, </address> <year> 1991. </year>
Reference-contexts: The goal of the paper is to characterize the interleaving problem, relating it to existing concepts in the literature, such as delocalized plans [15], coupling [29], and redistribution of intermediate results <ref> [8, 9] </ref>. The paper presents and categorizes examples of types of interleaving to begin to map out the space of interleaving situations. It also describes how the decision to introduce interleaving into a program interacts with other design decisions. <p> Their implementations overlapping computations. overlap in that a single structural element contributes to multiple goals. The sharing of the results of some subcomputation in the implementation of two distinct higher level operations is termed redistribution of intermediate results by Hall <ref> [8, 9] </ref>. More specifically, redistribution is a class of function sharing optimizations which are implemented simply by tapping into the dataflow from some value producer and feeding it to an additional target consumer, essentially introducing fanout in dataflow.
Reference: [10] <author> J. Hartman. </author> <title> Automatic control understanding for natural programs. </title> <type> Technical Report AI 91-161, </type> <institution> University of Texas at Austin, </institution> <year> 1991. </year> <type> PhD thesis. </type>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [11] <author> D. Hutchens and V. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 11(8), </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing [27, 17] is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [3, 11, 23, 24] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [12] <author> W. L. Johnson. </author> <title> Intention-Based Diagnosis of Novice Programming Errors. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [13] <author> W. Kozaczynski and J.Q. Ning. </author> <title> Automated program understanding by concept recognition. </title> <journal> Automated Software Engineering, </journal> <volume> 1(1) </volume> <pages> 61-78, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [14] <author> S. Letovsky. </author> <title> Plan analysis of programs. </title> <type> Research Report 662, </type> <institution> Yale University, </institution> <month> December </month> <year> 1988. </year> <type> PhD. </type>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [15] <author> S. Letovsky and E. Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3), </volume> <year> 1986. </year>
Reference-contexts: Or interleaving may arise as a natural byproduct of expressing separate but related plans in a linear, textual medium. For example, accessors and constructors for manipulating data structures are typ 2 This definition is distilled from definitions in <ref> [15, 21, 25] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> The goal of the paper is to characterize the interleaving problem, relating it to existing concepts in the literature, such as delocalized plans <ref> [15] </ref>, coupling [29], and redistribution of intermediate results [8, 9]. The paper presents and categorizes examples of types of interleaving to begin to map out the space of interleaving situations. It also describes how the decision to introduce interleaving into a program interacts with other design decisions. <p> Delocalization is one of the key characteristics of interleaving: one or more components of a plan are spatially separated from other components by the components of other plans with which they are interleaved. Letovsky and Soloway's cognitive study <ref> [15] </ref> shows the deleterious effects of delocalization on comprehension and maintenance. The "scale-unscale" pattern is a simple example of a more general delocalized plan, ("transform-untransform") which is frequently interleaved with computations in SPICELIB. <p> This allows the scaling factor to be computed once and the result reused. (The role of sharing in interleaving is discussed more extensively in Section 2.2.) Realizing that a reformulation wrapper or some other delocalized plan is interleaved with a particular computation can help prevent severe comprehension failures during maintenance <ref> [15] </ref>.
Reference: [16] <author> G. Myers. </author> <title> Reliable Software through Composite Design. </title> <type> Petrocelli Charter, </type> <year> 1975. </year>
Reference-contexts: Getting here means the line doesn't C intersect the ellipsoid. ... [handling the non-intercept case] RETURN END The use of control flags is a special form of control coupling: "any connection between two modules that communicates elements of control [29]," typically in the form of function codes, flags, or switches <ref> [16] </ref>. This sharing of control information between two modules increases the complexity of the code, complicating comprehension and maintenance. Content coupling. Another form of resource sharing occurs when the lexical structure of a module is shared among several related functional components.
Reference: [17] <author> J.Q. Ning, A. Engberts, and W. Kozaczynski. </author> <title> Automated support for legacy code understanding. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 50-57, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing <ref> [27, 17] </ref> is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis [3, 11, 23, 24] is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names.
Reference: [18] <author> A. Quilici. </author> <title> A memory-based approach to recognizing programming plans. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 84-93, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [19] <author> C. Rich. </author> <title> A formal representation for plans in the Programmer's Apprentice. </title> <booktitle> In Proc. 7th Int. Joint Conf. Artificial Intelligence, </booktitle> <pages> pages 1044-1052, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> August </month> <year> 1981. </year>
Reference-contexts: An existing formalism that meets these criteria is Rich's Plan Calculus <ref> [19, 20] </ref>, which was developed and used in the Programmer's Apprentice [21] project. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them.
Reference: [20] <author> C. Rich. </author> <title> Inspection methods in programming. </title> <type> Technical Report 604, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> June </month> <year> 1981. </year> <type> PhD thesis. </type>
Reference-contexts: An existing formalism that meets these criteria is Rich's Plan Calculus <ref> [19, 20] </ref>, which was developed and used in the Programmer's Apprentice [21] project. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them.
Reference: [21] <author> C. Rich and R. C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <publisher> MA and ACM Press, </publisher> <address> Baltimore, MD, </address> <year> 1990. </year>
Reference-contexts: Or interleaving may arise as a natural byproduct of expressing separate but related plans in a linear, textual medium. For example, accessors and constructors for manipulating data structures are typ 2 This definition is distilled from definitions in <ref> [15, 21, 25] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> For example, accessors and constructors for manipulating data structures are typ 2 This definition is distilled from definitions in [15, 21, 25]. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following <ref> [21, 25] </ref>, we reserve the term cliche for a plan that represents a standard, stereotypical form. ically interleaved throughout programs written in tra-ditional programming languages due to their procedural, rather than object-oriented structure. Regardless of why interleaving is introduced, it severely complicates understanding a program. <p> An existing formalism that meets these criteria is Rich's Plan Calculus [19, 20], which was developed and used in the Programmer's Apprentice <ref> [21] </ref> project. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them. This diagrammatic notation is complemented with an axiomatized description of the plan which defines its formal semantics. <p> One of the key features of GRASPR [28], for instance, is its ability to deal with de-localization and redistribution-type function sharing optimizations. KBEmacs <ref> [21, 26] </ref> uses a simple, special-purpose recognition strategy to segment loops within programs. This is based on detecting coarse patterns of data and control flow at the procedural level that are indicative of common ways of constructing, augmenting, and interleaving iterative computations.
Reference: [22] <author> S. Rugaber, S. Ornburn, and R. LeBlanc. </author> <title> Recognizing design decisions in programs. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 46-54, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The software performs calculations in the domain of solar system geometry. * A program for finding the roots of functions (ZEROIN), presented and analyzed in [1] and <ref> [22] </ref>. The goal of the paper is to characterize the interleaving problem, relating it to existing concepts in the literature, such as delocalized plans [15], coupling [29], and redistribution of intermediate results [8, 9]. <p> what types of program representations will facilitate the detection of interleaving decisions and the extraction of interleaved components; and how can interleaved components be automatically detected and extracted from code? 3.1 Interactions with Other Decisions Intentional interleaving is one of several ways in which design decisions are elaborated in code <ref> [22] </ref>.
Reference: [23] <author> R. Schwanke. </author> <title> An intelligent tool for re-engineering software modularity. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1991, </booktitle> <pages> pages 83-92, </pages> <year> 1991. </year>
Reference-contexts: When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing [27, 17] is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [3, 11, 23, 24] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [24] <author> R. Schwanke, R. Altucher, and M. Platoff. Discov--ering, </author> <title> visualizing, and controlling software structure. </title> <booktitle> In Proc. 5th Int. Workshop on Software Specs. and Design, </booktitle> <pages> pages 147-150, </pages> <address> Pittsburgh, PA, </address> <year> 1989. </year>
Reference-contexts: When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing [27, 17] is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [3, 11, 23, 24] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [25] <author> P. Selfridge, R. Waters, and E. Chikofsky. </author> <title> Challenges to the field of reverse engineering A position paper. </title> <booktitle> In Proc. of the First Working Conference on Reverse Engineering, </booktitle> <pages> pages 144-150, </pages> <address> Baltimore, Mary-land, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Or interleaving may arise as a natural byproduct of expressing separate but related plans in a linear, textual medium. For example, accessors and constructors for manipulating data structures are typ 2 This definition is distilled from definitions in <ref> [15, 21, 25] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> For example, accessors and constructors for manipulating data structures are typ 2 This definition is distilled from definitions in [15, 21, 25]. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following <ref> [21, 25] </ref>, we reserve the term cliche for a plan that represents a standard, stereotypical form. ically interleaved throughout programs written in tra-ditional programming languages due to their procedural, rather than object-oriented structure. Regardless of why interleaving is introduced, it severely complicates understanding a program.
Reference: [26] <author> R. C. Waters. </author> <title> A method for analyzing loop programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 237-247, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: One of the key features of GRASPR [28], for instance, is its ability to deal with de-localization and redistribution-type function sharing optimizations. KBEmacs <ref> [21, 26] </ref> uses a simple, special-purpose recognition strategy to segment loops within programs. This is based on detecting coarse patterns of data and control flow at the procedural level that are indicative of common ways of constructing, augmenting, and interleaving iterative computations.
Reference: [27] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 352-357, </pages> <year> 1984. </year>
Reference-contexts: When unfamiliar plans are interleaved, other, nonrecognition-based methods of delineation are needed. For example, slicing <ref> [27, 17] </ref> is a widely-used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis [3, 11, 23, 24] is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names.
Reference: [28] <author> L. Wills. </author> <title> Automated program recognition by graph parsing. </title> <type> Technical Report 1358, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> July </month> <year> 1992. </year> <type> PhD Thesis. </type>
Reference-contexts: The third dimension is the familiarity of the plans interleaved: are they cliches (i.e., stereotypical, frequently used plans) or are they unfamiliar plans (i.e., novel, idiosyncratic, or not used repeatedly)? When what is interleaved is familiar (i.e., a cliche), cliche recognition (e.g., <ref> [10, 12, 13, 14, 18, 28] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches. <p> One of the key features of GRASPR <ref> [28] </ref>, for instance, is its ability to deal with de-localization and redistribution-type function sharing optimizations. KBEmacs [21, 26] uses a simple, special-purpose recognition strategy to segment loops within programs. <p> The recognition and temporal abstraction of iteration cliches is similarly used in GRASPR to enable it to deal with generalized loop fusion forms of interleaving (loop fusion is viewed as redistribution of sequences of values and treated as any other redistribution optimization) <ref> [28] </ref>. Existing cliche recognition systems tend to deal with interleaving involving data and control mechanisms. Domain-based clustering, as explored by DM-TAO in the DESIRE system [3], focuses on naming mechanisms, by keying in on the patterns of linguistic idioms used in the program, which suggest the manifestations of domain concepts.

References-found: 28

