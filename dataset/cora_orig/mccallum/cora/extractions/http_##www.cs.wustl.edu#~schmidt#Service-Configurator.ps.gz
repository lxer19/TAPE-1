URL: http://www.cs.wustl.edu/~schmidt/Service-Configurator.ps.gz
Refering-URL: http://www.cs.wustl.edu/~pjain/java/java_notes.html
Root-URL: 
Email: pjain@cs.wustl.edu and schmidt@cs.wustl.edu  
Phone: (314) 935-7538 1  
Title: Service Configurator A Pattern for Dynamic Configuration of Services  
Author: Prashant Jain and Douglas C. Schmidt 
Address: St. Louis, MO 63130,  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper describes the Service Configurator pattern, which decouples the implementation of services from the time when they are configured. This pattern increases the flexibility and extensibility of applications by enabling their constituent services to be configured at any point in time. The Service Con- figurator pattern is widely used in application environments (e.g., to configure Java applets into WWW browsers), operating systems (e.g., to configure device drivers), and distributed systems (e.g., to configure standard Internet communication services). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This paper is organized as follows: Section 2 describes the Service Configurator pattern using a variant of the GoF pattern format <ref> [1] </ref> and Section 3 presents concluding remarks. 2 The Service Configurator Pattern 2.1 Intent Decouples the behavior of services from the point in time at which service implementations are configured into an application or system. 2.2 Also Known As Super-server 2.3 Motivation The Service Configurator pattern decouples the implementation of services <p> Likewise, dynamically configured services that run for a long periods of time often execute using the Active Object pattern [22]. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Fa- cade <ref> [1] </ref>. This Facade simplifies the management and control of applications that are executing within the Service Config- urator. The virtual methods provided by the Service base class are callback hooks [23] or hook methods [9]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. <p> The virtual methods provided by the Service base class are callback hooks [23] or hook methods [9]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class) may be created using a Factory Method <ref> [1] </ref>. This allows an application to decide the type of Service subclass to create. 3 Concluding Remarks This paper describes the Service Configurator pattern and illustrates how it decouples the implementation of services from their configuration. This decoupling increases the flexibility and extensibility of services.
Reference: [2] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for HighPerformance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: This service provides accurate, fault- tolerant clock synchronization for computers collaborating in local area networks and wide area networks. A synchronized time service is important in distributed systems that require multiple hosts to maintain accurate global time. For instance, large-scale distributed medical imaging systems <ref> [2] </ref> require globally synchronized clocks to ensure that patient exams are accurately timestamped and analyzed expeditiously by radiologists throughout the health-care delivery system.
Reference: [3] <author> R. Gusella and S. Zatti, </author> <title> The Accuracy of the Clock Synchronization Achieved by TEMPO in Berkeley UNIX 4.3BSD, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <pages> pp. 847853, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: architecture of the distributed time service contains the following components: * Time Server which answers queries about the time made by Clerks. * Clerk which queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algo <br>- rithms <ref> [3, 4] </ref>, and updates its own local system time. * Client which uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 2.3.2 Common Traps and Pitfalls One way to implement the distributed time service is to statically <p> Depending upon requirements, the user can choose from various implementations dynami <p>- cally, without having to focus on configuration issues. For instance, different Clerk services may exist corre-sponding to different algorithm implementations. Thus, the user may either select a Clerk service that implements the Berkeley algorithm <ref> [3] </ref> or a Clerk service that implements Cristian's algorithm [4]. The choice may depend upon the characteristics of the TimeServer. If the machine on which the TimeServer resides has a WWV receiver 5 the TimeServer can act as a passive entity and Cristian algorithm would be best suited.
Reference: [4] <author> F. Cristian, </author> <title> Probabilistic Clock Synchronization, </title> <journal> Distributed Computing, </journal> <volume> vol. 3, </volume> <pages> pp. 146-158, </pages> <year> 1989. </year>
Reference-contexts: architecture of the distributed time service contains the following components: * Time Server which answers queries about the time made by Clerks. * Clerk which queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algo <br>- rithms <ref> [3, 4] </ref>, and updates its own local system time. * Client which uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 2.3.2 Common Traps and Pitfalls One way to implement the distributed time service is to statically <p> For instance, different Clerk services may exist corre-sponding to different algorithm implementations. Thus, the user may either select a Clerk service that implements the Berkeley algorithm [3] or a Clerk service that implements Cristian's algorithm <ref> [4] </ref>. The choice may depend upon the characteristics of the TimeServer. If the machine on which the TimeServer resides has a WWV receiver 5 the TimeServer can act as a passive entity and Cristian algorithm would be best suited.
Reference: [5] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: However, terminating the process to change the Clerk code would also terminate the Time Server. This disruption in service availability may not be acceptable for mission critical distributed systems (such as telecommunication switches or call centers <ref> [5] </ref>). 2 For platforms that support shared memory, communication overhead can be minimized by storing the current time into shared memory that is mapped into the address space of the Clerk and all Clients on the same host. * System performance may not scale up efficiently: As-- sociating a process for <p> There are two ways to define the service control interface: inheritance-based and message-based, as described below: * Inheritance-based service control interface In this approach, each service inherits from a common base class. This approach is used by the ACE Service Configurator framework <ref> [5] </ref> and Java applets, which defines abstract base classes that contain pure virtual hook methods.
Reference: [6] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Moreover, processes are often the wrong concurrency model for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, a multi-threaded Active Object <ref> [6] </ref> or a single-threaded Re- active [7] event loop may be more efficient. 2.3.3 Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service concurrency model: A service that has been dynamically configured by a Service Configura- tor can be executed using various combinations of Reactive [7] and Active Object <ref> [6] </ref> schemes. <p> The example below focuses on the configuration-related aspects of the distributed time service described in Section 2.3. In addition, this example illustrates how other patterns (such as the Active Object pattern <ref> [6] </ref> and the Acceptor and Con- nector patterns [8]) are commonly used in conjunction with the Service Configurator pattern to develop flexible communication infrastructure and services.
Reference: [7] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: AddisonWesley, </address> <year> 1995. </year>
Reference-contexts: Moreover, processes are often the wrong concurrency model for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, a multi-threaded Active Object [6] or a single-threaded Re- active <ref> [7] </ref> event loop may be more efficient. 2.3.3 Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> inetd.conf file) simplifies the installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service concurrency model: A service that has been dynamically configured by a Service Configura- tor can be executed using various combinations of Reactive <ref> [7] </ref> and Active Object [6] schemes. <p> However, the functionality of dynamically configuring, initializing, suspending, resuming, and terminating a Service created using the Manager Pattern must be added to fully implement the Service Configurator Pattern. A Service Configurator often makes use of the Reactor <ref> [7] </ref> pattern to perform event demultiplexing and dispatching on behalf of configured services. Likewise, dynamically configured services that run for a long periods of time often execute using the Active Object pattern [22].
Reference: [8] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Each subclass represents a concrete Service, which has specific functionality in the distributed time service. The TimeServer service is responsible for receiving and processing requests for time updates from Clerks. The Clerk service is a Connector <ref> [8] </ref> factory that performs the following tasks: 1. Creates a new connection for every server; 2. Dynamically allocates a new handler to send time update requests to a connected server; 3. Receives the replies from all the servers through the handlers; 4. <p> The example below focuses on the configuration-related aspects of the distributed time service described in Section 2.3. In addition, this example illustrates how other patterns (such as the Active Object pattern [6] and the Acceptor and Con- nector patterns <ref> [8] </ref>) are commonly used in conjunction with the Service Configurator pattern to develop flexible communication infrastructure and services. In the example, the Concrete Service class in the OMT class diagram shown in Figure 3 is represented by the TimeServer class and the Clerk class. <p> The Acceptor class uses the Acceptor pattern <ref> [8] </ref> to create handlers for each Clerk connection that wants to receive requests for time up <p>- dates [13]. This design decouples the implementation of the TimeServer from its configuration. Therefore, developers can change the implementation of the TimeServer inde <p>- pendently of its configuration. <p> In addition, it can call getAppletInfo method to obtain useful information about the service, such as the version number or the name of the author. 2.9.2 The Clerk Class The Clerk uses the Connector pattern <ref> [8] </ref> to establish and maintain connections with one or more TimeServers. The Connector pattern creates a handler for every connection to a TimeServer. The handlers receive and process time updates from the TimeServers. The java.applet.Applet base class is the parent of the Clerk class. <p> These frameworks contain a master Acceptor <ref> [8] </ref> process that reactively monitors the set of ports associated with the services. When a client connection occurs on a monitored port, the Acceptor process accepts the connection and demultiplexes the request to the appropriate pre-registered service handler.
Reference: [9] <author> W. Pree, </author> <title> Design Patterns for Object-Oriented Software Development. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The key participants in the Service Configurator pattern include the following: * Service (Service) Specifies the interface that contains the abstract hook methods <ref> [9] </ref> (such as methods for initialization and termination) used by a Service Configurator-based application to dynamically configure each Service. * Concrete Service (Clerk and TimeServer) Implements the service hook methods and other service-specific functionality (such as event processing and communication with clients and other services). * Service Repository (ServiceRepository) Maintains a <p> This Facade simplifies the management and control of applications that are executing within the Service Config- urator. The virtual methods provided by the Service base class are callback hooks [23] or hook methods <ref> [9] </ref>. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class) may be created using a Factory Method [1].
Reference: [10] <author> D. Lea and J. Marlowe, </author> <title> PSL: Protocols and Pragmatics for Open Systems, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: For instance, a faulty service may crash, thereby corrupting state information it shares with other co-located services. This is particularly problematic for open systems <ref> [10] </ref>, such as Java applets within WWW browsers that configure and execute multiple services within the same process. * Increased overhead: The pattern adds extra levels of indirection to execute a service. For instance, the Service Configurator first initializes the service and then loads it into the Service Repository.
Reference: [11] <author> R. Gingell, M. Lee, X. Dang, and M. Weeks, </author> <title> Shared Libraries in SunOS, </title> <booktitle> in Proceedingsof the Summer 1987 USENIX Technical Conference, </booktitle> <address> (Phoenix, Arizona), </address> <year> 1987. </year>
Reference-contexts: This may be undesirable or an unnecessary overhead in time-critical applications. In addition, the Service Configurator pattern often configures services via dynamic linking, which adds extra indirection to invoke functions and access global variables <ref> [11] </ref>. * Lack of generality: If services are tightly coupled, it may not be possible to dynamically configure them in arbitrary ways using the Service Configurator pattern.
Reference: [12] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Microsoft Press, </publisher> <year> 1993. </year>
Reference-contexts: This makes it possible to integrate the Service Configurator into non-OO programming languages (such as C). The Windows NT Service Control Manager (SCM) <ref> [12] </ref> uses this scheme. Each Windows NT host has a master SCM process that automatically initiates and manages system services by passing them control messages such as PAUSE, RESUME, and TERMINATE. <p> A method in a Java applet can access the thread it is running in using Thread.currentThread (). In addition, threads can control each other by invoking methods like stop and start. * Modern operating system device drivers: Modern operating systems (such as Solaris [14] and Windows NT <ref> [12] </ref>) support dynamically configurable kernel-level device drivers. For instance, Solaris drivers can be linked into and unlinked out of the system dynamically via init/fini/info hooks. <p> This handler performs the service (either reactively or in an active object) and returns any results to the client. * The Windows NT Service Control Manager (SCM): Unlike inetd and listen, the Windows NT Service Con- trol Manager (SCM) <ref> [12] </ref> is not a port monitor. That is, it does not provide built-in support for listening to a set of I/O ports and dispatching server processes on-demand when client requests arrive.
Reference: [13] <author> P. Jain and D. Schmidt, </author> <title> Experiences Converting a C++ Communication Software Framework to Java,C++ Report, </title> <journal> vol. </journal> <volume> 9, </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: The Acceptor class uses the Acceptor pattern [8] to create handlers for each Clerk connection that wants to receive requests for time up <p>- dates <ref> [13] </ref>. This design decouples the implementation of the TimeServer from its configuration. Therefore, developers can change the implementation of the TimeServer inde <p>- pendently of its configuration. This design provides flex <p>- ibility with respect to evolving the implementation of the TimeServer class.
Reference: [14] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: A method in a Java applet can access the thread it is running in using Thread.currentThread (). In addition, threads can control each other by invoking methods like stop and start. * Modern operating system device drivers: Modern operating systems (such as Solaris <ref> [14] </ref> and Windows NT [12]) support dynamically configurable kernel-level device drivers. For instance, Solaris drivers can be linked into and unlinked out of the system dynamically via init/fini/info hooks.
Reference: [15] <author> W. R. Stevens, </author> <title> UNIX Network Programming, First Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd <ref> [15] </ref> and listen [16].
Reference: [16] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd [15] and listen <ref> [16] </ref>.
Reference: [17] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Massachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Each installed service is individually responsible for configuring itself and monitoring any communication endpoints (which may be more general than I/O ports, e.g., named pipes or shared memory). * The ADAPTIVE Communication Environment (ACE) framework: The ACE framework <ref> [17] </ref> provides a set of C++ mechanisms for configuring and controlling services dynamically. The ACE Service Configurator extends the mechanisms provided by inetd, listen, and SCM to automatically support dynamic linking and unlinking of services.
Reference: [18] <author> S. Crane, J. Magee, and N. Pryce, </author> <title> Design Patterns for Binding in Distributed Systems, </title> <booktitle> in The OOPSLA '95 Workshop on Design Patterns for Concurrent, Parallel, and Distributed Object-Oriented Systems, </booktitle> <address> (Austin, TX), </address> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: Rather than targeting kernel-level device drivers, however, the ACE Service Configurator framework focuses on dynamic configuration and control of application-level Service objects. 2.11 Related Patterns The intent of the Service Configurator pattern is similar to the Configuration pattern <ref> [18] </ref>. The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves.
Reference: [19] <author> J. Magee, N. Dulay, and J. Kramer, </author> <title> A Constructive Development Environment for Parallel and Distributed Programs, </title> <booktitle> in Proceedings of the 2 nd International Workshop on Configurable Distributed Systems, </booktitle> <address> (Pittsburgh, PA), </address> <pages> pp. 1-14, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves. The Configuration pattern has been used in frameworks for configuring distributed systems (such as Regis <ref> [19] </ref> and Polylith [20]) to support the construction of a distributed system from a set of components. In a similar way, the Service Configurator pattern decouples service initialization from service processing.
Reference: [20] <author> J. M. Purtilo, </author> <title> The Polylith Software Toolbus, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1994. </year>
Reference-contexts: The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves. The Configuration pattern has been used in frameworks for configuring distributed systems (such as Regis [19] and Polylith <ref> [20] </ref>) to support the construction of a distributed system from a set of components. In a similar way, the Service Configurator pattern decouples service initialization from service processing.
Reference: [21] <author> P. Sommerland and F. Buschmann, </author> <title> The Manager Design Pattern, </title> <booktitle> in Proceedings of the 3 rd Pattern Languages of Programming Conference, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: In addition, the Service Configurator pattern also focuses on decoupling service behavior from the service's concurrency strategies. The Manager Pattern <ref> [21] </ref> manages a collection of objects by assuming responsibility for creating and deleting these objects. In addition, it provides an interface to allow clients access to the objects it manages.
Reference: [22] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: A Service Configurator often makes use of the Reactor [7] pattern to perform event demultiplexing and dispatching on behalf of configured services. Likewise, dynamically configured services that run for a long periods of time often execute using the Active Object pattern <ref> [22] </ref>. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Fa- cade [1]. This Facade simplifies the management and control of applications that are executing within the Service Config- urator.
Reference: [23] <author> S. Berczuk, </author> <title> A Pattern for Separating Assembly and Processing, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Fa- cade [1]. This Facade simplifies the management and control of applications that are executing within the Service Config- urator. The virtual methods provided by the Service base class are callback hooks <ref> [23] </ref> or hook methods [9]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class) may be created using a Factory Method [1].
References-found: 23

