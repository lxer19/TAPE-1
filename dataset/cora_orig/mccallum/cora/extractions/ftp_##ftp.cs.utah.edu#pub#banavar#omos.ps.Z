URL: ftp://ftp.cs.utah.edu/pub/banavar/omos.ps.Z
Refering-URL: http://www.cs.utah.edu/~banavar/research.html
Root-URL: 
Email: fbanavar,dbo,lindstromg@cs.utah.edu  
Title: Layered, Server-based Support for Object-Oriented Application Development  
Author: Guruduth Banavar Douglas Orr Gary Lindstrom 
Address: Salt Lake City, UT 84112 USA  
Affiliation: Department of Computer Science University of Utah,  
Abstract: This paper advocates the idea that the physical modularity (file structure) of application components supported by conventional OS environments can be elevated to the level of logical modularity, which in turn can directly support application development in an object-oriented manner. We demonstrate this idea through a system-wide server that manages the manipulation of such components effectively. The server is designed to be a fundamental operating system service responsible for binding and mapping component instances into client address spaces. We show how this model solves some longstanding problems with the management of application components in existing application development environments. We demonstrate that this model's effectiveness derives from its support for the cornerstones of OO programming: classes and their instances, encapsulation, and several forms of inheritance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Apollo Computer, Inc, Chelmsford, MA. DOMAIN Software Engineering Environment (DSEE) Call Reference, </institution> <year> 1987. </year>
Reference-contexts: The dld utility does offer dynamic unlinking of a module, which OMOS currently does not support. However, since OMOS retains access to the symbol table and relocation information for loaded modules, unlinking support could be added. The Apollo DSEE <ref> [1] </ref> system was a server-based system which managed sources and objects, taking ad-vantage of caching to avoid recompilation. DSEE was primarily a CASE tool and did not take part in the execution phase of program development.
Reference: [2] <author> Guruduth Banavar and Gary Lindstrom. </author> <title> Object-oriented programming in Scheme with first-class modules and operator-based inheritance. </title> <type> Technical Report UUCS-95-002, </type> <institution> University of Utah, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Individual modules, or entire applications, can then be instantiated into the address spaces of particular client processes. Compositional modularity has a firm foundation [4], and has been shown to be flexible enough to support several important effects and styles of object-oriented programming <ref> [2] </ref>. This approach has other advantages besides making system building more principled and flexible. First, it enables a form of OO programming with components written in non OO languages such as C and Fortran. <p> can be combined in a manner similar to method wrapping to get the effect of a before-method: (hide (override (copy-as M meth old-meth) (merge W B)) old-meth) 4.2.2 Single and Multiple Inheritance The idioms shown in Figure 4 are in fact the basis of inheritance in current day OO languages <ref> [2] </ref>. In this section, we give a brief idea of how these idioms can be used to achieve notions of inheritance. Recall from Section 4.1.2 that a class can be defined using the macro define-class, which expands to a module expression that uses open-module and hide. <p> superclasses, as shown below: 2 (define-class land-chars "land chars.o" () ()) (define-class sea-chars "sea chars.o" () ()) (define-class amphibian "amphibian.o" (land-chars sea-chars vehicle) ()) With the module operations supported by our module language, several other single and multiple inheritance styles can be expressed as well | these are described in <ref> [2] </ref>. 5 Solving Old Problems Using the operations defined on modules it is possible to conveniently solve long-standing problems in software engineering, encountered when using C, or C++. Several of these problems had solutions previously, but they were ad-hoc and/or required changes to source code. <p> In other variants, the destructors for 2 Explicit specification of linearization is more useful than an implicit, language provided mechanism, see <ref> [2] </ref> for details. the standard I/O library are hard-coded into the standard exit routine. In neither case is there any provision for calling initialization routines (e.g., constructors) before program startup.
Reference: [3] <author> Guruduth Banavar, Gary Lindstrom, and Douglas Orr. </author> <title> Type-safe composition of object modules. </title> <booktitle> In Computer Systems and Education, </booktitle> <pages> pages 188-200. </pages> <publisher> Tata McGraw Hill Publishing Company, Limited, </publisher> <address> New Delhi, India, </address> <month> June 22-25, </month> <year> 1994. </year> <note> ISBN 0-07-462044-4. Also available as Technical Report UUCS-94-001. </note>
Reference-contexts: Symbols, both defined and merely declared, of physical modules make up the interface of logical modules. (For simplicity of presentation, we consider interfaces to comprise only the symbol names, without their programming language types; see <ref> [3] </ref> for a study of typed interfaces.) Compiled code and data in the actual object file represents the module implementation. A physical dot-o is brought into the purview of the logical layer by using the primitive open-module in our module language.
Reference: [4] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: Individual modules, or entire applications, can then be instantiated into the address spaces of particular client processes. Compositional modularity has a firm foundation <ref> [4] </ref>, and has been shown to be flexible enough to support several important effects and styles of object-oriented programming [2]. This approach has other advantages besides making system building more principled and flexible. <p> The OMOS server is described in more detail in Section 3.3. The module manipulation language supported by OMOS is derived from the programming language Scheme [6], and is based on the module manipulation language Jigsaw <ref> [4] </ref>. <p> Thus, the facility we describe here is intended mainly for enhancing application component management rather than for actual application programming. 4.1 Classes In the model of compositional modularity, a module corresponds to a distillation of the conventional notion of classes <ref> [4] </ref>. A module is a self-referential scope, consisting of a set of defined and declared attributes with no order significance. Definitions bind identifiers to values, and declarations simply associate identifiers with types (defining a label subsumes declaring it).
Reference: [5] <author> John R. Callahan and James M. Purtilo. </author> <title> A packaging system for heterogeneous execution environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(6) </volume> <pages> 626-635, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: DSEE was primarily a CASE tool and did not take part in the execution phase of program development. Several architecture description languages have been proposed, such as Rapide [12], the POLYLITH Module Interconnection Language (MIL) <ref> [5, 18] </ref>, and OMG's Interface Definition Language (IDL) [9]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections.
Reference: [6] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <year> 1991. </year>
Reference-contexts: The OMOS server is described in more detail in Section 3.3. The module manipulation language supported by OMOS is derived from the programming language Scheme <ref> [6] </ref>, and is based on the module manipulation language Jigsaw [4].
Reference: [7] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: Definitions bind identifiers to values, and declarations simply associate identifiers with types (defining a label subsumes declaring it). Every module has an associated interface comprising the labels and types of all its visible attributes. An important characteristic of modules is the self-reference of attribute definitions to sibling attributes (see <ref> [7] </ref> for details). Modules can be adapted and composed using operators that manipulate the interface and the corresponding self-references.
Reference: [8] <author> Robert A. Gingell. </author> <title> Shared libraries. </title> <journal> Unix Review, </journal> <volume> 7(8) </volume> <pages> 56-66, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Although programmable linkers exist, they do not offer the generality and flexibility of our system. A user-space loader such as OMOS is no longer unusual <ref> [19, 8] </ref>. Many operating systems, even those with monolithic kernels, now use an external process to do program loading involving shared libraries, and therefore linking.
Reference: [9] <author> Object Management Group. </author> <title> The common object request broker: Architecture and specification. </title> <note> Draft 10 Rev 1.1 Doc # 91.12.1, OMG, </note> <month> December </month> <year> 1991. </year>
Reference-contexts: DSEE was primarily a CASE tool and did not take part in the execution phase of program development. Several architecture description languages have been proposed, such as Rapide [12], the POLYLITH Module Interconnection Language (MIL) [5, 18], and OMG's Interface Definition Language (IDL) <ref> [9] </ref>. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections. Our approach offers the important advantage that OO like program adaptation and reuse techniques (inheritance, in all its meanings) can be applied to legacy components written in non-OO languages.
Reference: [10] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of OOPSLA Conference, </booktitle> <pages> pages 411 - 428. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: An environment for flexible application development has been pursued in the line of research leading to the so-called subject-oriented programming (SOP) <ref> [10] </ref>. In this research, a "subject" is in essence an OO component, i.e. a component built around an OO class hierarchy. Subjects can be separately compiled, and composed using tools know as "compositors" (similar to OMOS). Compositors use various operators similar to the ones presented here.
Reference: [11] <author> Wilson Ho and Ronald Olsson. </author> <title> An approach to genuine dynamic linking. </title> <journal> Software| Practice and Experience, </journal> <volume> 21(4) </volume> <pages> 375-390, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: However, the loader/dynamic linker is typically instantiated anew for each program, making it too costly for it to support more general functionality such as in OMOS. Utilities exist, such as dld <ref> [11] </ref>, to aid programmers in the dynamic loading of code and data. These packages tend to have a procedural point of view, provide lower-level functionality than OMOS , and do not offer the control over module manipulation that OMOS provides.
Reference: [12] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 138-150, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: The Apollo DSEE [1] system was a server-based system which managed sources and objects, taking ad-vantage of caching to avoid recompilation. DSEE was primarily a CASE tool and did not take part in the execution phase of program development. Several architecture description languages have been proposed, such as Rapide <ref> [12] </ref>, the POLYLITH Module Interconnection Language (MIL) [5, 18], and OMG's Interface Definition Language (IDL) [9]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections.
Reference: [13] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bo-brow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: The above idea of single inheritance can be generalized to multiple inheritance as found in languages such as CLOS <ref> [13] </ref>. In these languages, the graph of super-classes of a class is linearized into a single inheritance hierarchy by a language provided mechanism.
Reference: [14] <author> Douglas Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <pages> pages 237-251, </pages> <address> Cincinnati, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored elsewhere <ref> [14, 17, 15] </ref>; this paper focuses on application level support. It is important to make clear that compositional modularity supported by a logical layer is not in conflict with object-orientation supported by component-level languages. <p> OMOS supports three main functions: execution of module specs to compose applications, caching of intermediate results, and program loading. Module specs and their execution is described in the rest of the paper. The other two functions are described briefly below; the details, given in <ref> [16, 14] </ref>, are beyond the scope of this paper. Additionally, use of meta-protocols with OMOS is explored in [15]. Evaluation of a module expression will often produce the same results each time. As a result, OMOS caches module results in order to avoid re-doing unnecessary work. <p> As a result, OMOS caches module results in order to avoid re-doing unnecessary work. Since OMOS loads programs into client address spaces, it can be used as the basis for system program execution (the "exec server") and shared libraries <ref> [14] </ref>, as well as dynamic loading of modules. Combining a caching linker with the system object loader gives OMOS the flexibility to change implementations as it deems necessary, e.g. to reflect an updated implementation of a shared module across all its clients.
Reference: [15] <author> Douglas B. Orr. </author> <title> Application of meta-protocols to improve OS services. </title> <booktitle> In HOTOS-V: Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored elsewhere <ref> [14, 17, 15] </ref>; this paper focuses on application level support. It is important to make clear that compositional modularity supported by a logical layer is not in conflict with object-orientation supported by component-level languages. <p> Module specs and their execution is described in the rest of the paper. The other two functions are described briefly below; the details, given in [16, 14], are beyond the scope of this paper. Additionally, use of meta-protocols with OMOS is explored in <ref> [15] </ref>. Evaluation of a module expression will often produce the same results each time. As a result, OMOS caches module results in order to avoid re-doing unnecessary work.
Reference: [16] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: Finally, it must be continually available. For these reasons, the logical module layer in the prototype described here is managed by a server process | a second generation implementation of a server named OMOS <ref> [16] </ref>. The OMOS server is described in more detail in Section 3.3. The module manipulation language supported by OMOS is derived from the programming language Scheme [6], and is based on the module manipulation language Jigsaw [4]. <p> OMOS supports three main functions: execution of module specs to compose applications, caching of intermediate results, and program loading. Module specs and their execution is described in the rest of the paper. The other two functions are described briefly below; the details, given in <ref> [16, 14] </ref>, are beyond the scope of this paper. Additionally, use of meta-protocols with OMOS is explored in [15]. Evaluation of a module expression will often produce the same results each time. As a result, OMOS caches module results in order to avoid re-doing unnecessary work.
Reference: [17] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. In The Interaction of Compilation Technology and Computer Architecture. </title> <publisher> Kluwer Academic Publishers, </publisher> <month> February </month> <year> 1994. </year>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored elsewhere <ref> [14, 17, 15] </ref>; this paper focuses on application level support. It is important to make clear that compositional modularity supported by a logical layer is not in conflict with object-orientation supported by component-level languages.
Reference: [18] <author> James M. Purtilo. </author> <title> The POLYLITH software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: DSEE was primarily a CASE tool and did not take part in the execution phase of program development. Several architecture description languages have been proposed, such as Rapide [12], the POLYLITH Module Interconnection Language (MIL) <ref> [5, 18] </ref>, and OMG's Interface Definition Language (IDL) [9]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections.
Reference: [19] <editor> Marc Sabatella. </editor> <booktitle> Issues in shared libraries design. In Proc. of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 11-24, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Although programmable linkers exist, they do not offer the generality and flexibility of our system. A user-space loader such as OMOS is no longer unusual <ref> [19, 8] </ref>. Many operating systems, even those with monolithic kernels, now use an external process to do program loading involving shared libraries, and therefore linking.
Reference: [20] <author> Donn Seeley. </author> <title> Shared libraries as objects. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: a module that implements higher-level functionality, the functions in the former's interface can be subjected to the hide operation to avoid conflicts or accidental matches at higher levels. 6 Comparison to Related Research This work is in essence a general and concrete realization of a vision due to Donn Seeley <ref> [20] </ref>. Although programmable linkers exist, they do not offer the generality and flexibility of our system. A user-space loader such as OMOS is no longer unusual [19, 8].
References-found: 20

