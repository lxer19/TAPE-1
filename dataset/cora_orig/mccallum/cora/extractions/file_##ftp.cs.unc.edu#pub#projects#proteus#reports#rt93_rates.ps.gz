URL: file://ftp.cs.unc.edu/pub/projects/proteus/reports/rt93_rates.ps.gz
Refering-URL: http://www.cs.unc.edu/Research/proteus/proteus-publications.html
Root-URL: http://www.cs.unc.edu
Title: Rate-Control as a Language Construct for Parallel and Distributed Programming  
Author: Peter H. Mills, Jan F. Prins John H. Reif 
Date: April 13-16), 1993.  
Note: First IEEE Workshop on Parallel and Distributed  Abstract  
Address: Durham, N.C. 27708-0129 Chapel Hill, N.C. 27599-3175 USA  (IPPS'93, Newport Beach, California,  
Affiliation: Department of Computer Science, Department of Computer Science, Duke University, University of North Carolina,  Real-Time Systems,  
Abstract: This paper introduces a new parallel programming language construct, the rate construct, and examines its utility for a variety of problems. The rate construct specifies constraints on the relative rates of progress of tasks executing in parallel, where progress is the amount of computational work as measured by elapsed "ticks" on a local logical clock. By prescribing expected work, the rate construct constrains the allocation of processor-time to tasks needed to achieve that work; in a parallel setting this constrains the distribution of tasks to processors and multiprocessing ratios, effected for example by load balancing. We present definitions of rate and underlying real-time primitives as orthogonal extensions to the architecture-independent parallel programming language Proteus. The utility of the rate construct is evidenced for a variety of problems, including weighted parallel search for a goal, adaptive many-body simulation in which rates abstract the requirements for load-balancing, and variable time-stepped computations in which the use of rates can alter the frequency of asynchronous iterations. 
Abstract-found: 1
Intro-found: 1
Reference: [Ble92] <author> G. E. Blelloch, "NESL: </author> <title> A nested data-parallel language," </title> <type> Technical Report CMU-CS-92-103, </type> <institution> Carnegie Mellon University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Much attention has turned towards program transformation as a natural approach to bridge this gap, for example in the efforts of the Crystal equational language [CCL91], variants of Bird-Meertens functional formalism [Ski90], the NESL nested data-parallel language <ref> [Ble92] </ref>, and z This work was supported under DARPA / SISTO contracts N00014-88-K-0458, N00014-91-J-1985, N00014-91-C-0114 administered through ONR, NASA subcontract 550-63 of prime contract NAS5-30428, US-Israel Binational NSF Grant 88-00282/2, and NSF Grant NSF-IRI-91-00681. Proteus [MNPR92, PP93].
Reference: [CCL91] <author> M. C. Chen, Y. il Choo, and J. Li, </author> <title> "Crystal: Theory and pragmatics of generating efficient parallel code," </title> <booktitle> in Parallel Functional Languages and Compilers (B. </booktitle> <editor> K. Szymanski, ed.), ch. </editor> <volume> 7, </volume> <pages> pp. 255-308, </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Much attention has turned towards program transformation as a natural approach to bridge this gap, for example in the efforts of the Crystal equational language <ref> [CCL91] </ref>, variants of Bird-Meertens functional formalism [Ski90], the NESL nested data-parallel language [Ble92], and z This work was supported under DARPA / SISTO contracts N00014-88-K-0458, N00014-91-J-1985, N00014-91-C-0114 administered through ONR, NASA subcontract 550-63 of prime contract NAS5-30428, US-Israel Binational NSF Grant 88-00282/2, and NSF Grant NSF-IRI-91-00681. Proteus [MNPR92, PP93].
Reference: [CZ89] <author> R. Cole and O. Zajicek, </author> <title> "The APRAM: Incorporating asynchrony into the PRAM model," </title> <booktitle> in Proc. of the First ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <pages> pp. 169-178, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: A further generalization allows the specification of rates as probability variables that is, giving rate constraints as a function from rates to expected probability yielding a probabilistic rate control. The semantics then associates, for each admissible execution history, a probability in a manner analogous to that for variable-speed APRAM's <ref> [CZ89] </ref>. The rate construct proves advantageous in several ways. The specification of expected rate of progress is interpreted as a scheduling directive that, when simulating execution of prototypes, allows experimentation to predict real-time behavior.
Reference: [Dyb87] <author> R. K. Dybvig, </author> <title> The SCHEME Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: However, conventional timing constraints are typically too low level to effectively specify progress in a parallel setting. Some notion of progress is found in language features such as "engines" in MultiLisp and Scheme <ref> [Dyb87] </ref>. Engines typically employ timeouts to execute a function for a certain number of steps (fuel) before returning a continuation. However, engines constrain progress at a low level of detail and are really useful only in a sequential or multiprocessing situation.
Reference: [GHWS91] <author> H. GrubMuller, H. Heller, A. Windemuth, and K. Schulten, </author> <title> "Generalized Verlet algorithm for efficient molecular dynamics simulations with long-range interactions," </title> <journal> Molecular Simulation, </journal> <volume> vol. 6, </volume> <pages> pp. 121-142, </pages> <year> 1991. </year>
Reference-contexts: A further optimization is to, for a given particle, compute interactions with far-away points less frequently since their effects fall off rapidly with distance. Such a technique is used for example in the Generalized Verlet Algorithm described in <ref> [GHWS91] </ref>, where particles are separated into distance classes and interactions with far-away particles are computed less frequently. The rate construct can be used to control this iteration frequency for clusters which may be running on asynchronous processes.
Reference: [GL91] <author> R. Gerber and I. Lee, </author> <title> "Specification and analysis of resource-bound real-time systems," </title> <type> Technical Report MS-CIS-91-96, </type> <institution> University of Penn-sylvania, </institution> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Among the Proteus primitives are: duration t (stmt) [event duration] wait t [delay] wait t ! (stmt) [guarded timeouts] every t (stmt) [periodicity] within t (stmt) on timeout (stmt) [response time] S1 on E F1 () [exception handlers] These primitives encompass conventional real-time constructs such as those found in <ref> [GL91] </ref>. Our measurement of time relies fundamentally on viewing clocks as modules. Time parameters represent ticks on some named virtual clock, which is updated according to an underlying model of time and computation related to that found in [LVD + 91]. <p> Real-time behavior will depend not only on syn chronization and time constraints, but also on resource requests such as demands for computation, on the resource configuration which maps requesting agents such as processes to resources such as processors, and on scheduling which attempts to resolve resource contention and satisfy requests <ref> [GL91] </ref>. All these factors resources, requestors, constraints, and scheduling - interplay to determine real-time behavior, and both rate constraints and resource configuration can play heavily in this determination.
Reference: [Gre87] <author> L. F. Greengard, </author> <title> The Rapid Evaluation of Potential Fields in Particle Systems. </title> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: More sophisticated algorithms rely on approximation of the lesser effects of far-away clusters of particles (perhaps modeling them by a few large particles), and on multigrid techniques which exploit this approximation by hierarchically decomposing the particle space into near and far-away points in order to isolate these "far-field" interactions <ref> [Gre87] </ref>. A further optimization is to, for a given particle, compute interactions with far-away points less frequently since their effects fall off rapidly with distance.
Reference: [KL91] <author> K. Kenny and K. Lin, </author> <title> "Building flexible real-time systems using the Flex language," </title> <journal> IEEE Computer, </journal> <volume> vol. 24, </volume> <pages> pp. 70-78, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The duration construct is similar in form to that of the Flex language, in which conditions specifying inequalities on start, finish, interval and duration times can be attached to timing blocks <ref> [KL91] </ref>.
Reference: [Lam78] <author> L. Lamport, </author> <title> "Time, clocks, and the ordering of events in a distributed system," </title> <journal> Comm. ACM, </journal> <volume> vol. 21, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: These questions can be answered by making the underlying notions of clocks and steps more precise. Following Lamport <ref> [Lam78] </ref>, we view a process as a set of events, each consisting of the occurrence of some action or computation step (not necessarily atomic). 4 If the rates do not sum to 1 they are normalized to do so. <p> Let C i (t) denote the value of clock C i at "physical" time t. It must be emphasized that the C i still measure logical work, and are not to be regarded as physical clocks in the sense of Lamport <ref> [Lam78] </ref>. <p> The notion of global time can, without loss of generality, be ignored in several ways. One way is by replacing t with another logical clock on each process which abstracts physical time. It is well known that such physical clocks can be synchronized within a fixed small time interval <ref> [Lam78, MO83] </ref>, and we assume that the granularity of timing constraints and t are large compared to that error. <p> This can prove advantageous, for example, in modeling totally asynchronous distributed algorithms such as real-time resource granting systems which make assumptions about relative processor rates [RS82]. 6 By obeying certain local clock update rules and exchanging messages, a common clock consistent with local clocks can be derived <ref> [Lam78, LF81] </ref>.
Reference: [LF81] <author> N. A. Lynch and M. J. Fischer, </author> <title> "On describing the behavior and implementation of distributed systems," </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 13, </volume> <pages> pp. 17-43, </pages> <year> 1981. </year>
Reference-contexts: Another way, roughly equivalent to the first, might be to define a common virtual clock and use a type of rounds number <ref> [LF81] </ref>. 6 More important, however, is that the general notion of rate encompasses variable-speed processes (resulting from time-varying processor apportionment), so that much global progress adjustment may be necessary if any one process is allowed to slow arbitrarily. <p> This can prove advantageous, for example, in modeling totally asynchronous distributed algorithms such as real-time resource granting systems which make assumptions about relative processor rates [RS82]. 6 By obeying certain local clock update rules and exchanging messages, a common clock consistent with local clocks can be derived <ref> [Lam78, LF81] </ref>.
Reference: [LVD + 91] <author> D. C. Luckham, J. Vera, D. Bryan, L. Augustin, and F. Belz, </author> <title> "Partial orderings of event sets and their application to prototyping concurrent timed systems," </title> <type> Technical Report, </type> <institution> Computing Systems Laboratory, Stanford University, </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Our measurement of time relies fundamentally on viewing clocks as modules. Time parameters represent ticks on some named virtual clock, which is updated according to an underlying model of time and computation related to that found in <ref> [LVD + 91] </ref>. A "clock" is just a module with an active process responsible for updating the clock and distributing its values to a set of processes which it is said to "time". A clock times those processes which are visible from its module as determined by standard scoping rules. <p> These declarative assertions appear in the specification side of the module, whereas directives appear in the implementation or body of the module, similar in style to <ref> [LVD + 91] </ref>. 7. Summary and future work In this paper we have introduced the rate construct and examined its utility for a variety a problems such as minimizing parallel work in weighted parallel search and controlling the frequency of iteration in adaptive many-body simulation.
Reference: [MNP + 91] <author> P. H. Mills, L. S. Nyland, J. F. Prins, J. H. Reif, and R. A. Wagner, </author> <title> "Prototyping parallel and distributed programs in Proteus," </title> <booktitle> in Proc. of the Third IEEE Symp. on Parallel and Distributed Processing, </booktitle> <address> (Dallas, Texas, </address> <publisher> Dec.1-5), </publisher> <pages> pp. 10-19, </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: The Proteus language The rate construct and underlying real-time primitives, while in essence language independent, are succinctly presented in this paper as extensions to Proteus. Proteus is a high-level architecture-independent parallel programming language being developed to support the prototyping of parallel algorithms <ref> [MNP + 91, MNPR92] </ref>. The goal of the Proteus effort is to overcome the difficulties of expressing and evaluating design alternatives for parallel applications posed by the tedium of programming in non-portable low-level machine-specific parallel languages. <p> Parallel processes operate on individual copies of private variables which may be merged into the shared state at specifiable barrier synchronization points. This mimics the PRAM model of computation often used to design parallel algorithms. Private variables and other features of Pro-teus are more fully described in <ref> [MNP + 91, MNPR92] </ref>. 3. Progress constraints We now describe mechanisms for specifying time and progress-constrained computation, and illustrate their utility on a variety of problems.
Reference: [MNPR92] <author> P. H. Mills, L. S. Nyland, J. F. Prins, and J. H. Reif, </author> <title> "Prototyping n-body simulation in Proteus," </title> <booktitle> in Proc. of the Sixth International Parallel Processing Symp., </booktitle> <address> (Beverly Hills, Ca., </address> <publisher> Mar.23-26), </publisher> <pages> pp. 476-482, </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Proteus <ref> [MNPR92, PP93] </ref>. The gap between abstraction and practical realization also impacts whether properties such as performance can be preserved under transformation, an open problem. Secondly, and in a related vein, the question arises of what exactly should be abstracted and in what form. <p> The Proteus language The rate construct and underlying real-time primitives, while in essence language independent, are succinctly presented in this paper as extensions to Proteus. Proteus is a high-level architecture-independent parallel programming language being developed to support the prototyping of parallel algorithms <ref> [MNP + 91, MNPR92] </ref>. The goal of the Proteus effort is to overcome the difficulties of expressing and evaluating design alternatives for parallel applications posed by the tedium of programming in non-portable low-level machine-specific parallel languages. <p> For example, we have investigated refinement strategies that transform a broad class of high-level data parallel operations over sequences into the widely portable vector language CVL. The language and transformation techniques are also being used to prototype sophisticated parallel algorithms for many-body interaction as used in molecular dynamics simulations <ref> [MNPR92] </ref>. We describe here only a few salient features of Pro-teus. The Proteus language employs as its principle data types the high-level mathematical notions of sets, sequences, and maps, in a manner similar to such languages as SETL [SDDS86] and REFINE [Ref88]. <p> Parallel processes operate on individual copies of private variables which may be merged into the shared state at specifiable barrier synchronization points. This mimics the PRAM model of computation often used to design parallel algorithms. Private variables and other features of Pro-teus are more fully described in <ref> [MNP + 91, MNPR92] </ref>. 3. Progress constraints We now describe mechanisms for specifying time and progress-constrained computation, and illustrate their utility on a variety of problems. <p> However, one important consideration is how to ensure that data locality is preserved under any load balancing performed to effect progress constraints. It is a challenging problem to integrate abstractions for specifying data locality with abstractions such as rates which may effect load balancing. The private variables in Proteus <ref> [MNPR92] </ref> provide a weak measure of specifying a hierarchical form of data locality. We are investigating other techniques to specify a more general locality topology. 5.
Reference: [MO83] <author> K. Marzullo and S. Owicki, </author> <title> "Maintaining the time in a distributed system," </title> <booktitle> in Proc. 2nd Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 295-305, </pages> <year> 1983. </year>
Reference-contexts: The notion of global time can, without loss of generality, be ignored in several ways. One way is by replacing t with another logical clock on each process which abstracts physical time. It is well known that such physical clocks can be synchronized within a fixed small time interval <ref> [Lam78, MO83] </ref>, and we assume that the granularity of timing constraints and t are large compared to that error.
Reference: [PP93] <author> J. F. Prins and D. W. Palmer, </author> <title> "Transforming high-level data-parallel programs into vector operations," </title> <booktitle> to appear in Fourth ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, </booktitle> <address> (San Diego, Ca., May.20-22), </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Proteus <ref> [MNPR92, PP93] </ref>. The gap between abstraction and practical realization also impacts whether properties such as performance can be preserved under transformation, an open problem. Secondly, and in a related vein, the question arises of what exactly should be abstracted and in what form.
Reference: [Ref88] <institution> Reasoning Systems, Inc., Palo Alto, California, Refine 2.0 Language Summary, </institution> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: Actual parallel execution can be achieved by program transformations which place it in a restricted form that can be translated directly to a low-level machine-specific parallel language. The source-to-source transformations and translation can be managed semiautomatically by the analysis and theorem-proving capabilities of KIDS (Kestrel Interactive Development System) <ref> [Ref88, Smi90] </ref>. For example, we have investigated refinement strategies that transform a broad class of high-level data parallel operations over sequences into the widely portable vector language CVL. <p> We describe here only a few salient features of Pro-teus. The Proteus language employs as its principle data types the high-level mathematical notions of sets, sequences, and maps, in a manner similar to such languages as SETL [SDDS86] and REFINE <ref> [Ref88] </ref>. Sequence (similarly set) comprehension refers to the construction of a sequence by generation based on another sequence, of the form: [expr (x) : x in S j pred (x)] Sequences can also be constructed by enumeration.
Reference: [RKT92] <author> J. H. Reif, M. Kao, and S. Tate, </author> <title> "Searching in an unknown environment," </title> <booktitle> in Proc. of the Fourth Annual ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <address> (San Diego, Ca.), </address> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: In many robotic and other classes of search problems, the cost of search is proportional to the distance traveled in the search. The problem of searching in an unknown environment with this cost function is abstractly captured by the w-lane cow path problem <ref> [RKT92] </ref>. The name comes from the following scenario: a cow, Bessie, is standing at a crossroads with w paths leading off into unknown territory. On one of the paths there is a grazing field (the goal) at distance n from the intersection, and all other paths go on forever. <p> In general the rate construct can be used to succinctly express complex notions of progress in more sophisticated randomized algorithms. For example, algorithms for the cow-path problem can use randomized techniques to achieve optimal work <ref> [RKT92] </ref>. A sequential solution to the cow-path problem might use depth-first iterative deepening, which iteratively explores each path an increasing finite depth before returning to the pasture. A parallel solution, however, would explore each path at the same time, using one process per path.
Reference: [RS82] <author> J. H. Reif and P. Spirakis, </author> <title> "Real time resource allocation in distributed systems," </title> <booktitle> in Proc. of ACM Symp. on Principles of Distributed Computing, </booktitle> <address> (Ottawa, Canada), </address> <pages> pp. 84-94, </pages> <month> Aug. </month> <year> 1982. </year>
Reference-contexts: The problem of tracking relative rates between processes is thus reduced to ensuring absolute rates of progress of each process on its processor. This can prove advantageous, for example, in modeling totally asynchronous distributed algorithms such as real-time resource granting systems which make assumptions about relative processor rates <ref> [RS82] </ref>. 6 By obeying certain local clock update rules and exchanging messages, a common clock consistent with local clocks can be derived [Lam78, LF81]. <p> For example, rate constraints on the scheduling processes themselves can prove vital in guaranteeing good response time in distributed algorithms for resource allocation <ref> [RS82] </ref>. This algorithm uses probabilistic techniques to give real-time response for the allocation of resources in a distributed system, based on the ranges of relative rates of progress of non-equi-speed processes.
Reference: [SDDS86] <author> J. Schwartz, R. Dewar, E. Dubinsky, and E. Schonberg, </author> <title> Programming with Sets, An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: We describe here only a few salient features of Pro-teus. The Proteus language employs as its principle data types the high-level mathematical notions of sets, sequences, and maps, in a manner similar to such languages as SETL <ref> [SDDS86] </ref> and REFINE [Ref88]. Sequence (similarly set) comprehension refers to the construction of a sequence by generation based on another sequence, of the form: [expr (x) : x in S j pred (x)] Sequences can also be constructed by enumeration.
Reference: [SHT + 92] <author> J. P. Singh, C. Holt, T. Totsuka, A. Gupta, and J. L. Hennessy, </author> <title> "Load balancing and data locality in hierarchical N-body methods," </title> <type> Technical Report CSL-TR-92-505, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: There are implementations of adaptive partitioning and scheduling mechanisms which make explicit at a lower-level the recognition of this work distribution in adaptive N-body simulation <ref> [SHT + 92] </ref>. By specifying at a high-level this anticipated work distribution, the rate construct provides a flexible abstraction for controlling computational effort.
Reference: [Ski90] <author> D. Skillicorn, </author> <title> "Architecture-independent parallel computation," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, </volume> <pages> pp. 38-50, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Much attention has turned towards program transformation as a natural approach to bridge this gap, for example in the efforts of the Crystal equational language [CCL91], variants of Bird-Meertens functional formalism <ref> [Ski90] </ref>, the NESL nested data-parallel language [Ble92], and z This work was supported under DARPA / SISTO contracts N00014-88-K-0458, N00014-91-J-1985, N00014-91-C-0114 administered through ONR, NASA subcontract 550-63 of prime contract NAS5-30428, US-Israel Binational NSF Grant 88-00282/2, and NSF Grant NSF-IRI-91-00681. Proteus [MNPR92, PP93].
Reference: [Ski91] <author> D. Skillicorn, </author> <title> "Models for practical parallel computation," </title> <journal> International Journal of Parallel Programming, </journal> <volume> vol. 20, no. 2, </volume> <pages> pp. 133-158, </pages> <year> 1991. </year>
Reference-contexts: And so it is important to strike a careful balance between being sufficiently abstract to be simple and machine-independent, yet detailed enough to reflect realistic properties such as performance <ref> [Ski91] </ref>. For example, considerations of data locality are difficult yet desirable to address abstractly since they can strongly affect performance.
Reference: [Smi90] <author> D. R. Smith, </author> <title> "KIDS a semi-automactic program development system," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 16, </volume> <pages> pp. 1024-1043, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Actual parallel execution can be achieved by program transformations which place it in a restricted form that can be translated directly to a low-level machine-specific parallel language. The source-to-source transformations and translation can be managed semiautomatically by the analysis and theorem-proving capabilities of KIDS (Kestrel Interactive Development System) <ref> [Ref88, Smi90] </ref>. For example, we have investigated refinement strategies that transform a broad class of high-level data parallel operations over sequences into the widely portable vector language CVL.
References-found: 23

