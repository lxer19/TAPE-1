URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-064.ps
Refering-URL: http://www-ccsl.cs.umass.edu/~barrett/publications.html
Root-URL: 
Abstract-found: 0
Intro-found: 1
Reference: [App94] <author> Apple Computer, Inc. </author> <title> OpenDoc for Macintosh: An overview for developers. </title> <type> White paper, </type> <institution> Apple Computer, </institution> <year> 1994. </year>
Reference-contexts: That is, data stored in the database via one API cannot be accessed via another. Compound documents: Microsoft's OLE [Bro94] and Apple's OpenDoc <ref> [App94] </ref> support interoperability by allowing objects, called compound documents, to contain or refer (point) to other objects. For example, a Microsoft Word document can contain a reference to an Excel spreadsheet object, and when the object is accessed, the operations invoked on it are automatically routed to Excel.
Reference: [AR94] <author> Joshua S. Auerbach and James R. Russell. </author> <title> The Concert signature representation: IDL as intermediate language. </title> <journal> ACM SigPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 1-12, </pages> <month> August </month> <year> 1994. </year> <booktitle> From the Proceedings of the ACM Workshop on Interface Definition Languages, </booktitle> <year> 1994. </year> <institution> Originally IBM Research Report RC19229. </institution>
Reference-contexts: In this sense, our approach to polylingual systems may be thought of as a generalization of subject-oriented programming, since (as shall be described in Section 4) each language has its own interface to an object, with the selection of interface handled automatically when the object is accessed. Concert <ref> [AR94] </ref> is a system that uses an extended C language, called Concert/C, to support interoperability. Like the CORBA-style approaches, Concert uses an intermediate interface language; but unlike CORBA and ILU, Concert's interfaces are automatically generated.
Reference: [Aue96] <author> Joshua S. </author> <title> Auerbach. </title> <type> Personal communication, </type> <month> March </month> <year> 1996. </year>
Reference-contexts: So Concert eliminates the need for a human-created wrapper, at the cost of extending the programming language a cost not incurred by our approach. Although Concert supports only C and C++, a successor to Concert, called Mockingbird <ref> [Aue96] </ref>, is intended to provide interoperability between C++, Java, CORBA IDL, and other languages. 3.2 Example Application of a CORBA-style Approach We now describe an application of a representative approach to a specific interoperability problem in the Frank Lloyd example.
Reference: [BN84] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: The object code modules of p and s are linked, and the foreign function call is accomplished within a single address space. For calling across address spaces, remote procedure calls <ref> [BN84] </ref> have been extended to cross language boundaries (e.g., [MHO96]).
Reference: [Bro94] <author> Kraig Brockschmidt. </author> <title> Ole integration technologies technical overview. World Wide Web URL http://www.microsoft.com/TechNet/technol /ole/ddjole.htm, </title> <month> October </month> <year> 1994. </year> <title> Adapted from an article appearing in Dr. </title> <journal> Dobbs Journal, </journal> <month> December </month> <year> 1994. </year>
Reference-contexts: Object-oriented databases, such as the TI/Arpa Open OODB [WBT92], allow accessors to create and access objects using their own language's type model, but typically no facilities are provided for interoperability. That is, data stored in the database via one API cannot be accessed via another. Compound documents: Microsoft's OLE <ref> [Bro94] </ref> and Apple's OpenDoc [App94] support interoperability by allowing objects, called compound documents, to contain or refer (point) to other objects.
Reference: [BS92] <author> B. W. Boehm and W. L. Scherlis. Megapro-gramming. </author> <booktitle> In Proceedings of the DARPA Software Technology Conference, </booktitle> <pages> pages 63-82, </pages> <address> Los Angeles, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: this case, it is desirable that legacy module A need not be modified; but unless A was designed with future interoperability in mind, this is unlikely. 3 Our approach to automated support for interoperability in polylingual systems addresses the third and most difficult of the three scenarios, sometimes called megaprogram-ming <ref> [BS92, WWC92] </ref>. Since both A and B exist, we want to modify them as little as possible to make them interoperate. Our approach allows A and B to interoperate with no modifications visible to the developer nor the modules.
Reference: [ClPCC + 93] <institution> Digital Equipment Corporation, Hewlett Packard Company, HyperDesk Corporation, NCR Corporation, </institution> <note> Object Design, </note> <author> Inc., and SunSoft, Inc. </author> <title> The Common Object Request Broker: Architecture and Specification. Object Management Group and X/Open, 1993. Revision 1.2, incorporated as part of CORBA 2.0. </title>
Reference-contexts: Multilingual interoperability may be achieved, for example, by using heterogeneous remote procedure calls, while polylingual interoperability can be realized by enforcing the use of a common, foreign type model among the modules (e.g., as in CORBA <ref> [ClPCC + 93] </ref>). If developers of a multi-language software system need not be aware of language differences between the software modules, we call the interoperability approach seamless. <p> CORBA-style approaches: While the preceding classes of approaches focus on interlanguage invocation, CORBA-style approaches have emphasized the type compatibility dimension. They require all interoperating software modules to adhere to a single type model, separate from that of the modules' languages. This approach is typified by CORBA <ref> [ClPCC + 93] </ref> and ILU [JSS95]. Software modules are considered to be of two kinds: objects, which provide public interfaces, and clients, which invoke the methods of objects.
Reference: [HO93] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 411-428, </pages> <month> October </month> <year> 1993. </year> <journal> Published as ACM SIGPLAN Notices volume 28, </journal> <volume> number 10. </volume>
Reference-contexts: Hence, while they may provide or encapsulate all the subcomponents in our model, these approaches also fall far short of seamlessness. Languages and language extensions: The subject-oriented programming paradigm <ref> [HO93] </ref> permits objects to be accessed via more than one public interface. Each accessor can potentially use a different interface to access the same object.
Reference: [JS94] <author> Bill Janssen and Mike Spreitzer. </author> <title> ILU: Inter-language unification via object modules. </title> <booktitle> In Workshop on Multi-Language Object Models, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1994. </year> <note> (in conjunction with OOPSLA'94). </note>
Reference-contexts: Specifically, we illustrate the use of a particular CORBA-style approach, namely the Inter-Language Unification (ILU) system, an interoperability mechanism developed at Xerox PARC <ref> [JS94] </ref>. 3.2.1 An Example Scenario in Frank Lloyd As noted earlier, a potential interoperability problem for the new Frank Lloyd company might involve an application that assigns office space based on information contained in personnel data.
Reference: [JSS95] <author> Bill Janssen, Denis Severson, and Mike Spre-itzer. </author> <title> ILU Reference Manual. </title> <institution> Xerox Corporation, </institution> <address> Palo Alto, CA, 1.8 edition, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: They require all interoperating software modules to adhere to a single type model, separate from that of the modules' languages. This approach is typified by CORBA [ClPCC + 93] and ILU <ref> [JSS95] </ref>. Software modules are considered to be of two kinds: objects, which provide public interfaces, and clients, which invoke the methods of objects. These objects may be written in numerous languages, but a wrapper must be created for each object before it can be accessed by clients.
Reference: [Kap96] <author> Alan Kaplan. </author> <title> Name Management: Models, Mechanisms and Applications. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: The key component of PolySPIN is a language-neutral name management mechanism that allows for uniform name-based access to objects <ref> [Kap96] </ref>. This mechanism supports, but does not require, a uniform model of orthogonal persistence (see [WWFT88] for an overview) and/or transparent polylin-gual interoperability. The interoperability aspects of PolySPIN supplement the name management component (locator) with communicator, type matcher and language arbiter functionality, all of which are transparent to accessors.
Reference: [KW96] <author> Alan Kaplan and Jack Wileden. </author> <title> Toward painless polylingual persistence. </title> <booktitle> In Seventh International Workshop on Persistent Object Systems, </booktitle> <address> Cape May, NJ, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: In this section we outline our approach and describe the toolset that automates its use. 4.1 PolySPIN PolySPIN is an approach to Support for Persistence, Interoperability and Naming in POLYlingual systems <ref> [KW96] </ref>. The key component of PolySPIN is a language-neutral name management mechanism that allows for uniform name-based access to objects [Kap96]. This mechanism supports, but does not require, a uniform model of orthogonal persistence (see [WWFT88] for an overview) and/or transparent polylin-gual interoperability. <p> PolySPIN-ner currently produces code based on constructs provided by PolySPIN <ref> [KW96] </ref> and the foreign function interface mechanisms of C++ and CLOS. The specifics of these constructs are beyond the scope of the paper (for details see [KW96]). for the Salary methods. (Similar code would be generated for the YearsOfService methods.) When the Salary method is invoked on an object, the method <p> PolySPIN-ner currently produces code based on constructs provided by PolySPIN <ref> [KW96] </ref> and the foreign function interface mechanisms of C++ and CLOS. The specifics of these constructs are beyond the scope of the paper (for details see [KW96]). for the Salary methods. (Similar code would be generated for the YearsOfService methods.) When the Salary method is invoked on an object, the method first checks the defining language of the object.
Reference: [MHO96] <author> Mark J. Maybee, Dennis H. Heimbigner, and Leon J. Osterweil. </author> <title> Multilanguage interoperability in distributed systems. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The object code modules of p and s are linked, and the foreign function call is accomplished within a single address space. For calling across address spaces, remote procedure calls [BN84] have been extended to cross language boundaries (e.g., <ref> [MHO96] </ref>). Both foreign function calls and remote procedure calls represent relatively low-level approaches to interoperability, and as a result they are generally far from seamless because application programmers frequently must deal with details of parameter marshalling and because complex data types (pointer-based data structures, ADTs) are not supported.
Reference: [Pur94] <author> James M. Purtilo. </author> <title> The Polylith software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: In order to apply this approach to older procedural languages that do not support encapsulation, such as C and FORTRAN, some mechanism like that provided by Polylith <ref> [Pur94] </ref> would be needed for associating operations with datatypes. 3 Existing Approaches to Interoperability A variety of approaches to interoperability have been developed over the years [WWRT91]. Existing approaches tend to fall short of our goal of supporting seamless interoperability in polylingual systems, however. <p> Messaging systems: Some systems accomplish interoperability by allowing software modules to send messages to each other or to a central message server that routes messages to their intended recipients. Well-known examples are FIELD [Rei90] and Polylith <ref> [Pur94] </ref>. These systems primarily support interlanguage invocation and may also offer some, typically primitive, assistance with interlanguage naming. They seldom, however, provide much support for the remaining dimensions of language information and type compatibility.
Reference: [Rei90] <author> Steven P. Reiss. </author> <title> Connecting tools using message passing in the FIELD environment. </title> <journal> IEEE Software, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: Messaging systems: Some systems accomplish interoperability by allowing software modules to send messages to each other or to a central message server that routes messages to their intended recipients. Well-known examples are FIELD <ref> [Rei90] </ref> and Polylith [Pur94]. These systems primarily support interlanguage invocation and may also offer some, typically primitive, assistance with interlanguage naming. They seldom, however, provide much support for the remaining dimensions of language information and type compatibility.
Reference: [SL90] <author> Amit P. Sheth and James A. Larson. </author> <title> Federated database systems for managing distributed, heterogeneous, and autonomous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <month> September </month> <year> 1990. </year> <month> 8 </month>
Reference-contexts: The Parser PolySPINner's generic Parser component is responsible for managing the parsing of type definitions into PolySPINner's language-independent intermediate representation. In its current form, this intermediate representation 6 As noted in section 2.3, full discussion of database merging issues, such as semantic heterogeneity <ref> [SL90] </ref>, is beyond the scope of this paper. is fairly straightforward, consisting of abstract data types for object types, methods, and parameters. We intend to adopt a more powerful intermediate representation in the near future and are currently examining alternatives in the literature.
Reference: [WBT92] <author> David L. Wells, Jose A. Blakely, and Craig W. Thompson. </author> <title> Architecture of an open object-oriented database management system. </title> <journal> IEEE Computer, </journal> <volume> 25(10) </volume> <pages> 74-82, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In particular, shared objects must be created within the database's type model, usually different from a given language's type model, and the database's query language must be used when accessing those objects. Object-oriented databases, such as the TI/Arpa Open OODB <ref> [WBT92] </ref>, allow accessors to create and access objects using their own language's type model, but typically no facilities are provided for interoperability. That is, data stored in the database via one API cannot be accessed via another. <p> In this paper, we have described the PolySPIN approach and PolySPINner toolkit for automating seamless interoperability in polylingual systems. Since this approach evolved from work on name management in persistent object systems, our prototype toolset relies upon features of the Open Object-Oriented Database (Open OODB) <ref> [WBT92] </ref> and exploits inheritance of name management-associated capabilities in implementing seamless interoperability. The approach, however, does not depend on Open OODB, persistence in general, nor inheritance, so we plan to explore alternative implementation strategies that will broaden the applicability of our toolset.
Reference: [WWC92] <author> Gio Wiederhold, Peter Wegner, and Stefano Ceri. </author> <title> Toward megaprogramming. </title> <journal> Communications of the ACM, </journal> <volume> 35(11) </volume> <pages> 89-99, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: this case, it is desirable that legacy module A need not be modified; but unless A was designed with future interoperability in mind, this is unlikely. 3 Our approach to automated support for interoperability in polylingual systems addresses the third and most difficult of the three scenarios, sometimes called megaprogram-ming <ref> [BS92, WWC92] </ref>. Since both A and B exist, we want to modify them as little as possible to make them interoperate. Our approach allows A and B to interoperate with no modifications visible to the developer nor the modules.
Reference: [WWFT88] <author> J.C. Wileden, A.L. Wolf, C.D. Fisher, and P.L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent typed object management. </title> <booktitle> In Proceedings of the Third Symposium of Software Development Environments, </booktitle> <pages> pages 130-142, </pages> <month> Septem-ber </month> <year> 1988. </year>
Reference-contexts: The key component of PolySPIN is a language-neutral name management mechanism that allows for uniform name-based access to objects [Kap96]. This mechanism supports, but does not require, a uniform model of orthogonal persistence (see <ref> [WWFT88] </ref> for an overview) and/or transparent polylin-gual interoperability. The interoperability aspects of PolySPIN supplement the name management component (locator) with communicator, type matcher and language arbiter functionality, all of which are transparent to accessors. Language information (language arbiter) is associated with objects as part of the name-object binding.
Reference: [WWRT91] <author> Jack C. Wileden, Alexader L. Wolf, William R. Rosenblatt, and Peri L. Tarr. </author> <title> Specification level interoperability. </title> <journal> Communications of the ACM, </journal> <volume> 34(5) </volume> <pages> 73-87, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: apply this approach to older procedural languages that do not support encapsulation, such as C and FORTRAN, some mechanism like that provided by Polylith [Pur94] would be needed for associating operations with datatypes. 3 Existing Approaches to Interoperability A variety of approaches to interoperability have been developed over the years <ref> [WWRT91] </ref>. Existing approaches tend to fall short of our goal of supporting seamless interoperability in polylingual systems, however. In this section, we describe several major categories of existing approaches in terms of our four dimensions of interoperability, and assess their effectiveness in achieving seamlessness.
Reference: [ZW93] <author> Amy Moormann Zaremski and Jeannette M. Wing. </author> <title> Signature Matching: A Key to Reuse. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 182-190, </pages> <month> December </month> <year> 1993. </year> <note> Also appeared as Carnegie-Mellon technical report CMU-CS-93-151. 9 </note>
Reference-contexts: Such strictness is unrealistic, however, since interoperability is often desired between software modules whose types are nearly but not exactly equivalent. More lenient, or relaxed , matching criteria, are more realistic and useful. Zaremski and Wing <ref> [ZW93] </ref> have constructed a taxonomy of relaxed type matching criteria within the language ML. Using polylingual system concepts, we have created a prototype extension of their taxonomy that models matching across languages, and PolySPINner currently supports these (and other) matching criteria.
References-found: 21

