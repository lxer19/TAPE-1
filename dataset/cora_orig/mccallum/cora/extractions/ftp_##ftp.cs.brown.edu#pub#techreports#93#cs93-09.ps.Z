URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-09.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-09.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abiteboul and Kanellakis. </author> <title> Object identity as a query language primitive. </title> <editor> In Bruce Lindsay James Clifford and David Maier, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data. </booktitle> <publisher> ACM Press, </publisher> <address> Port-land, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: EXCESS [31]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [12, 5]) choose to support only objects in the type system and to model values as a special case of objects. IQL (see <ref> [1] </ref>) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [2] <author> S. Abiteboul, E. Simon, and V. Vianu. </author> <title> Non deterministic languages to express deterministic transformations. </title> <booktitle> In Proceedings of the Ninth ACM SIGACT/SIGMOD Symposium on Prin ciples of Database Systems, </booktitle> <address> Nashville, Tennesee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: A set-theoretic choose operator appears in the algebras of Osborne and MDM (see [22, 23]). Non-determinism is also present in <ref> [2] </ref>, which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism.
Reference: [3] <author> Antonio Albano, Giorgio Ghelli, and Renzo Orsini. </author> <title> Objects for a database programming lan guage. </title> <booktitle> In Kanellakis and Schmidt [16], </booktitle> <pages> pages 236-253. </pages>
Reference-contexts: AQUA can, of course, emulate these features of Postgres and EXCESS. The use of a type constructor to represent abstraction enables all objects in an AQUA database to exist in one seamless type system. Our approach is similar to that of <ref> [3] </ref>, but in their model not everything is an object, so their equivalent to our abstraction constructor must enforce many more of the facets of "objectness" than must ours. Several of our operators resemble operators of ENCORE/EQUAL, EXTRA/EXCESS, and Revelation. See Section 5 for detailed descriptions of the operators.
Reference: [4] <author> M. P. Atkinson, C. Lecluse, P. Philbrow, and P. Richard. </author> <title> Design issues in a map language. </title> <booktitle> In Kanellakis and Schmidt [16], </booktitle> <pages> pages 20-32. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [27, 22, 11] and the modeling of bulk types <ref> [4, 25, 19] </ref>. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here. <p> Unlike ILOG (see [14]) and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and re flecting the distinctions between objects and values by using varying semantics (see Section 3.3). It has been pointed out by Atkinson et al (see <ref> [4] </ref>) that in object-oriented systems, a type may supply its own method for testing equality. This capability, however, introduces problems such as what is the meaning of operators like set union that depend on equality for their own semantics.
Reference: [5] <author> Jay Banerjee, Hong-Tai Chou, Jorge F. Garza, Won Kim, Darrell Woelk, Nat Ballou, and Hyoung-Joo Kim. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In attempting to support both values and objects, some systems (e.g. EXCESS [31]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [12, 5] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL (see [1]) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [6] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, </booktitle> <pages> pages 72-88, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: AQUA is intended to support large numbers of bulk types and to do so in a flexible, uniform way, such that the addition of other bulk types later on will be straightforward. <ref> [6] </ref> proposes a meta-level algebra for collections of complex objects with identity and also includes some transformation rules for optimization. This algebra, however, does not correspond to a specific data model but rather to a higher-level notion of collections of objects.
Reference: [7] <author> Val Breazu-Tannen, Peter Buneman, and Shamim Naqvi. </author> <title> Structural recursion as a query language. </title> <booktitle> In Kanellakis and Schmidt [16], </booktitle> <pages> pages 9-19. </pages>
Reference: [8] <author> Peter Buneman and Atsushi Ohori. </author> <title> A type sys tem that reconciles classes and extents. </title> <booktitle> In Kanel-lakis and Schmidt [16], </booktitle> <pages> pages 191-202. </pages>
Reference-contexts: We are not aware of another model that takes this approach, nor of one that takes the clearly-separated, 3-level view of an object that we do (type, semantics, and implementation; see Section 3.1). Buneman and Ohori (see <ref> [8] </ref>) exhibits a similar philosophy, though, in its distinction between a kind and a type.
Reference: [9] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A data model and query language for EXODUS. </title> <editor> In Haran Boral and Per ake Larson, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 413-423, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This is similar to Postgres's notion of user-defined Postquel functions and the functions and procedures of EXCESS <ref> [9] </ref>, but in those systems, 3 the ability to define functions allows one to add oper-ations to an existing, non-encapsulated type (i.e., encapsulation is not enforced in those systems but is in AQUA). AQUA can, of course, emulate these features of Postgres and EXCESS. <p> B) = fxjx 2 A and x 2 Bg diff (T )(A; B) = fxjx 2 A and :(x 2 B)g Table 2: Binary Set Operators Definition LFP (T; f )(A) = i=0 where f 0 (A) = ; Table 3: Least Fixed Point Operator ilar operators in the literature <ref> [9, 26, 30] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in addition to the original operators, that makes this approach more flexible than previous ones. <p> When combining two sets with a binary set operator, it is not necessary that they have the same type. It is sufficient that their elements have at least one common supertype, as the default equality of this supertype is used for comparison. So as in EXCESS <ref> [9] </ref>, these operators take an extra argument that specifies the type of the result, as discussed in subsection 4.2. The result type of union has to be a supertype of the types of the input sets.
Reference: [10] <author> Scott Daniels et al. </author> <title> Query Optimization in Rev elation, an Overview. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(2) </volume> <pages> 58-62, </pages> <month> June </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: If the two input sets were sets of lists, it could combine the two elements by concatenation, thereby producing a set of lists. AQUA is currently being used as the input language for two prototype extensible optimizers, Epoq at Brown University [21] and Revelation at OGI <ref> [10] </ref>.
Reference: [11] <author> Umeshwar Dayal, Frank Manola, Alejandro Buchmann, Upen Chakravarthy, David Gold-hirsch, Sandra Heiler, Jack Orenstein, and Arnon Rosenthal. </author> <title> Simplifying complex objects: The PROBE approach to modelling and querying them. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 390-399. </pages> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [27, 22, 11] </ref> and the modeling of bulk types [4, 25, 19]. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here.
Reference: [12] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk 80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In attempting to support both values and objects, some systems (e.g. EXCESS [31]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [12, 5] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL (see [1]) defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [13] <author> John V. Guttag, James J. Horning, and Jeanette M. Wing. </author> <title> The Larch family of speci fication languages. </title> <journal> IEEE Software, </journal> <volume> 2(5) </volume> <pages> 24-36, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Our characterization of the distinction between "objects" and "values" as the difference between entities (objects) with mutable and immutable semantics provides a much cleaner formalism, and was partially inspired by systems such as Larch <ref> [13] </ref>. By cleanly separating the notions of type (a syntactic concept) and semantics we provide a model that treats both values and objects as first-class citizens and has a simpler type system. <p> We use the symbols v and w to indicate subtype and supertype relationships between types. Functions have types, although our notation (described below) only allows the instantiation of particular functions. Type equivalence is by name. The semantics of a type might loosely be thought of as a Larch <ref> [13] </ref> specification, which axiomatically describes properties of the operations on a type. The particular language used for describing semantics is a topic of our current research. Specifying semantics separately from types allows different instances of the same type to have different behaviors.
Reference: [14] <author> Hull and Yoshikawa. </author> <title> ILOG: Declarative creation and manipulation of object identifiers. </title> <editor> In Den-nis McLeod, Ron Sacks-Davis, and Hans Schek, editors, </editor> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Eiffel [20] makes a distinction between reference and copy semantics, but not between mutable and immutable semantics. Unlike ILOG (see <ref> [14] </ref>) and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and re flecting the distinctions between objects and values by using varying semantics (see Section 3.3).
Reference: [15] <editor> IEEE. </editor> <booktitle> Proceedings of the Sixth Interational Con ference on Data Engineering, </booktitle> <address> Los Angeles, Cal-ifornia, February 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [16] <author> Paris Kanellakis and Joachim W. Schmidt, edi tors. </author> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [17] <author> G. M. Kuper. </author> <title> The Logical Data Model: A New Approach to Database Logic. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, Stanford University,, </institution> <address> Stan-ford, CA, </address> <month> Sept </month> <year> 1985. </year>
Reference-contexts: EXTRA/EXCESS also attempts to support a large number of bulk types, but does not explicitly provide sets (they are provided only by eliminating duplicates from multisets). The inclusion of a union type is not new (see <ref> [17] </ref>), but we provide it with a clean algebraic interface using both tagcase and typecase constructs to be fully general.
Reference: [18] <author> David Maier, Jacob Stein, Allen Otis, and Alan Purdy. </author> <title> Development of an object-oriented dbms. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 472-482, </pages> <address> Portland, Oregon, </address> <month> September-October </month> <year> 1986. </year>
Reference: [19] <author> Florian Matthes and Joachim W. Schmidt. </author> <title> Bulk types: </title> <booktitle> Built-in or add-on? In Kanellakis and Schmidt [16], </booktitle> <pages> pages 33-53. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [27, 22, 11] and the modeling of bulk types <ref> [4, 25, 19] </ref>. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here. <p> The inclusion of a union type is not new (see [17]), but we provide it with a clean algebraic interface using both tagcase and typecase constructs to be fully general. The impor 2 tance of being flexible about the addition of new bulk types has been established (see <ref> [19] </ref>); the modularity of the AQUA approach facilitates this to an extent by following a rationale similar to that of Rozen and Shasha (see [25]) in several respects. In attempting to support both values and objects, some systems (e.g.
Reference: [20] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Con struction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference-contexts: C++ [28] has a notion of "const" that is similar to our notion of "immutable", but in C++ this notion is part of the type system, and thus causes a variety of problems that motivated us to separate type and semantics. Eiffel <ref> [20] </ref> makes a distinction between reference and copy semantics, but not between mutable and immutable semantics.
Reference: [21] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An Architecture for Query Processing in Persistent Object Stores. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 787-798, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: If the two input sets were sets of lists, it could combine the two elements by concatenation, thereby producing a set of lists. AQUA is currently being used as the input language for two prototype extensible optimizers, Epoq at Brown University <ref> [21] </ref> and Revelation at OGI [10].
Reference: [22] <author> S. Osborn. </author> <title> Identity, equality, and query opti mization. </title> <editor> In K. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems. </booktitle> <address> Berlin, Ger-many, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [27, 22, 11] </ref> and the modeling of bulk types [4, 25, 19]. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here. <p> A set-theoretic choose operator appears in the algebras of Osborne and MDM (see <ref> [22, 23] </ref>). Non-determinism is also present in [2], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism.
Reference: [23] <author> Joel Richardson and Peter Schwarz. </author> <title> MDM: An object-oriented data model. </title> <booktitle> In Kanellakis and Schmidt [16], </booktitle> <pages> pages 86-95. </pages>
Reference-contexts: Many models (e.g. MDM <ref> [23] </ref>) do not have this flexibility. Most "pure" object-oriented models ([12, 18], and others) provide and enforce encapsulation of data types. <p> AQUA's dup elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL [26]). Our binary join operation is similar to the n-ary Image operator of MDM <ref> [23] </ref>, but differs from it in that we separate the join predicate from the function to be applied to matching pairs; the idea of this is to enhance optimization by making certain queries (e.g. equijoins) easier to recognize. <p> A set-theoretic choose operator appears in the algebras of Osborne and MDM (see <ref> [22, 23] </ref>). Non-determinism is also present in [2], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism.
Reference: [24] <author> L. Rowe and M. Stonebraker. </author> <title> The postgres data model. </title> <booktitle> In Proceedings of the Thirteenth Very Large Databases Conference. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <year> 1987. </year>
Reference-contexts: But AQUA does support such types, and does so using the "abstraction" type constructor, allowing any database object to be described using a single uniform type system. This is similar to the ADT concept provided by Post-gres <ref> [24] </ref>, but more general in the sense that any type definable in the AQUA type system can be abstracted into a true encapsulated type, and an abstraction in AQUA is a first-class citizen of the type system - the abstraction constructor has the same status as any other constructor.
Reference: [25] <author> Steve Rozen and Dennis Shasha. </author> <title> Rationale and design of bulk. </title> <booktitle> In Kanellakis and Schmidt [16], </booktitle> <pages> pages 71-85. </pages>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras [27, 22, 11] and the modeling of bulk types <ref> [4, 25, 19] </ref>. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here. <p> The impor 2 tance of being flexible about the addition of new bulk types has been established (see [19]); the modularity of the AQUA approach facilitates this to an extent by following a rationale similar to that of Rozen and Shasha (see <ref> [25] </ref>) in several respects. In attempting to support both values and objects, some systems (e.g. EXCESS [31]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g.
Reference: [26] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> A query algebra for object-oriented databases. </title> <booktitle> In Proceedings of the Sixth Interational Conference on Data Engineering [15], </booktitle> <pages> pages 152-162. </pages>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [26, 30, 31] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [31], ENCORE/EQUAL <ref> [26] </ref>, and Revelation [30]. <p> Dup elim for both sets and multisets (as we've defined it) and convert appear to be original to this model, with dup elim being by far the more interesting. AQUA's dup elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL <ref> [26] </ref>). <p> B) = fxjx 2 A and x 2 Bg diff (T )(A; B) = fxjx 2 A and :(x 2 B)g Table 2: Binary Set Operators Definition LFP (T; f )(A) = i=0 where f 0 (A) = ; Table 3: Least Fixed Point Operator ilar operators in the literature <ref> [9, 26, 30] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in addition to the original operators, that makes this approach more flexible than previous ones.
Reference: [27] <author> David D. Straube and M Tamer Ozsu. </author> <title> Queries and query processsing ing object-oriented database systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 8(4), </volume> <month> Oct </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Recently, a great deal of work has been done on the topic of object-oriented query algebras <ref> [27, 22, 11] </ref> and the modeling of bulk types [4, 25, 19]. These proposals as well as those of other researchers on the topic have explored some of the fundamental issues and provided the starting point for the work reported here. <p> Also, the decision to make the boolean operators (and, or, and not) full-fledged algebra operators, rather than constructs available only in certain parts of the language (e.g. predicates), as in the relational algebra, EXCESS, and Straube's algebra (see <ref> [31, 27] </ref>), adds to the flexibility of the algebra. Finally, the type parameter to union, difference, and intersection is similar to that used in EXCESS. 3 The AQUA Data Model The AQUA data model is founded on the notions of strong typing and abstract data types.
Reference: [28] <author> B. Stroustrup. </author> <title> The C++ Programming Lan guage. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Buneman and Ohori (see [8]) exhibits a similar philosophy, though, in its distinction between a kind and a type. C++ <ref> [28] </ref> has a notion of "const" that is similar to our notion of "immutable", but in C++ this notion is part of the type system, and thus causes a variety of problems that motivated us to separate type and semantics.
Reference: [29] <author> Bharathi Subramanian, Stanley B. Zdonik, Theodore W. Leung, and Scott L. Vandenberg. </author> <title> Ordered types in the aqua data model. </title> <type> Technical Report CS-93-10, </type> <institution> Department of Computer Science, Brown University, </institution> <year> 1993. </year> <note> Submitted for publication. </note>
Reference-contexts: The presentation in this paper covers two bulk types, sets and multisets. The discussion of more complex, ordered types is beyond the scope of this paper <ref> [29] </ref>. Some of the operators that one would expect to find in any algebra appear in AQUA as well. They have, however, been generalized to deal with many data models and many possible bulk types. <p> Lists, trees, and graphs are not discussed further here; see <ref> [29] </ref> for a complete description of them. N-dimensional arrays are a subject of our future research. Abstractions, tuples and unions are subtypable. Functions are subtypable using the standard con-travariance rule. <p> This paper has discussed algebraic operators for the Set and the Multiset types. We also propose an extension to AQUA to include algebraic operators for other bulk types such as List, Tree, and Graph <ref> [29] </ref>. Acknowledgements Thanks to: Catriel Beeri, DARPA, Leo Fegaras, David Maier, Scott Meyers, and Hagit Shatkay.
Reference: [30] <author> B. Vance. </author> <title> Towards an object-oriented query al gebra. </title> <type> Tech. Report CS/E91-008, </type> <institution> Dept. of Com puter Science and Eng., Oregon Graduate Institute, Beaverton, </institution> <address> OR, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [26, 30, 31] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [31], ENCORE/EQUAL [26], and Revelation <ref> [30] </ref>. <p> B) = fxjx 2 A and x 2 Bg diff (T )(A; B) = fxjx 2 A and :(x 2 B)g Table 2: Binary Set Operators Definition LFP (T; f )(A) = i=0 where f 0 (A) = ; Table 3: Least Fixed Point Operator ilar operators in the literature <ref> [9, 26, 30] </ref> and exceptions are noted as they arise. It is our combination and utilization of them, in addition to the original operators, that makes this approach more flexible than previous ones.
Reference: [31] <author> S. Vandenberg and D. DeWitt. </author> <title> Algebraic sup port for complex objects with arrays, identity, and inheritance. </title> <editor> In James Clifford and Roger King, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous algebras <ref> [26, 30, 31] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the overarching goal for this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system <ref> [31] </ref>, ENCORE/EQUAL [26], and Revelation [30]. <p> In attempting to support both values and objects, some systems (e.g. EXCESS <ref> [31] </ref>) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [12, 5]) choose to support only objects in the type system and to model values as a special case of objects. <p> Also, the decision to make the boolean operators (and, or, and not) full-fledged algebra operators, rather than constructs available only in certain parts of the language (e.g. predicates), as in the relational algebra, EXCESS, and Straube's algebra (see <ref> [31, 27] </ref>), adds to the flexibility of the algebra. Finally, the type parameter to union, difference, and intersection is similar to that used in EXCESS. 3 The AQUA Data Model The AQUA data model is founded on the notions of strong typing and abstract data types.
References-found: 31

