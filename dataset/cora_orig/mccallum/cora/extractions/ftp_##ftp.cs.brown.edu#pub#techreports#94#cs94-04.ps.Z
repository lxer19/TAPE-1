URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-04.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-04.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [Copl92] <author> Advanced C++, </author> <title> Programming Styles and Idioms, </title> <editor> James O. Coplien, </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1992. </year>
Reference-contexts: These alternatives are the following. First we modelled a goal as a name, i.e. a text string. This name is mapped to a goalpackage. The success, prune and bestChoice functions were modelled as functor classes <ref> [Copl92] </ref>. A functor is a class that has a behaviour like a function and that is used just like you would use a function. Still you can sub class it to change the behaviour. <p> We distinguish between the public and protected interface of the classes because this document is also meant to be of help to anybody making subclasses for optimizers. All the classes have been designed using the Orthodox Canonical Class Form <ref> [Copl92] </ref>. If classes are designed according to this form, their instances can be assigned, declared, and passed as arguments just like any C++ variable.
Reference: [JoFo88] <editor> Designing Reusable Classes, Ralph E. Johnson, </editor> <title> Brian Foote, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> Vol. 1, No. 2, </volume> <pages> pp. 22-31, </pages> <year> 1988. </year>
Reference: [Lo92] <author> Query Tree Interface, </author> <title> Report on OODB Query Optimizer, by George C. </title> <type> Lo, </type> <institution> Brown Univer sity, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: If the Region wants to remove the entry in the Log, it can just call the function Abort (Region& unsuccessfulSu-bregion). 3.2 EREQ Query Representation The work on a query representation for this project started in 1992 when a parser and tree builder for the ENCORE Query Language was built <ref> [Lo92] </ref>. The representation was called qTree and was implemented in C. MacKeith was making a cost model for the optimizer, and he needed an updated query representation which included cost annotations. <p> This includes C files OptRepMeta.C, OptRep.C, OptRepCost.C. makeRep.C, costExp.C, costTest.C. Makefile for compilations of makeRep, libOptRep.a, costExp, costTest. This directory also includes test output, executables of the test drivers and copies of certain altair database input files. Files relating to the gcl representation <ref> [Lo92] </ref> are in directory EPOQHOME/epoq/rep/RepLib/. This contains the older version of the library, named libRep.a, which is now included in libOptRep.a. The header file OptRepIntRep.h, which contains enums for the operators etc. is in this directory, and is included in the .H files. <p> The directory EPOQHOME/regions contains two test regions and test drivers in three separate directories. The directory exodus-region contains header and C-files for a class Exodus that has been subclassed from Region. The library for the optimizer generated from Exodus <ref> [Lo92] </ref> is also placed here in addition to the c-source files and include files in two separate sub-directories. The directory join-region contains header and C-files for a class Join-region and necessary header-files and c-source code for the join-region described in [Tan 92]. <p> Thereafter the next goal is tried. In this simple case no attempt is made to re-plan while this activity is taking place. The leaf regions are simple transformations. When called they merely call an existing optimizer, one generated by the Exodus Optimizer Generator <ref> [Lo92] </ref> and one which tries to identify and insert hidden joins in a query [Tan92]. The two regions were named the Exodus and Join Region, respectively. Both these optimizers where implemented using an old query representation [Lo92], so these regions had to transform a query from the EREQ query representation to <p> called they merely call an existing optimizer, one generated by the Exodus Optimizer Generator <ref> [Lo92] </ref> and one which tries to identify and insert hidden joins in a query [Tan92]. The two regions were named the Exodus and Join Region, respectively. Both these optimizers where implemented using an old query representation [Lo92], so these regions had to transform a query from the EREQ query representation to this old representation whenever called. When done, the optimizer reports whether the transformation was successful or not, i.e., whether the goal was attained or not. <p> The resulting implementation is not as general, and it is still a bit uncertain as to how useful it may be. 6.1.2 Query Representation The EREQ query representation [MacKe93] provides all the functionality of the old <ref> [Lo92] </ref> and some additional facilities. One major problem is the fact that the annotations are not typed. The reason why this solution was chosen, was to keep the representation as exible as possible, i.e., so that new types of annotations could be added.
Reference: [MacKe93] <editor> Query Representation and Cost Model, Andrew MacKeith, </editor> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction This paper describes the implementation of the EPOQ architecture. EPOQ is an extensible, object-oriented query optimizer. The overall design of the architecture is described in [Mitch93] and so is an algebra and a query representation for object-oriented queries. The implementation of this query representation is described in <ref> [MacKe93] </ref>. The EPOQ architecture communicates with the queries through a single interface, thus hiding the complexity of the query classes. Although this representation is not described here, some comments are made regarding the interaction with the representation. <p> We therefore had to make some modifications on the implementation of the working memory. The resulting implementation is not as general, and it is still a bit uncertain as to how useful it may be. 6.1.2 Query Representation The EREQ query representation <ref> [MacKe93] </ref> provides all the functionality of the old [Lo92] and some additional facilities. One major problem is the fact that the annotations are not typed.
Reference: [Mitch91] <editor> An Architecture for Query Processing in Persistent Object Stores. Gail Mitchell, Stanley B. Zdonik, Umeshwar Dayal, </editor> <booktitle> Proceedings of VLDB, </booktitle> <year> 1991. </year>
Reference: [Mitch93] <institution> Extensible Query Processing in an Object-Oriented Database. Doctoral Thesis by Gail Mitch-ell, Comp. Sci. Dept., Brown University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: 1 Introduction This paper describes the implementation of the EPOQ architecture. EPOQ is an extensible, object-oriented query optimizer. The overall design of the architecture is described in <ref> [Mitch93] </ref> and so is an algebra and a query representation for object-oriented queries. The implementation of this query representation is described in [MacKe93]. The EPOQ architecture communicates with the queries through a single interface, thus hiding the complexity of the query classes. <p> Maybe we will find that the differences between regions may be hidden in the goal packages. 3 Design In this section we identify the main classes of the framework, and describe their role in the optimizer. A typical scenario is described using these classes. This is taken from <ref> [Mitch93] </ref>. The description of the individual classes will then be outlined, and the way these classes interact with the query representation classes. In this section I call the query class just Query. There is nothing in the architecture itself that limits the way this is represented or implemented. <p> I only outline some requirements for this Query class. 3.1 The Model for the Architecture We have already given a short outline of the general behaviour of the optimizer.The descriptions of the architecture and the scenarios in <ref> [Mitch93] </ref> has been used to identify the classes. From this description we can extract the following set: 1. Region the optimizer is organized as a DAG of regions. Each Region has one or several goals that it can attain, or try to attain, on a particular query. <p> If it is used as a tool for the planning system, this might very well be so. The Regions merely use the GoalPackages to do the transformations. The solution to this problem is probably slightly different from what is described in <ref> [Mitch93] </ref>. If the attain function is empty in MetaStructure, it may simply be a call to an optimizer in LeafRegion, and its subregions. In InterGoalRegion, it may be a sequence of calls to some local functions, and they may be redefined in the subclasses whenever necessary. <p> One of the problems with the void* representation is that the data cannot be copied by a copy constructor, neither can the data be deleted by a destructor. 3.3 C++ Class descriptions The class and function names are kept as close as possible to the names used in <ref> [Mitch93] </ref>. A problem has been that different names have been used for the same phenomenon in different parts of the thesis. Another problem has been that something that at first seemed to be an object turned out to be a property of another class and this led to a redesign. <p> a pointer to the query that results from the execution a pointer to the Region that is used to attain the query the goal that is tried to be attained a success factor If the goal is not attained the Region returns NULL not the initial query as specified in <ref> [Mitch93] </ref>. <p> There is not a fixed set of fields or attributes describing an element, although the working memory restricts the number of fields to 100. Each field is a string. The only types of elements that was described in <ref> [Mitch93] </ref> were queries and ags. Queries are not stored in our implementation of working memory. We have not come up with any other types of working memory elements. For simplicity we have decided that the three first fields means type, name and value of element. <p> The planning system for EPOQ is described as a rule based system in <ref> [Mitch93] </ref>, and it had been considered using a rule based language to implement at least this part of the system. However, this was abandoned. <p> In <ref> [Mitch93] </ref> several types of equality operators are described, deep equality, i.e. all the nodes in the query tree are identical in content at any level, or equal i where the queries are the same to a level i in the tree. <p> Another reason was that we focused on the overall structure and did not have time to study in detail the parts in <ref> [Mitch93] </ref> where the planning activities are discussed. A set of scenarios should be used to verify the design and to build prototypes.
Reference: [OPS5] <editor> Rule-based Programming with OPS5, Thomas A. Cooper & Nancy Wogrin, </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Working memory is modelled after OPS5 <ref> [OPS5] </ref>. A working memory element is composed of a set of fields that together describe the element. There is not a fixed set of fields or attributes describing an element, although the working memory restricts the number of fields to 100. Each field is a string. <p> However, this was abandoned. The best solution might have been to use a multi-paradigm solution, i.e. implement the architecture using an object-oriented approach and the planning system using a rule-based approach. The description of the working memory was modelled after the OPS5 working memory <ref> [OPS5] </ref>. The reason was that the OPS5 working memory is very general when it comes to what it can store and how new types can be added on the y.
Reference: [Rumb91] <author> Object-Oriented Modeling and Design, J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. </author> <title> Lorensen, </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference: [Tan92] <institution> Identification and Transformation of Queries with Join operations in EQUAL, Peter Tan, Brown University, </institution> <year> 1992. </year>
Reference-contexts: The leaf regions are simple transformations. When called they merely call an existing optimizer, one generated by the Exodus Optimizer Generator [Lo92] and one which tries to identify and insert hidden joins in a query <ref> [Tan92] </ref>. The two regions were named the Exodus and Join Region, respectively. Both these optimizers where implemented using an old query representation [Lo92], so these regions had to transform a query from the EREQ query representation to this old representation whenever called.
Reference: [USL] <institution> Introduction to the C++ Standard Components, AT&T Bell Labs (distributed with the library). </institution>
References-found: 10

