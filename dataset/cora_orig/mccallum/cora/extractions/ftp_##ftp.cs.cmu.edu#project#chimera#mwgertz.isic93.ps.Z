URL: ftp://ftp.cs.cmu.edu/project/chimera/mwgertz.isic93.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/chimera/www/journal_pages/publications.html
Root-URL: 
Title: A SOFTWARE ARCHITECTURE-BASED HUMAN-MACHINE INTERFACE FOR RECONFIGURABLE SENSOR-BASED CONTROL SYSTEMS  
Author: Matthew W. Gertz, David B. Stewart, and Pradeep K. Khosla 
Address: Pittsburgh, Pennsylvania 15213  
Affiliation: Dept. of Electrical and Computer Engineering The Robotics Institute at Carnegie Mellon University  
Note: In Proceedings of 8th IEEE International Symposium on Intelligent Control, Aug. 25-26, 1993, Chicago, Ill.  
Abstract: The development of software for reconfigurable sensor-based real-time systems is a complicated and tedious process, requiring highly specialized skills in real-time systems programming. The total development time can be reduced by automatically integrating reusable software modules to create applications. The integration of these modules can be further simplified by the use of a high-level programming interface. We have developed Onika, an iconically programmed human-machine interface, to interact with a reconfigurable software framework to create reusable code. Onika presents appropriate work environments for both application engineers and end-users. For engineers, icons representing real-time software modules can be combined to form real-time jobs. For the end-user, icons representing these jobs are assembled by the user into applications. Onika verifies that all jobs and applications are syntactically correct, non-ambiguous, and complete. They can then be executed from within Onika, or can be saved as a stand-alone program which can be executed independently on the underlying real-time operating system. Onika has been fully integrated with the Chimera real-time operating system in order to control several different robotic systems in the Advanced Manipulators Laboratory at Carnegie Mellon University. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Myers, B. A. </author> <title> Taxonomies of Visual Programming and Program Visualization, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1990 (1), </volume> <pages> pp. 97-123. </pages>
Reference-contexts: We conclude this paper in section 5. 2. Previous Work The problems associated with textual programming have been addressed on several levels in the past. (Comprehensive reviews of the state of visual programming techniques can be found in <ref> [1] </ref> and [7].) Researchers have created interfaces wherein routines for an existing programming language (such as C) are created by a higher-level VPL [1][5][6]. Interfaces such as these are designed to be used by programmers with knowledge of the structured programming language in question.
Reference: [2] <author> Leifer, L., Van der Loos, M., and Lees, D. </author> <title> Visual Language Programming: for robot command-control in unstructured environments, </title> <booktitle> Proceedings of the Fifth International Conference on Advanced Robotics: Robots in Unstructured Environments, </booktitle> <month> June 19-22, </month> <year> 1991, </year> <pages> pp. 31-36, </pages> <address> Pisa, Italy. </address>
Reference-contexts: Proc-BLOX [5], a lower-level VPL, allows users to create Pascal-like code by assembling blocks representing the textual code primitives in a jigsaw puzzle fashion. The shapes of the elements preclude the possibility of assembling syntactically incorrect programs. Other packages such as Lingraphica <ref> [2] </ref> and ISHeE [3] remove the text altogether and rely on pictures to determine the meaning of the program. ISHeE also uses the jigsaw puzzle format to convey syntax.
Reference: [3] <author> Mussio, P., Pietrogrande, M., Protti, M., Colombo, F., Finadri, M., and Gentini, P. </author> <title> Visual Programming in a Visual Environment for Liver Simulation Studies, </title> <booktitle> 1990 IEEE Workshop on Visual Languages, </booktitle> <month> Oct. </month> <pages> 4-6, </pages> <year> 1990, </year> <pages> pp. 29-35, </pages> <address> Skokie, Illinois. </address>
Reference-contexts: Proc-BLOX [5], a lower-level VPL, allows users to create Pascal-like code by assembling blocks representing the textual code primitives in a jigsaw puzzle fashion. The shapes of the elements preclude the possibility of assembling syntactically incorrect programs. Other packages such as Lingraphica [2] and ISHeE <ref> [3] </ref> remove the text altogether and rely on pictures to determine the meaning of the program. ISHeE also uses the jigsaw puzzle format to convey syntax. By making the visual representations more compact, more of the program under development can be seen on the screen at a time. 3.
Reference: [4] <author> Ichikawa, T. and Hirakawa, H. </author> <title> Visual Programming Toward Realization of User-Friendly Programming Environments, </title> <booktitle> Proceedings 2nd Fall Joint Computer Conference, </booktitle> <year> 1987, </year> <pages> pp. 129-137. </pages>
Reference-contexts: Flow charts reduce the complexity of textual code somewhat, but can still be quite cryptic and do not efficiently use screen space. Occasionally, pictures accompany or are used in place of the text (as in Pict [6] or HI-VISUAL <ref> [4] </ref>) within a flowchart, but this does not help to give syntactic clues for programming. Nassi-Schneiderman flowcharts, used primarily for lower-level programming, are more compact than traditional flowcharts and have an implied syntax. They can be textually cryptic and difficult to read, however.
Reference: [5] <author> Glinert, E. P. </author> <title> Out of Flatland: Towards 3-D Visual Programming, </title> <booktitle> Proceedings 2nd Fall Joint Computer Conference, </booktitle> <year> 1987, </year> <pages> pp. 292-299. </pages>
Reference-contexts: They can be textually cryptic and difficult to read, however. There are other VPLs which use pictures and other visual cues in order to construct the program use non-traditional flow methods. Proc-BLOX <ref> [5] </ref>, a lower-level VPL, allows users to create Pascal-like code by assembling blocks representing the textual code primitives in a jigsaw puzzle fashion. The shapes of the elements preclude the possibility of assembling syntactically incorrect programs.
Reference: [6] <author> Glinert, E. P. and Tanimoto, S. L. </author> <title> Pict: An Interactive Graphical Programming Environment, </title> <booktitle> Computer, </booktitle> <month> November </month> <year> 1984, </year> <pages> pp. 7-25. </pages>
Reference-contexts: Traditional flowchart methods are often used in both higher and lower-level VPLs. Flow charts reduce the complexity of textual code somewhat, but can still be quite cryptic and do not efficiently use screen space. Occasionally, pictures accompany or are used in place of the text (as in Pict <ref> [6] </ref> or HI-VISUAL [4]) within a flowchart, but this does not help to give syntactic clues for programming. Nassi-Schneiderman flowcharts, used primarily for lower-level programming, are more compact than traditional flowcharts and have an implied syntax. They can be textually cryptic and difficult to read, however.
Reference: [7] <author> Chang, S. K. </author> <title> Visual Languages: A Tutorial and Survey, </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1987, </year> <pages> pp. 29-39. </pages>
Reference-contexts: We conclude this paper in section 5. 2. Previous Work The problems associated with textual programming have been addressed on several levels in the past. (Comprehensive reviews of the state of visual programming techniques can be found in [1] and <ref> [7] </ref>.) Researchers have created interfaces wherein routines for an existing programming language (such as C) are created by a higher-level VPL [1][5][6]. Interfaces such as these are designed to be used by programmers with knowledge of the structured programming language in question.
Reference: [8] <author> Stewart, D. B., Volpe, R. A., and Khosla, P. K. </author> <title> Integration of software modules for reconfigurable sensor-based control systems, </title> <booktitle> in Proceedings of 1992 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS 92), </booktitle> <address> Raleigh, North Carolina, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Control Module Integration In order to integrate modules into a configuration, a reliable method of intertask communication is required. In our software framework, a state variable table is used to provide such capabilities <ref> [8] </ref>. Our mechanism assumes that each control task is self-contained on a single processor, and that a control subsystem is contained within a single open-architecture backplane. A global state variable table is stored in the shared memory. <p> Device drivers and sensor interfaces are combined with other code to create control modules. It is beyond the scope of this paper to define the legality of and modifications to combinations of sensor interfaces and device drivers, and the interested reader should to refer to <ref> [8] </ref>. The use of the routines created by the sensor interfaces is discussed in the following section. 4.3. Middle Level Details In the middle level interface, upper level routines may be created by combining certain modified routines called tasks into control block diagram form.

References-found: 8

