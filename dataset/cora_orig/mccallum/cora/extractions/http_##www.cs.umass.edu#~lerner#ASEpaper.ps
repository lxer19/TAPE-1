URL: http://www.cs.umass.edu/~lerner/ASEpaper.ps
Refering-URL: http://www.cs.umass.edu/~lerner/publications.html
Root-URL: 
Email: lerner@cs.umass.edu  
Title: TESS: Automated Support for the Evolution of Persistent Types  
Author: Barbara Staudt Lerner 
Address: Amherst  
Affiliation: Computer Science Department University of Massachusetts,  
Abstract: Persistent data often has a long lifetime. During its lifetime, the types that are used to structure the data may undergo evolution to support new requirements or provide more efficient services. This evolution often makes the persistent data inaccessible unless it also evolves with the types. Existing systems that support type and data evolution focus on changes isolated to individual types, thereby limiting what can be easily accomplished during maintenance. We extend this work by presenting a model of compound type changes that can also describe changes simultaneously involving multiple types and their effects on data. We then describe Tess, a system to automate the evolution of types and their associated data when the types undergo compound type changes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, W.P. Cock-shott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4), </volume> <year> 1983. </year> <note> Also published in Readings in Object-Oriented Database Systems, </note> <editor> Stanley B. Zdonik and David Maier, eds., </editor> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: With persistent programming languages the type evolution problem is more pervasive than with object-oriented databases since there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as Persistent Java, PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [12, 24, 22, 5, 1] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [2] <author> Jay Banerjee, Won Kim, Hyoung-Joo Kim, and Henry F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD 1987 Annual Conference, </booktitle> <pages> pages 311322, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year> <booktitle> Published in Proceedings of the 1997 Automated Software Engineering Conference, </booktitle> <month> November </month> <year> 19979 </year> <month> 9 </month>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion <ref> [2, 10] </ref>, GemStone [15], O 2 [7], and Tigukat [16] are object-oriented database systems that provide some evolution support.
Reference: [3] <author> S.E. Bratsberg. </author> <title> Unified class evolution by object--oriented views. </title> <booktitle> In Proceedings of the 11th International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 423439, </pages> <address> Karlsruhe, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the si multaneous maintenance of multiple versions of types and data <ref> [21, 4, 3, 11, 23] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that old and new code can operate on old and new objects without requiring either to be changed.
Reference: [4] <author> Stewart M. Clamen. </author> <title> Schema evolution and integration. Distributed and Parallel Databases: </title> <note> An International Journal, 2:101126, </note> <year> 1994. </year>
Reference-contexts: Another approach to schema evolution relies on the si multaneous maintenance of multiple versions of types and data <ref> [21, 4, 3, 11, 23] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that old and new code can operate on old and new objects without requiring either to be changed.
Reference: [5] <author> Alan Dearle, Richard Connor, Fred Brown, and Ron Morrison. </author> <booktitle> Napier88a database programming language? In Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <pages> pages 179195. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: With persistent programming languages the type evolution problem is more pervasive than with object-oriented databases since there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as Persistent Java, PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [12, 24, 22, 5, 1] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [6] <author> R. Fabry. </author> <title> How to design a system in which modules can be changed on the fly. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <pages> pages 470476, </pages> <address> Los Alamitos, CA, </address> <year> 1976. </year>
Reference-contexts: Type change is also an issue for dynamic module replacement systems whose goal is to replace program components without stopping execution of a program. In this case there is existing data that may need to be transformed even though it is not necessarily persistent data. Existing systems (such as <ref> [6, 8] </ref>) recognize the need for such transformation functions, but leave the development of those functions to the maintainer. Another situation in which type comparison may be applicable is interoperability and schema integration.
Reference: [7] <author> Fabrizio Ferrandina, Guy Ferran, Thorsten Meyer, Joelle Madec, and Roberto Zicari. </author> <title> Schema and database evolution in the o 2 object database system. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Databases, </booktitle> <year> 1995. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion [2, 10], GemStone [15], O 2 <ref> [7] </ref>, and Tigukat [16] are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive structural changes isolated to individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables.
Reference: [8] <author> O. Frieder and M. Segal. </author> <title> On dynamically updating a computer program: From concept to prototype. </title> <journal> Journal of Systems and Software, </journal> <pages> pages 111128, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Type change is also an issue for dynamic module replacement systems whose goal is to replace program components without stopping execution of a program. In this case there is existing data that may need to be transformed even though it is not necessarily persistent data. Existing systems (such as <ref> [6, 8] </ref>) recognize the need for such transformation functions, but leave the development of those functions to the maintainer. Another situation in which type comparison may be applicable is interoperability and schema integration.
Reference: [9] <author> David Garlan, Charles W. Krueger, and Barbara Staudt Lerner. TransformGen: </author> <title> Automating the maintenance of structure-oriented environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3):727774, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: It aggravates the evolution problem, however, because every type potentially has persistent data associated with it. Modifying any type definition may make some persistent data inaccessible. Unfortunately, there is little published data <ref> [9, 20] </ref> about how types change during maintenance, and even less is known about how the existence of persistent data constrains the type evolution process. One can expect, however, that maintainers are reluctant to make radical changes to types that have persistent data.
Reference: [10] <author> Hyoung-Joo Kim and Henry F. Korth. </author> <title> Schema versions and DAG rearrangement views in object-oriented databases. </title> <type> Technical Report TR-88-05, </type> <institution> University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion <ref> [2, 10] </ref>, GemStone [15], O 2 [7], and Tigukat [16] are object-oriented database systems that provide some evolution support.
Reference: [11] <author> S. Monk and I. Sommerville. </author> <title> A model for versioning classes in object-oriented databases. </title> <booktitle> In Proceedings of the Tenth British National Conference on Databases, </booktitle> <address> Aberdeen, Scotland, </address> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the si multaneous maintenance of multiple versions of types and data <ref> [21, 4, 3, 11, 23] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that old and new code can operate on old and new objects without requiring either to be changed.
Reference: [12] <author> Ron Morrison, Richard Connor, Graham Kirby, and David Munro. </author> <booktitle> Can Java persist? In Proceedings of the First International Workshop on Persistence and Java, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: With persistent programming languages the type evolution problem is more pervasive than with object-oriented databases since there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as Persistent Java, PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [12, 24, 22, 5, 1] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [13] <author> Shamkant B. Navathe. </author> <title> Schema analysis for database restructuring. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2):157184, </volume> <month> June </month> <year> 1980. </year>
Reference-contexts: Related work The problem of schema evolution was first addressed with respect to traditional database systems. While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [19, 13, 18] </ref> support more general transformations. In these cases, the maintainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [14] <author> Erik Odberg. MultiPerspectives: </author> <title> The classification dimension of schema modification management for object-oriented databases. </title> <booktitle> In Proceedings of TOOLS-USA '94, </booktitle> <address> Santa Barbara, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This approach admits more general type changes, but it still limits type changes to be isolated to individual types. It also results in significant overhead (in both space and time) for maintaining and accessing multiple class and object versions. Odberg <ref> [14] </ref> extends the ver-sioning approach to the entire class hierarchy, which is ver-sioned when a class is modified. This allows the description of changes that simultaneously affect multiple classes, but still requires the maintainer to define the translation routines between versions.
Reference: [15] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented DBMS. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 111117, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion [2, 10], GemStone <ref> [15] </ref>, O 2 [7], and Tigukat [16] are object-oriented database systems that provide some evolution support.
Reference: [16] <author> Randal J. Peters and M. Tamer Oszu. </author> <title> An axiomatic model of dynamic schema evolution in objectbase systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 22(1):75114, </volume> <month> March </month> <year> 1997. </year>
Reference-contexts: This approach is a powerful one, but creation of the transformer is a manual process. More recent database systems generate transformation functions based upon the changes made to the type definitions. Orion [2, 10], GemStone [15], O 2 [7], and Tigukat <ref> [16] </ref> are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive structural changes isolated to individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables.
Reference: [17] <author> Debra J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis (ISSTA) '94. </booktitle> <publisher> ACM Press, </publisher> <month> June 28-30 </month> <year> 1993. </year>
Reference-contexts: schema evolution and de Published in Proceedings of the 1997 Automated Software Engineering Conference, November 19974 4 scribe how it fits into the compound type change model. interrelated types extracted from TAOS, a software testing tool developed at the University of California at Irvine by Debra Richardson and her students <ref> [17] </ref>. (TAOS is written in Pleiades, an extension of Ada that supports persistence. To understand this example, it is sufficient to consider relationship types to be record types.) In this example, we see three modified types and four new types.
Reference: [18] <author> Ben Shneiderman and Glenn Thomas. </author> <title> An architecture for automatic relational database system conversion. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2):235 257, </volume> <month> June </month> <year> 1982. </year>
Reference-contexts: Related work The problem of schema evolution was first addressed with respect to traditional database systems. While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [19, 13, 18] </ref> support more general transformations. In these cases, the maintainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [19] <author> Nan C. Shu, Barron C. Housel, and Vincent Y. Lum. </author> <title> CONVERT: A high level translation definition language for data conversion. </title> <journal> Communications of the ACM, </journal> <volume> 18(10):557567, </volume> <month> October </month> <year> 1975. </year>
Reference-contexts: Related work The problem of schema evolution was first addressed with respect to traditional database systems. While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [19, 13, 18] </ref> support more general transformations. In these cases, the maintainer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language.
Reference: [20] <author> D. I. K. Sjberg. </author> <title> Thesaurus-Based Methodologies and Tools for Maintaining Persistent Application Systems. </title> <type> PhD thesis, </type> <institution> University of Glasgow, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: It aggravates the evolution problem, however, because every type potentially has persistent data associated with it. Modifying any type definition may make some persistent data inaccessible. Unfortunately, there is little published data <ref> [9, 20] </ref> about how types change during maintenance, and even less is known about how the existence of persistent data constrains the type evolution process. One can expect, however, that maintainers are reluctant to make radical changes to types that have persistent data.
Reference: [21] <author> Andrea H. Skarra and Stanley B. Zdonik. </author> <title> The management of changing types in an object-oriented database. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 483495, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Another approach to schema evolution relies on the si multaneous maintenance of multiple versions of types and data <ref> [21, 4, 3, 11, 23] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that old and new code can operate on old and new objects without requiring either to be changed.
Reference: [22] <author> Peri Tarr and Lori A. Clarke. Pleiades: </author> <title> An object management system for software engineering environments. </title> <booktitle> In Proceedings of ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: With persistent programming languages the type evolution problem is more pervasive than with object-oriented databases since there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as Persistent Java, PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [12, 24, 22, 5, 1] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
Reference: [23] <author> Markus Tresch and Marc H. Scholl. </author> <title> Meta object management and its application to database evolution. </title> <booktitle> In Proceedings of the 11th International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 299321, </pages> <address> Karlsruhe, Germany, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Another approach to schema evolution relies on the si multaneous maintenance of multiple versions of types and data <ref> [21, 4, 3, 11, 23] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that old and new code can operate on old and new objects without requiring either to be changed.
Reference: [24] <author> Jack C. Wileden, Alexander L. Wolf, Charles D. Fisher, and Peri L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent typed object management. </title> <booktitle> In Proceedings 3rd Software Development Environments Conference, </booktitle> <pages> pages 130142, </pages> <month> December </month> <year> 1988. </year> <booktitle> Published in Proceedings of the 1997 Automated Software Engineering Conference, </booktitle> <month> November </month> <year> 199710 </year> <month> 10 </month>
Reference-contexts: With persistent programming languages the type evolution problem is more pervasive than with object-oriented databases since there is typically no distinction in the programmer's eyes between transient and persistent types. In particular, some persistent programming languages, such as Persistent Java, PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [12, 24, 22, 5, 1] </ref>, treat persistence orthogonally to types. With these languages, an instance of any type can be made persistent dynamically. This approach is very powerful and flexible, since it allows programs to manipulate data uniformly without being concerned about whether it is persistent or transient data.
References-found: 24

