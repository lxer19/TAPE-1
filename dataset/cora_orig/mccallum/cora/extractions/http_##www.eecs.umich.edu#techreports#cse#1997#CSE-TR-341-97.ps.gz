URL: http://www.eecs.umich.edu/techreports/cse/1997/CSE-TR-341-97.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse97.html
Root-URL: http://www.eecs.umich.edu
Email: -leecc, uhlig, tnm-@eecs.umich.edu  
Title: A Case Study of a Hardware-Managed TLB in a Multi-Tasking Environment  
Author: Chih-Chieh Lee, Richard A. Uhlig, and Trevor N. Mudge 
Address: Ann Arbor, Michigan  
Affiliation: Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: There have been very few performance studies of hardware-managed translation look-aside buffers (TLBs).The major reason is the lack of efficient and accurate analysis tools. Newer operating systems, applications, and the popularity of the client-server model of computation place a greater burden than their predecessors on memory system components such as TLBs. Thus it is becoming more important to measure the performance of memory systems under such workloads. In this work, we implemented a trap-driven simulator in an operating system to emulate a variety of TLBs. Using this tool, we were able to evaluate the performance of a range of TLBs under these newer workloads. The results show that in order to improve the TLB performance, we should carefully map pages into the TLB, append process identifiers to avoid ushing the TLB contents frequently, or reserve part of the TLB for a particular server process. 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson91] <author> Anderson, T.E., Levy, H.M., Bershad, </author> <title> B.N., </title> <editor> et al. </editor> <booktitle> The interaction of architecture and operating system design, In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Santa Clara, California, </address> <publisher> ACM, </publisher> <pages> 108-119, </pages> <year> 1991 </year>
Reference: [Chen93] <editor> Chen, B., et al. </editor> <booktitle> The impact of operating system structure on memory system performance , In Proc. 14th Symposium on Operating System Principles, </booktitle> <year> 1993 </year>
Reference: [Chen94] <author> Chen, B. </author> <title> Memory Behavior of an X11 Window System, </title> <booktitle> In Proc. of the USENIX winter Technical Conference, </booktitle> <year> 1994 </year>
Reference-contexts: Meanwhile, multi-tasking is becoming increasingly popular, since the current trends in software design, such as object-oriented programs, microkernel operating systems, and client-server models, can generate process switching more frequently. Numerous preliminary studies have indicated that hardware performance can be degraded greatly in the presence of multi-tasking <ref> [Nagle93, Chen94, Nagle94] </ref>. It is thus becoming important to reconsider the hardware of modern computers in light of these trends. Hardware designers may already realize the importance of testing machines by putting them under a more realistic environment. <p> As a result, the path of invoking an OS service becomes longer, which, in turn, stresses the cache and TLB more than does the traditional OS structure. Studies of both X window and multi-media applications showed that these multi-tasking workloads degrade TLB performance considerably <ref> [Chen93b, Chen94] </ref>. This degradation occurs because these new applications consult servers or OS services more frequently than do the traditional benchmarks. Meanwhile, switching process contents between the applications and the servers prompts a purging of the TLB content, to ensure the address translation valid. <p> Without being ushed in context switches, the TLB can remember useful translation information across address space boundaries. Especially, X-window applications may invoke mandatory context switches frequently because they need immediate system services, as shown in <ref> [Chen94] </ref>. Flushing the TLB at context switching will thwart the TLB performance greatly for X-window applications. <p> This is interesting because it suggests that performance of the X server is strongly related to that of the UNIX server. Finally, for those applications which contact with servers intensively, OS scheduling policy may be irrelevant to the TLB performance because the context switches may occur before quota expires <ref> [Chen94] </ref>. However, if we preserve a subset of the TLB for the server such that TLB can remember the server-related translation information across context switches, then the scheduling policy may need to be considered. 4.2.2.4 The replacement policy In this work, we also examined different replacement policies for TLBs.
Reference: [Hennessy90] <author> Hennessy, J., Patterson, D., </author> <title> Computer Architecture: </title> <publisher> A Quantitative Approach Morgan Kaufmann Publishers, INC., </publisher> <year> 1990 </year>
Reference-contexts: However, splitting the TLB into instruction and data parts has no advantages, which is similar to the experience in designing caches that miss rates are not improved by splitting caches to reduce conicts between instructions and data <ref> [Hennessy90] </ref>. By improving the TLB structures we can enhance the performance of translating addresses under a multitasking environment. If software managed TLBs are used, there is almost no cost for adding enhancement since only a small amount of code needs to be added into kernel.
Reference: [Intel92] <author> Intel, </author> <title> Intel486 DX Microprocessor Data Book, </title>
Reference-contexts: The architecture we are working on in this study is the Intel i486 microprocessor, which has an on-chip 32-entry TLB, organized in 4-way set associative <ref> [Intel92] </ref>. The i486 microprocessor is unique because its TLB is managed by hardware instead of software, as is the case with previous study [Uhlig 94a].
Reference: [Malan92] <author> Malan, G., et al. </author> <title> DOS as a Mach 3.0 Application </title>
Reference: [Nagle92] <author> Nagle, D., Uhlig, R. and Mudge, T. </author> <title> Monster: A Tool for Analyzing the Interaction Between Operating Systems and Computer Architectures. </title> <institution> The University of Michigan. CSE-TR-147-92. </institution> <year> 1992 </year>
Reference-contexts: This process of inserting code is called annotation. When the annotated program is executed, the inserted code can record program activities into a predetermined file for post-analysis. In addition to purely software-based tools, hardware-assisted tools for monitoring system activities also exist. For example, Nagle <ref> [Nagle92] </ref> have developed a monitoring tool by combining a logic analyzer, which is a hardware item, with an instrumented OS kernel, which is a software item. This monitoring tool probes the system bus and records the system statistics in its own buffer. <p> The important parameters mentioned above can be obtained through hardware devices, such as Monster developed by Nagle <ref> [Nagle92] </ref> and timers with high resolution. Some microprocessors even provide on-chip instruction counters to make it easier to count total instructions of a workload. Unfortunately, the i486 does not provide such a counter, so an additional hardware device is necessary.
Reference: [Nagle93] <author> Nagle, D., Uhlig, R., Stanley. T., Sechrest, S., Mudge, T., Brown, R., </author> <title> Design tradeoffs for software-managed TLBs, </title> <booktitle> In the 20th Annual International Symposium on Computer Architecture, </booktitle> <address> San Diego, California, </address> <publisher> IEEE, </publisher> <pages> 27-38, </pages> <year> 1993 </year>
Reference-contexts: Meanwhile, multi-tasking is becoming increasingly popular, since the current trends in software design, such as object-oriented programs, microkernel operating systems, and client-server models, can generate process switching more frequently. Numerous preliminary studies have indicated that hardware performance can be degraded greatly in the presence of multi-tasking <ref> [Nagle93, Chen94, Nagle94] </ref>. It is thus becoming important to reconsider the hardware of modern computers in light of these trends. Hardware designers may already realize the importance of testing machines by putting them under a more realistic environment. <p> In these studies, furthermore, the evaluation of hardware performance is primarily focused on memory system performance. Studies of a microkernel OS, such as Mach 3.0, have consistently demonstrated that cache and TLB misses occur more frequently with the microkernel OS than with traditional OS structures <ref> [Chen93a, Nagle93, Nagle94] </ref>. A miss is, simply, an event which caches or TLBs do not contain the data requested by central process unit (CPU), and therefore CPU has to spend more clock cycles to get the data from main memory. <p> 1 8 5 , 4 5 , 8 5 , 1 2 6 5 5 2 5 2 5 2 6 1 5 2 x server ux server mpeg Fig. 4.7 Mpeg_play: TLB misses against TLB configurations microprocessors and the trade-off between its performance and cost has been studied in <ref> [Nagle93] </ref>. Here, we studied for the hardware managed TLB. By dedicating TLB slots for the UNIX server, we can preserve the translation information for the frequently invoked service subroutines in the TLB without being interfered by other address spaces.
Reference: [Nagle94] <author> Nagle, D., Uhlig, R., Mudge, T., et al. </author> <title> Optimal Allocation of On-chip Memory for Multiple-API Operating Systems, </title> <booktitle> In The 21st International Symposium on Computer Architecture, </booktitle> <address> Chicago, IL, </address> <year> 1994 </year>
Reference-contexts: Meanwhile, multi-tasking is becoming increasingly popular, since the current trends in software design, such as object-oriented programs, microkernel operating systems, and client-server models, can generate process switching more frequently. Numerous preliminary studies have indicated that hardware performance can be degraded greatly in the presence of multi-tasking <ref> [Nagle93, Chen94, Nagle94] </ref>. It is thus becoming important to reconsider the hardware of modern computers in light of these trends. Hardware designers may already realize the importance of testing machines by putting them under a more realistic environment. <p> In these studies, furthermore, the evaluation of hardware performance is primarily focused on memory system performance. Studies of a microkernel OS, such as Mach 3.0, have consistently demonstrated that cache and TLB misses occur more frequently with the microkernel OS than with traditional OS structures <ref> [Chen93a, Nagle93, Nagle94] </ref>. A miss is, simply, an event which caches or TLBs do not contain the data requested by central process unit (CPU), and therefore CPU has to spend more clock cycles to get the data from main memory.
Reference: [Ousterhout89] <author> Ousterhout, J. </author> <title> Why aren't operating systems getting faster as fast as hardware. </title> <note> WRL Technical Note </note>
Reference: [Patel92] <author> Patel, K., Smith, B. C. and Rowe, L. A., </author> <title> Performance of a Software MPEG Video Decoder, </title> <institution> University of California, Berkeley, </institution> <year> 1992 </year>
Reference-contexts: A previous study on the mpeg_play has shown that memory bandwidth is the primary limitation in performance of this decoder instead of the computational complexity <ref> [Patel92] </ref>. In addition, mpeg_play needs intensive supports from the operating system and X-window server. In the Mach 3.0 system, there are three user-level tasks being involved in when mpeg_play is running; they are the mpeg_play task, the UNIX server, and the X-window server.
Reference: [Rashid88] <author> Rashid, R., et al. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 8, p896-908, </volume> <month> Aug, </month> <year> 1988 </year>
Reference-contexts: This easy portability makes the OS more marketable, as it can easily be adapted to various hardware architectures. In contrast, the dependent layer is machine-specific. The dependent layer of the virtual memory system is contained in the PMAP module, which handles all virtual-to-physical address translations <ref> [Rashid88] </ref>. The PMAP module creates a unique pmap data structure for each task . Every pmap data structure also has its own unique handle number, whichif it can be detectedcan be used to determine the active task address space.
Reference: [Sites92] <author> Sites, R., </author> <title> Alpha Architecture Reference Manual, </title> <publisher> Digital Press, </publisher> <year> 1992 </year>
Reference: [Smith91] <author> Smith, </author> <title> M.D. Tracing with pixie. </title> <institution> Stanford University, Stanford, </institution> <address> CA. </address> <year> 1991 </year>
Reference-contexts: The most common monitoring tools are code annotation systems such as pixie <ref> [Smith91] </ref>. These are purely software-based because they work by inserting monitoring code directly into executable images of programs. This process of inserting code is called annotation. When the annotated program is executed, the inserted code can record program activities into a predetermined file for post-analysis.
Reference: [Uhlig94a] <author> Uhlig, R., Nagle, D., Mudge, T., Sechrest, S., </author> <title> Kernel-based Memory Simulation, </title> <booktitle> ACM Sigmetrics Conference on Measuring & Modeling of Computer Systems, </booktitle> <volume> Vol 22, </volume> <month> May, </month> <year> 1994 </year>
Reference-contexts: However, the difficulty and expensive cost of the experimental methodology restrains designers from doing it. To overcome this problem, an efficient method of evaluating the system performance under a multi-tasking environment has been proposed by Uhlig, , which is termed trap driven simulation <ref> [Uhlig94a, Uhlig94b] </ref>. In this study, we extended this new method to a different but even more popular hardware architecture and collected some interesting results. In order to emphasize the multi-tasking environment, we incorporated the operating system (OS) because the OS is primarily responsible for managing processes.
Reference: [Uhlig94b] <author> Uhlig, R., Nagle, D., Mudge, T., Sechrest, S. </author> <title> Trap-driven Simulation with Tapeworm II, </title> <booktitle> In the proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> San Jose, California, </address> <publisher> ACM, </publisher> <pages> 132-144, </pages> <year> 1994 </year>
Reference-contexts: However, the difficulty and expensive cost of the experimental methodology restrains designers from doing it. To overcome this problem, an efficient method of evaluating the system performance under a multi-tasking environment has been proposed by Uhlig, , which is termed trap driven simulation <ref> [Uhlig94a, Uhlig94b] </ref>. In this study, we extended this new method to a different but even more popular hardware architecture and collected some interesting results. In order to emphasize the multi-tasking environment, we incorporated the operating system (OS) because the OS is primarily responsible for managing processes. <p> A limited sized buffer and, therefore, the necessity of frequent system stalls inevitably changes the system behavior. To overcome these shortcomings, Uhlig et al. <ref> [Uhlig94b] </ref> developed a trap-driven simulator, called Tapeworm , that can capture events during operating system activity efficiently and correctly. Furthermore, these events can be processed on-the-y, thereby avoiding the need for buffering and stalling. Tapeworm, moreover, is purely software-based. <p> Because of this filtering capability, Tapeworm is much faster than other approaches <ref> [Uhlig94b] </ref>. However, because Tapeworm records only the miss events, its record of workloads (tasks processed in the TLB) is incomplete. Thus, it cannot simulate those replacement policies which depend on the full history of references, such as the least-recently-used (LRU) algorithm. <p> Fig. 4.6 shows the slowdown for the MDOS & Lotus test program running with Tapeworm. Note that Compared with the result in Uhligs work <ref> [Uhlig94b, Fig. 2] </ref>, the Tapeworm on i486 introduces almost the same degradation to the system performance as the one on MIPS R3000, although the i486 one performs worse while the emulated TLB is small. It performs worse because the codes have not yet been optimized.
References-found: 16

