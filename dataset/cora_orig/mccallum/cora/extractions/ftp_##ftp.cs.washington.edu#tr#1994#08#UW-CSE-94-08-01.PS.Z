URL: ftp://ftp.cs.washington.edu/tr/1994/08/UW-CSE-94-08-01.PS.Z
Refering-URL: http://www.cs.washington.edu/homes/ruzzo/
Root-URL: 
Abstract: Mediators: Easing the Design and Evolution of Integrated Systems Kevin J. Sullivan Technical Report 94-08-01 Department of Computer Science and Engineering University of Washington 
Abstract-found: 1
Intro-found: 1
Reference: [Bellcore 92] <author> Bell Communications Research, </author> <title> "The Framework: A Disciplined Approach to Analysis," </title> <journal> Science and Technology Series ST-OPT-002008, </journal> <note> Issue 1, </note> <month> May, </month> <year> 1992. </year>
Reference-contexts: Every object potentially announces and responds to explicitly declared events. Events in the Global Scope. Another possibility is to organize events as belonging not to individual objects but to a "global scope," in the way that operations do not belong to individual objects in the Generalized Object Model <ref> [Bellcore 92] </ref>. Some frameworks, such as Field, do just this. The message server manages a single, large space of events; and tools really register for these global events. There are several reasons to prefer ABTs.
Reference: [Bennington 56] <author> H.D. Bennington, </author> <title> "Production of Large Computer Programs," </title> <booktitle> Proceedings of ONR Symposium on Advanced Programming Methods for Digital Computers, </booktitle> <month> June </month> <year> 1956, </year> <pages> pp. 15-27. </pages> <note> Also in Annals of the History of Computing, </note> <month> October, </month> <year> 1983, </year> <booktitle> and Proceedings of the 9th International Conference on Software Engineering, </booktitle> <publisher> (Computer Society Press), </publisher> <year> 1987. </year>
Reference: [Birrell and Nelson 84] <author> A.D. Birrell, B.J. Nelson, </author> <title> "Implementing Remote Procedure Call," </title> <journal> ACM Transactions on Computer Systems 2,1, </journal> <pages> pp. 39-59, </pages> <month> February, </month> <year> 1984. </year>
Reference: [Bobrow et al. 88] <author> D.G. Bobrow et al. </author> <title> Common Lisp Object System Specification X3JI3 Document 88-002R. </title> <journal> ACM SIGPLAN Notices 23, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: The mediator method also allowed Griswold to reuse a substantial, existing software component: over 10,000 lines of Common Lisp/CLOS <ref> [Bobrow et al. 88] </ref> comprising the PDG, which was built by Jim Larus as part of his Curare system [Larus 89]. 80 Localizing the relationship between the AST and the PDG in the mediator was also useful in providing a place for the code and data that implemented a somewhat complex <p> An event object maintains a list of operations to be implicitly invoked, and the objects to which they are to be applied, when the event is announced [Sullivan and Notkin 92]. Events. The implementation environment for Prism is provided by Common Lisp [Steele 90] and CLOS <ref> [Bobrow et al. 88] </ref>. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this. An event object is an instance of an event class. <p> We applied this approach throughout Prism, at all levels of "granularity," and in solving a range of design problems of several different kinds. 7.6 Development Effort As of November of 1993, Prism was implemented in about 18,000 lines of Common Lisp [Steele 90] and CLOS <ref> [Bobrow et al. 88] </ref> and 4,500 lines of Pascal with 11,000 lines of L a T E X documentation. 2 The Lisp code handles modeling, visualization, and database management. The Pascal, adapted from an earlier system, computes dose distributions. <p> This section discusses the mediator method as presented in this work in relation to previous efforts in which mediator-like constructs have appeared. 9.2.1 AP5. AP5 [Cohen 89] is a declarative, constraint-based programming environment based on Common Lisp <ref> [Bobrow et al. 88] </ref>. AP5 extends Common Lisp with a transactional, relational database supporting triggers (procedures invoked when specified conditions are satisfied).
Reference: [Boehm 88] <author> Boehm, B.W. </author> <title> "A Spiral Model of Software Development and Enhancement," </title> <booktitle> Computer, </booktitle> <month> May, </month> <year> 1988, </year> <pages> pp. 61-72, </pages> <editor> in P.W. Oman and T.G. Lewis, Eds., </editor> <booktitle> Milestones in Software Evolution, </booktitle> <publisher> (Los Alamitos: IEEE Computer Society Press), </publisher> <year> 1990, </year> <pages> pp. 249-260. </pages>
Reference-contexts: This section extends the modeling framework to model systems consisting of multiple, related representations. 34 3.2.1 Background The idea of software as multi-representational and the existence of correspondences be tween the structures of adjacent representations have long been recognized. Boehm <ref> [Boehm 88, p.251] </ref> implicitly traces the idea to Bennington's stagewise process model [Benning-ton 56], an early view of software development as a sequence of transformations from higher to lower level representations.
Reference: [Brooks 86] <author> F.P. Brooks Jr., </author> <title> "No Silver Bullet|Essence and Accidents of Software Engineering," it Information Processing 86, H.J. </title> <editor> Kugler, Ed., </editor> <publisher> (North Holland), </publisher> <year> 1986, </year> <pages> pp. 1069-1076, </pages> <note> in Milestones in Software Evolution, </note> <editor> P.W. Oman, Ed., </editor> <publisher> (Los Alamitos: IEEE Computer Society Press), </publisher> <year> 1990, </year> <pages> pp. 293-300. </pages> <note> Also appears in Computer, </note> <month> April </month> <year> 1987, </year> <pages> pp. 10-19. 150 </pages>
Reference-contexts: Moreover, the design, realization, and evolution tasks are eased in the ways predicted by the reasoning presented above. The mediator method is no "silver bullet <ref> [Brooks 86] </ref>," but it provides significant value by helping software designers to think more clearly about integrated behaviors and to avoid unnecessary complexity in the design and evolution of software systems that realize those behaviors.
Reference: [Brooks ???] <editor> F.P. Brooks Jr., </editor> <publisher> Academic Careers for Experimental Computer Scientists. </publisher>
Reference: [Cagan 90] <author> M.R. Cagan, </author> <title> "The HP SoftBench Environment: An Architecture for a New Generation of Software Tools," </title> <journal> Hewlett-Packard Journal, </journal> <volume> 41,3, </volume> <pages> pp. 36-47, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Contributions of the project include the BMS mechanism, an associated design method, and a family of Unix-based [Ritchie and Thompson 78] integrated programming environments designed using this method. The FIELD method is now commercially supported, e.g., by Hewlett-Packard's Softbench <ref> [Cagan 90] </ref>. Fundamentally, the BMS method specializes the implicit invocation method by requiring communications between integrated modules to pass through a special component, the BMS. This relives the modules to be integrated (e.g., Unix tools) from having to invoke or reference each other directly.
Reference: [Cameron 89] <author> Cameron, J.R., </author> <title> JSP and JSD : The Jackson Approach to Software Development, </title> <publisher> (Washington : IEEE Computer Society Press), </publisher> <address> c. </address> <year> 1989. </year>
Reference: [Chase et al. 94] <author> J. Chase et al.,, </author> <title> On the Opal system, </title> <journal> ACM Transactions on Computer Systems, </journal> <note> forthcoming in 1994. </note>
Reference-contexts: Both the system and transfer were successful. The next chapter presents Prism as an in-depth case study, so I will not discuss it further here. 6.2.5 Large Address-Space Operating Systems Chase et al. exploited the mediator approach in the context of a single, large, shared address-space operating system, Opal <ref> [Chase et al. 94] </ref>. In this system, address translation and memory protection are decoupled. One promise of this kind of system is to efficiently support computer-aided design of such complex artifacts as passenger jets.
Reference: [Chen 76] <author> P.P. Chen, </author> <title> "The Entity-Relational Model|Toward a Unified View of Data," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1,1, </volume> <pages> pp. 9-36, </pages> <month> March, </month> <year> 1976. </year>
Reference-contexts: An integrated behavior is represented as a set of independent behaviors integrated in a network of externalized behavioral relationships. Recalling Chen's entity-relationship data modeling <ref> [Chen 76] </ref>, I call these networks behavioral entity-relationship (ER) models. 3 1.4.1 Applying the Method The top part of Figure 1.7 depicts a behavioral ER model of the behavior of the integrated programming environment. <p> behavioral ER modeling to other software engineering efforts in which the separation of relationship concerns figures prominently. 133 9.1.1 Entity-Relationship Data Modeling Separating the representations of relationships from those of the entities to be related in software engineering dates at least to Chen's entity relationship (ER) data model ing method <ref> [Chen 76] </ref>. Before Chen, data modelers tended to represent relationships in terms of attributes (fields) of the entities (relations) to be related.
Reference: [Cohen 89] <author> D. Cohen, </author> <title> "Compiling Complex Transition Database Triggers," </title> <booktitle> Proceedings of the 1989 ACM SIGMOD, 1989, Portland, Oregon, </booktitle> <pages> pp. 225-34. </pages>
Reference-contexts: This section discusses the mediator method as presented in this work in relation to previous efforts in which mediator-like constructs have appeared. 9.2.1 AP5. AP5 <ref> [Cohen 89] </ref> is a declarative, constraint-based programming environment based on Common Lisp [Bobrow et al. 88]. AP5 extends Common Lisp with a transactional, relational database supporting triggers (procedures invoked when specified conditions are satisfied).
Reference: [Collins et al. 91] <author> T. Collins, K. Ewert, C. Gerety, J. Gustafson, I. Thomas, "TICKLE: </author> <title> Object-Oriented Description and Composition Services for Software Engineering Environments," </title> <booktitle> Proceedings of the 3rd European Software Engineering Conference, </booktitle> <month> October </month> <year> 1991, </year> <title> Milan, </title> <booktitle> Italy, </booktitle> <pages> pp. 408-423. </pages>
Reference: [de Champeaux, Lea and Faure 93] <author> D. de Champeaux, D. Lea, P. Faure, </author> <title> Object-Oriented System Development, </title> <address> (Reading, Mass: </address> <publisher> Addison-Wesley), </publisher> <year> 1993. </year>
Reference-contexts: Even in the absence of formal transformations, the existence and importance of the structures of correspondences between representations is widely accepted. Jackson [Jackson 75] emphasizes that a close correspondence between problem and solution structure is key to reducing the difficulty of evolution; Meyer [Meyer 88], DeChampeaux <ref> [de Champeaux, Lea and Faure 93] </ref>, and many others echo similar concerns. 3.2.2 Specification. To begin, I take behavioral ER models as high-level representations.
Reference: [DeMarco 79] <author> T. DeMarco, </author> <title> Structured Analysis and System Specification, </title> <address> (Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall), </publisher> <year> 1979. </year>
Reference: [Dijkstra 65] <author> E. Disjkstra, </author> <title> "Programming Considered as a Human Activity," </title> <booktitle> Proceedings of the 1965 IFIP Congress, </booktitle> <address> (Amsterdam, The Netherlands: </address> <publisher> North-Holland), </publisher> <year> 1965, </year> <pages> pp. 213-217, </pages> <editor> in E.N. Yourdon, Ed., </editor> <booktitle> Classics in Software Engineering, </booktitle> <address> (New York: </address> <publisher> Yourdon Press), </publisher> <year> 1979, </year> <pages> pp. 3-9. 151 </pages>
Reference-contexts: modules where the behavior of one directly affects the behavior of the other; indirect behavioral links; and the presence of complex behavioral relationships (such as ) between the behaviors of modules. 3.1.1 Modules Modularity is a key property of software representations because it is essential for humans to manage complexity <ref> [Dijkstra 65, Dijkstra 72] </ref>. Even if the clients of a representation view it as a monolithic module, it will almost invariably be implemented internally as a structured set of modular parts.
Reference: [Dijkstra 72] <author> E. Disjkstra, </author> <title> "The Humble Programmer," </title> <booktitle> ACM Turning Award Lecture, ACM Annual Conference, </booktitle> <address> Boston, </address> <month> August 14, </month> <year> 1972, </year> <title> in E.N. Yourdon, </title> <editor> Ed., </editor> <booktitle> Classics in Software Engineering, </booktitle> <address> (New York: </address> <publisher> Yourdon Press), </publisher> <year> 1979, </year> <pages> pp. 113-125. </pages>
Reference-contexts: modules where the behavior of one directly affects the behavior of the other; indirect behavioral links; and the presence of complex behavioral relationships (such as ) between the behaviors of modules. 3.1.1 Modules Modularity is a key property of software representations because it is essential for humans to manage complexity <ref> [Dijkstra 65, Dijkstra 72] </ref>. Even if the clients of a representation view it as a monolithic module, it will almost invariably be implemented internally as a structured set of modular parts. <p> Dijkstra suggests that perhaps, "the only problems we can really solve in a satisfactory manner are those that finally admit a nicely factored solution <ref> [Dijkstra 72, p.124] </ref>." The contribution of this work in this dimension is to develop a nice way to factor the behaviors of integrated systems and their corresponding software representations.
Reference: [Fraass et al. 87] <author> B. A. Fraass and D. L. McShan, </author> <title> "3-D Treatment Planning I. Overview of a Clinical Planning System," </title> <editor> in I. A. D. Bruinvis, P. H. van der Giessen, H. J. van Kleffens and F. W. Wittkamper, eds., </editor> <booktitle> Proceedings of the Ninth International Conference on the Use of Computers in Radiation Therapy, </booktitle> <address> (Amsterdam: </address> <publisher> North-Holland), </publisher> <year> 1987, </year> <pages> pp. 273-277. </pages>
Reference: [Freeman-Benson, Maloney, and Borning 90] <author> B. Freeman-Benson, J. Maloney, A. Born-ing, </author> <title> "An Incremental Constraint Solver," </title> <journal> Communications of the ACM 33,1, </journal> <pages> pp. 54-63, </pages> <month> January, </month> <year> 1990. </year>
Reference-contexts: It is not hard to define adapter objects to add the level of indirection needed for generic mediators. 136 9.1.4 Constraint Programming Constraint programming systems are also based on a separate representation of relationships. Such systems include Penguims [Hudson and Mohamed 90], ThingLab II <ref> [Freeman-Benson, Maloney, and Borning 90] </ref>, Kaleidoscope [Freeman-Benson 90, Lopez, Freeman-Benson & Borning 93] (which extends the ThingLab II mechanisms by adding linguistic constructs for abstracting low-level constraints into compound constraint objects), and CLP (R) [Jaffar et al. 92]. <p> Some system only solve systems of linear inequa-tions [Jaffar et al. 92]. Others loosen the semantic restrictions while retaining automation, but at the cost of having to give up declarative notations. ThingLab II <ref> [Freeman-Benson, Maloney, and Borning 90] </ref> strikes an interesting compromise in this dimension. It promotes design in terms of logical constraints and variables; and it implements constraints and variables as corresponding physical "constraint" and "variable" objects that are imperatively progrmmed.
Reference: [Freeman-Benson 90] <author> B.N. Freeman-Benson, </author> <title> "Kaleidoscope: Mixing Objects, Constraints, and Imperative Programming," </title> <booktitle> Proceedings of OOPSLA/ECOOP 90, 1990, </booktitle> <address> Ottawa, Canada, </address> <pages> pp. 77-88. </pages>
Reference-contexts: Such systems include Penguims [Hudson and Mohamed 90], ThingLab II [Freeman-Benson, Maloney, and Borning 90], Kaleidoscope <ref> [Freeman-Benson 90, Lopez, Freeman-Benson & Borning 93] </ref> (which extends the ThingLab II mechanisms by adding linguistic constructs for abstracting low-level constraints into compound constraint objects), and CLP (R) [Jaffar et al. 92].
Reference: [Garlan 87] <author> D. Garlan. </author> <title> Views for Tools in Integrated Environments. </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1987. </year>
Reference-contexts: In an integrated environment, different tools may be designed to operate on the same information in different ways. The problem of the consistency of different views of common information arises. Garlan handled the problem by representing views as ADTs and by merging views that represent the same information <ref> [Garlan 87] </ref>. In merging, the separate interfaces of distinct ADTs are preserved, but multiple implementations are replaced with a single implementation that supports both the views individually as well as consistency among the views. The system produces merged implementations automatically by selecting appropriate compatibility maps.
Reference: [Garlan and Ilias 90] <author> D. Garlan and E. Ilias, </author> <title> "Low-cost, Adaptable Tool Integration Policies for Integrated Environments," </title> <booktitle> Proceedings of SIGSOFT90: Fourth Symposium on Software Development Environments, 1990, </booktitle> <address> Irvine, California, </address> <pages> pp. 1-10. </pages>
Reference-contexts: Although the components do not have to reference each other directly, they come to depend on each other's interfaces and protocols. Nor is there an impetus to represent behavioral relationships abstractly. This problem is addressed in Forest <ref> [Garlan and Ilias 90] </ref>, but not in great generality. 11 There are other problems, too. The BMS is a monolithic component, representing the global union of the interfaces of all system components. This may have serious results. <p> To see better how this method eases evolution consider two evolutionary changes. The first is a change in the way that the editor and compiler work together, so that the compiler regenerates object code when the editor saves a file only if the system load is low <ref> [Garlan and Ilias 90] </ref>. To handle this change in the specification requires changing only the behavioral relationship. We do not have to change the editor or compiler or their clients. The corresponding implementation change is a localized update of the mediator object.
Reference: [Garlan and Notkin 91] <author> D. Garlan, D. Notkin, </author> <title> Formalizing Design Spaces: Implicit Invocation Mechanisms. VDM '91, Formal Software Development Methods. </title> <note> Appears as Springer-Verlag Lecture Notes in Computer Science #551 (November 1991). </note>
Reference-contexts: I will argue that there is a second kind of abstract type: one that augments the ADT with the means for one object to implicitly extend certain behaviors of others. A mechanism that supports implicit extension is implicit invocation, or event notification <ref> [Garlan and Notkin 91] </ref>. Using such a mechanism, an object m extends the behavior of an object n by registering an operation to be invoked by an event announced by n. When n announces the event, the operation is invoked implicitly. <p> Many systems support specialized event mechanisms, including Smalltalk-80 [Goldberg and Robson 83], LOOPS [Stefik, Bobrow, and Kahn 86], APPL/A [Sutton, Heimbigner, and Osterweil 90], and many others. Despite this long history, a precise characterization of implicit invocation and its benefits has only recently emerged <ref> [Garlan and Notkin 91, Sullivan and Notkin 92] </ref>. The basic advantage of implicit invocation is that it provides engineers with the flexibly to choose the orientations of reference dependences between components that invoke each other. <p> Notkin 86, Stefik, Bobrow, and Kahn 86, Krasner and Pope 88, Cohen 89, Reiss 90, Cagan 90, Sutton, Heimbigner, and Osterweil 90, Collins et al. 91, Gorlick 91, Harrison, Kavianpour, and Ossher 92] However, a unified view of the behavior, benefits, and design space for such mechanisms emerged only recently <ref> [Garlan and Notkin 91, Sullivan and Notkin 92] </ref>. A detailed discussion of this work is beyond the scope of this dissertation.
Reference: [Goitein et al. 83] <author> M. Goitein and others, </author> <title> "Multi-dimensional Treatment Planning: II. Beam's Eye-view, Back Projection, and Projection Through CT Sections," </title> <journal> International Journal of Radiation Oncology Biology and Physics 9, </journal> <year> 1983, </year> <pages> pp. 789-797. 152 </pages>
Reference: [Goldberg and Robson 83] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <address> (Reading, Mass: </address> <publisher> Addison-Wesley), </publisher> <year> 1983. </year>
Reference-contexts: See Figure 1.5. 9 Compiler . . . . . . Save (File f) Compile (File f) Editor Implicit invocation is an old idea. Many systems support specialized event mechanisms, including Smalltalk-80 <ref> [Goldberg and Robson 83] </ref>, LOOPS [Stefik, Bobrow, and Kahn 86], APPL/A [Sutton, Heimbigner, and Osterweil 90], and many others. Despite this long history, a precise characterization of implicit invocation and its benefits has only recently emerged [Garlan and Notkin 91, Sullivan and Notkin 92].
Reference: [Griswold 91] <author> W.G. </author> <title> Griswold Program Restructuring to Aid Software Maintenance, </title> <type> Ph.D. Dissertation, Technical Report 91-08-04, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> August, </month> <year> 1991. </year>
Reference-contexts: The first was a tool to ease software enhancement by supporting meaning-preserving restructuring of programs <ref> [Griswold 91] </ref>. The tool helps the software engineer by decomposing enhancement into two phases. The claim is that prior restructuring decreases the cost of subsequent semantic enhancement more than enough to offset the up-front restructuring cost. One transformation changes the order of formal parameters in a procedure declaration.
Reference: [Gorlick 91] <author> Gorlick, M. M. and Razouk, R. R., </author> <title> "Using Weaves for Software Construction and Analysis," </title> <booktitle> Proceedings of the 13th International Conference on Software Engineering, </booktitle> <address> Austin, Texas, </address> <month> May, </month> <year> 1991, </year> <pages> pp. 23-34. </pages>
Reference: [Guibas and Stolfi 85] <author> L. Guibas and J. Stolfi, </author> <title> "Primitives for the Manipulation of Three-Dimensional Subdivisions," </title> <journal> ACM Transactions on Graphics 4,2, </journal> <pages> pp. 74-123, </pages> <month> April, </month> <year> 1985. </year>
Reference-contexts: ES stores a topological algebra|a set of edges plus several ordering relations over this set. Specifically, ES implements a variant of the quad-edge data structure <ref> [Guibas and Stolfi 85] </ref>. The clean, somewhat complex algebraic structure of this representations made it useful for exploring the consistency-maintenance capabilities of mediators. McCabe's system supports viewing of a mesh with n-dimensional geometry (n &gt; 2) as a set of 2-D views presenting orthographic projections.
Reference: [Habermann and Notkin 86] <author> A. N. Habermann and D. Notkin, </author> <title> "Gandalf Software Development Environments," </title> <journal> IEEE Transactions on Software Engineering SE-12,12, </journal> <pages> pp. 1117-1127, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: In a programming environment, neither the editor or compiler have to be changed if the user coordinates their activities. Unfortunately, this method reduces the value of systems to users. In may even impose unacceptable burdens on them <ref> [Taylor 88, Habermann and Notkin 86] </ref>. Manually coordinating tools in a programming environment is tedious and error-prone, and distracts users from building software. Manually updating graphical views as computerized models change and manually translating and transferring data between tools in computer-aided design (CAD) systems may also unduly burden users.
Reference: [Habermann et al. 88] <author> A.N. Habermann, C. Krueger, B. Pierce, B. Staudt, and J. Wenn. </author> <title> Programming with Views. </title> <type> Technical Report CMU-CS-87-177, </type> <institution> Carnegie-Mellon University, </institution> <month> January, </month> <year> 1988. </year>
Reference-contexts: A compiler may view data as a set interface, while another tool views it as a list, for example. In Garlan's approach a system has a fixed set of compatibility maps and composition rules; follow-on work loosened this restriction by providing a language for defining maps and compositions <ref> [Habermann et al. 88] </ref>. 142 An advantage of this approach is that it allows merged implementations to be optimized, with potentially significant savings in both time and space. Two views containing identical elements may share a single instance of that element in a merged view.
Reference: [Harrison, Kavianpour, and Ossher 92] <author> W. Harrison, M. Kavianpour, and H. Ossher. </author> <title> Integrating Coarse-Grained and Fine-Grained Tool Integration. </title> <institution> IBM Research Division, </institution> <note> Research Report RC 17524 (#77482), January 8, </note> <year> 1992. </year>
Reference: [Helm, Holland, and Gangopadhyay 90] <author> R. Helm, I.M. Holland, D. Gangopadhyay, </author> <title> "Contracts: Specifying Behavioral Compositions in Object-Oriented Systems," </title> <booktitle> Proceedings of OOPSLA/ECOOP 90, </booktitle> <year> 1990, </year> <pages> pp. 169-180. </pages>
Reference-contexts: There is no fundamental need for a separate construct, and some important advantages follow from using the single ABT construct. 135 9.1.3 Contracts. Helm et al. make the idea of generalized behavioral relationships explicit in a paper sketching a language for specifying such relationships <ref> [Helm, Holland, and Gangopadhyay 90] </ref>. The key construct in this language is the contract. <p> Second, contracts often specify that objects invoke each other. This biases implementations towards hardwired designs. Third, contracts emphasize relationships over the objects they relate: "the specification of a class becomes spread over a number of contracts and conformance declarations, and is not localized to one class definition <ref> [Helm, Holland, and Gangopadhyay 90, p.178] </ref>." Yet contracts are justified by the idea that in other languages, "behavioral compositions : : : are spread across many class definitions [Helm, Holland, and Gangopadhyay 90, p.169]." The mediator method, by contrast, emphasizes equally relationships and the objects they relate. <p> specification of a class becomes spread over a number of contracts and conformance declarations, and is not localized to one class definition [Helm, Holland, and Gangopadhyay 90, p.178]." Yet contracts are justified by the idea that in other languages, "behavioral compositions : : : are spread across many class definitions <ref> [Helm, Holland, and Gangopadhyay 90, p.169] </ref>." The mediator method, by contrast, emphasizes equally relationships and the objects they relate. Finally, the behavioral ER modeling method does not emphasize genericity of relationships, although it does not preclude it.
Reference: [Hoare 68] <author> C.A.R. Hoare, </author> <title> "Record Handling," </title> <editor> in F. Genuys, ed., </editor> <booktitle> Programming Languages, </booktitle> <pages> pp. 291-347, </pages> <publisher> Academic Press, </publisher> <year> 1968. </year> <month> 153 </month>
Reference-contexts: Events names and signatures are declared, and events have precise semantics. Hoare suggests what designers need are abstractions that support clear thinking about problems and solutions, and providing a basis for notations supporting clear expression of such thoughts <ref> [Hoare 68] </ref>. I believe ABTs satisfy this requirement. However, one might ask why adopt the ABT given many existing frameworks that support implicit invocation: Smalltalk-80, Field, etc? Indeed, the use of the mediator approach does not strictly require ABTs.
Reference: [Hoare 84] <author> C.A.R. Hoare, </author> <title> "Programming: </title> <journal> Sorcery or Science," IEEE Software 1,2, </journal> <month> April, </month> <year> 1983, </year> <pages> pp. 5-16, </pages> <editor> in P.W. Oman and T.G. Lewis, Eds., </editor> <publisher> (Los Alamitos: IEEE Computer Society Press), </publisher> <year> 1990, </year> <pages> pp. 273-283. </pages>
Reference-contexts: This is not a defect of their research; it is a necessity. All advances in engineering are tested first on small-scale models, in wave tanks, or in wind tunnels. Without models, the research would be prohibitively expensive, and progress would be correspondingly slow <ref> [Hoare 84, p. 282] </ref>. 121 8.2 Limitations of Implicit Invocation A behavioral ER model represents a complex behavior as a composition of simpler behaviors in a system of relationships. Each relationship must be satisfied after completion of an operation on a constituent behavior.
Reference: [Hoare 87] <author> C.A.R. Hoare, </author> <title> "An Overview of Some Formal Methods for Program Design," </title> <journal> IEEE Computer 20,9, </journal> <year> 1987. </year>
Reference-contexts: Mediator based implementations, by contrast, are imperative constructs. Their foundation is broadcast-based implicit invocation, which construct implements sequential invocation (in some unspecified order) of operations registered by mediators representing behavioral relationships. It is well known that logical conjunction cannot always be implemented directly by sequential composition <ref> [Hoare 87] </ref>. Yet, that is what the mediator method does. Events invoke multiple mediators to implement the conjunction of the behavioral relationships that the mediators implement individually.
Reference: [Hudson and Mohamed 90] <author> S.E. Hudson and S.P. Mohamed, </author> <title> "Interactive Specification of Flexible User Interface Displays," </title> <journal> ACM Transactions on Information Systems 8,3, </journal> <pages> pp. 269-288, </pages> <year> 1990. </year>
Reference-contexts: It is not hard to define adapter objects to add the level of indirection needed for generic mediators. 136 9.1.4 Constraint Programming Constraint programming systems are also based on a separate representation of relationships. Such systems include Penguims <ref> [Hudson and Mohamed 90] </ref>, ThingLab II [Freeman-Benson, Maloney, and Borning 90], Kaleidoscope [Freeman-Benson 90, Lopez, Freeman-Benson & Borning 93] (which extends the ThingLab II mechanisms by adding linguistic constructs for abstracting low-level constraints into compound constraint objects), and CLP (R) [Jaffar et al. 92].
Reference: [ISO/IEC JTC1/SC21/WG4 92] <author> ISO/IEC JTC1/SC21/WG4, </author> <title> "General Relationship Model|Third Working Draft: </title> <address> ISO/IEC JTC1/SC21 N 7126," </address> <month> May, </month> <year> 1992. </year>
Reference-contexts: First, the language is intended for specification, not implementation, while ABTs provide a medium for implementing relationships in common programming languages. The ISO Generalized Relationship Model <ref> [ISO/IEC JTC1/SC21/WG4 92, Kilov et al. 92] </ref> is similar in this regard. Second, contracts often specify that objects invoke each other. This biases implementations towards hardwired designs.
Reference: [Jackson 75] <author> M.A. Jackson, </author> <title> Principles of Program Design, </title> <publisher> (London: Academic Press), </publisher> <year> 1975. </year>
Reference-contexts: Even in the absence of formal transformations, the existence and importance of the structures of correspondences between representations is widely accepted. Jackson <ref> [Jackson 75] </ref> emphasizes that a close correspondence between problem and solution structure is key to reducing the difficulty of evolution; Meyer [Meyer 88], DeChampeaux [de Champeaux, Lea and Faure 93], and many others echo similar concerns. 3.2.2 Specification. To begin, I take behavioral ER models as high-level representations.
Reference: [Jacky and Kalet 86] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Approach to a Large Scientific Application," </title> <booktitle> OOPSLA '86 Object Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <editor> Meyrowitz, N., ed., </editor> <year> 1986, </year> <pages> pp. 368-376. </pages>
Reference-contexts: To modify an anatomical model, the dosimetrist terminates the dose display, runs then terminates the anatomy modeling tool, runs the dose computation program, then restarts the dose display. 89 Second, many systems provide rigid user interfaces. In Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, the user traverses a broad, deep, fixed menu tree to change plans, update models, tailor visualizations, use the patient database, etc. The visualization tools are inflexible, too. <p> These limitations make it hard quickly simulate plans. Third, to the extent that existing systems are tightly integrated, their architectures are often so inflexible as to severely complicate evolution. For example, despite the object-oriented architecture of Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, tight integration of prototype AI-based planning tools [Kalet 92c, Paluszynski 89a] is prohibitively expensive.
Reference: [Jacky and Kalet 87b] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Programming Discipline for Standard Pascal," </title> <journal> Communications of the ACM 30,9, </journal> <pages> pp. 772-776, </pages> <month> September, </month> <year> 1987. </year>
Reference-contexts: To modify an anatomical model, the dosimetrist terminates the dose display, runs then terminates the anatomy modeling tool, runs the dose computation program, then restarts the dose display. 89 Second, many systems provide rigid user interfaces. In Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, the user traverses a broad, deep, fixed menu tree to change plans, update models, tailor visualizations, use the patient database, etc. The visualization tools are inflexible, too. <p> These limitations make it hard quickly simulate plans. Third, to the extent that existing systems are tightly integrated, their architectures are often so inflexible as to severely complicate evolution. For example, despite the object-oriented architecture of Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref>, tight integration of prototype AI-based planning tools [Kalet 92c, Paluszynski 89a] is prohibitively expensive.
Reference: [Jaffar et al. 92] <author> Jaffar, J., Michaylov, S., Stuckey, P., Yap, R. </author> <title> "The CLP(R) Language and System," </title> <journal> ACM Transactions on Programming Languages and Systems 14,3, </journal> <month> July, </month> <year> 1992, </year> <pages> pp. 339-395. </pages>
Reference-contexts: Such systems include Penguims [Hudson and Mohamed 90], ThingLab II [Freeman-Benson, Maloney, and Borning 90], Kaleidoscope [Freeman-Benson 90, Lopez, Freeman-Benson & Borning 93] (which extends the ThingLab II mechanisms by adding linguistic constructs for abstracting low-level constraints into compound constraint objects), and CLP (R) <ref> [Jaffar et al. 92] </ref>. Using these systems, one organizes a program as a set of variables and a set of constraints over those values that are to be solved, or maintained as the variable values are changed. <p> The declarative notations used in some constraint systems also spare designers from having to translate specifications into error-prone imperative code. In exchange for these advantages, constraint programming systems often restrict the set of problems that can be handled. Some system only solve systems of linear inequa-tions <ref> [Jaffar et al. 92] </ref>. Others loosen the semantic restrictions while retaining automation, but at the cost of having to give up declarative notations. ThingLab II [Freeman-Benson, Maloney, and Borning 90] strikes an interesting compromise in this dimension.
Reference: [Johnson 92] <author> R.E. Johnson and V.F. Russo, </author> <title> "Reusing Object-Oriented Designs," </title> <institution> University of Illinois at Urbana-Champaign, </institution> <type> Technical Report UIUCDCS-R-91-1696, </type> <year> 1991. </year> <month> 154 </month>
Reference-contexts: First, it supports treatment planning in clinical practice. Second, it provides a platform for research on uses of software technologies in treatment planning. In the second role, Prism is something like a framework <ref> [Johnson 92] </ref>. It provides a basic environment can be extended with additional tools. A tool that computes radiation target volumes based on mathematical models of tumor shape and type and patient movement|a tool not foreseen in the original specification|was recently integrated.
Reference: [Keller, Cameron, Taylor, and Troup 91] <author> R.K. Keller, M. Cameron, R.N. Taylor, </author> <title> and D.B. </title> <booktitle> Troup, "User Interface Development and Software Environments: The Chiron-1 System," Proceedings of the 13th International Conference on Software Engineering, </booktitle> <month> May, </month> <year> 1991, </year> <title> Austin, </title> <booktitle> Texas, </booktitle> <pages> pp. 208-218. </pages>
Reference-contexts: The mediator method aggressively generalizes the special case, providing the designer with a more versatile medium for conceiving and representing systems. The APPL/A system provides a model for concurrency control lacking in the mediator approach. Marrying the strengths of these efforts is a promising research direction. 9.2.3 Chiron Chiron-1 <ref> [Keller, Cameron, Taylor, and Troup 91] </ref> also exhibits what can be seen as a special case of the mediator method. In Chiron-1, artist objects maintain consistency between arbitrary objects and objects called abstract depictions, representations from which a concrete, graphical displays of the underlying objects can readily be generated.
Reference: [Kalet and Jacky 82] <author> I. Kalet and J. Jacky, </author> <title> "A Research-Oriented Treatment Planning Program System," </title> <booktitle> Computer Programs in Biomedicine 14, </booktitle> <pages> pp. 85-98, </pages> <year> 1982. </year>
Reference-contexts: Taylor's observation has clearly been borne out in the radiation treatment planning domain. First, in many systems, different tasks are handled by stand-alone, "Unix-like" tools that run as separate processes and are loosely integrated through shared files. Kalet's first system <ref> [Kalet and Jacky 82] </ref> integrated anatomy modeling, beam specification, dose computation, and visualization tools this way.
Reference: [Kalet et al. 91] <author> I. Kalet, J. Jacky, S. Kromhout-Shiro, B. Lockyear, M. Niehaus, C. Sweeney, and J. Unger, </author> <title> "The Prism Radiation Treatment Planning System," </title> <type> Technical Report 91-10-03, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, </address> <month> October 31, </month> <year> 1991. </year>
Reference: [Kalet et al. 92] <author> I. Kalet, J. Unger, C. Sweeney, S. Kromhout-Shiro, J. Jacky, and M. Niehaus, </author> <title> "Prism Graphical User Interface Specification," </title> <type> Technical Report 92-02-02, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 18, </address> <year> 1992. </year>
Reference: [Kalet 92] <author> I. Kalet, </author> <title> "SLIK Programmer's Guide," </title> <type> Technical Report 92-02-01, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 17, </address> <year> 1992. </year>
Reference-contexts: I began to work with Kalet about once a week over a period of about a year analyzing the requirements by crafting behavioral ER models, designing 81 infrastructure (e.g., graphical user interface widgets, an implicit invocation mechanism, and basic ABTs and mediators <ref> [Kalet 92] </ref>), and advising on details of implementation. My contribution was the architecture of Prism. I was not always involved in detailed design or implementation.
Reference: [Kalet 92c] <author> I. Kalet, </author> <title> "Artificial Intelligence Applications in Radiation Therapy," in Advances in Radiation Oncology Physics: Dosimetry, Treatment Planning, </title> <editor> and Brachytherapy, J.A. Purdy, ed., </editor> <year> 1992, </year> <pages> pp. 1058-1085. </pages>
Reference-contexts: Third, to the extent that existing systems are tightly integrated, their architectures are often so inflexible as to severely complicate evolution. For example, despite the object-oriented architecture of Kalet's second system [Jacky and Kalet 86, Jacky and Kalet 87b], tight integration of prototype AI-based planning tools <ref> [Kalet 92c, Paluszynski 89a] </ref> is prohibitively expensive.
Reference: [Kernighan and Ritchie] <author> Kernighan and Ritchie, </author> <title> The C Programming Language. </title>
Reference-contexts: Kalet's second system, which is still in use as Prism is phased in, has 41,000 lines of Pascal, 5000 of which are for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 lines of C <ref> [Kernighan and Ritchie] </ref> and C++ [Stroustrup 86] in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C 3 Prism performs adequately on high-end workstations.
Reference: [Kilov and Ross 94] <author> Kilov, H. and Ross, J., </author> <title> Information Modeling: an Object-Oriented Approach, </title> <address> (Englewood Cliffs, N.J.: </address> <publisher> Prentice Hall), </publisher> <year> 1994. </year>
Reference-contexts: Data modeling can express some behavior, but not enough. Cardinality constraints on relationships, for example| e.g., every employee has one boss|do imply some behavior: e.g., adding an employee requires adding an association mapping the employee to a corresponding boss <ref> [Kilov and Ross 94] </ref>. However, simple constraints of this kind are not rich enough to effectively model the systems described in this work. 134 9.1.2 The Object-Relationship Model Rumbaugh [Rumbaugh 87] is largely responsible for introducing the relationship as first-class concept to the object-oriented community.
Reference: [Kilov et al. 92] <author> H. Kilov, B. Moore, L. S. Redmann, </author> <title> "Proposed U.S. Comments on General Relationship Model|Third Working Draft," Accredited Standards Committee X3|Information Processing Systems Document Number X3T5/92-296 X3T5.4/92-1142, </title> <month> September 14, </month> <year> 1992. </year> <month> 155 </month>
Reference-contexts: First, the language is intended for specification, not implementation, while ABTs provide a medium for implementing relationships in common programming languages. The ISO Generalized Relationship Model <ref> [ISO/IEC JTC1/SC21/WG4 92, Kilov et al. 92] </ref> is similar in this regard. Second, contracts often specify that objects invoke each other. This biases implementations towards hardwired designs.
Reference: [Krasner and Pope 88] <author> G.E. Krasner and S.T. Pope, </author> <title> "A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80," </title> <journal> Journal of Object Oriented Programming 1,3, </journal> <pages> pp. 26-49, </pages> <month> August/September </month> <year> 1988. </year>
Reference-contexts: In practice, many integration requirements call for such asymmetric propagation. In the automobile, engaging the transmission requires the doors to be locked|but not vice versa. In the programming environment, saving the source code causes object code to be updated. In the Smalltalk-80 MVC <ref> [Krasner and Pope 88] </ref>, changing a model updates its views. 2.2.3 Adding a Symmetric Behavioral Relationship Another common class of integration requirements call for behavioral relationships in volving symmetric or multi-directional propagation of effects|often to maintain an invariant over several objects.
Reference: [Kutcher 88] <author> G.J. Kutcher, R. Mohan, J.S. Laughlin, G. Barest, L. Brewster, C. Chue, C. Berman, and Z. Fuks, </author> <title> "Three Dimensional Radiation Treatment Planning," </title> <booktitle> Dosime-try in Radiotherapy: Proceedings of an International Symposium on Dosimetry in Radiotherapy 2, </booktitle> <address> Vienna, </address> <month> September, </month> <year> 1988, </year> <pages> pp. 39-63. </pages>
Reference: [Larus 89] <author> J. R. Larus, </author> <title> Restructuring Symbolic Programs for COncurrent Execution on Multiprocessors, </title> <type> Ph.D. dissertation, </type> <institution> UC Berkeley Computer Science, </institution> <month> May </month> <year> 1989. </year> <note> Also appears as Technical Report No. UCB/CSD 89/502. </note>
Reference-contexts: The mediator method also allowed Griswold to reuse a substantial, existing software component: over 10,000 lines of Common Lisp/CLOS [Bobrow et al. 88] comprising the PDG, which was built by Jim Larus as part of his Curare system <ref> [Larus 89] </ref>. 80 Localizing the relationship between the AST and the PDG in the mediator was also useful in providing a place for the code and data that implemented a somewhat complex approach to propagating changes from the AST to the PDG.
Reference: [Lehman 80] <author> M.M. Lehman, </author> <title> "Programs, Life Cycles and Laws of Software Evolution," </title> <journal> Proceedings of the IEEE Special Issue on Software Engineering 68, </journal> <volume> 9, </volume> <month> September, </month> <year> 1980, </year> <pages> pp. 1060-1076, </pages> <editor> in M.M Lehman and L.A. Belady, Eds., </editor> <title> Program Evolution: Processes of Software Change, </title> <publisher> (London: Academic Press), </publisher> <year> 1985, </year> <pages> pp. 393-449. </pages>
Reference-contexts: As evolving integration requirements continue to be met, unnecessarily structural complexity accumulates, driving up the cost of change. Eventually|often quickly|the cost becomes prohibitive of further integration or evolution <ref> [Lehman 80] </ref>. This dissertation makes two contributions to the software engineering field. The first is a new design method|the mediator method |that overcomes the problems with common methods without costly new mechanisms. <p> Lehman states "There should be no side effects, no incidental consequences of the execution of any code sequence <ref> [Lehman 80, p. 420] </ref>." Yet, side effects are key to the mediator method. Calling an operation executes its code, but also codes registered by arbitrary mediator objects.
Reference: [Lehman 81] <author> M.M. Lehman, </author> <title> "Programming Productivity|A Life Cycle Concept," </title> <booktitle> Proceedings of CompCon 81, IEEE Cat. </booktitle> <volume> No. 81CH-1702-0, </volume> <month> September, </month> <year> 1981, </year> <pages> pp. 232-241, </pages> <editor> in M.M Lehman and L.A. Belady, Eds., </editor> <title> Program Evolution: Processes of Software Change, </title> <publisher> (London: Academic Press), </publisher> <year> 1985, </year> <pages> pp. 469-489. </pages>
Reference-contexts: Boehm [Boehm 88, p.251] implicitly traces the idea to Bennington's stagewise process model [Benning-ton 56], an early view of software development as a sequence of transformations from higher to lower level representations. Lehman <ref> [Lehman 81, p. 474] </ref> finds the same idea in the transformational model of Zurcher and Randell [Zurcher and Randell 68]. The idea appears again in the waterfall model [Royce 70]. <p> If the source and object models of this transformation are both formally described and if a verified mechanical transformation is used, the precise correspondence between the representations may be guar anteed <ref> [Lehman 81, pp. 483-484] </ref>. Even in the absence of formal transformations, the existence and importance of the structures of correspondences between representations is widely accepted.
Reference: [Lehman and Belady 85] <editor> M.M Lehman and L.A. Belady, Eds., </editor> <title> Program Evolution: Processes of Software Change, </title> <publisher> (London: Academic Press), </publisher> <year> 1985, </year> <pages> pp. 355-373. </pages>
Reference-contexts: The important works of Belady and Lehman <ref> [Lehman and Belady 85] </ref> characterize statistical invariants that appear to govern the development, evolution, value over time, and ultimate ossification of large software systems.
Reference: [Linton, Vlissides, and Calder 89] <author> M.A. Linton, J.M Vlissides, and P.R. Calder, </author> <title> "Composing User Interfaces with InterViews," </title> <booktitle> Computer 22,2, </booktitle> <pages> pp. 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: One kind of mediator projects n-dimensional meshes into two dimensional meshes. Another integrates 2-D meshes with views based on the InterViews toolkit <ref> [Linton, Vlissides, and Calder 89] </ref>. A third kind of mediator keeps "dots" on the screen consistent with mesh vertices as either changes. This system has several structural properties that help to validate the claims made for the mediator method.
Reference: [Liskov and Zilles 75] <author> B.H. Liskov and S. N. Zilles, </author> <title> "Specification Techniques for Data Abstractions," </title> <journal> IEEE Transactions of Software Engineering SE-1,1, </journal> <month> March, </month> <year> 1975, </year> <pages> pp. 7-19. 156 </pages>
Reference-contexts: An ADT defines a class of objects in terms of the state spaces of the objects, possible initial states of objects, and operations that can be applied to observe or change the state of objects <ref> [Liskov and Zilles 75, Meyer 88] </ref>. I will argue that there is a second kind of abstract type: one that augments the ADT with the means for one object to implicitly extend certain behaviors of others. <p> In one approach, based on hierarchical composition of ADTs <ref> [Liskov and Zilles 75] </ref>, one represents an integrated behavior as an object that encapsulates and manages objects representing the behaviors to be integrated. A second approach integrates "peer" objects by having them communicate through implicit or explicit invocation. <p> Unfortunately, as discussed below, this method does not solve the problem of clients having to change, and it leads to design structures that unnecessarily complicate integration and evolution. The encapsulation design method has its roots in the theory of hierarchical composi tion of abstract data types <ref> [Liskov and Zilles 75] </ref>. The strategy is to implement integrated systems using given systems as hidden implementation components. One integrates the behaviors of given modules by interposing wrapper modules between modules and their clients. Responsibility for integration is then placed with the wrapper module.
Reference: [Lopez, Freeman-Benson & Borning 93] <author> Lopez, G., Freeman-Benson, B. and Borning, A., </author> <title> "Kaleidoscope: A Constraint Imperative Programming Language," </title> <editor> in Mayoh, B. et al. (Eds.), </editor> <booktitle> Constraint Programming, NATO Advanced Institute Series, Series F: Computer and System Sciences, </booktitle> <publisher> Springer-Verlag, </publisher> <year> (1993). </year> <note> Also appears as Technical Report 93-09-04, </note> <institution> University of Washginton Department of Computer Science, </institution> <address> Seattle, Washgington, </address> <month> September, </month> <year> 1993. </year>
Reference-contexts: Such systems include Penguims [Hudson and Mohamed 90], ThingLab II [Freeman-Benson, Maloney, and Borning 90], Kaleidoscope <ref> [Freeman-Benson 90, Lopez, Freeman-Benson & Borning 93] </ref> (which extends the ThingLab II mechanisms by adding linguistic constructs for abstracting low-level constraints into compound constraint objects), and CLP (R) [Jaffar et al. 92].
Reference: [Maloney 91] <author> J. Maloney, </author> <title> Using Constraints for User Interface Construction, </title> <type> Ph.D. Dissertation, </type> <institution> University of Washington Department of Computer Science and Engineering Technical Report 91-08-12, </institution> <month> August, </month> <year> 1991. </year>
Reference-contexts: This implementation structure imposes severe semantic and structural restrictions that make this system inappropriate for implementing complex, integrated environments. One problem is that "constraints" compute values in a functional manner, which makes impractical incremental consistency maintenance in the face of small changes to structured objects, such as sets <ref> [Maloney 91] </ref>. Another problem is that the constraint satisfaction procedures cannot update more than one constrained variable; but doing this is critical for incremental constraint maintenance.
Reference: [McCabe 91] <author> T. McCabe. </author> <title> Programming with Mediators: Developing a Graphical Mesh Environment. </title> <type> Masters Thesis, </type> <institution> University of Washington. </institution> <year> 1991. </year>
Reference-contexts: Once the tools and their respective parts of the data bases had been developed and tested, we integrated them by adding mediators to keep related representations consistent. 6.2.2 Computer-Aided Geometric Design System Tom McCabe developed a prototype "kernel" for a computer-aided geometric design (CAGD) system <ref> [McCabe 91] </ref>, supporting interactive, multi-view editing of a mesh. A mesh is a discrete representation of a surface|technically a two-manifold|embedded in an n-dimensional Euclidean space. A mesh is similar to a graph, but it has topology: edges are ordered around vertices.
Reference: [Meyer 88] <author> B. Meyer. </author> <title> Object-Oriented Software Construction, </title> <publisher> (Cambridge: Prentice-Hall), </publisher> <year> 1988. </year>
Reference-contexts: An ADT defines a class of objects in terms of the state spaces of the objects, possible initial states of objects, and operations that can be applied to observe or change the state of objects <ref> [Liskov and Zilles 75, Meyer 88] </ref>. I will argue that there is a second kind of abstract type: one that augments the ADT with the means for one object to implicitly extend certain behaviors of others. <p> Even in the absence of formal transformations, the existence and importance of the structures of correspondences between representations is widely accepted. Jackson [Jackson 75] emphasizes that a close correspondence between problem and solution structure is key to reducing the difficulty of evolution; Meyer <ref> [Meyer 88] </ref>, DeChampeaux [de Champeaux, Lea and Faure 93], and many others echo similar concerns. 3.2.2 Specification. To begin, I take behavioral ER models as high-level representations.
Reference: [Meyers 91] <author> S. Meyers, </author> <title> "Difficulties in Integrating Multiview Development Systems," </title> <journal> IEEE Software, </journal> <pages> pp. 49-57, </pages> <month> January, </month> <year> 1991. </year>
Reference-contexts: Another problem is that the events and operations that objects support may not be declared, making it hard to understand the abstractions that objects support <ref> [Meyers 91] </ref>. 1.4 The Mediator Method This dissertation presents a new design method that largely overcomes the problems with common design methods to ease the design, realization, and evolution of integrated sys tems.
Reference: [Moss 87] <author> J. Moss, </author> <title> "Nested Transactions: An Introduction," in Concurrency Control and Reliability in Distributed Systems. </title> <editor> B. Bhargava, ed., </editor> <publisher> Van Nostrand Reinhold, </publisher> <year> 1987. </year>
Reference-contexts: Mediator modularizations of Field-like environments are quite plausible. There may also be valuable solutions that combine the optimistic style of Field with more rigorous concur-rency control where needed. Nested transactions <ref> [Moss 87] </ref> in particular may be valuable in this regard. 123 8.4 Non-Conservative Integration The behavioral relationships discussed so far in this work have a common property: they conserve the behaviors they relate. <p> However, the mediator's lack of support for transactions (owing primarily to the lack of support in common languages) is a serious shortcoming for developers of large or complex systems. It appears that mediators could exploit transactions if they were implemented on a platform supporting objects and nested transactions <ref> [Moss 87] </ref>; but I still have yet to verify the practical utility of this combination. 9.2.2 APPL/A APPL/A [Sutton, Heimbigner, and Osterweil 90] is an Ada-based programming language that supports software process programming.
Reference: [Notkin et al. 93] <author> D. Notkin, D. Garlan, W.G. Griswold, and K. Sullivan, </author> <title> "Adding Implicit Invocation to Languages: Three Approaches," </title> <booktitle> Proceedings of the JSSST International Symposium on Object Technologies for Advanced Software (November 1993). </booktitle>
Reference-contexts: The main problem is representing events. This is not hard <ref> [Notkin et al. 93] </ref>. It is quite easy in object-oriented languages, which already support objects with states and operations. We represent events in interfaces as instance variables holding event objects.
Reference: [Paluszynski 89a] <author> W. Paluszynski, </author> <title> Designing Radiation Therapy for Cancer, an Approach to Knowledge-Based Optimization, </title> <type> Ph.D. Dissertation, </type> <institution> University of Wash-ington, </institution> <year> 1990. </year>
Reference-contexts: Third, to the extent that existing systems are tightly integrated, their architectures are often so inflexible as to severely complicate evolution. For example, despite the object-oriented architecture of Kalet's second system [Jacky and Kalet 86, Jacky and Kalet 87b], tight integration of prototype AI-based planning tools <ref> [Kalet 92c, Paluszynski 89a] </ref> is prohibitively expensive.
Reference: [Parnas 72] <author> D. L. Parnas, </author> <title> "On the Criteria to Be Used in Decomposing Systems into Modules," </title> <journal> Communications of the ACM 5,12, </journal> <pages> pp. 1053-58, </pages> <month> December </month> <year> 1972. </year> <month> 157 </month>
Reference-contexts: In contrast with common design methods, this method overcomes the problems of integration and evolution because it promotes software modularizations that anticipate evolving integration requirements, in analogy with Parnas's information hiding design method, which focused on anticipating the evolution of data representations and algorithms <ref> [Parnas 72] </ref>. To see better how this method eases evolution consider two evolutionary changes. <p> In contrast to the statistical|essentially thermodynamical|approach of Lehman and Belady, David Parnas takes a more classical approach to characterizing relationships between structure and evolution. Parnas's foundational work on information hiding <ref> [Parnas 72] </ref> argues that not all modular decompositions of software representations are equally good with respect to ease of evolution; but rather that evolution is eased by decompositions in which modules hide design decisions that are subject to change|in particular, choices about data representations and algorithms.
Reference: [Parnas 79] <author> D. L. Parnas, </author> <title> "Designing Software for Ease of Extension and Contraction," </title> <journal> IEEE Transactions on Software Engineering SE-5,2, </journal> <pages> pp. 128-138, </pages> <month> March, </month> <year> 1979. </year>
Reference-contexts: Parnas's Work on extension and contraction is also relevant <ref> [Parnas 79] </ref>. Here, Parnas argues that cyclical dependencies among modules complicates the design and evolution 144 of families of systems, the reason being that all modules must be present and work properly for any one to do so.
Reference: [Pound 37] <author> Ezra Pound, </author> <title> The ABC of Reading, </title> <address> (New York : New Directions), 1960, c. </address> <year> 1934 (1987 </year> <month> printing). </month>
Reference-contexts: To know it, you have got to know its limits, both what it is and what it is not. What substances are harder or softer, what more resilient, what more compact <ref> [Pound 37] </ref>." In this spirit, this chapter characterizes the work presented in this document by placing it in the context of other related efforts. 9.1 Behavioral Entity Relationship Modeling In this section, I consider work related to behavioral ER modeling, in particular, emphasizing the conception, specification, implementation, and evolution of relationships
Reference: [Reiss 90] <author> S. P. Reiss, </author> <title> "Connecting Tools using Message Passing in the Field Environment," </title> <journal> IEEE Software 7,4, </journal> <pages> pp. 57-66, </pages> <month> July, </month> <year> 1990. </year>
Reference-contexts: As integration requirements evolve, the level of unnecessary complexity mounts. Although details differ, the static and dynamic structural properties are about the same as with hardwiring. 1.3.4 Broadcast Message Servers The broadcast message server (BMS) method, pioneered by Reiss <ref> [Reiss 90] </ref>, specializes the implicit invocation method by using a distinguished broadcast message server component to coordinate communication among other components. <p> be changed, and in ways that compromise their simplicity and independence; nor are the behavioral relationships expressed in a form that allows them to be identified or changed, added, or removed as units. 4.6 Message Server The broadcast message server (BMS) method was pioneered by Reiss in the FIELD project <ref> [Reiss 90] </ref>. Contributions of the project include the BMS mechanism, an associated design method, and a family of Unix-based [Ritchie and Thompson 78] integrated programming environments designed using this method. The FIELD method is now commercially supported, e.g., by Hewlett-Packard's Softbench [Cagan 90].
Reference: [Ritchie and Thompson 78] <author> D.M. Ritchie, K. Thompson, </author> <title> "The Unix Time-sharing System," </title> <journal> Bell System Technical Journal 57,6, </journal> <volume> part 2, </volume> <pages> pp. 1905-1930, </pages> <address> July-August, </address> <year> 1987. </year>
Reference-contexts: Contributions of the project include the BMS mechanism, an associated design method, and a family of Unix-based <ref> [Ritchie and Thompson 78] </ref> integrated programming environments designed using this method. The FIELD method is now commercially supported, e.g., by Hewlett-Packard's Softbench [Cagan 90]. Fundamentally, the BMS method specializes the implicit invocation method by requiring communications between integrated modules to pass through a special component, the BMS.
Reference: [Rosenman et al. 89] <author> J. Rosenman, G.W. Sherouse, H. Fuchs, S. Pizer, A. Skinner, C. Mosher, K. Novins, and J. Tepper, </author> <title> "Three-dimensional Display Techniques in Radiation Therapy Treatment Planning", </title> <journal> International Journal of Radiation Oncology, Biology and Physics 16, </journal> <year> 1989, </year> <pages> pp. 263-269. </pages>
Reference-contexts: Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 lines of C [Kernighan and Ritchie] and C++ [Stroustrup 86] in GRATIS <ref> [Rosenman et al. 89] </ref>, of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C 3 Prism performs adequately on high-end workstations. Kalet uses HP9000 series 700 workstations for development and production.
Reference: [Royce 70] <author> W.W. </author> <title> Royce, "Managing the Development of Large Software Systems: Concepts and Techniques," </title> <booktitle> Proceedings of Wescon, </booktitle> <month> August, </month> <year> 1970, </year> <booktitle> also in Proceedings of the 9th International Conference on Software Engineering, </booktitle> <publisher> (Computer Society Press), </publisher> <year> 1987. </year>
Reference-contexts: Lehman [Lehman 81, p. 474] finds the same idea in the transformational model of Zurcher and Randell [Zurcher and Randell 68]. The idea appears again in the waterfall model <ref> [Royce 70] </ref>. The invariant across all these process models (and many others) is the view of software as multi-representational, with correspondences between representations.
Reference: [Rumbaugh 87] <author> J. Rumbaugh, </author> <title> "Relations as Semantic Constructs in an Object-Oriented Language," </title> <booktitle> Proceedings of OOPSLA, </booktitle> <year> 1987, </year> <pages> pp. 466-481. </pages>
Reference-contexts: However, simple constraints of this kind are not rich enough to effectively model the systems described in this work. 134 9.1.2 The Object-Relationship Model Rumbaugh <ref> [Rumbaugh 87] </ref> is largely responsible for introducing the relationship as first-class concept to the object-oriented community. He argued that representing relationships in terms of pointers in the objects to be related reduces clarity and complicates software evolution. This notion is the object-oriented analog of Chen's idea.
Reference: [Rumbaugh et al. 91] <author> J. Rumbaugh, . Blaha, W. Premerlani, F. Eddy, W. Lorenson, </author> <title> Object-Oriented Modeling and Design, </title> <address> (Englewood Cliffs: </address> <publisher> Prentice Hall), </publisher> <year> 1991. </year>
Reference-contexts: This idea was incorporated into a popular object-oriented modeling and design method <ref> [Rumbaugh et al. 91] </ref>. Behavioral ER modeling, although similar in spirit, differs both in its emphasis on defining relationships with rich behaviors and in its approach to implementing behavioral relationships as mediators.
Reference: [Scheifler and Gettys 86] <author> R.W. Scheifler and J. Gettys. </author> <title> "The X Window System," </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5 ,2, </volume> <pages> pp. 79-109, </pages> <year> 1986. </year>
Reference-contexts: The design and implementation of this model is straightforward based on the earlier examples. This structure paid off when Kalet discovered that the initial design for graphics rendering was unworkable. The problem was in using X windows <ref> [Scheifler and Gettys 86] </ref> to render multi-layered pictures with wireframe, contoured objects rendered over background, bitmapped images. The mediator-based architecture made it easy to fix the problem because all graphics code was localized in the submediators: each was responsible for rendering its object in its view.
Reference: [Snyder 89] <author> L. Snyder, </author> <title> "The XYZ Abstraction Levels of Poker-like Languages," </title> <booktitle> Proceedings of the Second Workshop on Parallel Compilers and Algorithms, 1989, </booktitle> <address> Urbana, Illinois. </address> <month> 158 </month>
Reference-contexts: greater depth, in the context of a detailed case study of the mediator method, as it was used in designing the Prism radiation treatment planning system. 6.2.1 Parallel Programming Environment The first system in which I applied the mediator method was a prototype environment for programming large-scale, nonshared-memory parallel computers <ref> [Snyder 89] </ref>. At the highest level, a program in this environment is structured as a sequential composition of 77 phases. Each phase is structured as a graph that represents a parallel program to be run on a network of computing nodes.
Reference: [Spivey 89] <author> J.M. Spivey, </author> <title> The Z Notation: A Reference Manual, </title> <publisher> (Prentiss Hall International), </publisher> <year> 1989. </year>
Reference-contexts: The promoted operations may also extend those operations, to ensure proper integration, by invoking the operations of other encapsulated objects. 1 I use the term promotion in the same way as it is used to describe similar structures in specifications written in Z <ref> [Spivey 89] </ref>. 6 Compiler . . . . . . Save (File f) Compile (File f) Compile (File f) Editor System EditorSave (File f) The wrapper object System encapsulates editor and compiler objects, shaded to indicate they cannot be accessed directly by clients. Arrows indicate invocations.
Reference: [Steele 90] <author> G. Steele, Jr. </author> <title> COMMON LISP, </title> <booktitle> the Language, second edition, </booktitle> <address> (Burlington, MA: </address> <publisher> Digital Press), </publisher> <year> 1990. </year>
Reference-contexts: An event object maintains a list of operations to be implicitly invoked, and the objects to which they are to be applied, when the event is announced [Sullivan and Notkin 92]. Events. The implementation environment for Prism is provided by Common Lisp <ref> [Steele 90] </ref> and CLOS [Bobrow et al. 88]. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this. An event object is an instance of an event class. <p> We applied this approach throughout Prism, at all levels of "granularity," and in solving a range of design problems of several different kinds. 7.6 Development Effort As of November of 1993, Prism was implemented in about 18,000 lines of Common Lisp <ref> [Steele 90] </ref> and CLOS [Bobrow et al. 88] and 4,500 lines of Pascal with 11,000 lines of L a T E X documentation. 2 The Lisp code handles modeling, visualization, and database management. The Pascal, adapted from an earlier system, computes dose distributions.
Reference: [Stefik, Bobrow, and Kahn 86] <author> M.J. Stefik, D.G. Bobrow, and K.M. Kahn, </author> <title> "Integrating Access-Oriented Programming into a Multiparadigm Environment," </title> <journal> IEEE Software, </journal> <pages> pp. 10-18, </pages> <month> January, </month> <year> 1986. </year>
Reference-contexts: See Figure 1.5. 9 Compiler . . . . . . Save (File f) Compile (File f) Editor Implicit invocation is an old idea. Many systems support specialized event mechanisms, including Smalltalk-80 [Goldberg and Robson 83], LOOPS <ref> [Stefik, Bobrow, and Kahn 86] </ref>, APPL/A [Sutton, Heimbigner, and Osterweil 90], and many others. Despite this long history, a precise characterization of implicit invocation and its benefits has only recently emerged [Garlan and Notkin 91, Sullivan and Notkin 92].
Reference: [Stevens, Myers, and Constantine 74] <author> W. Stevens, G. Myers, and L. Constantine, </author> <title> "Structured Design," </title> <journal> IBM Systems Journal 13,2, </journal> <pages> pp. 115-39, </pages> <month> May, </month> <year> 1974. </year>
Reference-contexts: The familiar software engineering idea of coupling of modules <ref> [Stevens, Myers, and Constantine 74] </ref> is based on the idea of references between modules. To support modeling of the reference structures of systems I extend the framework in several steps. First, I define reference as a type of modeling entity.
Reference: [Stroustrup 86] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> (Addison-Wesley: </publisher> <address> Reading, Massachusetts), </address> <year> 1986. </year>
Reference-contexts: Kalet's second system, which is still in use as Prism is phased in, has 41,000 lines of Pascal, 5000 of which are for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in Prism take about 60,000 lines of C [Kernighan and Ritchie] and C++ <ref> [Stroustrup 86] </ref> in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C 3 Prism performs adequately on high-end workstations. Kalet uses HP9000 series 700 workstations for development and production.
Reference: [Sullivan and Notkin 92] <author> K. Sullivan and D. Notkin, </author> <title> "Reconciling Environment Integration and Software Evolution," </title> <journal> ACM Transactions on Software Engineering and Methodology 1, </journal> <volume> 3, </volume> <month> July, </month> <year> 1992. </year>
Reference-contexts: Many systems support specialized event mechanisms, including Smalltalk-80 [Goldberg and Robson 83], LOOPS [Stefik, Bobrow, and Kahn 86], APPL/A [Sutton, Heimbigner, and Osterweil 90], and many others. Despite this long history, a precise characterization of implicit invocation and its benefits has only recently emerged <ref> [Garlan and Notkin 91, Sullivan and Notkin 92] </ref>. The basic advantage of implicit invocation is that it provides engineers with the flexibly to choose the orientations of reference dependences between components that invoke each other. <p> We represent events in interfaces as instance variables holding event objects. An event object maintains a list of operations to be implicitly invoked, and the objects to which they are to be applied, when the event is announced <ref> [Sullivan and Notkin 92] </ref>. Events. The implementation environment for Prism is provided by Common Lisp [Steele 90] and CLOS [Bobrow et al. 88]. Our first task was to support objects having events as well as operations in their interfaces. We used event object-valued instance variables for this. <p> Smalltalk-80 does not declare events; nor do objects register operations with events. Rather, objects register themselves as dependents of other objects. This effectively registers fixed operations defined in the Object base class with events also defined there. (The details are a bit more subtle, as discussed elsewhere <ref> [Sullivan and Notkin 92] </ref>.) One specializes the events by passing application-specific values as event parameters, usually indicating that some "aspect" of an object 129 changed. One specializes registered operations by redefining them in subclasses of Object. <p> Notkin 86, Stefik, Bobrow, and Kahn 86, Krasner and Pope 88, Cohen 89, Reiss 90, Cagan 90, Sutton, Heimbigner, and Osterweil 90, Collins et al. 91, Gorlick 91, Harrison, Kavianpour, and Ossher 92] However, a unified view of the behavior, benefits, and design space for such mechanisms emerged only recently <ref> [Garlan and Notkin 91, Sullivan and Notkin 92] </ref>. A detailed discussion of this work is beyond the scope of this dissertation.
Reference: [Sullivan, Kalet and Notkin 93] <author> K. Sullivan, I.J. Kalet, and D. Notkin, </author> <title> "Prism: A Case Study in Behavioral Entity-Relationship Modeling," </title> <institution> University of Washington Department of Computer Science Technical Report 93-09-03, </institution> <month> September, </month> <year> 1993. </year>
Reference-contexts: Chapters 6 and 7 address this concern by discussing systems built using mediators. After briefly summarizing the intellectual arguments, Chapter 6 discusses prototype and production systems in which mediators were systematically employed. Chapter 7 expands on one, the Prism radiation treatment planning system, presenting it as a case study <ref> [Sullivan, Kalet and Notkin 93] </ref>. Finally, Chapter 8 evaluates this work: whether the problem is important, whether the data support the conclusions, the validity and limitations of the methods used, and so forth. Chapter 9 discusses connections to related work. <p> My experiences with Prism and with the geographical information system discussed below allay this doubt. Prism in particular <ref> [Sullivan, Kalet and Notkin 93] </ref> is a thoroughly documented, substantial example of a system for which requirements were fixed prior to initiation of contact with the mediator method.
Reference: [Sutton, Heimbigner, and Osterweil 90] <author> S. Sutton, D. Heimbigner, and L. Osterweil, </author> <title> "Language Constructs for Managing Change in Process-Centered Environments," </title> <booktitle> Proceedings of SIGSOFT90: Fourth Symposium on Software Development Environments, 1990, </booktitle> <address> Irvine, California, </address> <pages> pp. 206-17. </pages>
Reference-contexts: See Figure 1.5. 9 Compiler . . . . . . Save (File f) Compile (File f) Editor Implicit invocation is an old idea. Many systems support specialized event mechanisms, including Smalltalk-80 [Goldberg and Robson 83], LOOPS [Stefik, Bobrow, and Kahn 86], APPL/A <ref> [Sutton, Heimbigner, and Osterweil 90] </ref>, and many others. Despite this long history, a precise characterization of implicit invocation and its benefits has only recently emerged [Garlan and Notkin 91, Sullivan and Notkin 92]. <p> It appears that mediators could exploit transactions if they were implemented on a platform supporting objects and nested transactions [Moss 87]; but I still have yet to verify the practical utility of this combination. 9.2.2 APPL/A APPL/A <ref> [Sutton, Heimbigner, and Osterweil 90] </ref> is an Ada-based programming language that supports software process programming. The extensions to Ada include relations with programmable implementations, triggers that respond to operations on relations, optionally enforceable predicates on relations, and statements with transaction-like capabilities.
Reference: [Taylor 88] <author> R.N. Taylor, R.W. Selby, M. Young, F.C. Belz, L.A. Clarke, J.C. Wileden, L. Osterweil, A.L. Wolf, </author> <title> "Foundations for the Arcadia Environment Architecture," </title> <booktitle> Proceedings of ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> P. Henderson, Ed., </editor> <address> Boston, Massachusetts, </address> <month> November 28-30, </month> <year> 1988, </year> <pages> pp. 1-13. 159 </pages>
Reference-contexts: In a programming environment, neither the editor or compiler have to be changed if the user coordinates their activities. Unfortunately, this method reduces the value of systems to users. In may even impose unacceptable burdens on them <ref> [Taylor 88, Habermann and Notkin 86] </ref>. Manually coordinating tools in a programming environment is tedious and error-prone, and distracts users from building software. Manually updating graphical views as computerized models change and manually translating and transferring data between tools in computer-aided design (CAD) systems may also unduly burden users.
Reference: [Yourdon 78] <author> E. Yourdon and L. L. Constantine, </author> <title> Structured Design, </title> <address> (New York: </address> <publisher> Your-don Press), </publisher> <year> 1978. </year>
Reference: [Zurcher and Randell 68] <author> F.W. Zurcher and B. Randell, </author> <title> "Iterative Multi-Level Modeling|A Methodology for Computer System Design," </title> <institution> IBM Res. Div. </institution> <type> Rep. </type> <institution> RC-1938, </institution> <month> Nov. </month> <year> 1967. </year> <note> Also Proc. IFIP Congr, 1968, Edinburgh, </note> <month> Aug. </month> <year> 1968, </year> <pages> pp. </pages> <address> 138-142 (Ch 1,3,19,20,21). </address>
Reference-contexts: Boehm [Boehm 88, p.251] implicitly traces the idea to Bennington's stagewise process model [Benning-ton 56], an early view of software development as a sequence of transformations from higher to lower level representations. Lehman [Lehman 81, p. 474] finds the same idea in the transformational model of Zurcher and Randell <ref> [Zurcher and Randell 68] </ref>. The idea appears again in the waterfall model [Royce 70]. The invariant across all these process models (and many others) is the view of software as multi-representational, with correspondences between representations.
References-found: 89

