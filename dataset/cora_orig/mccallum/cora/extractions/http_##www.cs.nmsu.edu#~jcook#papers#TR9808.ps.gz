URL: http://www.cs.nmsu.edu/~jcook/papers/TR9808.ps.gz
Refering-URL: http://www.cs.nmsu.edu/~jcook/papers/
Root-URL: http://www.cs.nmsu.edu
Email: jcook@cs.nmsu.edu alw@cs.colorado.edu  
Title: Event-Based Detection of Concurrency  
Author: Jonathan E. Cook Alexander L. Wolf 
Address: Las Cruces, NM 88003 USA Boulder, CO 80309 USA  
Affiliation: Department of Computer Science Department of Computer Science New Mexico State University University of Colorado  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-860-98 April 1998 New Mexico State University Department of Computer Science Technical Report NMSU-CSTR-9808 April 1998 ABSTRACT Understanding the behavior of a system is crucial in being able to modify, maintain, and improve the system. A particularly difficult aspect of some system behaviors is concur-rency. While there are many techniques to specify intended concurrent behavior, there are few, if any, techniques to capture and model actual concurrent behavior. This paper presents a technique to discover patterns of concurrent behavior from traces of system events. The technique is based on a probabilistic analysis of the event traces. Using met-rics for the number, frequency, and regularity of event occurrences, a determination is made of the likely concurrent behavior being manifested by the system. The technique is useful in a wide variety of software engineering tasks, including architecture discovery, reengineering, user interaction modeling, and software process improvement. This work was supported in part by the National Science Foundation under grant CCR-93-02739 and by the Air Force Material Command, Rome Laboratory, and the Defense Advanced Research Projects Agency under Contract Number F30602-94-C-0253. The content of the information does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. c fl 1998 Jonathan E. Cook and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, D. Gunopulos, and F. Leymann. </author> <title> Mining Process Models from Workflow Logs. </title> <type> Technical Report (draft technical report), </type> <institution> IBM, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: While our work in discovering concurrency from event traces appears to be novel, there certainly has been related work in understanding distributed, concurrent systems. * Agrawal et al. <ref> [1] </ref> investigate producing activity dependency graphs from event-based workflow logs. The logs already identify the partial ordering of concurrent, time-spanning activities, and they are concerned with producing correct and minimal graphs.
Reference: [2] <author> G.S. Avrunin, U.A. Buy, J.C. Corbett, L.K. Dillon, and J.C. Wileden. </author> <title> Automated Analysis of Concurrent Systems with the Constrained Expression Toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: The use of events to characterize behavior is already widely accepted in diverse areas of software engineering, such as program visualization [11], concurrent-system analysis <ref> [2] </ref>, and distributed debugging [3, 6]. The "instant" of an event is relative to the time granularity that is needed or desired. Thus, certain activities that are of short duration relative to the time granularity are represented as a single event.
Reference: [3] <author> P. Bates. </author> <title> Debugging Heterogenous Systems Using Event-Based Models of Behavior. </title> <booktitle> In Proceedings of a Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 11-22. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: The use of events to characterize behavior is already widely accepted in diverse areas of software engineering, such as program visualization [11], concurrent-system analysis [2], and distributed debugging <ref> [3, 6] </ref>. The "instant" of an event is relative to the time granularity that is needed or desired. Thus, certain activities that are of short duration relative to the time granularity are represented as a single event.
Reference: [4] <author> J.E. Cook and A.L. Wolf. </author> <title> Automating Process Discovery through Event-Data Analysis. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <pages> pages 73-82. </pages> <institution> Association for Computer Machinery, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: If one could analyze the trace to discover a model of the behavior, then that model could reliably be used to evaluate, maintain, and modify the system. In previous work <ref> [4, 5] </ref>, we developed methods for using event traces to automatically discover a sequential model of behavior. <p> Throughout, we use the term process to mean the whole system, and the term thread to mean a sequential execution control path within the process, perhaps running concurrently with other threads. Note that our use of the term process is somewhat non-traditional. 2.1 Events Following our previous work <ref> [4, 14] </ref>, we use an event-based model of process actions, where events are used to characterize the dynamic behavior of a process in terms of identifiable, instantaneous actions, such as sending a message, beginning a transaction, or invoking a development tool. <p> One of our successful sequential techniques, Markov, is based on a notion of frequency tables <ref> [4] </ref>. These tables record the frequencies at which each event and event sequence occur in the event stream. Along with frequencies, we also record the number of occurrences of each event type.
Reference: [5] <author> J.E. Cook and A.L. Wolf. </author> <title> Discovering Models of Software Processes from Event-Based Data. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 7(3), </volume> <month> July </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: If one could analyze the trace to discover a model of the behavior, then that model could reliably be used to evaluate, maintain, and modify the system. In previous work <ref> [4, 5] </ref>, we developed methods for using event traces to automatically discover a sequential model of behavior.
Reference: [6] <author> J. Cuny, G. Forman, A. Hough, J. Kundu, C. Lin, L. Snyder, and D. Stemple. </author> <title> The Adriane Debugger: Scalable Application of Event-Based Abstraction. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 85-95. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The use of events to characterize behavior is already widely accepted in diverse areas of software engineering, such as program visualization [11], concurrent-system analysis [2], and distributed debugging <ref> [3, 6] </ref>. The "instant" of an event is relative to the time granularity that is needed or desired. Thus, certain activities that are of short duration relative to the time granularity are represented as a single event.
Reference: [7] <author> J.L. Devore. </author> <title> Probability and Statistics for Engineering and the Sciences. </title> <address> Brooks/Cole, Pacific Grove, California, </address> <note> 3rd edition, </note> <year> 1991. </year>
Reference-contexts: Thus, we need enough data to make the analysis meaningful. How much data does our technique require? The statistical rule of thumb for using probabilities is that the number of observations of an occurrence should be at least five if the probability is to be used in some inference <ref> [7] </ref>. That is, AB in the example above should occur at least five times if we are going to use its frequency in our analysis. <p> The reverse frequencies can easily be computed from the forward frequencies using Bayes' rule <ref> [7] </ref>, so that extra tables are not needed. Unfortunately, this metric alone is insufficient, because the reasoning above applies to sequential branching behavior as well. A two-way branch that is balanced in its production of events will have the same frequency values as a two-way fork.
Reference: [8] <author> M. Diaz, G. Juanole, and J. Courtiat. </author> <title> Observer|A Concept for Formal On-Line Validation of Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(12) 900-913, 1994. 
Reference-contexts: They provide distributed algorithms for evaluating global predicates that specify the correct behavior that the system should be exhibiting. * Diaz et al. <ref> [8] </ref> use an event-based framework for on-line validation of distributed systems. Their mechanism employs an active observer that can listen to events (or messages) and compare the actual behavior to a formal specification of the correct behavior.
Reference: [9] <author> D. Harel. Statecharts: </author> <title> A Visual Formalism for Complex Systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: For concurrent transitions, a set of transitions are taken simultaneously from a state, or a set of transitions are taken when entering a state. It should be evident that we are defining a simplified form of statechart <ref> [9] </ref>. A traditional fork would be a marked state that has a single input transition and multiple output transitions, a traditional join would be a marked state that has multiple input transitions and one output transition, and a synchronization point would have multiple input and output transitions.
Reference: [10] <author> L.J. Holtzblatt, R.L. Piazza, H.B. Reubenstein, S.N. Roberts, and D.R. Harris. </author> <title> Design Recovery for Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(7) </volume> <pages> 461-472, </pages> <year> 1997. </year>
Reference-contexts: The logs already identify the partial ordering of concurrent, time-spanning activities, and they are concerned with producing correct and minimal graphs. There is no notion of identifying synchronization points within the activities. * Holtzblatt et al. <ref> [10] </ref> explore methods of design recovery for distributed systems, where they look at recovering the design architecture of the task flow from the source code.
Reference: [11] <author> R.J. LeBlanc and A.D. Robbins. </author> <title> Event-Driven Monitoring of Distributed Programs. </title> <booktitle> In Proceedings of the Fifth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: The use of events to characterize behavior is already widely accepted in diverse areas of software engineering, such as program visualization <ref> [11] </ref>, concurrent-system analysis [2], and distributed debugging [3, 6]. The "instant" of an event is relative to the time granularity that is needed or desired. Thus, certain activities that are of short duration relative to the time granularity are represented as a single event.
Reference: [12] <author> J.L. Peterson. </author> <title> Petri Nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 223-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: In addition to being created and destroyed, they will synchronize at certain points, and this will be reflected in the events produced. 2 In this paper, example models of concurrent processes are given in the familiar Petri net formalism <ref> [12] </ref>. The separate "threads" of execution in the Petri net models are visible from the connectedness of the places and transitions. Events are produced at transition firings; the sequence of events produced by the process is exactly the sequence of transition firings.
Reference: [13] <author> S. Venkatesan and B. Dathan. </author> <title> Testing and Debugging Distributed Programs Using Global Predicates. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 163-177, </pages> <year> 1995. </year>
Reference-contexts: They do not look at dynamic behavior, and indeed point to this as a limitation in their approach. * Venkatesan and Dathan <ref> [13] </ref> use an event-based framework for testing and debugging distributed programs. They provide distributed algorithms for evaluating global predicates that specify the correct behavior that the system should be exhibiting. * Diaz et al. [8] use an event-based framework for on-line validation of distributed systems.
Reference: [14] <author> A.L. Wolf and D.S. Rosenblum. </author> <title> A Study in Software Process Data Capture and Analysis. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <pages> pages 115-124. </pages> <publisher> IEEE Computer Society, </publisher> <month> February </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Throughout, we use the term process to mean the whole system, and the term thread to mean a sequential execution control path within the process, perhaps running concurrently with other threads. Note that our use of the term process is somewhat non-traditional. 2.1 Events Following our previous work <ref> [4, 14] </ref>, we use an event-based model of process actions, where events are used to characterize the dynamic behavior of a process in terms of identifiable, instantaneous actions, such as sending a message, beginning a transaction, or invoking a development tool.
References-found: 14

