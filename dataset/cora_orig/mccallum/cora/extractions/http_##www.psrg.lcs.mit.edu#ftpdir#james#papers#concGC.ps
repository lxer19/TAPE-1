URL: http://www.psrg.lcs.mit.edu/ftpdir/james/papers/concGC.ps
Refering-URL: http://www.psrg.lcs.mit.edu/publications.html
Root-URL: 
Title: Concurrent Replicating Garbage Collection  
Author: James O'Toole and Scott Nettles 
Abstract: We have implemented a concurrent copying garbage collector that uses replicating garbage collection. In our design, the client can continuously access the heap during garbage collection. No low-level synchronization between the client and the garbage collector is required on individual object operations. The garbage collector replicates live heap objects and periodically synchronizes with the client to obtain the client's current root set and mutation log. An experimental implementation using the Standard ML of New Jersey system on a shared-memory multiprocessor demonstrates excellent pause time performance and moderate execution time speedups. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <booktitle> In SIG-PLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: Essentially all of these collectors require the client to access the to-space version of an object during collections. The technique of Ellis, Li, and Appel <ref> [1] </ref> enforces this restriction by using virtual memory protection to force clients to use only to-space objects. Our technique does not require any unusual operating system or hardware support and it imposes smaller demands on the client than software versions of Bakers algorithm.
Reference: [2] <author> H. G. Baker. </author> <title> List Processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: These and other measurements might answer the policy questions raised in Sections 3.3 and 3.4. 5 Related Work There is a long history of incremental and concurrent copying collectors dating back to Baker <ref> [2] </ref>. Essentially all of these collectors require the client to access the to-space version of an object during collections. The technique of Ellis, Li, and Appel [1] enforces this restriction by using virtual memory protection to force clients to use only to-space objects.
Reference: [3] <author> Hans-Juergen Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly Parallel Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <year> 1991. </year>
Reference-contexts: Brooks' technique [4], later implemented by North and Reppy [12], requires the client to follow a forwarding pointer that leads to the relocated object. This eliminated a test in favor of extra space and an indirection. Work by Boehm, Demers and Shenker <ref> [3] </ref> on a concurrent mark-and-sweep collector uses mutation logging to track changes made by the client. The mutation log is implemented by periodically sampling the dirty page bits maintained by the virtual memory system. The authors observed the possibility of using a from-space invariant for a copying collector.
Reference: [4] <author> Rodney A. Brooks. </author> <title> Trading Data Space for Reduced Time and Code Space in Real-Time Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <year> 1984. </year>
Reference-contexts: The idea of a separate forwarding pointer word first appeared in the context of to-space methods. Brooks' technique <ref> [4] </ref>, later implemented by North and Reppy [12], requires the client to follow a forwarding pointer that leads to the relocated object. This eliminated a test in favor of extra space and an indirection.
Reference: [5] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Stef-fens. </author> <title> On-the-fly Garbage Collection:An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> Novem-ber </month> <year> 1978. </year>
Reference-contexts: The collector copies live immutable objects into a shared heap. To avoid the issue of inconsistent mutable values, all mutable objects are allocated in the shared heap. The shared heap is collected using a concurrent mark-and-sweep algorithm based on Dijkstra <ref> [5] </ref>. When a mutation causes immutable objects that reside in a private heap to become reachable from the shared heap, then these objects are immediately copied into the shared heap.
Reference: [6] <author> D. Doligez and X. Leroy. </author> <title> A Concurrent Generational Garbage Collector for a Multi-Threaded Implementation of ML. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 113-123, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The authors observed the possibility of using a from-space invariant for a copying collector. Two recent collectors for ML are quite closely related to ours and employ variations of the replication idea. Doligez and Leroy <ref> [6] </ref> implemented a concurrent collector that uses a mixed strategy to provide collection for a multithreaded version of CAML. Huelsbergen and Larus [7] implemented a concurrent collector for SML/NJ that uses replicating collection.
Reference: [7] <author> Lorenz Huelsbergen and James R. Larus. </author> <title> A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data. </title> <booktitle> In Proceedings of the 1993 ACM Sym-posiym on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Two recent collectors for ML are quite closely related to ours and employ variations of the replication idea. Doligez and Leroy [6] implemented a concurrent collector that uses a mixed strategy to provide collection for a multithreaded version of CAML. Huelsbergen and Larus <ref> [7] </ref> implemented a concurrent collector for SML/NJ that uses replicating collection. Both of these collectors depend heavily on the fact that ML implementations can distinguish mutable from immutable data. Our technique does not depend on this feature of ML and is therefore more generally applicable.
Reference: [8] <author> J. Gregory Morrisett and Andrew Tolmach. </author> <title> Procs and Locks: </title>
Reference-contexts: The gc thread does this using a Unix signal mechanism taken from the SML/NJ MP system by Morrisett and Tolmach <ref> [8] </ref>. The signal causes the client to enter the garbage collection module and attempt to complete the collection. The client processes the mutation log and scans to-space to perform a limited amount of replication work. <p> We hope to obtain measurements of some multithreaded applications soon. We have heard from Tolmach that the speedups achieved on the benchmarks in his work with Morrisett <ref> [8] </ref> may have been limited because the garbage collector was stop-and-copy and single-threaded. It is possible that those speedups would be closer to linear using a concurrent collector. We are also interested in investigating performance questions about the collector that are not answered by this paper.
References-found: 8

