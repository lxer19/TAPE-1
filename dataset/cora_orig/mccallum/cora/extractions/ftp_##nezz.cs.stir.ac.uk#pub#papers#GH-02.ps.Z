URL: ftp://nezz.cs.stir.ac.uk/pub/papers/GH-02.ps.Z
Refering-URL: http://www.gh.cs.su.oz.au/Grasshopper/Papers/Papers.html
Root-URL: 
Title: Supporting large persistent stores using conventional hardware Make an objects virtual address coincident with its
Author: Francis Vaughan, Alan Dearle 
Date: September 1992,  
Note: 1 Introduction Dynamically translate from a PID to a virtual address on each dereference.  In Proceedings of the 5 th International Workshop on Persistent  to appear in Springer-Verlag Workshops in Computing Series.  
Address: Adelaide Adelaide, Australia  San Miniato, Italy,  
Affiliation: Department of Computer Science, University of  Object Systems,  
Abstract: Persistent programming systems are generally supported by an object store, a conceptually infinite object repository. Objects in such a repository cannot be directly accessed by user programs; to be manipulated they must be fetched from the object store into virtual memory. Thus in these systems, two different kinds of object addresses may exist: those in the object store and those in virtual memory. The action of changing object store addresses into virtual memory addresses has become known as pointer swizzling and is the subject of this paper. The paper investigates three approaches to pointer swizzling: a typical software address translation scheme, a technique for performing swizzling at page fault time and finally a new hybrid scheme which performs swizzling in two phases. The hybrid scheme supports arbitrarily large pointers and object repositories using conventional hardware. The paper Most persistent and database programming languages are supported by an object store, a conceptually infinite repository in which objects reside. In order to manipulate these objects, they must be fetched from the object store into directly addressable memory, usually virtual memory. In systems which support orthogonal persistence [3] this is performed transparently. Thus in these systems, two different kinds of object addresses may exist: those in the backing store (persistent identifiers or PIDs) and those in directly addressable memory (virtual addresses). Many researchers have argued that large pointers (anywhere up to 128 bits) are required to support persistent systems [9, 17]. Persistent pointers need not be the same size as those supported by virtual memory (usually 32 bits); indeed persistent identifiers may be arbitrarily long. This paper presents a new architecture which supports arbitrarily large pointers and persistent stores using conventional hardware. The persistent address of an object may be mapped onto a virtual address in a number of ways: This last option has become known as pointer swizzling and is the subject of this paper. The first option, dynamic translation, is seldom more efficient than swizzling [16]. The second option is only possible if persistent stores are small enough to be contained within concludes with a comparison of these approaches.
Abstract-found: 1
Intro-found: 0
Reference: 1. <institution> "PS-algol Abstract Machine Manual", Universities of Glasgow and St Andrews, PPRR-11-85, </institution> <year> 1985. </year> <note> 2. "PS-algol Reference Manual - fourth edition", </note> <institution> University of Glasgow and St Andrews, </institution> <note> Persistent Programming Research Report 12/88, </note> <year> 1988. </year>
Reference-contexts: PIDs may be arbitrarily large but in current implementations PIDs are identical in size to the normal pointers (known as Local Object Numbers or LONs) used by the PS-algol run time system <ref> [1] </ref> . PIDs are distinguished by having their most significant bit set. Hence it is possible for the PS-algol run time system to distinguish between a LON and a PID.
Reference: 3. <author> Atkinson, M. P., Bailey, P. J., Chisholm, K. J., Cockshott, W. P. and Morrison, R. </author> <title> "An Approach to Persistent Programming", </title> <journal> The Computer Journal, </journal> <volume> vol 26, 4, </volume> <pages> pp. 360 - 365, </pages> <year> 1983. </year>
Reference-contexts: 1 . Introduction Most persistent and database programming languages are supported by an object store, a conceptually infinite repository in which objects reside. In order to manipulate these objects, they must be fetched from the object store into directly addressable memory, usually virtual memory. In systems which support orthogonal persistence <ref> [3] </ref> this is performed transparently. Thus in these systems, two different kinds of object addresses may exist: those in the backing store (persistent identifiers or PIDs) and those in directly addressable memory (virtual addresses).
Reference: 4. <author> Atkinson, M. P., Bailey, P. J., Cockshott, W. P., Chisholm, K. J. and Morrison, R. "POMS: </author> <title> A Persistent Object Management System", </title> <journal> Software Practice and Experience, </journal> <volume> vol 14, 1, </volume> <pages> pp. 49-71, </pages> <year> 1984. </year>
Reference-contexts: It is believed that a variation of this scheme is also used by Object Design [15] . In persistent systems it is unusual to be able to identify a self contained data set and some lazy swizzling is unavoidable. The first persistent systems to employ swizzling <ref> [4] </ref> relied upon a software test to distinguish between PIDs and local addresses. Recently, schemes have been described which avoid performing these tests by performing pointer swizzling at page fault time [18]. <p> We also suggest some implementation techniques that may be utilised in conjunction with such a scheme. The paper concludes with a comparison of the three architectures. 2 . Software address translation The first object systems to be called persistent <ref> [4, 5] </ref> performed lazy pointer swizzling implemented entirely in software. In this section, for illustration purposes, we will concentrate on one of these, the Persistent Object Management System written in C, the CPOMS [7]. The CPOMS is the underlying system used to support implementations of PS-algol [2] under Unix.
Reference: 5. <author> Atkinson, M. P., Chisholm, K. J. and Cockshott, W. P. </author> <title> "PS-algol: An Algol with a Persistent Heap", </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol 17, 7, </volume> <pages> pp. 24-31, </pages> <year> 1981. </year>
Reference-contexts: We also suggest some implementation techniques that may be utilised in conjunction with such a scheme. The paper concludes with a comparison of the three architectures. 2 . Software address translation The first object systems to be called persistent <ref> [4, 5] </ref> performed lazy pointer swizzling implemented entirely in software. In this section, for illustration purposes, we will concentrate on one of these, the Persistent Object Management System written in C, the CPOMS [7]. The CPOMS is the underlying system used to support implementations of PS-algol [2] under Unix.
Reference: 6. <author> Brown, A. L. </author> <title> "Persistent Object Stores", </title> <type> Ph.D Thesis, </type> <institution> Universities of St. Andrews and Glasgow, </institution> <year> 1988. </year>
Reference-contexts: The persistent store implemented by the CPOMS is a large heap with objects being addressed using persistent identifiers (PIDs). How PIDs are interpreted is not relevant to this paper and the interested reader is referred to <ref> [6] </ref> for more details. PIDs may be arbitrarily large but in current implementations PIDs are identical in size to the normal pointers (known as Local Object Numbers or LONs) used by the PS-algol run time system [1] . PIDs are distinguished by having their most significant bit set.
Reference: 7. <author> Brown, A. L. and Cockshott, W. P. </author> <title> "The CPOMS Persistent Object Management System", </title> <institution> Universities of Glasgow and St Andrews, PPRR-13, </institution> <year> 1985. </year>
Reference-contexts: Software address translation The first object systems to be called persistent [4, 5] performed lazy pointer swizzling implemented entirely in software. In this section, for illustration purposes, we will concentrate on one of these, the Persistent Object Management System written in C, the CPOMS <ref> [7] </ref>. The CPOMS is the underlying system used to support implementations of PS-algol [2] under Unix. The persistent store implemented by the CPOMS is a large heap with objects being addressed using persistent identifiers (PIDs).
Reference: 8. <author> Cockshott, W. P., Atkinson, M. P., Chisholm, K. J., Bailey, P. J. and Morrison, R. "POMS: </author> <title> A Persistent Object Management System", </title> <journal> Software Practice and Experience, </journal> <volume> vol 14, 1, </volume> <year> 1984. </year>
Reference-contexts: All these techniques have been used to implement persistent object stores <ref> [8, 12, 13] </ref> . Pointer swizzling may be performed at a variety of times, the earliest being when objects are loaded or faulted into memory; this is termed eager pointer swizzling. The latest time swizzling may be performed is when a pointer is dereferenced, and is termed lazy pointer swizzling.
Reference: 9. <author> Cockshott, W. P. and Foulk, P. W. </author> <title> "Implementing 128 Bit Persistent Addresses on 80x86 Processors", </title> <booktitle> Proceedings of the International Workshop on Computer Architectures to Support Security and Persistence of Information, </booktitle> <address> Bremen, </address> <publisher> West Germany, </publisher> <editor> ed J. Rosenberg and J. L. Keedy, </editor> <publisher> Springer-Verlag and British Computer Society, </publisher> <pages> pp. 123-136, </pages> <year> 1990. </year>
Reference-contexts: Thus in these systems, two different kinds of object addresses may exist: those in the backing store (persistent identifiers or PIDs) and those in directly addressable memory (virtual addresses). Many researchers have argued that large pointers (anywhere up to 128 bits) are required to support persistent systems <ref> [9, 17] </ref>. Persistent pointers need not be the same size as those supported by virtual memory (usually 32 bits); indeed persistent identifiers may be arbitrarily long. This paper presents a new architecture which supports arbitrarily large pointers and persistent stores using conventional hardware.
Reference: 10. <author> Dearle, A., Rosenberg, J., Henskens, F. A., Vaughan, F. A. and Maciunas, K. J. </author> <title> "An Examination of Operating System Support for Persistent Object Systems", </title> <booktitle> 25th Hawaii International Conference on System Sciences, </booktitle> <volume> vol 1, </volume> <publisher> IEEE Computer Society Press, </publisher> <address> Poipu Beach, </address> <publisher> Kauaii, </publisher> <pages> pp. 779-789, </pages> <year> 1992. </year>
Reference-contexts: When a page is removed from physical memory, pointers within it must be deswizzled as described above. A page which is not resident in physical memory may still reside within the virtual address space of the process. In a persistent operating system <ref> [10] </ref> the integration of swap space and persistent storage may give considerable advantages. We will therefore assume that pages removed from physical memory are either returned to the persistent store or to another persistent application. Virtual memory is also a finite resource.
Reference: 11. <author> Ellis, J., Li, K. and Appel, A. </author> <title> "Real-time Concurrent Collection on Stock Multiprocessors", </title> <note> DEC SRC, 25, </note> <year> 1988. </year>
Reference-contexts: This same requirement is made of object systems by some parallel garbage collection techniques <ref> [11, 14] </ref> and the solutions are well known. The first solution is to maintain a bitmap known as a crossing map which indicates if an object header is coincident with the start of a page. <p> Access to the translation table. In the hybrid architecture described in this paper user code is prohibited access to the translation table whilst the exception handler and page fault handler have full access to it. This situation is also found in some garbage collection schemes <ref> [11] </ref> and the solutions are the same. If the exception and fault handlers are implemented within the kernel they can make use of the full access accorded the kernel to user address spaces.
Reference: 12. <author> Kaehler, T. and Krasner, G. </author> <title> "LOOM large objectoriented memory for Smalltalk--80", Smalltalk-80: Bits of History, Words of Advice, </title> <editor> ed G. Krasner, </editor> <publisher> Addison-Wesley, </publisher> <pages> pp. 251-270, </pages> <year> 1983. </year>
Reference-contexts: All these techniques have been used to implement persistent object stores <ref> [8, 12, 13] </ref> . Pointer swizzling may be performed at a variety of times, the earliest being when objects are loaded or faulted into memory; this is termed eager pointer swizzling. The latest time swizzling may be performed is when a pointer is dereferenced, and is termed lazy pointer swizzling.
Reference: 13. <author> Koch, B., Schunke, T., Dearle, A., Vaughan, F., Marlin, C., Fazakerley, R. and Barter, C. </author> <title> "Cache Coherence and Storage Management in a Persistent Object System", </title> <booktitle> Proceedings, The Fourth International Workshop on Persistent Object Systems, </booktitle> <editor> Marthas Vineyard, ed A. Dearle, G. Shaw and S. Zdonik, </editor> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 99-109, </pages> <year> 1990. </year>
Reference-contexts: All these techniques have been used to implement persistent object stores <ref> [8, 12, 13] </ref> . Pointer swizzling may be performed at a variety of times, the earliest being when objects are loaded or faulted into memory; this is termed eager pointer swizzling. The latest time swizzling may be performed is when a pointer is dereferenced, and is termed lazy pointer swizzling.
Reference: 14. <author> Kolodner, E., Liskov, B. and Weihl, W. </author> <title> "Atomic Garbage Collection: Managing a Stable Heap", </title> <booktitle> Proceedingss of the 1989 ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pp. 15-25, </pages> <year> 1989. </year>
Reference-contexts: This same requirement is made of object systems by some parallel garbage collection techniques <ref> [11, 14] </ref> and the solutions are well known. The first solution is to maintain a bitmap known as a crossing map which indicates if an object header is coincident with the start of a page.
Reference: 15. <author> Lamb, C., Landis, G., Orenstein, J. and Weinreb, D. </author> <title> "The Objectstore Database System", </title> <journal> CACM, </journal> <volume> vol 34, 10, </volume> <pages> pp. 50-63, </pages> <year> 1991. </year>
Reference-contexts: However if the appropriate region has already been allocated, swizzling is employed. Such systems are unable to support persistent stores larger than virtual memory and are not discussed further. It is believed that a variation of this scheme is also used by Object Design <ref> [15] </ref> . In persistent systems it is unusual to be able to identify a self contained data set and some lazy swizzling is unavoidable. The first persistent systems to employ swizzling [4] relied upon a software test to distinguish between PIDs and local addresses.
Reference: 16. <author> Moss, J. E. B. </author> <title> "Working with Persistent Objects: To Swizzle or Not to Swizzle", </title> <type> COINS, </type> <institution> University of Massachusetts, </institution> <month> 90-38, </month> <year> 1990. </year>
Reference-contexts: This last option has become known as pointer swizzling and is the subject of this paper. The first option, dynamic translation, is seldom more efficient than swizzling <ref> [16] </ref>. The second option is only possible if persistent stores are small enough to be contained within In Proceedings of the 5 th International Workshop on Persistent Object Systems, San Miniato, Italy, September 1992, to appear in Springer-Verlag Workshops in Computing Series. the virtual memory.
Reference: 17. <author> Rosenberg, J. </author> <title> "Architectural Support for Persistent Object Systems", </title> <booktitle> International Workshop on ObjectOrientation in Operating Systems, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Xerox-Parc, California, </address> <year> 1991. </year>
Reference-contexts: Thus in these systems, two different kinds of object addresses may exist: those in the backing store (persistent identifiers or PIDs) and those in directly addressable memory (virtual addresses). Many researchers have argued that large pointers (anywhere up to 128 bits) are required to support persistent systems <ref> [9, 17] </ref>. Persistent pointers need not be the same size as those supported by virtual memory (usually 32 bits); indeed persistent identifiers may be arbitrarily long. This paper presents a new architecture which supports arbitrarily large pointers and persistent stores using conventional hardware.
Reference: 18. <author> Wilson, P. </author> <title> "Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware", </title> <journal> ACM Computer Architecture News, </journal> <month> June, </month> <pages> pp. 6-13, </pages> <year> 1991. </year>
Reference-contexts: The first persistent systems to employ swizzling [4] relied upon a software test to distinguish between PIDs and local addresses. Recently, schemes have been described which avoid performing these tests by performing pointer swizzling at page fault time <ref> [18] </ref>. In this paper we present a new hybrid technique which offers many of the advantages of both these approaches. The remainder of the paper is structured as follows: firstly we will describe a typical software address translation scheme. <p> For example, pointers loaded onto a stack in the dynamic call chain are eagerly swizzled. The third problem may be overcome by amortising the cost of disk access across many object fetches. 3 . Address translation at page fault time Recently, an approach has been suggested by Wilson <ref> [18] </ref> that employs both pointer swizzling and page faulting techniques. The basic strategy is to fetch pages of data into virtual memory rather than individual objects. As pages are fetched, they are scanned and all (persistent) pointers are translated into valid virtual memory addresses.
References-found: 17

