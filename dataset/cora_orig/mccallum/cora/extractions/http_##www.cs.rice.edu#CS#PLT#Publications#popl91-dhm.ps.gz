URL: http://www.cs.rice.edu/CS/PLT/Publications/popl91-dhm.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Typing First-Class Continuations in ML  
Author: Bruce F. Duba Robert Harper David MacQueen 
Affiliation: Rice University  Carnegie Mellon University  AT&T Bell Laboratories  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: as the meaning of its cps transform, M , defined as follows: x = : x M N = :M (m:N (n:mn)) letcc x in M = :(x:M ) throw M N = :M N (In fact, the Standard ML of New Jersey compiler is based on a similar transformation <ref> [1] </ref>.) To relate the type of a term M to the type of its cps transform, we associate to each type t of the illustrative language, a simple type t fl given by b fl = b (t cont ) fl = t fl !ff where ff is a fixed, but
Reference: [2] <author> Andrew W. Appel and David MacQueen. </author> <title> Standard ML of New Jersey Reference Manual. </title> <note> (in preparation), </note> <year> 1990. </year>
Reference-contexts: It is here that the two constructs differ in an ML-like setting. Another way of typing continuations, and the one currently adopted in Standard ML of New Jersey <ref> [2] </ref>, is to abandon the view that continuations are functions in the ordinary sense and to consider t cont as a primitive type with an operation throw for invoking a continuation.
Reference: [3] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Laurent Hascoet, and Gilles Kahn. </author> <title> Natural semantics on the computer. </title> <type> Technical Report RR 416, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: The main results are a Milner-style soundness theorem ("well-typed programs cannot go wrong") and an observational soundness theorem ("convergent programs of type int yield integers"). Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn <ref> [27, 3] </ref>. The operational presentation illustrates the extent to which the definition of Standard ML [24] would have to be changed to accommodate the proposed extension.
Reference: [4] <author> William Clinger, Daniel P. Friedman, and Mitchell Wand. </author> <title> A scheme for higher-level semantic algebra. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 237-250. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: In a typical implementation the final result is passed to the interactive top-level, which prints the result, and continues by evaluating the next expression. Around 1982 the special-form catch was replaced by call-with-current-continuation or call/cc for short <ref> [4] </ref>. The act of capturing the current continuation did not require a special variable binding form, but could be performed by a primitive operator whose argument was a function that would be applied to the captured continuation. Therefore, (catch x body) becomes (call/cc (lambda (x) body)) in Scheme.
Reference: [5] <author> Eric C. Cooper. </author> <title> An overview of the FOX project. </title> <institution> Talk at Bell Laboratories, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [29, 5, 28, 37] </ref>.
Reference: [6] <author> R. Kent Dybvig and Bob Hieb. </author> <title> Engines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 14(2) </volume> <pages> 109-124, </pages> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control <ref> [41, 18, 29, 6] </ref>, for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39].
Reference: [7] <author> Arthur Evans. </author> <title> PAL a language designed for teaching programming linguistics. </title> <booktitle> In Proc. ACM 23rd National Conference, </booktitle> <pages> pages 395-403, </pages> <address> Prince-ton, 1968. </address> <publisher> ACM, Brandin Systems Press. </publisher>
Reference-contexts: Andrzej Filinski, Timothy Griffin, John Reppy, Didier Remy, Olin Shivers, and Mads Tofte for their comments and suggestions. 2 Adding Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [21], Reynold's escape [32], label variables in Gedanken [31] and PAL <ref> [7] </ref>, and from the semantic analyses of general control structures, including jumps [36]. Scheme [38] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [8] <author> Matthias Felleisen. </author> <title> Transliterating Prolog into Scheme, </title> <type> Technical Report No. 182, </type> <institution> Indiana University Computer Science Department, </institution> <year> 1985. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables <ref> [8, 19] </ref>, for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17].
Reference: [9] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In First Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [9, 10, 39] </ref>.
Reference: [10] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [9, 10, 39] </ref>.
Reference: [11] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming languages, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1988, </year> <pages> pages 180-190. </pages>
Reference-contexts: printing of a report for the user are the responsibility of the interactive top-level. 2 So the evaluation context represented by the continuation k stored in c is limited to the right hand 2 The interface between the interactive system and the object level evaluation is similar to a prompt <ref> [11] </ref>. side of the declaration of n, of type int. When this continuation is fetched and invoked in the right hand side of the declaration of b, that expression returns the value 3, which the top-level would erroneously interpret as a boolean value.
Reference: [12] <author> Andrzej Filinski. </author> <title> Declarative continuations: An investigation of duality in programming language semantics. </title> <booktitle> In Summer Conference on Category Theory and Computer Science, volume 389 of Lecture Notes in Computer Science, </booktitle> <address> Manchester, UK, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 12, 15] </ref> and their impact on full abstraction results [34]. fl This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. y This research was supported in part by the Defense Advanced Research Projects Agency (DARPA), monitored by the Office of Naval
Reference: [13] <author> Andrzej Filinski. </author> <title> Declarative continuations and categorical duality. </title> <type> Master's thesis, </type> <institution> University of Copenhagen, Copenhagen, Denmark, </institution> <month> August </month> <year> 1989. </year> <type> (DIKU Report 89/11). </type>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 12, 15] </ref> and their impact on full abstraction results [34]. fl This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. y This research was supported in part by the Defense Advanced Research Projects Agency (DARPA), monitored by the Office of Naval
Reference: [14] <author> Daniel P. Friedman, Christopher T. Haynes, and Eugene Kohlbecker. </author> <title> Programming with continuations. Program Transformations and Programming Environments, edited by P. Pepper. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985, </year> <pages> 263-274. </pages>
Reference-contexts: "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking <ref> [14] </ref> and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39].
Reference: [15] <author> Timothy Griffin. </author> <title> A formulas-as-types notion of control. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990, </year> <pages> pages 47-58. </pages>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 12, 15] </ref> and their impact on full abstraction results [34]. fl This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. y This research was supported in part by the Defense Advanced Research Projects Agency (DARPA), monitored by the Office of Naval <p> of application of a continuation is now void, we must introduce, in compensation, a map ignore witnessing the inclusion of void into every type t : ` M : void ` ignore M : t (give-up) (These two rules have the form of Pierce's Law and false elimination, respectively; see <ref> [15] </ref> for further discussion.) The expression throw M N is now defined as ignore (M N ). For the polymorphic variant, the typing rule for letcc appears in the introduction. The denotational semantics must be changed to reflect the representation of continuations as functions.
Reference: [16] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 11 </volume> <pages> 143-153, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines <ref> [16] </ref>, exceptions [42], and logic variables [8, 19], for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17].
Reference: [17] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 582-598, </pages> <year> 1987. </year>
Reference-contexts: provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect <ref> [17] </ref>. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39].
Reference: [18] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Abstracting timed preemption with engines. </title> <journal> Journal of Computer Languages, </journal> <volume> 12 </volume> <pages> 109-121, </pages> <year> 1987. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control <ref> [41, 18, 29, 6] </ref>, for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39].
Reference: [19] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 157-176, </pages> <year> 1987. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables <ref> [8, 19] </ref>, for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17].
Reference: [20] <author> J. Roger Hindley. </author> <title> The completeness theorem for typing terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22 </volume> <pages> 127-134, </pages> <year> 1983. </year>
Reference: [21] <author> Peter J. Landin. </author> <title> A correspondence between ALGOL-60 and Church's lambda notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 89-101, </pages> <year> 1965. </year>
Reference-contexts: We are grateful to Andrew Appel, Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, John Reppy, Didier Remy, Olin Shivers, and Mads Tofte for their comments and suggestions. 2 Adding Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator <ref> [21] </ref>, Reynold's escape [32], label variables in Gedanken [31] and PAL [7], and from the semantic analyses of general control structures, including jumps [36].
Reference: [22] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: By exploiting the type structure of the language, the complexity of reflexive domains can be avoided (while still admitting extensions such as fix). The fundamental idea is to adapt the methods of Meyer and Wand <ref> [22] </ref>, and make use of standard results of the typed -calculus to obtain the desired result.
Reference: [23] <author> Robin Milner and Mads Tofte. </author> <title> Co-induction in relational semantics. </title> <type> Technical Report ECS-LFCS-88-65, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, Edinburgh, </institution> <month> Octo-ber </month> <year> 1988. </year>
Reference-contexts: In contrast to the domain-theoretic semantics, the proof of the soundness theorem is significantly complicated by the introduction of fixed-point operators for defining recursive functions; see <ref> [23] </ref> for a careful discussion of a closely-related problem in the setting of natural semantics. 5 Conclusions First-class continuations are a powerful tool for implementing sophisticated control constructs like coroutines, processes, backtracking, and asynchronous signals.
Reference: [24] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn [27, 3]. The operational presentation illustrates the extent to which the definition of Standard ML <ref> [24] </ref> would have to be changed to accommodate the proposed extension. <p> above argument shows that if :: t , then v: 0 :(v) : t !t 0 for any type t 0 (not just void). 4 Extending the Definition of Standard ML An operational semantics for our language presented in the relational semantics style of the formal definition of Standard ML <ref> [24] </ref> may be obtained from the de-notational semantics by a process of "defunctionaliza-tion" [32] whereby closures and continuations are represented by finitary objects that are then "interpreted" on an argument, rather than simply applied to it. The resulting semantics differs substantially from the dynamic semantics of Standard ML.
Reference: [25] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <type> Technical Report STAN-CS-89-1277, </type> <institution> Stanford University, </institution> <year> 1989. </year>
Reference-contexts: We say that an environment matches a typing context iff (x) 2 A (x) for each x 2 dom (). It is a standard result that if ` ! M : t and matches , then A [[M ]] 2 A t <ref> [25] </ref>. Hence if we define [[M ]] to be A [[M]], then [[M ]] is in the set A (t fl !ff)!ff whenever matches fl .
Reference: [26] <author> Gordon Plotkin. </author> <title> Lambda-definability in the full type hierarchy. </title> <editor> In J. P. Seldin and J. R. Hind-ley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combi-natory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 363-373. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [27] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: The main results are a Milner-style soundness theorem ("well-typed programs cannot go wrong") and an observational soundness theorem ("convergent programs of type int yield integers"). Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn <ref> [27, 3] </ref>. The operational presentation illustrates the extent to which the definition of Standard ML [24] would have to be changed to accommodate the proposed extension.
Reference: [28] <author> Norman Ramsey. </author> <title> Concurrent programming in ML. </title> <type> Technical Report CS-TR-262-90, </type> <institution> Computer Science Department, Princeton University, </institution> <year> 1990. </year>
Reference-contexts: Continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [29, 5, 28, 37] </ref>.
Reference: [29] <author> John Reppy. </author> <title> First-class synchronous operations in Standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control <ref> [41, 18, 29, 6] </ref>, for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. <p> Continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [29, 5, 28, 37] </ref>.
Reference: [30] <author> John Reppy. </author> <title> Asynchronous signals in Standard ML. </title> <type> Technical Report TR 90-1144, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers <ref> [30] </ref>, and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. <p> Another use of continuations is to provide a clean, typed interface for asynchronous signal handling <ref> [30] </ref>. In Standard ML of New Jersey the type of a signal handler is (int * unit cont) -&gt; unit cont, where the argument is a pair consisting of a count of pending signals of the kind being handled and the continuation representing the interrupted process.
Reference: [31] <author> John C. Reynolds. </author> <title> GEDANKEN | a simple type-less language based on the principle of completeness and the reference concept. </title> <journal> Communications of the ACM, </journal> <volume> 13(5) </volume> <pages> 308-319, </pages> <month> May </month> <year> 1970. </year>
Reference-contexts: Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, John Reppy, Didier Remy, Olin Shivers, and Mads Tofte for their comments and suggestions. 2 Adding Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [21], Reynold's escape [32], label variables in Gedanken <ref> [31] </ref> and PAL [7], and from the semantic analyses of general control structures, including jumps [36]. Scheme [38] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [32] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <note> ACM. </note>
Reference-contexts: grateful to Andrew Appel, Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, John Reppy, Didier Remy, Olin Shivers, and Mads Tofte for their comments and suggestions. 2 Adding Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [21], Reynold's escape <ref> [32] </ref>, label variables in Gedanken [31] and PAL [7], and from the semantic analyses of general control structures, including jumps [36]. <p> )) [[M N ]] = [[M ]] (m: [[N ]] (n: let clsr (f)=m in fn else wrong )) [[letcc x in M ]] = [[M ]] [x:= clsr (v 0 :v)] [[ignore M ]] = [[M ]] A continuation is represented by a closure that ignores its continuation argument <ref> [32] </ref>. The definition of the relation v : t remains essentially the same, ignoring the clause for continuation types. Since void is a base type with no proper elements, if v : void, then v =?: there are no terminating values of type void. <p> t !t 0 for any type t 0 (not just void). 4 Extending the Definition of Standard ML An operational semantics for our language presented in the relational semantics style of the formal definition of Standard ML [24] may be obtained from the de-notational semantics by a process of "defunctionaliza-tion" <ref> [32] </ref> whereby closures and continuations are represented by finitary objects that are then "interpreted" on an argument, rather than simply applied to it. The resulting semantics differs substantially from the dynamic semantics of Standard ML.
Reference: [33] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <booktitle> In Proc. ICALP '74, volume 14 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: This entails extending the "non-escaping" property to arbitrary values, and to do so appears to require an inclusive predicate argument similar to that considered by Reynolds <ref> [33] </ref>. Given that such a predicate exists, we may choose the initial continuation as discussed above, and conclude, by the non-escaping property, that well-typed closed terms of base type evaluate to values of that type.
Reference: [34] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 Conference on LISP and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39]. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 12, 15] and their impact on full abstraction results <ref> [34] </ref>. fl This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. y This research was supported in part by the Defense Advanced Research Projects Agency (DARPA), monitored by the Office of Naval Research under Contract N00014-84-K-0415, ARPA Order No. 5404.
Reference: [35] <author> Richard Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65 </volume> <pages> 85-97, </pages> <year> 1985. </year>
Reference: [36] <author> Christopher Strachey and Christopher Wadsworth. </author> <title> A mathematical semantics for handling full jumps. </title> <type> Technical Report Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: Tofte for their comments and suggestions. 2 Adding Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [21], Reynold's escape [32], label variables in Gedanken [31] and PAL [7], and from the semantic analyses of general control structures, including jumps <ref> [36] </ref>. Scheme [38] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [37] <author> Bernard Sufrin. </author> <title> CSP-style processes in ML. </title> <journal> (Pri--vate communication), </journal> <year> 1989. </year>
Reference-contexts: Continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [29, 5, 28, 37] </ref>.
Reference: [38] <author> Gerald Jay Sussman and Guy Lewis Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Technical Report Memo No. 349, </type> <institution> MIT AI Laboratory, </institution> <month> December </month> <year> 1975. </year>
Reference-contexts: Scheme <ref> [38] </ref> originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [39] <author> Carolyn Talcott. Rum: </author> <title> An intensional theory of function and control abstractions. </title> <booktitle> In Proc. 1987 Workshop of Foundations of Logic and Functional Programming, volume 306 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [9, 10, 39] </ref>.
Reference: [40] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1988. </year> <note> Available as Edinburgh University Laboratory for Foundations of Computer Science Technical Report ECS-LFCS-88-54. </note>
Reference-contexts: For instance, if the identity function is stored into a cell, then a single instance of its polymorphic type must be chosen for all subsequent retrievals: its polymorphic character is lost. (See Tofte's thesis <ref> [40] </ref> for further discussion of this point.) Thus if a continuation was represented as a function of polymorphic result type, then the result type, which is irrelevant since no result is actually returned, would have to be fixed when the continuation is stored, rather than when it is invoked.
Reference: [41] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <year> 1980. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions [42], and logic variables [8, 19], for supporting multiple threads of control <ref> [41, 18, 29, 6] </ref>, for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [9, 10, 39].
Reference: [42] <author> Andrew Wright and Matthias Felleisen. </author> <title> The nature of exceptions in polymorphic languages. </title> <type> Unpublished manuscript, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [16], exceptions <ref> [42] </ref>, and logic variables [8, 19], for supporting multiple threads of control [41, 18, 29, 6], for providing asynchronous signal handlers [30], and for implementing non-blind backtracking [14] and dynamic barriers such as unwind-protect [17].
References-found: 42

