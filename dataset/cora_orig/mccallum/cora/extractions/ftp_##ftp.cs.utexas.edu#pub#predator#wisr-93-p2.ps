URL: ftp://ftp.cs.utexas.edu/pub/predator/wisr-93-p2.ps
Refering-URL: http://www.cs.utexas.edu/users/jthomas/publications.html
Root-URL: 
Email: Email: fjthomas,batory,singhalg@cs.utexas.edu  Email: marty@cs.utexas.edu  
Phone: Tel: (512) 471-9711/9713  
Title: A Scalable Approach to Software Libraries  
Author: Jeff Thomas, Don Batory, and Vivek Singhal Marty Sirkin 
Keyword: Predator, GenVoca, domain analysis, containers, software libraries, software reuse, compositional reuse, generative reuse, feature combinatorics. Working Groups: reuse process models; reuse terminology standards; domain analysis engineering; design guidelines for reuse-general, Ada, and C++; reuse and OO methods; tools and environments.  
Note: Appeared in Proceedings of the Sixth Annual Workshop on Software Reuse, Owego, New York, November 1993.  
Address: Austin, Texas 78712  Seattle, Washington 98195  
Affiliation: Department of Computer Sciences The University of Texas at Austin  Department of Computer Sciences and Engineering University of Washington  
Abstract: Software libraries offer a convenient and accessible means to achieve the benefits of reuse. The components of these libraries are written by hand, and each represents a unique combination of features that distinguishes it from other components. Unfortunately, as the number of features grows, the size of these libraries grows exponentially, making them unscalable. Predator is a research project to develop abstractions and tools to provide the benefits of software libraries without incurring the scalability disadvantages just mentioned. Our approach relies on a careful analysis of an application domain to arrive at appropriate high-level abstractions, standardized (i.e., plug-compatible) interfaces, and layered decompositions. Predator defines language extensions for implementing components, and compilers to automatically convert component compositions into efficient programs. Workshop Goals: feedback on our work; exposure to other important work in software reuse. 
Abstract-found: 1
Intro-found: 1
Reference: [BM93] <author> D. A. Brant and D. P. Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of 1993 ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Currently, there are two compilers (P1 [SBS93] and P2 [BSST93]), both providing language extensions to ANSI C. 1 P1 demonstrated that our approach was promising. It was used to generate the data structures for the OPS5/LEAPS compiler, a compiler for OPS5 rules <ref> [BM93] </ref>. OPS5/LEAPS was chosen 1 We are also developing a third Predator compiler (P++ [SB93]) that will provide domain-independent language extensions to C++.
Reference: [BO92] <author> D. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software system with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Such interfaces might be identified using domain modeling techniques. In Predator, component interfaces actually were deliberately designed to ensure that they would be suitable for building complex data structures. Good component designs result from interfaces that possess the following three properties <ref> [BSS92, BO92] </ref>: 1. High-level abstractions. It is well-known that using high-level abstractions makes programs easier to write and debug. It is essential for component interfaces to hide the complex details of their encapsulated data structures; not doing so would make components difficult to use and virtually impossible to combine. 2.
Reference: [Boo87] <author> G. Booch. </author> <title> Software Components with Ada. </title> <address> Benjamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: Because each of these structures could be implemented using a variety of algorithms, the domain of data structures is clearly quite large. The FSF's libg++ class library [Lea88] and the C++ Booch Components <ref> [Boo87] </ref> are examples of data structure software libraries. Although software libraries offer a simple and effective means of attaining the benefits of reuse, they also expose a basic obstacle that limits the long-term success of software libraries as a reuse paradigm.
Reference: [BSS92] <author> D. Batory, V. Singhal, and M. Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Such interfaces might be identified using domain modeling techniques. In Predator, component interfaces actually were deliberately designed to ensure that they would be suitable for building complex data structures. Good component designs result from interfaces that possess the following three properties <ref> [BSS92, BO92] </ref>: 1. High-level abstractions. It is well-known that using high-level abstractions makes programs easier to write and debug. It is essential for component interfaces to hide the complex details of their encapsulated data structures; not doing so would make components difficult to use and virtually impossible to combine. 2.
Reference: [BSST93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of the ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <address> Los Angeles, California, </address> <month> December 7-10 </month> <year> 1993. </year>
Reference-contexts: Predator provides language extensions to support the specification and composition of primitive components, and compilers to convert them into efficient executable code. The Predator compilers use advanced optimizations such as inlining and partial evaluation. Currently, there are two compilers (P1 [SBS93] and P2 <ref> [BSST93] </ref>), both providing language extensions to ANSI C. 1 P1 demonstrated that our approach was promising. It was used to generate the data structures for the OPS5/LEAPS compiler, a compiler for OPS5 rules [BM93].
Reference: [Kru92] <author> C. W. Krueger. </author> <title> Software reuse. </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: Twenty-five years ago, McIlroy [McI69] postulated that a well-stocked library of sine routines would have to contain as many as 300 components, supporting different degrees of precision, granularity, range, and robustness. Still others have recognized that the problem of feature combinatorics is, unfortunately, inherent to all libraries <ref> [Kru92] </ref>.
Reference: [Lea88] <author> Doug Lea. libg++, </author> <title> the GNU C++ library. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <year> 1988. </year>
Reference-contexts: For example, consider the domain of data structure algorithms (i.e., containers of objects); examples include linked lists, arrays, trees, and hash tables. Because each of these structures could be implemented using a variety of algorithms, the domain of data structures is clearly quite large. The FSF's libg++ class library <ref> [Lea88] </ref> and the C++ Booch Components [Boo87] are examples of data structure software libraries. Although software libraries offer a simple and effective means of attaining the benefits of reuse, they also expose a basic obstacle that limits the long-term success of software libraries as a reuse paradigm.
Reference: [McI69] <author> M.D. McIlroy. </author> <title> Mass produced software components. </title> <booktitle> In Proceedings of NATO Conference on Software Engineering, </booktitle> <pages> pages 88-98, </pages> <year> 1969. </year>
Reference-contexts: This problem of feature combinatorics is not unique to data structures. Twenty-five years ago, McIlroy <ref> [McI69] </ref> postulated that a well-stocked library of sine routines would have to contain as many as 300 components, supporting different degrees of precision, granularity, range, and robustness. Still others have recognized that the problem of feature combinatorics is, unfortunately, inherent to all libraries [Kru92].
Reference: [SB93] <author> V. Singhal and D. Batory. </author> <title> P++: a language for software system generators. </title> <type> Technical Report TR-93-16, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1993. </year>
Reference-contexts: It was used to generate the data structures for the OPS5/LEAPS compiler, a compiler for OPS5 rules [BM93]. OPS5/LEAPS was chosen 1 We are also developing a third Predator compiler (P++ <ref> [SB93] </ref>) that will provide domain-independent language extensions to C++.

References-found: 9

