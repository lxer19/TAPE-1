URL: http://www.cs.utexas.edu/users/ashis/ASSET98.ps
Refering-URL: http://www.cs.utexas.edu/users/ashis/papers.html
Root-URL: http://www.cs.utexas.edu
Email: ashis@cs.utexas.edu  garg@ece.utexas.edu  
Title: Debugging in a Distributed World: Observation and Control  
Author: Ashis Tarafdar Vijay K. Garg 
Address: Austin, TX 78712-1188, USA  Austin, TX 78712-1084, USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  Department of Electrical and Computer Engineering The University of Texas at Austin  
Abstract: Debugging distributed programs is considerably more difficult than debugging sequential programs. We address issues in debugging distributed programs and provide a general framework for observing and controlling a distributed computation and its applications to distributed debugging. Observing distributed computations involves solving the predicate detection problem. We present the main ideas involved in developing efficient algorithms for predicate detection. Controlling distributed computations involves solving the predicate control problem. Predicate control may be used to restrict the behavior of the distributed program to suspicious executions. We also present an example of how predicate detection and predicate control can be used in practice to facilitate distributed debugging. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: fundamental concepts and mecha nisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chap ter 4. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Aside from practical implementation work, much research has been devoted to the study of problems arising in distributed debugging. As noted before, we classify these problems into those that deal with observation and those that deal with control. Predicate Detection <ref> [1, 6] </ref> is the main problem involved in observing distributed computations. It involves detecting whether a specified global property ever occurs in a distributed computation. For example, one might wish to check that the validity of mutually exclusive sections of code is maintained.
Reference: [2] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: de termining global states of distributed systems. </title> <journal> ACM Trans actions on Computer Systems, </journal> <volume> 3(1):6375, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: For example, one might wish to check that the validity of mutually exclusive sections of code is maintained. Predicate detection is used to set global breakpoints in distributed computations. Approaches to solving predicate detection are divided into three categories: global snapshot based <ref> [2] </ref>, lattice construction based [4], and predicate restriction based [7] approaches. The first approach can detect only stable predicates (which remain true once they become true). The second approach uses the interleaving model of concurrency and, therefore, suffers from combinatorial explosion.
Reference: [3] <author> C. Chase and V. K. Garg. </author> <title> On techniques and their limita tions for the global predicate detection problem. </title> <booktitle> In Proc. of the Workshop on Distributed Algorithms, </booktitle> <pages> pages 303 317, </pages> <address> France, </address> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: NP-Completeness and Conjunctive Predicates Even within the happened before model, if the predicate is a boolean expression it has been demonstrated that the predicate detection problem is NP-complete <ref> [3] </ref>. In spite of this fact, there are efficient algorithms for predicate detection for several useful classes of predicates. For a survey of such algorithms, refer to [6]. In particular, the class of conjunctive predicates is found to be very useful in practice.
Reference: [4] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163 173, </pages> <address> Santa Cruz, California, </address> <year> 1991. </year>
Reference-contexts: For example, one might wish to check that the validity of mutually exclusive sections of code is maintained. Predicate detection is used to set global breakpoints in distributed computations. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based <ref> [4] </ref>, and predicate restriction based [7] approaches. The first approach can detect only stable predicates (which remain true once they become true). The second approach uses the interleaving model of concurrency and, therefore, suffers from combinatorial explosion. <p> Checking every global state by explicit construction would lead to combinatorial explosion and so we follow the approach of trying to avoid this by working in the partial order model rather than attempting to construct all possible interleavings (an approach that has been studied <ref> [4] </ref>). 4.1. NP-Completeness and Conjunctive Predicates Even within the happened before model, if the predicate is a boolean expression it has been demonstrated that the predicate detection problem is NP-complete [3]. In spite of this fact, there are efficient algorithms for predicate detection for several useful classes of predicates.
Reference: [5] <author> C. Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8):28 33, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: The strong causally precedes relation is also easy to implement while tracing a running distributed computation. It involves a generalization of vector clocks that was introduced in <ref> [5] </ref> which allow the tracing of a general partial order. Comparing the clocks of two events gives us their relative ordering according to the strong causally precedes relation. The choice of how much independence to model depends on the particular application.
Reference: [6] <author> V. K. Garg. </author> <title> Observation of global properties in distributed systems. </title> <booktitle> In Proceedings of the IEEE International Confer ence on Software and Knowledge Engineering, </booktitle> <pages> pages 418 425, </pages> <address> Lake Tahoe, Nevada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Aside from practical implementation work, much research has been devoted to the study of problems arising in distributed debugging. As noted before, we classify these problems into those that deal with observation and those that deal with control. Predicate Detection <ref> [1, 6] </ref> is the main problem involved in observing distributed computations. It involves detecting whether a specified global property ever occurs in a distributed computation. For example, one might wish to check that the validity of mutually exclusive sections of code is maintained. <p> In spite of this fact, there are efficient algorithms for predicate detection for several useful classes of predicates. For a survey of such algorithms, refer to <ref> [6] </ref>. In particular, the class of conjunctive predicates is found to be very useful in practice. These are predicates that can be expressed as a conjunction of local predicates. Intuitively, these properties check if a combination of events happen together.
Reference: [7] <author> V. K. Garg and B. Waldecker. </author> <title> Detection of weak unsta ble predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3):299307, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: Predicate detection is used to set global breakpoints in distributed computations. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based [4], and predicate restriction based <ref> [7] </ref> approaches. The first approach can detect only stable predicates (which remain true once they become true). The second approach uses the interleaving model of concurrency and, therefore, suffers from combinatorial explosion. <p> An example of a global predicate would be detecting if functions on two processes are entered at the same time, violating a required mutual-exclusion property. 4.2. Detecting Conjunctive Predicates in the Hap pened Before Model The detection of conjunctive predicates has been efficiently solved in <ref> [7] </ref>. Their algorithm first eliminates all states in which the local predicate is false. It then starts at the initial global state and proceeds forward.
Reference: [8] <author> R. Kilgore and C. Chase. </author> <title> Re-execution of distributed pro grams to detect bugs hidden by racing messages. </title> <booktitle> In Proceed ings of the International Conference on System Sciences, Hawaii, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Off-line control is easier to achieve than on-line control because of the pre-knowledge of future events. One method to control a computation is to re-order messages. This form of control (which may also be considered a testing methodology) has been studied in both its on-line [12] and off-line <ref> [8] </ref> variants. We consider a less-intrusive form of control which is only capable of delaying events (and not reordering them). This has been termed the predicate control problem and has been studied in both on-line and off-line variants [17]. 3. <p> During control, strong causality may be used to model independent events and thus model various message reorderings in the same model. A form of this kind of modeling may be found in <ref> [8] </ref>. For our purposes of controlling using event delays, the happened before model suffices. Since each event leads to a state, we may apply both happened before and strong causally precedes to order states instead of events.
Reference: [9] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: This has been termed the predicate control problem and has been studied in both on-line and off-line variants [17]. 3. Modeling Distributed Computations The traditional model of a distributed computation has been based on the happened before relation introduced in <ref> [9] </ref>. The distributed system is divided into a set of processes. Events on a single process are totally ordered according to the local clock from the initial (earliest) event to the final (latest) event.
Reference: [10] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging par allel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Our focus in this paper will be on the third approach to predicate detection. Control of distributed computations can be at various levels. So far, the literature has focussed mainly on the most basic form of control: deterministic replaying of distributed computations to recreate failures <ref> [10, 14] </ref>. This leads to a debugging cycle consisting of passive observation and computation replaying. We believe that a more effective and active debugging method would involve instead a cycle of observation followed by controlled replaying based on observation [17].
Reference: [11] <author> F. Mattern. </author> <title> Virtual time and global states of distributed sys tems. </title> <booktitle> In Parallel and Distributed Algorithms: Proc. of the International Workshop on Parallel and Distributed Algo rithms, </booktitle> <pages> pages 215226. </pages> <publisher> Elsevier Science Publishers B. V. (North Holland), </publisher> <year> 1989. </year>
Reference-contexts: The happened-before model of a computation is easy to implement while tracing a running distributed computation. This involves the use of vector clocks <ref> [11] </ref>. A vector clock is stored for each event. By comparing the vector clocks of two events, we can deduce their ordering with respect to the happened-before relation.
Reference: [12] <author> V. V. Murty and V. K. Garg. </author> <title> Characterization of message ordering specifications and protocols. </title> <booktitle> In Proceedings of the 17th International Conference on Distributed Comput ing Systems, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: Off-line control is easier to achieve than on-line control because of the pre-knowledge of future events. One method to control a computation is to re-order messages. This form of control (which may also be considered a testing methodology) has been studied in both its on-line <ref> [12] </ref> and off-line [8] variants. We consider a less-intrusive form of control which is only capable of delaying events (and not reordering them). This has been termed the predicate control problem and has been studied in both on-line and off-line variants [17]. 3.
Reference: [13] <author> C. M. Pancake and R. H. B. Netzer. </author> <title> A bibliography of par allel debuggers. </title> <note> 26(1):21 37, 1991. updated version at http://www.engr.orst.edu/ pancake/papers/biblio.html. </note>
Reference-contexts: In spite of the lack of support for distributed debugging in commercial tools, there have been many research projects that have built either prototype or full-fledged implementations. An extensive summary of these projects may be found in <ref> [13] </ref>. Closely related to debugging is the field of testing which studies the process of selecting test cases. A good summary of testing techniques for distributed programs may be found in [15].
Reference: [14] <author> M. Raynal. </author> <title> Algorithms for mutual exclusion. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Our focus in this paper will be on the third approach to predicate detection. Control of distributed computations can be at various levels. So far, the literature has focussed mainly on the most basic form of control: deterministic replaying of distributed computations to recreate failures <ref> [10, 14] </ref>. This leads to a debugging cycle consisting of passive observation and computation replaying. We believe that a more effective and active debugging method would involve instead a cycle of observation followed by controlled replaying based on observation [17].
Reference: [15] <author> K. C. Tai and R. H. Carver. </author> <title> Testing of distributed programs, </title> <booktitle> chapter 33, </booktitle> <pages> pages 955978. </pages> <publisher> McGraw-Hill. </publisher> <editor> (A. Zoyama Ed.), </editor> <year> 1996. </year>
Reference-contexts: An extensive summary of these projects may be found in [13]. Closely related to debugging is the field of testing which studies the process of selecting test cases. A good summary of testing techniques for distributed programs may be found in <ref> [15] </ref>. Aside from practical implementation work, much research has been devoted to the study of problems arising in distributed debugging. As noted before, we classify these problems into those that deal with observation and those that deal with control.
Reference: [16] <author> A. Tarafdar and V. K. Garg. </author> <title> Addressing false causal ity while detecting predicates in distributed programs. </title> <booktitle> In Proceedings of the 18th International Conference on Dis tributed Computing Systems (to appear), </booktitle> <month> May </month> <year> 1998. </year> <note> avail able at http://maple.ece.utexas.edu as technical report TR PDS-1997-011. </note>
Reference-contexts: The scenario in Figure 1 (a) may be just one possible scheduling of events. Figure 1 (b) shows another scheduling in which mutual-exclusion would be violated. A model which partially orders the events on a local process would allow events within a process to be independent. causality diagram <ref> [16] </ref>. Strong causality is based on the strong causally precedes relation between events. It is an extension of happened before based on the key observation that totally ordering the events on a single process leads to false causality between events. <p> As we will see, problems become harder to solve in the new strong causality model but the model itself is more expressive. This expressiveness is demonstrated in both observation and control. During observation, as illustrated in the mutual exclusion example, strong causality allows us to detect more bugs <ref> [16] </ref>. During control, strong causality may be used to model independent events and thus model various message reorderings in the same model. A form of this kind of modeling may be found in [8]. For our purposes of controlling using event delays, the happened before model suffices. <p> In the strong causality model, we cannot apply the same algorithm for conjunctive predicate detection because the key observation which allowed us to eliminate a local state from consideration in every global state considered would not work as before. In fact, the problem becomes NP-complete as is demonstrated in <ref> [16] </ref>. However, for a large class of computations, we can still efficiently detect conjunctive predicates. If, in a computation, the events which send messages are all totally ordered with respect to each other, then we say that the computation is send-ordered. <p> Analogously, we may define receive-ordered computations as those which have totally ordered receive events. Now for the classes of send-ordered and receive-ordered computations, we can efficiently detect conjunctive predicates. The algorithm to do so is presented in <ref> [16] </ref>. It applies a preprocessing step to the strong causality model to convert it to a representative happened before model on which the above algorithm for conjunctive predicates may be applied. 5.
Reference: [17] <author> A. Tarafdar and V. K. Garg. </author> <title> Predicate control for ac tive debugging of distributed programs. </title> <booktitle> In Proceed ings of the 9th Symposium on Parallel and Distributed Processing (to appear). IEEE, </booktitle> <month> April </month> <year> 1998. </year> <note> available at http://maple.ece.utexas.edu as technical report TR-PDS 1998-002. </note>
Reference-contexts: This leads to a debugging cycle consisting of passive observation and computation replaying. We believe that a more effective and active debugging method would involve instead a cycle of observation followed by controlled replaying based on observation <ref> [17] </ref>. We may classify control into on-line control or off-line control depending on whether it is applied to a fresh computation or to a replayed computation. Off-line control is easier to achieve than on-line control because of the pre-knowledge of future events. <p> We consider a less-intrusive form of control which is only capable of delaying events (and not reordering them). This has been termed the predicate control problem and has been studied in both on-line and off-line variants <ref> [17] </ref>. 3. Modeling Distributed Computations The traditional model of a distributed computation has been based on the happened before relation introduced in [9]. The distributed system is divided into a set of processes. <p> Clearly, online predicate control is harder than off-line predicate control. 5.1. NP-Completeness and Disjunctive Predicates If the specified global predicate to be maintained is a simple boolean expression of local predicates then it can be shown that the problem of determining if a control strategy exists is NP-complete <ref> [17] </ref>. Considering that the predicate detection problem is also NP-complete for general boolean expressions, this fact is not surprising. The issue of obvious interest is whether there is a useful class of predicates for which predicates can be controlled efficiently. One such class of predicates is disjunctive predicates. <p> Since any global state has to intersect this chain, it must either satisfy the disjunctive predicate or it must be inconsistent. The only problem that remains is whether the chain of true intervals can be selected efficiently. This is demonstrated by an algorithm in <ref> [17] </ref> which achieves predicate control if at all possible. The algorithm runs in O (n 2 p) where p is a bound on the number of false intervals in a process. 5.3. <p> The algorithm runs in O (n 2 p) where p is a bound on the number of false intervals in a process. 5.3. Solving On-line Disjunctive Predicate Control Without prior knowledge of the entire partial-order of events, it is impossible to prevent a deadlock while adding causal edges on-line <ref> [17] </ref>. An adversary can force the debugger into making the wrong choice when presented with multiple possible causal edges to add. Since the debugger is unaware of the future computation, it is unable to avoid creating `wait-for' cycles with the as yet unrevealed partial-order.
References-found: 17

