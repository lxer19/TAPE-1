URL: http://www.cs.washington.edu/homes/wchan/work/TSE98.ps
Refering-URL: http://www.cs.washington.edu/homes/wchan/work/
Root-URL: http://www.cs.washington.edu
Title: Model Checking Large Software Specifications  
Author: William Chan Richard J. Anderson Paul Beame Steve Burns Francesmary Modugno David Notkin Jon D. Reese 
Keyword: Index TermsFormal methods, state-based specifications, requirements, statecharts, symbolic model checking, binary decision diagrams, software verification.  
Abstract: In this paper we present our experiences in using symbolic model checking to analyze a specification of a software system for aircraft collision avoidance. Symbolic model checking has been highly successful when applied to hardware systems. We are interested in whether model checking can be effectively applied to large software specifications. To investigate this, we translated a portion of the state-based system requirements specification of Traffic Alert and Collision Avoidance System II (TCAS II) into input to a model checker (SMV). We successfully used the model checker to analyze a number of properties of the system. We report on our experiences, describing our approach to translating the specification to the SMV language, explaining our methods for achieving acceptable performance, and giving a summary of the properties analyzed. Based on our experiences, we discuss the possibility of using model checking to aid specification development by iteratively applying the technique early in the development cycle. We consider the paper to be a data point for optimism about the potential for more widespread application of model checking to software systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> Software requirements for the A-7E aircraft. </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: For example, they do not contain features such as hierarchical states or microsteps, or do not assume the synchrony hypothesis. Sreemani and Atlee [53] used SMV to analyze the A-7E aircraft software requirements, written in the Software Cost Reduction (SCR) notation <ref> [1, 36] </ref>. They successfully verified and falsified several temporal properties. From an informal specification of a hydroelectric power plant, Pugliese and Tronci [50] developed a process-algebra specification, which was then verified with an in-house BDD-based model checker.
Reference: [2] <author> R. Alur, C. Courcoubetis, and D. L. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proceedings: 5th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <address> Philadelphia, USA, </address> <month> June </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: Although we have been assuming the discrete-time model (i.e., time is a natural number), it is possible to extend model checking to handle the dense-time model (i.e., time is a nonnegative real number), when we restrict to the same class of time predicates <ref> [2] </ref>.
Reference: [3] <author> R. Alur, C. Courcoubetis, T. A. Henzinger, N. Halbwachs, P.- H. Ho, X. Nicollini, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: However, when t, Entered (s), or Exited (s) are used in arbitrary arithmetic expressions, whether discrete time or dense time is used, the machine cannot be precisely modeled as a finite-state system, and in fact, the model checking problem becomes undecidable <ref> [3] </ref>. 4.6 Translate PREV When the value of PREV (y) for some input y is needed, we use the following code: VAR prev-y: Range (y); ASSIGN next (prev-y) := case stable: y; 1: prev-y; esac; Again, we do not initialize prev-y for the same reason that we do not initialize timers. <p> In principle, were such information available, we could have incorporated it in our model, but we would have to discretize the inherently continuous environment. Verification of hybrid systems tackles this problem by modeling the environment with a set of real-valued variables governed by constraints on their derivatives <ref> [3] </ref>. The complexity of model checking becomes much higher and some problems even become undecidable, but symbolic model checkers for hybrid systems have been built [38]. <p> Restriction to Finite States One concern is that BDD-based model checking can only apply to finite state systems, but software is often specified with infinite states. A current research trend is to devise symbolic representations and model-checking algorithms to directly verify some classes of infinite state systems <ref> [3, 9, 14] </ref>, although these techniques are far less mature than BDD-based methods. However, many infinite state systems can be abstracted as finite state ones, which are then amenable to conventional model-checking analysis [39, 55].
Reference: [4] <editor> R. Alur and T. A. Henzinger, editors. </editor> <booktitle> Computer Aided Verification, 8th International Conference, CAV'96 Proceedings, volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, New Jersey, USA, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [5] <author> R. J. Anderson, P. Beame, S. Burns, W. Chan, F. Modugno, D. Notkin, and J. D. Reese. </author> <title> Model checking large software specifications. </title> <editor> In D. Garlan, editor, </editor> <booktitle> Proceedings of the 4th ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 156-166, </pages> <address> San Francisco, USA, </address> <month> October </month> <year> 1996. </year> <note> Also published as Software Engineering Notes, 21(6), </note> <month> November </month> <year> 1996. </year>
Reference-contexts: This article is a full-length report of the conference version of the paper <ref> [5] </ref>. 2 MODEL CHECKING Model checking is a formal-verification technique based on state exploration. Given a state transition system and a property, model checking algorithms exhaustively explore the state space to determine whether the system satisfies the property.
Reference: [6] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language: Design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: This process continues until no more transitions are enabled, at which point the machine becomes stable. This cascading of microsteps, from the point when the external events arrive to the point when the machine becomes stable, is called a step. RSML assumes the synchrony hypothesis <ref> [6] </ref>, which says that during a step, no new external event may occur and the values of the inputs remain unchanged. In Transition (s): Off ! On Location: Mode Trigger Event: w Condition: A D Alt-Layer in state Low T T T alt &lt; 1000 T . .
Reference: [7] <author> R. Bharadwaj and C. Heitmeyer. </author> <title> Verifying SCR requirements specifications using state exploration. </title> <booktitle> In Proceedings of the 1st ACM SIGPLAN Workshop on Automatic Analysis of Software, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Abstraction is the key to scale. In our experiment, most details in Other-Aircraft and arithmetic operations that are inefficient for BDDs were manually abstracted away by nondeter-minism. Some form of abstraction can be automated by performing dependency analysis <ref> [7, 18] </ref>. Another approach to scale is automatic reduction techniques, of which the most relevant is perhaps BDD-based symmetry reduction [20].
Reference: [8] <author> B. W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: 1 INTRODUCTION Errors in software specifications cost money and, in some cases, threaten lives <ref> [8, 43] </ref>.
Reference: [9] <author> B. Boigelot and P. Godefroid. </author> <title> Symbolic verification of communication protocols with infinite state spaces using QDDs. </title> <booktitle> In Alur and Henzinger [4], </booktitle> <pages> pages 1-12. </pages>
Reference-contexts: Restriction to Finite States One concern is that BDD-based model checking can only apply to finite state systems, but software is often specified with infinite states. A current research trend is to devise symbolic representations and model-checking algorithms to directly verify some classes of infinite state systems <ref> [3, 9, 14] </ref>, although these techniques are far less mature than BDD-based methods. However, many infinite state systems can be abstracted as finite state ones, which are then amenable to conventional model-checking analysis [39, 55].
Reference: [10] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(6) </volume> <pages> 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Symbolic model checking [15] based on binary decision diagrams (BDDs) <ref> [10] </ref> is an efficient automatic verification technique that is simultaneously capable of scaling and of verifying a wide range of properties (Section 2). It has been applied successfully to many industry-scale hardware circuits, but not aggressively to the analysis of software specifications. <p> When the state space is finite, we can assume without loss of generality that the state variables are Boolean and there are only finitely many of them. A predicate on these variables is simply a Boolean function, which can be represented by reduced ordered binary decision diagrams (BDDs) <ref> [10] </ref>. Intuitively, a BDD is like a binary decision tree, except that isomorphic subtrees must be combined resulting in a directed acyclic graph. In addition, each path can contain a variable at most once, and must comply with a fixed linear order of the variables.
Reference: [11] <author> R. E. Bryant. </author> <title> On the complexity of VLSI implementations and graph representation of boolean functions with applications to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2) </volume> <pages> 205-213, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Although BDDs under a suitable variable order can efficiently represent equality and inequality between linear expressions (e.g., 2alt 1 + 3alt 2 &gt; alt 3 ), there is provably no efficient BDD representation for multiplication or division of variables (e.g., alt fi time &gt; distance) under any variable order <ref> [11, 54] </ref>. So, we needed to avoid them. Two functions in Own-Aircraft do involve multiplication and division of values for measured altitudes and altitude rates. These are measurements of input variables that we already modeled nondeterministically.
Reference: [12] <author> R. E. Bryant and Y.-A. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <type> Technical Report CMU-CS-94-160, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: transition with a guarding condition xy = z ^ x &gt; 1 ^ y &gt; 1, and determine whether z is a prime number by model-checking whether the transition is never enabled; finding a counterexample corresponds to factoring z. (Bryant and Chen observed a similar connection between BDDs and factoring <ref> [12] </ref>.) Nevertheless, we should note that multiplication does not change the worst-case complexity of model checking, which is already a theoretically intractable problem without it. It follows that any symbolic technique is a heuristic.
Reference: [13] <author> R. E. Bryant and Y.-A. Chen. </author> <title> Verification of arithmetic circuits with binary moment diagrams. </title> <booktitle> In 32nd ACM/IEEE Design Automation Conference, Proceedings 1995, </booktitle> <pages> pages 535-541, </pages> <address> San Francisco, USA, </address> <month> June </month> <year> 1995. </year> <month> ACM/IEEE. </month>
Reference-contexts: It is tempting to adapt BDDs to handle multiplication. Word-level model checking is one such technique [21]. There, control is represented using BDDs and operations on integers are represented using binary moment diagrams <ref> [13] </ref>, which can concisely represent the product of two integers. The algorithm in Clarke et al. [21] allows multiplication in the temporal logic formula, but not multiplicative predicates in the guarding conditions. It is unclear how this method can be adapted to solve our problem.
Reference: [14] <author> T. Bultan, R. Gerber, and W. Pugh. </author> <title> Symbolic model checking of infinite state programs using Presburger artihmetic. </title> <booktitle> In Grumberg [30], </booktitle> <pages> pages 400-411. </pages>
Reference-contexts: Restriction to Finite States One concern is that BDD-based model checking can only apply to finite state systems, but software is often specified with infinite states. A current research trend is to devise symbolic representations and model-checking algorithms to directly verify some classes of infinite state systems <ref> [3, 9, 14] </ref>, although these techniques are far less mature than BDD-based methods. However, many infinite state systems can be abstracted as finite state ones, which are then amenable to conventional model-checking analysis [39, 55].
Reference: [15] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Symbolic model checking <ref> [15] </ref> based on binary decision diagrams (BDDs) [10] is an efficient automatic verification technique that is simultaneously capable of scaling and of verifying a wide range of properties (Section 2). It has been applied successfully to many industry-scale hardware circuits, but not aggressively to the analysis of software specifications. <p> An important breakthrough in model checking was the introduction of symbolic techniques: Instead of visiting individual states as in conventional state space search, symbolic model checkers visit a set of states at a time <ref> [15, 45] </ref>. A state set can be represented by a predicate on the state variables such that a state is in the set if and only if the predicate is true at the state. The efficiency of symbolic model checking relies on succinct representations and efficient manipulations of these predicates. <p> The BDD size can be reduced by dynamic variable reordering and conjunctive partitioning <ref> [15] </ref>, which are supported by the version of SMV that we used (Release 2.4.4). These techniques dramatically improved the performance of checking some formulas; however, they did not solve all the problems. The BDD size was very sensitive to the ranges of the variables representing altitudes and altitude rates.
Reference: [16] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A number of BDD-based symbolic model checkers have been built, mainly for hardware circuit verification. They represent state sets, and often the transition relation, as BDDs. Because of the efficiency of BDDs and their algorithms, hardware systems with over 10 20 states have been analyzed <ref> [16] </ref>, and many industrial designs have been verified or falsified. 2.3 SMV SMV [45] is a CTL symbolic model checker using BDDs to represent state sets and transition relations. Below we summarize the SMV features pertinent to our discussion. In SMV, 1 represents true, and 0, false.
Reference: [17] <author> W. Chan, R. J. Anderson, P. Beame, and D. Notkin. </author> <title> Combining constraint solving and symbolic model checking for a class of systems with non-linear constraints. </title> <booktitle> In Grumberg [30], </booktitle> <pages> pages 316-327. </pages>
Reference-contexts: It is unclear how this method can be adapted to solve our problem. Some of us have proposed tightly coupling BDDs with a decision procedure for nonlinear predicates to attack the problem <ref> [17] </ref>, but more work is needed to investigate its practicality. Another possible approach is approximation, as a middle ground between abstracting out multiplication completely and representing it precisely. 8.6 More Case Studies Additional experience is needed in applying model checking to realistic state-based specifications.
Reference: [18] <author> W. Chan, R. J. Anderson, P. Beame, and D. Notkin. </author> <title> Improving efficiency of symbolic model checking for state-based system 23 requirements. </title> <editor> In M. Young, editor, </editor> <booktitle> ISSTA 98: Proceedings of the ACM SIGSOFT International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 102-112, </pages> <address> Clearwater Beach, Florida, USA, </address> <month> March </month> <year> 1998. </year> <note> Published as Software Engineering Notes, 23(2). </note>
Reference-contexts: As a result, once such a formula is evaluated false, a counterexample can now be found almost instantly. The changes we made to the model checker are detailed elsewhere <ref> [18] </ref>. 6 RESULTS OF ANALYSIS Once we overcame these obstacles, we were ready to do some analysis of the specification using the model checker. The properties that we analyzed include general properties that should hold in most RSML specifications (Sections 6.1-6.3) and domain-specific properties (Sections 6.4 and 6.5). <p> Abstraction is the key to scale. In our experiment, most details in Other-Aircraft and arithmetic operations that are inefficient for BDDs were manually abstracted away by nondeter-minism. Some form of abstraction can be automated by performing dependency analysis <ref> [7, 18] </ref>. Another approach to scale is automatic reduction techniques, of which the most relevant is perhaps BDD-based symmetry reduction [20]. <p> The advantages of so doing compared with the translation approach include more flexibility in the construction of the BDDs, and more efficient and application-sensitive model checking algorithms. For example, the performance of the analysis in this paper can be improved by orders of magnitude by modifying the model checker <ref> [18] </ref>. It is important to design tools that domain experts feel comfortable in using. For example, AND/OR tables (Section 3.1) were designed to replace propositional logic for specifying guarding conditions in RSML because aircraft engineers did not find the latter natural [34].
Reference: [19] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A common logic for model checking is the branching-time Computation Tree Logic (CTL) <ref> [19] </ref>, which extends propositional logic with certain temporal operators. Typical formulas include the following (meanings of the temporal operators such as AG will be given later): AG safe: All reachable states are safe. AG AF stable: The system is stable infinitely often. <p> for our presentation. 2 2.2 Symbolic Model Checking and BDDs In explicit model-checking techniques, the truth value of a CTL formula is determined in a graph-theoretic manner by traversing the state diagram, with time complexity linear in the size of the state space and in the length of the formula <ref> [19] </ref>. Unfortunately, the size of the state space is often exponential in the size of the system description, resulting in the state explosion problem.
Reference: [20] <author> E. M. Clarke, R. Enders, T. Filkorn, and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):77-104, August 1996. 
Reference-contexts: Some form of abstraction can be automated by performing dependency analysis [7, 18]. Another approach to scale is automatic reduction techniques, of which the most relevant is perhaps BDD-based symmetry reduction <ref> [20] </ref>.
Reference: [21] <author> E. M. Clarke, M. Khaira, and X. Zhao. </author> <title> Word level model checkingavoiding the Pentium FDIV error. </title> <booktitle> In 33rd Design Automation Conference, Proceedings 1996, </booktitle> <pages> pages 645-648, </pages> <address> Las Vegas, USA, </address> <month> June </month> <year> 1996. </year> <month> ACM/IEEE. </month>
Reference-contexts: Similarly, there may be other techniques or representations that can handle the nonlinear arithmetic calculations that arise in practice. It is tempting to adapt BDDs to handle multiplication. Word-level model checking is one such technique <ref> [21] </ref>. There, control is represented using BDDs and operations on integers are represented using binary moment diagrams [13], which can concisely represent the product of two integers. The algorithm in Clarke et al. [21] allows multiplication in the temporal logic formula, but not multiplicative predicates in the guarding conditions. <p> It is tempting to adapt BDDs to handle multiplication. Word-level model checking is one such technique <ref> [21] </ref>. There, control is represented using BDDs and operations on integers are represented using binary moment diagrams [13], which can concisely represent the product of two integers. The algorithm in Clarke et al. [21] allows multiplication in the temporal logic formula, but not multiplicative predicates in the guarding conditions. It is unclear how this method can be adapted to solve our problem.
Reference: [22] <author> R. J. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench: A semantics-based verification tool for the verification of concurrent systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: More generally, simulations preserve ACTL formulas, which intuitively include the CTL formulas without the E operator and with negations applied only to propositions. Efficient algorithms for simulation exist <ref> [22, 37] </ref> and provide an attractive way of hierarchical development of systems, although more experimental work for software specification is needed. 8.3 Tool Integration Few, if any, integrated CASE tools today offer symbolic model checking as an option for verification.
Reference: [23] <author> J. C. Corbett. </author> <title> Evaluating deadlock detection methods for concurrent software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(3) </volume> <pages> 161-180, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: In contrast to our work, which studies a single data point for a single approach, Corbett recently compared three approaches, BDD-based model checking (using SMV), partial-order state-space reduction, and inequality necessary conditions, all in the context of detecting deadlock in Ada tasking programs <ref> [23] </ref>. For deadlock, Corbett observed that no technique was clearly superior to the others, but rather each excelled on certain kinds of programs. [23, p. 179] Although the model of synchronization that Corbett considered was different from ours, some issues in the translation to SMV are relevant. <p> For deadlock, Corbett observed that no technique was clearly superior to the others, but rather each excelled on certain kinds of programs. <ref> [23, p. 179] </ref> Although the model of synchronization that Corbett considered was different from ours, some issues in the translation to SMV are relevant. He considered two translation schemes.
Reference: [24] <author> J. Crow and B. L. Di Vito. </author> <title> Formalizing space shuttle software requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT Workshop on Formal Methods in Software Practice, </booktitle> <pages> pages 40-48, </pages> <month> Jan-uary </month> <year> 1996. </year>
Reference-contexts: They successfully verified and falsified several temporal properties. From an informal specification of a hydroelectric power plant, Pugliese and Tronci [50] developed a process-algebra specification, which was then verified with an in-house BDD-based model checker. Crow and Di Vito <ref> [24] </ref> analyzed the requirements for a software subsystem on the Space Shuttle of NASA, using the explicit model checker Murj [26] to verify invariants. Since symbolic representations like BDDs were not used, they manually reduced the ranges of the environment inputs to control the size of the state space.
Reference: [25] <author> W. Damm, H. Hungar, P. Kelb, and R. Schlor. Statecharts: </author> <title> Using graphical specification languages and symbolic model checking in the verification of a production cell. </title> <editor> In C. Lewer-entz and T. Lindner, editors, </editor> <title> Formal Development of Reactive Systems: Case Study Production Cell, </title> <booktitle> volume 891 of Lecture Notes in Computer Science, </booktitle> <pages> pages 131-149. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: We, in contrast, focused on deterministic transitions and certain nondeterministic ones that are easy to model and sufficient for our experiments. Their scheme was used to analyze a hypothetical production cell <ref> [25] </ref>. A compositional approach was used to cope with the BDD explosion problem. 7.2 Approaches to Fighting State Explosion There are a number of other widely researched approaches to handling the state space explosion problem.
Reference: [26] <author> D. L. Dill. </author> <title> The Murj verification system. </title> <booktitle> In Alur and Hen-zinger [4], </booktitle> <pages> pages 390-393. </pages>
Reference-contexts: Crow and Di Vito [24] analyzed the requirements for a software subsystem on the Space Shuttle of NASA, using the explicit model checker Murj <ref> [26] </ref> to verify invariants. Since symbolic representations like BDDs were not used, they manually reduced the ranges of the environment inputs to control the size of the state space. Helbig and Kelb [35] gave a BDD encoding for statecharts.
Reference: [27] <author> M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. </author> <title> Property specification patterns for finite-state verification. </title> <editor> In M. Ardis, editor, </editor> <booktitle> Proceedings of FMSP'98: The 2nd Workshop on Formal Methods in Software Practice, </booktitle> <pages> pages 7-15, </pages> <address> Clearwater Beach, Florida, USA, </address> <month> March </month> <year> 1998. </year>
Reference-contexts: Similarly, domain experts may not like temporal logic or understand its intricacies. Finding intuitive alternatives (perhaps even sacrificing some of the expressive power of the logic) is critical for gaining wider acceptance. Recently, Dwyer et al. have worked along this line and suggested using specification patterns <ref> [27] </ref>. 8.4 Properties to Check Model checking (or any form of property verification) is of no use if we do not know what properties to check. Finding a set of properties with good coverage can also increase our confidence in the correctness of the specification.
Reference: [28] <institution> Federal Aviation Administration, US Department of Transportation. </institution> <note> Introduction to TCAS II, </note> <month> March </month> <year> 1990. </year>
Reference-contexts: In other words, it can only stay unstable for a finite number of microsteps. This formula was found to be true for our model of the specification, as expected. 6.4 Inhibition of Resolution Advisories A TCAS II document <ref> [28] </ref> claims that (1) all Descend RAs are inhibited when the own aircraft is below 1000 feet above ground level, and (2) all Increase-Descend RAs are inhibited below 1450 feet above ground level. The logic that guarantees these safety properties resides in both Own-Aircraft and Other-Aircraft.
Reference: [29] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Architectural mismatch: Why reuse is so hard. </title> <journal> IEEE Software, </journal> <volume> 12(6) </volume> <pages> 17-26, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Symbolic model checking, in its purest form at least, is conceptually simple and, with one of the available BDD pack 20 ages [52], incorporating model checking algorithms into an integrated CASE tool should not be difficult in principle (although integration is almost always more difficult than anticipated <ref> [29] </ref>). The advantages of so doing compared with the translation approach include more flexibility in the construction of the BDDs, and more efficient and application-sensitive model checking algorithms.
Reference: [30] <author> O. Grumberg, </author> <title> editor. </title> <booktitle> Computer Aided Verification, 9th International Conference, CAV'97 Proceedings, volume 1254 of Lecture Notes in Computer Science, </booktitle> <address> Haifa, Israel, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference: [31] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: General translation rules will be described in the next section. 3.1 RSML Overview RSML [44] is a state-machine language based on state-charts <ref> [31] </ref>, extending conventional state diagrams with state hierarchies and broadcast communications. Focusing on a subset of RSML, we model a system by a state hierarchy, events, and inputs; in particular, the input and output interfaces in RSML are ignored.
Reference: [32] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of statecharts. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(4) </volume> <pages> 293-333, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Our representation of microsteps can be viewed as a way of statically eliminating such asynchrony. Alternative Semantics Some other variants of statecharts can be translated with similar rules. For example, the STATE-MATE semantics <ref> [32] </ref> of statecharts is close to the semantics considered here. A notable exception is that the former does not insist on the synchrony hypothesis but provides it as an option. We can easily forsake the synchrony hypothesis by changing Rule 15 in Figure 7 to set stable to 1.
Reference: [33] <author> M. P. E. Heimdahl and B. J. Czerny. </author> <title> Using PVS to analyze hierarchical state-based requirements for completeness and consistency. </title> <booktitle> In Proceedings of the IEEE High Assurance Systems Engineering Workshop, </booktitle> <address> Niagara Falls, Canada, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: This clearly results in a false negative. Heimdahl and Czerny <ref> [33] </ref> use the theorem prover PVS [48] to attack this problem. <p> A disadvantage is the inability to deal with real numbers, which have to be dis-cretized as bounded integers. BDDs also cannot efficiently handle the complicated nonlinear predicates in TCAS II, but currently neither can their theorem-proving approach <ref> [33] </ref>. Although model checking can give more accurate results, it is also more costly.
Reference: [34] <author> M. P. E. Heimdahl and N. G. Leveson. </author> <title> Completeness and consistency in hierarchical state-based requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 363-377, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: In contrast, the semantics defined by Pnueli and Shalev [49] are quite different. It is unclear how to translate from their semantics in a simple way without introducing many auxiliary global state variables. The RSML semantics defined by Heimdahl and Leve-son <ref> [34] </ref> are slightly different from the semantics consid 12 ered here, which are based the earlier work of Leveson et al. [44]. <p> So, our first attempt was to find such transitions with the model checker. (For the other properties that we checked, we worked with a later draft specification, in which there are no inconsistencies in Own-Aircraft.) These nondeterministic transitions had previously been identified by Heimdahl and Leveson <ref> [34] </ref> using a different technique. We were interested in checking these properties to show that model checking could match previous results. In Section 7.3 we will summarize the differences between our model checking approach and the technique used by Heimdahl and Leveson. <p> Corbett's comparison, but further work is needed to determine which approaches are most effective for checking particular properties on specific classes of systems. 7.3 Consistency and Completeness Instead of exploring the state space, Heimdahl and Leveson compose results of local analysis to deduce global properties of the TCAS II specification <ref> [34] </ref>. However, the properties that we checked were different. Their concerns were transition consistency and completeness [41], which are domain-independent properties. In Section 6.1 we discussed how 18 we verified transition consistency. <p> It is important to design tools that domain experts feel comfortable in using. For example, AND/OR tables (Section 3.1) were designed to replace propositional logic for specifying guarding conditions in RSML because aircraft engineers did not find the latter natural <ref> [34] </ref>. Similarly, domain experts may not like temporal logic or understand its intricacies. Finding intuitive alternatives (perhaps even sacrificing some of the expressive power of the logic) is critical for gaining wider acceptance.
Reference: [35] <author> J. Helbig and P. Kelb. </author> <title> An OBDD-representation of state-charts. </title> <booktitle> In Proceedings: The European Design and Test Conference. EDAC, The European Conference on Design Automation. ETC, European Test Conference. EUROASIC, The European Event in ASIC Design, </booktitle> <pages> pages 142-149, </pages> <address> Paris, France, Febru-ary/March 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: There are other potentially more efficient ways of constructing the global transition relation, but in general the constructions are still expensive. Interested readers are referred to the work of Helbig and Kelb <ref> [35] </ref> for an example. We now give modifications to the rules in Figure 7 to handle a rich class of nondeterministic machines, namely those with the property that a transition is taken if and only if it appears to be taken. <p> Since symbolic representations like BDDs were not used, they manually reduced the ranges of the environment inputs to control the size of the state space. Helbig and Kelb <ref> [35] </ref> gave a BDD encoding for statecharts. The version of statecharts semantics and the state hierarchy encoding that they used are similar to ours, except that they did not assume the synchrony hypothesis and did not flatten nested-or states (Section 4.2).
Reference: [36] <author> K. Heninger. </author> <title> Specifying software requirements for complex systems: New techniques and their applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 2-12, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: For example, they do not contain features such as hierarchical states or microsteps, or do not assume the synchrony hypothesis. Sreemani and Atlee [53] used SMV to analyze the A-7E aircraft software requirements, written in the Software Cost Reduction (SCR) notation <ref> [1, 36] </ref>. They successfully verified and falsified several temporal properties. From an informal specification of a hydroelectric power plant, Pugliese and Tronci [50] developed a process-algebra specification, which was then verified with an in-house BDD-based model checker.
Reference: [37] <author> M. R. Henzinger, T. A. Henzinger, and P. W. Kopke. </author> <title> Computing simulations on finite and infinite graphs. </title> <booktitle> In Proceedings: 36th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 453-462, </pages> <address> Milwaukee, Wisconsin, USA, </address> <month> October </month> <year> 1995. </year> <note> IEEE. </note>
Reference-contexts: More generally, simulations preserve ACTL formulas, which intuitively include the CTL formulas without the E operator and with negations applied only to propositions. Efficient algorithms for simulation exist <ref> [22, 37] </ref> and provide an attractive way of hierarchical development of systems, although more experimental work for software specification is needed. 8.3 Tool Integration Few, if any, integrated CASE tools today offer symbolic model checking as an option for verification.
Reference: [38] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HYTECH: </author> <title> A model checker for hybrid systems. </title> <booktitle> In Grumberg [30], </booktitle> <pages> pages 460-463. </pages>
Reference-contexts: Verification of hybrid systems tackles this problem by modeling the environment with a set of real-valued variables governed by constraints on their derivatives [3]. The complexity of model checking becomes much higher and some problems even become undecidable, but symbolic model checkers for hybrid systems have been built <ref> [38] </ref>. Currently, they cannot cope with TCAS II: They cannot handle multiplication, and the sizes of the models analyzed in published case studies are orders of magnitude smaller than TCAS II.
Reference: [39] <author> D. Jackson. </author> <title> Abstract model checking of infinite specifications. </title> <editor> In M. Naftalin, T. Denvir, and M. Bertran, editors, FME'94: </editor> <booktitle> Industrial Benefit of Formal Methods, 2nd International Symposium of Formal Methods Europe, Proceedings, volume 873 of Lecture Notes in Computer Science, </booktitle> <pages> pages 519-531, </pages> <address> Barcelona, Spain, </address> <month> October </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: However, many infinite state systems can be abstracted as finite state ones, which are then amenable to conventional model-checking analysis <ref> [39, 55] </ref>. Often, the abstraction is conservative in the sense that, if the properties hold in the abstraction, they are guaranteed to hold in the full specification.
Reference: [40] <author> D. Jackson and C. A. Damon. </author> <title> Elements of style: Analyzing a software design feature with a counterexample detector. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7) </volume> <pages> 484-95, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: If the goal of analysis is to find errors instead of proving correctness, this preservation guarantee can be forsaken, using techniques like model checking to find counterexamples but not to guarantee prop 19 erties <ref> [40] </ref>. In our work, for example, some inputs of one of the versions of TCAS II are specified as real numbers, which were discretized as integers in our model (Section 5.2). The counterexamples we found in the finite-state model also exist in the full specification.
Reference: [41] <author> M. S. Jaffe, N. G. Leveson, M. P. E. Heimdahl, and B. E. Mel-hart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 241-258, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: There are two reasons why we want to find the latter transitions. First, as Jaffe et al. <ref> [41] </ref> argue, nondeterminism in software requirements usually reflects inconsistency and should be avoided. Second, in our translation into SMV, we assumed the transitions are deterministic and separately dealt with the nondeterministic transitions as special cases (Section 4.4). <p> However, the properties that we checked were different. Their concerns were transition consistency and completeness <ref> [41] </ref>, which are domain-independent properties. In Section 6.1 we discussed how 18 we verified transition consistency. Completeness intuitively means that a response is specified for every input, and in principle can also be checked in our framework. <p> Finding a set of properties with good coverage can also increase our confidence in the correctness of the specification. A number of approaches can be used to address this complex question. * The specification may already state some properties that are supposed to hold. * Jaffe et al. <ref> [41] </ref> described a number of properties that should be satisfied by specifications (at least those with a safety-critical component): determinism, completeness, etc.
Reference: [42] <author> O. Kupferman and M. Y. Vardi. </author> <title> Module checking. </title> <booktitle> In Alur and Henzinger [4], </booktitle> <pages> pages 75-86. </pages>
Reference-contexts: So the analysis of such AG EF formulas is not sound. (This problem can be solved by a recent technique called module checking <ref> [42] </ref>.) 7 RELATED WORK 7.1 Case Studies There have been several other independent case studies of model checking for real-life software requirements.
Reference: [43] <author> N. G. Leveson. Safeware: </author> <title> System Safety and Computers. </title> <publisher> Ad-dison Wesley Longman, </publisher> <year> 1995. </year>
Reference-contexts: 1 INTRODUCTION Errors in software specifications cost money and, in some cases, threaten lives <ref> [8, 43] </ref>.
Reference: [44] <author> N. G. Leveson, M. P. E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: Email: jdreese@safeware-eng.com. large system requirements specification using symbolic model checking. In our experiment, we translated (Sections 3 and 4) a significant portion of a preliminary version of the Traffic Alert and Collision Avoidance System II (TCAS II) System Requirements Specification from the Requirements State Machine Language (RSML) <ref> [44] </ref> into input to the Symbolic Model Verifier (SMV) [45]. TCAS II is an aircraft collision avoidance system required on many commercial aircraft and has been described as the most complex system to be incorporated into the avionics of commercial aircraft [44, p. 685]. <p> TCAS II is an aircraft collision avoidance system required on many commercial aircraft and has been described as the most complex system to be incorporated into the avionics of commercial aircraft <ref> [44, p. 685] </ref>. We were able to control the size of the BDDs representing the specification (Section 5) so that we could analyze a number of properties (Section 6). These include general robustness properties as well as some safety-critical properties specific to the domain. <p> Their conjunction forms the transition relation. 3 TRANSLATION BASICS In this section, we give an informal overview of RSML, and provide intuition of the translation from RSML to SMV by showing an example. General translation rules will be described in the next section. 3.1 RSML Overview RSML <ref> [44] </ref> is a state-machine language based on state-charts [31], extending conventional state diagrams with state hierarchies and broadcast communications. Focusing on a subset of RSML, we model a system by a state hierarchy, events, and inputs; in particular, the input and output interfaces in RSML are ignored. <p> not further discuss identity transitions in this paper. 4 TRANSLATION RULES To explain the translation from RSML to SMV more generally and precisely, we first formally define an RSML machine as a state transition system given in Section 2.1, based on the operational semantics of RSML by Leveson et al. <ref> [44] </ref>. Some of our definitions are based on Pnueli and Shalev [49]. For simplicity, we first assume the absence of timing constraints and PREV functions. Then we show how we translate deterministic RSML machines and certain nondeterministic machines to SMV programs. <p> Yet another possibility is to represent a microstep as a series of global transitions, which directly corresponds to the semantics of RSML given by Leveson et al. <ref> [44] </ref>. There, instead of being defined as a maximal set T of nonconflicting transitions, a microstep is equivalently defined by a loop: T is initially empty, and enabled transitions are added to T one at a time until a maximal set is obtained. <p> It is unclear how to translate from their semantics in a simple way without introducing many auxiliary global state variables. The RSML semantics defined by Heimdahl and Leve-son [34] are slightly different from the semantics consid 12 ered here, which are based the earlier work of Leveson et al. <ref> [44] </ref>. The differences become important when conflicting transitions with different triggers are simultaneously enabled, which does not happen in the portion of the TCAS II requirements machine that we modeled. <p> done as the specification was developed, it could also be an effective way to understand and document the interactions between the parts of the specification. 6.3 Step Termination A step in an RSML state machine may not terminate if the machine contains a cycle of events under the transition relation <ref> [44] </ref>. However, the precedence relation of the events in an RSML specification usually forms a partial order, so it is easy to see that a step will always terminate; this happens in the TCAS II specification.
Reference: [45] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: In our experiment, we translated (Sections 3 and 4) a significant portion of a preliminary version of the Traffic Alert and Collision Avoidance System II (TCAS II) System Requirements Specification from the Requirements State Machine Language (RSML) [44] into input to the Symbolic Model Verifier (SMV) <ref> [45] </ref>. TCAS II is an aircraft collision avoidance system required on many commercial aircraft and has been described as the most complex system to be incorporated into the avionics of commercial aircraft [44, p. 685]. <p> An important breakthrough in model checking was the introduction of symbolic techniques: Instead of visiting individual states as in conventional state space search, symbolic model checkers visit a set of states at a time <ref> [15, 45] </ref>. A state set can be represented by a predicate on the state variables such that a state is in the set if and only if the predicate is true at the state. The efficiency of symbolic model checking relies on succinct representations and efficient manipulations of these predicates. <p> They represent state sets, and often the transition relation, as BDDs. Because of the efficiency of BDDs and their algorithms, hardware systems with over 10 20 states have been analyzed [16], and many industrial designs have been verified or falsified. 2.3 SMV SMV <ref> [45] </ref> is a CTL symbolic model checker using BDDs to represent state sets and transition relations. Below we summarize the SMV features pertinent to our discussion. In SMV, 1 represents true, and 0, false. The logical operators and, or, and not are &, |, and !, respectively.
Reference: [46] <author> K. L. McMillan. </author> <title> Fitting formal methods into the design cycle. </title> <booktitle> In 31st ACM/IEEE Design Automation Conference, Proceedings 1994, </booktitle> <pages> pages 314-319, </pages> <address> San Diego, USA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In addition, analysis results can give fast feedback to designers to improve the cost-effectiveness of the technique. Researchers on hardware verification have also pointed out some advantages of early use of verification <ref> [46] </ref>. For example, when developing the TCAS II specification, an engineer could have specified Own-Aircraft first and have left Other-Aircraft nondeterministic. Then an analyst could have analyzed Own-Aircraft with model checking and discovered the assumptions on the behaviors of Other-Aircraft that are necessary for Own-Aircraft's correct operations.
Reference: [47] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings of the 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: During the development of Other-Aircraft, the properties can be re-checked, as with regression testing, to ensure that the properties are continually maintained. As an alternative to regression checking, if the abstracted model of Other-Aircraft simulates (in the sense of Mil-ner <ref> [47] </ref>) a refined model, then every CTL formula in Sections 6.1-6.5 that holds in the former is guaranteed to hold in the latter as well. More generally, simulations preserve ACTL formulas, which intuitively include the CTL formulas without the E operator and with negations applied only to propositions.
Reference: [48] <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Sri-vas. PVS: </author> <title> Combining specification, proof checking, and model checking. </title> <booktitle> In Alur and Henzinger [4], </booktitle> <pages> pages 411-414. 24 </pages>
Reference-contexts: This clearly results in a false negative. Heimdahl and Czerny [33] use the theorem prover PVS <ref> [48] </ref> to attack this problem. On the other hand, for the same property, we would have 15 Boolean variables representing the bit encoding of alt and then construct the BDD for the predicate alt &gt; 10050 ^ alt &lt; 1950, which is automatically reduced to a contradiction.
Reference: [49] <author> A. Pnueli and M. Shalev. </author> <title> What is in a step: </title> <booktitle> On the seman-tics of statecharts. </booktitle> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Theoretical Aspects of Computer Software, International Conference TACS'91, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-264, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Some of our definitions are based on Pnueli and Shalev <ref> [49] </ref>. For simplicity, we first assume the absence of timing constraints and PREV functions. Then we show how we translate deterministic RSML machines and certain nondeterministic machines to SMV programs. <p> Trigger events are also optional. Slight modifications to the rules would suffice for these differences. Other constructs like history connectors and synchronization through activities would require new translation rules. In contrast, the semantics defined by Pnueli and Shalev <ref> [49] </ref> are quite different. It is unclear how to translate from their semantics in a simple way without introducing many auxiliary global state variables.
Reference: [50] <author> R. Pugliese and E. Tronci. </author> <title> Automatic verification of a hydroelectric power plant. </title> <editor> In M.-C. Gaudel and J. Woodcock, editors, FME'96: </editor> <booktitle> Industrial Benefit and Advances in Formal Methods, 3rd International Symposium of Formal Methods Eu-rope, Proceedings, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 425-444, </pages> <address> Oxford, UK, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Sreemani and Atlee [53] used SMV to analyze the A-7E aircraft software requirements, written in the Software Cost Reduction (SCR) notation [1, 36]. They successfully verified and falsified several temporal properties. From an informal specification of a hydroelectric power plant, Pugliese and Tronci <ref> [50] </ref> developed a process-algebra specification, which was then verified with an in-house BDD-based model checker. Crow and Di Vito [24] analyzed the requirements for a software subsystem on the Space Shuttle of NASA, using the explicit model checker Murj [26] to verify invariants.
Reference: [51] <author> J. D. Reese and N. G. Leveson. </author> <title> Software deviation analysis: A safeware technique. </title> <booktitle> In Proceedings of the 1997 International Conference on Software Engineering: </booktitle> <volume> ICSE 97, </volume> <pages> pages 250-260, </pages> <address> Boston, USA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: We also believe that certain domain-specific properties like output agreement (Section 6.5) are applicable across many applications. * Some other software analysis problems, such as deviation analysis <ref> [51] </ref>, can be posed as model-checking prob lems. * Some properties to check may arise in the field. For example, pilots have reported anomalous behavior that they observed while using some versions of TCAS II.
Reference: [52] <author> E. M. Sentovich. </author> <title> A brief study of BDD package performance. </title> <editor> In M. Srivas and A. Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design: 1st International Conference, FM-CAD'96 Proceedings, </booktitle> <pages> pages 389-403, </pages> <address> Palo Alto, California, USA, </address> <month> November </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Whether manual or automatic translation is used, our experiences showed that checking simple properties like transition consistency and completeness is useful in catching translation bugs. Symbolic model checking, in its purest form at least, is conceptually simple and, with one of the available BDD pack 20 ages <ref> [52] </ref>, incorporating model checking algorithms into an integrated CASE tool should not be difficult in principle (although integration is almost always more difficult than anticipated [29]).
Reference: [53] <author> T. Sreemani and J. M. Atlee. </author> <title> Feasibility of model checking software requirements: A case study. </title> <booktitle> In COMPASS'96, Proceedings of the 11th Annual Conference on Computer Assurance, </booktitle> <pages> pages 77-88, </pages> <address> Gaithersburg, Maryland, USA, </address> <month> June </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: These studies also differ from ours in the requirements languages used. For example, they do not contain features such as hierarchical states or microsteps, or do not assume the synchrony hypothesis. Sreemani and Atlee <ref> [53] </ref> used SMV to analyze the A-7E aircraft software requirements, written in the Software Cost Reduction (SCR) notation [1, 36]. They successfully verified and falsified several temporal properties.
Reference: [54] <author> J. S. Thathachar. </author> <title> On the limitations of ordered representations of functions. </title> <editor> In A. J. Hu and M. Y. Vardi, editors, </editor> <booktitle> Computer Aided Verification, 10th International Conference, CAV'98 Proceedings, volume 1427 of Lecture Notes in Computer Science, </booktitle> <pages> pages 232-243, </pages> <address> Vancouver, Canada, June/July 1998. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Although BDDs under a suitable variable order can efficiently represent equality and inequality between linear expressions (e.g., 2alt 1 + 3alt 2 &gt; alt 3 ), there is provably no efficient BDD representation for multiplication or division of variables (e.g., alt fi time &gt; distance) under any variable order <ref> [11, 54] </ref>. So, we needed to avoid them. Two functions in Own-Aircraft do involve multiplication and division of values for measured altitudes and altitude rates. These are measurements of input variables that we already modeled nondeterministically.
Reference: [55] <author> J. M. Wing and M. Vaziri-Farahani. </author> <title> A case study in model checking software systems. </title> <booktitle> Science of Computer Programming, </booktitle> 28(2/3):273-299, April 1997. 
Reference-contexts: However, many infinite state systems can be abstracted as finite state ones, which are then amenable to conventional model-checking analysis <ref> [39, 55] </ref>. Often, the abstraction is conservative in the sense that, if the properties hold in the abstraction, they are guaranteed to hold in the full specification.
Reference: [56] <author> J. Yang, A. K. Mok, and F. Wang. </author> <title> Symbolic model checking for event-driven real-time systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 19(2) </volume> <pages> 386-412, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: If the subtraction or the comparison were modeled nondeterministically, this safety requirement would be violated trivially. The problem with the ranges was due to SMV's inefficient implementation rather than the limitations of BDDs. As Yang et al. <ref> [56] </ref> observe, SMV is extremely inefficient in constructing BDDs for integers: Building the BDD for even a simple assignment like next (x) := x; requires time and space exponential in the number of bits of x. For expressions involving multiple variables, an additional problem is the variable ordering. <p> We considered two ways of attacking this problem, namely changing the internals of SMV, or doing addition and comparison at the source code level. Although in principle the former may be a better long term solution (Yang et al. <ref> [56] </ref> give an efficient algorithm for constructing BDDs for linear predicates), the latter method seemed a simpler approach and we were able to use it with great success.
References-found: 56

