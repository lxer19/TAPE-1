URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/stack-gc.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Title: Tail-Recursive Stack Disciplines for an Interpreter  
Author: Richard A. Kelsey 
Note: This is a slightly enhanced version  
Date: March 8, 1993  
Affiliation: College of Computer Science Northeastern University  of  College of Computer Science, Northeastern University, 1992.  
Pubnum: Technical Report NU-CCS-93-03,  
Abstract: Many languages, including Scheme, ML, and Haskell, require that their implementations support tail-recursive calls to arbitrary depth. This requirement means that a traditional stack discipline cannot be used for these languages. This paper examines several different methods of implementing proper tail recursion in a stack-based interpeter, including passing arguments in a heap, copying arguments to tail-recursive calls, and garbage collecting the stack. Benchmark timings and other run-time statistics are used to compare the different methods. The results show that using a stack is a good idea, and that the overhead of the interpreter largely overshadows the differences in performance of the various stack disciplines. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffery D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: a stack, and with an efficient garbage collector, the benchmarks used in this paper ran 13% more slowly than the slowest of the stack implementations, and 27% more slowly than the fastest. 2 Why a traditional stack won't work Stacks are the standard way to implement continuations and lexical environments <ref> [Aho 86] </ref>. To make a procedure call, the arguments are pushed on the stack followed by the saved program counter, environment pointer and whatever else will be needed once the procedure returns.
Reference: [Appel 87] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <note> In Information Processing Letters 25, </note> <year> 1987. </year>
Reference-contexts: Interpreters should be simple, fast, and provide good debugging information for the user. I will judge the stack disciplines on how well they support these goals. The best stack discipline might be not to have a stack at all. It is advocated in <ref> [Appel 87] </ref> that with a very efficient garbage collector and a good compiler, heaps may be more efficient than stacks. With an interpreter this appears not to be the case. Making efficient use of a heap for procedure calls requires more sophisticated compilation than is usual for interpreters. <p> Use the heap instead of a stack One obvious solution, since there has to be a heap for some environments and continuations, is just to put the environments there in the first place. Unused heap storage will eventually be reclaimed, which allows for an unbounded number of tail-recursive calls. <ref> [Appel 87] </ref> advocates placing all environments, as well as all continuations, in the heap. 2. Overwrite the environment during tail-recursive calls It is also possible to implement proper tail recursion and still use a stack for the environments. <p> With relatively few tail-recursive calls and almost no preserved environments, heap-envs loses and stack-gc and move-args tie. 7 Comparison with other work The methods of implementing tail recursion with a stack that I have described here have been discussed in <ref> [Hanson 90, McDermott 80, Appel 87, Kranz 88] </ref>, usually in the context of a native-code compiler. Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques.
Reference: [Clinger 88] <author> William D Clinger, Anne H Hartheimer, and Eric M Ost. </author> <title> Implementation strategies for continuations. </title> <booktitle> In Proceedings Record of the 1988 ACM Symposium on Lisp and Functional Programming, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: In most cases, the environment and continuation passed to a procedure are removed from the stack when the procedure returns. If they need to be preserved they may be copied to a heap <ref> [Clinger 88] </ref>. Copying requires that each environment and continuation include an indication of its size. <p> Checking for stack underflow during procedure returns can be avoided by placing a special continuation at the base of the stack which copies the next continuation from the heap onto the stack. Locality considerations might keep the cost of copying fairly low, as argued in <ref> [Clinger 88] </ref>. This is certainly the most attractive strategy for languages that already require a heap. 6 4 Saving Environments All of the languages which were given as examples of properly tail-recursive languages are also lexically scoped and allow procedures to escape upwards. <p> For example, much of the concern in [Hanson 90] and [Kranz 88] is with trying to get the maximum number of environments on the stack. In the benchmarks in this paper, the effects of not putting any environments on the stack are not all that great. In <ref> [Clinger 88] </ref> different stack implementations are compared in terms of implementing continuations with unlimited extent. In terms of implementing explicit continutions, the no-stack version here corresponds to their `garbage collection strategy', and the others are all variations on their `incremental stack/heap strategy'.
Reference: [Hanson 90] <author> Chris Hanson. </author> <title> Efficient stack allocation for tail recursive languages. </title> <booktitle> In Proceedings of the 1990 ACM Symposium on Lisp and Functional Programming, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Any number of such calls could be made without overflowing. There are two possibilities here. The current environment could be incrementally overwritten as the new arguments are produced, as in <ref> [Kranz 88, Hanson 90] </ref>, or the arguments could be stored in temporary locations and then copied on top of the current environment once they are all available, also in [Hanson 90, McDermott 80]. <p> There are two possibilities here. The current environment could be incrementally overwritten as the new arguments are produced, as in [Kranz 88, Hanson 90], or the arguments could be stored in temporary locations and then copied on top of the current environment once they are all available, also in <ref> [Hanson 90, McDermott 80] </ref>. The first is usually more efficient, as a clever implementation can get away with moving fewer values, and the second is clearly simpler, as data dependencies between the values in the environment and the arguments can be ignored. <p> Compile-time analysis and run-time checks can both be used to reduce the number of environments that are migrated to the heap, as reported in <ref> [McDermott 80, Kranz 88, Hanson 90] </ref> and elsewhere. The ability to garbage collect the stack increases the number of environments that can be allocated on the stack, even for a compiler that normally overwrites the current lexical environment when making tail-recursive calls. <p> With relatively few tail-recursive calls and almost no preserved environments, heap-envs loses and stack-gc and move-args tie. 7 Comparison with other work The methods of implementing tail recursion with a stack that I have described here have been discussed in <ref> [Hanson 90, McDermott 80, Appel 87, Kranz 88] </ref>, usually in the context of a native-code compiler. Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques. <p> Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques. For example, much of the concern in <ref> [Hanson 90] </ref> and [Kranz 88] is with trying to get the maximum number of environments on the stack. In the benchmarks in this paper, the effects of not putting any environments on the stack are not all that great.
Reference: [Hudak 90] <editor> P. Hudak and P. Wadler (editors). </editor> <title> Report on the programming language Haskell. </title> <type> Technical Report YALEU/DCS/TR-777, </type> <institution> Department of Computer Science, Yale University, </institution> <year> 1990. </year>
Reference-contexts: 1 The Problem A programming language implementation is properly tail recursive if unbounded iterative computations that are expressed recursively can be executed in constant space. Implementations of languages such as Scheme [Rees 86], ML [Milner 88], and Haskell <ref> [Hudak 90] </ref> are required to be tail recursive. These languages also require that some lexical environments have indefinite extent. That is, arguments passed to a procedure may need to be preserved until long after the procedure has returned. Similarly, in Scheme, continuations also may have indefinite extent.
Reference: [Hieb 90] <author> Robert Hieb, R. Kent Dybvig and Carl Bruggeman. </author> <title> Representing Control in the Presence of First-Class Continuations. </title> <booktitle> In Proceddings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: It could result in thrashing if a program pushed a large quantity of live data and then repeatedly caused the stack to overflow. A system similar to that described in <ref> [Hieb 90] </ref> for minimizing the cost of saving continuations could be used to reduce or avoid copying data multiple times. The third possibility, copying the live data into a heap, reduces the possibility of thrashing.
Reference: [Kranz 88] <author> David Andrew Kranz. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <type> Technical Report YALEU/DCS/TR-632, </type> <institution> Department of Computer Science, Yale University, </institution> <year> 1988. </year>
Reference-contexts: Any number of such calls could be made without overflowing. There are two possibilities here. The current environment could be incrementally overwritten as the new arguments are produced, as in <ref> [Kranz 88, Hanson 90] </ref>, or the arguments could be stored in temporary locations and then copied on top of the current environment once they are all available, also in [Hanson 90, McDermott 80]. <p> Compile-time analysis and run-time checks can both be used to reduce the number of environments that are migrated to the heap, as reported in <ref> [McDermott 80, Kranz 88, Hanson 90] </ref> and elsewhere. The ability to garbage collect the stack increases the number of environments that can be allocated on the stack, even for a compiler that normally overwrites the current lexical environment when making tail-recursive calls. <p> The results of running several benchmarks are shown in figures 3 and 4. With the exception of length and cpstak, the benchmarks were taken from <ref> [Kranz 88] </ref> and modified to run in Scheme instead of T. length is a simple loop in which all of the calls are tail recursive. cpstak was written by Will Clinger. The benchmarks were run with a heap size of one megabyte and a 40,000 byte stack. <p> With relatively few tail-recursive calls and almost no preserved environments, heap-envs loses and stack-gc and move-args tie. 7 Comparison with other work The methods of implementing tail recursion with a stack that I have described here have been discussed in <ref> [Hanson 90, McDermott 80, Appel 87, Kranz 88] </ref>, usually in the context of a native-code compiler. Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques. <p> Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques. For example, much of the concern in [Hanson 90] and <ref> [Kranz 88] </ref> is with trying to get the maximum number of environments on the stack. In the benchmarks in this paper, the effects of not putting any environments on the stack are not all that great.
Reference: [McDermott 80] <author> Drew McDermott. </author> <title> An efficient environment allocation scheme in an interpreter for a lexically-scoped Lisp. </title> <booktitle> In Proceedings of the 1980 Lisp Conference, ACM, </booktitle> <year> 1980 </year>
Reference-contexts: There are two possibilities here. The current environment could be incrementally overwritten as the new arguments are produced, as in [Kranz 88, Hanson 90], or the arguments could be stored in temporary locations and then copied on top of the current environment once they are all available, also in <ref> [Hanson 90, McDermott 80] </ref>. The first is usually more efficient, as a clever implementation can get away with moving fewer values, and the second is clearly simpler, as data dependencies between the values in the environment and the arguments can be ignored. <p> Compile-time analysis and run-time checks can both be used to reduce the number of environments that are migrated to the heap, as reported in <ref> [McDermott 80, Kranz 88, Hanson 90] </ref> and elsewhere. The ability to garbage collect the stack increases the number of environments that can be allocated on the stack, even for a compiler that normally overwrites the current lexical environment when making tail-recursive calls. <p> With relatively few tail-recursive calls and almost no preserved environments, heap-envs loses and stack-gc and move-args tie. 7 Comparison with other work The methods of implementing tail recursion with a stack that I have described here have been discussed in <ref> [Hanson 90, McDermott 80, Appel 87, Kranz 88] </ref>, usually in the context of a native-code compiler. Interpreters require a different set of priorities. Simple translation and preserving debugging information are much more important than with native-code compilers. The inherent inefficiency of interpretation affects the relative efficiencies of different techniques.
Reference: [Milner 88] <author> R. Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, ACM, </booktitle> <year> 1984. </year>
Reference-contexts: 1 The Problem A programming language implementation is properly tail recursive if unbounded iterative computations that are expressed recursively can be executed in constant space. Implementations of languages such as Scheme [Rees 86], ML <ref> [Milner 88] </ref>, and Haskell [Hudak 90] are required to be tail recursive. These languages also require that some lexical environments have indefinite extent. That is, arguments passed to a procedure may need to be preserved until long after the procedure has returned.
Reference: [Rees 86] <editor> Jonathan A. Rees and William Clinger, editors. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21(12), </journal> <pages> pages 37-79, </pages> <year> 1986. </year>
Reference-contexts: 1 The Problem A programming language implementation is properly tail recursive if unbounded iterative computations that are expressed recursively can be executed in constant space. Implementations of languages such as Scheme <ref> [Rees 86] </ref>, ML [Milner 88], and Haskell [Hudak 90] are required to be tail recursive. These languages also require that some lexical environments have indefinite extent. That is, arguments passed to a procedure may need to be preserved until long after the procedure has returned.
Reference: [Steele 77] <author> Guy Lewis Steele Jr. </author> <title> Debunking the "expensive procedure call" myth. </title> <type> AI Memo 443, </type> <institution> Artificial Intellegence Laboratory, Massachusetts Institute of Technology, </institution> <year> 1977. </year> <month> 13 </month>
Reference-contexts: To avoid complications, the stack usage would have to be changed so that continuations to calls were pushed before the arguments, rather than afterwards. Figure 2 shows how such a stack would appear at various times during the execution of the example. A similar calling sequence is presented in <ref> [Steele 77] </ref>. Otherwise a procedure would sometimes be called with its arguments on the top of the stack, while at other times there would be a continuation above the arguments. 3.
References-found: 11

