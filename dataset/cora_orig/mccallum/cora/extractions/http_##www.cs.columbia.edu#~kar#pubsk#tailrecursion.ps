URL: http://www.cs.columbia.edu/~kar/pubsk/tailrecursion.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: Tail Recursion Elimination in Deductive Databases  
Author: Kenneth A. Ross 
Date: 2, June 1996, pp.208-237  
Note: ACM Transactions on Database Systems, Vol. 21, No.  
Affiliation: Columbia University  
Abstract: We consider an optimization technique for deductive and relational databases. The optimization technique is an extension of the magic templates rewriting, and it can improve the performance of query evaluation by not materializing the extension of intermediate views. Standard relational techniques, such as unfolding embedded view definitions, do not apply to recursively defined views, and so alternative techniques are necessary. We demonstrate the correctness of our rewriting. We define a class of "nonrepeating" view definitions, and show that for certain queries our rewriting performs at least as well as magic templates on nonrepeating views, and often much better. A syntactically recognizable property, called "weak right-linearity," is proposed. Weak right-linearity is a sufficient condition for nonrepetition, and is more general than right-linearity. Our technique gives the same benefits as right-linear evaluation of right linear views, while applying to a significantly more general class of views.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Apt, K. R., and Van Emden, M. H. </author> <title> Contributions to the theory of logic programming. </title> <journal> JACM 29, </journal> <volume> 3 (1982), </volume> <pages> 841-862. </pages>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 5.1, the soundness and completeness of SLD-resolution <ref> [1, 6, 8, 11] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . 14 Note that our correctness result does not state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [2] <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J. D. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Database Systems (1986), </booktitle> <pages> pp. 1-15. </pages>
Reference-contexts: The total number of materialized tuples is two orders of magnitude smaller than that for the standard approach, and thus represents a significant improvement in performance. 2 Magic-sets <ref> [2, 3] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant.
Reference: [3] <author> Beeri, C., and Ramakrishnan, R. </author> <title> On the power of magic. </title> <note> Journal of Logic Programming 10 (1991), 255-300. Preliminary version appeared in the 6th ACM Symposium on Principles of Database Systems, </note> <year> 1987. </year>
Reference-contexts: The total number of materialized tuples is two orders of magnitude smaller than that for the standard approach, and thus represents a significant improvement in performance. 2 Magic-sets <ref> [2, 3] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. <p> Hence it may be preferable to compute this join once, and refer to the computed result in each of these rules. A technique for systematically performing such common-subexpression elimination has been proposed in <ref> [3] </ref> and extended in [20]. The basic idea is to create new relations called "supplementary relations" that hold the result of the conjunction of an initial sequence of the subgoals in the body of a rule.
Reference: [4] <author> Bry, F. </author> <title> Query evaluaton in recursive databases: Bottom-up and top-down reconciled. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases (1989), </booktitle> <publisher> Elsevier, </publisher> <address> New York, </address> <pages> pp. 20-39. </pages>
Reference-contexts: This transformation will allow the tail recursive evaluation of a portion of the program while the remainder of the program is evaluated according to standard magic template techniques. Bry's translation of SLD-resolution <ref> [4] </ref> explicitly represents the intermediate tuples, and hence does not take advantage of this potential optimization. 1 Here, F n is the nth Fibonacci number, which for large n is well approximated by ff n where 1:618 and ff 0:447. 4.1 The Tail-Recursive Rewriting The first step of the rewriting is
Reference: [5] <author> Chen, W., Kifer, M., and Warren, D. S. HiLog: </author> <title> A first order semantics for higher-order logic programming constructs. </title> <booktitle> In Proc. North American Logic Programming Conference (1989), </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <pages> pp. 1090-1114. </pages>
Reference-contexts: We consider only Horn programs in this paper. The techniques developed in this paper could be extended to programs with negation by combining with the techniques of [9, 12, 17, 19]. HiLog It will be convenient in our exposition to use HiLog notation for some meta-predicates <ref> [5] </ref>. HiLog allows one to have atoms as terms in other atoms. For example, we might write magic (h (X)) where h is a predicate symbol rather than a function symbol. The use of HiLog in the present context is not essential.
Reference: [6] <author> Clark, K. L. </author> <title> Predicate logic as a computational formalism. </title> <type> Tech. Rep. 79/59, </type> <institution> Department of Computing, Imperial College, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 5.1, the soundness and completeness of SLD-resolution <ref> [1, 6, 8, 11] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . 14 Note that our correctness result does not state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [7] <author> Codish, M., Dams, D., and Yardeni, E. </author> <title> Bottom-up abstract interpretation of logic programs. </title> <booktitle> Theoretical Computer Science 124, 1 (1994), </booktitle> <pages> 93-125. 25 </pages>
Reference-contexts: In Theorem 6.1 we make the assumption that newly generated atoms are checked against the current information for variance rather than subsumption. There are some subtle effects 18 on relative efficiency that appear when one uses subsumption checking. For a discussion of this issue, see <ref> [7, 23] </ref>. With the extension proposed above we can do better than "sip-optimal" [16].
Reference: [8] <author> Hill, R. </author> <title> LUSH resolution and its completeness. </title> <type> Tech. Rep. DCL Memo 78, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1974. </year>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 5.1, the soundness and completeness of SLD-resolution <ref> [1, 6, 8, 11] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . 14 Note that our correctness result does not state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [9] <author> Kemp, D., Stuckey, P., and Srivastava, D. </author> <title> Query restricted bottom-up evaluation of normal logic programs. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming (1992), </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <pages> pp. 288-302. </pages>
Reference-contexts: We consider only Horn programs in this paper. The techniques developed in this paper could be extended to programs with negation by combining with the techniques of <ref> [9, 12, 17, 19] </ref>. HiLog It will be convenient in our exposition to use HiLog notation for some meta-predicates [5]. HiLog allows one to have atoms as terms in other atoms. For example, we might write magic (h (X)) where h is a predicate symbol rather than a function symbol.
Reference: [10] <author> Kemp, D. B., Ramamohanarao, K., and Somogyi, Z. Right-, </author> <title> left- and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (1990), </booktitle> <publisher> Morgan Kaufman, Palo Alto, </publisher> <pages> pp. 380-391. </pages>
Reference-contexts: The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in <ref> [10] </ref> and (independently) in [13] for right-linear programs with multiple bindings. It is noted in [25] that Prolog effectively applies tail-recursion optimization for right-linear programs. 6.2 Examples We shall demonstrate below some examples of nonrepeating programs that are not right linear, for which tail-recursion elimination produces a significant speedup.
Reference: [11] <author> Lloyd, J. W. </author> <booktitle> Foundations of Logic Programming, 2nd ed. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: We consider normal programs with function symbols <ref> [11] </ref> as presented formally below. <p> We could rewrite magic (h (X)) as m h (X), and rewrite magic (A) in terms of several cases for A having various predicate names. However, HiLog enables a more concise and clear presentation. 2.1 SLD Resolution We present a definition of SLD-resolution from <ref> [11] </ref>, specialized to use a left-to-right "computation rule." Definition 2.3: A goal is a (negated) conjunction of atoms, written A 1 ; ; A n . 2 Definition 2.4: (SLD-tree) Let P be a program and G a goal. <p> Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 5.1, the soundness and completeness of SLD-resolution <ref> [1, 6, 8, 11] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . 14 Note that our correctness result does not state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [12] <author> Morishita, S. </author> <title> An alternating fixpoint tailored to magic programs. </title> <booktitle> In Proceedings of the Twelfth ACM Conference on Principles of Database Systems (1993), </booktitle> <pages> pp. 123-134. </pages>
Reference-contexts: We consider only Horn programs in this paper. The techniques developed in this paper could be extended to programs with negation by combining with the techniques of <ref> [9, 12, 17, 19] </ref>. HiLog It will be convenient in our exposition to use HiLog notation for some meta-predicates [5]. HiLog allows one to have atoms as terms in other atoms. For example, we might write magic (h (X)) where h is a predicate symbol rather than a function symbol.
Reference: [13] <author> Mumick, I. S., and Pirahesh, H. </author> <title> Right-linear and overbound queries. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems (1991), </booktitle> <pages> pp. 127-141. </pages>
Reference-contexts: The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in [10] and (independently) in <ref> [13] </ref> for right-linear programs with multiple bindings. It is noted in [25] that Prolog effectively applies tail-recursion optimization for right-linear programs. 6.2 Examples We shall demonstrate below some examples of nonrepeating programs that are not right linear, for which tail-recursion elimination produces a significant speedup.
Reference: [14] <author> Naughton, J. F., Ramakrishnan, R., Sagiv, Y., and Ullman, J. D. </author> <title> Argument reduction by factoring. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (1989), </booktitle> <publisher> Morgan Kaufman, Palo Alto, </publisher> <pages> pp. 173-182. </pages>
Reference-contexts: Magic templates [16] is an extension of magic-sets to handle nonground tuples. Magic-sets and magic-templates materialize portions of all intermediate views, as described in Example 1.1, and so suffer from the problems mentioned above. 3 Other techniques, such as right-linear evaluation <ref> [14, 15] </ref> give better performance than magic sets for restricted classes of programs. Common programs such as transitive closures (including Example 1.1) fall into the class of right-linear programs. The right-linear optimization can be thought of as a limited form of tail-recursion elimination. <p> Our techniques are motivated by considering a top-down, Prolog-style evaluation method without memoing that does not fully compute "intermediate" predicates. In some cases, Prolog-style evaluation effectively applies tail-recursion elimination. It is this tail-recursion elimination that is exploited for right-linear programs in <ref> [14, 15] </ref>. We use this observation about top-down evaluation to motivate a bottom-up formalization of tail-recursion elimination. This formalization improves on top-down evaluation in that it remains efficient even when top-down evaluation does not terminate. <p> In Section 6.3 we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. 6.1 Right Linearity So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [14, 15, 25] </ref> could have been applied. Definition 6.2: An adornment for an occurrence of a predicate p is a string of "b" and "f" symbols, one for each argument of p, indicating whether the corresponding argument is called bound or free, respectively.
Reference: [15] <author> Naughton, J. F., Ramakrishnan, R., Sagiv, Y., and Ullman, J. D. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data (1989), </booktitle> <pages> pp. 235-242. </pages>
Reference-contexts: Magic templates [16] is an extension of magic-sets to handle nonground tuples. Magic-sets and magic-templates materialize portions of all intermediate views, as described in Example 1.1, and so suffer from the problems mentioned above. 3 Other techniques, such as right-linear evaluation <ref> [14, 15] </ref> give better performance than magic sets for restricted classes of programs. Common programs such as transitive closures (including Example 1.1) fall into the class of right-linear programs. The right-linear optimization can be thought of as a limited form of tail-recursion elimination. <p> Our techniques are motivated by considering a top-down, Prolog-style evaluation method without memoing that does not fully compute "intermediate" predicates. In some cases, Prolog-style evaluation effectively applies tail-recursion elimination. It is this tail-recursion elimination that is exploited for right-linear programs in <ref> [14, 15] </ref>. We use this observation about top-down evaluation to motivate a bottom-up formalization of tail-recursion elimination. This formalization improves on top-down evaluation in that it remains efficient even when top-down evaluation does not terminate. <p> In Section 6.3 we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. 6.1 Right Linearity So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [14, 15, 25] </ref> could have been applied. Definition 6.2: An adornment for an occurrence of a predicate p is a string of "b" and "f" symbols, one for each argument of p, indicating whether the corresponding argument is called bound or free, respectively. <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv [21], the class of left-linear rules <ref> [15] </ref> can be generalized in a symmetric way. Left-linear optimization and mixed-linear optimization [15] can then be suitably generalized for programs with rules that commute and are either weakly right-linear or "weakly left-linear." Acknowledgements I would like to thank Michael Maher, Shuky Sagiv, S. <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv [21], the class of left-linear rules <ref> [15] </ref> can be generalized in a symmetric way. Left-linear optimization and mixed-linear optimization [15] can then be suitably generalized for programs with rules that commute and are either weakly right-linear or "weakly left-linear." Acknowledgements I would like to thank Michael Maher, Shuky Sagiv, S. Sudarshan, Jeff Ullman, and the NAIL! group at Stanford for helpful comments on this work.
Reference: [16] <author> Ramakrishnan, R. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <journal> Journal of Logic Programming 11 (1991), </journal> <pages> 189-216. </pages>
Reference-contexts: By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. Magic templates <ref> [16] </ref> is an extension of magic-sets to handle nonground tuples. <p> In the rewritten program, only rules that are relevant to the query are ever fired. One rewriting technique developed for this purpose is the "magic templates" rewriting of Ramakrishnan <ref> [16] </ref>. We now review the magic templates rewriting. 6 In our presentation we shall assume that subgoals are evaluated from left to right. In the terminology of [16], we use a "full sideways information passing strategy" with a left-to-right order of subgoals. <p> One rewriting technique developed for this purpose is the "magic templates" rewriting of Ramakrishnan <ref> [16] </ref>. We now review the magic templates rewriting. 6 In our presentation we shall assume that subgoals are evaluated from left to right. In the terminology of [16], we use a "full sideways information passing strategy" with a left-to-right order of subgoals. While the original magic templates transformation introduces a new predicate m p for each predicate p, we shall use the notation magic (p ( ~ X)) rather than m p ( ~ X). <p> In the case where there are no right-recursive predicates, our result implies the correctness of magic templates, as shown previously in <ref> [16] </ref>. We assume that a subset of the IDB predicates of the program have been labeled as "right-recursive." We make use of the concept of a "right ancestor." Definition 5.1: (Right ancestor). <p> There are some subtle effects 18 on relative efficiency that appear when one uses subsumption checking. For a discussion of this issue, see [7, 23]. With the extension proposed above we can do better than "sip-optimal" <ref> [16] </ref>. <p> Modulo the magic tuples, magic templates is sip-optimal <ref> [16] </ref>. Modulo the magic and query tuples, our extension is at worst sip-optimal for nonrepeating programs, by Theorem 6.1.
Reference: [17] <author> Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proc. Joint International Conference and Symposium on Logic Programming (1992), </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <pages> pp. 273-287. </pages>
Reference-contexts: We consider only Horn programs in this paper. The techniques developed in this paper could be extended to programs with negation by combining with the techniques of <ref> [9, 12, 17, 19] </ref>. HiLog It will be convenient in our exposition to use HiLog notation for some meta-predicates [5]. HiLog allows one to have atoms as terms in other atoms. For example, we might write magic (h (X)) where h is a predicate symbol rather than a function symbol.
Reference: [18] <author> Ross, K. A. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems (1991), </booktitle> <pages> pp. 92-101. </pages>
Reference-contexts: J. Watson Research Laboratory. The research conducted at Stanford University was supported under NSF grant IRI-87-22886, a grant from IBM Corporation, and AFOSR contract 88-0266. A preliminary version of this paper appeared at the 1991 conference on Principles of Database Systems <ref> [18] </ref>. 1 not representing intermediate results of a bottom-up computation, substantial savings over magic sets alone can be realized. To motivate our technique, consider the following SQL views. <p> The tail-recursive evaluation will mean that we won't directly generate tuples for the head predicate, and so the conjunction of all subgoals but the rightmost will be used once rather than twice. For a version of our transformation that incorporates supplementary predicates see <ref> [18] </ref>. 4.3 Nonrecursive Predicates While our terminology describes predicates as "right-recursive," it is not necessary that such predicates actually be recursive. The optimization described above can still provide significant benefits for nonrecursive programs.
Reference: [19] <author> Ross, K. A. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <journal> Journal of the ACM 41, </journal> <volume> 6 (1994), </volume> <pages> 1216-1266. </pages>
Reference-contexts: We consider only Horn programs in this paper. The techniques developed in this paper could be extended to programs with negation by combining with the techniques of <ref> [9, 12, 17, 19] </ref>. HiLog It will be convenient in our exposition to use HiLog notation for some meta-predicates [5]. HiLog allows one to have atoms as terms in other atoms. For example, we might write magic (h (X)) where h is a predicate symbol rather than a function symbol.
Reference: [20] <author> Sacca, D., and Zaniolo, C. </author> <title> Implementation of recursive queries for a data language based on pure Horn logic. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming (1987), </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <pages> pp. 104-135. </pages>
Reference-contexts: Hence it may be preferable to compute this join once, and refer to the computed result in each of these rules. A technique for systematically performing such common-subexpression elimination has been proposed in [3] and extended in <ref> [20] </ref>. The basic idea is to create new relations called "supplementary relations" that hold the result of the conjunction of an initial sequence of the subgoals in the body of a rule.
Reference: [21] <author> Sagiv, Y., </author> <year> 1990. </year> <type> (personal communication). </type>
Reference-contexts: free according to ff is the same variable in both the head and the recursive subgoal, and each of these variables appears only in these two positions. 2 When rightmost subgoals of right-recursive predicates satisfy the condition of right-linearity, our transformation is essentially the same as one developed by Sagiv <ref> [21] </ref> for this special case. The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in [10] and (independently) in [13] for right-linear programs with multiple bindings. <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv <ref> [21] </ref>, the class of left-linear rules [15] can be generalized in a symmetric way. Left-linear optimization and mixed-linear optimization [15] can then be suitably generalized for programs with rules that commute and are either weakly right-linear or "weakly left-linear." Acknowledgements I would like to thank Michael Maher, Shuky Sagiv, S.
Reference: [22] <author> Sethi, R. </author> <title> Programming Languages, Concepts and Constructs. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year> <month> 26 </month>
Reference-contexts: In other cases, the nonground tuples are essential. An example is a program containing a fact p (X; X) that states that p is true if its two arguments are equal. 2.3 Tail Recursion Consider the following C code fragment for a recursive binary-search procedure, based on one from <ref> [22] </ref>. int search (int lo, int hi, int val) - int k; if (lo &gt; hi) return 0; k = (lo + hi)/2; if (val == List [k]) return 1; else if (val &lt; List [k]) return search (lo,k-1,val); else if (val &gt; List [k]) return search (k+1,hi,val); - This procedure
Reference: [23] <author> Sudarshan, S. </author> <title> Optimizing Bottom-Up Query Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, Madison, </institution> <month> November </month> <year> 1992. </year> <note> University of Wisconsin Technical Report 1125. </note>
Reference-contexts: In Theorem 6.1 we make the assumption that newly generated atoms are checked against the current information for variance rather than subsumption. There are some subtle effects 18 on relative efficiency that appear when one uses subsumption checking. For a discussion of this issue, see <ref> [7, 23] </ref>. With the extension proposed above we can do better than "sip-optimal" [16].
Reference: [24] <author> Ullman, J. D. </author> <title> Bottom-up beats top-down for datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems (1989), </booktitle> <pages> pp. 140-149. </pages>
Reference-contexts: it is particularly important that these recursive calls be optimized so that such relations are not stored or copied more often than necessary. 3 Top-Down Can Beat Bottom-Up You may be startled by the title of this section, especially if you have seen the paper "Bottom-up Beats Top-down for DATALOG," <ref> [24] </ref>. However, there is no inconsistency here: the model of top-down computation in [24] represents intermediate answers, whereas the one used in this section does not. <p> relations are not stored or copied more often than necessary. 3 Top-Down Can Beat Bottom-Up You may be startled by the title of this section, especially if you have seen the paper "Bottom-up Beats Top-down for DATALOG," <ref> [24] </ref>. However, there is no inconsistency here: the model of top-down computation in [24] represents intermediate answers, whereas the one used in this section does not. <p> Without this kind of tail-recursion elimination, the answers would be percolated up the tree through the intermediate nodes until the original query was reached, as in the top-down method of <ref> [24] </ref>. To find all the answers the amount of work done by SLD-resolution is fi (m + n). As we have seen, the magic templates method would compute all the intermediate relations p (i; X) for i = 2; : : : n, each of which is of size m.
Reference: [25] <author> Ullman, J. D. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title> <type> 27 </type>
Reference-contexts: In large databases they could make the difference between a query being feasible or infeasible. For nonrecursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See <ref> [25] </ref> for a comprehensive discussion of these and other strategies.) In this paper we propose an optimization technique that integrates magic sets and a form of tail-recursion elimination significantly more general than right-linear evaluation. <p> a rule is fired only for instances of the body in which at least one subgoal was newly derived on the previous iteration is called "semi-naive evaluation." There are a number of reasons why one might prefer a bottom-up strategy to a top-down strategy, and the reader is referred to <ref> [25] </ref> for a discussion of this issue. However, a bottom-up evaluation of the original rules is likely to be inefficient because it does not take the query into account. <p> In Section 6.3 we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. 6.1 Right Linearity So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [14, 15, 25] </ref> could have been applied. Definition 6.2: An adornment for an occurrence of a predicate p is a string of "b" and "f" symbols, one for each argument of p, indicating whether the corresponding argument is called bound or free, respectively. <p> The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in [10] and (independently) in [13] for right-linear programs with multiple bindings. It is noted in <ref> [25] </ref> that Prolog effectively applies tail-recursion optimization for right-linear programs. 6.2 Examples We shall demonstrate below some examples of nonrepeating programs that are not right linear, for which tail-recursion elimination produces a significant speedup.
References-found: 25

