URL: http://www.pmg.lcs.mit.edu/papers/thor.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/areas/type-safe.html
Root-URL: 
Email: fliskov,adya,castro,,,,umesh,andru,liubag@lcs.mit.edu  
Title: Safe and Efficient Sharing of Persistent Objects in Thor an object-oriented database system designed for
Author: B. Liskov, A. Adya, M. Castro, M. Day S. Ghemawat R. Gruber U. Maheshwari, A. C. Myers, L. Shrira 
Note: Thor is  
Address: 545 Technology Square, Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science, Massachusetts Institute of Technology,  
Abstract: This paper appears in Proceedings of the 1996 ACM SIGMOD Int. Conf. on Management of Data, Montreal, Canada, June 1996. Note: the pages are numbered 318-329, as in the proceedings. Abstract This paper gives an overview of Thor's design and implementation. We focus on two areas that set Thor apart from other object-oriented databases. First, we discuss safe sharing and techniques for ensuring it; we also discuss ways of improving application performance without sacrificing safety. Second, we describe our approach to cache management at client machines, including a novel adaptive prefetching strategy. The paper presents performance results for Thor, on several OO7 benchmark traversals. The results show that adaptive prefetching is very effective, improving both the elapsed time of traversals and the amount of space used in the client cache. The results also show that the cost of safe sharing can be negligible; thus it is possible to have both safety and high performance. 
Abstract-found: 1
Intro-found: 1
Reference: [AGLM95] <author> A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. </author> <title> Efficient optimistic concurrency control using loosely synchronized clocks. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: This lazy swizzling allows us to minimize the cost for prefetching an object that is not used and reduce the number of surrogates. Transactions. We use an optimistic concurrency control scheme <ref> [AGLM95] </ref>. As a transaction runs, the FE keeps track of which objects it reads and modifies. <p> Modified objects are unswizzled before being sent. While doing unswizzling, the FE may discover pointers to volatile objects that are being made persistent by the transaction; the FE sends them to the ORs as well. The ORs then validate the transaction <ref> [AGLM95] </ref>.
Reference: [Bak78] <author> Henry Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> CACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: In a page cache, available memory is divided into page-sized slots, allowing a new page to overwrite an old one. Objects are of variable size and require more complex memory management. The Thor 0 implementation uses a variant of copying garbage collection <ref> [Bak78] </ref> to manage the cache. The FE reads an arriving prefetch group into the beginning of free space. When free space runs low, some persistent objects are evicted from the cache, followed by a copying collection. The collection compacts storage to provide enough contiguous space for incoming prefetch groups.
Reference: [BL94] <author> Philip Bogle and Barbara Liskov. </author> <title> Reducing cross domain call overhead using batched futures. </title> <booktitle> In OOPSLA '94, </booktitle> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: We have defined veneers for C, C++, Perl, Tcl, and Java, none of which required compiler modifications. The existing veneers show that object-oriented features can be mapped easily to languages lacking objects. More information about veneers is available <ref> [BL94] </ref>. 3 Type-safe Sharing Type-safe sharing provides two important properties. First, because objects can be manipulated only by their methods, users can focus on how objects behave rather than how 320 they are implemented. <p> Batching reduces total execution time by grouping calls into batches and making a single domain crossing for each batch, amortizing the domain-crossing penalty over all calls in the batch. We have studied batching of straight-line code <ref> [BL94] </ref> and loops [Zon95]; the latter is especially promising since it allows large batches and reduces the overhead of dynamic type checking: each call in the loop is checked just once, although the loop body may execute many times. 321 Code transfer moves a portion of the application into the database.
Reference: [BOS91] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The GemStone database management system. </title> <journal> CACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Type checking is needed since stub code can be corrupted or bypassed. Thor ensures legitimacy of object references by checking the validity of handles and by managing the persistent heap with a garbage collector. Other systems do not provide safe sharing. O2 [D + 90] and GemStone <ref> [BOS91] </ref> store methods in the database. However, the languages provided by O2 for method definition are not safe (for example, one of these languages is an extension of C).
Reference: [C + 89] <author> M. Carey et al. </author> <title> Storage management for objects in EXODUS. </title> <editor> In W. Kim and F. Lochovsky, editors, </editor> <title> Object-Oriented Concepts, Databases, and Applications. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The details of our scheme, including support for object migration, are available [DLMM94]. Using xrefs for object addressing at the FE cache would be expensive because each object use would require a table lookup. Like many other systems <ref> [SKW92, C + 89] </ref>, we swizzle xrefs, replacing them with local addresses. Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses. <p> The traversals were run in an isolated network; we report the average of the elapsed times obtained in 10 runs of each traversal. The standard deviation was always below 2% of the reported value. To put our performance in perspective, we compare our results with results for E/EXODUS <ref> [RCS93, C + 89] </ref>. We selected this system because it has the best overall performance among the database systems evaluated in [CDN94]. E/EXODUS is a page-based client-server system that uses 8 KB pages as the unit of cache management, network transfer and disk transfer.
Reference: [Cat94] <author> Richard G.G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Safe sharing requires that someone write the definitions and implementations of persistent object types in the database language (e.g., Theta). Writing type definitions is similar to what other systems require (for example, we could translate ODMG descriptions <ref> [Cat94] </ref> to Theta), but writing implementations is more work. However, extra work is needed only when an entire application is written in one application language and does not share its objects with applications written in other languages. <p> Code transfer effectively increases the granularity of application calls. Queries are a code transfer technique; here we are interested in other kinds of code transfers that cannot be expressed in a query language such as OQL <ref> [Cat94] </ref> or extended SQL [SQL92]. We cannot move a procedure written in an unsafe language into the database.
Reference: [CDF + 94] <author> Michael J. Carey, David J. DeWitt, Michael J. Franklin, Nancy E. Hall, Mark L. McAuliffe, Jef-frey F. Naughton, Daniel T. Schuh, Marvin H. Solomon, C. K. Tan, Odysseas G. Tsatalos, Seth J. White, and Michael J. Zwilling. </author> <title> Shoring up persistent applications. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: However, GemStone exports an unsafe interface to client applications that allows direct access to an object's internal state. Other object-oriented systems, e.g., SHORE <ref> [CDF + 94] </ref> and ObjectStore [LLOW91], do not store methods in the database. Instead, applications compile or link against appropriate method code that is stored outside the database system. This approach is fragile: it works only if the right version of the method code is linked in. <p> Our technique is better: it adapts over time, uses a wide range of possible prefetch group sizes, and does not require programmer involvement. Some systems, such as SHORE <ref> [CDF + 94] </ref> and a system described by Kemper/Kossman [KK94], use a dual caching scheme, in which pages are fetched into a page cache, and objects are then copied into an object cache.
Reference: [CDN93] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washing-ton, DC, </address> <month> May </month> <year> 1993. </year> <note> WWW users: see URL ftp://ftp.cs.wisc.edu/OO7. </note>
Reference-contexts: We also present some performance results (and their analyses) for our initial prototype, Thor 0, run on several OO7 benchmark traversals <ref> [CDN93] </ref>. The results show that Thor does well on these benchmarks, and that adaptive prefetching is very effective, reducing both the elapsed time of traversals and the amount of space used in the client cache. <p> The OR also weeds out objects over some threshold size (at present the threshold is 800 bytes); such big objects are sent only in response to explicit fetch requests. 6 Performance Studies This section shows how Thor 0 performs on OO7 traversals <ref> [CDN93] </ref> for the small and medium databases. We also present results comparing adaptive prefetching to fixed-size techniques such as page fetching. <p> The FE cache was 12 MB. The OR cache was 36 MB, of which 6 MB were used for the mcache. We used 28.5 KB segments (one track on our disk). The experiments ran the single-user OO7 benchmark <ref> [CDN93] </ref>. The OO7 database contains a tree of assembly objects, with leaves pointing to three composite parts chosen randomly from among 500 such objects. Each composite part contains a graph of atomic parts linked by connection objects; each atomic part has 3 outgoing connections.
Reference: [CDN94] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <type> Technical Report; Revised Version dated 7/21/1994 1140, </type> <institution> University of 328 Wisconsin-Madison, </institution> <year> 1994. </year> <note> WWW users: see URL ftp://ftp.cs.wisc.edu/OO7. </note>
Reference-contexts: The small database has 20 atomic parts per composite part; the medium has 200. The total size is 6.7 MB for the small database and 62.9 MB for the medium database. We implemented the database in Theta, following the specification <ref> [CDN94] </ref> closely. <p> There are 110 transactions. The overhead introduced by having multiple transactions is bounded by the total commit overhead which is less than 10% for these traversals. The code was compiled with DEC's CXX and CC compilers with optimization flag -O2. Our experiments followed the methodology in <ref> [CDN94] </ref>. Hot traversals run five times within a single transaction starting with cold FE and OR caches; the elapsed time is the average of the middle runs, so that start up costs and commit times are excluded (but concurrency control costs are included). <p> The standard deviation was always below 2% of the reported value. To put our performance in perspective, we compare our results with results for E/EXODUS [RCS93, C + 89]. We selected this system because it has the best overall performance among the database systems evaluated in <ref> [CDN94] </ref>. E/EXODUS is a page-based client-server system that uses 8 KB pages as the unit of cache management, network transfer and disk transfer.
Reference: [D + 90] <editor> O Deux et al. </editor> <title> The story of O2. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Type checking is needed since stub code can be corrupted or bypassed. Thor ensures legitimacy of object references by checking the validity of handles and by managing the persistent heap with a garbage collector. Other systems do not provide safe sharing. O2 <ref> [D + 90] </ref> and GemStone [BOS91] store methods in the database. However, the languages provided by O2 for method definition are not safe (for example, one of these languages is an extension of C). <p> Thus we adapt minimizing the amount of cache space wasted and reducing network communication overheads. Others have developed caching schemes that are similar to ours in some respects. Some systems (e.g., <ref> [Ont92, D + 90] </ref>) fetch and discard objects, but none has an adaptive prefetching algorithm. Ontos [Ont92] allows the user to specify at object creation time whether object-based or page-based fetching should be used for the new object.
Reference: [Day95] <author> Mark Day. </author> <title> Client cache management in a distributed object database. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses. A number of studies have compared various approaches to swizzling and object fault detection; e.g., see <ref> [Day95, Mos92, HM93, WD92] </ref>. Thor 0 uses a form of node marking. All the references in an object are swizzled at once. <p> In response to a fetch request for a particular object, the OR sends the entire group that contains the requested object. (Earlier we used a policy that determined the prefetch group based on the structure of the object graph <ref> [Day95] </ref>. This policy was discarded because it often generated very small prefetch groups near the fringes of the object graph. Furthermore, the traversal of the object graph added a non-trivial run-time cost to the OR.) We vary the requested group size k dynamically to improve the effectiveness of prefetching.
Reference: [DGLM95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In OOPSLA '95, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: yet support queries, although we have studied support for efficient queries [Hwa94].) objects and code remain inside Thor; this is an important way in which Thor differs from other systems. 2.1 Defining and Implementing Object Types Object types are defined and implemented in Theta, a new, general-purpose object-oriented programming language <ref> [DGLM95, LCD + 94] </ref>. Although Theta can be used separately from Thor, it was developed to support the type-safe sharing requirement of Thor. Theta is a strongly-typed language.
Reference: [DLMM94] <author> Mark Day, Barbara Liskov, Umesh Maheshwari, and Andrew C. Myers. </author> <title> References to remote mobile objects in Thor. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <month> March </month> <year> 1994. </year>
Reference-contexts: An xref is a pair, containing the id of an OR and some OR-dependent information. With a location-dependent name, an FE can easily determine from which OR to fetch an object. The details of our scheme, including support for object migration, are available <ref> [DLMM94] </ref>. Using xrefs for object addressing at the FE cache would be expensive because each object use would require a table lookup. Like many other systems [SKW92, C + 89], we swizzle xrefs, replacing them with local addresses.
Reference: [Ghe95] <author> S. Ghemawat. </author> <title> The Modified Object Buffer: a Storage Manamement Technique for Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: This approach provides stability at a lower cost than writing the log to disk [LGG + 91], and in addition provides highly-available object storage. We keep new versions of modified objects in a volatile modified object cache (mcache) <ref> [Ghe95] </ref>. This has several advantages over the modified page cache that is used in other systems. First, the mcache allows us to ship objects rather than pages to ORs at transaction commit, making commit messages smaller. Second, we need not do installation reads [OS94] at commit time. <p> The good performance for T2b is due to other parts of the Thor 0 implementation: it costs less to write to the backup as in [LGG + 91] than to force the log to disk at commit, plus our disk management at the server is very effective <ref> [Ghe95] </ref>. 7 Conclusions In this paper, we described the interface and implementation of Thor, a new object-oriented database developed for use in heterogeneous distributed systems. We presented two novel aspects of Thor: its support for type-safe heterogeneous sharing, and its client cache management.
Reference: [HM93] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Protection traps and alteratives for memory management of an object-oriented language. </title> <booktitle> In 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 106-119, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses. A number of studies have compared various approaches to swizzling and object fault detection; e.g., see <ref> [Day95, Mos92, HM93, WD92] </ref>. Thor 0 uses a form of node marking. All the references in an object are swizzled at once. <p> to an object not present in the cache, we create a surrogate, a small object that contains the xref of the missing object; the pointer is swizzled to point to the surrogate, and an entry is made for the surrogate in the ROT. (Our surrogates are similar to fault blocks <ref> [HM93] </ref>.) Fetching occurs when an attempt is made to use a surrogate; if the object named by the xref in the surrogate is not yet at the FE, the FE sends a fetch request to the OR requesting the object identified by the xref.
Reference: [Hwa94] <author> Deborah J. Hwang. </author> <title> Function-Based Indexing for Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Each server root is a directory object that maps strings to objects, which allows applications to locate their data. Objects of interest can be found by navigation or queries. (Thor does not yet support queries, although we have studied support for efficient queries <ref> [Hwa94] </ref>.) objects and code remain inside Thor; this is an important way in which Thor differs from other systems. 2.1 Defining and Implementing Object Types Object types are defined and implemented in Theta, a new, general-purpose object-oriented programming language [DGLM95, LCD + 94].
Reference: [KK94] <author> Alfons Kemper and Donald Kossmann. </author> <title> Dual-buffer strategies in object bases. </title> <booktitle> In 20th Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: Our technique is better: it adapts over time, uses a wide range of possible prefetch group sizes, and does not require programmer involvement. Some systems, such as SHORE [CDF + 94] and a system described by Kemper/Kossman <ref> [KK94] </ref>, use a dual caching scheme, in which pages are fetched into a page cache, and objects are then copied into an object cache.
Reference: [LACZ] <author> B. Liskov, A. Adya, M. Castro, and Q. Zondervan. </author> <title> Type-safe heterogeneous sharing can be fast. </title> <note> Submitted for publication. </note>
Reference-contexts: These requirements add a substantial cost to short calls (but not to long ones, such as queries). This section briefly discusses three ways to reduce this cost: batching, code transfer, and sandboxing; we have performed a more detailed performance study <ref> [LACZ] </ref>. Batching reduces total execution time by grouping calls into batches and making a single domain crossing for each batch, amortizing the domain-crossing penalty over all calls in the batch. <p> However, every call made from the sandboxed code to the database methods must still be type checked. Since the code transfer technique reduces the number of type-checked calls, sandboxing cannot perform as well as code transfer. Our performance studies indicate that code transfer techniques <ref> [LACZ] </ref> offer the best performance. The performance studies presented in this paper are based on code transfer; our benchmark code was written in Theta. 4 System Architecture Thor has the client/server architecture illustrated in Figure 4. Persistent objects are stored at servers called ORs (object repositories).
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gruber, Paul Johnson, and An-drew C. Myers. </author> <title> Theta reference manual. Programming Methodology Group Memo 88, </title> <institution> MIT Lab. for Computer Science, </institution> <month> February </month> <year> 1994. </year> <note> Also available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: Type-safe sharing requires that code uses objects only by calling their methods. A combination of techniques ensures type-safe sharing. Thor stores objects with their methods, and methods are implemented in Theta <ref> [LCD + 94] </ref>, a new, statically-typed programming language that enforces strict encapsulation. When client code is written in an unsafe language, Thor runs it in a separate protection domain. Finally, Theta and Thor provide automatic memory management and therefore avoid dangling references. <p> yet support queries, although we have studied support for efficient queries [Hwa94].) objects and code remain inside Thor; this is an important way in which Thor differs from other systems. 2.1 Defining and Implementing Object Types Object types are defined and implemented in Theta, a new, general-purpose object-oriented programming language <ref> [DGLM95, LCD + 94] </ref>. Although Theta can be used separately from Thor, it was developed to support the type-safe sharing requirement of Thor. Theta is a strongly-typed language.
Reference: [LGG + 91] <author> Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. </author> <title> Replication in the Harp file system. </title> <booktitle> In 13th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 226-238, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: To achieve high availability, each OR is replicated at a number of server machines and its objects have copies stored at these servers. We plan to use a primary/backup replication scheme as in the Harp file system <ref> [LGG + 91] </ref>, but replication is not yet implemented. An application interacts with Thor through a component called the FE (front end), which is created when an application starts a session. <p> Our log is not normally kept on disk; instead, it is kept in primary memory at two servers, a primary and a backup, as in Harp <ref> [LGG + 91] </ref>. The primary and backup each have an uninterruptible power supply that allows them to write the log to disk in the case of a power failure. This approach provides stability at a lower cost than writing the log to disk [LGG + 91], and in addition provides highly-available <p> primary and a backup, as in Harp <ref> [LGG + 91] </ref>. The primary and backup each have an uninterruptible power supply that allows them to write the log to disk in the case of a power failure. This approach provides stability at a lower cost than writing the log to disk [LGG + 91], and in addition provides highly-available object storage. We keep new versions of modified objects in a volatile modified object cache (mcache) [Ghe95]. This has several advantages over the modified page cache that is used in other systems. <p> The good performance for T2b is due to other parts of the Thor 0 implementation: it costs less to write to the backup as in <ref> [LGG + 91] </ref> than to force the log to disk at commit, plus our disk management at the server is very effective [Ghe95]. 7 Conclusions In this paper, we described the interface and implementation of Thor, a new object-oriented database developed for use in heterogeneous distributed systems.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> CACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: However, GemStone exports an unsafe interface to client applications that allows direct access to an object's internal state. Other object-oriented systems, e.g., SHORE [CDF + 94] and ObjectStore <ref> [LLOW91] </ref>, do not store methods in the database. Instead, applications compile or link against appropriate method code that is stored outside the database system. This approach is fragile: it works only if the right version of the method code is linked in.
Reference: [LSAS77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> CACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: Note that methods can be both procedures and iterators (an iterator yields a sequence of results one at a time <ref> [LSAS77] </ref>), and that calls can either return normally or signal an exception.
Reference: [ML94] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-tolerant dis tributed garbage collection in a client-server, object-oriented database. </title> <booktitle> In Third PDIS Conference, </booktitle> <pages> pages 239-248, </pages> <address> Austin, TX, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: When an object becomes inaccessible from the roots, and also inaccessible from the handles of all current sessions, its storage is reclaimed automatically by the garbage collector <ref> [ML94, ML95] </ref>.
Reference: [ML95] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Collecting cyclic distributed garbage by controlled migration. </title> <booktitle> In 14th ACM Symp. on Principles of Dist. Computing, </booktitle> <pages> pages 57-63, </pages> <address> Ottawa, Canada, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: When an object becomes inaccessible from the roots, and also inaccessible from the handles of all current sessions, its storage is reclaimed automatically by the garbage collector <ref> [ML94, ML95] </ref>.
Reference: [Mos92] <author> J. Eliot B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(3), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses. A number of studies have compared various approaches to swizzling and object fault detection; e.g., see <ref> [Day95, Mos92, HM93, WD92] </ref>. Thor 0 uses a form of node marking. All the references in an object are swizzled at once.
Reference: [OMG91] <author> OMG. </author> <title> The Common Object Request Broker: Archi tecture and Specification, </title> <month> December </month> <year> 1991. </year> <title> OMG TC Document Number 91.12.1, Revision 1.1. </title>
Reference-contexts: In fact, the need to write the methods in various languages is an impediment to heterogeneous sharing; an approach with a database language, on the other hand, encourages heterogeneous sharing. In CORBA <ref> [OMG91] </ref>, objects implemented in different programming languages can call one another.
Reference: [Ont92] <author> Ontos. Inc. </author> <title> Ontos reference manual, </title> <year> 1992. </year>
Reference-contexts: Thus we adapt minimizing the amount of cache space wasted and reducing network communication overheads. Others have developed caching schemes that are similar to ours in some respects. Some systems (e.g., <ref> [Ont92, D + 90] </ref>) fetch and discard objects, but none has an adaptive prefetching algorithm. Ontos [Ont92] allows the user to specify at object creation time whether object-based or page-based fetching should be used for the new object. <p> Thus we adapt minimizing the amount of cache space wasted and reducing network communication overheads. Others have developed caching schemes that are similar to ours in some respects. Some systems (e.g., [Ont92, D + 90]) fetch and discard objects, but none has an adaptive prefetching algorithm. Ontos <ref> [Ont92] </ref> allows the user to specify at object creation time whether object-based or page-based fetching should be used for the new object. Our technique is better: it adapts over time, uses a wide range of possible prefetch group sizes, and does not require programmer involvement.
Reference: [OS94] <author> James O'Toole and Liuba Shrira. </author> <title> Opportunistic Log: Efficient Installation Reads in a Reliable Object Server. </title> <booktitle> In Proceedings of OSDI, </booktitle> <year> 1994. </year>
Reference-contexts: This has several advantages over the modified page cache that is used in other systems. First, the mcache allows us to ship objects rather than pages to ORs at transaction commit, making commit messages smaller. Second, we need not do installation reads <ref> [OS94] </ref> at commit time. Third, we can store many more modified objects in the mcache than modified pages in a page cache of the same size the cache can absorb more writes, reducing the I/O needed to record new object states onto disk.
Reference: [RCS93] <author> J. Richardson, M. Carey, and D. Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(3), </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: The traversals were run in an isolated network; we report the average of the elapsed times obtained in 10 runs of each traversal. The standard deviation was always below 2% of the reported value. To put our performance in perspective, we compare our results with results for E/EXODUS <ref> [RCS93, C + 89] </ref>. We selected this system because it has the best overall performance among the database systems evaluated in [CDN94]. E/EXODUS is a page-based client-server system that uses 8 KB pages as the unit of cache management, network transfer and disk transfer.
Reference: [SKW92] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas: An efficient, portable persistent store. </title> <booktitle> In 5th Int'l Workshop on Persistent Object Systems, </booktitle> <address> San Miniato, Italy, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: The details of our scheme, including support for object migration, are available [DLMM94]. Using xrefs for object addressing at the FE cache would be expensive because each object use would require a table lookup. Like many other systems <ref> [SKW92, C + 89] </ref>, we swizzle xrefs, replacing them with local addresses. Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses.
Reference: [SQL92] <institution> American National Standards Institute, </institution> <address> New York, NY. </address> <booktitle> Database Language SQL, </booktitle> <address> ANSI X3.135-1992 edition, </address> <year> 1992. </year>
Reference-contexts: Code transfer effectively increases the granularity of application calls. Queries are a code transfer technique; here we are interested in other kinds of code transfers that cannot be expressed in a query language such as OQL [Cat94] or extended SQL <ref> [SQL92] </ref>. We cannot move a procedure written in an unsafe language into the database. Safe ways of transferring code include writing the procedure in the database language (Theta), translating application subroutines into the database language, and translating application subroutines to type-safe intermediate code such as Java bytecodes [Sun95].
Reference: [Sun95] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification, release 1.0 beta edition, </title> <month> August </month> <year> 1995. </year> <note> http://ftp.javasoft.com/docs/ javaspec.ps.tar.Z. </note>
Reference-contexts: We cannot move a procedure written in an unsafe language into the database. Safe ways of transferring code include writing the procedure in the database language (Theta), translating application subroutines into the database language, and translating application subroutines to type-safe intermediate code such as Java bytecodes <ref> [Sun95] </ref>. The latter approach is particularly promising since translators from various application languages to Java may be common in the future. The Java code could either be verified and then run inside Thor, or it could be compiled to Theta.
Reference: [TN92] <author> Manolis M. Tsangaris and Jeffrey F. Naughton. </author> <title> On the performance of object clustering techniques. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 144-153, </pages> <address> California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Typically, many objects are stored on each disk page. Even when objects are well-clustered on disk pages, no single clustering matches all uses <ref> [TN92] </ref>. A page cache works well when clustering matches usage, but wastes storage when it doesn't. It also wastes network bandwidth by sending unwanted objects; although this cost may not be large for the future LANs, it will still be significant for WANs (and wireless networks).
Reference: [WD92] <author> S. White and D. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In 18th Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Swizzling is accomplished using a resident object table (ROT) that maps the xrefs of resident objects to their local addresses. A number of studies have compared various approaches to swizzling and object fault detection; e.g., see <ref> [Day95, Mos92, HM93, WD92] </ref>. Thor 0 uses a form of node marking. All the references in an object are swizzled at once.
Reference: [WD94] <author> Seth J. White and David J. DeWitt. </author> <title> QuickStore: A high performance mapped object store. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: We selected this system because it has the best overall performance among the database systems evaluated in [CDN94]. E/EXODUS is a page-based client-server system that uses 8 KB pages as the unit of cache management, network transfer and disk transfer. We use results for E/EXODUS taken from <ref> [WD94] </ref>; these results were obtained using a Sun IPX workstation for the server and a Sun ELC workstation for the client, connected by a 10 MB/s Ethernet. <p> As pointed out in <ref> [WD94] </ref>, one of the reasons E/EXODUS does poorly on T1 and T6 is because it 325 spends a significant amount of time executing system code to dereference unswizzled pointers.
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The latter approach is particularly promising since translators from various application languages to Java may be common in the future. The Java code could either be verified and then run inside Thor, or it could be compiled to Theta. In the sandboxing <ref> [WLAG93] </ref> approach, (unsafe) application code/data is placed inside the database but allowed to access only a restricted range of virtual memory addresses. The restriction is enforced by inexpensive runtime checks. However, every call made from the sandboxed code to the database methods must still be type checked.
Reference: [Zon95] <author> Quinton Zondervan. </author> <title> Increasing cross-domain call batching using promises and batched control structures. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1995. </year> <note> A couple of useful WWW URL's: OO7 papers and technical reports: ftp://ftp.cs.wisc.edu/OO7 Other Thor papers: http://www.pmg.lcs.mit.edu/Thor-papers.html 329 </note>
Reference-contexts: Batching reduces total execution time by grouping calls into batches and making a single domain crossing for each batch, amortizing the domain-crossing penalty over all calls in the batch. We have studied batching of straight-line code [BL94] and loops <ref> [Zon95] </ref>; the latter is especially promising since it allows large batches and reduces the overhead of dynamic type checking: each call in the loop is checked just once, although the loop body may execute many times. 321 Code transfer moves a portion of the application into the database.
References-found: 37

