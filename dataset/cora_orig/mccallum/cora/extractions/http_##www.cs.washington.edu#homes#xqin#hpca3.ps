URL: http://www.cs.washington.edu/homes/xqin/hpca3.ps
Refering-URL: http://www.cs.washington.edu/homes/baer/
Root-URL: 
Email: fxqin,baerg@cs.washington.edu  
Title: On the Use and Performance of Explicit Communication Primitives in Cache-coherent Multiprocessor Systems  
Author: Xiaohan Qin and Jean-Loup Baer 
Address: Seattle, WA 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: software to implement cache coherence policies. The exposure of communication mechanisms to software opens many opportunities for enhancing application performance. In this paper we propose a set of communication primitives implemented on a communication co-processor that introduce a flavor of message passing and permit protocol optimization. To assess the overhead of the software implementation of the primitives and protocols, we compare a PRAM model, a hardware cache coherence scheme, a software scheme implementing only the basic cache coherence protocol, and an optimized software solution supporting the additional communication primitives and running with applications annotated with those primitives. With the parameters we chose for the communication processor, the overall memory system overhead of the basic software scheme is at least 50% higher than that of the hardware implementation. With the adequate insertion of the communication primitives, the optimized software solution has a performance comparable to that of the hardware scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Agarwal, D. Kranz B.-H. Lim, and J. Ku-biatowicz. </author> <month> APRIL: </month> <title> a processor architecture for multiprocessing. </title> <booktitle> In Proc. of 17th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 104-114, </pages> <year> 1990. </year>
Reference: [2] <author> V. Bala et al. </author> <title> The IBM external user interface for scalable parallel systems. </title> <journal> Parallel Computing, </journal> <volume> 20(4) </volume> <pages> 445-462, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Since our interest was mainly on performance related issues, we have concentrated on the latter, imposing a global coherence strategy for prefetching and bulk data transfers. The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces <ref> [2, 21] </ref>, prefetching [20, 4, 11] and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [3] <author> L. M. Censier and P. Feautrier. </author> <title> A new solution to coherence problems in multicache systems. </title> <journal> IEE Trans. on Computers, </journal> <volume> c-27(12):1112-1118, </volume> <month> Dec. </month> <year> 1978. </year>
Reference: [4] <author> T.-F. Chen and J.-L. Baer. </author> <title> A performance study of software and hardware data prefetching schemes. </title> <booktitle> In Proc. the 21st Annual Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 223-32, </pages> <year> 1994. </year>
Reference-contexts: The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching <ref> [20, 4, 11] </ref> and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [5] <author> T. M. Chilimbi and J. R. Larus. Cachier: </author> <title> A tool for automatically inserting cico annotations. </title> <booktitle> In Proc. of Int. Conf. on Parallel Processing, </booktitle> <pages> pages 89-98, </pages> <year> 1994. </year>
Reference: [6] <author> A. L. Cox and R. J. Fowler. </author> <title> Adaptive cache coherency for detecting migratory shared data. </title> <booktitle> In Proc. of 20th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 98-108, </pages> <year> 1993. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level [10] or in incremental fashion [14], can be dictated by the compiler [22, 8], or can be the result of hardware monitoring <ref> [6, 25] </ref>.
Reference: [7] <editor> D. E. Culler et al. </editor> <booktitle> Parallel programming in Split-C. In Proc. Supercomputing '93, </booktitle> <pages> pages 262-73, </pages> <year> 1993. </year>
Reference-contexts: The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching [20, 4, 11] and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C <ref> [7] </ref>, and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [8] <author> R. Cytron, S. Karlovsky, and K. P. McAuliffe. </author> <title> Automatic management of programmable caches. </title> <booktitle> In Proc. of Int. Conf. on Parallel Processing, </booktitle> <pages> pages 229-238, </pages> <year> 1988. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level [10] or in incremental fashion [14], can be dictated by the compiler <ref> [22, 8] </ref>, or can be the result of hardware monitoring [6, 25].
Reference: [9] <author> S. Eggers and R. Katz. </author> <title> A characterization of sharing in parallel programs and its application to coherency protocol evaluation. </title> <booktitle> In Proc. of 15th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 373-382, </pages> <year> 1988. </year>
Reference: [10] <author> B. Falsafi et al. </author> <title> Application-specific protocols for user-level shared memory. </title> <booktitle> In Proc. of Supercomputing '94, </booktitle> <pages> pages 380-9, </pages> <year> 1994. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level <ref> [10] </ref> or in incremental fashion [14], can be dictated by the compiler [22, 8], or can be the result of hardware monitoring [6, 25].
Reference: [11] <author> E. Gornish, E. Granston, and A. Veidenbaum. </author> <title> Compiler-directed data prefetching in multiprocessor with memory hierarchies. </title> <booktitle> In Proc. of Int. Conf. on Supercomputing, </booktitle> <pages> pages 354-368, </pages> <year> 1990. </year>
Reference-contexts: The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching <ref> [20, 4, 11] </ref> and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [12] <author> J. Heinlein, K. Gharachorloo, S. Dresser, and A. Gupta. </author> <title> Integration of message passing and shared memory in the Stanford FLASH multiprocessor. </title> <booktitle> In Proc. of 6th Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 38-50, </pages> <year> 1994. </year>
Reference-contexts: Combining message passing with shared memory to overcome some of the inefficiencies of cache coherence mechanisms was first proposed in the context of the Alewife project [17, 18] and further elaborated in Flash <ref> [12] </ref>. A number of important issues have been raised and discussed, e.g., user-level messaging and protection, and coherence strategy for bulk data transferring. Since our interest was mainly on performance related issues, we have concentrated on the latter, imposing a global coherence strategy for prefetching and bulk data transfers.
Reference: [13] <author> M. Heinrich et al. </author> <title> The performance impact of flexibility in the Stanford FLASH multiprocessor. </title> <booktitle> In Proc. of 6th Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 274-285, </pages> <year> 1994. </year>
Reference: [14] <author> M. Hill, J. Larus, S. Reinhardt, and D. Wood. </author> <title> Cooperative shared memory: software and hardware for scalable multiprocessors. </title> <booktitle> In Proc. of 5th Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 262-273, </pages> <year> 1992. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level [10] or in incremental fashion <ref> [14] </ref>, can be dictated by the compiler [22, 8], or can be the result of hardware monitoring [6, 25].
Reference: [15] <institution> Intel Corporation. Intel Paragon(tm) Supercomputer Product Brochure. </institution> <note> http://www.ssd.intel.com/paragon.html#system. </note>
Reference-contexts: introduction of new primitives or changes in the protocols, and closer to what is available off-the-shelf, but the software overhead is of the order of 50%. The use of dedicated communication hardware can also be found in tightly-coupled message-passing systems such as the Intel Paragon <ref> [15] </ref> and has been proposed for networks of workstations [24]. Combining message passing with shared memory to overcome some of the inefficiencies of cache coherence mechanisms was first proposed in the context of the Alewife project [17, 18] and further elaborated in Flash [12].
Reference: [16] <institution> Kendall Square Research Corporation. </institution> <type> KSR1 technical summary, </type> <year> 1992. </year>
Reference-contexts: The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching [20, 4, 11] and poststore <ref> [16] </ref> commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [17] <author> D. Kranz, K. Johnson, A. Agarwal, J. Kubiatow-icz, and B.H. Lim. </author> <title> Integrating message-passing and shared-memory: early experience. </title> <booktitle> In Proc. of 4th ACM Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 54-63, </pages> <year> 1993. </year>
Reference-contexts: Combining message passing with shared memory to overcome some of the inefficiencies of cache coherence mechanisms was first proposed in the context of the Alewife project <ref> [17, 18] </ref> and further elaborated in Flash [12]. A number of important issues have been raised and discussed, e.g., user-level messaging and protection, and coherence strategy for bulk data transferring.
Reference: [18] <author> J. Kubiatowicz and A. Agarwal. </author> <title> Anatomy of a message in the Alewife multiprocessor. </title> <booktitle> In Proc. of 7th ACM Int. Conf. on Supercomputing, </booktitle> <year> 1993. </year>
Reference-contexts: Combining message passing with shared memory to overcome some of the inefficiencies of cache coherence mechanisms was first proposed in the context of the Alewife project <ref> [17, 18] </ref> and further elaborated in Flash [12]. A number of important issues have been raised and discussed, e.g., user-level messaging and protection, and coherence strategy for bulk data transferring.
Reference: [19] <author> J. Kuskin et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In Proc. of 21st Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 302-313, </pages> <year> 1994. </year>
Reference: [20] <author> D. Lenoski et al. </author> <title> The Standford DASH multiprocessor. </title> <journal> IEEE Trans. on Computer, </journal> <volume> 25(3) </volume> <pages> 63-79, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching <ref> [20, 4, 11] </ref> and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [21] <author> P. Pierce. </author> <title> The NX message passing interface. </title> <journal> Parallel Computing, </journal> <volume> 20(4) </volume> <pages> 463-480, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Since our interest was mainly on performance related issues, we have concentrated on the latter, imposing a global coherence strategy for prefetching and bulk data transfers. The communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces <ref> [2, 21] </ref>, prefetching [20, 4, 11] and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms [23]. The common idea is the overlap of communication with computation.
Reference: [22] <author> D. K. Poulsend and P.-C. Yew. </author> <title> Integrating fine-grained message passing in cache coherent shared memory multiprocessors. </title> <journal> J. of Parallel and Distributed Computing, </journal> <volume> 33(2) </volume> <pages> 172-188, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level [10] or in incremental fashion [14], can be dictated by the compiler <ref> [22, 8] </ref>, or can be the result of hardware monitoring [6, 25].
Reference: [23] <author> U. Ramachandran, G. Shah, A. Sivasubrama-niam, A. Singla, and I Yanasak. </author> <title> Architectural mechanisms for explicit communication in shared memory multiprocessors. </title> <booktitle> In Proc. of Supercomputing '95, </booktitle> <year> 1995. </year>
Reference-contexts: communication primitives that instruct the system to perform efficient data transfers resemble the asynchronous send/receive operations in message passing interfaces [2, 21], prefetching [20, 4, 11] and poststore [16] commands, non-blocking (bulk) read (get) and write (put) operations in the split-phase assignment statement of Split-C [7], and explicit communication mechanisms <ref> [23] </ref>. The common idea is the overlap of communication with computation.
Reference: [24] <author> S. K. Reinhardt, R. W. Pfile, and D. A. Wood. </author> <title> Decoupled hardware support for distributed shared memory. </title> <booktitle> In Proc. of 24th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 34-43, </pages> <year> 1996. </year>
Reference-contexts: The use of dedicated communication hardware can also be found in tightly-coupled message-passing systems such as the Intel Paragon [15] and has been proposed for networks of workstations <ref> [24] </ref>. Combining message passing with shared memory to overcome some of the inefficiencies of cache coherence mechanisms was first proposed in the context of the Alewife project [17, 18] and further elaborated in Flash [12].
Reference: [25] <author> P. Strenstrom, M. Brorsson, and L. Sandberg. </author> <title> An adaptive cache coherence protocol optimized for migratory sharing. </title> <booktitle> In Proc. of 20th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 109-118, </pages> <year> 1993. </year>
Reference-contexts: Tailoring the coherence protocol to the application can be done in several ways. Protocol modifications can be specified by the user at a coarse grain level [10] or in incremental fashion [14], can be dictated by the compiler [22, 8], or can be the result of hardware monitoring <ref> [6, 25] </ref>.
Reference: [26] <author> J. E. Veenstra and R. J. Fowler. MINT: </author> <title> a front end for efficient simulation of shared-memory multiprocessors. </title> <booktitle> In Proc. of the Second Int. Workshop on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems, </booktitle> <pages> pages 201-7, </pages> <year> 1994. </year>
Reference: [27] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, and K. K. Schauser. </author> <title> Active messages: a mechanism for intergrated communication and computation. </title> <booktitle> In Proc. of 19th Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 256-66, </pages> <year> 1992. </year>
Reference: [28] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta. </author> <title> The SPLASH-2 programs: Characterization and methodological considerations. </title> <booktitle> In Proc. of 22nd Int. Symp. on Comp. Architecture, </booktitle> <pages> pages 24-36, </pages> <year> 1995. </year>
Reference: [29] <author> S. C. Woo, J. P. Singh, and J. L. Hennessy. </author> <title> The performance advantages of integrating block data transfer in cache-coherent multiprocessors. </title> <booktitle> In Proc. of 6th Int. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 219-229, </pages> <year> 1994. </year>
References-found: 29

