URL: ftp://ftp.cm.deakin.edu.au/pub/TR/Computing/TR-C94-17.ps.gz
Refering-URL: http://gollum.cm.deakin.edu.au/techreports.html
Root-URL: 
Title: A Survey of Tools for the Development and Maintenance of Programs.  
Author: Timothy Jones Peter Horan 
Date: August 11, 1994  
Address: 4072  Geelong, Victoria, 3217  
Affiliation: Software Verification Research Centre, Department of Computing Science, University of Queensland, St. Lucia, QLD,  School of Computing and Mathematics, Deakin University,  
Pubnum: Technical Report C94/17  
Abstract: In this report is a survey of tools required for the implementation and maintenance of software. The need to develop code of high quality means that the programmer must have a range of development and maintenance tools for the generation of code and its static and dynamic analysis. Individual tools as well as integrated environments supplying a range of coordinated tools are covered. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> 6 Bibliography </institution>
Reference: [Bar84] <editor> Barstow D. R., Shrobe H. E., Sandewall E. </editor> <title> Interactive programming environments, </title> <publisher> McGraw-Hill Book Company, </publisher> <address> USA, </address> <year> 1984. </year>
Reference-contexts: The Cornell environment is completely syntax directed, leading to a tightening of any conceptual view of the program from being a text file to being computational structures represented by text. Many different integrated programming environments exist for many different systems <ref> [Bar84] </ref>. Another integrated programming environment Cens [Kow91] which was developed at AT&T Bell Laboratories. This environment uses the cin/cin++ C interpreter as its kernel, allowing tools to be added or changed as required.
Reference: [Ber85] <author> Berry R. E., Meekings B. A. E. </author> <title> A style analysis of C programs. </title> <journal> Communications of the ACM, </journal> <volume> 28(1):808, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: symbols; V (G) - the number of logical conditions plus 1 (McCabes [McC76] cyclomatic complexity number); Function calls - the number of function calls; Structure pointers - the number of structure pointers; and NPath - the number of acyclic execution paths (Nejmehs [Nej88] enhancement of McCabes metric) Berry and Meekings <ref> [Ber85] </ref> have written a program called style which attempts to apply metrics to style analysis of C programs.
Reference: [Cam88] <author> Cameron D., Rosenblatt B. </author> <title> Learning GNU Emacs. </title> <publisher> OReilly & Associates, </publisher> <address> Sebastopol, California, </address> <year> 1988. </year>
Reference: [Che86] <author> Chen Y. F., Ramamoorthy C. V. </author> <title> The C Information Abstractor. </title> <booktitle> In Proceedings of the Tenth International Computer Software and Application Conference, </booktitle> <pages> pages 29198. </pages> <address> COMPAC, </address> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1986. </year>
Reference-contexts: A more comprehensive static analysis tool is cia <ref> [Che86] </ref>[Che90b] (C Information Abstractor) which was developed for AT&T Bell Laboratories by Chen and Ramamoorthy [Che86]. This tool extracts information about functions, files, user defined data types, macros and global variables. This information is stored in a relational database, and can be accessed by most relational databases.
Reference: [Che90a] <author> Chen Y. F., Grass J. E. </author> <title> The C++ Information Abstractor. </title> <booktitle> In Proceedings of the Second C++ Conference, </booktitle> <pages> pages 3450. </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: By creating an external model of the code, cia allows other tools to query the information further, and provide the programmer with a large range of information and views of his program. A similar system called cia++ <ref> [Che90a] </ref> has been written using the same principals for the C++ language. Another static analysis tools that allow source code to be viewed at different levels of abstraction is TuringTool [Cor90]. TuringTool was specifically designed to support the maintenance of software.
Reference: [Che90b] <author> Chen Y.F., Nishimoto M. Y., Ramamoorthy C. V. </author> <title> The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3):32534, </volume> <month> March </month> <year> 1990. </year>
Reference: [Cor90] <author> Cordy J. R., Eliot N. L. Robertson M. G. Turingtool: </author> <title> A user interface to aid in the software maintenance task. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3):294301, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: A similar system called cia++ [Che90a] has been written using the same principals for the C++ language. Another static analysis tools that allow source code to be viewed at different levels of abstraction is TuringTool <ref> [Cor90] </ref>. TuringTool was specifically designed to support the maintenance of software. It uses a viewing paradigm known as source text elision to provide various views of the program in question. The Maintainers Assistant [War89] is a static analysis tool whose main aim is to assist in maintenance of programs.
Reference: [Dar88] <author> Darwin I. F. </author> <title> Checking C Programs with Lint. </title> <publisher> OReilly & Associates, </publisher> <address> Sebasterpol, California, </address> <year> 1988. </year>
Reference-contexts: C compilers typically provide poor diagnostic facilities, and as a result compiled code is more likely to contain runtime errors. This and the fact that they tend to produce very cryptic error messages, provides a strong argument for the use of static analysis tools such as lint <ref> [Dar88] </ref> (discussed later), before compilation. Often programs to be compiled consist of many files, and require various ags to be set. <p> The most common and probably the most important static analysis tool is lint <ref> [Dar88] </ref>. As mentioned previously, lint can be used to provide the programmer with more information about the correctness of the code than standard C compilers.
Reference: [Don84] <author> Donzeau-gouge V., Huet G., Kahn G., Lang B. </author> <title> Programming environments based on structure editors: The mentor experience. </title> <booktitle> In Interactive Programming Environments, </booktitle> <pages> pages 12840. </pages> <publisher> McGraw Hill Book Company, </publisher> <address> USA, </address> <year> 1984. </year>
Reference-contexts: It also provides the ability to interact easily with the shell environment, and the ability to view separate texts on a split screen. A more complex editor is MENTOR <ref> [Don84] </ref> which is based on building an abstract syntax tree of the code as it is created. This editor is based on a pascal programming environment and provides a more complex structured interface to the pascal language than does a pascal-customized emacs editor. <p> This editor is based on a pascal programming environment and provides a more complex structured interface to the pascal language than does a pascal-customized emacs editor. That is, the user cannot simply write pascal code: they must define their pascal program in the tree manipulation language, MENTOL <ref> [Don84] </ref>.
Reference: [Fra91] <author> Frakes W. B., Fox C. J., Nejmeh B. A. </author> <title> Software Engineering in the Unix/C Environment. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: This discussion is preceded by a short introduction to the software development process. 2 The Software Development Process The software development process is the primary concern of a discipline known as software engineering. Software engineering has been a recognised discipline since the late 1960s <ref> [Fra91] </ref>. It is a hybrid discipline which has incorporated aspects from other disciplines such as computer science, engineering, mathematics, economics, and management. Software engineers have defined many models describing the software development process in terms of the life cycle of the software. <p> There are many models which describe these phases, and most agree at the fundamental level as to what the phases are, although the terminology tends to differ. The simplest model is the waterfall model. This model generally describes six or seven phases. Frakes <ref> [Fra91] </ref> presents a model with six phases as follows: Feasibility analysis phase: involves the analysis of the feasibility of creating software for a particular purpose. <p> Requirements Specification Maintenance Feasibility Analysis Design Implementation Testing Fig 1 Waterfall model for Software Life Cycle A Survey of Tools for the Development and Maintenance of Programs 4 Program Development And Maintenance Tools Code Quality Frakes <ref> [Fra91] </ref> defines good code as resulting in a program with the following properties: Correctness: The program should performs the task intended. Efficiency: The program should utilize its resources in a manner that achieves the task at hand in the minimal possible time while not compromising the correctness of the code. <p> Of particular interest in creating this conceptual model is understanding the structure and layout of the program. 3 Program Development And Maintenance Tools Program development, regardless of the magnitude of the problem, requires that a minimum set of tools be available to aid the programmer. Frakes <ref> [Fra91] </ref> identifies three categories that these tools fall into: A Survey of Tools for the Development and Maintenance of Programs 5 Program Development And Maintenance Tools Program Generation Tools; Static Analysis Tools; and Dynamic Analysis Tools. <p> The most commonly used screen editor in the A Survey of Tools for the Development and Maintenance of Programs 6 Program Development And Maintenance Tools Unix environment is vi. Frakes <ref> [Fra91] </ref> identifies four very helpful and important features of vi that are prevalent in most screen editors: i) Auto indentation - where a new line is automatically indented to the first non white space character on the previous line; ii) The ability to identify matching braces and parentheses; iii) Line count <p> This editor is based on a pascal programming environment and provides a more complex structured interface to the pascal language than does a pascal-customized emacs editor. That is, the user cannot simply write pascal code: they must define their pascal program in the tree manipulation language, MENTOL [Don84]. Frakes <ref> [Fra91] </ref> identifies two problems that arise from the use of syntax-directed editors, but points out that this type of editor is not yet widely used, so their real value has not been clearly identified: They prevent novice programmers from learning the language well, and by continually correcting syntactic mistakes they reinforce <p> Another C formatting tool available with recent versions of Unix is indent, which provides many more options than cb. This is the preferred formatting tool for C code. Frakes <ref> [Fra91] </ref> raises the following question in relation to the use of such tools. A Survey of Tools for the Development and Maintenance of Programs 8 Program Development And Maintenance Tools Q. Why worry about readable code when tools like cb and indent can clean it up later? A. <p> The primary advantage of this tool is that it promotes the reusability of the functions built into the library. Interpreters execute code piece by piece, rather than translating the entire program into an executable form. Frakes <ref> [Fra91] </ref> emphasises the fact that interpreters are useful because they shorten the edit, execute and debug cycle which is generally fairly time consuming. <p> The most common and probably the most important static analysis tool is lint [Dar88]. As mentioned previously, lint can be used to provide the programmer with more information about the correctness of the code than standard C compilers. Frakes <ref> [Fra91] </ref> lists the following useful areas that lint reports on, some of which are also reported by compilers: The syntax errors the compiler would have found; Functions without return value checks; Functions declarations and calls with incorrect numbers and types of arguments in parameter lists; Variables declared but not used; Unreachable <p> Frakes <ref> [Fra91] </ref> indicates that all programs should be run through lint. Kernighan and Pike [Ker84] provide the following appraisal of lint, which supports this assertion. lint is a mixed success. <p> These tools are generally used to determine which areas of code need testing, to estimate the readability of the code formally and to determine if modules are too complex. Frakes <ref> [Fra91] </ref> provides a simple example of such a program called ccount. It reports the number of commentary source lines, the number of non-commentary source lines and the commentary to non-commentary source line ratio. <p> As a result, resolving these errors is left to the programmers ability to identify them and reason why they occur. There is current research into intelligent debuggers which attempt to solve this problem. However this is not within the scope of this review. Frakes <ref> [Fra91] </ref> provides the following list of activities which most debuggers allow users to perform: Examine source code during execution; Insert breakpoints to stop execution at a given point; Examine variable contents during execution; Change a variables value; Examine the stack used during function calls; and Execute the program line by line, <p> this type of profiler are that they provide too much information which therefore must be summarized, resulting in a loss of accuracy, and that they provide information about the dynamic behaviour of a program, but do not allow this to be easily related back to the source code [Hal92]. lprof <ref> [Fra91] </ref> is an example of a trace profiler for C in the Unix environment. Another example of a trace profiler is Quantify by Pure Software.
Reference: [Fra93] <author> Franklin D. </author> <title> Insight: A tool to support total quality software. Correspondence, </title> <publisher> Parasoft Corporation, 2500 E. </publisher> <address> Foothill Blvd., Suite 205, Pasadena, CA 91107, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Such tools can be used to locate bugs that do not result in an immediate problem, reducing the need for future maintenance. Examples of such tools for Unix C/C++ are Insight <ref> [Fra93] </ref>, Purify [Has92][The93], Sentinel and CodeCenter.
Reference: [Gan83] <author> Ganser E. Syned: </author> <title> A language based editor for an interactive programming environment. </title> <booktitle> In COMPCON Proceedings, </booktitle> <pages> pages 5568. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1983. </year>
Reference-contexts: Syned <ref> [Gan83] </ref> is a syntax-directed editor for C developed by Bell Laboratories, which attempts to overcome the second problem by allowing the syntax directed features to be turned off.
Reference: [Gol83] <author> Goldberg A. </author> <title> The influence of an Object-Oriented language on the programming environment. </title> <booktitle> In Proceedings of the 1983 ACM Computer Science Conference, </booktitle> <pages> pages 3554, </pages> <address> Orlando, Florida, </address> <month> February </month> <year> 1983. </year> <note> ACM Press. </note>
Reference-contexts: The more advanced syntax directed editors provide such an environment, which is known as an interactive programming environment. Environments that provide syntax directed editing and browsing environments such as Magpie [Mor81], smalltalk-80 <ref> [Gol83] </ref>, Pegasys [Mor85], Gandalf [Hab86] and the Cornell Program Synthesizer [Tei81] represent the program internally in semantically meaningful structures such as abstract syntax trees. However these environments encompass the three categories of programming tools previously identified, and therefore is discussed later in section 3.4.
Reference: [Gra82] <author> Graham S. L., Kessler P. B., McKusick M. K. </author> <title> GPROF: A call graph execution profiler. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(6):1206, </volume> <month> June </month> <year> 1982. </year>
Reference: [Hab86] <author> Habermann A. N., Notkin D. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):11171127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: The more advanced syntax directed editors provide such an environment, which is known as an interactive programming environment. Environments that provide syntax directed editing and browsing environments such as Magpie [Mor81], smalltalk-80 [Gol83], Pegasys [Mor85], Gandalf <ref> [Hab86] </ref> and the Cornell Program Synthesizer [Tei81] represent the program internally in semantically meaningful structures such as abstract syntax trees. However these environments encompass the three categories of programming tools previously identified, and therefore is discussed later in section 3.4.
References-found: 16

