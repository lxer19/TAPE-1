URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-125.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Title: Measuring Software Reuse in Object Oriented Systems and Ada Software  
Affiliation: Department of Computer Science  Colorado State University  
Abstract: Santhi Karunanithi and James M. Bieman Technical Report CS-93-125 October 13, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [BB81] <author> J. Bailey and V. Basili. </author> <title> A meta-model for software development resource expenditures. </title> <booktitle> In Proc. 5th Int. Conf. Software Engineering (ICSE-5), </booktitle> <pages> pages 107-116, </pages> <year> 1981. </year>
Reference-contexts: Conte [CDS86], Boehm [Boe81], Bailey <ref> [BB81] </ref>, and Fenton [Fen91] describe reuse measures that are based on comparisons between the length or size of reused code and the size of newly written code in particular software products. Modifications to reused code are not considered by these researchers. Conte's reuse measure is for estimating coding effort.
Reference: [BBF + 90] <author> A. Baker, J. Bieman, N. Fenton, A. Melton, and R. Whitty. </author> <title> A philosophy for software measurement. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(3) </volume> <pages> 277-281, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The focus of reuse measurement is on internal product reuse measures. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Metric development follows the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. In order to derive reuse measures, definitions of software reuse attributes, the documents to be measured, formal models of reuse attributes and a method for generating consistent numerical values from the documents and attributes need to be identified. <p> In this chapter existing software reuse metrics are reviewed and research needs are identified. 2.1 Software Measurement Theory Any metric development should follow the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Measurement theory suggest the following process [BBF + 90]. 1. Identify and define intuitive and well-understood attributes of software reuse. 2. <p> The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Measurement theory suggest the following process <ref> [BBF + 90] </ref>. 1. Identify and define intuitive and well-understood attributes of software reuse. 2. Specify precisely the documents and the attributes to be measured. 3. Determine formal models or abstractions which capture these attributes. Formal models are required to unambiguously produce numerical measurement values. 4.
Reference: [Bie92] <author> J. Bieman. </author> <title> Deriving measures of software reuse in object-oriented systems. </title> <booktitle> proc. bcs workshop on formal aspects of measurement (1991). </booktitle> <editor> In T. Denvir, R. Herman, and 25 R. Whitty, editors, </editor> <booktitle> Formal Aspects of Measurement, </booktitle> <pages> pages 63-83. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The limitations of the surveyed research is the motivation for this paper. In Chapter 3, existing definitions of measurable reuse attributes appropriate to object oriented systems <ref> [Bie92] </ref> are extended with additional definitions of measurable attributes. Also, the documents to be measured and formal models or abstractions for capturing the reuse attributes are presented. Then reuse attributes and abstractions pertaining to object based language Ada are identified. <p> Bieman defines classes of software reuse, identifies important perspectives of reuse, proposes relevant reuse abstractions, and suggests reuse attributes and associated metrics applicable to object oriented systems <ref> [Bie92] </ref>. He provides a framework for the derivation of software reuse measures. Reuse is classified along three axis: public or private, verbatim or leveraged, and direct 6 or indirect reuse. <p> The scope of measures is restricted to static reuse measurements. 3.1 Reuse Classification Reuse can be measured along three axis: the public or private, classification as described by Fenton [Fen91], verbatim or leveraged, and direct or indirect as described by Bieman <ref> [Bie92] </ref>. Verbatim reuse is reuse without modifications. Reusing code from a library without change is verbatim reuse. Leveraged reuse is reuse with modifications. Leveraged reuse is accomplished when code from predefined classes is tailored to a new use.
Reference: [Boe81] <author> B. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Conte [CDS86], Boehm <ref> [Boe81] </ref>, Bailey [BB81], and Fenton [Fen91] describe reuse measures that are based on comparisons between the length or size of reused code and the size of newly written code in particular software products. Modifications to reused code are not considered by these researchers.
Reference: [Boo91] <author> G. Booch. </author> <title> Object oriented design with applications. </title> <publisher> The Benjamin/Cummings Publishing, Inc., </publisher> <address> Menlo Park, CA, </address> <year> 1991. </year>
Reference-contexts: These software documents are either design documents or code documents. Design documents can be documents in the form of graph models such as call multigraph, inheritance hierarchy graph and Booch diagrams <ref> [Boo91] </ref>. Booch diagrams consist of four types of diagrams namely class diagrams, object diagrams, module diagrams and process diagrams.
Reference: [BP84] <author> T. Biggerstaff and A. Perlis, </author> <title> editors. </title> <journal> Special Issue on software reuseability. IEEE Trans. Software Engineering, </journal> <volume> volume SE-10(5). </volume> <year> 1984. </year>
Reference-contexts: One important step towards solving this software crisis is via software reuse. One of the fundamental causes for the software bottleneck is that new software systems are usually developed from scratch even though much of the code in a given software system can be found in other similar systems <ref> [BP84, BP89, BR89] </ref>. Software reuse can potentially increase the quality and productivity of software development and maintenance. Software reuse reduces the amount of software that needs to be produced from scratch and thus allows a greater focus on quality.
Reference: [BP89] <author> T. Biggerstaff and A. Perlis, </author> <title> editors. Software Reusability Vols. I, II. </title> <publisher> ACM Press. Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: One important step towards solving this software crisis is via software reuse. One of the fundamental causes for the software bottleneck is that new software systems are usually developed from scratch even though much of the code in a given software system can be found in other similar systems <ref> [BP84, BP89, BR89] </ref>. Software reuse can potentially increase the quality and productivity of software development and maintenance. Software reuse reduces the amount of software that needs to be produced from scratch and thus allows a greater focus on quality.
Reference: [BR89] <author> T. Biggerstaff and C. Richer. </author> <title> Reusability framework, assessment, and directions. </title> <editor> In T. Biggerstaff and A. Perlis, editors, </editor> <title> Software Reusability Vols. I, II. </title> <publisher> ACM Press. Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: One important step towards solving this software crisis is via software reuse. One of the fundamental causes for the software bottleneck is that new software systems are usually developed from scratch even though much of the code in a given software system can be found in other similar systems <ref> [BP84, BP89, BR89] </ref>. Software reuse can potentially increase the quality and productivity of software development and maintenance. Software reuse reduces the amount of software that needs to be produced from scratch and thus allows a greater focus on quality.
Reference: [Bro87] <author> F. Brooks. </author> <title> No silver bullet: </title> <journal> Essence and accidents of software engineering. IEEE Computer, </journal> <volume> 20(4) </volume> <pages> 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: There is a high demand for software systems of increasing complexity as well as the need to modify and extend existing software systems. Finding solutions to this "software crisis" is difficult <ref> [Bro87] </ref>. One important step towards solving this software crisis is via software reuse.
Reference: [CDS86] <author> S. Conte, H. Dunsmore, and V. Shen. </author> <title> Software Engineering Metrics and Models. </title> <publisher> The Benjamin/Cummings Publishing, Inc., </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year>
Reference-contexts: Conte <ref> [CDS86] </ref>, Boehm [Boe81], Bailey [BB81], and Fenton [Fen91] describe reuse measures that are based on comparisons between the length or size of reused code and the size of newly written code in particular software products. Modifications to reused code are not considered by these researchers.
Reference: [CK91] <author> S. Chidambar and C. Kemerer. </author> <title> Towards a metrics suite for object oriented design. </title> <booktitle> In Proc. OOPSLA, </booktitle> <pages> pages 197-211, </pages> <year> 1991. </year>
Reference-contexts: The expected new version of Ada, Ada 9X [Coh90] incorporates additional features for generic parameters, overloading, and inheritance. A suite of new metrics especially designed to measure unique aspects of the object oriented approach is needed. Reuse Metrics for Object Oriented Software Chidamber et al. <ref> [CK91] </ref> propose a set of six metrics specifically developed for measuring elements contributing to size and complexity of object oriented design namely weighted methods per class, depth of inheritance tree, number of sub-classes subordinated to a class in the class hierarchy, coupling between objects, response for a class or cardinality of <p> There is also a need for research on measuring reuse when the reused software is modified for new uses. There has been only minimal previous research on measuring reuse and even less research has been conducted on measuring reuse in object oriented systems. The results of Chidamber et al. <ref> [CK91] </ref> are very preliminary. Gannon et al. claim that the component access metric measures the units resistance to changes. They also claim that the package visibility metric UA measures the perceived generality of the package. PC directly indicates the success of design decision to minimize visibility.
Reference: [Coh90] <author> S. Cohen. </author> <title> Ada 9x project report: Ada support for software reuse. </title> <type> Technical Report SEI-90-SR-16, </type> <institution> Software Engineering Institute, Carnegie Mellon University, Pittsburg, </institution> <address> PA, </address> <month> Oct </month> <year> 1990. </year>
Reference-contexts: The expected new version of Ada, Ada 9X <ref> [Coh90] </ref> incorporates additional features for generic parameters, overloading, and inheritance. A suite of new metrics especially designed to measure unique aspects of the object oriented approach is needed. <p> It supports software portability and reuse. The current version of Ada does not support inheritance. Hence all the measures defined for object oriented systems except leveraged reuse measures are applicable for Ada. However, the expected new version of Ada, Ada 9X <ref> [Coh90] </ref> incorporates more kinds of generic parameters, overloading, and inheritance thus making Ada an object oriented language. In this thesis, metrics are derived only for object based Ada systems. Hence, leveraged reuse metrics are not derived and empirically validated in this thesis.
Reference: [Fen91] <author> N. Fenton. </author> <title> Software Metrics A Rigorous Approach. </title> <publisher> Chapman & Hall, </publisher> <address> London, </address> <year> 1991. </year>
Reference-contexts: The objective of our work is to identify a suite of metrics for primitive reuse attributes appropriate to object oriented systems. The focus of reuse measurement is on internal product reuse measures. The attributes of reuse measurement are internal product attributes related to properties of particular software documents <ref> [Fen91] </ref>. Metric development follows the guidelines of scientific measurement principles as applied to software [BBF + 90, MGBB90, FM90]. <p> Reuse can not be completely quantified by a single reuse metric. Primitive metrics based on primitive reuse attributes are clearly components of the "level of reuse." Composite metrics are often less sensitive than the primitive metrics and must be defined carefully <ref> [Fen91] </ref>. Thus no attempt is made to combine the primitive components into meaningful composite metrics. The primitive components can later be used (or combined) to satisfy specific goals and questions of software developers. <p> The attributes of reuse measurement are internal product attributes related to properties of particular software documents <ref> [Fen91] </ref>. Measurement theory suggest the following process [BBF + 90]. 1. Identify and define intuitive and well-understood attributes of software reuse. 2. Specify precisely the documents and the attributes to be measured. 3. Determine formal models or abstractions which capture these attributes. <p> Conte [CDS86], Boehm [Boe81], Bailey [BB81], and Fenton <ref> [Fen91] </ref> describe reuse measures that are based on comparisons between the length or size of reused code and the size of newly written code in particular software products. Modifications to reused code are not considered by these researchers. Conte's reuse measure is for estimating coding effort. <p> Reuse can not be completely quantified by a single reuse metric. Primitive metrics based on primitive reuse attributes are clearly components of the "level of reuse." Composite metrics are often less sensitive than the primitive metrics and must be defined carefully <ref> [Fen91] </ref>. Thus no attempt is made to combine the primitive components into meaningful composite metrics. In this chapter, a set of measurable, intuitively meaningful reuse attributes in object oriented systems, documents to be measured, and formal models of reuse attributes are identified. <p> The scope of measures is restricted to static reuse measurements. 3.1 Reuse Classification Reuse can be measured along three axis: the public or private, classification as described by Fenton <ref> [Fen91] </ref>, verbatim or leveraged, and direct or indirect as described by Bieman [Bie92]. Verbatim reuse is reuse without modifications. Reusing code from a library without change is verbatim reuse. Leveraged reuse is reuse with modifications. Leveraged reuse is accomplished when code from predefined classes is tailored to a new use.
Reference: [FM90] <author> N. Fenton and A. Melton. </author> <title> Deriving structurally based software measures. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(3) </volume> <pages> 177-187, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The focus of reuse measurement is on internal product reuse measures. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Metric development follows the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. In order to derive reuse measures, definitions of software reuse attributes, the documents to be measured, formal models of reuse attributes and a method for generating consistent numerical values from the documents and attributes need to be identified. <p> In this chapter existing software reuse metrics are reviewed and research needs are identified. 2.1 Software Measurement Theory Any metric development should follow the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Measurement theory suggest the following process [BBF + 90]. 1. Identify and define intuitive and well-understood attributes of software reuse. 2.
Reference: [GKB86] <author> J. Gannon, E. Katz, and V. Basili. </author> <title> Metrics for ada packages : An initial study. </title> <journal> Communications of the ACM, </journal> <volume> 29(7) </volume> <pages> 616-623, </pages> <year> 1986. </year>
Reference-contexts: Gannon et al. <ref> [GKB86] </ref> show that a good background in software engineering principles is necessary to use the full capabilities of the Ada language. They propose three metrics for Ada packages: a component access metric and two package visibility metrics UA and PC. <p> Table 4 gives reuse measures from the server perspective under each reuse classification. In addition, the package visibility measures of Gannon et al. <ref> [GKB86] </ref> are also relevant measures from the server perspective. Hence the following measures are to be measured for each server: Used: Number of units where information from the server is accessed or changed. Current: Number of units where the server is currently visible. <p> From the Table 6 we find that the subunits Safe Streams.Enum Stream (body), Safe Streams.Reduce Stream (body) and Safe Streams.Output Driver (body) do not use List Manager though they have visibility to List Manager. Hence we get the following values for Gannon et al. measures <ref> [GKB86] </ref> corresponding to List Manager package. Used: 9 units Current: 13 units Available: 14 units Proposed: 9 units UA (List Manager) or perceived generality of List Manager is calculated as Used/Available = 0.64 and the PC (List Manager) or excess visibility of List Manager is calculated as Proposed/Current = 0.69.
Reference: [GWJB83] <author> G. Goos, W. Wulf, A. Evans Jr., and K. Butler. DIANA, </author> <title> An Intermediate Language for Ada, volume 161. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: The Program and Analysis Group at Stanford University has developed a prototype environment supporting the Anna language [Men92]. The tools implement a large subset of the Ada and Anna languages. The Anna-I tools are completely implemented in Ada and uses Descriptive Intermediate Attributed Notation for Ada (DIANA), <ref> [GWJB83] </ref> to form the intermediate representation of Ada programs. DIANA is an intermediate form of Ada programs which has been designed to be especially suitable for communication between the front and back ends of a compiler.
Reference: [KB93] <author> S. Karunanithi and J. Bieman. </author> <title> Candidate reuse metrics for object oriented and ada software. </title> <booktitle> Proc. IEEE-CS Int. Software Metrics Symposium, </booktitle> <pages> pages 120-128, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A set of potentially measurable attributes can be derived for OOPLs based on profiles of reuse from each perspective. In each perspective, reuse can be categorized as either verbatim, generic, or leveraged. As a result, we can define numerous measurable attributes <ref> [KB93] </ref>. Because of the numerous candidate reuse metrics that can be derived, they are presented here in a set of tables. Client Perspective The client perspective is the perspective of a new system or a new system component.
Reference: [Luc90] <author> David C. Luckham, </author> <title> editor. Programming with Specifications: An Introduction to Anna, A language for specifying Ada programs. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: developing Ada syntactic and semantic analyzers from scratch, the Anna tool set developed at Stanford [Men92] is used as a base for the prototype tool design. 4.1 Anna Tool Set Description Anna is a language extension of Ada which includes facilities for formally specifying the intended behavior of Ada programs <ref> [Luc90] </ref>. Anna is designed to augment Ada with precise machine-processable annotations so that formal methods of specification and documentation can be applied to Ada programs. The Program and Analysis Group at Stanford University has developed a prototype environment supporting the Anna language [Men92].
Reference: [Men92] <author> G. Mendal. </author> <title> The anna-i user's guide and installation manual, version 1.4 edition. </title> <type> Technical Report ERL 456, </type> <institution> Stanford University, Computer Systems Lab, Stanford, </institution> <address> CA, </address> <month> Sept </month> <year> 1992. </year> <month> 26 </month>
Reference-contexts: Chapter 4 describes the design of the reuse measurement tool, the Ada Reuse Metric Analyzer (ARMA), developed for measuring reuse in Ada systems. The measurement tool is an extension of the Anna tool set developed at Stanford <ref> [Men92] </ref>. Chapter 5 presents the data sets used in evaluating the reuse measurement tool, the derived reuse measures and an evaluation of the measures and the tool. Chapter 6 presents a summary of the results and general conclusions and implications of this work. <p> This chapter presents the design of a prototype software tool, the "Ada Reuse Metric Analyzer" (ARMA), developed to measure reuse. The tool is designed to measure reuse properties in Ada programs. Instead of developing Ada syntactic and semantic analyzers from scratch, the Anna tool set developed at Stanford <ref> [Men92] </ref> is used as a base for the prototype tool design. 4.1 Anna Tool Set Description Anna is a language extension of Ada which includes facilities for formally specifying the intended behavior of Ada programs [Luc90]. <p> Anna is designed to augment Ada with precise machine-processable annotations so that formal methods of specification and documentation can be applied to Ada programs. The Program and Analysis Group at Stanford University has developed a prototype environment supporting the Anna language <ref> [Men92] </ref>. The tools implement a large subset of the Ada and Anna languages. The Anna-I tools are completely implemented in Ada and uses Descriptive Intermediate Attributed Notation for Ada (DIANA), [GWJB83] to form the intermediate representation of Ada programs. <p> The prototype tool ARMA has been implemented and initial empirical evaluation of the measurement tool was accomplished by measuring proposed reuse metrics for a selected software supplied by CTA, Inc. The ARMA tool extends the Anna-I tool set developed at Stanford <ref> [Men92] </ref>. There are two parts to the ARMA tool, Metric Generator and Metric Analyzer. The Metric Generator takes the AST with semantic information as input and generates reuse information using an internal reuse representation language.
Reference: [Mey87] <author> B. Meyer. </author> <title> Reusability: The case for object oriented design. </title> <journal> IEEE Software, </journal> <volume> 4(2):50--64, </volume> <month> Mar </month> <year> 1987. </year>
Reference-contexts: Proponents assert that a major benefit of object oriented or object based design and programming is the generation of reusable software components <ref> [Mey87] </ref>. To support or refute claims that object oriented or object based software promotes software reuse, one must be able to measure reuse in these systems. Current reuse measures are not directed toward the object oriented approach.
Reference: [MGBB90] <author> A. Melton, D. Gustafson, J. Bieman, and A. Baker. </author> <title> A mathematical perspective for software measures research. </title> <journal> IEE Software Engineering Journal, </journal> <volume> 5(5) </volume> <pages> 246-254, </pages> <year> 1990. </year>
Reference-contexts: The focus of reuse measurement is on internal product reuse measures. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Metric development follows the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. In order to derive reuse measures, definitions of software reuse attributes, the documents to be measured, formal models of reuse attributes and a method for generating consistent numerical values from the documents and attributes need to be identified. <p> In this chapter existing software reuse metrics are reviewed and research needs are identified. 2.1 Software Measurement Theory Any metric development should follow the guidelines of scientific measurement principles as applied to software <ref> [BBF + 90, MGBB90, FM90] </ref>. The attributes of reuse measurement are internal product attributes related to properties of particular software documents [Fen91]. Measurement theory suggest the following process [BBF + 90]. 1. Identify and define intuitive and well-understood attributes of software reuse. 2.
Reference: [Sel89] <author> R. Selby. </author> <title> Quantitative studies of software reuse. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability Vol. II Applications and Experiences, </booktitle> <pages> pages 213-233. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Selby addresses the measurement of reuse with modifications <ref> [Sel89] </ref>. He classifies modules into categories based on the percentage of new versus reused code in a module. The categories are completely new modules, reused modules with major revisions ( 25%changed), reused modules with slight revisions (&lt; 25 % changed), and modules that are reused without change.
Reference: [YW78] <author> B. Yin and J. </author> <title> Winchester. The establishment and use of measures to evaluate the quality of system designs. </title> <booktitle> In Proc. Software Quality and Assurance Workshop, </booktitle> <pages> pages 45-52, </pages> <year> 1978. </year>
Reference-contexts: within a product are reused within the same product." Using the call graph as an abstraction, Yin and Winchester measure the private reuse as r (G) = e - n + 1 where e is the number of edges and n is the number of nodes in the call graph <ref> [YW78] </ref>. Selby addresses the measurement of reuse with modifications [Sel89]. He classifies modules into categories based on the percentage of new versus reused code in a module.
References-found: 23

