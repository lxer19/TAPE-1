URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/CC_CHiso.ps.gz
Refering-URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/
Root-URL: http://www.win.tue.nl
Title: The Calculus of Constructions and Higher Order Logic  
Author: Herman Geuvers, 
Date: August 1992  
Address: Toernooiveld 1, 6525 ED Nijmegen, The Netherlands  
Affiliation: Faculty of Mathematics and Computer Science, University of Nijmegen,  
Abstract: The Calculus of Constructions (CC) ([Coquand 1985]) is a typed lambda calculus for higher order intuitionistic logic: proofs of the higher order logic are interpreted as lambda terms and formulas as types. It is also the union of Girard's system F ! ([Girard 1972]), a higher order typed lambda calculus, and a first order dependent typed lambda calculus in the style of de Bruijn's Automath ([de Bruijn 1980]) or Martin-Lof's intuitionistic theory of types ([Martin-Lof 1984]). Using the impredicative coding of data types in F ! , the Calculus of Constructions thus becomes a higher order language for the typing of functional programs. We shall introduce and try to explain CC by exploiting especially the first point of view, by introducing a typed lambda calculus that faithfully represent higher order predicate logic (so for this system the Curry-Howard `formulas-as-types isomorphism' is really an isomorphism.) Then we discuss some propositions that are provable in CC but not in the higher order logic, showing that the formulas-as-types embedding of higher order predicate logic into CC is not an isomorphism. It is our intention that this chapter can be read without any specialist knowledge of higher order logic or higher order typed lambda calculi. 
Abstract-found: 1
Intro-found: 1
Reference: [Barendregt 1984] <author> H.P. Barendregt, </author> <title> The lambda calculus: its syntax and semantics, revised edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics, </booktitle> <publisher> North Holland. </publisher>
Reference-contexts: T. (That is, if M !! fi M 1 and M !! fi M 2 then M 1 !! fi N and M 2 !! fi N for some N 2 T. (The proof is the same as the Church-Rosser proof of fi-reduction on the untyped lambda terms in e.g. <ref> [Barendregt 1984] </ref>.) One of the basic properties is the Substitution property, stating that if 1 ; x:A; 2 ` M : B and 1 ` N : A then 1 ; 2 [N=x] ` M [N=x] : B [N=x].
Reference: [Barendregt 199+] <author> H.P. Barendregt, </author> <title> Typed lambda calculi. </title> <editor> In Abramski et al. (eds.), </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <institution> Oxford Univ. </institution> <note> Press, to appear. </note>
Reference-contexts: We shall not go into details about meta theory nor do we give a list of examples of systems in the form of a PTS but refer to <ref> [Barendregt 199+] </ref> and [Geuvers and Nederhof 1991]. Here we just repeat the definition and the main meta-theoretic properties. <p> A practical purpose for the use of the PTS framework is that many properties can be proved once and for all for the whole class of PTSs. We list the most important ones. (Proofs can be found in [Geuvers and Nederhof 1991] 9 or <ref> [Barendregt 199+] </ref>.
Reference: [Barendregt 1992] <author> H.P. Barendregt, </author> <title> The cube of typed lambda calculi. This volume. </title>
Reference-contexts: latter as it is very short (but syntactic.) Both proofs give a counterexample already for the completeness of the embedding of third order predicate logic in so called third order dependent typed lambda calculus. (In this terminology, CC is higher order dependent typed lambda calculus and the system P2 of <ref> [Barendregt 1992] </ref> is second order dependent typed lambda calculus.) The counterexample with empty domains above already works for second order dependent typed lambda calculus; it is not known whether one can find a counterexample without allowing empty domains. <p> The idea comes from an argument by Berardi, suggesting a possible method to show that the formulas-as-types embedding from second order predicate logic into second order dependent typed lambda calculus (P2 in <ref> [Barendregt 1992] </ref>) is not complete. (The proofs of incompleteness for Proposition 4.12 also work to show the incompleteness of the formulas-as-types embedding from nth order predicate logic into nth order dependent typed lambda calculus, but only for for n &gt; 2.) We look at the context := A:Set; a; a 0
Reference: [van Benthem Jutting 199+] <editor> L.S. van Benthem Jutting, </editor> <title> Typing in Pure Type Systems. </title> <note> To appear in Information and Computation. </note>
Reference: [Berardi 1988] <author> S. Berardi, </author> <title> Towards a mathematical analysis of the Coquand-Huet calculus of constructions and the other systems in Barendregt's cube. </title> <institution> Dept. Computer Science, Carnegie-Mellon University and Dipartimento Matematica, Universita di Torino, Italy. </institution>
Reference-contexts: For the syntactic rules there is no distinction between the basic domains and the domain Prop. Further it doesn't allow a straightforward syntactical description of the formulas-as-types embedding of higher order predicate logic into CC. We therefore look at the following definition of higher order predicate logic, due to <ref> [Berardi 1988] </ref> (and defined for the purpose of describing the Curry-Howard embedding.) Definition 2.10 The system PRED! is the following Pure Type System S = Prop; Set; Type p ; Type s ; A = Prop : Type p Set : Type s ; R = (Set; Set); (Set; Type p <p> The following can be proved by an easy induction on derivations. (` CC denotes derivability in CC, ` PROP! denotes derivability in PROP!.) Proposition 4.5 <ref> [Paulin 1989, Berardi 1988] </ref> ` CC M : A ) [] ` PROP! [M ] : [A] 20 Corollary 4.6 [Paulin 1989, Berardi 1988]) CC is conservative over PROP! Proof The only thing to check is that for M 2 TERM (PROP!), [M ] j M . <p> The following can be proved by an easy induction on derivations. (` CC denotes derivability in CC, ` PROP! denotes derivability in PROP!.) Proposition 4.5 <ref> [Paulin 1989, Berardi 1988] </ref> ` CC M : A ) [] ` PROP! [M ] : [A] 20 Corollary 4.6 [Paulin 1989, Berardi 1988]) CC is conservative over PROP! Proof The only thing to check is that for M 2 TERM (PROP!), [M ] j M .
Reference: [Berardi 1989] <author> S. Berardi, </author> <title> Talk given at the `Jumelage meeting on typed lambda calculus', </title> <publisher> Edinburgh, </publisher> <month> September </month> <year> 1989. </year> <month> 36 </month>
Reference-contexts: In CC, take M j z:(9x:A:P x):y:(A!'):y (px), with p as in Remark 4.10. Also without using empty domains the embedding is not complete, as was first independently shown by <ref> [Berardi 1989] </ref> and [Geuvers 1989]. <p> More precisely, in 0 = A:Prop; a:A; ':Prop; ff:Prop!Prop; z:P (x:A:'), 0 ` fl:Prop:h:(fi:Prop:P (fl!')!fi):hAz : 9fi:Prop:P (fi!'): Proof <ref> [Berardi 1989] </ref> Define EXT := 8ff; fi:Prop:(ff$fi) ! (ff = Prop fi); where ff$fi denotes (ff!fi)&(fi!ff) and = Prop denotes the Leibniz equality on Prop, ff = Prop fi :j 8P :Prop!Prop:P ff!P fi.
Reference: [Berardi 199+] <author> S. Berardi, </author> <title> Encoding of data types in Pure Construction Calculus: a semantic justification. </title> <booktitle> To appear in the Proceedings of the second BRA meeting on Logical Frameworks, </booktitle> <address> Edinburgh, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: For details and proofs we refer to <ref> [Berardi 199+] </ref>. The point is that for purposes of deriving programs from proofs, it doesn't seem to make sense to declare a theory in the context. Instead one uses the definable impredicative data types and inductive predicates on them, as is done in the examples of 3.4. <p> EXT ! 9x:Nat:Sx = Nat x (see the second proof of Proposition 4.12) and Ind Nat &(Z 6= Nat SZ) ! 8x; y:Nat:(Sx = Nat Sy)!(x = Nat y) (see Example 3.3.)) First we have to consider only the strongest version of inductive data types, called parametric data types in <ref> [Berardi 199+] </ref>. <p> For example Nat fi Nat and 2 Nat fi List of the Examples in 3.4 are inductive predicates.) In <ref> [Berardi 199+] </ref> all this is defined in set-theoretic terms and then translated into CC. As is done there, we shall not denote this translation explicitly (but there are no ambiguities about this.) The main result of [Berardi 199+] is now saying that for ' a proposition in the set Pos, if <p> and 2 Nat fi List of the Examples in 3.4 are inductive predicates.) In <ref> [Berardi 199+] </ref> all this is defined in set-theoretic terms and then translated into CC. As is done there, we shall not denote this translation explicitly (but there are no ambiguities about this.) The main result of [Berardi 199+] is now saying that for ' a proposition in the set Pos, if ` M :' in CC for some term M , and is satisfied in the model PER, then ' is provable in Set theory. <p> Here PER is some model based on the interpretation of propositions of CC as partial equivalence realtions on fl (the set of untyped lambda terms.) The model-construction is in <ref> [Berardi 199+] </ref>; we will not go into it here but state the important facts that for all parametric data type D, the interpretation of Ind D in PER is not empty, which means that z:Ind D is satisfied. <p> n ; a:Ind Nat ; b:Z 6= Nat SZ ` P : ', where D 1 ; : : :; D n are the parametric data types that occur in '. (We omit the mapping H for reasons of readability.) In view of the proof of the original result in <ref> [Berardi 199+] </ref>, we have a strong feeling that this adapted completeness of the formulas-as-types embedding from PRED! p into CC holds. However, it is not as general as the original result; one would like to allow more assumptions then just those stating the parametricity of the data types.
Reference: [Bohm and Berarducci 1985] <author> C. Bohm and A. Berarducci, </author> <title> Automatic synthesis of typed fl-programs on term algebras Theor. </title> <journal> Comput. Science, </journal> <volume> 39, </volume> <pages> pp 135-154. </pages>
Reference-contexts: We feel this is necessary for a good understanding of the system. Details of the encoding can be found in <ref> [Bohm and Berarducci 1985] </ref> 13 and [Girard et al. 1989].
Reference: [de Bruijn 1980] <author> N.G. de Bruijn, </author> <title> A survey of the project Automath, </title> <editor> In J.P. Seldin, J.R. Hindley, eds. </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <pages> pp 580-606. </pages>
Reference: [CC-documentation] <institution> The Calculus of Constructions, </institution> <note> documentation and users guide, version 4.10, Technical report, INRIA, </note> <month> August </month> <year> 1989. </year>
Reference-contexts: the collection of all domains), is inconsistent, which was the original statement referred to as `Girard's paradox'. (For details about the paradox see [Coquand 1986].) It is not so difficult to see that the extension of HOPL with only the rule (Type s ; Prop) is consistent, but only in <ref> [CC-documentation] </ref> it is shown by Coquand that the system U is inconsistent, which was left as an open question in [Girard 1972]. The proof by Coquand is done by internalising Reynolds result about the non-existence of a set-theoretic model for the polymorphic lambda calculus.
Reference: [Church 1940] <author> A. Church, </author> <title> A formulation of the simple theory of types J. </title> <journal> Symbolic Logic, </journal> <volume> 5, </volume> <pages> pp 56-68. </pages>
Reference-contexts: Finally we discuss some variants and extensions of the system. 2 Higher Order Predicate Logic as a typed lambda calculus In the literature there are several systems of higher order predicate logic (e.g. <ref> [Church 1940] </ref>, [Takeuti 1975], [Schutte 1977] and [Lambek and Scott 1986]), most of them aiming at the formalisation of higher order arithmetic. <p> Let's now say something about the relations between HOPL and the definitions of higher order predicate logic in <ref> [Church 1940] </ref>, [Takeuti 1975], [Schutte 1977] and [Lambek and Scott 1986]. We try to restrict to the essential differences and not go into issues of notation. <p> The way we introduce the 8 oe (as constants of the language of type (oe!)!) is like in <ref> [Church 1940] </ref>. This is also the only version that formalises classical logic. It should be remarked here that Lambek and Scott do suggest the extension of the domains to include all arrow domains as a `seemingly stronger version' of the theory. <p> This is very similar to [Takeuti 1975], [Schutte 1977] and <ref> [Church 1940] </ref>. (In the latter this is not explicitly noted as a feature of the system.) In [Lambek and Scott 1986] comprehension has to be explicitly included as an axiom because, unlike the other systems, predicates and functions can not be formed by (-)abstraction.
Reference: [Coquand 1985] <author> Th. Coquand, </author> <title> Une theorie des constructions, </title> <institution> These de troisieme cycle, Universite Paris VII, France. </institution>
Reference-contexts: In the examples we already came accross the normalization property. Theorem 3.5 CC is strongly normalizing. (All fi-reduction sequences starting from an M 2 TERM (CC) are finite.) A first proof of this theorem can be found in <ref> [Coquand 1985] </ref>, but the proof contained a bug as remarked by Jutting, who then gave a proof of normalization for CC. (That is, every M 2 TERM (CC) reduces to a term in normal form.) Coquand repaired his own proof in a preliminary version of [Coquand 1990]. <p> If such a term A exists, it can be computed effectively. Some hints towards a proof can be found in [Coquand and Huet 1988] and more details in <ref> [Coquand 1985] </ref> and especially in [Martin-Lof 1971]. <p> In fact this is the whole reason for introducing PRED! here. In fact there are different ways of interpreting HOPL in CC, but the one we describe here is what the inventor (s) of CC aim at (see <ref> [Coquand 1985] </ref> and [Coquand and Huet 1988]), and which is sometimes called the `canonical embedding' of higher order predicate logic into CC. In our setting this canonicity is partly forced upon by the syntax, therefore it is worthwile to also understand the embedding from a more semantical point of view.
Reference: [Coquand 1986] <author> Th. Coquand, </author> <title> An analysis of Girard's paradox, </title> <booktitle> Proceedings of the first symposium on Logic in Computer Science, </booktitle> <address> Cambridge Mass., </address> <publisher> IEEE, </publisher> <pages> pp 227-236. </pages>
Reference-contexts: There it is also shown that the system U , which is U extended with the rule (Type s ; Prop) (quantification over the collection of all domains), is inconsistent, which was the original statement referred to as `Girard's paradox'. (For details about the paradox see <ref> [Coquand 1986] </ref>.) It is not so difficult to see that the extension of HOPL with only the rule (Type s ; Prop) is consistent, but only in [CC-documentation] it is shown by Coquand that the system U is inconsistent, which was left as an open question in [Girard 1972]. <p> Similarly one can't allow an impredicative -type like ff:Prop:' : Prop. This means it is not possible, as can be done in the first order case, to represent the higher order existential quantification by a -type. See <ref> [Coquand 1986] </ref> for a discussion on inconsistent extensions of CC, and [Harper and Pollack 1991] for a description of CC ! , CC extended with universes and universe inclusion. As a final extension of CC we want to point at the possibility of adding inductive types to the system.
Reference: [Coquand 1990] <author> Th. Coquand, </author> <title> Metamathematical investigations of a calculus of constructions. </title> <booktitle> In Logic and Computer Science, </booktitle> <editor> ed. P.G. Odifreddi, </editor> <booktitle> APIC series, </booktitle> <volume> vol. 31, </volume> <publisher> Academic Press, </publisher> <pages> pp 91-122. </pages>
Reference-contexts: theorem can be found in [Coquand 1985], but the proof contained a bug as remarked by Jutting, who then gave a proof of normalization for CC. (That is, every M 2 TERM (CC) reduces to a term in normal form.) Coquand repaired his own proof in a preliminary version of <ref> [Coquand 1990] </ref>. <p> is not complete (CC proves more propositions than PRED!), one may wonder whether there are propositions that CC can not prove, or to put the question differently, is CC consistent? That this is the case can be shown quite easily by giving a two-point model for CC. (Originally due to <ref> [Coquand 1990] </ref>.) The type Prop is interpreted as f;; f;gg (or f0; 1g in ZF language) and if ` M : A, the interpretation of M is in the set A. This model is called the `proof-irrelevance' model in [Coquand 1990] because in the model all proofs of a proposition are <p> easily by giving a two-point model for CC. (Originally due to <ref> [Coquand 1990] </ref>.) The type Prop is interpreted as f;; f;gg (or f0; 1g in ZF language) and if ` M : A, the interpretation of M is in the set A. This model is called the `proof-irrelevance' model in [Coquand 1990] because in the model all proofs of a proposition are mapped to 0; the model doesn't distinguish between proofs. So the model also implies that in CC one can not prove a 6= A a 0 (for ` a; a 0 : A) in the empty context. <p> higher order propositional logic.) We sketch here a short proof of the consistency of PROP! by constructing the promised two point model, which is (by Proposition 4.5) also a model of CC. (It is not so easy to construct the model immediately for CC, a problem that is solved in <ref> [Coquand 1990] </ref> by describing the model for a variant of CC that we shall discuss in 6.3. Here we use the mapping [] from CC to PROP! for this purpose.) Before constructing the model we want to state some properties of PROP! that will be used. <p> In [Seldin 1990] one can find a detailed proof of the consistency of a context that represents Peano Arithmetic in a system that is a slight extension of CC. Coquand shows in <ref> [Coquand 1990] </ref> by a normalization argument that the context Inf = A:Prop; a:A; f :A!A; R:A!A!Prop z 1 :8x:A:(Rxx)!?; z 2 :8x; y; z:A:Rxy!Ryz!Rxz; z 3 :8x:A:Rx (f x) is consistent. When contexts become larger, a consistency proof by the normalization argument can of course get very involved. <p> (<ref> [Coquand 1990] </ref>), showing that CC with classical logic and a derivation rule for a strong version of disjoint sum yields proof irrelevance. Let's also state this result, but not by adding a derivation rule but by adding an axiom, which really amounts to the same as the rule used in [Coquand 1990]. (Using the result by Reynolds that polymorphism is not set-theoretic, Berardi has proved that in CC, classical logic with a stronger form of definite descriptions (replacing the 9! by 9) implies PI. See [LEGO-examples] for details.) Proposition 4.14 [Coquand 1990] `Classical logic' with `disjunction property for classical proofs' implies <p> really amounts to the same as the rule used in <ref> [Coquand 1990] </ref>. (Using the result by Reynolds that polymorphism is not set-theoretic, Berardi has proved that in CC, classical logic with a stronger form of definite descriptions (replacing the 9! by 9) implies PI. See [LEGO-examples] for details.) Proposition 4.14 [Coquand 1990] `Classical logic' with `disjunction property for classical proofs' implies proof irrelevance in CC. <p> In presence of CL also the reverse can be proved, so we can construct a proof p with cl:CL ` p : P I $ (8ff:Prop:(ff + :ff)(clff)): The implication from right to left is the most interesting. The proof (in <ref> [Coquand 1990] </ref>) uses the fact that if in one can construct A : Prop, E : A!Prop, * : Prop!A and a proof of 8ff:Prop:ff $ E (*ff), then proves ?. 5 Formulas about data-types in CC Having seen the incompleteness of the formulas-as-types embedding of higher order predicate logic in <p> Strong normalization of fij-reduction for CC with fij-conversion can be proved by adapting the proof for the fi-case in [Geuvers and Nederhof 1991]. In <ref> [Coquand 1990] </ref> and in [Streicher 1988] the syntax is built up more explicitly using a T -operator. This is done for semantical reasons (the latter therefore discusses even more explicit versions of the calculus), to be better able to describe the interpretation of the syntax in the model. <p> x:A:B representing the type of pairs ha; bi with b:B [a=x]; there are projections 1 : (x:A:B)!A and 2 : z:(x:A:B):B [ 1 z=x]. (These projections distinguish the `strong' Sigma types from weaker versions with different elimination rules.) The Sigma types are well-known to be useful for describing theories (see <ref> [Coquand 1990] </ref> for a discussion), especially in combination with universes (ECC has sorts (universes) Type i for all natural numbers i with the axiom Type i : Type i+1 (the Type of CC is just Type 0 ) and further an inclusion rule for these universes: if ` A : Type
Reference: [Coquand and Huet 1988] <author> Th. Coquand and G. Huet, </author> <title> The calculus of constructions, </title> <journal> Information and Computation, </journal> <volume> 76, </volume> <pages> pp 95-120. </pages>
Reference-contexts: Application, -abstraction and conversion serve as tools for handling the basic mathematical manipulations like function application, function definition and substitution. Although the Calculus of Constructions can serve perfectly well as an Automath-like logical framework, from the literature about the system ([Coquand 1985], <ref> [Coquand and Huet 1988] </ref>) it clearly shows that the inventors aim at the formulas-as-types embedding in the first sense. In this paper we shall therefore look at the Curry-Howard formulas-as-types embedding of higher order predicate logic into CC. <p> There is however also the possibility to restrict the conversion rule of CC, such that only some convertible propositions are identified. (A system like this is described in <ref> [Coquand and Huet 1988] </ref>.) It should be clear that in any of the two approaches the distinction between domains, objects and proofs is blurred: propositions may contain proofs and there is no a priori distinction between domains and propositions. <p> Theorem 3.6 Given a context and a pseudoterm M , it is decidable whether there exists a term A with ` M : A. If such a term A exists, it can be computed effectively. Some hints towards a proof can be found in <ref> [Coquand and Huet 1988] </ref> and more details in [Coquand 1985] and especially in [Martin-Lof 1971]. <p> In fact this is the whole reason for introducing PRED! here. In fact there are different ways of interpreting HOPL in CC, but the one we describe here is what the inventor (s) of CC aim at (see [Coquand 1985] and <ref> [Coquand and Huet 1988] </ref>), and which is sometimes called the `canonical embedding' of higher order predicate logic into CC. In our setting this canonicity is partly forced upon by the syntax, therefore it is worthwile to also understand the embedding from a more semantical point of view. <p> This may be solved by representing variables with De Bruijn indices ([de Bruijn 1980]). An extended exposition about this technique for the case of CC is in <ref> [Coquand and Huet 1988] </ref>. Another practical issue is how to introduce definitions: To release the burden of writing the same -term several times and for reasons of readability one wants to abbreviate terms by a smaller expression that can replace it.
Reference: [Coquand and Mohring 1990] <author> Th. Coquand and Ch. </author> <title> Paulin-Mohring Inductively defined types, </title> <editor> In P. Martin-Lof and G. Mints editors. </editor> <booktitle> COLOG-88 : International conference on computer logic, </booktitle> <publisher> LNCS 417. </publisher>
Reference-contexts: The problem of the inefficiency of recursion over data types already appears in system F and therefore a the suggested extensions to system F can immediately be adapted to CC. (For example the ones in [Mendler 1987] or [Parigot 1992].) An essentially different approach is taken in <ref> [Coquand and Mohring 1990] </ref>, where inductive types as well as inductive predicates can be constructed by a scheme and the scheme not only allows to define functions by recursion, but also to do proofs by induction. The latter system is implemented as `Coq'. (See [Dowek e.a. 1991].)
Reference: [Dowek e.a. 1991] <author> G. Dowek, A. Felty, H. Herbelin, G. Huet, Ch. Paulin-Mohring, B. Werner, </author> <title> The Coq proof assistant version 5.6, user's guide. </title> <institution> INRIA Rocquencourt - CNRS ENS Lyon. </institution>
Reference-contexts: The latter system is implemented as `Coq'. (See <ref> [Dowek e.a. 1991] </ref>.)
Reference: [Geuvers 1989] <author> J.H. </author> <title> Geuvers, Talk given at the `Jumelage meeting on typed lambda calculus', </title> <publisher> Edinburgh, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: In CC, take M j z:(9x:A:P x):y:(A!'):y (px), with p as in Remark 4.10. Also without using empty domains the embedding is not complete, as was first independently shown by [Berardi 1989] and <ref> [Geuvers 1989] </ref>. <p> Proposition 4.12 The formulas-as-types embedding of higher order predicate logic into CC is not complete. Proof <ref> [Geuvers 1989] </ref> We use the fact that if x =2 FV ('), then 8x:A:' and A oe ' can not be distinguished in CC. Take := A:Set; a:A; ':Prop; ff:Prop!Prop; z:P (8x:A:'); and we try to find a proof t of 9fi:Prop:P (fi!').
Reference: [Geuvers and Nederhof 1991] <author> J.H. Geuvers and M.J. Nederhof, </author> <title> A modular proof of strong normalisation for the calculus of constructions. </title> <journal> Journal of Functional Programming, </journal> <volume> vol 1 (2), </volume> <pages> pp 155-189. </pages>
Reference-contexts: We shall not go into details about meta theory nor do we give a list of examples of systems in the form of a PTS but refer to [Barendregt 199+] and <ref> [Geuvers and Nederhof 1991] </ref>. Here we just repeat the definition and the main meta-theoretic properties. <p> A practical purpose for the use of the PTS framework is that many properties can be proved once and for all for the whole class of PTSs. We list the most important ones. (Proofs can be found in <ref> [Geuvers and Nederhof 1991] </ref> 9 or [Barendregt 199+]. <p> A detailed explanation of the method can be found in [Gallier 1990]. It is also possible to obtain the strong normalisation for CC more or less directly from the strong normalisation property of F ! , as is shown in <ref> [Geuvers and Nederhof 1991] </ref>. <p> Typeg.) ` A : s; 0 ` A : s 0 ) s j s 0 ; This property is valid for a whole class of Pure Type Systems (provided we have made the sketched alterations to the syntax), which covers all PTSs that are used in this paper. (See <ref> [Geuvers and Nederhof 1991] </ref> for more details.) The mapping [] straightforwardly extends to contexts. <p> Strong normalization of fij-reduction for CC with fij-conversion can be proved by adapting the proof for the fi-case in <ref> [Geuvers and Nederhof 1991] </ref>. In [Coquand 1990] and in [Streicher 1988] the syntax is built up more explicitly using a T -operator.
Reference: [Geuvers 1992] <author> J.H. </author> <title> Geuvers, The Church-Rosser property for fij-reduction in typed lambda calculi. </title> <booktitle> Proceedings of the seventh annual symposium on Logic in Computer Science, </booktitle> <address> Santa Cruz, </address> <publisher> Cal., IEEE, </publisher> <pages> pp 453-460. 37 </pages>
Reference-contexts: Church-Rosser property holds for the set of typable terms of a fixed type in a fixed context; this suffices to prove the equivalence as in Theorem 6.2.) A discussion of and a solution to the problem of Church-Rosser (of fij-reduction) for CC with fij-conversion can be found in [Salvesen1991] and <ref> [Geuvers 1992] </ref>, the first proving the property for the semantical version of CC and the second proving Church-Rosser for the syntactical version of CC (and hence the equivalence of the two versions.) Both proofs rely on the assumption that fij-reduction is normalizing and in both cases the proof is given for
Reference: [Gallier 1990] <editor> On Girard's "Candidats de Reductibilite". </editor> <booktitle> In Logic and Computer Science, </booktitle> <editor> ed. P.G. Odifreddi, </editor> <booktitle> APIC series, </booktitle> <volume> vol. 31, </volume> <publisher> Academic Press, </publisher> <pages> pp 123-204. </pages>
Reference-contexts: A detailed explanation of the method can be found in <ref> [Gallier 1990] </ref>. It is also possible to obtain the strong normalisation for CC more or less directly from the strong normalisation property of F ! , as is shown in [Geuvers and Nederhof 1991].
Reference: [Girard 1972] <author> J.-Y. Girard, </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieur. </title> <type> Ph.D. thesis, </type> <institution> Universite Paris VII, France. </institution>
Reference-contexts: We call this system U , in analogy with <ref> [Girard 1972] </ref>, where the same system formulated as a logic is 30 called U . <p> the paradox see [Coquand 1986].) It is not so difficult to see that the extension of HOPL with only the rule (Type s ; Prop) is consistent, but only in [CC-documentation] it is shown by Coquand that the system U is inconsistent, which was left as an open question in <ref> [Girard 1972] </ref>. The proof by Coquand is done by internalising Reynolds result about the non-existence of a set-theoretic model for the polymorphic lambda calculus.
Reference: [Girard 1986] <author> J.-Y. Girard, </author> <title> The system F of variable types, fifteen years later. </title> <journal> TCS 45, </journal> <pages> pp 159-192. </pages>
Reference: [Girard et al. 1989] <author> J.-Y. Girard, Y. Lafont and P. Taylor, </author> <title> Proofs and types, Camb. </title> <booktitle> Tracts in Theoretical Computer Science 7, </booktitle> <publisher> Cambridge University Press. </publisher>
Reference-contexts: We feel this is necessary for a good understanding of the system. Details of the encoding can be found in [Bohm and Berarducci 1985] 13 and <ref> [Girard et al. 1989] </ref>. First we define the polymorphic lambda calculus (Gi- rard's system F) as the Pure Type System with S = Prop; Type; A = Prop : Type; R = (Prop; Prop); (Type; Prop): This is a polymorphic language for the typing of functional programs. <p> All proofs use a higher order variant of the `candidat de reducibilite' method as developped by Girard for proving strong normalisation for his system F and F ! . (See <ref> [Girard et al. 1989] </ref> for the proof for system F.) The idea is to define a kind of realisability model in which propositions are interpreted as sets of lambda terms (the realisers). A detailed explanation of the method can be found in [Gallier 1990].
Reference: [Harper and Pollack 1991] <author> R. Harper and R. Pollack, </author> <title> Type checking with universes, </title> <journal> TCS 89, </journal> <pages> pp 107-136. </pages>
Reference-contexts: If such a term A exists, it can be computed effectively. Some hints towards a proof can be found in [Coquand and Huet 1988] and more details in [Coquand 1985] and especially in [Martin-Lof 1971]. See also <ref> [Harper and Pollack 1991] </ref> for an exposition on the decidability of typing for an extended version of CC, which also describes an algorithm for computing a type. 17 4 The formulas-as-types embedding from higher or- der predicate logic into CC The Curry-Howard embedding from higher order predicate logic into CC makes <p> Similarly one can't allow an impredicative -type like ff:Prop:' : Prop. This means it is not possible, as can be done in the first order case, to represent the higher order existential quantification by a -type. See [Coquand 1986] for a discussion on inconsistent extensions of CC, and <ref> [Harper and Pollack 1991] </ref> for a description of CC ! , CC extended with universes and universe inclusion. As a final extension of CC we want to point at the possibility of adding inductive types to the system.
Reference: [Howard 1980] <author> W.A. Howard, </author> <title> The formulas-as-types notion of construction. In To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </title> <editor> eds. J.P. Seldin, J.R. Hindley, </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <pages> pp 479-490. </pages>
Reference-contexts: 1 Introduction The so called Curry-Howard formulas-as-types embedding provides a formalization of the Brouwer-Heyting-Kolmogorov understanding of proofs as constructions. (See [Troelstra and Van Dalen 1988].) The first detailed description is in <ref> [Howard 1980] </ref>, where also the terminology `formulas-as-types' is first used. <p> In view of the last point it would be correct to associate also Tait with 1 the formulas-as-types notion, as his ([Tait 1965])`discovery of the close corre-spondence between cut elimination and reduction of -terms provided half of the motivation' for <ref> [Howard 1980] </ref>. Also De Bruijn is often associated to the formulas-as-types notion, because the Automath project which was founded by De Bruijn, was the first to rigorously interpret mathematical structures and propositions as types and objects and proofs as -terms.
Reference: [Hyland and Pitts 1988] <editor> The theory of constructions: </editor> <title> categorical semantics and topos-theoretic models. </title> <booktitle> In Categories in computer science and logic, Proc. of the AMS Research Conference, Boulder, </booktitle> <editor> Col., eds. J.W. </editor> <title> Gray and A.S. Scedrov, </title> <journal> Contemporary Math., </journal> <volume> vol 92, </volume> <publisher> AMS, </publisher> <pages> pp 137-199. </pages>
Reference: [Lambek and Scott 1986] <author> J. Lambek and P.J. Scott, </author> <title> Introduction to higher order Categorical Logic, </title> <booktitle> Cambridge studies in advanced mathematics 7, Camb. </booktitle> <address> Univ.Press. </address>
Reference-contexts: Finally we discuss some variants and extensions of the system. 2 Higher Order Predicate Logic as a typed lambda calculus In the literature there are several systems of higher order predicate logic (e.g. [Church 1940], [Takeuti 1975], [Schutte 1977] and <ref> [Lambek and Scott 1986] </ref>), most of them aiming at the formalisation of higher order arithmetic. <p> Let's now say something about the relations between HOPL and the definitions of higher order predicate logic in [Church 1940], [Takeuti 1975], [Schutte 1977] and <ref> [Lambek and Scott 1986] </ref>. We try to restrict to the essential differences and not go into issues of notation. <p> them start from two basic domains (usually called types), i and o, letting oe 1 fi fi oe n !o be a type if oe 1 ; ; oe n are types, with o representing the type of formulas. (In [Takeuti 1975] the type o doesn't have an explicit name, <ref> [Lambek and Scott 1986] </ref> also have the `singleton type' 1 as base type and a more fine grained syntax for types, allowing oe 1 fi fi oe n and oe!o (denoted by P oe) for oe 1 ; ; oe n ; oe types.) Only Church allows all arrow types, where <p> The derivation rules are given in various ways (sequent calculus, natural deduction or with inference rules and axioms.) Our formulation is closest to <ref> [Lambek and Scott 1986] </ref>. Most of the systems have in addition to the derivation rules a list of axioms to include (among other things) arithmetic, extensionality and comprehension. <p> This is very similar to [Takeuti 1975], [Schutte 1977] and [Church 1940]. (In the latter this is not explicitly noted as a feature of the system.) In <ref> [Lambek and Scott 1986] </ref> comprehension has to be explicitly included as an axiom because, unlike the other systems, predicates and functions can not be formed by (-)abstraction.
Reference: [LEGO-examples] <author> R. Pollack and others, </author> <title> Examples of formalised proofs in LEGO, </title> <publisher> Edinburgh. </publisher>
Reference-contexts: See <ref> [LEGO-examples] </ref> for details.) Proposition 4.14 [Coquand 1990] `Classical logic' with `disjunction property for classical proofs' implies proof irrelevance in CC.
Reference: [Luo 1989] <author> Z. Luo, </author> <title> ECC: An extended Calculus of Constructions. </title> <booktitle> Proc. of the fourth ann. symp. on Logic in Comp. Science, Asilomar, Cal. IEEE, </booktitle> <pages> pp 386-395. </pages>
Reference-contexts: that the mapping back yields the derivation we started with. 6.4 Further extensions There are many other extensions and variations for CC in the literature that we want to discuss in some short detail. (Most of them are treated extensively in other texts.) First there is the system ECC of <ref> [Luo 1989] </ref>, which is an extension of CC with strong Sigma types, universes and universe inclusion.
Reference: [Martin-Lof 1971] <author> P. Martin-Lof, </author> <title> A theory of types, </title> <type> manuscript, </type> <month> October </month> <year> 1971. </year>
Reference-contexts: If such a term A exists, it can be computed effectively. Some hints towards a proof can be found in [Coquand and Huet 1988] and more details in [Coquand 1985] and especially in <ref> [Martin-Lof 1971] </ref>.
Reference: [Martin-Lof 1984] <author> P. Martin-Lof, </author> <title> Intuitionistic Type Theory, Studies in Proof theory, </title> <publisher> Bibliopolis, Napoli. </publisher>
Reference-contexts: First we show that if one allows empty domains in the logic, the incompleteness is quite easy. Remark 4.10 In CC, the existential quantifier has a first projection, similar to Martin-Lof 's understanding of the existential quantifier as a strong -type. (See e.g. <ref> [Martin-Lof 1984] </ref>.) To be precise, there is a projection function p : (9x:A:')!A, for A; ':Prop in CC: Remember that 9x:A:' j ff:Prop:(x:A:'!ff)!ff and take p :j z:(9x:A:'):zA (x:A:y:':x). So, if 9x:A:' is provable one immediately obtains a closed term of type A by applying p.
Reference: [Mendler 1987] <author> N.P. Mendler, </author> <title> Inductive types and type constraints in second-order lambda calculus. </title> <booktitle> Proceedings of the Second Symposium of Logic in Computer Science. </booktitle> <address> Ithaca, N.Y., </address> <publisher> IEEE, </publisher> <pages> pp 30-36. </pages>
Reference-contexts: The problem of the inefficiency of recursion over data types already appears in system F and therefore a the suggested extensions to system F can immediately be adapted to CC. (For example the ones in <ref> [Mendler 1987] </ref> or [Parigot 1992].) An essentially different approach is taken in [Coquand and Mohring 1990], where inductive types as well as inductive predicates can be constructed by a scheme and the scheme not only allows to define functions by recursion, but also to do proofs by induction.
Reference: [Mohring 1986] <author> Ch. Mohring, </author> <title> Algorithm development in the calculus of constructions. </title> <booktitle> In Proceedings of the first symposium on Logic in Computer Science, </booktitle> <address> Cambridge, Mass. </address> <publisher> IEEE, </publisher> <pages> pp 84-91. 38 </pages>
Reference: [Nederpelt 1973] <author> R.P. </author> <title> Nederpelt, Strong normalization in a typed lambda calculus with lambda structured types. </title> <type> Ph.D. thesis, </type> <institution> Eindhoven Technological University, The Netherlands. </institution>
Reference-contexts: The equivalence of the two versions follows from the Church-Rosser property for typable terms in CC with (conv fij ). However, with fij-reduction the Church-Rosser property on the pseudoterms T is invalid. (The well-known counterexample is due to <ref> [Nederpelt 1973] </ref>: For A 6= fij B and x =2 FV (M ), x:A:(y:B:M y)x can be reduced by a fi step and an j step to two terms that have no common reduct.) This complicates matters quite a lot because some meta theorems depend on the Church-Rosser property (normalization proofs
Reference: [Paulin 1989] <author> Ch. Paulin-Mohring, </author> <title> Extraction des programmes dans le calcul des constructions, </title> <institution> These, Universite Paris VII, France. </institution>
Reference-contexts: To understand this result, we have to devote some attention to data types and specifications in CC, a subject extensively studied in e.g. <ref> [Paulin 1989] </ref>. <p> constructive logic in which one can represent specifications as formulas (about data types.) From a proof of the formula the constructive content can then be extracted as a program (more precisely a lambda term typable in F ! .) A lot of work on this subject has been done in <ref> [Paulin 1989] </ref>; we shall say a little bit more about this in Section 5. <p> A lot of work has been done in this field by Paulin. (See <ref> [Paulin 1989] </ref>.) In 5 we shall give an example to get an idea of the strength of the formalism. 4.1 Consistency of CC As the described embedding from PRED! into CC is not complete (CC proves more propositions than PRED!), one may wonder whether there are propositions that CC can not <p> As this is an 19 introductory text we shall make the model construction a bit more precise here, in the meantime obtaining the result that CC is conservative over PROP!. (A result first proved by Paulin (see <ref> [Paulin 1989] </ref>) and independently due to Berardi ([Berardi 1988]).) Definition 4.3 Define the mapping [] : TERM (CC) ! TERM (PROP!) as follows. [Type] = Type; [Prop] = Prop; [x] = x; for x a variable; [x:A:B] = [B] if A:Prop; B:Type; = x:[A]:[B] else; [x:A:M ] = [M ] if <p> The following can be proved by an easy induction on derivations. (` CC denotes derivability in CC, ` PROP! denotes derivability in PROP!.) Proposition 4.5 <ref> [Paulin 1989, Berardi 1988] </ref> ` CC M : A ) [] ` PROP! [M ] : [A] 20 Corollary 4.6 [Paulin 1989, Berardi 1988]) CC is conservative over PROP! Proof The only thing to check is that for M 2 TERM (PROP!), [M ] j M . <p> The following can be proved by an easy induction on derivations. (` CC denotes derivability in CC, ` PROP! denotes derivability in PROP!.) Proposition 4.5 <ref> [Paulin 1989, Berardi 1988] </ref> ` CC M : A ) [] ` PROP! [M ] : [A] 20 Corollary 4.6 [Paulin 1989, Berardi 1988]) CC is conservative over PROP! Proof The only thing to check is that for M 2 TERM (PROP!), [M ] j M . <p> Instead one uses the definable impredicative data types and inductive predicates on them, as is done in the examples of 3.4. This is not the place to discuss in detail the topic of extracting programs from proofs in CC, for which we refer to <ref> [Paulin 1989] </ref>, but to get some flavor we do want to treat the first example of 3.4. Roughly, the program extracted from the proof is the F omega -term obtained by the mapping [], as defined in Definition 4.3. Let's consider the first example of 3.4. <p> Of course it is not irrelevant what we substitute for a, but the general picture should be clear: From the proof of the specification one can obtain the program that staisfies the specification. In <ref> [Paulin 1989] </ref> it is also shown how to extract from the proof the logical content which is a proof that the extracted program satisfies the specification. Some parts of the proof have computational content while others don't. Therefore, to mechanize the extraction proces, in [Paulin 1989] the type Prop is divided <p> In <ref> [Paulin 1989] </ref> it is also shown how to extract from the proof the logical content which is a proof that the extracted program satisfies the specification. Some parts of the proof have computational content while others don't. Therefore, to mechanize the extraction proces, in [Paulin 1989] the type Prop is divided in Prop, Data and Spec, the first consisting of the propositions with purely logical content, the second consisting of the propositions with purely computaional content and the third consisting of propositions containing both logical and computaional content.
Reference: [Parigot 1992] <author> M. Parigot, </author> <title> Recursive programming with proofs. </title> <booktitle> Theor. Comp. Science 94, </booktitle> <pages> pp 335-356. </pages>
Reference-contexts: The problem of the inefficiency of recursion over data types already appears in system F and therefore a the suggested extensions to system F can immediately be adapted to CC. (For example the ones in [Mendler 1987] or <ref> [Parigot 1992] </ref>.) An essentially different approach is taken in [Coquand and Mohring 1990], where inductive types as well as inductive predicates can be constructed by a scheme and the scheme not only allows to define functions by recursion, but also to do proofs by induction.
Reference: [Pollack 1989] <author> R. Pollack, </author> <title> Talk given at the `Jumelage meeting on typed lambda calculus', </title> <publisher> Edinburgh, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: In the syntax this can be done by introducing some extra rules for introducing variables as abbreviations as follows (we follow <ref> [Pollack 1989] </ref>.) (def var) ; x = M ` x : A if x doesn't occur free in (def ) ; hx = M i ` hx = M i : hx = M iB with the extra reduction rules hx = M iN ! ffi N; if x =2 (FV
Reference: [Pottinger 1989] <author> G. Pottinger, </author> <title> Definite descriptions and excluded middle in the theory of constructions, TYPES network, </title> <month> November </month> <year> 1989. </year>
Reference-contexts: An example of this is the axiom of definite descriptions as described in <ref> [Pottinger 1989] </ref>, DD := 8ff:Prop:8P :ff!Prop:8z:(9!x:ff:P x):P (ffP z); where 9!x:ff:P x := (9x:ff:P x)&(8x; y:ff:P x!P y!(x = ff y)) and is a term of type 8ff:Prop:8P :ff!Prop:(9!x:ff:P x)!ff. (One can take some fixed closed term for but also declare it as variable in the context.) We assume the intended <p> Together with classical logic, the axiom of definite descriptions has an unexpected side-effect in CC. Proposition 4.13 <ref> [Pottinger 1989] </ref> `Classical logic' and `definite descriptions' yield proof irrelevance in CC We have already encountered the semantical notion of proof irrelevance in the discussion of the model in 4.7. <p> Because of the treatment of domains and propositions at the same level, principles about (proofs of) propositions have unwanted applications to the domains. The proof of Proposition 4.13 in <ref> [Pottinger 1989] </ref> uses an adapted form of a proof by Coquand ([Coquand 1990]), showing that CC with classical logic and a derivation rule for a strong version of disjoint sum yields proof irrelevance.
Reference: [Salvesen1991] <author> A. Salvesen, </author> <title> The Church-Rosser property for fij-reduction, </title> <type> manuscript. </type>
Reference-contexts: that the Church-Rosser property holds for the set of typable terms of a fixed type in a fixed context; this suffices to prove the equivalence as in Theorem 6.2.) A discussion of and a solution to the problem of Church-Rosser (of fij-reduction) for CC with fij-conversion can be found in <ref> [Salvesen1991] </ref> and [Geuvers 1992], the first proving the property for the semantical version of CC and the second proving Church-Rosser for the syntactical version of CC (and hence the equivalence of the two versions.) Both proofs rely on the assumption that fij-reduction is normalizing and in both cases the proof is
Reference: [Scedrov 1990] <editor> A guide to polymorphic types. </editor> <booktitle> In Logic and Computer Science, </booktitle> <editor> ed. P.G. Odifreddi, </editor> <booktitle> APIC series, </booktitle> <volume> vol. 31, </volume> <publisher> Academic Press, </publisher> <pages> pp 387-420. </pages>
Reference-contexts: To get the picture clear we discuss the variant of CC with equality judgement and state the important properties. (The syntax is very close to the one given in <ref> [Scedrov 1990] </ref>, where also a semantics for this system is discussed.) Definition 6.1 The system CC = is a typed lambda calculus with a typing judgement and an equality judgement.
Reference: [Seldin 1990] <author> J. Seldin, </author> <title> Excluded middle without definite descriptions in the theory of constructions, TYPES network, </title> <month> September </month> <year> 1990. </year>
Reference-contexts: Contexts of this kind are called strongly consistent in <ref> [Seldin 1990] </ref>. To verify the consistency we let = x 1 :A 1 ; : : : ; x n :A n be a strongly consistent context and suppose that ` M : ? for some M . <p> These kind of contexts have to be handled by a normalization argument; assuming the inconsistency of HA , show that a proof of ? in HA can not be in normal form, and so there is no such proof. In <ref> [Seldin 1990] </ref> one can find a detailed proof of the consistency of a context that represents Peano Arithmetic in a system that is a slight extension of CC.
Reference: [Schutte 1977] <author> K. Schutte, </author> <title> Proof Theory, Grundlehren der mathematischen Wissenschaften 225, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Finally we discuss some variants and extensions of the system. 2 Higher Order Predicate Logic as a typed lambda calculus In the literature there are several systems of higher order predicate logic (e.g. [Church 1940], [Takeuti 1975], <ref> [Schutte 1977] </ref> and [Lambek and Scott 1986]), most of them aiming at the formalisation of higher order arithmetic. <p> Let's now say something about the relations between HOPL and the definitions of higher order predicate logic in [Church 1940], [Takeuti 1975], <ref> [Schutte 1977] </ref> and [Lambek and Scott 1986]. We try to restrict to the essential differences and not go into issues of notation. <p> This is very similar to [Takeuti 1975], <ref> [Schutte 1977] </ref> and [Church 1940]. (In the latter this is not explicitly noted as a feature of the system.) In [Lambek and Scott 1986] comprehension has to be explicitly included as an axiom because, unlike the other systems, predicates and functions can not be formed by (-)abstraction.
Reference: [Streicher 1988] <author> T. Streicher, </author> <title> Correctness and completeness of a categorical semantics of the calculus of constructions, </title> <type> Ph.D. Thesis, </type> <institution> Passau University, Germany. </institution>
Reference-contexts: Strong normalization of fij-reduction for CC with fij-conversion can be proved by adapting the proof for the fi-case in [Geuvers and Nederhof 1991]. In [Coquand 1990] and in <ref> [Streicher 1988] </ref> the syntax is built up more explicitly using a T -operator. This is done for semantical reasons (the latter therefore discusses even more explicit versions of the calculus), to be better able to describe the interpretation of the syntax in the model.
Reference: [Streicher 1991] <author> T. Streicher, </author> <title> Independence of the induction principle and the axiom of choice in the pure calculus of constructions, </title> <journal> TCS 103(2), </journal> <pages> pp 395 - 409. </pages>
Reference-contexts: Semantics is then a very helpful tool for showing that contexts are consistent and in general to show the non-derivability of a formula from a specific set of assumptions. Of course one has to use more interesting models then the one of 4.7 to establish this. In <ref> [Streicher 1991] </ref> there are some examples of this technique using the realisability semantics. Knowing that a certain context is consistent is of course not enough to be able to use it safely for doing proofs.
Reference: [Tait 1965] <author> W.W. Tait, </author> <title> Infinitely long terms of transfinite type. In Formal Systems and Recursive Functions, </title> <editor> eds. J.N. Crossley and M.A.E. Dummett, </editor> <publisher> North-Holland. </publisher>
Reference: [Takeuti 1975] <author> G. Takeuti, </author> <title> Proof Theory, </title> <booktitle> Studies in Logic, </booktitle> <volume> vol. 81, </volume> <publisher> North-Holland. </publisher>
Reference-contexts: Finally we discuss some variants and extensions of the system. 2 Higher Order Predicate Logic as a typed lambda calculus In the literature there are several systems of higher order predicate logic (e.g. [Church 1940], <ref> [Takeuti 1975] </ref>, [Schutte 1977] and [Lambek and Scott 1986]), most of them aiming at the formalisation of higher order arithmetic. <p> Let's now say something about the relations between HOPL and the definitions of higher order predicate logic in [Church 1940], <ref> [Takeuti 1975] </ref>, [Schutte 1977] and [Lambek and Scott 1986]. We try to restrict to the essential differences and not go into issues of notation. <p> Most of them start from two basic domains (usually called types), i and o, letting oe 1 fi fi oe n !o be a type if oe 1 ; ; oe n are types, with o representing the type of formulas. (In <ref> [Takeuti 1975] </ref> the type o doesn't have an explicit name, [Lambek and Scott 1986] also have the `singleton type' 1 as base type and a more fine grained syntax for types, allowing oe 1 fi fi oe n and oe!o (denoted by P oe) for oe 1 ; ; oe n <p> This is very similar to <ref> [Takeuti 1975] </ref>, [Schutte 1977] and [Church 1940]. (In the latter this is not explicitly noted as a feature of the system.) In [Lambek and Scott 1986] comprehension has to be explicitly included as an axiom because, unlike the other systems, predicates and functions can not be formed by (-)abstraction.
Reference: [Troelstra and Van Dalen 1988] <author> A. Troelstra and D. van Dalen, </author> <title> Constructivism in mathematics, an introduction, </title> <booktitle> Volume I/II , Studies in logic and the foundations of mathematics, </booktitle> <volume> vol 121 and volume 123, </volume> <publisher> North-Holland. </publisher> <pages> 39 </pages>
Reference-contexts: 1 Introduction The so called Curry-Howard formulas-as-types embedding provides a formalization of the Brouwer-Heyting-Kolmogorov understanding of proofs as constructions. (See <ref> [Troelstra and Van Dalen 1988] </ref>.) The first detailed description is in [Howard 1980], where also the terminology `formulas-as-types' is first used.
References-found: 48

