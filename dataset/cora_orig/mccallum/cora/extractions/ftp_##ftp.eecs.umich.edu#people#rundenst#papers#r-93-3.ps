URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-93-3.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: rundenst@eecs.umich.edu,  
Phone: phone: (313) 936-2971  
Title: Tools for View Generation in Object-Oriented Databases  
Author: Elke A. Rundensteiner 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Electrical Eng. and Computer Science University of Michigan,  
Abstract: This paper discusses two aspects of the object-oriented view management system, MultiView, which we designed to simplify view specification. First, we introduce a query language for view customization that operates on a complete schema, rather than deriving only individual virtual classes. This graph algebra promises to reduce the effort involved in view specification by lowering the number of queries necessary to define a view. Second, we introduce a tool that guarantees the composition of view classes into arbitrarily complex, yet consistent, view schemata. Unlike for relational views, generalization relationships in OO views must be validated so that they are consistent with the global schema. In our system, we solve this problem by reformulating view schema construction as a classical graph theory problem, called minimal covering. This allows us to develop efficient algorithms that automatically generate a complete, minimal and consistent view schema. Proofs of correctness of these algorithms can be shown. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., and Bonner, A., </author> <title> "Objects and Views," </title> <booktitle> SIGMOD, </booktitle> <year> 1991, </year> <pages> pp. 238-247. </pages>
Reference-contexts: Algorithms and numerous examples can be found in Section 5. 4 Using Graph Algebra for Class Cus tomization 4.1 Graph Algebra While the query languages used by other view systems generally derive individual view classes <ref> [1, 7, 19] </ref> we propose a query language for deriving complete view schemata. The development of this graph algebra was driven by our observations obtained from using ordinary object algebra for defining views for interfacing CAD tools with a design database [18]. <p> Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], [7], [9], [19], and <ref> [1] </ref>. Bancilhon and Kim [4] have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem. <p> Most approaches in the literature do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [7] or they are attached directly as subclasses of the schema root [10]. Scholl et al. [19] and Abiteboul et al. <ref> [1] </ref> both indicate the need for the classification of virtual classes into one schema, but they keep the derived classes into several view schema graphs rather than generating one underlying global schema.
Reference: [2] <author> Aho, A. V., Garey, M.R., and Ullman, J.D., </author> <title> "The Transitive Reduction of a Directed Graph," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 1, No. 2, </volume> <month> June </month> <year> 1972. </year>
Reference-contexts: Proof: See [17] for the proof. In this case, we need to remove all redundant arcs from the view schema graph. For this, we reformulate our problem of view generation as the graph-theoretic problem called transitive reduction <ref> [2] </ref>. <p> graph G' for a given directed acyclic graph G such that (1) there is a directed path from vertex u to v in G' whenever there is a path from u to v in G and (2) there is no graph with fewer arcs than G' satisfying the first condition" <ref> [2] </ref>. G' is called the transitive reduction of G. Since the transitive reduction removes all redundant edges from a view schema, we are not concerned with preventing the creation of redundant edges during the edge creation stage.
Reference: [3] <author> Aho, A. V., Hopcroft, J. E., and Jeffrey, D. U., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley Pub. Company, </publisher> <year> 1974. </year>
Reference-contexts: Proof: See [17]. The complexity of the transitive closure and boolean multiplication algorithms have been shown to be O (n 2:37 (logn) 2 ) for large n <ref> [3] </ref>. Since the size of a schema graph is generally not large, a straightforward implementation of these algorithms as shown in Figure 9 with cube complexity is preferable.
Reference: [4] <author> Bancilhon and W. Kim, </author> <title> "OODB Systems: In Transition," </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> Vol. 19, No. 4, </volume> <month> Dec. </month> <year> 1990, </year> <pages> pp. 49 - 53. </pages>
Reference-contexts: Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], [7], [9], [19], and [1]. Bancilhon and Kim <ref> [4] </ref> have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem.
Reference: [5] <author> Bertino, E., </author> <title> "A view mechanism for OODBs," </title> <booktitle> 3rd Int. Conf on Extending DB Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference: [6] <author> Gilbert, J. P., </author> <title> "Supporting User Views," </title> <booktitle> OODB Task Group Workshop Proc., </booktitle> <address> Ottawa, Can., </address> <month> Oct. </month> <year> 1990. </year>
Reference: [7] <author> Heiler, S., and Zdonik, S. B., </author> <title> Object views: Extending the vision, </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <address> Los Angeles, </address> <month> Feb. </month> <year> 1990, </year> <journal> pg. </journal> <volume> 86 - 93. </volume>
Reference-contexts: Lastly, the view fl The author is grateful for support from the University of Michigan Faculty Award Program, and from NSF (IRI-9309076) update problem can be successfully addressed due to the concepts of object identity and encapsulation <ref> [7, 19, 10] </ref>. The construction of these virtual, possibly restructured, subschema graphs of the global schema raises a number of challenging research issues in terms of how to restructure view schema graphs and how to maintain them consistent with the global schema. <p> Algorithms and numerous examples can be found in Section 5. 4 Using Graph Algebra for Class Cus tomization 4.1 Graph Algebra While the query languages used by other view systems generally derive individual view classes <ref> [1, 7, 19] </ref> we propose a query language for deriving complete view schemata. The development of this graph algebra was driven by our observations obtained from using ordinary object algebra for defining views for interfacing CAD tools with a design database [18]. <p> Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], <ref> [7] </ref>, [9], [19], and [1]. Bancilhon and Kim [4] have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem. <p> Our MultiView approach represents a solution to this problem. Most approaches in the literature do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects <ref> [7] </ref> or they are attached directly as subclasses of the schema root [10].
Reference: [8] <author> D. Fishman et al., </author> <title> "Iris: An Object-Oriented Database Management System," </title> <journal> ACM TOIS, </journal> <volume> vol. 5, no. 1, </volume> <month> Jan. </month> <year> 1987, </year> <pages> pp. 48 - 69. </pages>
Reference-contexts: We compare MultiView to related work in Section 6, and conclude with Section 7. 2 OBJECT-ORIENTED VIEWS 2.1 The Object Data Model Our view system is based on a typical object model like for instance COCOON [19], Morsi et al.'s model [13], and IRIS <ref> [8] </ref>. Below we review terminology required for remainder of the paper. A class C i 2 C has a unique class name, a type description and a set membership.
Reference: [9] <author> Kaul, M., Drosten, K., and Neuhold, E.J., "ViewSystem: </author> <title> Integrating Heterogeneous Information Bases by Object-Oriented Views", </title> <journal> Proc. IEEE Data Eng. Conf., </journal> <month> Feb. </month> <year> 1990, </year> <pages> pp. 2 - 10. </pages>
Reference-contexts: Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], [7], <ref> [9] </ref>, [19], and [1]. Bancilhon and Kim [4] have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem.
Reference: [10] <author> Kim, W., </author> <title> A model of queries in object-oriented databases, </title> <booktitle> In Proc. Int. Conf. on Very Large Databases, </booktitle> <pages> pp. 423 - 432, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Lastly, the view fl The author is grateful for support from the University of Michigan Faculty Award Program, and from NSF (IRI-9309076) update problem can be successfully addressed due to the concepts of object identity and encapsulation <ref> [7, 19, 10] </ref>. The construction of these virtual, possibly restructured, subschema graphs of the global schema raises a number of challenging research issues in terms of how to restructure view schema graphs and how to maintain them consistent with the global schema. <p> Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., <ref> [10] </ref>, [7], [9], [19], and [1]. Bancilhon and Kim [4] have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem. <p> Our MultiView approach represents a solution to this problem. Most approaches in the literature do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [7] or they are attached directly as subclasses of the schema root <ref> [10] </ref>. Scholl et al. [19] and Abiteboul et al. [1] both indicate the need for the classification of virtual classes into one schema, but they keep the derived classes into several view schema graphs rather than generating one underlying global schema.
Reference: [11] <author> Kuno, H. and Rundensteiner, E. A., </author> <title> Building A View Manager System Using GemStone, </title> <institution> Univ. of Michigan, </institution> <type> Technical Report, </type> <month> June </month> <year> 1993. </year>
Reference-contexts: We have developed and implemented a view support system, MultiView, that successfully addresses these issues <ref> [16, 11] </ref>. MultiView breaks view specification into two tasks: (a) the derivation of virtual classes via an object-oriented query and their integration into one consistent global schema and (b) the definition of view schemata composed of both base and virtual classes on top of this augmented global schema. <p> Proofs of correctness of these algorithms can be found in [17]. We have implemented a preliminary prototype of the Mul-tiView system (including the view schema generator) using GemStone. An initial description of this implementation effort is reported in <ref> [11] </ref>. We are currently extending the system to also function as a consistency checking tool for user-specified class relationships. Acknowledgements. My thanks goes to several students at the University of Michigan for their effort on implementing a MultiView prototype using GemStone, in particular, Harumi A. Kuno, Doug L.
Reference: [12] <author> Maier, D., Stein, J., Otis, A., and Purdy, A., </author> <title> "Development of an Object-Oriented DBMS," </title> <booktitle> in Proc. </booktitle> <address> OOPSLA'86, </address> <month> Sep. </month> <year> 1986, </year> <pages> pp. 472-482. </pages>
Reference: [13] <author> Morsi, M. M., Navathe, s. B., Kim, H. K., </author> <title> An Extensible Object-Oriented Database Testbed, </title> <booktitle> Int. Conf. on Data Eng., </booktitle> <year> 1992, </year> <pages> pp. 150 - 157. </pages>
Reference-contexts: We compare MultiView to related work in Section 6, and conclude with Section 7. 2 OBJECT-ORIENTED VIEWS 2.1 The Object Data Model Our view system is based on a typical object model like for instance COCOON [19], Morsi et al.'s model <ref> [13] </ref>, and IRIS [8]. Below we review terminology required for remainder of the paper. A class C i 2 C has a unique class name, a type description and a set membership. <p> View classes (including their extent and type description) are completely defined by class derivation, and this definition is not modified by organizing them into a view schema. In other systems <ref> [13] </ref>, the same class often exhibits different behavior in different views. 2.3 The Validity of the View Generaliza tion Hierarchy Next, we introduce criteria that indicate whether the class generalization hierarchy of a view schema is consistent with the one of the underlying global schema. Definition 3. <p> This feature of MultiView is a significant difference to other approaches <ref> [13] </ref>. Rather than requiring the manual insertion of view is-a relationships by the view definer, we have developed algorithms that automatically augment the set of selected view classes by these relationships to generate a valid view schema. <p> Furthermore, they do not consider the problem of enforcing the consistency of view schemata using a view generation approach. Morsi et al. <ref> [13] </ref> are developing a graphical interface for DAG rearrangement views of a class hierarchy. This tool is part of a graphical environment for schema evolution and version support, and hence focuses on defining a view using manipulation operations similar in flavor to typical schema evolution operators.
Reference: [14] <author> Richardson, J. P. Schwarz, </author> <title> Aspects: Extending Objects to Support Multiple, Independent Roles; Proc. </title> <booktitle> ACM SIGMOD 1991, </booktitle> <pages> 298-307 </pages>
Reference: [15] <author> Rundensteiner, E. A., and Bic, L., </author> <title> "Set Operations in Object-Based Data Models", </title> <journal> in IEEE Trans. on Data and Knowledge Eng., </journal> <volume> Vol. 4, Iss. 3, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: For each type t, properties t denotes the set of property functions of t and domain p (t) denotes the domain of p in t. A class is also a container for a set of object instances, denoted by extent (C i ) <ref> [15] </ref>. Given two classes C1 and C2. C1 is called a subset of C2, denoted by C1 C2, if and only if (8 o 2 O) ((o2C1) =) (o2C2)).
Reference: [16] <author> Rundensteiner, E. A., </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in OODBs", </title> <address> VLDB'92, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: We have developed and implemented a view support system, MultiView, that successfully addresses these issues <ref> [16, 11] </ref>. MultiView breaks view specification into two tasks: (a) the derivation of virtual classes via an object-oriented query and their integration into one consistent global schema and (b) the definition of view schemata composed of both base and virtual classes on top of this augmented global schema. <p> VS3 is not is-a valid. 2 3 THE MultiView METHODOLOGY We provide a short overview of MultiView here to set the context for the remainder of the paper <ref> [16] </ref>. 3 . <p> The current prototype of MultiView utilizes an object algebra for this purpose <ref> [16] </ref> 4 In this paper, we present a new language for class derivation, called graph algebra, that simplifies view specification by grouping these similar types of simple queries into queries on schema graphs. MultiView integrates all virtual classes into one global schema [17]. <p> The classes in a view schema are also referred to as view classes. 4 Because we restrict the query language used for virtual class derivation to be an object-preserving algebra, views in MultiView are automatically updatable <ref> [16, 19] </ref>. the virtual restructuring of the is-a hierarchy by allow-ing to hide from and to expose classes within a view schema. <p> We hence have developed a solution to this problem by extending the well-known object algebra which operates on individual classes to operate on complete schema graphs. Our definition of this graph algebra is based on the `ordinary' object algebra we presented in <ref> [16] </ref>, with some example operators depicted in Figure 2. In the following, we demonstrate that these operators can be built by composing primitive operators on individual classes into meaningful operators on schemata. These graph operators serve two purposes.
Reference: [17] <author> Rundensteiner, E. A., </author> <title> "Object-Oriented Views: An Approach to Tool Integration in Design Environments," </title> <institution> Diss., Info. and Comp. Scie. Dept. Univ. of Cal. Irvine, </institution> <type> Tech. Rep. </type> <pages> 92-83, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: When using a simple object algebra for defining views for interfacing CAD tools with a CAD database, we found that the specification of most views was repetitious requiring many similar types of queries <ref> [17] </ref>. In this paper, we therefore introduce a new query language that simplifies view specification by grouping similar types of simple queries into queries on schema graphs. <p> MultiView integrates all virtual classes into one global schema <ref> [17] </ref>. Global schema integration ensures the explicit capture of all class relationships between stored and derived classes in terms of type inheritance and subset relationships (rather than only between base classes as typically done in OODBs). <p> Hence, a valid view schema can be derived from a valid global schema (Definition 4) by exploiting the syntactic graph structure of the global schema rather than by requiring the semantic comparison of class specifications for each pair of classes. For a global schema classification algorithm see <ref> [17] </ref>. The view generation problem can thus be reformulated as a graph-theoretic problem. Let GS = (V,E) be a global schema. Assume that a subset of classes VV V of GS has been selected (marked) to belong to &lt; V S &gt; (Section 3). <p> However, to avoid inconsistent class relationships, a view consistency checker would have to be developed for manually specified views. 7 We assume that each view schema includes the root object class of GS, i.e., it's a DAG. Proof: See <ref> [17] </ref> for the proof. Theorem 2. (Complexity) The complexity of the Edge-Creation algorithm is linear in the number of nodes in GS, i.e., O (jGSj), assuming the class hierarchy of GS is a tree. Proof: See [17] for the proof. 5.3 View Generation For Global Schemata with Multiple Inheritance For a <p> Proof: See <ref> [17] </ref> for the proof. Theorem 2. (Complexity) The complexity of the Edge-Creation algorithm is linear in the number of nodes in GS, i.e., O (jGSj), assuming the class hierarchy of GS is a tree. Proof: See [17] for the proof. 5.3 View Generation For Global Schemata with Multiple Inheritance For a schema with multiple inheritance (a DAG) the Edge-Creation algorithm does no longer guarantee the creation of a valid view schema. Lemma 1. <p> Lemma 1. For a global schema GS with multiple inheritance, the Edge-Creation algorithm in Figure 8 generates a view schema with all required but possibly also redundant is-a arcs. Proof: See <ref> [17] </ref> for the proof. In this case, we need to remove all redundant arcs from the view schema graph. For this, we reformulate our problem of view generation as the graph-theoretic problem called transitive reduction [2]. <p> M required is incidence matrix for VS; end algorithm; Theorem 3. The View-Generation1 algorithm (Figure 9) generates a valid view schema. Proof: Due to the reformulation of view generation as transitive reduction, the proof of Theorem 3 can be directly derived from the proof for the transitive reduction <ref> [17] </ref>. Creating A Valid Schema. Theorem 4. (Complexity) The worst-case complex ity of the View-Generation1 algorithm is O (jGSj 3 ) with jGSj the number of classes in the global schema GS. Proof: See [17]. <p> the proof of Theorem 3 can be directly derived from the proof for the transitive reduction <ref> [17] </ref>. Creating A Valid Schema. Theorem 4. (Complexity) The worst-case complex ity of the View-Generation1 algorithm is O (jGSj 3 ) with jGSj the number of classes in the global schema GS. Proof: See [17]. The complexity of the transitive closure and boolean multiplication algorithms have been shown to be O (n 2:37 (logn) 2 ) for large n [3]. <p> Theorem 6. (Complexity) The worst-case complexity of the View-Generation2 algorithm is O (min (jGSj fl edges (GS); jV Sj 3 )) with jGSj the number of classes in the global schema GS and jV Sj the number of classes in the view schema VS. Proof: For a proof see <ref> [17] </ref>. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], [7], [9], [19], and [1]. <p> This tool automatically generates a valid and most informative view generalization hierarchy for a set of user selected view classes, making the manual entry of view is-a arcs by the view definer obsolete. Proofs of correctness of these algorithms can be found in <ref> [17] </ref>. We have implemented a preliminary prototype of the Mul-tiView system (including the view schema generator) using GemStone. An initial description of this implementation effort is reported in [11]. We are currently extending the system to also function as a consistency checking tool for user-specified class relationships. Acknowledgements.
Reference: [18] <author> Rundensteiner, E. A., </author> <title> "Design Tool Integration using Object-Oriented Database Views," </title> <booktitle> IEEE Int. Conf. on CAD, </booktitle> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: The development of this graph algebra was driven by our observations obtained from using ordinary object algebra for defining views for interfacing CAD tools with a design database <ref> [18] </ref>. Namely, we found that the specification of most views was repetitious requiring many similar types of queries. We hence have developed a solution to this problem by extending the well-known object algebra which operates on individual classes to operate on complete schema graphs.
Reference: [19] <author> Scholl, M. H., Laasch, C. and Tresch, M., </author> <title> Updat-able Views in Object-Oriented Databases, </title> <booktitle> Proc. 2nd DOOD Conf., </booktitle> <address> Muenich, </address> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Lastly, the view fl The author is grateful for support from the University of Michigan Faculty Award Program, and from NSF (IRI-9309076) update problem can be successfully addressed due to the concepts of object identity and encapsulation <ref> [7, 19, 10] </ref>. The construction of these virtual, possibly restructured, subschema graphs of the global schema raises a number of challenging research issues in terms of how to restructure view schema graphs and how to maintain them consistent with the global schema. <p> The graph algebra takes as input a schema and generates as output another schema, whereas conventional object algebra has one class as input and another class as output <ref> [19] </ref>. Graph algebra operators can be arbitrarily combined with the "regular" object algebra for view generation. This graph algebra promises to lower the number of queries necessary for defining a view. <p> We compare MultiView to related work in Section 6, and conclude with Section 7. 2 OBJECT-ORIENTED VIEWS 2.1 The Object Data Model Our view system is based on a typical object model like for instance COCOON <ref> [19] </ref>, Morsi et al.'s model [13], and IRIS [8]. Below we review terminology required for remainder of the paper. A class C i 2 C has a unique class name, a type description and a set membership. <p> The classes in a view schema are also referred to as view classes. 4 Because we restrict the query language used for virtual class derivation to be an object-preserving algebra, views in MultiView are automatically updatable <ref> [16, 19] </ref>. the virtual restructuring of the is-a hierarchy by allow-ing to hide from and to expose classes within a view schema. <p> Algorithms and numerous examples can be found in Section 5. 4 Using Graph Algebra for Class Cus tomization 4.1 Graph Algebra While the query languages used by other view systems generally derive individual view classes <ref> [1, 7, 19] </ref> we propose a query language for deriving complete view schemata. The development of this graph algebra was driven by our observations obtained from using ordinary object algebra for defining views for interfacing CAD tools with a design database [18]. <p> Proof: For a proof see [17]. 6 RELATED WORK Most initial proposals for defining views for OODBs suggest the use of the query language of their respective object model to derive a virtual class, e.g., [10], [7], [9], <ref> [19] </ref>, and [1]. Bancilhon and Kim [4] have indicated that current OODBs offer at best some degraded form of views, either through exports of schemas or through encapsulation, but no complete and simple mechanism is yet available. Our MultiView approach represents a solution to this problem. <p> Most approaches in the literature do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [7] or they are attached directly as subclasses of the schema root [10]. Scholl et al. <ref> [19] </ref> and Abiteboul et al. [1] both indicate the need for the classification of virtual classes into one schema, but they keep the derived classes into several view schema graphs rather than generating one underlying global schema.
Reference: [20] <author> Shilling, J. J., and Sweeney, P. F., </author> <title> Three Steps to Views: Extending the Object-Oriented Paradigm, </title> <address> OOPSLA'89, New Orleans , Sep. </address> <year> 1989, </year> <pages> 353 - 361. </pages>
Reference-contexts: They point out that work is needed for developing a definition language for view schemata. In this paper, we have provided a solution for this. Shilling and Sweeney's approach <ref> [20] </ref> propose that a class has multiple type interfaces instead of having one type.
Reference: [21] <author> Tanaka, K., Yoshikawa, M., and Ishihara, K., </author> <title> Schema Virtualization in Object-Oriented Databases, </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <month> Feb. </month> <year> 1988, </year> <journal> pg. </journal> <volume> 23 - 30. </volume>
Reference-contexts: The use of a query language to define arbitrary view classes or the classification of such classes are not addressed by their work. Tanaka et al.s early work on schema virtualization <ref> [21] </ref> does not distinguish between the task of integrating derived classes into a common schema and the task of 8 We have modified the Edge-Creation procedure defined for tree-structures (Section 5.2) to run efficiently on a DAG graph structure, e.g., by using markers. generating view schemata.
Reference: [22] <author> Yu and Osborn, </author> <title> "An Evaluation Framework for Algebraic Object-Oriented Query Models," </title> <booktitle> in Proc. IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1991. </year>
References-found: 22

