URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS94-01.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Semantic Locking in Object-Oriented Database Systems  
Author: R. F. Resende D. Agrawal A. El Abbadi 
Keyword: Category: Research. Topic Area: Datbases, Concurrent Systems.  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: Object-oriented databases are being increasingly used to model non-standard applications that emphasize modularity, composition, and rapid prototyping. Semantic locking protocols are presented for transaction management for such object-oriented databases. In particular, the protocol incorporates the semantics of complex objects, nested executions and dynamic conflicts resulting from referentially shared objects. 
Abstract-found: 1
Intro-found: 1
Reference: [AE90] <author> D. Agrawal and A. El Abbadi. </author> <title> Locks with Constrained Sharing. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 85-93, </pages> <month> April </month> <year> 1990. </year> <note> To appear in Journal of Computer and System Sciences. </note>
Reference-contexts: This is mainly due to the fact that the traditional locks are limited to two types: shared and non-shared locks. This results in the unnecessary blocking of conflicting method executions. Recently, Agrawal and El Abbadi <ref> [AE90] </ref> have introduced a new type of relationship between locks called ordered sharing. Ordered sharing permits concurrent execution of conflicting operations with some constraints on termination. Ordered sharing has been adapted to nested two phase locking in object-oriented databases [AE92]. <p> Although this protocol provides more concurrency than the traditional approach it still may unnecessarily delay execution of some methods. We remedy this problem by incorporating a new type of locks called ordered sharing <ref> [AE90] </ref>. The resulting protocol, semantic locking with ordered sharing, provides more concurrency and hence minimizes blocking in object-oriented databases.
Reference: [AE92] <author> D. Agrawal and A. El Abbadi. </author> <title> A Non-restrictive Concurrency Control Protocol for Object Oriented Databases. </title> <booktitle> In Proceedings of the Third International Conference on Extending Data Base Technology (EDBT'92), volume 580 of Lecture Notes in Computer Science, </booktitle> <pages> pages 469-482. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1992. </year> <note> An extended version of this paper will appear in Distributed and Parallel Databases: An International Journal. </note>
Reference-contexts: Earlier work on transaction management in object oriented databases has either ignored the issue of semantics [HH91], or have only used semantics partially <ref> [AE92] </ref>, or do not completely deal with referential sharing [MRW + 93]. The paper is organized as follows. The model is described in Section 3. We motivate the notion of using semantics for object oriented databases and the protocol in Section 4. <p> A lock is granted only if there are no other conflicting locks. Locks are discarded only when the top-level transaction terminates. The proposed mechanism, however, does not take advantage of the semantics of the methods at the higher levels. Agrawal and El Abbadi <ref> [AE92] </ref> have proposed a concurrency control protocol for providing transactional access to object-oriented databases. They provided a uniform treatment for dealing with both class and instance objects and extend the two phase locking protocol to objects with arbitrary operations. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. <p> Recently, Agrawal and El Abbadi [AE90] have introduced a new type of relationship between locks called ordered sharing. Ordered sharing permits concurrent execution of conflicting operations with some constraints on termination. Ordered sharing has been adapted to nested two phase locking in object-oriented databases <ref> [AE92] </ref>. We now extend semantic locking to incorporate locks with ordered sharing. <p> This is to ensure the 20 serializability of the nested computations rooted at ancestors of x and y that are siblings <ref> [AE92, Res94] </ref>. locks. Transaction T 1 updates the price list of four items. Class Item defines a method "change-price ()" for such updates. T 2 is another transaction that computes "total-price-list ()" for only a single order: o4.
Reference: [BBG89] <author> C. Beeri, P. A. Bernstein, and N. Goodman. </author> <title> A Model for Concurrency in Nested Transactions Systems. </title> <journal> Journal of the ACM, </journal> <volume> 36(2) </volume> <pages> 230-269, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Moss [Mos85] introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control [EGLT76]. Beeri, Bernstein and Goodman <ref> [BBG89] </ref> presented a description of nested transactions systems, which includes a definition of serializability, and a set of basic techniques that can be used for proving the serializability of nested computations. Hadzilacos and Hadzilacos [HH91] simplified the model proposed by [BBG89] and applied it to transaction executions in object-oriented databases. <p> Beeri, Bernstein and Goodman <ref> [BBG89] </ref> presented a description of nested transactions systems, which includes a definition of serializability, and a set of basic techniques that can be used for proving the serializability of nested computations. Hadzilacos and Hadzilacos [HH91] simplified the model proposed by [BBG89] and applied it to transaction executions in object-oriented databases. In particular, Hadzilacos and Hadzi-lacos explicitly model the nested execution of transactions and propose a correctness criterion for such executions. <p> However, this protocol also does not exploit 3 the semantics of higher level methods to increase concurrency. Muth et al. [MRW + 93] present a locking protocol for object oriented databases. The authors adopt a notion of commutativity similar to the one in <ref> [BBG89] </ref> in which the conflicts between lower level operations or methods can be ignored due to the commutativity of the corresponding higher level methods in the nested execution. However, the protocol cannot be used with object-oriented databases with referentially shared objects, i.e., non-disjoint complex objects. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects <ref> [BBG89, MRW + 93] </ref>, nested executions [HH91, AE92, MRW + 93] and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. <p> In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. The correctness of our protocol is based on the theory of nested transactions proposed in <ref> [BBG89] </ref>. 3 The Model An object oriented database is a collection of classes and instances of these classes. A class defines a set of attributes for its instances and methods or procedures that are used to manipulate these instances. <p> N2PL captures these conflicts using lock inheritance, however, it fails to take advantage of any object semantics. Our approach extends N2PL to object-oriented databases and uses the additional semantic information to increase concurrency. Beeri, Bernstein, and Goodman <ref> [BBG89] </ref> developed a general theory to reason about nested executions with semantics. They introduced two transformations that establish an equivalence relationship between executions: substitution and commutativity-based reversals. Substitution can be specialized in terms of reduction and expansion. <p> We call conflict serializability the notion of serializability where all conflicts are preserved, and semantic serializability the serializability where some conflicts can be ignored based on the semantics of operations at higher level <ref> [BHG87, BBG89, MRW + 93] </ref>. 4 Motivation Locking is a mechanism commonly used to solve the problem of synchronizing access to shared resources. Locks are place holders for checking concurrency control predicates. Each atomic operation has a lock associated with it. <p> A lock lock (x) can be granted to a method execution iff 8 (a) No other method execution holds a conflicting lock, and (b) All the retainers of a conflicting lock are ancestors of the requesting method execution. It is shown in <ref> [BBG89, HH91] </ref> that N2PL ensures serializability. N2PL does not take advantage of any knowledge about the semantics of the methods being executed. We now show an example of how N2PL can potentially take advantage of the semantics of method executions in order to ignore certain conflicts and accept more executions. <p> This is because the commutativity of these two method executions is derived assuming the atomicity of the operations. In this execution the two method executions are not executed atomically with respect to each other. Using the theory described in <ref> [BBG89] </ref> we can establish the semantic serializability of the execution showed in Figure 4. We can reduce the computations rooted at method executions "decrease-percent ()" since these computations are separated. <p> For example, in Figure 5, semantic locking results in a deadlock. This occurs since both T 1 and T 2 are both blocked when trying to obtain locks on gadget2. To reason about the correctness of semantic locking we use the two transformations described in <ref> [BBG89] </ref>. We illustrate the use of these two transformations in Figure 8 using the example of Figure 4. Since each "decrease-percent ()" in execution (a) is separated we can reduce them. We can go from execution (a) to execution (b) by using four reductions. <p> In execution (c), since T 1 and T 2 are separated we can use two reductions to obtain execution (d) which is a serial execution. We now use the bottom-up proof paradigm of <ref> [BBG89] </ref> to informally argue about the correctness of semantic locking. The goal is to create a sequence of equivalent executions starting from an execution, C 0 , resulting from semantic locking and terminating with a serial execution, C serial , consisting of top-level transactions.
Reference: [BDK92] <editor> F. Bancilhon, C. Dolobel, and P. Kanellakis, editors. </editor> <title> Building an Object-Oriented database System: </title> <publisher> The story of O 2 . Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: This protocol is extended for further concurrency in Section 5. We conclude with a discussion in Section 7. 2 Related Work In traditional databases, the most commonly adopted correctness criterion is serializability. Object-oriented database systems such as ORION [GK88, Kim90] and O 2 <ref> [CF90, BDK92] </ref> ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [BHG87] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: We call conflict serializability the notion of serializability where all conflicts are preserved, and semantic serializability the serializability where some conflicts can be ignored based on the semantics of operations at higher level <ref> [BHG87, BBG89, MRW + 93] </ref>. 4 Motivation Locking is a mechanism commonly used to solve the problem of synchronizing access to shared resources. Locks are place holders for checking concurrency control predicates. Each atomic operation has a lock associated with it.
Reference: [CF90] <author> M. Cart and J. Ferrie. </author> <title> Integrating Concurrency Control into an Object-Oriented Database System. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Technology, </booktitle> <publisher> Springer-Verlag, LNCS 416, </publisher> <pages> pages 363-376, </pages> <year> 1990. </year> <month> 22 </month>
Reference-contexts: This protocol is extended for further concurrency in Section 5. We conclude with a discussion in Section 7. 2 Related Work In traditional databases, the most commonly adopted correctness criterion is serializability. Object-oriented database systems such as ORION [GK88, Kim90] and O 2 <ref> [CF90, BDK92] </ref> ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78]. <p> Ancestor relationship is defined analogously. Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex 10 objects. However, in a system with referentially shared sub-objects, the commutativity re-lation needs to be redefined even for methods that are executed on different objects.
Reference: [EGLT76] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. 
Reference-contexts: Moss [Mos85] introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control <ref> [EGLT76] </ref>. Beeri, Bernstein and Goodman [BBG89] presented a description of nested transactions systems, which includes a definition of serializability, and a set of basic techniques that can be used for proving the serializability of nested computations.
Reference: [FLW90] <author> A. Fekete, N. Lynch, and W. Weihl. </author> <title> A Serialization Graph Construction for Nested Transactions. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 94-108, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Furthermore, the referential sharing of objects may occur dynamically during execution. We assume that commutativity relations are defined for atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. The conflict and commutativity relations between methods that referentially share sub-objects are left unspecified and are determined dynamically during the execution of such methods.
Reference: [GK88] <author> J. F. Garza and W. Kim. </author> <title> Transaction Management in an Object-oriented Data Model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 37-55, </pages> <month> June 88. </month>
Reference-contexts: This protocol is extended for further concurrency in Section 5. We conclude with a discussion in Section 7. 2 Related Work In traditional databases, the most commonly adopted correctness criterion is serializability. Object-oriented database systems such as ORION <ref> [GK88, Kim90] </ref> and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78]. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex 10 objects. However, in a system with referentially shared sub-objects, the commutativity re-lation needs to be redefined even for methods that are executed on different objects.
Reference: [Gra78] <author> J. N. Gray. </author> <title> Notes on database systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Object-oriented database systems such as ORION [GK88, Kim90] and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking <ref> [Gra78] </ref>. Multigranularity locking was developed to reduce locking overhead by organizing the database in the form of a hierarchy, e.g., the database is composed of files, and each file is composed of a set of records etc.
Reference: [HDK + 90] <author> U. Herrmann, P. Dadam, K. Kuspert, E. Roman, and G. Schl ageter. </author> <title> A Lock Technique for Disjoint and Non-Disjoint Complex Objects. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Technology, </booktitle> <publisher> Springer-Verlag, LNCS 416, </publisher> <pages> pages 219-237, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In particular, the proposed protocols allow concurrency between schema changes as well as user transactions. This approach was also applied to complex objects with pre-declaration of locks <ref> [HDK + 90] </ref>. Moss [Mos85] introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control [EGLT76].
Reference: [HH91] <author> T. Hadzilacos and V. Hadzilacos. </author> <title> Transaction Synchronization in Object Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 2-24, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: We believe this is an important property of object oriented systems since new objects are composed from existing objects, hence referential sharing among unrelated objects is unavoidable. Earlier work on transaction management in object oriented databases has either ignored the issue of semantics <ref> [HH91] </ref>, or have only used semantics partially [AE92], or do not completely deal with referential sharing [MRW + 93]. The paper is organized as follows. The model is described in Section 3. We motivate the notion of using semantics for object oriented databases and the protocol in Section 4. <p> Beeri, Bernstein and Goodman [BBG89] presented a description of nested transactions systems, which includes a definition of serializability, and a set of basic techniques that can be used for proving the serializability of nested computations. Hadzilacos and Hadzilacos <ref> [HH91] </ref> simplified the model proposed by [BBG89] and applied it to transaction executions in object-oriented databases. In particular, Hadzilacos and Hadzi-lacos explicitly model the nested execution of transactions and propose a correctness criterion for such executions. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. <p> Users access objects by executing methods defined on objects or atomic operations associated with objects. A method execution is a partial order of method executions and atomic operations <ref> [HH91] </ref>. Such a caller-callee relationship between methods establishes a hierarchy that is known as nested transactions or nested method executions [Mos85]. <p> The method "total-list-price ()" defined in the class Order computes the list-price for the order. In the class Order, the method "report-status ()" is implemented with atomic operation "read (status)". Similarly in class Item, "report-price ()" is implemented with atomic operation "read (price)" . As in <ref> [HH91] </ref>, we assume that user transactions are methods of a distinct object called environment. We will be using the terms transaction and method execution interchangeably. We also assume the existence of a special method execution, T 0 , in the environment object that invokes the top-level method executions. <p> A lock lock (x) can be granted to a method execution iff 8 (a) No other method execution holds a conflicting lock, and (b) All the retainers of a conflicting lock are ancestors of the requesting method execution. It is shown in <ref> [BBG89, HH91] </ref> that N2PL ensures serializability. N2PL does not take advantage of any knowledge about the semantics of the methods being executed. We now show an example of how N2PL can potentially take advantage of the semantics of method executions in order to ignore certain conflicts and accept more executions. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex 10 objects. However, in a system with referentially shared sub-objects, the commutativity re-lation needs to be redefined even for methods that are executed on different objects. <p> Furthermore, the referential sharing of objects may occur dynamically during execution. We assume that commutativity relations are defined for atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. The conflict and commutativity relations between methods that referentially share sub-objects are left unspecified and are determined dynamically during the execution of such methods. <p> In addition, our protocols are novel in the sense that they support referentially shared objects as well as conflicts that arise dynamically during execution. We first presented the semantic locking protocol which is a generalization of nested two phase locking in object oriented databases <ref> [Mos85, HH91, MRW + 93] </ref>. Although this protocol provides more concurrency than the traditional approach it still may unnecessarily delay execution of some methods. We remedy this problem by incorporating a new type of locks called ordered sharing [AE90].
Reference: [HW91] <author> M. P. Herlihy and W. E. Weihl. </author> <title> Hybrid Concurrency Control for Abstract Data Types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 25-61, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: Ancestor relationship is defined analogously. Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>.
Reference: [Kim90] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This protocol is extended for further concurrency in Section 5. We conclude with a discussion in Section 7. 2 Related Work In traditional databases, the most commonly adopted correctness criterion is serializability. Object-oriented database systems such as ORION <ref> [GK88, Kim90] </ref> and O 2 [CF90, BDK92] ensure the serializable execution of transactions. Both of these database systems employ a locking protocol based on multigranularity locking [Gra78].
Reference: [Mos85] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: In particular, the proposed protocols allow concurrency between schema changes as well as user transactions. This approach was also applied to complex objects with pre-declaration of locks [HDK + 90]. Moss <ref> [Mos85] </ref> introduced the notion of nested transactions for modular composition of applications and programs in database systems. He proposed the nested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking protocol for concurrency control [EGLT76]. <p> In particular, Hadzilacos and Hadzi-lacos explicitly model the nested execution of transactions and propose a correctness criterion for such executions. They present a nested two phase locking protocol for an object oriented database that is a generalization of the locking protocol for nested transactions proposed by Moss <ref> [Mos85] </ref>. In this protocol, locks are requested for the atomic operations, which correspond to the leaves in the nested execution. When a method execution terminates, its parent inherits its locks. A lock is granted only if there are no other conflicting locks. <p> Users access objects by executing methods defined on objects or atomic operations associated with objects. A method execution is a partial order of method executions and atomic operations [HH91]. Such a caller-callee relationship between methods establishes a hierarchy that is known as nested transactions or nested method executions <ref> [Mos85] </ref>. We assume that the objects are ordered in a hierarchy and a method in one object can only call methods on objects that are lower in the hierarchy. and Order. <p> We summarize the nested two-phase locking (N2PL) rules adapted from <ref> [Mos85] </ref> as follows. 1. A method execution t 0 can execute an atomic operation t, iff lock (t) is requested and is granted (we say that the method execution t 0 holds lock (t)). 2. A method execution cannot terminate (commit or abort) until all its children have terminated. <p> Furthermore, the referential sharing of objects may occur dynamically during execution. We assume that commutativity relations are defined for atomic operations. This is the same assumption made by most previous work in both nested transactions and object oriented databases <ref> [Mos85, HH91, FLW90] </ref>. However, we enrich this model by exploiting semantic information, i.e., commutativity relations that are derived from the semantics of methods of classes. The conflict and commutativity relations between methods that referentially share sub-objects are left unspecified and are determined dynamically during the execution of such methods. <p> Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to <ref> [Mos85] </ref>, locks are only required for the execution of atomic operations and contrasts with [MRW + 93] where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. <p> Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to <ref> [Mos85] </ref>, locks are only required for the execution of atomic operations and contrasts with [MRW + 93] where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. The locks that a method execution x inherits from its children are said to be retained by x. In semantic locking, locks can be granted to conflicting operations if the corresponding operations have commuting ancestors. <p> In this latter case semantic information is used by the locking protocol, hence the name semantic locking protocol. 12 5.2 Implementation issues We briefly discuss an implementation of the semantic locking protocol proposed in this paper. Our approach is to generalize the implementation proposed for nested two-phase locking protocol <ref> [Mos85] </ref> and we have chosen a similar terminology to that in [MRW + 93]. Obviously semantic locking demands more implementation effort than N2PL, but this extra demand does not add significant complexity. Objects have methods and atomic operations, and belong to a certain object class. <p> An entry in a commutativity table indi cates that it is unknown that the methods commute or whether they commute. The scheduler also maintains a lock table in each object that determines which atomic operations have locks requested and granted. The following structure adapted from <ref> [Mos85] </ref> illustrates some of the relevant fields of an entry in a lock table: t - t - Lock Record Format Parent Id State information Mode Next lock for the same method The lock record entry parent-id identifies the transaction who currently holds/retains the lock on this object. <p> One way to implement this is to maintain a reference to all objects that were visited by descendents of method executions. If the information about commutativity of methods is not used our implementation is essentially the same implementation as in N2PL <ref> [Mos85] </ref>. 14 We use the example in Figure 7, to illustrate the dynamics of our design. Method execution T 2 of the environment object is invoked and calls method execution T 2 .decrease-percent () of object gadget2. <p> In addition, our protocols are novel in the sense that they support referentially shared objects as well as conflicts that arise dynamically during execution. We first presented the semantic locking protocol which is a generalization of nested two phase locking in object oriented databases <ref> [Mos85, HH91, MRW + 93] </ref>. Although this protocol provides more concurrency than the traditional approach it still may unnecessarily delay execution of some methods. We remedy this problem by incorporating a new type of locks called ordered sharing [AE90].
Reference: [MRW + 93] <author> P. Muth, T. C. Rakow, G. Weikum, P. Brossler, and C. Hasse. </author> <title> Semantic Con-currency Control in Object-Oriented Database Systems. </title> <booktitle> In Proceedings of the 9th IEEE International Conference on Data Engineering, </booktitle> <pages> pages 233-242, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Earlier work on transaction management in object oriented databases has either ignored the issue of semantics [HH91], or have only used semantics partially [AE92], or do not completely deal with referential sharing <ref> [MRW + 93] </ref>. The paper is organized as follows. The model is described in Section 3. We motivate the notion of using semantics for object oriented databases and the protocol in Section 4. In Section 5, we describe the protocol that is based on the above design criterion. <p> Allowing updates to both classes and instances of these classes makes the proposed protocol beneficial for extensibility and experimentation, which are needed for continuously evolving object oriented database applications. However, this protocol also does not exploit 3 the semantics of higher level methods to increase concurrency. Muth et al. <ref> [MRW + 93] </ref> present a locking protocol for object oriented databases. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects <ref> [BBG89, MRW + 93] </ref>, nested executions [HH91, AE92, MRW + 93] and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. <p> We have developed a locking-based concurrency control protocol for object-oriented databases. Our protocol generalizes Moss's original nested transaction protocol in that it incorporates the rich semantic information available in object oriented databases. Our protocol incorporates the notions of semantics of higher level objects [BBG89, MRW + 93], nested executions <ref> [HH91, AE92, MRW + 93] </ref> and dynamic conflicts. In particular, we address the issue of referentially shared objects where the referential sharing is determined dynamically during the execution. <p> We assume that the objects are ordered in a hierarchy and a method in one object can only call methods on objects that are lower in the hierarchy. and Order. This example is similar to the one in <ref> [MRW + 93] </ref> but is extended to a more 4 class Customer class Item class Order customerNo: integer itemNo: integer orderNo: integer name: string name: string customer: Customer orders: set (Order) quantity: integer status: integer orders: set (Order) itemset: set (tuple (item: Item, price: float quantity: integer, price: float)) realistic setting <p> Ancestor relationship is defined analogously. Two method invocations x and y on the same object commute if and only if the two possible sequential executions of x and y are indistinguishable for both x and y and for all possible sequences of methods that may be invoked subsequently <ref> [CF90, HW91, MRW + 93] </ref>. <p> We call conflict serializability the notion of serializability where all conflicts are preserved, and semantic serializability the serializability where some conflicts can be ignored based on the semantics of operations at higher level <ref> [BHG87, BBG89, MRW + 93] </ref>. 4 Motivation Locking is a mechanism commonly used to solve the problem of synchronizing access to shared resources. Locks are place holders for checking concurrency control predicates. Each atomic operation has a lock associated with it. <p> In general, in object-oriented databases, the conflicts and commutativity relations between methods are defined on a per class basis. Methods on different objects are generally assumed to commute with each other <ref> [GK88, CF90, HH91, MRW + 93] </ref>. This approach is reasonable for object-oriented databases with disjoint complex 10 objects. However, in a system with referentially shared sub-objects, the commutativity re-lation needs to be redefined even for methods that are executed on different objects. <p> Before a method execution may execute an atomic operation, a lock must be requested and granted. This is similar to [Mos85], locks are only required for the execution of atomic operations and contrasts with <ref> [MRW + 93] </ref> where locks are required for the execution of methods. Similar to [Mos85] when a method execution terminates its parent inherits all its locks. The locks that a method execution x inherits from its children are said to be retained by x. <p> Our approach is to generalize the implementation proposed for nested two-phase locking protocol [Mos85] and we have chosen a similar terminology to that in <ref> [MRW + 93] </ref>. Obviously semantic locking demands more implementation effort than N2PL, but this extra demand does not add significant complexity. Objects have methods and atomic operations, and belong to a certain object class. The scheduler maintains for each object class: * A conflict table indexed by the atomic operations. <p> In addition, our protocols are novel in the sense that they support referentially shared objects as well as conflicts that arise dynamically during execution. We first presented the semantic locking protocol which is a generalization of nested two phase locking in object oriented databases <ref> [Mos85, HH91, MRW + 93] </ref>. Although this protocol provides more concurrency than the traditional approach it still may unnecessarily delay execution of some methods. We remedy this problem by incorporating a new type of locks called ordered sharing [AE90].
Reference: [Res94] <author> R. Resende. </author> <title> Conflict and Semantic Serializability of Nested transactions Proto--cols. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of California at Santa Barbara, </institution> <year> 1994. </year> <note> In preparation. 24 </note>
Reference-contexts: This argument can be extended to the general case when a sequence of nodes y 1 ; : : : ; y n are interleaved within x <ref> [Res94] </ref>. We conclude this section by noting that the protocol depends crucially on the assumption that objects are modularly designed and that they are hierarchically organized in a static manner. <p> By enforcing this restriction dynamically we can ensure that no incorrect executions occur without imposing a static hierarchy on the objects. The details of the implementation and correctness proof of this approach appear in <ref> [Res94] </ref>. 6 Semantic Locking with Ordered Shared Locks Semantic locking allows more concurrency when compared to nested two phase locking. However, it may cause unnecessary blocking of concurrent method executions. <p> This is to ensure the 20 serializability of the nested computations rooted at ancestors of x and y that are siblings <ref> [AE92, Res94] </ref>. locks. Transaction T 1 updates the price list of four items. Class Item defines a method "change-price ()" for such updates. T 2 is another transaction that computes "total-price-list ()" for only a single order: o4.
References-found: 17

