URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/papers/rida.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/newProgram.html
Root-URL: 
Email: bazzi@asu.edu  
Title: Synchronous Byzantine Quorum Systems  
Author: Rida A. Bazzi 
Keyword: quorum systems, fault tolerance, byzantine failures, load, distributed systems.  
Address: Tempe, AZ 85287-5406 U.S.A.  
Affiliation: Department of Computer Science and Engineering Arizona State University  
Abstract: Quorum systems have been used to implement many coordination problems in distributed systems such as mutual exclusion, data replication, distributed consensus, and commit protocols. Malkhi and Re- iter recently proposed quorum systems that can tolerate byzantine failures; they called these systems byzantine quorum systems and gave some examples of such quorum systems. In this paper, we argue that the proposed definition of byzantine quorums is too strong for synchronous systems and we propose a definition of synchronous byzantine quorums. We show that the new definition is more appropriate for synchronous systems. We prove tight lower bounds on the load of synchronous byzantine quorums for various failure assumptions and we present synchronous byzantine quorums that have optimal loads that match the lower bounds for two failure assumptions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal and A. El-Abbadi. </author> <title> An efficient and faulttolerant solution for distributed mutual exclusion. </title> <journal> ACM Transactions on Computer Systems, 9(1):120,1991. </journal>
Reference-contexts: 1 Introduction A quorum system is a collection of sets (quorums) that mutually intersect. Quorum systems have been used to implement mutual exclusion <ref> [1, 9] </ref>, replicated data systems [8], commit protocols [19], and distributed consensus [13]. For example, in a typical implementation of mutual exclusion using a quorum system, processors request access to the critical section from all members of a quorum. <p> The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [2] <author> R. A. </author> <title> Bazzi. </title> <booktitle> Planar Quorums In Proceedings of the 10th International Workshop on Distributed Algorithms, </booktitle> <pages> pages 251-268, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures. <p> If one of the servers failed, then the client attempts to access another quorum that does not have any faulty processor (the question of finding a quorum with no faulty processors has been addressed in <ref> [2, 16] </ref>). Since processors access a quorum only if all its members are correct, two clients are always guaranteed to receive a response from a common correct server which belongs to a non-empty intersection of two quorums. The correctness of quorum-based protocols rely on this intersection property. <p> This completes the proof. Now, we describe the quorum system. On S i , i 2 f0; 1; 2g, define a quorum system with load O ( 1 p jS i j Many such systems exist. One such system is the triangle lattice system <ref> [2] </ref>. In the triangle lattice system over S i , we can choose p 2jS i j quorums such that each processor belongs to exactly two quorums.
Reference: [3] <author> H. Garcia-Molina and D. Barbara. </author> <title> How to assign votes in a distributed system. </title> <journal> Journal of the ACM, </journal> <volume> 32(4) </volume> <pages> 481-860, </pages> <year> 1985. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [4] <author> D. K. Gifford. </author> <booktitle> Weighted Voting for Replicated Data Proceeding of 7th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [5] <author> M. P. Herlihy. </author> <title> Replication Methods for Abstract Data Types. </title> <type> Ph.D. Thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1984. </year>
Reference: [6] <author> T. Ibaraki and T. Kameda. </author> <title> A theory of Coteries: Mutual Exclusion in Distributed Systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <year> 779-749,1993. </year>
Reference: [7] <author> A. Kumar. </author> <title> Hierarchical quorum consensus: A new algorithm for managing replicated data. </title> <journal> IEEE Transactions of Computers, </journal> <volume> 40(9) </volume> <year> 996-1004,1991. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [8] <author> A. Kumar., M. Rabinovich, and R. Sinha. </author> <title> A per-formance study of general grid structures for repli-cated data. </title> <booktitle> In Proceedings of International Conference on Distributed Computing Systems, </booktitle> <pages> pages 178185, </pages> <month> May, </month> <year> 1993. </year>
Reference-contexts: 1 Introduction A quorum system is a collection of sets (quorums) that mutually intersect. Quorum systems have been used to implement mutual exclusion [1, 9], replicated data systems <ref> [8] </ref>, commit protocols [19], and distributed consensus [13]. For example, in a typical implementation of mutual exclusion using a quorum system, processors request access to the critical section from all members of a quorum. <p> The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [9] <author> M. Maekawa. </author> <title> A p n algorithm for mutual exclu-sion in decentralized systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(2) </volume> <year> 145-159,1985. </year>
Reference-contexts: 1 Introduction A quorum system is a collection of sets (quorums) that mutually intersect. Quorum systems have been used to implement mutual exclusion <ref> [1, 9] </ref>, replicated data systems [8], commit protocols [19], and distributed consensus [13]. For example, in a typical implementation of mutual exclusion using a quorum system, processors request access to the critical section from all members of a quorum. <p> The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures. <p> It follows that k q 2f+1 . Divide the processors into 2f + 1 identical sets. On each of the sets, define a finite projective plane system consisting of n 2f+1 quorums numbered from 1 to k + 1 <ref> [9] </ref>. Each quorum consists of k + 1 processors and each processor belongs to exactly k + 1 quorums [9]. A quorum of the parallel finite projective planes is the union of 2f + 1 identically numbered quorums, one from each set. <p> On each of the sets, define a finite projective plane system consisting of n 2f+1 quorums numbered from 1 to k + 1 <ref> [9] </ref>. Each quorum consists of k + 1 processors and each processor belongs to exactly k + 1 quorums [9]. A quorum of the parallel finite projective planes is the union of 2f + 1 identically numbered quorums, one from each set. The size of each quorum is (2f + 1) q 2f+1 = n (2f + 1) and each processor belongs to exactly k + 1 quorums.
Reference: [10] <author> D. Malkhi and M. Reiter. </author> <title> Byzantine Quorum Systems. </title> <booktitle> In Proceedings of ACM 29th Symposium on Theory of Computing, </booktitle> <month> May, </month> <year> 1997. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures [1, 2, 3, 4, 7, 8, 9, 18, 17, 16]. Re- cently, Malkhi and Reiter <ref> [10] </ref> proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures. <p> They presented a number of masking byzantine and dissemination quorum systems for different failure assumptions and calculated their load. The quorum systems they presented assume that the system is asynchronous. 2 Contributions In this paper we carefully study the definitions of byzantine quorums as proposed in <ref> [10] </ref>. Specifically, we study how the synchrony assumptions affect the definition of byzantine quorums. This leads us to revisit the traditional definition of availability of quorum systems and the way quorums are accessed. <p> We note that the probabilistic model is not adequate for byzantine failures and conclude that a new definition of availability and quorum access is needed in the presence of byzantine failures in a synchronous system. We revise the definition of masking byzantine quorums proposed in <ref> [10] </ref> and propose to relax it in a way that allows for more failures in synchronous systems. We develop necessary and sufficient conditions for the existence of synchronous byzantine quorums that can tolerate a general failure pattern. <p> A common example of a failure pattern is the f - threshold pattern in which F = fF 2 P : jF j = f g. Another interesting failure pattern is the disjoint pattern in which all elements of F are disjoint <ref> [10] </ref>. 3.3 Coteries and Quorums The standard definition of a quorum is the following. Definition 1: A quorum system Q over P is a set of subsets (called quorums) of P such that any two quorums have a non-empty intersection. <p> This is because processors that have failed will not recover later and put the system in an inconsistent state. This is the case if failures are arbitrary. 3 Timeouts are not possible in asynchronous systems 4 Byzantine Quorums Malkhi and Reiter <ref> [10] </ref> gave a general definition of quorum systems that can tolerate byzantine failures in asynchronous systems. <p> It follows that a processor must base its coordination decisions on replies that it knows to be from correct processors. Motivated by this requirement, Malkhi and Reiter gave the following definition <ref> [10] </ref>: Definition 7: A quorum system tolerates failure pattern F if 1. 8Q 1 ; Q 2 2 Q 8F 1 ; F 2 2 F : (Q 1 "Q 2 )F 1 6 F 2 . <p> From the discussion above and in the previous section, we conclude that only the first of the two conditions proposed by <ref> [10] </ref> is needed for byzantine quorums in synchronous systems. <p> This necessary and sufficient condition is to be contrasted with the requirement that n 4f + 1 for the existence of a byzantine quorum for asynchronous systems <ref> [10] </ref>. 5 Load Lower Bounds Let c (Q) be the size of the smallest quorum of Q. Naor and Wool [15] proved the following lower bound on the load of a quorum system. Proposition 11: L (Q) maxf c (Q) c (Q) g. <p> Naor and Wool [15] proved the following lower bound on the load of a quorum system. Proposition 11: L (Q) maxf c (Q) c (Q) g. This lower bound obviously applies to byzantine quorum systems because they are also quorum systems. Malkhi and Reiter <ref> [10] </ref> proved the same lower bounds with more direct methods, but did not prove any new lower bounds for byzantine quorums. 4 In this section, we prove new lower bounds that are specific to byzantine quorums in synchronous systems. The lower bounds we prove also apply to asynchronous byzantine quorums [10]. <p> <ref> [10] </ref> proved the same lower bounds with more direct methods, but did not prove any new lower bounds for byzantine quorums. 4 In this section, we prove new lower bounds that are specific to byzantine quorums in synchronous systems. The lower bounds we prove also apply to asynchronous byzantine quorums [10]. We prove lower bounds for a general failure pattern, the f -threshold failure pattern, and the disjoint failure pattern. The bounds we prove for the f -threshold failure pattern and the disjoint failure pattern are tight.
Reference: [11] <author> D. Malkhi, M. Reiter, and A. Wool. </author> <title> The load and availability of Byzantine quorum systems. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August, </month> <year> 1997. </year>
Reference-contexts: (Q) maxf c (Q (F i [F j )) c (Q (F i [F j )) g for any F i Proposition 14: Let Q be a quorum system that tolerates failure pattern F , then L (Q) 1 p nmax i;j=1;:::;m jF i [F j j . 4 In <ref> [11] </ref>, Malkhi et al. prove some lower bounds similar to ours. 5.2 Disjoint Failure Pattern Applying Proposition 13 to a disjoint failure pattern F d , we obtain: Proposition 15: Let Q be a quorum system that tolerates F d = fF 1 ; : : : ; F m g
Reference: [12] <author> S. J. Mullender and P. M. B. Vitanyi. </author> <title> Distributed Match Making. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 367-391, </pages> <year> 1992. </year>
Reference: [13] <author> M. L. </author> <title> Neilsen Quorum Structures in Distributed Systems. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer and Information Sciences, Kansas State University, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction A quorum system is a collection of sets (quorums) that mutually intersect. Quorum systems have been used to implement mutual exclusion [1, 9], replicated data systems [8], commit protocols [19], and distributed consensus <ref> [13] </ref>. For example, in a typical implementation of mutual exclusion using a quorum system, processors request access to the critical section from all members of a quorum.
Reference: [14] <author> M. L. Neilsen and M. Mizuno. </author> <booktitle> Decentralized Consensus Porotocols In Proceedings of 10th International Phoenix Conference on Computing and Communications, </booktitle> <pages> pages 257-262, </pages> <year> 1991. </year>
Reference: [15] <author> M. Naor and A. </author> <title> Wool The Load, capacity and avail-ability of quorum systems. </title> <booktitle> In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 214-225. </pages> <year> 1994. </year>
Reference-contexts: This suggests the definition of a non-dominated quorum systems, or NDQ for short. Definition 4: A quorum system is non-dominated if there is no other quorum system that dominates it. 3.4 Strategies and Load This section presents the formal definitions of strategy and load <ref> [15] </ref>. A protocol using a quorum system chooses a quorum for access according to some rules. A strategy is a probabilistic rule to choose a quorum. Formally, a strategy is defined as follows. <p> The correctness of quorum-based protocols rely on this intersection property. Traditionally, a quorum is said to be available if all its elements are correct processors <ref> [15] </ref>. One might think that it is sufficient to have a non-empty intersection between quorums to have availability. The following is an alternative definition of availability. * Availability (alternative). A quorum system is available if one of its quorums intersects every other quorum in a correct processor. <p> This necessary and sufficient condition is to be contrasted with the requirement that n 4f + 1 for the existence of a byzantine quorum for asynchronous systems [10]. 5 Load Lower Bounds Let c (Q) be the size of the smallest quorum of Q. Naor and Wool <ref> [15] </ref> proved the following lower bound on the load of a quorum system. Proposition 11: L (Q) maxf c (Q) c (Q) g. This lower bound obviously applies to byzantine quorum systems because they are also quorum systems.
Reference: [16] <author> D. Peleg and A. Wool. </author> <title> How to be an Efficient Snoop, or the Probe Complexity of Quorum Systems. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 290-299, </pages> <year> 1996. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures. <p> If one of the servers failed, then the client attempts to access another quorum that does not have any faulty processor (the question of finding a quorum with no faulty processors has been addressed in <ref> [2, 16] </ref>). Since processors access a quorum only if all its members are correct, two clients are always guaranteed to receive a response from a common correct server which belongs to a non-empty intersection of two quorums. The correctness of quorum-based protocols rely on this intersection property.
Reference: [17] <author> D. Peleg and A. Wool. </author> <title> The availability of quorum systems. Information and Computation, </title> <address> 123(2):210223, </address> <year> 1995. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [18] <author> D. Peleg and A. Wool. Crumbling Walls: </author> <title> A class of high availability quorum systems. </title> <booktitle> In Processedings 14th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 120-129, </pages> <year> 1995. </year>
Reference-contexts: The probabilistic model is not appropriate for byzantine failures. Other criteria are also considered in the literature, but we do not study them in this paper. Work on quorum systems traditionally considered crash failures <ref> [1, 2, 3, 4, 7, 8, 9, 18, 17, 16] </ref>. Re- cently, Malkhi and Reiter [10] proposed the interesting notion of byzantine quorums quorum systems that can tolerate byzantine failures.
Reference: [19] <author> D. Skeen. </author> <title> A quorum-based commit protocol. </title> <booktitle> In Proceedings of 6th Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <pages> pages 69-80, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction A quorum system is a collection of sets (quorums) that mutually intersect. Quorum systems have been used to implement mutual exclusion [1, 9], replicated data systems [8], commit protocols <ref> [19] </ref>, and distributed consensus [13]. For example, in a typical implementation of mutual exclusion using a quorum system, processors request access to the critical section from all members of a quorum.
References-found: 19

