URL: http://www.cse.ogi.edu/~jl/Papers/lazyImp.ps
Refering-URL: http://www.cse.ogi.edu/~jl/biblio-functional.html
Root-URL: http://www.cse.ogi.edu
Email: jl@dcs.glasgow.ac.uk  
Title: Lazy Imperative Programming  
Author: John Launchbury 
Address: Glasgow University  
Affiliation: Computing Science Department  
Abstract: In this paper we argue for the importance of lazy state, that is, sequences of imperative (destructive) actions in which the actions are delayed until their results are required. This enables state-based computations to take advantage of the control power of lazy evaluation. We provide some examples of its use, and describe an implementation within Glasgow Haskell. 
Abstract-found: 1
Intro-found: 1
Reference: [Hug89] <author> J.Hughes, </author> <title> Why Functional Programming Matters, </title> <journal> The Computer Journal, </journal> <volume> Vol 32, No. 2, </volume> <pages> CUP, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This may be generalised by making the state thread entirely lazy. Hughes argues that the true power of laziness is to decouple control from calculation <ref> [Hug89] </ref>, and we show the same arguments apply to internally state-based computations. We provide some examples of this, and give an implementation of lazy-state in Glasgow Haskell.
Reference: [Mog89] <author> E.Moggi, </author> <title> Computational Lambda Calculus and Monads, </title> <booktitle> proc. IEEE. Logic in Computer Science, Asilomar, </booktitle> <address> California, </address> <year> 1989. </year>
Reference-contexts: Determining which side effects are to be performed, and worse, in which order, would rely on determining the exact order of evaluation|the very thing that laziness tends to hide! Consequently lazy evaluation and side effects do not mix. There is a way forward however. The recent work of Moggi <ref> [Mog89] </ref> showed how monads could be used to structure denotational semantics, including the handling of state in imperative languages. Wadler recognised that the same principles apply for functional programs and, in particular, showed how the state monad could be used to incorporate imperative operations in a purely functional language [Wad92].
Reference: [ORH93] <author> M.Odersky, D.Rabin and P.Hudak, </author> <title> Call by Name, Assignment, and the Lambda Calculus, </title> <booktitle> proc. ACM Principles of Programming Languages 93, </booktitle> <address> Charlston, N.Carolina, </address> <year> 1993. </year>
Reference-contexts: This paper builds directly on top of the IO work at Glas-gow as reported by Peyton Jones and Wadler [PW93], and summarised in Section 2. There are also strong similarities with the var work of Odersky, Rabin and Hudak <ref> [ORH93] </ref>, which itself was influenced by Swarup, Reddy and Ireland [SRI91]. Like Peyton Jones and Wadler, var provides only for strict imperative actions: no purely functional result is returned until the structure and content of the state is resolved.
Reference: [Ode93] <author> M.Odersky, </author> <title> Making Gensym Safe for Functional Programming, </title> <institution> Dept. of Computer Science, Yale Univ, </institution> <note> unpublished. </note>
Reference-contexts: However, we also need to generate a unique identifier. The problem is well known: it is just gensym. Again, we could implement gensym using slightly dirty tricks with the dangerous performIO. Interestingly, however, Odersky has recently shown that the lambda calculus may be safely extended with a gensym operator <ref> [Ode93] </ref>. The term -t:e introduces a new name t within e. The only operation provided on names is equality. The resulting calculus is Church-Rosser. The concrete syntax Odersky proposes for -t:e is new t -&gt; e.
Reference: [PL91] <author> S.Peyton Jones and J.Launchbury, </author> <title> Unboxed Values as First Class Citizens, </title> <booktitle> proc. ACM Functional Programming Languages and Computer Architecture, </booktitle> <address> Boston, </address> <publisher> LNCS 523, </publisher> <address> S-V, </address> <year> 1991. </year>
Reference-contexts: Here World# is an unboxed data type <ref> [PL91] </ref>. The # suffix is a lexical convention only with no semantic content, but un-boxed types are very different beasts from normal types. In particular, unboxed types have no bottom element, so cannot be undefined.
Reference: [PW93] <author> S.Peyton Jones and P.Wadler, </author> <title> Imperative Functional Programming, </title> <booktitle> proc. ACM Principles of Programming Languages 93, </booktitle> <address> Charlston, N.Carolina, </address> <year> 1993. </year>
Reference-contexts: From this work it became clear that lazy evaluation and imperative actions could coexist quite happily, with each being able to pass values to the other. The Glasgow Haskell compiler incorporates extensions to the lazy functional language Haskell. These extensions implement imperative actions <ref> [PW93] </ref>. However, the implementation has an important shortcoming: all imperative actions are performed before any results are returned. This parallels strict evaluation where all the arguments to a function are evaluated before a result is given, even if the values of the arguments are not required. <p> As this paper builds directly on the work by Peyton Jones and Wadler <ref> [PW93] </ref>, it makes sense to review that first. 2 Imperative Haskell Imperative features were introduced to Glasgow Haskell for expressing input and output, so the type constructor for state-based computations is called IO. A state-based computation that produces a purely functional value of type a therefore has type IO a. <p> The practical advantage is that the power of lazy evaluation for decoupling calculation and control may be used even across functions which used internal state. This paper builds directly on top of the IO work at Glas-gow as reported by Peyton Jones and Wadler <ref> [PW93] </ref>, and summarised in Section 2. There are also strong similarities with the var work of Odersky, Rabin and Hudak [ORH93], which itself was influenced by Swarup, Reddy and Ireland [SRI91].
Reference: [Sha81] <author> Sharir, </author> <title> A Strong Connectivity Algorithm & its Application in Data Flow Analysis, </title> <booktitle> in Computers and Mathematics with Applications 7:1, </booktitle> <pages> pp. 67-72, </pages> <year> 1981. </year>
Reference-contexts: Strongly-Connected Components To demonstrate the flexibility of dfs we provide a second example of its use, this time the strongly connected components algorithm due to Kosaraju in 1978 (unpublished) <ref> [Sha81] </ref>. This example does not take particular advantage of laziness, but does show a reuse the DFS code. For the purposes of this algorithm, we originally specify a graph as a pair of bounds for the vertices (low and high), together with a list of edges.
Reference: [SRI91] <author> V.Swarup, U.Reddy and E.Ireland, </author> <title> Assignments for Applicative Languages, </title> <booktitle> proc. FPCA 91, LNCS 523, </booktitle> <address> London, </address> <year> 1991. </year>
Reference-contexts: This paper builds directly on top of the IO work at Glas-gow as reported by Peyton Jones and Wadler [PW93], and summarised in Section 2. There are also strong similarities with the var work of Odersky, Rabin and Hudak [ORH93], which itself was influenced by Swarup, Reddy and Ireland <ref> [SRI91] </ref>. Like Peyton Jones and Wadler, var provides only for strict imperative actions: no purely functional result is returned until the structure and content of the state is resolved.
Reference: [TJ92] <author> J-P.Talpin and P.Jouvelot, </author> <title> Polymorphic type, region and effect inference, </title> <booktitle> Jounal of Functional Programming, </booktitle> <volume> Vol 2, Part 3, </volume> <pages> CUP, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Cross references between supposedly independent state threads must be banned. Otherwise the result of a program could depend on the order of evaluation|the very thing we are trying to avoid. The best solution to this is almost certainly a stronger type system, perhaps like the effects system <ref> [TJ92] </ref>. This would determine that no supposedly pure calculation made reference to anything other than its own internal state.
Reference: [Wad92] <author> P.Wadler, </author> <title> Comprehending Monads, </title> <journal> MSCS, </journal> <volume> vol 2, </volume> <pages> pp 461-493, CUP, </pages> <year> 1992. </year>
Reference-contexts: Wadler recognised that the same principles apply for functional programs and, in particular, showed how the state monad could be used to incorporate imperative operations in a purely functional language <ref> [Wad92] </ref>. From this work it became clear that lazy evaluation and imperative actions could coexist quite happily, with each being able to pass values to the other. The Glasgow Haskell compiler incorporates extensions to the lazy functional language Haskell. These extensions implement imperative actions [PW93].
References-found: 10

