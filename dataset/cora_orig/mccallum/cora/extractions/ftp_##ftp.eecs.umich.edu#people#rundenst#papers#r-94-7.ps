URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-94-7.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: ygra@eecs.umich.edu, rundenst@eecs.umich.edu  
Phone: phone: 313-936-2971 fax: 313-763-1503  
Title: OODB Support for providing Transparent Schema Changes  
Author: Young-Gook Ra and Elke A. Rundensteiner 
Keyword: KEY WORDS Object-Oriented Databases, Interoperability, Migration Paths to Technological Advances, Transparent Schema Evolution.  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Electrical Engineering and Computer Science The University of Michigan,  
Abstract: Schema updates on shared object-oriented databases (OODBs) are almost always prohibited because of the risk of making existing application programs obsolete when run against the modified schema. We have proposed a solution approach, called Transparent Schema Evolution (TSE), that successfully addresses this problem by integrating schema evolution capabilities with object-oriented view facilities. In TSE, users interface with the OODB exclusively through their customized database view. In this paper, we identify key features required from OODB systems in order to provide such transparent schema change support, including multiple classification, dynamic reclassification, and flexible restructuring. Such features are currently not supported by commercial OODB systems. We thus propose a novel object-oriented modeling paradigm that overcomes these limitations. Key concepts of the proposed solution include object-slicing techniques and object-oriented views. In this paper, we describe a prototype implementation of the object-slicing paradigm that we have built to demonstrate the feasibility of our TSE approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner, </author> <title> "Objects and Views," </title> <booktitle> in Proc. ACM SIGMOD, </booktitle> <pages> pp. 238-247, </pages> <year> 1991. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views.
Reference: [2] <author> J. Banerjee, H. Chou, and W. Kim, </author> <title> "Data Model issues for Object-Oriented Applications," </title> <journal> ACM Trans. on Office Information Systems, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 3-26, </pages> <month> January 87. </month>
Reference-contexts: In addition, the implemen 8 tation objects of a same class are collected together and associated with the class to which they belong as an extent. 3 This notion of the extent is similar to that of Orion <ref> [2] </ref>. Object-slicing intrinsically includes its own inheritance mechanism, in which implementation objects search upwards for methods through other implementation objects. This means that objects of user-defined classes in our object-slicing representation can not directly use the GemStone inheritance mechanism.
Reference: [3] <author> J. Banerjee, W. Kim, and H. Kim, </author> <booktitle> "Semantics and Implementation of Schema Evolution in Object-Oriented Database ," in ACM SIGMOD, </booktitle> <pages> pp. 311-322, </pages> <year> 1987. </year>
Reference-contexts: Thus, there is active research on schema evolution <ref> [3, 12, 21, 9, 22] </ref>. However, even with the schema evolution support currently provided in most OODBs, schema updates on shared OODBs are problematic and thus generally avoided.
Reference: [4] <author> E. Bertino, </author> <title> "A View Mechanism for Object-Oriented Databases," </title> <booktitle> in EDBT, </booktitle> <pages> pp. 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: A recent SIGMOD record article by Tresch and Scholl [21] also advocates views as a suitable mechanism for simulating schema evolution. They state that schema evolution can be simulated using views if they are not capacity augmenting. In addition, <ref> [4] </ref> presents a view mechanism which can be utilized to simulate schema evolution. The proposed mechanism is capacity augmenting in that new stored attributes can be added to a view.
Reference: [5] <author> A. Chan, S. Danberg, S. Fox, W. Lin, A. Nori, and D. Ries, </author> " <title> Storage and Access Structures to Support a Semantic Data Model," </title> <booktitle> in VLDB, </booktitle> <pages> pp. 122-130, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: The "intersect" subclass is managed by the system but could be hidden from the user. This approach for multiple classification is considered in [8] and is taken for the implementation of the Daplex object model <ref> [5] </ref>. Instead, the object-slicing approach (Figure 5 (c)) would implement multiple classification by creating three objects to represent the O1 object, each of which carries data and behavior specific to its corresponding class.
Reference: [6] <author> D. Fishman, </author> <title> "Iris: An Object Oriented Database Management System," </title> <journal> in ACM Trans. on Office Info. Sys., </journal> <volume> volume 5, </volume> <pages> pp. 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This situation of an object being classified as an instance of more than one class even though the classes are not super/subclass of each other is called multiple classification. To the best of our knowledge, current OODB systems do not support multiple classification. The only exception is IRIS <ref> [6] </ref> a functional database system that actually uses a relational database as storage structure, storing data from one object across many relations. Other OODBs typically represent an object as a chunk of contiguous storage based on the type determined at object creation time. <p> TSE system goes one step further, however, by supporting a comprehensive set of schema change operations [13]. Realization of TSE using the view approach requires multiple classification from the object model. As discussed earlier, IRIS is the only commercially available OODB system supporting multiple classification <ref> [6] </ref>. IRIS is a functional database system that uses a relational database as storage structure, storing data from one object across many relations. However, IRIS is limited in that it restricts the modification of populated classes such that instances do not have to be modified.
Reference: [7] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending Object-Oriented Systems with Roles. </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: Concepts of this implementation are related to the ideas of role systems, where an object may serve different roles according to the given context <ref> [19, 7, 14] </ref>. This paper describes the prototype of this object layer, which we have built on top of the commercial system GemStone to demonstrate feasibility of our TSE approach. <p> However, IRIS is limited in that it restricts the modification of populated classes such that instances do not have to be modified. Our object-slicing implementation can be compared to mechanisms used in role modeling approaches <ref> [7, 14, 19] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically.
Reference: [8] <author> H. Kim, </author> <title> "Issues in Object-Oriented Database Schemas," in Diss., </title> <institution> Dept. of Comp. Sci., Univ. of Texas at Austin, TR-88-20, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: We could then create O1 as a member of the intersect class (Figure 5 (b)). The "intersect" subclass is managed by the system but could be hidden from the user. This approach for multiple classification is considered in <ref> [8] </ref> and is taken for the implementation of the Daplex object model [5]. Instead, the object-slicing approach (Figure 5 (c)) would implement multiple classification by creating three objects to represent the O1 object, each of which carries data and behavior specific to its corresponding class.
Reference: [9] <author> W. Kim and H. Chou, </author> <title> "Versions of Schema For Object-Oriented Databases," </title> <booktitle> in Proc. 14th VLDB, </booktitle> <pages> pp. 148-159, </pages> <year> 1988. </year>
Reference-contexts: Thus, there is active research on schema evolution <ref> [3, 12, 21, 9, 22] </ref>. However, even with the schema evolution support currently provided in most OODBs, schema updates on shared OODBs are problematic and thus generally avoided. <p> Thus, TSE can keep the old versions (i.e., views) of a schema instead of modifying them; efficiently achieving schema versioning using a view system. 1 Note that in the TSE approach, unlike in other systems <ref> [9] </ref>, the scope of a schema version (view) is not confined to the objects which have been created under this particular schema version. <p> priority to the leftmost subclass of each class. 3. to detect the potential ambiguity at schema compilation, in cases when detectable, and let the user resolve it. 5 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [9, 20] </ref>. Some systems such as such as Encore [20], Orion [9], and CLOSQL [12] use more traditional ver-sioning concepts rather than the view approach. <p> Some systems such as such as Encore [20], Orion <ref> [9] </ref>, and CLOSQL [12] use more traditional ver-sioning concepts rather than the view approach. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created.
Reference: [10] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Developing an Object-Oriented View Management System," </title> <booktitle> in Proceedings of CASCON, </booktitle> <pages> pp. 548-562, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views.
Reference: [11] <author> S. Marche, </author> <title> "Measuring the Stability of Data Models," </title> <journal> European Journal of Information Systems, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 37-47, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research, not only because data models are less stable fl This work was supported in part by the NSF RIA grant #IRI-9309076, the University of Michigan Faculty Award Program, and the NSF NYI grant #IRI-9457609. than expected <ref> [11] </ref>, but also because typical OODB application areas such CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. Thus, there is active research on schema evolution [3, 12, 21, 9, 22].
Reference: [12] <author> S. Monk and I. Sommerville, </author> " <title> Schema Evolution in OODBs Using Class Versioning," </title> <booktitle> in SIGMOD RECORD, </booktitle> <volume> VOL. 22, NO.3, </volume> <pages> pp. 16-22, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Thus, there is active research on schema evolution <ref> [3, 12, 21, 9, 22] </ref>. However, even with the schema evolution support currently provided in most OODBs, schema updates on shared OODBs are problematic and thus generally avoided. <p> Some systems such as such as Encore [20], Orion [9], and CLOSQL <ref> [12] </ref> use more traditional ver-sioning concepts rather than the view approach. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created.
Reference: [13] <author> Y. Ra and E. A. Rundensteiner, </author> <title> "A Transparent Object-Oriented Schema Change Approach Using View Schema Evolution," </title> <note> in Tech. Report CSE-TR-211-94, </note> <institution> Dept. of EECS, Univ. of Michigan, </institution> <month> February </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: For TSE we clearly need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data [21]) <ref> [13] </ref>. This requires that the physical object representation can be efficiently restructured to accommodate new storage for the new added attributes. In addition to the restructuring capability, multiple classification must also be supported by the OODB model, meaning an object can be classified as an instance of multiple classes. <p> We have developed solutions to all these problems based on object-oriented view mechanisms <ref> [13] </ref>. In particular, in the next section, we discuss extensions of MultiView required to be capacity-augmenting. <p> It is not clear how she deals with the requirements of multiple classification and dynamic restructuring. The above two papers explain their approaches by presenting some examples. TSE system goes one step further, however, by supporting a comprehensive set of schema change operations <ref> [13] </ref>. Realization of TSE using the view approach requires multiple classification from the object model. As discussed earlier, IRIS is the only commercially available OODB system supporting multiple classification [6].
Reference: [14] <author> J. Richardson and P. Schwarz, </author> <title> "Aspects: Extending objects to support multiple, independent roles," </title> <booktitle> SIGMOD, </booktitle> <pages> pp. 298-307, </pages> <year> 1991. </year>
Reference-contexts: Concepts of this implementation are related to the ideas of role systems, where an object may serve different roles according to the given context <ref> [19, 7, 14] </ref>. This paper describes the prototype of this object layer, which we have built on top of the commercial system GemStone to demonstrate feasibility of our TSE approach. <p> However, IRIS is limited in that it restricts the modification of populated classes such that instances do not have to be modified. Our object-slicing implementation can be compared to mechanisms used in role modeling approaches <ref> [7, 14, 19] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically.
Reference: [15] <author> E. A. Rundensteiner, </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in Object-Oriented Databases," </title> <booktitle> in 18th VLDB, </booktitle> <pages> pp. 187-198, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system <ref> [15] </ref>. However, like all other current OO view systems that we are aware of [1, 10, 18, 17, 15, 16], the original MultiView prototype did not support capacity-augmenting views. <p> To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views. <p> The dotted ellipses represent virtual classes, whereas the solid ellipses represent base classes. Second, the two virtual classes are integrated into one global schema by the classification algorithm of our view system as shown in Figure 3 (c) <ref> [15] </ref>. Third, the system selects the classes Person, Student' and TA' for the new view. It then renames the Student' and TA' classes to Student and TA within the context of the view, respectively. <p> In Section 3.2, we identify specific requirements for the object data model caused by these TSE requirements. 3.1 MultiView Extensions Since our TSE approach is based on object-oriented view concepts, we describe below the view system we have developed towards the specification and maintenance of views, called Mul-tiView <ref> [15] </ref>. MultiView creates a complete view schema rather than just deriving individual virtual classes. Furthermore, views in MultiView allow for the insertion of new classes or the modification of existing classes into one consistent class hierarchy. <p> In addition, MultiView offers the following features that make it suitable as foundation for our schema change approach. First, it generates updatable views <ref> [15] </ref>. Second, several of the view specification subtasks are already automated and can be reused in our system. Last, a prototype of Mul-tiView has been implemented at the University of Michigan and thus can be used as a platform for constructing the TSE system. <p> Last, a prototype of Mul-tiView has been implemented at the University of Michigan and thus can be used as a platform for constructing the TSE system. Since our view schema evolution approach is built using the MultiView system, we use the view definition language of MultiView, an object algebra <ref> [15, 17, 16] </ref>, as foundation of our TSE system. We find that a subset of MultiView's object-preserving algebra is sufficient to achieve typical schema change modification, namely select, hide, difference, union, and refine. A de 5 tailed definition of syntax and semantics of these operators can be found in [15]. <p> We find that a subset of MultiView's object-preserving algebra is sufficient to achieve typical schema change modification, namely select, hide, difference, union, and refine. A de 5 tailed definition of syntax and semantics of these operators can be found in <ref> [15] </ref>. In the context of the TSE approach, we apply them to classes in order to derive new virtual classes. Multi-View allows arbitrary queries composed by nesting these object algebra operators to serve as view definitions, exactly as in relational DBMSs: defineVC &lt;name&gt; as &lt;query&gt;.
Reference: [16] <author> E. A. Rundensteiner, </author> <title> "Tools for View Generation in Object-Oriented Database," </title> <booktitle> in CIKM, </booktitle> <pages> pp. 635-644, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views. <p> It then renames the Student' and TA' classes to Student and TA within the context of the view, respectively. Fourth, a new view schema VS2 is generated from the selected classes by running the schema generation algo rithm <ref> [16] </ref>. At last, the system replaces the old view with the newly generated view. Because all these procedures are transparent to him/her, the schema change specifier will have the perception that the original schema has actually been modified. <p> Last, a prototype of Mul-tiView has been implemented at the University of Michigan and thus can be used as a platform for constructing the TSE system. Since our view schema evolution approach is built using the MultiView system, we use the view definition language of MultiView, an object algebra <ref> [15, 17, 16] </ref>, as foundation of our TSE system. We find that a subset of MultiView's object-preserving algebra is sufficient to achieve typical schema change modification, namely select, hide, difference, union, and refine. A de 5 tailed definition of syntax and semantics of these operators can be found in [15].
Reference: [17] <author> E. A. Rundensteiner and L. Bic, </author> <title> "Set Operations in Object-Based Data Models," </title> <journal> IEEE Trans. on Data and Knowledge Engineering, </journal> <pages> pp. 382-398, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views. <p> Last, a prototype of Mul-tiView has been implemented at the University of Michigan and thus can be used as a platform for constructing the TSE system. Since our view schema evolution approach is built using the MultiView system, we use the view definition language of MultiView, an object algebra <ref> [15, 17, 16] </ref>, as foundation of our TSE system. We find that a subset of MultiView's object-preserving algebra is sufficient to achieve typical schema change modification, namely select, hide, difference, union, and refine. A de 5 tailed definition of syntax and semantics of these operators can be found in [15].
Reference: [18] <author> M. Scholl and C. Laasch, </author> <title> "Updatable views in object-oriented databases," </title> <booktitle> in Proceedings of the Second DOOD Conference, </booktitle> <pages> pp. 1-19, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: To realize the TSE approach in a working system, we need to utilize object-oriented view mechanisms. We have based our TSE design on the MultiView object-oriented view system [15]. However, like all other current OO view systems that we are aware of <ref> [1, 10, 18, 17, 15, 16] </ref>, the original MultiView prototype did not support capacity-augmenting views.
Reference: [19] <author> E. Sciore, </author> <title> "Object specialization," </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pp. 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Concepts of this implementation are related to the ideas of role systems, where an object may serve different roles according to the given context <ref> [19, 7, 14] </ref>. This paper describes the prototype of this object layer, which we have built on top of the commercial system GemStone to demonstrate feasibility of our TSE approach. <p> However, IRIS is limited in that it restricts the modification of populated classes such that instances do not have to be modified. Our object-slicing implementation can be compared to mechanisms used in role modeling approaches <ref> [7, 14, 19] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically. <p> In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically. In <ref> [19] </ref>, a real world entity is modeled by multiple objects arranged in an object hierarchy. Although our implementation objects resemble object hierarchies in that they inherit from each other, our model restricts object hierarchies to conform to the class hierarchy model.
Reference: [20] <author> A. H. Skarra and S. B. Zdonik, </author> <title> "The Management of Changing Types in an Object-Oriented Database," </title> <booktitle> in Proc. 1st OOPSLA, </booktitle> <pages> pp. 483-494, </pages> <year> 1986. </year>
Reference-contexts: priority to the leftmost subclass of each class. 3. to detect the potential ambiguity at schema compilation, in cases when detectable, and let the user resolve it. 5 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [9, 20] </ref>. Some systems such as such as Encore [20], Orion [9], and CLOSQL [12] use more traditional ver-sioning concepts rather than the view approach. <p> Some systems such as such as Encore <ref> [20] </ref>, Orion [9], and CLOSQL [12] use more traditional ver-sioning concepts rather than the view approach. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created.
Reference: [21] <author> M. Tresch and M. H. Scholl, </author> <title> "Schema Transformation without Database Reorganization," </title> <booktitle> in SIGMOD RECORD, </booktitle> <pages> pp. 21-27, </pages> <year> 1993. </year>
Reference-contexts: Thus, there is active research on schema evolution <ref> [3, 12, 21, 9, 22] </ref>. However, even with the schema evolution support currently provided in most OODBs, schema updates on shared OODBs are problematic and thus generally avoided. <p> For TSE we clearly need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data <ref> [21] </ref>) [13]. This requires that the physical object representation can be efficiently restructured to accommodate new storage for the new added attributes. In addition to the restructuring capability, multiple classification must also be supported by the OODB model, meaning an object can be classified as an instance of multiple classes. <p> We solve this problem by specifying the schema change directly on a view rather than on the global schema. A recent SIGMOD record article by Tresch and Scholl <ref> [21] </ref> also advocates views as a suitable mechanism for simulating schema evolution. They state that schema evolution can be simulated using views if they are not capacity augmenting. In addition, [4] presents a view mechanism which can be utilized to simulate schema evolution.
Reference: [22] <author> R. Zicari, </author> <title> "A Framework for O 2 Schema Updates," </title> <booktitle> in 7th IEEE International Conf. on Data Engineering, </booktitle> <pages> pp. 146-182, </pages> <month> April </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: Thus, there is active research on schema evolution <ref> [3, 12, 21, 9, 22] </ref>. However, even with the schema evolution support currently provided in most OODBs, schema updates on shared OODBs are problematic and thus generally avoided.
References-found: 22

