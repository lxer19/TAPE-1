URL: http://www.cs.ucl.ac.uk/staff/L.Braine/ifl96.ps
Refering-URL: http://www.cs.ucl.ac.uk/dept-seminar-abstracts/dept-seminar-961017.html
Root-URL: http://www.cs.ucl.ac.uk
Email: L.Braine@cs.ucl.ac.uk C.Clack@cs.ucl.ac.uk  
Title: Introducing CLOVER: an Object-Oriented Functional Language  
Author: Lee Braine and Chris Clack 
Address: Gower Street, London WC1E 6BT, UK  
Affiliation: Department of Computer Science, University College London,  
Abstract: The search for a language which combines both functional and object-oriented features has a long and distinguished history [Can82, Car84, BK86, BD88, BGW91, MHH91, AP93, CL91, MMH91, Sar93, CL96]. The aim is to integrate the formal methods benefits of functional programming with the software engineering benefits of both paradigms. However, to date we know of no language which can claim to be both purely functional and purely object-oriented (and retains complete type safety). We present CLOVER, a new language which is 100% functional and 99% object-oriented. It is also completely type safe. We explain the design issues and how CLOVER achieves its aim. We also explain the "missing" 1%, discuss its relevance, and illustrate how its loss can be extenuated through the use of a new visual programming notation. 
Abstract-found: 1
Intro-found: 1
Reference: [AF95] <author> Aiken, A., Fahndrich, M.: </author> <title> Dynamic Typing and Subtype Inference. </title> <type> Technical Report, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <year> (1995) </year>
Reference-contexts: This is not what functional programmers think of as "type safe"! The FP world requires complete type safety, where the type system guarantees that it is impossible for a type error to occur at run-time. Dynamic types thus appear to compromise type safety, though recent work <ref> [AW94, AF95, AM90] </ref> partially extenuates the problem. 4.2 Type Safety versus Overloading and Partial Applications Overloading is a common feature of OO languages, allowing different definitions for the same method name.
Reference: [AH87] <author> Agha, G., Hewitt, C.: </author> <title> Actors: A Conceptual Foundation for Concurrent Object-Oriented Programming. </title> <editor> In Shriver & Wegner (Eds), </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <year> (1987) </year> <month> 47-74 </month>
Reference-contexts: From the foregoing discussion it can be seen that we align ourselves with the Actor model <ref> [AH87] </ref> used for distributed OOP based on sequences of behaviours rather than state changes. This is also similar to the continuation-passing style often used by FP programmers.
Reference: [AM90] <author> Aiken, A., Murphy, B.: </author> <title> Static Type Inference in a Dynamically Typed Language. </title> <type> Technical Report, </type> <institution> IBM Almaden Research Centre, </institution> <year> (1990) </year>
Reference-contexts: This is not what functional programmers think of as "type safe"! The FP world requires complete type safety, where the type system guarantees that it is impossible for a type error to occur at run-time. Dynamic types thus appear to compromise type safety, though recent work <ref> [AW94, AF95, AM90] </ref> partially extenuates the problem. 4.2 Type Safety versus Overloading and Partial Applications Overloading is a common feature of OO languages, allowing different definitions for the same method name.
Reference: [AP93] <author> Ait-Kaci, H., Podelski, A.: </author> <title> Towards a Meaning of LIFE. </title> <journal> Journal of Logic Programming, </journal> <pages> 16(3-4), </pages> <year> (1993) </year> <month> 195-234 </month>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE <ref> [AP93] </ref> only supports a simulation of FP, and HOP [DV96] does not support full OOP. Kea [MHH91], Rapide and HOP are briefly outlined below: - Kea is a higher-order, polymorphic, lazy functional language supporting multi-methods and a type inference system.
Reference: [AW93] <author> Aiken, A., Wimmer, E.: </author> <title> Type Inclusion Constraints and Type Inference. </title> <type> Technical Report, </type> <institution> IBM Almaden Research Center, </institution> <year> (1993) </year>
Reference-contexts: Our type matcher checks declared return types against declared argument types, for every application, to ensure that the subset relationship holds. We do not attempt type inference; type inference for inclusion polymorphism has long been considered problematic, yet we are encouraged by recent work <ref> [AW93, BM96] </ref>. We also intend to investigate the provision of incremental type inference, but this is left for future work. 7 Abstract Expression Semantics Space does not permit a full exposition of CLOVER's abstract expression semantics.
Reference: [AW94] <author> Aiken, A., Wimmers, E.: </author> <title> Soft Typing with Conditional Types. </title> <booktitle> In Proc. 21st POPL, </booktitle> <year> (1994) </year>
Reference-contexts: This is not what functional programmers think of as "type safe"! The FP world requires complete type safety, where the type system guarantees that it is impossible for a type error to occur at run-time. Dynamic types thus appear to compromise type safety, though recent work <ref> [AW94, AF95, AM90] </ref> partially extenuates the problem. 4.2 Type Safety versus Overloading and Partial Applications Overloading is a common feature of OO languages, allowing different definitions for the same method name.
Reference: [BD88] <author> Bobrow, D., DeMichiel, L., et al.: </author> <title> Common Lisp Object System Specification. </title> <journal> SIGPLAN Notices v23, </journal> <year> (1988) </year>
Reference-contexts: This work culminated in CLOS <ref> [BD88] </ref>, a set of tools for developing object-oriented programs in Common LISP [Ste84].
Reference: [Ber92] <author> Berger, E.: </author> <title> FP + OOP = Haskell. </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <year> (1992) </year>
Reference-contexts: Haskell [HPW91] has at various times been the subject of claims that its type classes mechanism [WB89] facilitates OO programming <ref> [Ber92] </ref>; this has promulgated the mistaken assumption that Haskell's type classes provide sub-typing. Unfortunately type classes do not provide the subtype relationship that we require; rather, they support a structured form of overloading.
Reference: [BGW91] <author> Bobrow, D., Gabriel, R., White, J.: </author> <title> CLOS: Integrating Object-Oriented and Functional Programming. </title> <type> CACM 34(9), </type> <year> (1991) </year> <month> 28-38 </month>
Reference-contexts: This work culminated in CLOS [BD88], a set of tools for developing object-oriented programs in Common LISP [Ste84]. Significant claims have been made <ref> [BGW91] </ref> that CLOS combines both OOP and FP yet, because it is based on LISP (like Flavors and Common-LOOPS), it is not referentially transparent and therefore fails to satisfy our primary criterion. 3.2 1990-1992 In the early 1990s interest in OOP/FP integration increased, with several newly developed languages.
Reference: [BK86] <editor> Bobrow, D., Kahn, K., et al.: CommonLOOPS: </editor> <booktitle> Merging Lisp and Object-Oriented Programming. In Proc. ACM OOPSLA, </booktitle> <year> (1986) </year>
Reference-contexts: system with a pairwise relation on types which provides a partial ordering. 3 Related Work Since at least the early 1980s there has been considerable interest in the formal-isation of OOP, most notable being attempts to integrate OOP and FP. 3.1 1980-1989 Early work such as Flavors [Can82] and CommonLOOPS <ref> [BK86] </ref> involved the extension of LISP with object-oriented features. This work culminated in CLOS [BD88], a set of tools for developing object-oriented programs in Common LISP [Ste84].
Reference: [BM96] <author> Bourdoncle, F., Merz, S.: </author> <title> Primitive subtyping ^ implicit polymorphism j= object-orientation. </title> <booktitle> In Proc. 3rd FOOL, </booktitle> <year> (1996) </year>
Reference-contexts: A notable exception is Mitchell's extension to the SML type system to admit inclusion poly-morphism through subtyping [MMH91]. Subtyping in HOP [DV96] claims to be based largely on Mitchell's work (using recursive type constraints). Whereas polymorphic type inference used to be considered undecidable for inclusion types, recent work <ref> [BM96] </ref> has demonstrated that decidable systems can be implemented. 4.5 Lazy Evaluation versus Discrete Messages and State Update We wish to retain the powerful FP feature of lazy evaluation, yet this does not seem to have a natural meaning within the message-passing view of OOP. For example: 1. <p> Our type matcher checks declared return types against declared argument types, for every application, to ensure that the subset relationship holds. We do not attempt type inference; type inference for inclusion polymorphism has long been considered problematic, yet we are encouraged by recent work <ref> [AW93, BM96] </ref>. We also intend to investigate the provision of incremental type inference, but this is left for future work. 7 Abstract Expression Semantics Space does not permit a full exposition of CLOVER's abstract expression semantics.
Reference: [Boo94] <author> Booch, G.: </author> <title> Object-Oriented Analysis and Design with Applications, Second Edition. </title> <address> Benjamin-Cummings, </address> <year> (1994) </year>
Reference-contexts: Further Terms: Binary methods take a parameter (in addition to the distinguished object) which has the same type as the distinguished object. Delegation is the act of one object forwarding an operation to another object, to be performed on behalf of the first object <ref> [Boo94] </ref>. A distinguished object (DO) is used at run-time to resolve method overriding and determine which implementation should be used for a given method application (vide overloading and overriding). <p> Dynamic typing associates a name with a type at run-time. Inheritance is a relationship among classes, wherein a class shares the attributes or methods defined in one (single inheritance) or more (multiple inheritance) other classes (see also <ref> [Boo94] </ref>). - Multi-methods is a run-time feature which allows dynamic despatch to be based on more than one parameter. Overloading provides multiple implementations for a method, each with a distinct type. <p> Control-flow diagrams are clearly inappropriate for a single-assignment, expression-based language, and data-flow diagrams provide no semantics for OO notions of object identity (with or without behaviours), subsumption, dynamic despatch, etc. A common OO notation is the object diagram <ref> [Boo94] </ref>, otherwise known as message-passing or message-flow notation; unfortunately, this notation relies on multiple assignment and does not support the concept of laziness. Our solution is to use a notation that is almost the dual of message-flow notation, and is similar to Uflow notation [SKA94].
Reference: [Bud95] <author> Budd, T.: </author> <title> Multiparadigm Programming in Leda. </title> <publisher> Addison-Wesley, </publisher> <year> (1995) </year>
Reference-contexts: However, four of these languages (Leda <ref> [Bud95] </ref>, Quest [CL91], Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP.
Reference: [Can82] <author> Cannon, H.: </author> <title> Flavors: A non-hierarchical approach to object-oriented programming. </title> <publisher> Symbolics Inc., </publisher> <year> (1982) </year>
Reference-contexts: as a type system with a pairwise relation on types which provides a partial ordering. 3 Related Work Since at least the early 1980s there has been considerable interest in the formal-isation of OOP, most notable being attempts to integrate OOP and FP. 3.1 1980-1989 Early work such as Flavors <ref> [Can82] </ref> and CommonLOOPS [BK86] involved the extension of LISP with object-oriented features. This work culminated in CLOS [BD88], a set of tools for developing object-oriented programs in Common LISP [Ste84].
Reference: [Car84] <author> Cardelli, L.: </author> <title> A Semantics of Multiple Inheritance. </title> <booktitle> In Proc. Intl. Symposium on Semantics of Data Types, </booktitle> <year> (1984) </year> <month> 51-67 </month>
Reference-contexts: We therefore currently implement a simple subtype matching algorithm. We take a traditional set-theoretic view of the class system <ref> [Car84] </ref>: class types are sets of attributes and methods, with subclassing equivalent to sub-typing. Subtypes are ordered inversely by set-inclusion over the above semantic domain.
Reference: [Cas95] <author> Castagna, G.: </author> <title> Covariance and Contravariance: Conflict without a Cause. </title> <journal> ACM TOPLAS, </journal> <volume> 17(3), </volume> <year> (1995) </year> <month> 431-447 </month>
Reference: [CC89] <author> Canning, P., Cook, W., et al.: </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Proc. </booktitle> <address> FPCLA, </address> <year> (1989) </year> <month> 273-280 </month>
Reference-contexts: Our prototype does not yet support recursive types, though they are an essential element of CLOVER. We plan to implement F-Bounded quantification <ref> [CC89] </ref>. Our type matcher checks declared return types against declared argument types, for every application, to ensure that the subset relationship holds. We do not attempt type inference; type inference for inclusion polymorphism has long been considered problematic, yet we are encouraged by recent work [AW93, BM96].
Reference: [CCP95] <author> Clack, C., Clayman, S., Parrott, D.: </author> <title> Lexical Profiling | Theory and Practice. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(2), </volume> <year> (1995) </year> <month> 225-277 </month>
Reference-contexts: Run-time analyses can be assisted by the addition of algorithm animation and the extension of lexical profiling <ref> [CCP95] </ref> to visual profiling. A revised object-oriented analysis and design notation will be required because existing notations assume stateful objects.
Reference: [CL91] <author> Cardelli, L., Longo, G.: </author> <title> A Semantic Basis for Quest. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4), </volume> <year> (1991) </year> <month> 417-458 </month>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest <ref> [CL91] </ref>, Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP.
Reference: [CL96] <author> Caseau, Y., Laburthe, F.: </author> <title> Introduction to the CLAIRE Programming Language. </title> <type> Technical Report, </type> <institution> LIENS, </institution> <year> (1996) </year>
Reference-contexts: Objective ML [RV96] is implemented on top of Caml Special Light and is an extension of ML with objects, top-level classes, multiple inheritance, methods returning self, binary methods and parametric classes. Object ML [RR96] extends ML with objects, subtyping and heterogeneous collections. CLAIRE <ref> [CL96] </ref> is a high-level functional and object-oriented language with advanced rule processing capabilities. Bla [Oor96] claims to unite functional and object-oriented programming through first class environments [GJL87]. <p> This also provides obvious benefits for searching algorithms which use backtracking; previous incarnations of an object are immediately accessible. The idea is not new: CLAIRE <ref> [CL96] </ref> provides versioning for the entire object database, however we provide versioning on a per-object basis.
Reference: [CW85] <author> Cardelli, L., Wegner, P.: </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <year> (1985) </year> <month> 471-522 </month>
Reference-contexts: is bound dynamically to the distinguished object. - Subsumption allows a function of type oe 1 ! oe 2 to be provided with an argument of type oe 3 iff oe 3 is a subtype of oe 1 . - Subtyping has been defined in many ways (see, for example, <ref> [CW85] </ref>). <p> We currently require the programmer to give explicit upperbound types in all method type signatures and for all method arguments, though in future we hope to implement a subtype inference system. Inclusion polymorphism is thus implemented as bounded universal quantification <ref> [CW85] </ref>. Monotonic inheritance: For completely safe method despatch, statically resolvable upperbounds are only part of the solution. When a message is passed to an object, the required method must also actually be defined for that object. <p> This generalises to multiple arguments and overloadings with different numbers of arguments. Note that this style of overloading permits some covariant specialisation. 6.5 Polymorphism Polymorphism is supported in CLOVER through bounded universal quantification <ref> [CW85] </ref> which provides both inclusion and parametric polymorphism without the need for type variables (which are replaced by subtype constraints). Our prototype does not yet support recursive types, though they are an essential element of CLOVER. We plan to implement F-Bounded quantification [CC89].
Reference: [DM82] <author> Damas, L., Milner, R.: </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th POPL, </booktitle> <year> (1982) </year> <month> 207-212 </month>
Reference-contexts: Similarly, subsumption requires sub-typing to be applied to method arguments. FP languages rely on advanced polymorphic type inference to ensure type correctness. The type systems of most FP languages are based on the Hind-ley/Milner algorithm <ref> [DM82] </ref> which does not admit subtypes. A notable exception is Mitchell's extension to the SML type system to admit inclusion poly-morphism through subtyping [MMH91]. Subtyping in HOP [DV96] claims to be based largely on Mitchell's work (using recursive type constraints).
Reference: [DV96] <author> Dami, L., Vitek, J.: </author> <title> Introduction to HOP, a Functional and Object-Oriented Language. </title> <note> Submitted for publication, </note> <year> (1996) </year>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP <ref> [DV96] </ref> does not support full OOP. Kea [MHH91], Rapide and HOP are briefly outlined below: - Kea is a higher-order, polymorphic, lazy functional language supporting multi-methods and a type inference system. Unlike Smalltalk [GR83], Kea does not enforce certain aspects of OO encapsulation. <p> The type systems of most FP languages are based on the Hind-ley/Milner algorithm [DM82] which does not admit subtypes. A notable exception is Mitchell's extension to the SML type system to admit inclusion poly-morphism through subtyping [MMH91]. Subtyping in HOP <ref> [DV96] </ref> claims to be based largely on Mitchell's work (using recursive type constraints).
Reference: [DY94] <author> Drossopoulou, S., Yang, D.: ST&T: </author> <title> Smalltalk with Types. </title> <type> Technical Report DOC 94/11, </type> <institution> Imperial College, </institution> <year> (1994) </year>
Reference-contexts: OBJ [GWM93] is a functional language that supports multiple inheritance, exception handling and overloading but has no higher-order programming facilities. ST&T <ref> [DY94] </ref> is an extension of Smalltalk's type system bringing it closer to ML, though the result is first-order, strict, and still not referentially transparent. Uflow [SKA94] is an extension to UFO using a data-flow model for visualising execution, but is still not referentially transparent.
Reference: [DY96] <author> Drossopoulou, S., Yang, D.: </author> <title> Permissive Types. </title> <booktitle> Proc. 3rd FOOL, </booktitle> <year> (1996) </year>
Reference: [GJL87] <author> Gelernter, D., Jagannathan, S., London, T.: </author> <title> Environments as First Class Objects. </title> <booktitle> In Proc. 14th POPL, </booktitle> <year> (1987) </year> <month> 98-100 </month>
Reference-contexts: Object ML [RR96] extends ML with objects, subtyping and heterogeneous collections. CLAIRE [CL96] is a high-level functional and object-oriented language with advanced rule processing capabilities. Bla [Oor96] claims to unite functional and object-oriented programming through first class environments <ref> [GJL87] </ref>.
Reference: [GR83] <author> Goldberg, A., Robson, D.: </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> (1983) </year>
Reference-contexts: Kea [MHH91], Rapide and HOP are briefly outlined below: - Kea is a higher-order, polymorphic, lazy functional language supporting multi-methods and a type inference system. Unlike Smalltalk <ref> [GR83] </ref>, Kea does not enforce certain aspects of OO encapsulation. In particular, Kea functions do not have to be associated with classes according to a distinguished object.
Reference: [GWM93] <author> Goguen, J., Winkler, T., Meseguer, J., Futatsugi, K., Jouannaud, J.: </author> <title> Introducing OBJ. Tutorial and Manual, </title> <institution> Computing Laboratory, Oxford University, </institution> <year> (1993) </year>
Reference-contexts: However, there is as yet no clear notion of "object" and no explanation of how dynamic despatch, inheritance, subsumption, overloading and overriding would be implemented. 3.3 1993-1995 In this period there were a number of notable attempts at integration, plus extensions of previous systems. OBJ <ref> [GWM93] </ref> is a functional language that supports multiple inheritance, exception handling and overloading but has no higher-order programming facilities. ST&T [DY94] is an extension of Smalltalk's type system bringing it closer to ML, though the result is first-order, strict, and still not referentially transparent.
Reference: [HPW91] <editor> Hudak, P., Peyton Jones, S., Wadler, P. (Eds): </editor> <title> Report on the Programming Language Haskell. </title> <institution> Department of Computing Science, University of Glasgow, </institution> <year> (1991) </year>
Reference-contexts: Furthermore, as we have already seen, it is difficult to reconcile curried partial applications with dynamic despatch and full overloading. 4.4 Subtyping Subtyping is central to OOP but absent from current "production" FP languages. Haskell <ref> [HPW91] </ref> has at various times been the subject of claims that its type classes mechanism [WB89] facilitates OO programming [Ber92]; this has promulgated the mistaken assumption that Haskell's type classes provide sub-typing.
Reference: [Ler95] <author> Leroy, X.: </author> <title> Le systeme Caml Special Light: modules et compilation ef-ficace en Caml. </title> <type> Research Report 2721, </type> <institution> Institut National de Recherche en Informatique et Automatique (INRIA), </institution> <year> (1995) </year>
Reference-contexts: ST&T [DY94] is an extension of Smalltalk's type system bringing it closer to ML, though the result is first-order, strict, and still not referentially transparent. Uflow [SKA94] is an extension to UFO using a data-flow model for visualising execution, but is still not referentially transparent. Finally, Caml Special Light <ref> [Ler95] </ref> (later re-named Objective Caml) laid the foundations for Objective ML (see next subsection), but unfortunately these foundations are not referentially transparent. 3.4 1996 This year has witnessed an intensifying of interest in the field with several new languages being established, including our language CLOVER.
Reference: [Mey91] <author> Meyer, B.: </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <year> (1991) </year>
Reference-contexts: Many OO languages assume and accept that this implies type errors may occur at run-time. Having realised that this is undesirable, some OO language designers have created what they claim to be "type safe" OO languages: Eiffel <ref> [Mey91] </ref>, for example, makes this claim. However, Eiffel actually provides an assignment attempt operator which handles run-time type errors in a controlled manner by assigning a void value; it is assumed that the programmer will always check for the possibility of a void value and take appropriate action.
Reference: [MHH91] <author> Mugridge, W., Hosking, J., Hammer, J.: </author> <title> Multi-methods in a Statically-Typed Programming Language. </title> <booktitle> In Proc. </booktitle> <address> ECOOP'91, </address> <year> (1991) </year>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP. Kea <ref> [MHH91] </ref>, Rapide and HOP are briefly outlined below: - Kea is a higher-order, polymorphic, lazy functional language supporting multi-methods and a type inference system. Unlike Smalltalk [GR83], Kea does not enforce certain aspects of OO encapsulation. <p> Unlike Smalltalk [GR83], Kea does not enforce certain aspects of OO encapsulation. In particular, Kea functions do not have to be associated with classes according to a distinguished object. Furthermore, Kea's notion of polymorphism only admits the single type variable Any, and <ref> [MHH91] </ref> mentions that Kea "is currently being extended to include higher-order and (implicitly) polymorphic functions", which implies that it does not have these features. - Rapide extends Standard ML (SML) [MTH90] with subtyping and inheritance.
Reference: [MMH91] <author> Mitchell, J., Meldal, S., Hadhav, N.: </author> <title> An Extension of Standard ML Modules with Subtyping and Inheritance. </title> <booktitle> In Proc. 18th POPL, </booktitle> <year> (1991) </year>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide <ref> [MMH91] </ref> and UFO [Sar93]) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP. <p> FP languages rely on advanced polymorphic type inference to ensure type correctness. The type systems of most FP languages are based on the Hind-ley/Milner algorithm [DM82] which does not admit subtypes. A notable exception is Mitchell's extension to the SML type system to admit inclusion poly-morphism through subtyping <ref> [MMH91] </ref>. Subtyping in HOP [DV96] claims to be based largely on Mitchell's work (using recursive type constraints).
Reference: [MTH90] <author> Milner, R., Tofte, M., Harper, R.: </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> (1990) </year>
Reference-contexts: Furthermore, Kea's notion of polymorphism only admits the single type variable Any, and [MHH91] mentions that Kea "is currently being extended to include higher-order and (implicitly) polymorphic functions", which implies that it does not have these features. - Rapide extends Standard ML (SML) <ref> [MTH90] </ref> with subtyping and inheritance. Objects are modelled as structures, and SML is extended so that structures may be passed to and from functions. Unfortunately, Rapide re tains SML's lack of referential transparency and, indeed, relies on it.
Reference: [Oor96] <author> Oortmerssen, W.: </author> <title> The Bla Language: Extending Functional Programming with First Class Environments. </title> <type> Masters thesis, </type> <institution> Department of Computational Linguistics, University of Amsterdam, </institution> <year> (1996) </year>
Reference-contexts: Object ML [RR96] extends ML with objects, subtyping and heterogeneous collections. CLAIRE [CL96] is a high-level functional and object-oriented language with advanced rule processing capabilities. Bla <ref> [Oor96] </ref> claims to unite functional and object-oriented programming through first class environments [GJL87].
Reference: [PM93] <author> Poswig, J., Moraga, C.: </author> <title> Incremental type systems and implicit parametric overloading in visual languages. </title> <booktitle> IEEE Symposium on Visual Languages, </booktitle> <year> (1993) </year> <month> 126-133 </month>
Reference-contexts: We have a draft concrete syntax for the visual notation and have implemented a prototype visual front-end, type-checker, and translator to Haskell. Further work includes the implementation of subtype inference incorporating F-bounded polymorphism, the design of an incremental type checker <ref> [PM93] </ref>, the design of CLOVER's real-world interface (including file input/output and user interaction), support for event-driven programming and the construction of a GUI builder. Run-time analyses can be assisted by the addition of algorithm animation and the extension of lexical profiling [CCP95] to visual profiling.
Reference: [RR96] <author> Reppy, J., Riecke, J.: </author> <title> Simple objects for Standard ML. </title> <booktitle> In Proc. </booktitle> <address> PLDI'97, </address> <year> (1997) </year> <month> 171-180 </month>
Reference-contexts: Objective ML [RV96] is implemented on top of Caml Special Light and is an extension of ML with objects, top-level classes, multiple inheritance, methods returning self, binary methods and parametric classes. Object ML <ref> [RR96] </ref> extends ML with objects, subtyping and heterogeneous collections. CLAIRE [CL96] is a high-level functional and object-oriented language with advanced rule processing capabilities. Bla [Oor96] claims to unite functional and object-oriented programming through first class environments [GJL87].
Reference: [RV96] <author> Remy, D., Vouillon, J.: </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In Proc. 3rd FOOL, </booktitle> <year> (1996) </year>
Reference-contexts: Objective ML <ref> [RV96] </ref> is implemented on top of Caml Special Light and is an extension of ML with objects, top-level classes, multiple inheritance, methods returning self, binary methods and parametric classes. Object ML [RR96] extends ML with objects, subtyping and heterogeneous collections.
Reference: [Sar93] <editor> Sargeant, J.: </editor> <booktitle> Uniting Functional and Object-Oriented Programming. In Proc. </booktitle> <address> ISOTAS'93, </address> <publisher> LNCS 742, Springer-Verlag, </publisher> <year> (1993) </year> <month> 1-26 </month>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide [MMH91] and UFO <ref> [Sar93] </ref>) are not referentially transparent, FOOPS [Soc93] has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP.
Reference: [SKA94] <author> Sargeant, J., Kirkham, C., Anderson, S.: </author> <title> The Uflow Computational Model and Intermediate Format. </title> <type> Technical Report UMCS-94-5-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> (1994) </year>
Reference-contexts: OBJ [GWM93] is a functional language that supports multiple inheritance, exception handling and overloading but has no higher-order programming facilities. ST&T [DY94] is an extension of Smalltalk's type system bringing it closer to ML, though the result is first-order, strict, and still not referentially transparent. Uflow <ref> [SKA94] </ref> is an extension to UFO using a data-flow model for visualising execution, but is still not referentially transparent. <p> Our solution is to use a notation that is almost the dual of message-flow notation, and is similar to Uflow notation <ref> [SKA94] </ref>. Instead of nodes representing objects and messages flowing along arcs, in our notation the nodes represent the application of methods to their arguments and objects flow along the arcs. When we include higher-order methods, we allow both objects and messages (which may be partial) to flow along the arcs.
Reference: [Soc93] <author> Socorro, A.: </author> <title> Design, implementation and evaluation of a declarative object-oriented programming language. </title> <type> DPhil thesis, </type> <institution> Computing Laboratory, University of Oxford, </institution> <year> (1993) </year>
Reference-contexts: However, four of these languages (Leda [Bud95], Quest [CL91], Rapide [MMH91] and UFO [Sar93]) are not referentially transparent, FOOPS <ref> [Soc93] </ref> has no higher-order programming facilities, LIFE [AP93] only supports a simulation of FP, and HOP [DV96] does not support full OOP. Kea [MHH91], Rapide and HOP are briefly outlined below: - Kea is a higher-order, polymorphic, lazy functional language supporting multi-methods and a type inference system.
Reference: [Ste84] <author> Steele Jr, G.: </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> (1984) </year>
Reference-contexts: This work culminated in CLOS [BD88], a set of tools for developing object-oriented programs in Common LISP <ref> [Ste84] </ref>.
Reference: [Tur85] <author> Turner, D.: </author> <title> Functional Programs as Executable Specifications. </title> <editor> In Hoare & Shepherdson (Eds), </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <publisher> Prentice Hall, </publisher> <year> (1985) </year>
Reference-contexts: CLOVER is intended to be used for application development, not low-level systems programming. We support programming at the specification level, much as functional languages can be used to write executable specifications <ref> [Tur85] </ref>. CLOVER supports the traditional OOP features of a class hierarchy, subtyp-ing, subsumption, inheritance, method overloading, method overriding and dynamic despatch. It also incorporates the FP features of referential transparency, single-assignment attributes, polymorphism, curried partial applications, higher-order functions and lazy evaluation.
Reference: [WB89] <author> Wadler, P., Blott, S.: </author> <title> How to make ad-hoc polymorphism less ad-hoc. In Proc. 16th POPL, (1989) 60-76 This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Haskell [HPW91] has at various times been the subject of claims that its type classes mechanism <ref> [WB89] </ref> facilitates OO programming [Ber92]; this has promulgated the mistaken assumption that Haskell's type classes provide sub-typing. Unfortunately type classes do not provide the subtype relationship that we require; rather, they support a structured form of overloading.
References-found: 44

