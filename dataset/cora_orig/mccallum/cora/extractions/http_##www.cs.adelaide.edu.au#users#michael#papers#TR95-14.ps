URL: http://www.cs.adelaide.edu.au/users/michael/papers/TR95-14.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. Ashton. </author> <title> The Amoeba interaction network monitor initial results. </title> <type> Technical Report TR-COSC 09/95, </type> <institution> Department of Computer Science, University of Canterbury, </institution> <address> New Zealand, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: This can be done by during run-time, as implemented by Cai [12] and in PICL [20]. It can also be achieved by post-processing trace-files, as in Xab [5, 6], and in Interaction Network <ref> [1, 2] </ref>. This approach is applicable to post-mortem visualisation systems. As for the logical-clock, it can be used in visualisation systems that only emphasises the ordering of events, without having to display performance data. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo [3, 42], Xab [5], TraceView [37], and Interaction Network <ref> [1, 2] </ref>. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. In this case, it is better to use the on-the-fly analysis.
Reference: [2] <author> P. Ashton. </author> <title> Monitoring the processing of interactive requests on distributed systems. </title> <type> Technical Report TR-COSC 07/95, </type> <institution> Department of Computer Science, University of Canterbury, </institution> <address> New Zealand, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: The operating sys-tem is modified to produce, or to help to produce, events of interest during program execution. Little or no change is made to the user program or the compiler, as implemented in BugNet [58], and Interaction Network <ref> [2] </ref>. This technique has an apparent advantage in that the instrumentation process is fully transparent to both the user/programmer. Complete low-level diagnostics of a program can also be readily obtained. However, this produces very low-level events which need complicated processing for interpretation. <p> This can be done by during run-time, as implemented by Cai [12] and in PICL [20]. It can also be achieved by post-processing trace-files, as in Xab [5, 6], and in Interaction Network <ref> [1, 2] </ref>. This approach is applicable to post-mortem visualisation systems. As for the logical-clock, it can be used in visualisation systems that only emphasises the ordering of events, without having to display performance data. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo [3, 42], Xab [5], TraceView [37], and Interaction Network <ref> [1, 2] </ref>. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. In this case, it is better to use the on-the-fly analysis.
Reference: [3] <author> R.A. Aydt. </author> <title> A User's Guide to Pablo I/O Instrumentation. </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> December </month> <year> 1994. </year> <note> Retrieved from ftp://www-pablo.cs.uiuc.edu/pub/Release/Documentation/IOextension.ps. </note>
Reference-contexts: Another approach is to use adaptive instrumentation control by setting a maximum rate of event generation, as used in Pablo <ref> [3, 45] </ref>. During run-time, Pablo monitors the recording rate for each event. If the rate is greater than a pre-specified value, then the system replaces the current event recording method with one which is less intrusive. Several methods have been introduced to annul those probe effects. <p> Events generated by a program are all collected during run-time. Later, the recorded events are processed for display. In this way, any subsequent display of the events follows exactly the same sequence or ordering. There have been many tools that employ this approach. BugNet [58], Pablo <ref> [3, 42] </ref>, ParaGraph [22] and TraceViewer [24] are some examples. 2. Event Collection and Analysis The events generated by an instrumented program are collected by the visualisation system for further analysis before display. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo <ref> [3, 42] </ref>, Xab [5], TraceView [37], and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. <p> The second type of graphical representation is the statistics-based display. This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see [22]) fall into this category. Tools such as PIE [34], ParaGraph [22], Pablo <ref> [3, 42] </ref> and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24].
Reference: [4] <author> P. Bates. </author> <title> Debugging heterogeneous distributed systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Volume 24, Number 1, </volume> <pages> pages 11-22, </pages> <month> May </month> <year> 1989. </year> <booktitle> Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <institution> at the University of Wisconsin, Madison, </institution> <address> Washington 1988. </address>
Reference-contexts: For example, this is done by Zhou [61] for debugging RPC-based distributed programs. * Event Clustering As it may be difficult to interpret program behaviour from raw events, it is useful to encapsulate events to form higer-level events. This way, event-abstraction is achieved. For example, EBBA <ref> [4] </ref> employs this approach for devising a high-level debugging system. Kunz [31] also utilises event clustering to devise an abstract debugging tool in the Hermes distributed language environment. <p> For example, TraceView [37] lets the user specify which events to be filtered out from a trace file for display. Another tool, EBBA <ref> [4] </ref>, also offers filtering, which is combined with event clustering. In this approach, even compound or abstract event can be filtered out.
Reference: [5] <author> A. Beguelin, J. Dongarra, A. Geist and V. Sunderam. </author> <title> Visualisation and debugging in a heterogeneous environment. </title> <journal> IEEE Computer, </journal> <volume> Volume 26, Number 6, </volume> <pages> pages 88-95, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In the same spirit, the term program animation or algorithm animation means a visualisation system in which the execution of a program or algorithm is animated. (b) Visual programming Visual programming is defined as the use of visual expressions in the process of programming [10, 39, 51]. HeNCE <ref> [5] </ref>, and Hyperpascal [36] are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data [16]. It mainly deals with ways to represent large volumes of scientific data in an efficient way. <p> The third approach is a hybrid approach, in which partial instrumentation of a program is undertaken by the user. This may take the form of a transparent library, as in PICL [20] with its library ParaGraph [22], and PVM [55] with its library Xab <ref> [5] </ref>. It may also take the form in which the tool automatically determines the possible points of instrumentation and lets the user decide their inclusion or exclusion. This technique is implemented in Pablo [42]. <p> This approach has the advantage of being easy to implement and change, and is highly portable. Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE <ref> [5] </ref> with its instrumented PVM libraries [55], ParaGraph [22] with its instrumented PICL [20] libraries, Zeus [9], Ovation [14], and GThreads [60] fall into this category. <p> Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai [12] and in PICL [20]. It can also be achieved by post-processing trace-files, as in Xab <ref> [5, 6] </ref>, and in Interaction Network [1, 2]. This approach is applicable to post-mortem visualisation systems. As for the logical-clock, it can be used in visualisation systems that only emphasises the ordering of events, without having to display performance data. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo [3, 42], Xab <ref> [5] </ref>, TraceView [37], and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE <ref> [5] </ref>, Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this.
Reference: [6] <author> A. Beguelin and E. Seligman. </author> <title> Causality-preserving timestamps in distributed programs. </title> <type> Technical Report CMU-CS-93-167, </type> <institution> School of Computer Science, Canergie-Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Further, the various processors in a computation may have unsynchronised clocks. If the events are generated without inter-processor clock-correction, or merely displayed in the order they arrived, then tachyons (violations in event causality) can be produced <ref> [6, 45] </ref>. Event reordering can be achieved by using timestamping mechanisms. Times-tamps can be generated by using physical clocks [45], or by logical clocks [32]. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. <p> Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai [12] and in PICL [20]. It can also be achieved by post-processing trace-files, as in Xab <ref> [5, 6] </ref>, and in Interaction Network [1, 2]. This approach is applicable to post-mortem visualisation systems. As for the logical-clock, it can be used in visualisation systems that only emphasises the ordering of events, without having to display performance data.
Reference: [7] <author> W.C. Brantley, K.P. McAuliffe and T.A. Ngo. </author> <title> RP3 performance monitoring hardware. </title> <editor> In M. Simmons, R. Koskela and I. Bucher (editors), </editor> <booktitle> Instrumentation for Future Parallel Computing Systems, Chapter 2, </booktitle> <pages> pages 35 - 47. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: The first is the events happening at the hardware layer. TraceView [37] is one example of a software that visualises events at this layer. Special hardware can also be used to assist the monitoring and collection of events. One example is the IBM RP3 hardware <ref> [7] </ref>. This paper is merely concerned with software implementation and does not discuss hardware issues any further. The second type is the events happening at the software layer. This has been discussed in Section 4.1. 2.
Reference: [8] <author> T. Braybrook. </author> <title> Vista: A visualisation tool, 1994. </title> <institution> Thesis for the Honours Degree of Bachelor of Science, Department of Computer Science, University of Adelaide. </institution>
Reference-contexts: For debugging purposes, breakpoints such as in Virtual Images [57], or inspection of program data structures such as in KAESTLE [16] can be used. Recently, tools to visualise the history of variable values such as in Vista <ref> [8] </ref> can also be found. A program visualisation tool usually takes views of basic events in the program, such as variable-value inspection. However, abstract views consisting of lower-level events, such as implemented by Kunz [30], can also be used. <p> The second approach is through automatic instrumentation by a tool. This is the approach taken by many instrumentation tools. Examples of this are Ovation [14], VizBug++ [25], Vista <ref> [8] </ref> and Visputer [38]. It has the advantage that the error-prone process of instrumentation is fully managed by the tool. However, it means that there is no way, or very limited ways that the user can specify the events in the program to monitor. <p> Consequently, the probing commands are automatically inserted into the user programs during compilation. This approach is used, for instance, in GraphTrace [27], Instant Replay [33], and Vista <ref> [8] </ref>. The principal advantage is that it is highly transparent to the user. Complete information of program structure and its associated object code can be obtained. However, portability is an issue, since the same language can be implemented differently on different platforms. <p> Furthermore, since visualisation tools involve the use of graphical user interface, these ideals are relatively subjective. However, several criteria can be established as the ideals. These may be incomplete, yet should be sufficient for most cases. The points set up here approximately follow those in <ref> [8, 25, 40] </ref>. 16 The ideals of a visualisation system can be roughly divided into two perspectives: the sys- tem's perspective, and the user's perspective. 1.
Reference: [9] <author> M.H. Brown. Zeus: </author> <title> A system for algorithm animation and multi-view editing. </title> <type> Technical Report 75, </type> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus <ref> [9] </ref>, ParaGraph [22], and Pablo [42]. <p> This approach has the advantage of being easy to implement and change, and is highly portable. Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries [55], ParaGraph [22] with its instrumented PICL [20] libraries, Zeus <ref> [9] </ref>, Ovation [14], and GThreads [60] fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45]. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus <ref> [9] </ref>, HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this. <p> Each serves a different need. Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus <ref> [9] </ref>, Virtual Images [57], GraphTrace [27], the IBM system [14, 15], and VizBug++ [25] fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. <p> Other types of display include the ones which are not commonly found in current visualisation systems. For example, SIEVE [48] uses spreadsheet-style display to show performance data. * Application-specific Display In this type of display, a user can actively design the graphical representation and its attributes. Voyeur [53], Zeus <ref> [9] </ref>, POLKA [54], and SIEVE [48] are examples of such visualisation tools. They allow the user to construct views specific to each program. This approach is more suitable for experienced programmers, or for creating a general-purpose visualisation package.
Reference: [10] <author> M.H. Brown, B.A. Myers and E.P. Glinert. </author> <title> Introduction to Visual Programming Environment. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year> <note> ACM SIGGRAPH '89 course notes/SIGGRAPH '89. </note>
Reference-contexts: The discussion is concluded with a summary. 2 Terminology Several terms need to be clarified, as they are used throughout the discussion. 2 1. Program Visualisation Program visualisation is a component of the more general concept known as Software Visualisation [44], which includes <ref> [10, 16] </ref>: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes [16, 41, 46]. <p> In the same spirit, the term program animation or algorithm animation means a visualisation system in which the execution of a program or algorithm is animated. (b) Visual programming Visual programming is defined as the use of visual expressions in the process of programming <ref> [10, 39, 51] </ref>. HeNCE [5], and Hyperpascal [36] are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data [16]. It mainly deals with ways to represent large volumes of scientific data in an efficient way.
Reference: [11] <author> W.T. Cai, W.J. Milne and S.J. Turner. </author> <title> Graphical views of the behaviour of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 223-230, </pages> <year> 1993. </year>
Reference-contexts: At the same time, partial ordering of events can be imposed. The result is that the time component that arises from probe statements is deleted. Such a method is used in the Logical Clock approach <ref> [11, 13, 12] </ref> and in the Virtual Clock approach [59]. In general, this method assumes that transparent monitoring is obtained by preserving the partial ordering of events and the communication ordering on each process.
Reference: [12] <author> W.T. Cai and S.J. Turner. </author> <title> Process scheduling and program monitoring on transputers. </title> <editor> In S. Atkins and A.S. Wagner (editors), </editor> <booktitle> Transputer Research and Applications, NATUG-6, Proceedings of the 6th Conference of the North American Transputer Users Group, </booktitle> <pages> pages 290 - 305. </pages> <publisher> IOS Press, </publisher> <year> 1993. </year> <month> 20 </month>
Reference-contexts: At the same time, partial ordering of events can be imposed. The result is that the time component that arises from probe statements is deleted. Such a method is used in the Logical Clock approach <ref> [11, 13, 12] </ref> and in the Virtual Clock approach [59]. In general, this method assumes that transparent monitoring is obtained by preserving the partial ordering of events and the communication ordering on each process. <p> Times-tamps can be generated by using physical clocks [45], or by logical clocks [32]. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai <ref> [12] </ref> and in PICL [20]. It can also be achieved by post-processing trace-files, as in Xab [5, 6], and in Interaction Network [1, 2]. This approach is applicable to post-mortem visualisation systems.
Reference: [13] <author> W.T. Cai and S.J. Turner. </author> <title> An approach to the run-time monitoring of parallel programs. </title> <journal> The Computer Journal, </journal> <volume> Volume 37, Number 4, </volume> <pages> pages 333 - 345, </pages> <year> 1994. </year>
Reference-contexts: At the same time, partial ordering of events can be imposed. The result is that the time component that arises from probe statements is deleted. Such a method is used in the Logical Clock approach <ref> [11, 13, 12] </ref> and in the Virtual Clock approach [59]. In general, this method assumes that transparent monitoring is obtained by preserving the partial ordering of events and the communication ordering on each process. <p> In general, this method assumes that transparent monitoring is obtained by preserving the partial ordering of events and the communication ordering on each process. Furthermore, it should be possible to get an accurate timing, and to trap and control inter-process communication <ref> [13] </ref>. The second method is similar to the first method, except that both the imposition of partial ordering and the removal of probe-effect components are done to trace files.
Reference: [14] <author> W. DePauw, R. Helm, D. Kimelman and J. Vlissides. </author> <title> Visualising the behaviour of object-oriented systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Volume 28, Number 10, </volume> <pages> pages 326-337, </pages> <month> October </month> <year> 1993. </year> <pages> Pictures on pages 453-454. </pages>
Reference-contexts: As described by DePauw [15], a visualisation tool that supports this purpose bridges the gap between the static specifications and run-time behavior of a program. Either basic views or abstract high-level views are used. The work by De Pauw <ref> [14, 15] </ref>, and by Jerding [25] represent this purpose. The purpose of a visualisation tool is further determined by two other factors. The first factor is the level of events the visualisation tool is to visualise. The decision is also determined by the second factor, the intended audience or users. <p> BugNet [58], for example, visualises inter-process communication, input-output events and the execution of individual processes in a distributed C-language environment. The second level is for events happening at the user-program level. The work by Jerding [25] and DePauw <ref> [14] </ref> represent this level by visualising the run-time execution of object-oriented programs. The intended level of users also affects the choice of visualisation support and its purpose. The user may be a system-level programmer. In this case, a visualisation of low-level events are more appropriate. <p> The second approach is through automatic instrumentation by a tool. This is the approach taken by many instrumentation tools. Examples of this are Ovation <ref> [14] </ref>, VizBug++ [25], Vista [8] and Visputer [38]. It has the advantage that the error-prone process of instrumentation is fully managed by the tool. However, it means that there is no way, or very limited ways that the user can specify the events in the program to monitor. <p> Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries [55], ParaGraph [22] with its instrumented PICL [20] libraries, Zeus [9], Ovation <ref> [14] </ref>, and GThreads [60] fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45]. <p> Other forms of event clustering are facilitated in the display in which several events which form a logical meaning are grouped under a higher-level entity. When a user expands that entity, those lower-level entities are displayed. Such a hierarchical event clustering is implemented by De Pauw <ref> [14, 15] </ref>. * Event Filtering The purpose of event filtering is to eliminate the events which do not suit a particular criteria, which is generally set by a user. For example, TraceView [37] lets the user specify which events to be filtered out from a trace file for display. <p> This 11 further means that there is a high degree of real-time interaction between the visualisation system and the visualised program. Generally, such a method is used by systems that visualise sequential programs. The IBM system <ref> [14, 15] </ref>, for example, visualises the execution of sequential object-oriented programs in terms of the statistics of object interaction. GraphTrace [27] is another example that visualises the run-time behaviour of object-oriented programs written in the Strobe language. <p> For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE [34], TraceViewer [24] and Multiview [18]. Other examples, such as GraphTrace [27] and the IBM system <ref> [14, 15] </ref>, depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates. Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system <ref> [14, 15] </ref>, visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this. The first one is that the program and its algorithm may already be well-understood. <p> Each serves a different need. Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus [9], Virtual Images [57], GraphTrace [27], the IBM system <ref> [14, 15] </ref>, and VizBug++ [25] fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. The second type of graphical representation is the statistics-based display. <p> The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. In addition, other static information extracted from the source code can also be displayed. This is implemented in GraphTrace [27] and the IBM system <ref> [14, 15] </ref>, displaying the static class hierarchies of object-oriented programs. As previously stated, these types of representations do not stand alone, but are usually linked with other types of display. For example, PIE [34] shows source-code information, which is linked with performance data display. <p> Another method is by using hierarchical displays. Here, events or program entities can be grouped in some hierarchical way. Each of those entities can be expanded on demand by the user. An example of this is the debugging system implemented by Kunz [30, 31], and the IBM system <ref> [14, 15] </ref>. In this respect, the three dimensional display system is devised to overcome the problem with two-dimentional display, as stated above.
Reference: [15] <author> W. DePauw, D. Kimelman and J. Vlissides. </author> <title> Modeling object-oriented program execution. </title> <booktitle> Proceedings of the 8th European Conference, ECOOP'94, </booktitle> <pages> pages 163-182, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: However, abstract views consisting of lower-level events, such as implemented by Kunz [30], can also be used. Another purpose of program visualisation tools, namely that of understanding programs [40], is especially useful in the development and maintenance process of a program. As described by DePauw <ref> [15] </ref>, a visualisation tool that supports this purpose bridges the gap between the static specifications and run-time behavior of a program. Either basic views or abstract high-level views are used. The work by De Pauw [14, 15], and by Jerding [25] represent this purpose. <p> As described by DePauw [15], a visualisation tool that supports this purpose bridges the gap between the static specifications and run-time behavior of a program. Either basic views or abstract high-level views are used. The work by De Pauw <ref> [14, 15] </ref>, and by Jerding [25] represent this purpose. The purpose of a visualisation tool is further determined by two other factors. The first factor is the level of events the visualisation tool is to visualise. The decision is also determined by the second factor, the intended audience or users. <p> Other forms of event clustering are facilitated in the display in which several events which form a logical meaning are grouped under a higher-level entity. When a user expands that entity, those lower-level entities are displayed. Such a hierarchical event clustering is implemented by De Pauw <ref> [14, 15] </ref>. * Event Filtering The purpose of event filtering is to eliminate the events which do not suit a particular criteria, which is generally set by a user. For example, TraceView [37] lets the user specify which events to be filtered out from a trace file for display. <p> This 11 further means that there is a high degree of real-time interaction between the visualisation system and the visualised program. Generally, such a method is used by systems that visualise sequential programs. The IBM system <ref> [14, 15] </ref>, for example, visualises the execution of sequential object-oriented programs in terms of the statistics of object interaction. GraphTrace [27] is another example that visualises the run-time behaviour of object-oriented programs written in the Strobe language. <p> For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE [34], TraceViewer [24] and Multiview [18]. Other examples, such as GraphTrace [27] and the IBM system <ref> [14, 15] </ref>, depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates. Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system <ref> [14, 15] </ref>, visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this. The first one is that the program and its algorithm may already be well-understood. <p> Each serves a different need. Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus [9], Virtual Images [57], GraphTrace [27], the IBM system <ref> [14, 15] </ref>, and VizBug++ [25] fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. The second type of graphical representation is the statistics-based display. <p> The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. In addition, other static information extracted from the source code can also be displayed. This is implemented in GraphTrace [27] and the IBM system <ref> [14, 15] </ref>, displaying the static class hierarchies of object-oriented programs. As previously stated, these types of representations do not stand alone, but are usually linked with other types of display. For example, PIE [34] shows source-code information, which is linked with performance data display. <p> Another method is by using hierarchical displays. Here, events or program entities can be grouped in some hierarchical way. Each of those entities can be expanded on demand by the user. An example of this is the debugging system implemented by Kunz [30, 31], and the IBM system <ref> [14, 15] </ref>. In this respect, the three dimensional display system is devised to overcome the problem with two-dimentional display, as stated above.
Reference: [16] <author> S. Ellershaw and M. Oudshoorn. </author> <title> Program visualisation | the state of the art. </title> <type> Technical Report TR94-19, </type> <institution> Department of Computer Science, University of Adelaide, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: The visual aspects of program visualisation can make these tasks easier. This paper discusses program visualisation for concurrent and object-oriented programs. It does not attempt to present a comprehensive survey of currently available tools, as in <ref> [16] </ref> and [44], nor does it present a comprehensive taxonomy of visualisation systems, as this has been well presented in many papers, such as by Price [44] and Roman [46]. However, it deals with issues specifically pertaining to devising a visualisation tool for concurrent and object-oriented programs. <p> The discussion is concluded with a summary. 2 Terminology Several terms need to be clarified, as they are used throughout the discussion. 2 1. Program Visualisation Program visualisation is a component of the more general concept known as Software Visualisation [44], which includes <ref> [10, 16] </ref>: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes [16, 41, 46]. <p> visualisation is a component of the more general concept known as Software Visualisation [44], which includes [10, 16]: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes <ref> [16, 41, 46] </ref>. A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus [9], ParaGraph [22], and Pablo [42]. <p> HeNCE [5], and Hyperpascal [36] are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data <ref> [16] </ref>. It mainly deals with ways to represent large volumes of scientific data in an efficient way. Examples of these are visualisation of climatic data [21] and data visualisation of ocean currents [47]. 2. <p> Most of them fall into two common categories: debugging and understanding, both of which make a visualisation tool an invaluable aid during program maintenance. For debugging purposes, breakpoints such as in Virtual Images [57], or inspection of program data structures such as in KAESTLE <ref> [16] </ref> can be used. Recently, tools to visualise the history of variable values such as in Vista [8] can also be found. A program visualisation tool usually takes views of basic events in the program, such as variable-value inspection.
Reference: [17] <author> Q.W. Feng, P. Eades and R.F. Cohen. </author> <title> Planar drawing of clustered graphs. </title> <type> Technical Report 05/95, </type> <institution> Department of Computer Science, the University of Newcastle, New South Wales, Australia, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Display grouping can also be used. Using graphs again as an example, graphs can be grouped to form some logical hierarchy, which can be traversed or exploded <ref> [17, 26, 52] </ref>. (c) Display Dimension A visualisation system can use two- or three-dimensional displays. Currently, most vi-sualisation tools employ two-dimensional displays. Only a limited number of systems, such as Virtual Images [57], employ three-dimensional displays.
Reference: [18] <author> C.H. Ferguson. </author> <title> Multiview: An integrated approach to visualisation of parallel programs. </title> <type> Technical Report UCSC-CRL-90-20, </type> <institution> Computer Research Laboratory, University of Califor-nia at Santa Cruz, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE [34], TraceViewer [24] and Multiview <ref> [18] </ref>. Other examples, such as GraphTrace [27] and the IBM system [14, 15], depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates.
Reference: [19] <author> S Gasiorowicz. </author> <title> Quantum Physics. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1974. </year>
Reference-contexts: Non-determinism, which is sometimes present in a parallel system, can further make the execution course unpredictable and non-repeatable. (a) Probe Effects A probe effect in program execution closely follows the Heisenberg principle in physics <ref> [19] </ref>, which basically means that the more information is to be extracted from a program, the more perturbation is introduced. This effect usually means that the program execution time is altered/increased. It may also mean that the original relative ordering of events is altered.
Reference: [20] <author> G.A. Geist, M.T. Heath, B.W. Peyton and P.H. Worley. </author> <title> A user's guide to PICL, a Portable Instrumented Communication Library. </title> <type> Technical Report ORNL/TM-11616, </type> <institution> Oak Ridge National Laboratory, Oak Ridge National Laboratory, Mathematical Sciences Section, Oak Ridge, Tennessee, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: The third approach is a hybrid approach, in which partial instrumentation of a program is undertaken by the user. This may take the form of a transparent library, as in PICL <ref> [20] </ref> with its library ParaGraph [22], and PVM [55] with its library Xab [5]. It may also take the form in which the tool automatically determines the possible points of instrumentation and lets the user decide their inclusion or exclusion. This technique is implemented in Pablo [42]. <p> This approach has the advantage of being easy to implement and change, and is highly portable. Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries [55], ParaGraph [22] with its instrumented PICL <ref> [20] </ref> libraries, Zeus [9], Ovation [14], and GThreads [60] fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45]. <p> Times-tamps can be generated by using physical clocks [45], or by logical clocks [32]. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai [12] and in PICL <ref> [20] </ref>. It can also be achieved by post-processing trace-files, as in Xab [5, 6], and in Interaction Network [1, 2]. This approach is applicable to post-mortem visualisation systems. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL <ref> [20] </ref> with ParaGraph [22], Pablo [3, 42], Xab [5], TraceView [37], and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible.
Reference: [21] <author> R.B. Haber. </author> <title> Scientific visualisation and the rivers project at the National Center for Supercomputing Applications. </title> <journal> IEEE Computer, </journal> <volume> Volume 22, Number 8, </volume> <pages> pages 84-89, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: It mainly deals with ways to represent large volumes of scientific data in an efficient way. Examples of these are visualisation of climatic data <ref> [21] </ref> and data visualisation of ocean currents [47]. 2. Programmer and User The term "programmer" means the person who originally wrote the program being visu-alised, while a "user" is the one who uses or maintains a program visualisation tool or system.
Reference: [22] <author> M.T. Heath and J.A. Etheridge. </author> <title> Visualising the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> Volume 8, Number 9, </volume> <pages> pages 29-39, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus [9], ParaGraph <ref> [22] </ref>, and Pablo [42]. <p> The third approach is a hybrid approach, in which partial instrumentation of a program is undertaken by the user. This may take the form of a transparent library, as in PICL [20] with its library ParaGraph <ref> [22] </ref>, and PVM [55] with its library Xab [5]. It may also take the form in which the tool automatically determines the possible points of instrumentation and lets the user decide their inclusion or exclusion. This technique is implemented in Pablo [42]. <p> This approach has the advantage of being easy to implement and change, and is highly portable. Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries [55], ParaGraph <ref> [22] </ref> with its instrumented PICL [20] libraries, Zeus [9], Ovation [14], and GThreads [60] fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45]. <p> Events generated by a program are all collected during run-time. Later, the recorded events are processed for display. In this way, any subsequent display of the events follows exactly the same sequence or ordering. There have been many tools that employ this approach. BugNet [58], Pablo [3, 42], ParaGraph <ref> [22] </ref> and TraceViewer [24] are some examples. 2. Event Collection and Analysis The events generated by an instrumented program are collected by the visualisation system for further analysis before display. Several issues thereof are as follows: 10 (a) Event Processing Before being sent to display, events are processed further. <p> The complexity of analysis also increases, because it can be difficult to determine the current state of the program. Furthermore, real-time processing means real-time unfolding of events on the screen, which is difficult for the user to follow <ref> [22] </ref>. Attempts to pause the execution bring into play the problem of program synchronisation and excessive perturbations. * Post-mortem analysis Post-mortem analysis means that the events produced by an instrumented program are replayed after program execution is over. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph <ref> [22] </ref>, Pablo [3, 42], Xab [5], TraceView [37], and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. <p> As a result, it can easily be understood. The second type of graphical representation is the statistics-based display. This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see <ref> [22] </ref>) fall into this category. Tools such as PIE [34], ParaGraph [22], Pablo [3, 42] and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. <p> The second type of graphical representation is the statistics-based display. This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see <ref> [22] </ref>) fall into this category. Tools such as PIE [34], ParaGraph [22], Pablo [3, 42] and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24].
Reference: [23] <author> D.P. Helmbold, C.E. McDowell and J.Z. Wang. </author> <title> Detecting data races by analysing sequential traces. </title> <type> Technical Report UCSC-CRL-90-57, </type> <institution> University of California at Santa Cruz, California, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Finally, processing of events by using trace files means that it is easier, because all the program states are known in advance, and that the tool only deals with the processing of event logs. This, for example, enables the user to detect race conditions in a program <ref> [23] </ref>, or to design more efficient screen output. 4.2.3 Display When program events have been generated, collected and analysed, they are ready for display. During this phase, the display acts as a medium of interaction between the user and the program. Several issues thereof are as follows: 1.
Reference: [24] <author> D.P. Helmbold, C.E. McDowell and J.Z. Wang. Traceviewer: </author> <title> A graphical browser for trace analysis. </title> <type> Technical Report UCSC-CRL-90-59, </type> <institution> University of California at Santa Cruz, California, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Later, the recorded events are processed for display. In this way, any subsequent display of the events follows exactly the same sequence or ordering. There have been many tools that employ this approach. BugNet [58], Pablo [3, 42], ParaGraph [22] and TraceViewer <ref> [24] </ref> are some examples. 2. Event Collection and Analysis The events generated by an instrumented program are collected by the visualisation system for further analysis before display. Several issues thereof are as follows: 10 (a) Event Processing Before being sent to display, events are processed further. <p> Display of static aspects of a program is usually associated with other displays in a multi-view visualisation environment. For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE [34], TraceViewer <ref> [24] </ref> and Multiview [18]. Other examples, such as GraphTrace [27] and the IBM system [14, 15], depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates. <p> Tools such as PIE [34], ParaGraph [22], Pablo [3, 42] and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer <ref> [24] </ref>. In addition, other static information extracted from the source code can also be displayed. This is implemented in GraphTrace [27] and the IBM system [14, 15], displaying the static class hierarchies of object-oriented programs.
Reference: [25] <author> D.F. Jerding and J.T. Stasko. </author> <title> Using visualisation to foster object-oriented understanding. </title> <type> Technical Report GIT-GVU-94-33, </type> <institution> Graphics, Visualisation and Usability Centre | College of Computing, Georgia Institute of Technology, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: As described by DePauw [15], a visualisation tool that supports this purpose bridges the gap between the static specifications and run-time behavior of a program. Either basic views or abstract high-level views are used. The work by De Pauw [14, 15], and by Jerding <ref> [25] </ref> represent this purpose. The purpose of a visualisation tool is further determined by two other factors. The first factor is the level of events the visualisation tool is to visualise. The decision is also determined by the second factor, the intended audience or users. <p> The first level is to visualise the events happening at the system software layer. BugNet [58], for example, visualises inter-process communication, input-output events and the execution of individual processes in a distributed C-language environment. The second level is for events happening at the user-program level. The work by Jerding <ref> [25] </ref> and DePauw [14] represent this level by visualising the run-time execution of object-oriented programs. The intended level of users also affects the choice of visualisation support and its purpose. The user may be a system-level programmer. In this case, a visualisation of low-level events are more appropriate. <p> The second approach is through automatic instrumentation by a tool. This is the approach taken by many instrumentation tools. Examples of this are Ovation [14], VizBug++ <ref> [25] </ref>, Vista [8] and Visputer [38]. It has the advantage that the error-prone process of instrumentation is fully managed by the tool. However, it means that there is no way, or very limited ways that the user can specify the events in the program to monitor. <p> Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus [9], Virtual Images [57], GraphTrace [27], the IBM system [14, 15], and VizBug++ <ref> [25] </ref> fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. The second type of graphical representation is the statistics-based display. <p> Furthermore, since visualisation tools involve the use of graphical user interface, these ideals are relatively subjective. However, several criteria can be established as the ideals. These may be incomplete, yet should be sufficient for most cases. The points set up here approximately follow those in <ref> [8, 25, 40] </ref>. 16 The ideals of a visualisation system can be roughly divided into two perspectives: the sys- tem's perspective, and the user's perspective. 1.
Reference: [26] <author> D. Kimelman, B. Leban, T. Roth and D. Zernik. </author> <title> Reduction of visual complexity in dynamic graphs. </title> <note> Submitted to DIMACS Graph Drawing'94, 1994. </note> <institution> IBM Thomas J. Watson Research Center, </institution> <address> Yorktown Heights, New York. </address>
Reference-contexts: This compression can be achieved through graphical manipulations. For instance, in graph representations, operations such as "ghosting" (drawing nodes and edges by using dim or background colour) and "hiding" (removing nodes and edges entirely from the display) can be employed <ref> [26] </ref>. Display grouping can also be used. Using graphs again as an example, graphs can be grouped to form some logical hierarchy, which can be traversed or exploded [17, 26, 52]. (c) Display Dimension A visualisation system can use two- or three-dimensional displays. Currently, most vi-sualisation tools employ two-dimensional displays. <p> Display grouping can also be used. Using graphs again as an example, graphs can be grouped to form some logical hierarchy, which can be traversed or exploded <ref> [17, 26, 52] </ref>. (c) Display Dimension A visualisation system can use two- or three-dimensional displays. Currently, most vi-sualisation tools employ two-dimensional displays. Only a limited number of systems, such as Virtual Images [57], employ three-dimensional displays.
Reference: [27] <author> M.F. </author> <title> Kleyn and P.C. Gingrich. GraphTrace | Understanding object-oriented systems using concurrently animated views. </title> <booktitle> In Proceedings of Object-Oriented Programming Systems, Languages, and Applications OOPSLA 1988, </booktitle> <pages> pages 191-205, </pages> <month> September </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: Instead, either the semantics of the language or the associated compiler is augmented to produce the side effects of event generation and visualisation. Consequently, the probing commands are automatically inserted into the user programs during compilation. This approach is used, for instance, in GraphTrace <ref> [27] </ref>, Instant Replay [33], and Vista [8]. The principal advantage is that it is highly transparent to the user. Complete information of program structure and its associated object code can be obtained. However, portability is an issue, since the same language can be implemented differently on different platforms. <p> Generally, such a method is used by systems that visualise sequential programs. The IBM system [14, 15], for example, visualises the execution of sequential object-oriented programs in terms of the statistics of object interaction. GraphTrace <ref> [27] </ref> is another example that visualises the run-time behaviour of object-oriented programs written in the Strobe language. The amount of on-the-fly analysis is generally limited by time constraints on event processing [29]. This is especially true for concurrent or distributed programs. <p> For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE [34], TraceViewer [24] and Multiview [18]. Other examples, such as GraphTrace <ref> [27] </ref> and the IBM system [14, 15], depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace <ref> [27] </ref>, GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this. <p> Each serves a different need. Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus [9], Virtual Images [57], GraphTrace <ref> [27] </ref>, the IBM system [14, 15], and VizBug++ [25] fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. <p> The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. In addition, other static information extracted from the source code can also be displayed. This is implemented in GraphTrace <ref> [27] </ref> and the IBM system [14, 15], displaying the static class hierarchies of object-oriented programs. As previously stated, these types of representations do not stand alone, but are usually linked with other types of display. For example, PIE [34] shows source-code information, which is linked with performance data display.
Reference: [28] <author> J.A. Kohl. </author> <title> Visual tecniques for parallel processing. </title> <type> Technical Report ECETR-910726, </type> <institution> Department of Electrical and Computer Engineering, University of Iowa, </institution> <month> July </month> <year> 1991. </year> <type> Preliminary Written Ph.D. Comprehensive Examination. </type>
Reference-contexts: These ideals might serve as a metrics to evaluate the effectiveness of the tool. 4.3.1 Ideals Program visualisation is still a relatively new research area <ref> [28] </ref>. Many problems are still under investigation. In the same light, the ideals of what and how a visualisation tool should be are still not very clear. Furthermore, since visualisation tools involve the use of graphical user interface, these ideals are relatively subjective. <p> Due to the subjective qualities of visualisation tools, quantitative measurement is difficult to obtain, although not impossible. Kohl, for example, has established such a measurement, based on scalability, visualisation degree, graphical sophistication, and focusing capability <ref> [28] </ref>. The advantage of using a definite measurement is that program visualisation tools can be compared objectively.
Reference: [29] <author> E. Kraemer and J.T. Stasko. </author> <title> The visualisation of parallel systems: An overview. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 105-117, </pages> <year> 1993. </year>
Reference-contexts: However, it deals with issues specifically pertaining to devising a visualisation tool for concurrent and object-oriented programs. This paper closely follows the style of the discussion in <ref> [29] </ref>. The content herein can also be applied or extrapolated to the visualisation of the programs in other programming paradigms. Section 2 introduces some necessary terminology, followed by Section 3, describing the connection between program visualisation and the tasks in the program development life-cycle. <p> This effect usually means that the program execution time is altered/increased. It may also mean that the original relative ordering of events is altered. Kraemer <ref> [29] </ref> argues that whatever the level of instrumentation, perturbances or probe effects are still inevitable. Therefore, they can not be anulled, but only minimised or set to a certain level. <p> The developers of Conch argue that the overhead for instrumentation is less at the system level than at the user-program level. However, as argued by Kraemer <ref> [29] </ref>, this does not annihilate probe effects, because although the probes do not "directly affect" a user's program, they are now part of the whole system. Another approach is to use adaptive instrumentation control by setting a maximum rate of event generation, as used in Pablo [3, 45]. <p> GraphTrace [27] is another example that visualises the run-time behaviour of object-oriented programs written in the Strobe language. The amount of on-the-fly analysis is generally limited by time constraints on event processing <ref> [29] </ref>. This is especially true for concurrent or distributed programs. The reason is that within a limited amount of time, the tool has to receive, process and display the incoming events so that it can proceed with the next ones.
Reference: [30] <author> T. Kunz. </author> <title> Abstract debugging of distributed applications. </title> <type> Technical Report TI-10/93, </type> <institution> Institut fur Theoretische Informatik, Technische Hochschule Darmstadt, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Recently, tools to visualise the history of variable values such as in Vista [8] can also be found. A program visualisation tool usually takes views of basic events in the program, such as variable-value inspection. However, abstract views consisting of lower-level events, such as implemented by Kunz <ref> [30] </ref>, can also be used. Another purpose of program visualisation tools, namely that of understanding programs [40], is especially useful in the development and maintenance process of a program. <p> Another method is by using hierarchical displays. Here, events or program entities can be grouped in some hierarchical way. Each of those entities can be expanded on demand by the user. An example of this is the debugging system implemented by Kunz <ref> [30, 31] </ref>, and the IBM system [14, 15]. In this respect, the three dimensional display system is devised to overcome the problem with two-dimentional display, as stated above.
Reference: [31] <author> T. Kunz. </author> <title> An event abstraction tool: Theory, design, and results. </title> <type> Technical Report TI-1/94, </type> <institution> Institut fur Theoretische Informatik, Technische Hochschule Darmstadt, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This way, event-abstraction is achieved. For example, EBBA [4] employs this approach for devising a high-level debugging system. Kunz <ref> [31] </ref> also utilises event clustering to devise an abstract debugging tool in the Hermes distributed language environment. Other forms of event clustering are facilitated in the display in which several events which form a logical meaning are grouped under a higher-level entity. <p> Another method is by using hierarchical displays. Here, events or program entities can be grouped in some hierarchical way. Each of those entities can be expanded on demand by the user. An example of this is the debugging system implemented by Kunz <ref> [30, 31] </ref>, and the IBM system [14, 15]. In this respect, the three dimensional display system is devised to overcome the problem with two-dimentional display, as stated above.
Reference: [32] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communication of the ACM, </journal> <volume> Volume 21, Number 7, </volume> <pages> pages 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: If the events are generated without inter-processor clock-correction, or merely displayed in the order they arrived, then tachyons (violations in event causality) can be produced [6, 45]. Event reordering can be achieved by using timestamping mechanisms. Times-tamps can be generated by using physical clocks [45], or by logical clocks <ref> [32] </ref>. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai [12] and in PICL [20].
Reference: [33] <author> T.J. LeBlanc and J.M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Volume C-36, Number 4, </volume> <pages> pages 471-481, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Instead, either the semantics of the language or the associated compiler is augmented to produce the side effects of event generation and visualisation. Consequently, the probing commands are automatically inserted into the user programs during compilation. This approach is used, for instance, in GraphTrace [27], Instant Replay <ref> [33] </ref>, and Vista [8]. The principal advantage is that it is highly transparent to the user. Complete information of program structure and its associated object code can be obtained. However, portability is an issue, since the same language can be implemented differently on different platforms. <p> For "on-the-fly" visualisation, events generated by a program are directly processed and analysed for display. This means that event-ordering must be preserved for each execution of the program. This method is implemented in Instant Replay <ref> [33] </ref>, in which inter-process interactions are modeled as accesses to shared objects. A total order of write operations and a partial order of read operations on the objets are recorded. Subsequent replays of the program then refer to these records to impose the same ordering as the first execution.
Reference: [34] <author> T. Lehr, Z. Segall, D.F. Vrsalovic, E. Caplan, A.L. Chung and C.E. Fineman. </author> <title> Visualising performance debugging. </title> <journal> IEEE Computer, </journal> <volume> Volume 22, Number 10, </volume> <pages> pages 38-51, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Furthermore, it requires careful design so that changes to the operating system do not severely affect other applications. This approach is usually implemented in a very specific and system-dependent way. Another approach for instrumentation is to use a combination of the abovementioned approaches. PIE <ref> [34] </ref>, for example, instruments the operating system, the language/compiler, and the user program. Summing up the above discussion, there are three levels of instrumentation: at the user-program level, at the language or compiler level, and at the operating-system level. <p> Display of static aspects of a program is usually associated with other displays in a multi-view visualisation environment. For example, if a program event is being displayed, the associated source code sections can also be displayed (See Figure 5). Such an approach is supported in PIE <ref> [34] </ref>, TraceViewer [24] and Multiview [18]. Other examples, such as GraphTrace [27] and the IBM system [14, 15], depict the static hierarchy of classes and objects in object-oriented programs. Dynamic aspects of a program are its run-time behaviour, represented by the events it generates. <p> Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. By using this method, many dynamic aspects of program execution can be revealed. For example, PIE <ref> [34] </ref>, TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. <p> The second type of graphical representation is the statistics-based display. This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see [22]) fall into this category. Tools such as PIE <ref> [34] </ref>, ParaGraph [22], Pablo [3, 42] and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. <p> Tools such as PIE <ref> [34] </ref>, ParaGraph [22], Pablo [3, 42] and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. In addition, other static information extracted from the source code can also be displayed. This is implemented in GraphTrace [27] and the IBM system [14, 15], displaying the static class hierarchies of object-oriented programs. <p> This is implemented in GraphTrace [27] and the IBM system [14, 15], displaying the static class hierarchies of object-oriented programs. As previously stated, these types of representations do not stand alone, but are usually linked with other types of display. For example, PIE <ref> [34] </ref> shows source-code information, which is linked with performance data display. When a user selects a particular section in the performance display, the associated source-code 15 section is displayed. Other types of display include the ones which are not commonly found in current visualisation systems.
Reference: [35] <author> J.E. Lumpp, T.L. Casavant, J.A. Gannon, K.J. Williams and M.S. Andersland. </author> <title> Trace recovery for debugging parallel and distributed systems. </title> <booktitle> The 3rd ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <address> San Diego, </address> <pages> pages 208 - 210, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The second method is similar to the first method, except that both the imposition of partial ordering and the removal of probe-effect components are done to trace files. This is implemented by Scheetz, et al <ref> [35, 49] </ref>. (b) Execution Non-determinism Non-determinism in parallel, concurrent, or distributed environment means that the relative ordering of events in a program can be different for each execution. In devising visualisation systems, attempts have been made to reduce this effect.
Reference: [36] <author> P. Lyons, C. Simmons and M. Apperley. Hyperpascal: </author> <title> A visual language to model idea space. </title> <booktitle> In Proc. 13th New Zealand Computer Society Conference, </booktitle> <pages> pages 492-508, </pages> <address> New Zealand, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: HeNCE [5], and Hyperpascal <ref> [36] </ref> are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data [16]. It mainly deals with ways to represent large volumes of scientific data in an efficient way.
Reference: [37] <author> A.D. Malony, D.H. Hammerslag and D.J. Jablonowski. </author> <title> TraceView: A trace visualisation tool. </title> <journal> IEEE Software, </journal> <volume> Volume 8, Number 9, </volume> <pages> pages 19-28, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: In this stage, there are several issues to consider. 6 1. Event Types There are two types of events to visualise. The first is the events happening at the hardware layer. TraceView <ref> [37] </ref> is one example of a software that visualises events at this layer. Special hardware can also be used to assist the monitoring and collection of events. One example is the IBM RP3 hardware [7]. <p> Such a hierarchical event clustering is implemented by De Pauw [14, 15]. * Event Filtering The purpose of event filtering is to eliminate the events which do not suit a particular criteria, which is generally set by a user. For example, TraceView <ref> [37] </ref> lets the user specify which events to be filtered out from a trace file for display. Another tool, EBBA [4], also offers filtering, which is combined with event clustering. In this approach, even compound or abstract event can be filtered out. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo [3, 42], Xab [5], TraceView <ref> [37] </ref>, and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. <p> Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView <ref> [37] </ref> and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. <p> This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see [22]) fall into this category. Tools such as PIE [34], ParaGraph [22], Pablo [3, 42] and TraceView <ref> [37] </ref> use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24]. In addition, other static information extracted from the source code can also be displayed.
Reference: [38] <author> G. Marwaha and K. Zhang. </author> <title> Parallel program visualisation for a message-passing system. </title> <booktitle> In Proceedings of the 13th Annual IEEE International Conference on Computers and Communications, Phoenix, USA, </booktitle> <pages> pages 200 - 205. </pages> <publisher> IEEE Press, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The second approach is through automatic instrumentation by a tool. This is the approach taken by many instrumentation tools. Examples of this are Ovation [14], VizBug++ [25], Vista [8] and Visputer <ref> [38] </ref>. It has the advantage that the error-prone process of instrumentation is fully managed by the tool. However, it means that there is no way, or very limited ways that the user can specify the events in the program to monitor. This difficulty can be alleviated in some ways.
Reference: [39] <author> D. McIntyre. </author> <title> Comp.Lang.Visual | frequently-asked questions (FAQ) list. </title> <booktitle> The Internet Newsgroup comp.lang.visual, </booktitle> <month> April </month> <year> 1995. </year> <note> Updated weekly. </note>
Reference-contexts: In the same spirit, the term program animation or algorithm animation means a visualisation system in which the execution of a program or algorithm is animated. (b) Visual programming Visual programming is defined as the use of visual expressions in the process of programming <ref> [10, 39, 51] </ref>. HeNCE [5], and Hyperpascal [36] are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data [16]. It mainly deals with ways to represent large volumes of scientific data in an efficient way.
Reference: [40] <author> B.P. Miller. </author> <title> What to draw? When to draw? An essay on parallel program visualisation. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 265-269, </pages> <year> 1993. </year>
Reference-contexts: A program visualisation tool usually takes views of basic events in the program, such as variable-value inspection. However, abstract views consisting of lower-level events, such as implemented by Kunz [30], can also be used. Another purpose of program visualisation tools, namely that of understanding programs <ref> [40] </ref>, is especially useful in the development and maintenance process of a program. As described by DePauw [15], a visualisation tool that supports this purpose bridges the gap between the static specifications and run-time behavior of a program. Either basic views or abstract high-level views are used. <p> Furthermore, since visualisation tools involve the use of graphical user interface, these ideals are relatively subjective. However, several criteria can be established as the ideals. These may be incomplete, yet should be sufficient for most cases. The points set up here approximately follow those in <ref> [8, 25, 40] </ref>. 16 The ideals of a visualisation system can be roughly divided into two perspectives: the sys- tem's perspective, and the user's perspective. 1.
Reference: [41] <author> J. Muthukumarasamy and J.T. Stasko. </author> <title> Visualising program executions on large data sets using Semantic Zooming. </title> <type> Technical Report GIT-GVU-95-02, </type> <institution> Graphics, Visualisation and Usability Centre | College of Computing, Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: visualisation is a component of the more general concept known as Software Visualisation [44], which includes [10, 16]: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes <ref> [16, 41, 46] </ref>. A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus [9], ParaGraph [22], and Pablo [42].
Reference: [42] <author> R.J. Noe. </author> <title> Pablo Instrumentation Environment Reference Manual. </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> December </month> <year> 1994. </year> <note> Retrieved from ftp://site www-pablo.cs.uiuc.edu/pub/Release/Documentation/InstrumentRefMan.ps. </note>
Reference-contexts: A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus [9], ParaGraph [22], and Pablo <ref> [42] </ref>. In the same spirit, the term program animation or algorithm animation means a visualisation system in which the execution of a program or algorithm is animated. (b) Visual programming Visual programming is defined as the use of visual expressions in the process of programming [10, 39, 51]. <p> It may also take the form in which the tool automatically determines the possible points of instrumentation and lets the user decide their inclusion or exclusion. This technique is implemented in Pablo <ref> [42] </ref>. <p> Events generated by a program are all collected during run-time. Later, the recorded events are processed for display. In this way, any subsequent display of the events follows exactly the same sequence or ordering. There have been many tools that employ this approach. BugNet [58], Pablo <ref> [3, 42] </ref>, ParaGraph [22] and TraceViewer [24] are some examples. 2. Event Collection and Analysis The events generated by an instrumented program are collected by the visualisation system for further analysis before display. <p> The replay typically uses trace-files which contain all the events saved during program run-time. As a result, any subsequent replay yield the same display. This approach is used by many systems, such as PICL [20] with ParaGraph [22], Pablo <ref> [3, 42] </ref>, Xab [5], TraceView [37], and Interaction Network [1, 2]. Post-mortem analysis has the disadvantage that it can require a large amount of storage to record all the events. This is sometimes infeasible. Also, it may be infeasible for programs that have an extended execution. <p> Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo <ref> [42, 45] </ref> visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. <p> The second type of graphical representation is the statistics-based display. This display is usually used for showing performance data. The Kiviat diagram (see Figure 6), the Feynman diagram, bar graphs, matrix views, and charts (see [22]) fall into this category. Tools such as PIE [34], ParaGraph [22], Pablo <ref> [3, 42] </ref> and TraceView [37] use this display type to show performance data. The third display type is source-code-related representations. Such a display shows the source-code itself. This, for example, is implemented in PIE [34] and TraceViewer [24].
Reference: [43] <author> R.S. Pressman. </author> <title> Software Engineering, A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc., 3rd edition, </publisher> <year> 1992. </year> <month> 22 </month>
Reference-contexts: Program visualisation can be used for many programming paradigms. Each paradigm needs different approaches, as they utilise different methods of problem solving. Program visualisa-tion can also be used throughout the program development life-cycle, e.g. during the testing, verification and maintenance steps <ref> [43] </ref>. The visual aspects of program visualisation can make these tasks easier. This paper discusses program visualisation for concurrent and object-oriented programs. <p> These terms are used interchangeably. 3 The Big Picture The use of program visualisation fits into the software lifecycle model. This model basically has five stages <ref> [43] </ref>: analysis, design, coding, testing (verifying), and maintenance (see Figure 1). 3 Usually, the testing and maintenance stages are the most costly and time-consuming. For testing, the resulting software has to be verified against the initial specifications.
Reference: [44] <author> B.A. Price, </author> <title> R.M. Baecker and I.S. Small. A principled taxonomy of software visualisa--tion. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> Volume 4, Number 3, </volume> <pages> pages 211-266, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: It takes advantage of the human visual ability to perceive pictorial representations of a program faster than the corresponding textual information. Generally, such visualisation is used to enhance human understanding of a program or algorithm <ref> [44] </ref>. Program visualisation can be used for many programming paradigms. Each paradigm needs different approaches, as they utilise different methods of problem solving. Program visualisa-tion can also be used throughout the program development life-cycle, e.g. during the testing, verification and maintenance steps [43]. <p> The visual aspects of program visualisation can make these tasks easier. This paper discusses program visualisation for concurrent and object-oriented programs. It does not attempt to present a comprehensive survey of currently available tools, as in [16] and <ref> [44] </ref>, nor does it present a comprehensive taxonomy of visualisation systems, as this has been well presented in many papers, such as by Price [44] and Roman [46]. However, it deals with issues specifically pertaining to devising a visualisation tool for concurrent and object-oriented programs. <p> It does not attempt to present a comprehensive survey of currently available tools, as in [16] and <ref> [44] </ref>, nor does it present a comprehensive taxonomy of visualisation systems, as this has been well presented in many papers, such as by Price [44] and Roman [46]. However, it deals with issues specifically pertaining to devising a visualisation tool for concurrent and object-oriented programs. This paper closely follows the style of the discussion in [29]. <p> The discussion is concluded with a summary. 2 Terminology Several terms need to be clarified, as they are used throughout the discussion. 2 1. Program Visualisation Program visualisation is a component of the more general concept known as Software Visualisation <ref> [44] </ref>, which includes [10, 16]: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes [16, 41, 46].
Reference: [45] <author> D.A. Reed. </author> <title> Performance Instrumentation Techniques for Parallel Systems, </title> <booktitle> Volume 729 of Lecture Notes in Computer Science, </booktitle> <pages> pages 463-490. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: instrumentation has an advantage in that the user participates in the instrumentation of the program without having to do it in a purely manual and error-prone way. (b) Types of Probes Depending on the final outcome to be achieved, there are four basic approaches to data capturing or event generation <ref> [45] </ref>, and hence, four types of probes, described as follows: * Timing Data on timing can be obtained by measuring the time a program spends in particular program sections. <p> The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code <ref> [45] </ref>. If this requirement is not satisfied, then instrumentation results may not be reliable, particularly for performance measurement. Program instrumentation can also be done at the language or compiler level. Using this method, the original user program is not altered. <p> Therefore, they can not be anulled, but only minimised or set to a certain level. Depending on the outcome, less intrusive methods can be employed by collecting a minimal amount of information, such as by counting or sampling methods <ref> [45] </ref>. Other methods, such as used in the distributed-system visualisation tool Conch [56], try to "minimise" these probe effects by supplying user-activated instrumentation into system levels 9 rather than the user-program. <p> Another approach is to use adaptive instrumentation control by setting a maximum rate of event generation, as used in Pablo <ref> [3, 45] </ref>. During run-time, Pablo monitors the recording rate for each event. If the rate is greater than a pre-specified value, then the system replaces the current event recording method with one which is less intrusive. Several methods have been introduced to annul those probe effects. <p> Further, the various processors in a computation may have unsynchronised clocks. If the events are generated without inter-processor clock-correction, or merely displayed in the order they arrived, then tachyons (violations in event causality) can be produced <ref> [6, 45] </ref>. Event reordering can be achieved by using timestamping mechanisms. Times-tamps can be generated by using physical clocks [45], or by logical clocks [32]. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. <p> If the events are generated without inter-processor clock-correction, or merely displayed in the order they arrived, then tachyons (violations in event causality) can be produced [6, 45]. Event reordering can be achieved by using timestamping mechanisms. Times-tamps can be generated by using physical clocks <ref> [45] </ref>, or by logical clocks [32]. Since physical clocks are possibly unsynchronised among processors, this approach is usually accompanied by clock correction or synchronisation. This can be done by during run-time, as implemented by Cai [12] and in PICL [20]. <p> Exploring the dynamic aspects of a program means that the aspects concerning the execution of the program itself are visualised. By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo <ref> [42, 45] </ref> visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user.
Reference: [46] <author> G. Roman and K.C. Cox. </author> <title> Program visualisation: The art of mapping programs to pictures. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 412-420, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: It does not attempt to present a comprehensive survey of currently available tools, as in [16] and [44], nor does it present a comprehensive taxonomy of visualisation systems, as this has been well presented in many papers, such as by Price [44] and Roman <ref> [46] </ref>. However, it deals with issues specifically pertaining to devising a visualisation tool for concurrent and object-oriented programs. This paper closely follows the style of the discussion in [29]. The content herein can also be applied or extrapolated to the visualisation of the programs in other programming paradigms. <p> visualisation is a component of the more general concept known as Software Visualisation [44], which includes [10, 16]: (a) Program visualisation Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes <ref> [16, 41, 46] </ref>. A program visualisation tool can visualise both the static and dynamic (run-time) aspects of a program or algorithm. Examples include Zeus [9], ParaGraph [22], and Pablo [42].
Reference: [47] <author> L.J. Rosenblum. </author> <title> Visualisation of experimental data at the Naval research laboratory. </title> <journal> IEEE Computer, </journal> <volume> Volume 22, Number 8, </volume> <pages> pages 95-101, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: It mainly deals with ways to represent large volumes of scientific data in an efficient way. Examples of these are visualisation of climatic data [21] and data visualisation of ocean currents <ref> [47] </ref>. 2. Programmer and User The term "programmer" means the person who originally wrote the program being visu-alised, while a "user" is the one who uses or maintains a program visualisation tool or system.
Reference: [48] <author> S.R. Sarukkai and D. Gannon. </author> <title> SIEVE: A performance debugging environment for parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 147-168, </pages> <year> 1993. </year>
Reference-contexts: When a user selects a particular section in the performance display, the associated source-code 15 section is displayed. Other types of display include the ones which are not commonly found in current visualisation systems. For example, SIEVE <ref> [48] </ref> uses spreadsheet-style display to show performance data. * Application-specific Display In this type of display, a user can actively design the graphical representation and its attributes. Voyeur [53], Zeus [9], POLKA [54], and SIEVE [48] are examples of such visualisation tools. <p> For example, SIEVE <ref> [48] </ref> uses spreadsheet-style display to show performance data. * Application-specific Display In this type of display, a user can actively design the graphical representation and its attributes. Voyeur [53], Zeus [9], POLKA [54], and SIEVE [48] are examples of such visualisation tools. They allow the user to construct views specific to each program. This approach is more suitable for experienced programmers, or for creating a general-purpose visualisation package. Regardless of the graphical representations used, they should be able to convey information easily to the user.
Reference: [49] <author> T.E. Scheetz, T.A. Braun and T.L. Casavant. </author> <title> Effectiveness of software trace recovery techniques for current parallel architectures. </title> <booktitle> In Proceedings of the 1995 International Conference on High-Performance Computing, </booktitle> <address> New Delhi, India, </address> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: The second method is similar to the first method, except that both the imposition of partial ordering and the removal of probe-effect components are done to trace files. This is implemented by Scheetz, et al <ref> [35, 49] </ref>. (b) Execution Non-determinism Non-determinism in parallel, concurrent, or distributed environment means that the relative ordering of events in a program can be different for each execution. In devising visualisation systems, attempts have been made to reduce this effect.
Reference: [50] <author> J.T Shilling and J.T. Stasko. </author> <title> Using animation to design, document and trace object-oriented systems. </title> <type> Technical Report GIT-GVU-93-12, </type> <institution> Graphics, Visualisation and Usability Centre | College of Computing, Georgia Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Program visualisation can also be regarded as a type of program documentation. This stems from the notion that the most reliable form of such documentation is the program itself. By using this approach, both the static and dynamic aspects of a program can readily be understood. For example, GROOVE <ref> [50] </ref> | based on this notion | is a program visualisation tool for developing and capturing object-oriented designs. 4 Devising a Visualisation System In devising a visualisation tool, there are issues to be resolved. Generally, they pertain to a wide range of visualisation tools.
Reference: [51] <author> N.C. Shu. </author> <title> Visual Programming. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: In the same spirit, the term program animation or algorithm animation means a visualisation system in which the execution of a program or algorithm is animated. (b) Visual programming Visual programming is defined as the use of visual expressions in the process of programming <ref> [10, 39, 51] </ref>. HeNCE [5], and Hyperpascal [36] are two such examples. (c) (Scientific) data visualisation (Scientific) data visualisation is the visualisation which solely deals with the graphical representation of (scientific) data [16]. It mainly deals with ways to represent large volumes of scientific data in an efficient way.
Reference: [52] <author> M. Sifer and J. Potter. </author> <title> Structured graphs: A visual formalism for scalable graph-based CASE tools. </title> <booktitle> Presented at the First Australian Software Visualisation Workshop, </booktitle> <address> MacQuarie University, Sydney, Australia, </address> <year> 1995. </year>
Reference-contexts: Display grouping can also be used. Using graphs again as an example, graphs can be grouped to form some logical hierarchy, which can be traversed or exploded <ref> [17, 26, 52] </ref>. (c) Display Dimension A visualisation system can use two- or three-dimensional displays. Currently, most vi-sualisation tools employ two-dimensional displays. Only a limited number of systems, such as Virtual Images [57], employ three-dimensional displays.
Reference: [53] <author> D. Socha, M.L. Bailey and D. Notkin. Voyeur: </author> <title> Graphical views of parallel programs. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Volume 24, Number 1, </volume> <pages> pages 206-215, </pages> <month> January </month> <year> 1988. </year> <booktitle> Proceedings of the Workshop on Parallel and Distributed Debugging. </booktitle>
Reference-contexts: Here, several issues need to be considered. (a) Level of User-Participation The first issue is concerned with the level of user-participation in instrumenting a program. The user can insert the instrumentation probes manually. This approach is adopted, for instance, in POLKA [54], and Voyeur <ref> [53] </ref>. It is usually done to give users a high degree of flexibility in the construction of program-specific views. However, there is a cost in that the user has to know in advance how the program works, how to instrument the code, and where to put the probes. <p> This basically means that the user cannot change the display, but only make "cosmetic" changes. Another approach is to allow the user to fully specify both the display of event representations and their behaviour. This is used in Voyeur <ref> [53] </ref>, in which both the annotation of programs and the construction of graphical views are handled by the user. The same approach is used in POLKA [54]. Both systems use an object-oriented approach to provide a hierarchy of customisable views. <p> Other types of display include the ones which are not commonly found in current visualisation systems. For example, SIEVE [48] uses spreadsheet-style display to show performance data. * Application-specific Display In this type of display, a user can actively design the graphical representation and its attributes. Voyeur <ref> [53] </ref>, Zeus [9], POLKA [54], and SIEVE [48] are examples of such visualisation tools. They allow the user to construct views specific to each program. This approach is more suitable for experienced programmers, or for creating a general-purpose visualisation package.
Reference: [54] <author> J.T. Stasko and E. Kraemer. </author> <title> A methodology for building application-specific visualisations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 258-264, </pages> <year> 1993. </year>
Reference-contexts: Here, several issues need to be considered. (a) Level of User-Participation The first issue is concerned with the level of user-participation in instrumenting a program. The user can insert the instrumentation probes manually. This approach is adopted, for instance, in POLKA <ref> [54] </ref>, and Voyeur [53]. It is usually done to give users a high degree of flexibility in the construction of program-specific views. <p> This is used in Voyeur [53], in which both the annotation of programs and the construction of graphical views are handled by the user. The same approach is used in POLKA <ref> [54] </ref>. Both systems use an object-oriented approach to provide a hierarchy of customisable views. This is suitable for developing a general-purpose customisable visualisation or a graphical package. It is also useful for highly technical users who want to design their own display. <p> For example, SIEVE [48] uses spreadsheet-style display to show performance data. * Application-specific Display In this type of display, a user can actively design the graphical representation and its attributes. Voyeur [53], Zeus [9], POLKA <ref> [54] </ref>, and SIEVE [48] are examples of such visualisation tools. They allow the user to construct views specific to each program. This approach is more suitable for experienced programmers, or for creating a general-purpose visualisation package.
Reference: [55] <author> V.S Sunderam. </author> <title> PVM: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> Volume 2, Number 4, </volume> <pages> pages 315-339, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The third approach is a hybrid approach, in which partial instrumentation of a program is undertaken by the user. This may take the form of a transparent library, as in PICL [20] with its library ParaGraph [22], and PVM <ref> [55] </ref> with its library Xab [5]. It may also take the form in which the tool automatically determines the possible points of instrumentation and lets the user decide their inclusion or exclusion. This technique is implemented in Pablo [42]. <p> This approach has the advantage of being easy to implement and change, and is highly portable. Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries <ref> [55] </ref>, ParaGraph [22] with its instrumented PICL [20] libraries, Zeus [9], Ovation [14], and GThreads [60] fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45].
Reference: [56] <author> B. Topol, J.T. Stasko and V. Sunderam. </author> <title> Integrating visualisation support into distributed computing systems. </title> <type> Technical Report GIT-GVU-94-38, </type> <institution> Graphics, Visualisation and Usability Centre | College of Computing, Georgia Institute of Technology, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Depending on the outcome, less intrusive methods can be employed by collecting a minimal amount of information, such as by counting or sampling methods [45]. Other methods, such as used in the distributed-system visualisation tool Conch <ref> [56] </ref>, try to "minimise" these probe effects by supplying user-activated instrumentation into system levels 9 rather than the user-program. The developers of Conch argue that the overhead for instrumentation is less at the system level than at the user-program level.
Reference: [57] <author> J.Y. Vion-Dury and M. Santana. </author> <title> Virtual Images: Interactive visualisation of distributed object-oriented systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Volume 29, Number 10, </volume> <pages> pages 65-84, </pages> <month> October </month> <year> 1994. </year> <booktitle> Proceedings of Object-Oriented Programming Systems, Languages, and Applications 1994. </booktitle>
Reference-contexts: Most of them fall into two common categories: debugging and understanding, both of which make a visualisation tool an invaluable aid during program maintenance. For debugging purposes, breakpoints such as in Virtual Images <ref> [57] </ref>, or inspection of program data structures such as in KAESTLE [16] can be used. Recently, tools to visualise the history of variable values such as in Vista [8] can also be found. A program visualisation tool usually takes views of basic events in the program, such as variable-value inspection. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images <ref> [57] </ref>, GraphTrace [27], GThreads [60], and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this. <p> Each serves a different need. Graph-based displays are generally used for simulating, and representing program activities. Program entities are represented by nodes which are in the forms of closed geometric figures, while their interactions are represented as edges. Zeus [9], Virtual Images <ref> [57] </ref>, GraphTrace [27], the IBM system [14, 15], and VizBug++ [25] fall into this category. The advantage of this approach is that it gives a direct | usually one-to-one | relationship between program activities and their display representations. As a result, it can easily be understood. <p> Currently, most vi-sualisation tools employ two-dimensional displays. Only a limited number of systems, such as Virtual Images <ref> [57] </ref>, employ three-dimensional displays. In two dimensional-display, usually the area of display is the limiting factor, especially for large-scale visualisation. To overcome this limitation, visual manipulations are performed, such as by creating a larger window area. To explore the whole workspace, scroll-bars or navigational icons can be used.
Reference: [58] <author> L.D. Wittie. </author> <title> Debugging distributed C programs by real time replay. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Volume 24, Number 1, </volume> <pages> pages 57-67, </pages> <month> January </month> <year> 1989. </year> <booktitle> Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging. </booktitle> <pages> 23 </pages>
Reference-contexts: The decision is also determined by the second factor, the intended audience or users. The level of events to be visualised can be divided into two types. The first level is to visualise the events happening at the system software layer. BugNet <ref> [58] </ref>, for example, visualises inter-process communication, input-output events and the execution of individual processes in a distributed C-language environment. The second level is for events happening at the user-program level. The work by Jerding [25] and DePauw [14] represent this level by visualising the run-time execution of object-oriented programs. <p> The operating sys-tem is modified to produce, or to help to produce, events of interest during program execution. Little or no change is made to the user program or the compiler, as implemented in BugNet <ref> [58] </ref>, and Interaction Network [2]. This technique has an apparent advantage in that the instrumentation process is fully transparent to both the user/programmer. Complete low-level diagnostics of a program can also be readily obtained. However, this produces very low-level events which need complicated processing for interpretation. <p> Events generated by a program are all collected during run-time. Later, the recorded events are processed for display. In this way, any subsequent display of the events follows exactly the same sequence or ordering. There have been many tools that employ this approach. BugNet <ref> [58] </ref>, Pablo [3, 42], ParaGraph [22] and TraceViewer [24] are some examples. 2. Event Collection and Analysis The events generated by an instrumented program are collected by the visualisation system for further analysis before display.
Reference: [59] <author> K. Zhang, C.Z. Sun and K.C. Li. </author> <title> Collecting timing information while preserving events ordering in parallel program instrumentation. Not yet published. </title>
Reference-contexts: At the same time, partial ordering of events can be imposed. The result is that the time component that arises from probe statements is deleted. Such a method is used in the Logical Clock approach [11, 13, 12] and in the Virtual Clock approach <ref> [59] </ref>. In general, this method assumes that transparent monitoring is obtained by preserving the partial ordering of events and the communication ordering on each process. Furthermore, it should be possible to get an accurate timing, and to trap and control inter-process communication [13].
Reference: [60] <author> Q.A. Zhao and J.T. Stasko. </author> <title> Visualising the execution of thread-based parallel programs. </title> <type> Technical Report GIT-GVU-95-01, </type> <institution> Graphics, Visualisation and Usability Centre | College of Computing, Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Evidence of this can be found in the relatively large number of examples applying this technique. HeNCE [5] with its instrumented PVM libraries [55], ParaGraph [22] with its instrumented PICL [20] libraries, Zeus [9], Ovation [14], and GThreads <ref> [60] </ref> fall into this category. The basic assumption that validates the use of source-code instrumentation is that the underlying structure of the object code should be similar to that of its associated source code [45]. <p> In this way, the user has no control over how program events are represented. This is the approach taken by most visualisation tools, and this fact is not surprising, because a visualisation tool usually addresses a particular problem domain. For example, GThreads <ref> [60] </ref> only visualises the execution of a thread-based application in KSR machines. The question then becomes: "How well can the visualisation tool achieve its goals in relation to the needs of targetted users?" 2. Display During display, a user interacts directly with the visualisation tool. <p> By using this method, many dynamic aspects of program execution can be revealed. For example, PIE [34], TraceView [37] and Pablo [42, 45] visualise performance data. Other tools, such as Zeus [9], HeNCE [5], Virtual Images [57], GraphTrace [27], GThreads <ref> [60] </ref>, and the IBM system [14, 15], visualise run-time program states. It is worth noting that static aspects of a program generally do not convey much useful information to a user. There are two reasons for this.
Reference: [61] <author> W.L. Zhou. </author> <title> The design and implementation of a distributed program monitor. </title> <journal> Journal of Systems Software, </journal> <volume> Volume 22, </volume> <pages> pages 63-77, </pages> <year> 1993. </year> <month> 24 </month>
Reference-contexts: This approach is applicable to post-mortem visualisation systems. As for the logical-clock, it can be used in visualisation systems that only emphasises the ordering of events, without having to display performance data. For example, this is done by Zhou <ref> [61] </ref> for debugging RPC-based distributed programs. * Event Clustering As it may be difficult to interpret program behaviour from raw events, it is useful to encapsulate events to form higer-level events. This way, event-abstraction is achieved. For example, EBBA [4] employs this approach for devising a high-level debugging system.
References-found: 61

