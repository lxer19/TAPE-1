URL: http://www.daimi.aau.dk/~mis/gt.ps
Refering-URL: http://scotch.systemsz.cs.yale.edu/aplar/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fklarlund,misg@daimi.aau.dk  
Title: Graph Types  
Author: Nils Klarlund Michael I. Schwartzbach 
Address: Ny Munkegade, DK-8000 -Arhus, Denmark  
Affiliation: Aarhus University, Department of Computer Science,  
Abstract: We propose a notion of graph types, which allow common shapes, such as doubly-linked lists or threaded trees, to be expressed concisely and efficiently. We define regular languages of routing expressions to specify relative addresses of extra pointers in a canonical spanning tree. An efficient algorithm for computing such addresses is developed. We employ a second-order monadic logic to decide well-formedness of graph type specifications. This logic can also be used for automated reasoning about pointer structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci and R. Nasr. </author> <title> Logic and inheritance. </title> <booktitle> In Proc. 13th ACM Symp. on Princ. of Programming Languages, </booktitle> <pages> pages 219-228, </pages> <year> 1986. </year>
Reference-contexts: Not being based on tree structures, features allow the description of self-referential data structures. As opposed to our approach, the values designated are not guided by any expressions. The programming languages in <ref> [1, 2] </ref> and [3] use similar ideas and permits circular data structures. A restriction of this work is that such circular references may only point to nodes labeled syntactically with a marker.
Reference: [2] <author> H. At-Kaci and R. Nasr. </author> <title> Login: A logic programming language with built-in in 8 heritance. </title> <journal> Journal of Logic Program--ming, </journal> <volume> 3 </volume> <pages> 185-215, </pages> <year> 1986. </year> <note> Journal version of [1]. </note>
Reference-contexts: Not being based on tree structures, features allow the description of self-referential data structures. As opposed to our approach, the values designated are not guided by any expressions. The programming languages in <ref> [1, 2] </ref> and [3] use similar ideas and permits circular data structures. A restriction of this work is that such circular references may only point to nodes labeled syntactically with a marker.
Reference: [3] <author> H. At-Kaci and A. </author> <title> Podelski. Towards a meaning of life. </title> <editor> In Jan Maluszynski and Martin Wirsing, editors, </editor> <booktitle> Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming (Passau, Ger-many), </booktitle> <pages> pages 255-274. </pages> <publisher> Springer-Verlag, LNCS 528, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Not being based on tree structures, features allow the description of self-referential data structures. As opposed to our approach, the values designated are not guided by any expressions. The programming languages in [1, 2] and <ref> [3] </ref> use similar ideas and permits circular data structures. A restriction of this work is that such circular references may only point to nodes labeled syntactically with a marker.
Reference: [4] <author> B. Courcelle. </author> <title> The monadic second-order logic of graphs I. Recognizable sets of finite graphs. </title> <journal> Information and computation, </journal> <volume> 85 </volume> <pages> 12-75, </pages> <year> 1990. </year>
Reference-contexts: For doubly-linked lists of type D, such reasoning allows the automatic generation of optimal, constant-time code for concatenating lists|without the programmer having to specify any pointer operations. 6 Related Work Decidability of logics of graphs have been studied extensively; see <ref> [4] </ref> for references to the classical results that the monadic second order logic on finite trees is decidable and for extensions to more general graphs. The hyperedge-replacement grammars of [4] and similar context-free graph rewriting formalisms describe much larger classes of graphs than our graph types. An important result of [4] <p> the programmer having to specify any pointer operations. 6 Related Work Decidability of logics of graphs have been studied extensively; see <ref> [4] </ref> for references to the classical results that the monadic second order logic on finite trees is decidable and for extensions to more general graphs. The hyperedge-replacement grammars of [4] and similar context-free graph rewriting formalisms describe much larger classes of graphs than our graph types. An important result of [4] is that any property expressed in second-order monadic logic on graphs is decidable on hyperedge-replacement grammars. <p> <ref> [4] </ref> for references to the classical results that the monadic second order logic on finite trees is decidable and for extensions to more general graphs. The hyperedge-replacement grammars of [4] and similar context-free graph rewriting formalisms describe much larger classes of graphs than our graph types. An important result of [4] is that any property expressed in second-order monadic logic on graphs is decidable on hyperedge-replacement grammars. We could have used this result to derive our decidability result; but the translation into context-free graph grammars appears to be more complex than our approach.
Reference: [5] <author> J. Dorre and W.C Rounds. </author> <title> On subsump-tion and semiunification in feature algebras. </title> <booktitle> In Proc. IEEE Symp. on Logics in Computer Science, </booktitle> <pages> pages 300-310, </pages> <year> 1990. </year>
Reference-contexts: Although mathematically interesting, context-free graph grammars tend to be hard to understand; this is likely the reason why, to our knowledge, they have not been used for describing types in programming languages. Closer in spirit to our approach are the feature grammars and algebras; see <ref> [5] </ref> for references. These formalisms are built on the view that features (corresponding to our record fields) are partial functions that identify attributes. Not being based on tree structures, features allow the description of self-referential data structures.
Reference: [6] <author> L. Hendren, J. Hummel, and A. Nico-lau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proc. SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: A restriction of this work is that such circular references may only point to nodes labeled syntactically with a marker. Since the number of markers is finite, this language precludes the modeling of e.g. doubly-linked lists or leaf-linked trees, but allows root-linked trees. The ADDS notation in <ref> [6] </ref> allows the description of abstract properties of pointer structures through the concepts of dimensions and directions. The main motivation is to make static analysis more feasible through (non-invasive) program annotations.
Reference: [7] <author> C.A.R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer and Information Sciences, </journal> <volume> 4:2:105-132, </volume> <year> 1975. </year>
Reference-contexts: Recursive data types originate from the seventies <ref> [7] </ref> and have become ubiquitous in modern typed functional languages such as ML [8] and Miranda [10], but they may also be employed in Pascal-like imperative languages. Their benefits are substantial, but they also impose limitations; in particular, the values of recursive data types will always be tree shaped.
Reference: [8] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Recursive data types originate from the seventies [7] and have become ubiquitous in modern typed functional languages such as ML <ref> [8] </ref> and Miranda [10], but they may also be employed in Pascal-like imperative languages. Their benefits are substantial, but they also impose limitations; in particular, the values of recursive data types will always be tree shaped.
Reference: [9] <author> T. Reps. </author> <title> Incremental evaluation for attribute grammars with unrestricted movement between tree modifications. </title> <journal> Acta Informatica, </journal> <volume> 25, </volume> <year> 1986. </year>
Reference-contexts: The main motivation is to make static analysis more feasible through (non-invasive) program annotations. With the ADDS notation one cannot specify the exact shape of values, and manipulations still rely on explicit pointer operations. The techniques for evaluating routing fields are similar to algorithms for reevaluating attributed grammars <ref> [9] </ref>, but to our knowledge the algorithms for updating a tree of a grammar whose attributes are nodes in the tree has not been described before. Acknowledgments Thanks to the anonymous referees for their helpful comments.
Reference: [10] <author> D.A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag (LNCS 201), </publisher> <year> 1985. </year>
Reference-contexts: Recursive data types originate from the seventies [7] and have become ubiquitous in modern typed functional languages such as ML [8] and Miranda <ref> [10] </ref>, but they may also be employed in Pascal-like imperative languages. Their benefits are substantial, but they also impose limitations; in particular, the values of recursive data types will always be tree shaped.
References-found: 10

