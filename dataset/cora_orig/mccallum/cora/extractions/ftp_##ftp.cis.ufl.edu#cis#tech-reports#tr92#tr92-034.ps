URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-034.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Sorting n 2 Numbers On n n Meshes*  
Author: Madhusudan Nigam and Sartaj Sahni 
Keyword: Sorting, mesh architectures, distance lower bound  
Note: This research was supported, in part, by the National Science Foundation under grant MIP-9103379.  
Address: Gainesville, FL 32611  
Affiliation: University of Florida  
Abstract: Technical Report 92-34 ABSTRACT We show that by folding data from an n n mesh onto an n (n/k) submesh, sorting on the submesh, and finally unfolding back onto the entire n n mesh it is possible to sort on bidirectional and strict unidirectional meshes using a number of routing steps that is very close to the distance lower bound for these architectures. The technique may also be applied to reconfigurable bus architectures to obtain faster sorting algorithms. Keyword and Phrases 
Abstract-found: 1
Intro-found: 1
Reference: [BAUD78] <author> G. Baudet, and D. Stevenson, </author> <title> "Optimal Sorting Algorithms for Parallel Computers," </title> <journal> IEEE Transactions on Computers, C-27, </journal> <volume> 1, </volume> <month> Jan </month> <year> 1978, </year> <pages> 84-87. </pages>
Reference-contexts: Let T r denote the time needed to send a message of arbitrary length to a neighbor processor. We may generalize the sorting algorithm of Figure 6 to the case when each processor has k elements. Now, to sort a row or column of data, we use neighborhood sort <ref> [BAUD78] </ref> which is a generalization of even-odd transposition sort. Suppose that m processors have k elements each. The mk elements are sorted in m steps. In the even steps, the elements in each even processor are merged with those in the next odd processor.
Reference: [JANG92] <author> J. Jang and V. Prasanna, </author> <title> "An optimal sorting algorithm on reconfigurable meshes", </title> <booktitle> International Parallel Processing Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 12 and 13). If A = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a - 13 - variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>.
Reference: [KUMA83] <author> M. Kumar and D.S. Hirschberg, </author> <title> "An efficient implementation of Batcher's odd-even merge algorithm and its application in parallel sorting schemes," </title> <journal> IEEE Transactions on Computing, </journal> <volume> C-32, 3, </volume> <month> March </month> <year> 1983, </year> <pages> 254-264. </pages>
Reference-contexts: In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], [NASS79], <ref> [KUMA83] </ref>, [LEIG85], [SCHN86], [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor.
Reference: [KNUT73] <author> D. E. Knuth, </author> <title> The Art of Computer Programming, Vol 3, Sorting and Searching, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: To establish the correctness of the sorting algorithm with step 6 changed to sort pairs of columns as though they were a single column, we use the zero-one principle <ref> [KNUT73] </ref>. This was also used by Schnorr and Shamir to establish the correctness of their unmodified algorithm. Here, we assume that the input data consists solely of zeroes and ones.
Reference: [LEIG85] <author> T. Leighton, </author> <title> "Tight bounds on the complexity of parallel sorting", </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-34, 4, </volume> <month> April </month> <year> 1985, </year> <pages> 344-354. </pages> - <address> 16 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh </address>
Reference-contexts: In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], [NASS79], [KUMA83], <ref> [LEIG85] </ref>, [SCHN86], [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor.
Reference: [LIN92] <author> R. Lin, S. Olariu, J. Schwing, and J. Zhang, </author> <title> "A VLSI-optimal constant time Sorting on reconfigurable mesh", </title> <booktitle> Proceedings of Ninth European Workshop on Parallel Computing, </booktitle> <address> Madrid, Spain, </address> <year> 1992. </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 12 and 13). If A = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a - 13 - variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>.
Reference: [MARB88] <author> John M. Marberg, and Eli Gafni, </author> <title> "Sorting in Constant Number of Row and Column Phases on a Mesh", </title> <journal> Algorithmica, </journal> <volume> 3, </volume> <year> 1988, </year> <pages> 561-572. </pages>
Reference-contexts: In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], [NASS79], [KUMA83], [LEIG85], [SCHN86], [SCHER89], <ref> [MARB88] </ref>). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor.
Reference: [MILL88a] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Data movement operations and applications on reconfigurable VLS I arrays", </title> <booktitle> Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <publisher> The Pennsylvania State University Press, </publisher> <year> 1988, </year> <pages> 205-208. </pages>
Reference: [MILL88b] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Meshes with reconfigurable buses", </title> <booktitle> Proceedings 5th MIT Conference On Advanced Research In VLSI, </booktitle> <year> 1988, </year> <pages> 163-178. </pages>
Reference: [MILL88c] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Image computations on reconfigurable VLSI arrays", </title> <booktitle> Proceedings IEEE Conference On Computer Vision And Pattern Recognition, </booktitle> <year> 1988, </year> <pages> 925-930. </pages> - <address> 17 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh </address>
Reference: [MILL91a] <author> R. Miller, V. K. Prasanna Kumar, D. Reisis and Q. Stout, </author> <title> "Efficient parallel algorithms for intermediate level vision analysis on the reconfigurable mesh", Parallel Architectures and Algorithms for Image Understanding, </title> <editor> Viktor K. Prasanna ed., </editor> <address> 185-207, </address> <publisher> Academic Press, </publisher> <year> 1991 </year>
Reference-contexts: If this is done in each processor, then we get, simultaneously, disjoint row and column buses (Figure 12 and 13). If A = --N,S,E,W-,f-, then all four bus segments are connected. PARBUS algorithms for a - 13 - variety of applications can be found in <ref> [MILL91a, WANG90ab, LIN92, JANG92] </ref>.
Reference: [NASS79] <author> D. Nassimi and S. Sahni, </author> <title> "Bitonic sort on a mesh-connected parallel computer," </title> <journal> IEEE Transactions on Computers, C-27, </journal> <volume> 1, </volume> <month> Jan </month> <year> 1979, </year> <pages> 2-7. </pages>
Reference-contexts: The initial and final configurations have one data element in each of the nn processors (say in the A variable of each processor). In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], <ref> [NASS79] </ref>, [KUMA83], [LEIG85], [SCHN86], [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor.
Reference: [PARK87] <author> A. Park and K. Balasubramanian, </author> <title> "Improved Sorting Algorithms for Parallel Computers," </title> <booktitle> Proceedings of 1987 ACM Computer Science Conference, </booktitle> <month> Feb </month> <year> 1987, </year> <pages> 239-244. </pages>
Reference-contexts: example, the data to be sorted is the result of a computation that produces this configuration and the sorted data is to be used for further computation), then it is necessary to first fold the data to get the two element per processor configuration, then sort using the algorithm of <ref> [PARK87, 90] </ref>, and finally unfold to get the desired one element per processor final configuration. The folding can be done in n/ 2 t r time as below (see also Figure 1 (a)). F1: The left n/4 columns shift their data n/ 4 columns to right.
Reference: [PARK90] <author> A. Park and K. Balasubramanian, </author> <title> "Reducing Communication Costs for Sorting on Mesh-Connected and Linerly Connected Parallel Computers," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9, </volume> <pages> 318-322, </pages> <year> 1990. </year>
Reference: [SCHER89] <author> Issac D. Scherson, Sandeep Sen, and Yiming MA, </author> <title> "Two nearly Optimal Sorting algorithms for Mesh-Connected processor arrays using shear sort," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6, </volume> <pages> 151-165, </pages> <year> 1989. </year>
Reference-contexts: In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], [NASS79], [KUMA83], [LEIG85], [SCHN86], <ref> [SCHER89] </ref>, [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor.
Reference: [SCHN86] <author> C.P. Schnorr, and A. Shamir, </author> <title> "An Optimal Sorting Algorithm for Mesh Connected Computers," </title> <booktitle> Proceeding of the 18th ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1985, </year> <title> Berkely, </title> <publisher> CA, </publisher> <pages> 255-263. - 18 </pages> - 
Reference-contexts: In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. [THOM77], [NASS79], [KUMA83], [LEIG85], <ref> [SCHN86] </ref>, [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor. <p> In the bidirectional model, we assume there are two links between every pair (P,Q) of neighbors. As a result, P can send a data element to Q at the same time that Q sends one to P. Using this model, Schnorr and Shamir <ref> [SCHN86] </ref> have developed a sorting algorithm with complexity 3nt r + 2nt c . <p> Similarly, we can do U1 and U2 in parallel. The total sort time now becomes 4.5nt r + nt c . - 4 - In section 2, we show that the Schnorr/Shamir algorithm of <ref> [SCHN86] </ref> can be modified to sort on unidirectional meshes using the same number of routes as above. The number of comparison steps is, however, larger. The modified Schnorr/Shamir algorithm of section 2 runs in 2.5nt r + 3nt c time on an n n bidirectional mesh. <p> The number of comparison steps is, however, larger. The modified Schnorr/Shamir algorithm of section 2 runs in 2.5nt r + 3nt c time on an n n bidirectional mesh. The number of routes is therefore less than the 3n lower bound established in <ref> [SCHN86] </ref>. The algorithm of section 2 folds data onto an n n/ 2 submesh. By folding onto smaller submeshes, i.e., onto n n/ k submeshes for k &gt; 2, the number of routes can be reduced further. <p> Modified Schnorr/Shamir Algorithm The sorting algorithm of Schnorr and Shamir <ref> [SCHN86] </ref> is given in Figure 3. This algorithm uses the following terms and assumes that n = 2 4q for some integer q. 1. <p> Step 5: Sort all the vertical slices into snake-like row-major order. Step 6: Sort all the rows of the array into alternating left-to-right and right-to-left order. Step 7: Perform 2n 3/4 steps of even-odd transposition sort along the snake. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The correctness of the algorithm is established in <ref> [SCHN86] </ref>. As pointed out in [SCHN86], steps 1,3,5,7 take O (n 3/4 ) time and are dominated by steps 2,4,6. <p> Step 6: Sort all the rows of the array into alternating left-to-right and right-to-left order. Step 7: Perform 2n 3/4 steps of even-odd transposition sort along the snake. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The correctness of the algorithm is established in <ref> [SCHN86] </ref>. As pointed out in [SCHN86], steps 1,3,5,7 take O (n 3/4 ) time and are dominated by steps 2,4,6. <p> Following step 3 of the sorting algorithm, the maximum difference d 3 between the number of zeroes in any two columns of a horizontal slice is at most 2 <ref> [SCHN86] </ref>. <p> The proof of (ii) is same as that in <ref> [SCHN86] </ref> as our modification of step 4 does not move data between vertical slices. For (i), consider any two columns of n elements each. <p> Suppose the two element columns reside in two different processor columns. These two processor columns contain 4 element columns A,B,C,D. Let a,b,c,d respectively be the number of zeroes in these four columns prior to the execution of the modified step 4. From the proof of Theorem 3, part 4 <ref> [SCHN86] </ref>, we know that c x - y c 2n 1/4 where x,y a,b,c,d-. Let a,b,c ,d be the number of zeroes in column A,B,C,D following the modified step 4. <p> So, the complexity of the sort algorithm on a bidirectional mesh is 2.5n t r + 3n t c . Since t c is zero on the stronger mesh model, the sort time for this model is 2.5n t r (note that the algorithm of <ref> [SCHN86] </ref> has a run time of 3n t r ). <p> Conclusion We have shown that the lower bound for the number of routes needed to sort on an n n bidirectional mesh that was established in <ref> [SCHN86] </ref> is incorrect. Furthermore, we have provided algorithms that sort using fewer routes than the lower bound of [SCHN86]. <p> Conclusion We have shown that the lower bound for the number of routes needed to sort on an n n bidirectional mesh that was established in <ref> [SCHN86] </ref> is incorrect. Furthermore, we have provided algorithms that sort using fewer routes than the lower bound of [SCHN86].
Reference: [THOM77] <author> C.D. Thompson, H.T. Kung, </author> <title> "Sorting on a Mesh Connected Parallel Computer," </title> <journal> Communications of ACM, </journal> <volume> 20, 4, </volume> <month> April </month> <year> 1977, </year> <pages> 263-271. </pages>
Reference-contexts: The initial and final configurations have one data element in each of the nn processors (say in the A variable of each processor). In the final configuration the data elements are sorted in snake-like row-major order. This problem has been extensively studied for mesh architectures (see for e.g. <ref> [THOM77] </ref>, [NASS79], [KUMA83], [LEIG85], [SCHN86], [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor. <p> This problem has been extensively studied for mesh architectures (see for e.g. <ref> [THOM77] </ref>, [NASS79], [KUMA83], [LEIG85], [SCHN86], [SCHER89], [MARB88]). While all of these studies consider SIMD meshes, they differ in the permissible communication patterns. Thomp-son and Kung [THOM77] consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor. That is, all active processors transfer data to their north neighbor, or all to their south neighbor, etc. Using this model, Thompson and kung [THOM77] have developed <p> and Kung <ref> [THOM77] </ref> consider a strict unidirectional model in which all processors that simultaneously transfer data to a neighbor processor do so to the same neighbor. That is, all active processors transfer data to their north neighbor, or all to their south neighbor, etc. Using this model, Thompson and kung [THOM77] have developed a sorting algorithm with comlexity 6nt r + nt c + low order terms, where t r is the time needed to transfer one data element from a processor to its neighbor and t c is the time needed to compare two data elements that are in the <p> B is unfolded in a similar way. The total time for the sort is therefore 5nt r + nt c which is nt r less than that of <ref> [THOM77] </ref>. <p> Since (4n - 2) is the distance lower bound for the strict unidirectional model, our algorithm is near optimal for large k for this model too. The s 2 -way merge sorting algorithm of Thompson and Kung <ref> [THOM77] </ref> may be similarly generalized to sort n 2 elements stored k to a PE in an n (n/k ) mesh configuration. The resulting sort has a complexity that is almost identical to that of Figure 7. However, Figure 7 is conceptually much simpler. 4.
Reference: [WANG90a] <author> B. Wang and G. Chen, </author> <title> "Constant time algorithms for the transitive closure and some related graph problems on processor arrays with reconfigurable bus systems," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1, 4, </volume> <pages> 500-507, </pages> <year> 1990. </year>
Reference: [WANG90b] <author> B. Wang, G. Chen, and F. Lin, </author> <title> "Constant time sorting on a processor array with a reconfigurable bus system," </title> <journal> Info. Proc. Letrs., </journal> <volume> 34, 4, </volume> <pages> 187-190, </pages> <year> 1990. </year>
References-found: 19

