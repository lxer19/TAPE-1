URL: http://www.cs.ucsd.edu/~wgg/Abstracts/mchen.thesis.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/mchen.thesis.html
Root-URL: http://www.cs.ucsd.edu
Title: A Tool for Planning the Restructuring of Data Abstractions in Large Systems  
Author: Morison I-Fu Chen 
Degree: A thesis submitted in partial satisfaction of the requirements for the degree Master of Science in Computer Science by  Committee in charge: Professor William G. Griswold, Chairperson Professor Jeanne Ferrante Professor Karen Kavanagh  
Date: 1996  
Affiliation: UNIVERSITY OF CALIFORNIA, SAN DIEGO  
Abstract-found: 0
Intro-found: 1
Reference: [Adams 80] <author> Adams, S. </author> <title> Pirate's Adventure. </title> <journal> Byte, </journal> <volume> 5(12) </volume> <pages> 192-212, </pages> <year> 1980. </year>
Reference-contexts: We also provide an example of its use. Lastly, we justify that the C star diagram satisfies our goal of scaling and planning. 2.1 High-Level Description of the C Star Diagram all uses of the currentRoom global variable in the Scott Adam's adventure game program <ref> [Adams 80] </ref>. The C star diagram window consists of three major parts. The C star diagram visualization itself fills most of the window. The visualization appears in the form of a tree-shaped directed graph in the bottom half of the window. <p> We show the process of planning for data encapsulation, and demonstrate some of useful features provided by our tool to aid the planning for restructuring task. 2.3.1 Sample Encapsulation Exercise We use an adventure game program written by Scott Adams called saad-venture <ref> [Adams 80] </ref> to show a sample encapsulation using the C star diagram. saad-venture is a dungeon exploration game. The game allows the player to move around in a world, divided into rooms, to solve a puzzle. The complete description of the puzzle includes: room descriptions, objects, and results of actions. <p> The first program is the Scott Adam's saadventure program <ref> [Adams 80] </ref>. The second program is the Lawrence Brothers' omega adventure program [Lawrence 89]. The last program is the GNU Emacs program [GNU emacs]. The collected sample data is shown in Table 4.1; the data regarding the reduction in number of nodes and overall height is presented in Table 4.2.
Reference: [Brighton 93] <author> Brighton, A. TkTree widget. </author> <note> Copyright 1993. Available by anonymous ftp at ftp.aud.alcatel.com/tcl/extensions/tree. </note>
Reference-contexts: The current implementation runs under the X-windows environment on a Sun Sparc-station. 3.3.1 Tree Layout/Star Diagram Layout The star diagram visualization is essentially a tree with "merging" leaves at the end. We use Allan Brighton's TkTree widget <ref> [Brighton 93] </ref> for use with the Tcl/Tk [Ousterhout 94] script. We first use the TkTree widget to display the tree data structure we maintain in C++ class. <p> This process reduces the width of the star diagram. Since the TkTree widget <ref> [Brighton 93] </ref> tries to keep the parents close to the children in the display, the spacing between the parent nodes is reduced if the children nodes are removed as described previously. This in turn cuts down the height of the star diagram. <p> Also, the TkTree widget <ref> [Brighton 93] </ref> tries to keep the parents close to the children in the display, the spacing between the parent nodes is reduced if the children nodes are removed.
Reference: [Bowdidge 95] <author> Bowdidge, R. W. </author> <title> "Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization." </title> <type> PhD Dissertation. </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: Enhancements then can be more easily applied, thus reducing the overall time required to perform software maintenance and also lowering the overall cost. The research in this thesis builds on a visualization technique called the star diagram <ref> [Bowdidge 95] </ref> that can be used to help a programmer understand and manipulate the overall structure of a program. The star diagram uses a tree-like graphical representation to express the definition of a variable and its uses throughout the program. <p> Griswold and Bowdidge found the following restructuring transformations to be most applicable in use with a star diagram: Extract Function, Inline Function, Extract Parameter, Inline Parameter, Rename Function, Make Call, Move 5 into Interface, and Remove from Interface. The transformations available in the original star diagram are <ref> [Bowdidge 95] </ref>: * Extract Function. Extracting a computation or a set of similar computations makes the associated code the body of a new function, and replaces the occurrences of the computations with calls to that function. * Inline Function. <p> It may also be necessary to move a function out of an interface. This transformation is the opposite of "Move into Interface." 1.2.3 Key Concepts of Original Star Diagram Bowdidge argues in his dissertation that his star diagram concept works well for performing data encapsulation for the following reasons <ref> [Bowdidge 95] </ref>: a star diagram * provides a global, condensed view of program, * elides details irrelevant to the encapsulation, * groups similar expressions together, * supports restructuring, and * gives the tool user the control of planning and manipulation. <p> One of the biggest examples that Bowdidge has encountered in printing out a C star diagram was the global variable struct buffer in GNU Emacs. The resulting star diagram expands to twenty-six (26) 8.5 x 11 pages in height and three (3) pages in width <ref> [Bowdidge 95] </ref>. Thus, the scalability issue proves to be a great concern. Finally, the original star diagram provides the policy of changing the diagram by applying a specific restructuring transformation. It does not allow a tool user to modify the visualization without restructuring actual source code. <p> Horizontal Elision. The horizontal elision technique is used to bring the function nodes on the right side of a star diagram closer to first few levels of star nodes on the left side <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. Most C star diagram tool users tend to look at the first few levels of the star diagram on the left (especially stacked 21 nodes) and want to know their corresponding function nodes on the right. <p> For a complete description on the original star diagram design, please refer to Bowdidge's work <ref> [Bowdidge 95] </ref>. 3.2 Algorithm for Generating a C Star Diagram The C star diagram algorithm creates the star diagram by using the abstract syntax tree (AST). In order to generate a star diagram, the algorithm first parses the source code and generates an AST for the source code. <p> in dealing with the scalability of the C star diagram. 4 Effects of Elision Techniques On the Scalability of the C Star Diagram Bowdidge determined that the horizontal width of a star diagram tends to remain short, while the vertical height of a star diagram tends to be less scalable <ref> [Bowdidge 95] </ref>. In this section, we examine the effects of both "horizontal" and "vertical" elision techniques on the scalability of the C star diagram. We discuss each elision technique. We also present some sample data regarding the size of various C star diagrams and the effects of the elision techniques. <p> We first explain the study method used, present some observations and results we derived from the study, and provide a brief analysis. 5.1 Experiments Our study is modeled after Bowdidge's programmer study <ref> [Bowdidge 95] </ref>, which is based on Flor's studies of organization within teams of programmers in a laboratory setting [Flor & Hutchins 91, Flor 94]. We used two teams of two programmers working together. <p> There are several ways to help lower the cost of maintenance. One effective way is to restructure the existing system. The star diagram concept <ref> [Bowdidge 95] </ref> can be used to help a programmer understand and manipulate the overall structure of a program, thus reducing the overall time required to perform maintenance and also lowering the overall cost.
Reference: [Bowdidge & Griswold 94] <author> Bowdidge, R. and Griswold, W. G. </author> <title> "Automated Support for Encapsulating Abstract Data Types." </title> <booktitle> ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering. </booktitle> <pages> pp. 97-110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This idea, known as the star diagram, uses a graphical, direct-manipulation approach <ref> [Bowdidge & Griswold 94] </ref>. <p> Horizontal Elision. The horizontal elision technique is used to bring the function nodes on the right side of a star diagram closer to first few levels of star nodes on the left side <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. Most C star diagram tool users tend to look at the first few levels of the star diagram on the left (especially stacked 21 nodes) and want to know their corresponding function nodes on the right.
Reference: [Flor 94] <author> Flor, N. </author> <title> "Dynamic Organization in Multi-Agent Distributed Cognitive Systems." </title> <type> PhD dissertation, </type> <institution> Cognitive Science Department, University of California, </institution> <address> San Diego, </address> <year> 1994. </year>
Reference-contexts: We first explain the study method used, present some observations and results we derived from the study, and provide a brief analysis. 5.1 Experiments Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's studies of organization within teams of programmers in a laboratory setting <ref> [Flor & Hutchins 91, Flor 94] </ref>. We used two teams of two programmers working together.
Reference: [Flor & Hutchins 91] <author> Flor, N. and Hutchins, E. L. </author> <title> "Analyzing Distributed Cognition in Software Teams: A Case Study of Team Programming During Perfective Software Maintenance." </title> <editor> In Koenemann-Belliveau, J, Moher, T. G., and Robertson, S. P., editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Fourth Workshop, </booktitle> <pages> pp. 36-64. </pages> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1991. </year>
Reference-contexts: We first explain the study method used, present some observations and results we derived from the study, and provide a brief analysis. 5.1 Experiments Our study is modeled after Bowdidge's programmer study [Bowdidge 95], which is based on Flor's studies of organization within teams of programmers in a laboratory setting <ref> [Flor & Hutchins 91, Flor 94] </ref>. We used two teams of two programmers working together.
Reference: [GNU emacs] <editor> GNU Emacs (The extensible self-documenting text editor). </editor> <title> Copyright by Free Software Foundation, </title> <publisher> Inc., </publisher> <address> Cambridge, MA.. </address> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: The first program is the Scott Adam's saadventure program [Adams 80]. The second program is the Lawrence Brothers' omega adventure program [Lawrence 89]. The last program is the GNU Emacs program <ref> [GNU emacs] </ref>. The collected sample data is shown in Table 4.1; the data regarding the reduction in number of nodes and overall height is presented in Table 4.2.
Reference: [GNU g++] <author> GNU g++ compiler. </author> <title> Copyright by Free Software Foundation, </title> <publisher> Inc., </publisher> <address> Cam-bridge, MA., </address> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: We implemented the C star diagram generator in C++ to make use of Morgenthaler's 45 AST. We wrote a Tcl/Tk script to implement the graphical user interface and provide display and manipulation of the C star diagram. We use the GNU g++ compiler <ref> [GNU g++] </ref> and also make use of the GNU libg++ library [GNU lib] in our work. The current implementation runs under the X-windows environment on a Sun Sparc-station. 3.3.1 Tree Layout/Star Diagram Layout The star diagram visualization is essentially a tree with "merging" leaves at the end.
Reference: [GNU lib] <author> GNU Libg++ (The g++ class library). </author> <title> Copyright by Free Software Foundation, </title> <publisher> Inc., </publisher> <address> Cambridge, MA. </address> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: We wrote a Tcl/Tk script to implement the graphical user interface and provide display and manipulation of the C star diagram. We use the GNU g++ compiler [GNU g++] and also make use of the GNU libg++ library <ref> [GNU lib] </ref> in our work. The current implementation runs under the X-windows environment on a Sun Sparc-station. 3.3.1 Tree Layout/Star Diagram Layout The star diagram visualization is essentially a tree with "merging" leaves at the end.
Reference: [Griswold & Bowdidge 93] <author> Griswold, W. G. and Bowdidge, R. W. </author> <title> "Program Restructuring Via Design-Level Manipulation." </title> <booktitle> In Workshop on Studies of Software Design, 1993. </booktitle> <volume> 72 73 </volume>
Reference-contexts: However, its lexical and line-based orientation usually yields false matches, includes irrelevant information, misses surrounding context, and misses cases such as indirect references through assignment. 1.2 The Star Diagram The problems that Griswold and Bowdidge confronted in restructuring with the text view and other views <ref> [Griswold & Bowdidge 93] </ref> led them to a new idea 3 for dealing with data encapsulation. This idea, known as the star diagram, uses a graphical, direct-manipulation approach [Bowdidge & Griswold 94].
Reference: [Hutchins et al. 85] <author> Hutchins, E. L., Hollan, J. D., and Norman, D. A. </author> <title> "Direct Manipulation Interfaces." </title> <journal> Human-Computer Interaction, </journal> <volume> 1 </volume> <pages> 311-338, </pages> <year> 1985. </year>
Reference-contexts: The original star diagram uses a direct-manipulation interface <ref> [Hutchins et al. 85, Schneiderman 83] </ref> to specify a restructuring change. To apply a restructuring transformation to the program, the tool user clicks on a node, then clicks on a button for the desired restructuring transformation.
Reference: [Lawrence 89] <author> Lawrence, B. </author> <title> omega. [A complex, rogue-like game of dungeon exploration written and freely distributed by Lawrence Brothers.] </title> <note> Copyright 1989. Available from Lawrence Brothers: brothers@paul.rutgers.edu. </note>
Reference-contexts: The first program is the Scott Adam's saadventure program [Adams 80]. The second program is the Lawrence Brothers' omega adventure program <ref> [Lawrence 89] </ref>. The last program is the GNU Emacs program [GNU emacs]. The collected sample data is shown in Table 4.1; the data regarding the reduction in number of nodes and overall height is presented in Table 4.2. <p> We gave the programmers an adventure program called omega, written in roughly 31,000 lines of C. Omega is a complex, rogue-like game of dungeon exploration written and freely distributed by Lawrence Brothers <ref> [Lawrence 89] </ref>. The game lets a single player search through dungeons, cities, and wilderness. As a result, it is significantly more complex than rogue, which keeps the player in a dungeon only. 55 We asked the programmers to perform data encapsulation on the global variable Objects.
Reference: [Lientz & Swanson 80] <author> Lientz, B. and Swanson, E. </author> <title> "Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations," </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Software development is a complex and costly process. In particular, maintaining the source code usually proves to be difficult and time-consuming. Some studies have shown that software maintenance can account for 70% of the total software system's lifetime cost <ref> [Lientz & Swanson 80] </ref>. There are two choices for dealing with the maintenance of a system. One is to re-develop the system to meet the new requirements. The other is to make appropriate changes to the existing system.
Reference: [Liskov et al. 77] <author> Liskov, B., Snyder, A., Atkinson, R., and Schaffert, C. </author> <title> "Abstraction Mechanisms in CLU." </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <year> 1977. </year>
Reference-contexts: An effective method of maintaining a system is to re-introduce structure to the existing system while retaining current functionality. One of the more useful restructuring activities is data encapsulation. Data encapsulation <ref> [Parnas 72, Liskov et al. 77] </ref> is a useful restructuring activity because hiding the code related to a data structure undergoing maintenance limits the extent of changes to the scope of a module.
Reference: [Miyake 86] <author> Miyake, N. </author> <title> "Constructive Interaction and the Iterative Process of Understanding." </title> <journal> Cognitive Science, </journal> <volume> 10(2) </volume> <pages> 151-177, </pages> <year> 1986. </year>
Reference-contexts: We used two teams of two programmers working together. This technique, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it: * provides a more natural way to induce programmer talking than single-person think-aloud methods, and it * allows observing how the programmers perform problem solving and also ex posing the possible solutions they consider by studying their dialogue. 5.1.1 Study
Reference: [Morgenthaler 95] <author> Morgenthaler, J. D. and Griswold, W. G. </author> <title> "Program Analysis for Practical Program Restructuring." </title> <booktitle> In Proceedings of the ICSE-17 Workshop on Program Transformations for Software Evolution, </booktitle> <year> 1995. </year> <note> Proceedings available as Technical Report CS95-418, </note> <institution> Department of Computer Science and Engineering, University of California, </institution> <address> San Diego. </address>
Reference-contexts: David Morgenthaler provides the AST front end <ref> [Morgenthaler 95] </ref>, written in C++. We implemented the C star diagram generator in C++ to make use of Morgenthaler's 45 AST. We wrote a Tcl/Tk script to implement the graphical user interface and provide display and manipulation of the C star diagram.
Reference: [Ousterhout 94] <author> Ousterhout, J. K. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: the current AST node pointer into the current star node set and also maintains the link information between the current AST node pointer and the last AST node pointer. 3.3 Implementation Details The code for generating and manipulating the C star diagram consists of about 5,000 lines of Tcl/Tk script <ref> [Ousterhout 94] </ref> and about 800 lines of C++. (These numbers of lines do not include the code for the AST front end.) J. David Morgenthaler provides the AST front end [Morgenthaler 95], written in C++. <p> The current implementation runs under the X-windows environment on a Sun Sparc-station. 3.3.1 Tree Layout/Star Diagram Layout The star diagram visualization is essentially a tree with "merging" leaves at the end. We use Allan Brighton's TkTree widget [Brighton 93] for use with the Tcl/Tk <ref> [Ousterhout 94] </ref> script. We first use the TkTree widget to display the tree data structure we maintain in C++ class.
Reference: [Parnas 72] <author> Parnas, D. L. </author> <title> "On the Criteria To Be Used in Decomposing Systems into Modules," </title> <journal> Communication of the ACM, </journal> <volume> vol. 15, no. 12, </volume> <pages> pp. 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: An effective method of maintaining a system is to re-introduce structure to the existing system while retaining current functionality. One of the more useful restructuring activities is data encapsulation. Data encapsulation <ref> [Parnas 72, Liskov et al. 77] </ref> is a useful restructuring activity because hiding the code related to a data structure undergoing maintenance limits the extent of changes to the scope of a module.
Reference: [Schneiderman 83] <author> Schneidermann, B. </author> <title> "Direct Manipulation: A Step Beyond Programming Languages." </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 57-69, </pages> <year> 1983. </year>
Reference-contexts: The original star diagram uses a direct-manipulation interface <ref> [Hutchins et al. 85, Schneiderman 83] </ref> to specify a restructuring change. To apply a restructuring transformation to the program, the tool user clicks on a node, then clicks on a button for the desired restructuring transformation.
Reference: [Stevens et al. 74] <author> Stevens, W. P., Myers, G. J., and Constantine, L. L. </author> <title> "Structured Design." </title> <journal> IBM Systems Journal, </journal> <volume> 13(2) </volume> <pages> 115-139, </pages> <year> 1974. </year>
Reference: [Wildman 95] <author> Wildman, D. </author> <title> "Getting the Most From Paired-User Testing." </title> <journal> ACM Interactions, </journal> <volume> 2(3) </volume> <pages> 21-27, </pages> <year> 1995. </year>
Reference-contexts: We used two teams of two programmers working together. This technique, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it: * provides a more natural way to induce programmer talking than single-person think-aloud methods, and it * allows observing how the programmers perform problem solving and also ex posing the possible solutions they consider by studying their dialogue. 5.1.1 Study
References-found: 21

