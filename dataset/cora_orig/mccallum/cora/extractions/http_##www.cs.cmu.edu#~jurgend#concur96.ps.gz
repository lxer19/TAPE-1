URL: http://www.cs.cmu.edu/~jurgend/concur96.ps.gz
Refering-URL: http://www.cs.cmu.edu/~jurgend/cv.html
Root-URL: 
Email: E-mail: jurgend@cs.cmu.edu  
Title: Modular verification for shared-variable concurrent programs  
Author: Jurgen Dingel 
Address: Pittsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We propose a specification language for shared-variable concurrent programs based on Morgan's specification statement [Mor89]. A denotational semantics is given in terms of transition traces (sequences of pairs of states) following [Bro93]. A context-sensitive notion of approximation between specifications is presented which permits modular verification through stepwise program transformation. We argue that the resulting framework also supports program development through step wise refinement.
Abstract-found: 1
Intro-found: 1
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction In the quest for tractable verification methods for concurrent systems, assumption-commitment reasoning has received a lot of attention, e.g., <ref> [Jon83, Pnu85, AL93, GL91] </ref>. In this approach, proofs are split into two parts: First, it is shown that a component of the overall system satisfies a certain property under the assumption that its environment behaves in a certain way. <p> Context-sensitive approximation, for instance, could readily be extended to finer levels of granularity by following [Bro93] and allowing for assignments to be treated as non-atomic. Moreover, <ref> [AL93] </ref>, which is cast in a much more general setting, might be helpful for extending our work. The most important focus for further work will be the development of a proof system with which approximations S 1 I E S 2 could be formally derived.
Reference: [Bac88] <author> R.J.R. </author> <title> Back. A calculus of refinements for program derivations. </title> <journal> Acta Inform-atica, </journal> <volume> 25 </volume> <pages> 593-624, </pages> <year> 1988. </year>
Reference-contexts: The first pair of contexts in Example 4 suggests that in sequential contexts the input-output behaviour of a subprogram suffices to determine its effect on the rest of the context. Consider the refinement calculi for sequential programs as developed by Back, Morgan and Morris <ref> [Bac88, Mor94, Mor87] </ref>. There, a sequential program C is refined by another C 0 , C 0 ref seq C for short, iff wp (C; R))wp (C 0 ; R) for all state predicates R.
Reference: [BKP84] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Sixteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 51-63. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year>
Reference-contexts: Thus, we need to be able to distinguish transitions made by the program from transitions made by its environment. To this end, we tag the transitions appropriately | an idea already used, for instance, in <ref> [BKP84] </ref>. A tagged transition is of the form (s; t; s 0 ) 2 fi fp; eg fi where the tag t indicates whether the transition was made by the program or its environment. Tagged transitions with t = p are called program transitions. Environment transitions have t = e.
Reference: [Bro93] <author> S. D. Brookes. </author> <title> Full abstraction for a shared-variable parallel language. </title> <booktitle> In Proceedings 8th Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: The semantics is based on transition traces (sequences of pairs of states) which provide an elegant and robust denotational model of fair concurrent computation with shared memory as demonstrated in <ref> [Bro93] </ref>. We argue that transition traces constitute a powerful specification device and give rise to a useful notion of context-sensitive approximation which supports modular verification in the form of assumption-commitment reasoning. It seems that research on concurrency has so far been dominated by mostly operational methods. <p> E ::= [] j S; E j E ; S j S _ E j E _ S j S ^ E j E ^ S j [S||E ] j [E ||S] j In <ref> [Bro93] </ref>, the so-called transition traces form the basic tool to describe the behaviour of a command. Let s i 2 denote states, that is, mappings from the finite set of program variables Var to values. <p> In <ref> [Bro93] </ref> the meaning T of a command is given by a set of transition traces. To achieve full abstraction, trace sets are closed under two conditions: stuttering and mumbling. These closure conditions correspond, respectively, to reflexivity and transitivity of the ! fl relation in a conventional operational semantics. <p> These closure conditions correspond, respectively, to reflexivity and transitivity of the ! fl relation in a conventional operational semantics. We will also use transition traces to describe the behaviour of partial programs. However, in contrast with <ref> [Bro93] </ref>, we have to adopt a more restrictive mumbling closure condition, because we want to be able to interpret linear temporal logic (LTL) formulae over denotations of programs. The context-insensitive semantics T S maps partial programs to sets of transition traces closed under stuttering and restricted mumbling. <p> Fair interleaving of closed sets of traces can now be defined by: U 1 kU 2 = fff 1 kff 2 j ff 1 2 U 1 ^ ff 2 2 U 2 g y : For more details on the above definitions see <ref> [Bro93] </ref>. The treatment of local variables requires some notation. The trace hx = niff is like ff except that x has value n in the first state and that the value of x is "retained across points of interference". <p> Let sp (S; B) be the strongest postcondition of statement S with respect to initial states B. fBg denotes ; : [B; B], the stuttering step satisfying B. The programming language considered in <ref> [OG76, Bro93] </ref> is embedded into the language of partial programs through the following abbreviations. Note how the await statement is implemented using busy waiting. <p> Then, E [S 1 ] v T S E [S 2 ] but E [hS 1 i] 6v T SE E [hS 2 i]. 3 Approximation A very natural notion of approximation arises through trace inclusion. This was already considered in <ref> [Bro93] </ref> and used to validate several natural laws of concurrent programming, such as C||skip v T C and C 1 ||[C 2 ||C 3 ] v T [C 1 ||C 2 ]||C 3 . <p> Note that, since we assume the set of program variables Var to be finite, ff can expect only finitely many different variables to be changed by the environment. Following the full abstraction proof in <ref> [Bro93] </ref>, ff can be used to construct a context E ff such that there exists an interference-free ff 0 2 T SE [[ E ff [hS 1 i] ]] with ff 0 p = ff. <p> The resulting framework resembles compositional approaches to model checking [GL91] which considers finite state systems. This makes our approach more general, but also less amenable to automatic verification methods. One of the major advantages of our approach is that it builds on the rich theories in <ref> [Bro93, Mor94] </ref> which means that a lot of useful properties and results are directly available to us. Context-sensitive approximation, for instance, could readily be extended to finer levels of granularity by following [Bro93] and allowing for assignments to be treated as non-atomic. <p> One of the major advantages of our approach is that it builds on the rich theories in [Bro93, Mor94] which means that a lot of useful properties and results are directly available to us. Context-sensitive approximation, for instance, could readily be extended to finer levels of granularity by following <ref> [Bro93] </ref> and allowing for assignments to be treated as non-atomic. Moreover, [AL93], which is cast in a much more general setting, might be helpful for extending our work.
Reference: [Dij76] <author> E. W. Dijkstra. </author> <title> A discipline of programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: Following [Mor89], the weakest precondition of V : [P; Q] with respect to a state predicate R is given by wp (V : [P; Q]; R) = P ^ (8x 2 V:Q)R)[~x=~x 0 ]: The remaining sequential constructs are characterized by Dijkstra's well-known weakest precondition semantics <ref> [Dij76] </ref>. In Section 4 we will need the following proof rules. Proposition 10.
Reference: [Din96] <author> J. Dingel. </author> <title> Towards a theory for shared-variable concurrent programming. </title> <type> Thesis proposal, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: T S S 2 W W W W W W V 1 : [P 1 ; Q 1 ] v T S V 2 : [P 2 ; Q 2 ] iff P 1 [~x 0 =~x] ^ Q 1 ^ x2V 1 x = x 0 ) V See <ref> [Din96] </ref> for a more complete set of rules which also make use of the regular expression-like shape of partial programs. 3.1 Context-sensitive approximation on partial programs Trace set inclusion between two programs is a rather strong property since it expresses that the behaviour of one program in every possible context can <p> )I E S 0 2 if S 1 I 1 and S 2 I 2 S;E S 2 iff S 1 I 0 E S 2 and I)wp (S; I 0 ) where S is sequential We currently work on extending this proposition to a proof system for context-sensitive approximation <ref> [Din96] </ref>. 3.2 Approximation on contexts We extend approximation to contexts. Consider the contexts x:=1;y:=2;[]and y:=2;x:=1;[]. Both establish the same precondition for the program to be placed in the hole, and thus any program should behave the same in both of them. Consequently, we would like to identify these contexts. <p> Therefore, M 0 []kM A 0 , which implies M kM 0 [] M kA 0 with together with M kA 0 j= ' and Proposition 16 gives us M kM 0 j= '. 5 Other applications Stepwise Refinement: In <ref> [Din96] </ref> transition traces are used to work towards a refinement calculus for concurrent programs with shared memory. The idea is to start out with the specification itself and successively refine it until it contains sufficient detail to be implemented directly. <p> Refinement is reflexive and transitive and preserves LTL properties. Proposition 9 implies that approximation entails refinement, that is, S 1 I E S 2 implies E [S 1 ] ref E [S 2 ] (mod I). Examples for the formal derivation of programs from specifications can be found in <ref> [Din96] </ref>. Automatic verification: Example 3 illustrates two points. First, our framework supports the replacement of subprograms with large (possibly infinite) state spaces by subprograms with smaller (possibly finite) state spaces. Secondly, partial programs are expressive enough to conveniently capture typical underlying environment assumptions.
Reference: [GL91] <author> O. Grumberg and D. </author> <title> Long. Model checking and modular verification. </title> <booktitle> In CONCUR '91, </booktitle> <publisher> LNCS 527. Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction In the quest for tractable verification methods for concurrent systems, assumption-commitment reasoning has received a lot of attention, e.g., <ref> [Jon83, Pnu85, AL93, GL91] </ref>. In this approach, proofs are split into two parts: First, it is shown that a component of the overall system satisfies a certain property under the assumption that its environment behaves in a certain way. <p> Automatic verification methods like model checking constitute a very interesting and rewarding domain of application. There, researchers find themselves in a constant struggle to strike an appropriate balance between expressivity on the one hand and computational complexity on the other. In <ref> [GL91] </ref>, assumption-commitment arguments are introduced into the model-checking setting. Using this approach, a typical line of reasoning goes as follows: Suppose that M and M 0 are finite state machines and that we want to show that their parallel composition M kM 0 satisfies some temporal logic property '. <p> In other words, M discharges assumption A, M 0 under assumption A discharges assumption A 0 , and M under assumption A 0 satisfies the desired formula. The approach to assumption-commitment reasoning as developed in <ref> [GL91] </ref> allows us to conclude that M kM 0 j= '. This paper transfers some of these ideas from finite state machines to shared-variable concurrent programs and uses them for a formal framework supporting compositional reasoning about these kinds of programs. <p> ] :cs^:ct [] S init ; E [Var : [tt; :(cs ^ ct)] ! ] from which the desired result easily follows with Proposition 16. 2 Before we conclude this section, we want to return to the introduction and validate how closely our theory corresponds to the one presented in <ref> [GL91] </ref>. To this end, we recast the derivation presented in the introduction in our setting. We will overload the notation and assume that M; M 0 ; A and A 0 also make sense in our framework. <p> In contrast to related approaches, e.g. [Jon83, Sti88, Stt91], it is specification-oriented, that is, specifications are distinguished from programs not by the kind of semantic properties they define, but rather by the amount of information they provide towards implementation. The resulting framework resembles compositional approaches to model checking <ref> [GL91] </ref> which considers finite state systems. This makes our approach more general, but also less amenable to automatic verification methods.
Reference: [Jon83] <author> C. B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <booktitle> In IFIF '83, </booktitle> <year> 1983. </year>
Reference-contexts: 1 Introduction In the quest for tractable verification methods for concurrent systems, assumption-commitment reasoning has received a lot of attention, e.g., <ref> [Jon83, Pnu85, AL93, GL91] </ref>. In this approach, proofs are split into two parts: First, it is shown that a component of the overall system satisfies a certain property under the assumption that its environment behaves in a certain way. <p> In contrast to related approaches, e.g. <ref> [Jon83, Sti88, Stt91] </ref>, it is specification-oriented, that is, specifications are distinguished from programs not by the kind of semantic properties they define, but rather by the amount of information they provide towards implementation. The resulting framework resembles compositional approaches to model checking [GL91] which considers finite state systems.
Reference: [Lar87] <author> K. G. Larsen. </author> <title> A context dependent equivalence between processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 49(2) </volume> <pages> 185-216, </pages> <year> 1987. </year>
Reference-contexts: Typically, we want to reason about a program in a fixed context and thus it suffices to show approximation with respect to that particular context. So, one would like to parameterize the approximation relation with information about the context. In <ref> [Lar87] </ref> Larsen demonstrates how this can be done for CCS and bisimulation. Let I range over state predicates.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentise Hall International, </publisher> <year> 1989. </year>
Reference-contexts: Note, for instance, that trace inclusion is a congruence. This is due essentially to the compositional definition of T S in terms of monotone operations on trace sets. Moreover, parallel compositions can be "unrolled" using a variant of Milner's expansion theorem <ref> [Mil89] </ref>. Additionally, trace inclusion between specification statements can be characterized logically. Let A and B range over specification statements. Proposition 4.
Reference: [Mor87] <author> J.M. Morris. </author> <title> A theoretical basis for stepwise refinement and the programming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(3) </volume> <pages> 287-306, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: The first pair of contexts in Example 4 suggests that in sequential contexts the input-output behaviour of a subprogram suffices to determine its effect on the rest of the context. Consider the refinement calculi for sequential programs as developed by Back, Morgan and Morris <ref> [Bac88, Mor94, Mor87] </ref>. There, a sequential program C is refined by another C 0 , C 0 ref seq C for short, iff wp (C; R))wp (C 0 ; R) for all state predicates R.
Reference: [Mor89] <author> C. Morgan. </author> <title> The specification statement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: We adopt Morgan's specification statement <ref> [Mor89] </ref> to achieve this. The most basic partial program statement is of the form V : [P; Q], where V is a set of variables and P and Q are assertions. <p> T 0 3 on the other hand, can set its variables to only finitely many values in any environment. 2 A partial program is called sequential if it does not contain a parallel composition. We can give a weakest precondition semantics to sequential partial programs. Following <ref> [Mor89] </ref>, the weakest precondition of V : [P; Q] with respect to a state predicate R is given by wp (V : [P; Q]; R) = P ^ (8x 2 V:Q)R)[~x=~x 0 ]: The remaining sequential constructs are characterized by Dijkstra's well-known weakest precondition semantics [Dij76].
Reference: [Mor94] <author> C. Morgan. </author> <title> Programming from specifications. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: The first pair of contexts in Example 4 suggests that in sequential contexts the input-output behaviour of a subprogram suffices to determine its effect on the rest of the context. Consider the refinement calculi for sequential programs as developed by Back, Morgan and Morris <ref> [Bac88, Mor94, Mor87] </ref>. There, a sequential program C is refined by another C 0 , C 0 ref seq C for short, iff wp (C; R))wp (C 0 ; R) for all state predicates R. <p> The resulting framework resembles compositional approaches to model checking [GL91] which considers finite state systems. This makes our approach more general, but also less amenable to automatic verification methods. One of the major advantages of our approach is that it builds on the rich theories in <ref> [Bro93, Mor94] </ref> which means that a lot of useful properties and results are directly available to us. Context-sensitive approximation, for instance, could readily be extended to finer levels of granularity by following [Bro93] and allowing for assignments to be treated as non-atomic.
Reference: [OG76] <author> S.S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: Let sp (S; B) be the strongest postcondition of statement S with respect to initial states B. fBg denotes ; : [B; B], the stuttering step satisfying B. The programming language considered in <ref> [OG76, Bro93] </ref> is embedded into the language of partial programs through the following abbreviations. Note how the await statement is implemented using busy waiting.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, NATO ASI F13, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction In the quest for tractable verification methods for concurrent systems, assumption-commitment reasoning has received a lot of attention, e.g., <ref> [Jon83, Pnu85, AL93, GL91] </ref>. In this approach, proofs are split into two parts: First, it is shown that a component of the overall system satisfies a certain property under the assumption that its environment behaves in a certain way.
Reference: [Sti88] <author> C. Stirling. </author> <title> A generalization of Owicki-Gries' Hoare logic for a concurrent while language. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 347-359, </pages> <year> 1988. </year>
Reference-contexts: In contrast to related approaches, e.g. <ref> [Jon83, Sti88, Stt91] </ref>, it is specification-oriented, that is, specifications are distinguished from programs not by the kind of semantic properties they define, but rather by the amount of information they provide towards implementation. The resulting framework resembles compositional approaches to model checking [GL91] which considers finite state systems.
Reference: [Stt91] <author> K. Sttlen. </author> <title> A method for the development of totally correct shared-state parallel programs. </title> <booktitle> In CONCUR '91. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In contrast to related approaches, e.g. <ref> [Jon83, Sti88, Stt91] </ref>, it is specification-oriented, that is, specifications are distinguished from programs not by the kind of semantic properties they define, but rather by the amount of information they provide towards implementation. The resulting framework resembles compositional approaches to model checking [GL91] which considers finite state systems.
References-found: 17

