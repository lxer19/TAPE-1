URL: http://www-sal.cs.uiuc.edu/~nachum/papers/mitra-thesis.ps.gz
Refering-URL: http://sal.cs.uiuc.edu/~nachum/papers/
Root-URL: http://www.cs.uiuc.edu
Title: SEMANTIC UNIFICATION FOR CONVERGENT SYSTEMS  
Author: BY SUBRATA MITRA 
Degree: B.Tech., Indian Institute of Technology, Kanpur, 1988 M.S., University of Delaware, 1991 THESIS Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science in the Graduate College of the  
Address: 1994 Urbana, Illinois  
Affiliation: University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [ Arnborg and Tiden, 1985 ] <author> A. Arnborg and E. Tiden. </author> <title> Unification problems with one-sided dis-tributivity. </title> <booktitle> In Proceedings of the First International Conference on Rewriting Techniques and Applications. </booktitle> <volume> Volume 202, </volume> <pages> pages 398-406, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity [Stickel, 1981], and different variants of distributivity <ref> [Arnborg and Tiden, 1985; Contejean, 1992] </ref>; see [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] for surveys on unification. Here, we study the unification problem with respect to convergent systems, where some of the function symbols in the system additionally satisfy the equivalences of associativity and commutativity. <p> A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes <ref> [Arnborg and Tiden, 1985] </ref> Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo D (f; g),A (f ),C (f ) no Szabo D (f; g) unknown Szabo Table 2.6: Results on equational unification In Table 2.5 we have listed the operators and equational theories that <p> Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes <ref> [Arnborg and Tiden, 1985] </ref> Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo D (f; g),A (f ),C (f ) no Szabo D (f; g) unknown Szabo Table 2.6: Results on equational unification In Table 2.5 we have listed the operators and equational theories that are of interested, while Table 2.6 contains the
Reference: [ Baader, 1986 ] <author> A. Baader. </author> <title> Unification in idempotent semigroups is of type zero. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Volume 2, Number 3, </volume> <pages> pages 283-286, </pages> <year> 1986. </year>
Reference-contexts: [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes <ref> [Siekmann and Szabo, 1984; Baader, 1986] </ref> C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo
Reference: [ Baader and Buttner, 1988 ] <author> F. Baader and W. Buttner. </author> <title> Unification in commutative, idempotent monoids. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 56, Number 1, </volume> <pages> pages 345-352, </pages> <year> 1988. </year>
Reference-contexts: Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes <ref> [Baader and Buttner, 1988] </ref> Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo D (f; g),A (f ),C (f ) no Szabo D (f; g) unknown Szabo Table 2.6: Results on equational unification In Table 2.5 we
Reference: [ Baader and Siekmann, 1993 ] <author> F. Baader and J. H. Siekmann. </author> <title> Unification theory. </title> <editor> In D. M. Gab-bay, C. J. Hogger and J. A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity [Stickel, 1981], and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see <ref> [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] </ref> for surveys on unification. Here, we study the unification problem with respect to convergent systems, where some of the function symbols in the system additionally satisfy the equivalences of associativity and commutativity. <p> Almost all the material in this section has been adapted from [Jouannaud and Kirchner, 1991]. Other surveys of unification include <ref> [Siekmann, 1989; Baader and Siekmann, 1993] </ref>. <p> It would be interesting to see if the combination technique of Chapter 4 would still be valid in this case. * The second problem concerns decidability of higher-order matching. Higher-order matching seems to be significantly simpler than higher-order unification <ref> [Baader and Siekmann, 1993] </ref>. Huet [1975] himself showed that second-order matching is decidable and conjectured that this decidability result holds in general, which is still an open problem, except for the third-order case [Dowek, 1992].
Reference: [ Bachmair, 1987 ] <author> L. Bachmair. </author> <title> Proof methods for equational theories. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1987. </year>
Reference-contexts: Their solution is based on the fact that any equational theory can be completed (using unfailing completion techniques developed by <ref> [Bachmair, 1987] </ref> and others) into a (possibly infinite) ground convergent rewrite system.
Reference: [ Bachmair, 1992 ] <author> L. Bachmair. </author> <title> Associative-commutative reduction orderings. </title> <journal> Information Processing Letters, </journal> <volume> Volume 43, </volume> <pages> pages 21-27, </pages> <year> 1992. </year>
Reference-contexts: In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in [Kapur et al., 1990]. Similar research has been reported in <ref> [Bachmair and Plaisted, 1985; Bachmair, 1992] </ref>, and recently in [Delor and Puel, 1993; Rubio and Nieuwenhuis, 1993]. 1.2 Outline of the Thesis In Chapter 2 we introduce most of the notations that we are going to use, and briefly provide some historical perspective on semantic unification. <p> Independently, Bachmair [1992] presented an AC-compatible rewrite-relation, also based on [Kapur et al., 1990], and proved its termination using a minimal counterexample argument. Our termination condition is essentially the same as one rewrite step of <ref> [Bachmair, 1992] </ref>, with the possibility of multiset status added. It is believed that the transitive closure of our relation is identical to the ordering in [Kapur et al., 1990], but this remains to be proved. <p> It will be interesting to be able to extend the relation defined here to cases where simple multiset comparisons may be allowed for subterms of the AC-terms. However, as shown 79 in <ref> [Bachmair, 1992] </ref>, even simple rules like f (g (x; y); z) ! f (x; y), may lead to non-terminating rewrite sequences. The binary path condition as a sufficient condition for AC-termination was presented in [Der-showitz and Mitra, 1992]. <p> However, one inconvenience with their ordering is that it orients the distributivity axiom (for example, x fl (y + z) = x fl y + x fl z) the "wrong" way. We believe that a lexicographic combination of BPC (or, for that matter, any other ordering, for example, <ref> [Kapur et al., 1990; Bachmair, 1992; Delor and Puel, 1993] </ref>, that orients distributivity the right way) together with the ordering of [Rubio and Nieuwenhuis, 1993] would solve the problem. 80 7 DECIDABLE EQUATION SOLVING The transformation systems described in Chapter 3 are complete for unification and matching in convergent rewrite systems.
Reference: [ Bachmair and Plaisted, 1985 ] <author> L. Bachmair and D. A. Plaisted. </author> <title> Termination orderings for associative-commutative rewrite systems. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Volume 1, </volume> <pages> pages 329-349, </pages> <year> 1985. </year>
Reference-contexts: In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in [Kapur et al., 1990]. Similar research has been reported in <ref> [Bachmair and Plaisted, 1985; Bachmair, 1992] </ref>, and recently in [Delor and Puel, 1993; Rubio and Nieuwenhuis, 1993]. 1.2 Outline of the Thesis In Chapter 2 we introduce most of the notations that we are going to use, and briefly provide some historical perspective on semantic unification. <p> The interesting point about bpc is that it is easy to implement; much easier than the ordering of [Kapur et al., 1990]. 6.3 Examples The binary path condition developed in the previous section, like ac , and unlike <ref> [Bachmair and Plaisted, 1985] </ref>, has no restriction on the precedence relation f , and can therefore be used to prove termination of a large class of rewrite systems. 78 Example 17 (Arithmetic over natural numbers).
Reference: [ Barbuti et al., 1986 ] <author> R. Barbuti, M. Bellia, G. Levi and M. Martelli. Leaf: </author> <title> a language which integrates logic, equations and functions. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 201-238, </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year> <month> 129 </month>
Reference: [ Ben Cherifa and Lescanne, 1987 ] <author> A. Ben Cherifa and P. Lescanne. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Volume 9, </volume> <pages> pages 137-159, </pages> <year> 1987. </year>
Reference-contexts: Polynomials can be used to prove termination of rewriting modulo AC when AC-equivalent terms have the same interpretation. But this severely restricts the degree of polynomial that can be used. (See [Lankford, 1979] and <ref> [Ben Cherifa and Lescanne, 1987] </ref>.) Path orderings have been commonly used in theorem provers, even for AC-rewriting (see the discussion in [Bjorner, 1982, page 350]), despite the fact that they do not establish termination in the AC case (see the counterexamples in [Dershowitz et al., 1983]).
Reference: [ Bellia and Levi, 1986 ] <author> M. Bellia and G. Levi. </author> <title> The relation between logic and functional languages: a survey. </title> <journal> Journal of Logic Programming, </journal> <volume> Volume 3, Number3, </volume> <pages> pages 217-236, </pages> <year> 1986. </year>
Reference: [ Bjorner, 1982 ] <editor> D. Bjorner, editor. </editor> <booktitle> Proceedings of the IFIP working conference on formal description of programming concepts-II. </booktitle> <address> Garmisch-Partenkirchen, West Germany, </address> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: But this severely restricts the degree of polynomial that can be used. (See [Lankford, 1979] and [Ben Cherifa and Lescanne, 1987].) Path orderings have been commonly used in theorem provers, even for AC-rewriting (see the discussion in <ref> [Bjorner, 1982, page 350] </ref>), despite the fact that they do not establish termination in the AC case (see the counterexamples in [Dershowitz et al., 1983]).
Reference: [ Bockmayr, 1987 ] <author> A. Bockmayr. </author> <title> A note on a canonical theory with undecidable unification and matching problem. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Volume 3, </volume> <pages> pages 379-381, </pages> <year> 1987. </year>
Reference-contexts: However, it is well-known that both these problems are, in general, undecidable <ref> [Bockmayr, 1987; Heilbrunner and Holldobler, 1987; Dershowitz and Jouannaud, 1990] </ref>. Hullot [1980], Kapur and Narendran [1987] and Christian [1992] have provided different syntactic restrictions on the rewrite system which result in decidable unification in theories defined by convergent systems.
Reference: [ Bockmayr et al., 1992 ] <author> A. Bockmayr, S. Krischer and A. Werner. </author> <title> An optimal narrowing strategy for general canonical systems. </title> <booktitle> In Proceedings of the Third International Workshop on Conditional Term Rewriting Systems, France, 1992. </booktitle> <volume> Volume 656, </volume> <pages> pages 483-497, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference: [ Bosco et al., 1987 ] <author> P. G. Bosco, E. Giovanneti and C. Moiso. </author> <title> Refined strategies for semantic unification. </title> <booktitle> In Proceedings of the International Joint Conference on Theory and Practice of Software Development. </booktitle> <volume> Volume 250, </volume> <pages> pages 276-290, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Thus, one branch of the choice would explore different narrowings at any position, while the other branch would mark that position as irreducible. Completeness of this 15 kind of a narrowing strategy has been explored in <ref> [Bosco et al., 1987] </ref>, wherein an innermost order has been used for applying narrowings. In Chapter 3 we use a similar idea to provide a complete unification procedure for convergent systems; however, our solution looks at terms at the outermost position, and therefore allows for more pruning of unsatisfiable goals.
Reference: [ Breazu-Tannen, 1988 ] <author> V. Breazu-Tannen. </author> <title> Combining algebra and higher-order types. </title> <booktitle> In Proceedings of the Third Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 82-90, </pages> <year> 1988. </year>
Reference-contexts: This was, in fact, pointed out in [Dougherty and Johann, 1990], wherein a more efficient system for general E-unification has been presented. 48 4 HIGHER-ORDER UNIFICATION There have been different proposals to combine higher-order features with first order equational reasoning (including <ref> [Breazu-Tannen, 1988; Dougherty, 1991] </ref>, and others). These proposals deal with the combination of lambda-calculus and a first-order equational theory. <p> We define combinatory-R reduction as ! C [ ! R , which is convergent whenever R is a convergent rewrite system (using a similar result from <ref> [Breazu-Tannen, 1988] </ref>). It is well-known that using combinatory reductions is not enough to capture equivalence of lambda terms. For example, SK and KI are distinct normal forms with respect to ! C , though their translations to lambda-calculus are both equal to yz:z.
Reference: [ Chabin and Rety, 1991 ] <author> J. Chabin and P. Rety. </author> <title> Narrowing directed by a graph of terms. </title> <booktitle> In Proceedings of the Fourth International Conference on Rewriting Techniques and Applications, Como, Italy, 1991. </booktitle> <volume> Volume 488, </volume> <pages> pages 112-123, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In general, we apply rules only to the top-most position in goals. * It is possible to incorporate additional pruning rules (for example, reachability analysis of <ref> [Dershowitz and Sivakumar, 1987; Chabin and Rety, 1991] </ref>) directly. 4.1 Notations for Combinatory Logic We begin with a brief discussion of notations pertaining to combinatory-logic.
Reference: [ Cheong and Fribourg, 1993 ] <author> P. H. Cheong and L. </author> <title> Fribourg. Implementation of narrowing: the prolog-based approach. </title> <editor> In K. R. Apt, J. W. de Bakker, and J. Rutten, editors, </editor> <title> Logic 130 Programming Languages, Constraints, Functions and Objects, </title> <booktitle> chapter 1, </booktitle> <pages> pages 1-20, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference: [ Christian, 1992 ] <author> J. Christian. </author> <title> Some termination criteria for narrowing and E-narrowing. </title> <booktitle> In Proceeding of the Eleventh International Conference on Automated Deduction, </booktitle> <address> Saratoga Springs, New York, </address> <booktitle> 1992. </booktitle> <volume> Volume 607, </volume> <pages> pages 582-588, </pages> <booktitle> of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer Verlag. </publisher>
Reference: [ Clocksin and Mellish, 1981 ] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: See [Kowalski, 1979] for a survey on logic programming. Logic programs, which use Horn clauses to recursively define predicates, are elegant in their use of "logic-variables." For example, we could define append in Prolog (see <ref> [Clocksin and Mellish, 1981] </ref>) as: append (nil; x; x) :- true; append (a x; y; a z) :- append (x; y; z) and solve the query append (x; x; x) ? = true to obtain the solution fx 7! nilg.
Reference: [ Comon, 1992 ] <author> H. Comon. </author> <title> On unification of terms with integer exponents. </title> <type> Technical Report 770, </type> <institution> Universite de Paris-Sud, Laboratoire de Recherche en Informatique, </institution> <year> 1992. </year>
Reference-contexts: Therefore, whenever we have multiple such subgoals to solve, we have to find the language in the intersection of two such recurrent schemata, which can be done, using a result from [Socher-Ambrosius, 1993], which itself is an extension of a theorem from <ref> [Comon, 1992] </ref> (see discussion after Example 35). Example 34.
Reference: [ Comon et al., 1991 ] <author> H. Comon, M. Haberstrau and J.-P. Jouannaud. </author> <title> Decidable problems in shallow equational theories. </title> <type> Technical Report 718, </type> <institution> Universite de Paris-Sud, Laboratoire de Recherche en Informatique, </institution> <year> 1991. </year>
Reference: [ Contejean, 1992 ] <author> E. Contejean. </author> <title> A partial solution for D-unification based on a reduction to AC1-unification. </title> <journal> Journal of Symbolic Computation, </journal> <note> to appear. </note>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity [Stickel, 1981], and different variants of distributivity <ref> [Arnborg and Tiden, 1985; Contejean, 1992] </ref>; see [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] for surveys on unification. Here, we study the unification problem with respect to convergent systems, where some of the function symbols in the system additionally satisfy the equivalences of associativity and commutativity.
Reference: [ DeGroot and Lindstrom, 1986 ] <editor> D. DeGroot and G. Lindstrom, editors. </editor> <title> Logic programming: Functions, Relations and Equations. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: It is, therefore, of interest to combine the essential features of these two programming paradigms. Over the years, numerous different approaches have been suggested for this combination, including [Barbuti et al., 1986; Bellia and Levi, 1986; Reddy, 1986; Subrahmanyam and You, 1986]; see <ref> [DeGroot and Lindstrom, 1986] </ref> for a survey of the area. One popular idea is based on conditional equational theories [Dershowitz and Josephson, 1984; Goguen and Meseguer, 1984; Fribourg, 1985; Lindstrom, 1985; Dershowitz and Plaisted, 1988; Cheong and Fribourg, 1993].
Reference: [ Delor and Puel, 1993 ] <author> C. Delor and L. Puel. </author> <title> Extension of the associative path ordering to a chain of associative-commutative symbols. </title> <booktitle> In Proceedings of the Fifth International Conference on Rewriting Techniques and Applications, Montreal, Canada, 1993. </booktitle> <volume> Volume 690, </volume> <pages> pages 389-404, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in [Kapur et al., 1990]. Similar research has been reported in [Bachmair and Plaisted, 1985; Bachmair, 1992], and recently in <ref> [Delor and Puel, 1993; Rubio and Nieuwenhuis, 1993] </ref>. 1.2 Outline of the Thesis In Chapter 2 we introduce most of the notations that we are going to use, and briefly provide some historical perspective on semantic unification. <p> However, one inconvenience with their ordering is that it orients the distributivity axiom (for example, x fl (y + z) = x fl y + x fl z) the "wrong" way. We believe that a lexicographic combination of BPC (or, for that matter, any other ordering, for example, <ref> [Kapur et al., 1990; Bachmair, 1992; Delor and Puel, 1993] </ref>, that orients distributivity the right way) together with the ordering of [Rubio and Nieuwenhuis, 1993] would solve the problem. 80 7 DECIDABLE EQUATION SOLVING The transformation systems described in Chapter 3 are complete for unification and matching in convergent rewrite systems.
Reference: [ Dershowitz, 1982 ] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 17, </volume> <pages> pages 279-301, </pages> <year> 1982. </year>
Reference-contexts: Therefore, it is important to find orderings which can be used to prove termination of rewrite systems, modulo the combination of associativity and commutativity. We show that a simple (and easily implementable) restriction on the recursive path ordering <ref> [Dershowitz, 1982] </ref> is sufficient for establishing termination of extended rewriting, modulo associativity and commutativity.
Reference: [ Dershowitz, 1987 ] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Volume 3, </volume> <pages> pages 69-116, </pages> <year> 1987. </year> <month> 131 </month>
Reference-contexts: Termination of a system of rewrite rules is important for using rewriting as a computational tool, and for simplification in theorem provers. Typically, termination proofs are done using path orderings, or by interpreting function symbols as multivariate polynomials; see <ref> [Dershowitz, 1987] </ref> for a survey of the area. In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in [Kapur et al., 1990]. <p> One popular way of proving termination of a rewrite system is to use path orderings, based on a precedence relation on the function symbols of the system. Another common approach interprets function symbols as multivariate polynomials. For a survey of these techniques, see <ref> [Dershowitz, 1987] </ref>. In this chapter we will consider extended rewriting modulo the axioms of associativity and commutativity. Since it is not possible to orient the commutativity axiom without losing termination, rewriting modulo such a congruence has to be handled in a special way.
Reference: [ Dershowitz and Josephson, 1984 ] <author> N. Dershowitz and A. N. Josephson. </author> <title> Logic programming by completion. </title> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <address> Uppsala, Sweden, </address> <pages> pages 313-320, </pages> <year> 1984. </year>
Reference: [ Dershowitz et al., 1983 ] <author> N. Dershowitz, J. Hsiang, N. A. Josephson and D. A. Plaisted. </author> <title> Associative-commutative rewriting. </title> <booktitle> In Proceedings of the Eighth International Joint Conference on Artificial Intelligence, </booktitle> <address> Karlsruhe, West Germany, </address> <pages> pages 940-944, </pages> <year> 1983. </year>
Reference-contexts: that can be used. (See [Lankford, 1979] and [Ben Cherifa and Lescanne, 1987].) Path orderings have been commonly used in theorem provers, even for AC-rewriting (see the discussion in [Bjorner, 1982, page 350]), despite the fact that they do not establish termination in the AC case (see the counterexamples in <ref> [Dershowitz et al., 1983] </ref>). Extensions of path orderings that do handle associative and commutative functions properly ([Bachmair and Plaisted, 1985], for example) have been proposed, most recently in [Kapur et al., 1990].
Reference: [ Dershowitz and Jouannaud, 1990 ] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 6, </booktitle> <pages> pages 243-320, </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: We also briefly recall important results about semantic unification. 2.1 Terminology In this section we describe and review basic notation, and indicate some important results that are needed in the remainder of this thesis. For surveys of rewrite systems refer to <ref> [Huet and Oppen, 1980; Dershowitz and Jouannaud, 1990; Klop, 1992] </ref>. Most of the notations that we use in this thesis have been borrowed from [Dershowitz and Jouannaud, 1990]. <p> For surveys of rewrite systems refer to [Huet and Oppen, 1980; Dershowitz and Jouannaud, 1990; Klop, 1992]. Most of the notations that we use in this thesis have been borrowed from <ref> [Dershowitz and Jouannaud, 1990] </ref>. <p> However, it is well-known that both these problems are, in general, undecidable <ref> [Bockmayr, 1987; Heilbrunner and Holldobler, 1987; Dershowitz and Jouannaud, 1990] </ref>. Hullot [1980], Kapur and Narendran [1987] and Christian [1992] have provided different syntactic restrictions on the rewrite system which result in decidable unification in theories defined by convergent systems.
Reference: [ Dershowitz and Manna, 1979 ] <author> N. Dershowitz and Z. Manna. </author> <title> Proving termination with multi-set orderings. </title> <journal> Communications of the ACM, </journal> <volume> Volume 22, </volume> <pages> pages 465-476, </pages> <year> 1979. </year>
Reference: [ Dershowitz and Mitra, 1992 ] <author> N. Dershowitz and S. Mitra. </author> <title> Path orderings for termination of associative-commutative rewriting. </title> <booktitle> In Proceedings of the Third International Workshop on Conditional Term Rewriting Systems, France, 1992. </booktitle> <volume> Volume 656, </volume> <pages> pages 168-174, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference: [ Dershowitz and Mitra, 1993 ] <author> N. Dershowitz and S. Mitra. </author> <title> Higher-order and semantic unification. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Foundations of Software Technology and Theoretical Computer Science, Bombay, India, 1993. </booktitle> <volume> Volume 761, </volume> <pages> pages 139-150, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: the instance of PCP under consideration has one. 7.4 Summary on Decidability Results Most of the results on decidable semantic matching using non-erasing rules were first presented in [Dershowitz et al., 1992], while the theorem for decidable unification (using left- and right-linear systems with flat right-hand sides) was presented in <ref> [Dershowitz and Mitra, 1993] </ref>. Decidable matching and unification are particularly useful in pattern directed languages, constraint solving and theorem proving.
Reference: [ Dershowitz et al., 1992 ] <author> N. Dershowitz, S. Mitra and G. Sivakumar. </author> <title> Decidable matching for convergent systems. </title> <booktitle> In Proceedings of the Eleventh Conference on Automated Deduction, 1992. </booktitle> <volume> Volume 607, </volume> <pages> pages 589-602, </pages> <booktitle> of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: case of non-erasing systems, we could apply partial solutions as required, and therefore do not have to explicitly consider Apply. 3.6 Discussion Most of the results given in Section 3.1 were first presented in [Dershowitz et al., 1990], while the completeness of matching in the restricted case was proved in <ref> [Dershowitz et al., 1992] </ref>. The main advantage of the method outlined in this thesis, over narrowing, is that our approach provides more control on positions where rules get applied to goals. Completeness of narrowing strategies (for example, outer narrowing [You, 1989] and innermost narrowing [Fribourg, 1985]) have been investigated. <p> convergent rewrite system with the required syntactic restrictions, such that the matching problem described above has a solution if and only if the instance of PCP under consideration has one. 7.4 Summary on Decidability Results Most of the results on decidable semantic matching using non-erasing rules were first presented in <ref> [Dershowitz et al., 1992] </ref>, while the theorem for decidable unification (using left- and right-linear systems with flat right-hand sides) was presented in [Dershowitz and Mitra, 1993]. Decidable matching and unification are particularly useful in pattern directed languages, constraint solving and theorem proving.
Reference: [ Dershowitz et al., 1990 ] <author> N. Dershowitz, S. Mitra and G. Sivakumar. </author> <title> Equation solving in conditional AC-theories. </title> <booktitle> In Proceedings of the Second International Conference on Algebraic and Logic Programming, Nancy, France, 1990. </booktitle> <volume> Volume 463, </volume> <pages> pages 283-297, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher> <pages> 132 </pages>
Reference-contexts: That this computed solution is at least as general as the solution under consideration is a consequence of the fact that each application of a transformation rule is solution preserving. A sketch of this completeness proof first appeared in <ref> [Dershowitz et al., 1990] </ref>. However, in that paper, Definition 4.4 (Page 289) does not include the subterm property for the ordering , which is incorrect (actually, the completeness proof in Section 5 of [Dershowitz et al., 1990] uses the correct ordering). <p> A sketch of this completeness proof first appeared in <ref> [Dershowitz et al., 1990] </ref>. However, in that paper, Definition 4.4 (Page 289) does not include the subterm property for the ordering , which is incorrect (actually, the completeness proof in Section 5 of [Dershowitz et al., 1990] uses the correct ordering). This was pointed out by Hanus [1993] and others. 31 3.2.3 Discussion We have used the concept of irreducibility predicates in the transformation rules, which was used in the soundness proof, but not for completeness. <p> Note that, as in the case of non-erasing systems, we could apply partial solutions as required, and therefore do not have to explicitly consider Apply. 3.6 Discussion Most of the results given in Section 3.1 were first presented in <ref> [Dershowitz et al., 1990] </ref>, while the completeness of matching in the restricted case was proved in [Dershowitz et al., 1992]. The main advantage of the method outlined in this thesis, over narrowing, is that our approach provides more control on positions where rules get applied to goals. <p> This example shows that for RC-unification, the top-down approach works better than one based on narrowing. Similar pruning capabilities of the top-down approach for the first-order case alone has been mentioned in <ref> [Dershowitz and Sivakumar, 1987; Dershowitz et al., 1990] </ref>, and they carry over to higher-order solving also. More elaborate pruning mechanisms have been studied for the first order case by Chabin and Rety [1991], where a graph of terms based on R and the goals under question has been used.
Reference: [ Dershowitz and Okada, 1990 ] <author> N. Dershowitz and M. Okada. </author> <title> A rationale for conditional equa-tional programming. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 75, </volume> <pages> pages 111-138, </pages> <year> 1990. </year>
Reference-contexts: One popular idea is based on conditional equational theories [Dershowitz and Josephson, 1984; Goguen and Meseguer, 1984; Fribourg, 1985; Lindstrom, 1985; Dershowitz and Plaisted, 1988; Cheong and Fribourg, 1993]. In the equational programming paradigm proposed by Dershowitz and Plaisted [1988] (see also <ref> [Josephson and Dershowitz, 1989; Dershowitz and Okada, 1990] </ref>), computation consists of solving an equation in the theory specified by the program (program being a set of conditional equations that define unique normal forms).
Reference: [ Dershowitz et al., 1987 ] <author> N. Dershowitz, M. Okada and G. Sivakumar. </author> <title> Confluence of conditional rewrite systems. </title> <booktitle> In Proceedings of the First International Workshop on Conditional Term Rewriting Systems, Orsay, France, 1987. </booktitle> <volume> Volume 308, </volume> <pages> pages 31-44, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: By restricting the terms in the condition to be "smaller" (in some well-founded ordering) we obtain a class of decreasing systems for which we have methods for checking important properties like confluence, etc., <ref> [Dershowitz et al., 1987] </ref>. Definition 1 (Decreasing). A conditional rewrite rule is decreasing, if there is a well-founded extension of the proper subterm ordering that contains !, such that for each rule c : l ! r and any substitution , l c.
Reference: [ Dershowitz et al., 1988 ] <author> N. Dershowitz, M. Okada and G. Sivakumar. </author> <title> Canonical conditional rewrite systems. </title> <booktitle> In Proceedings of the Ninth Conference on Automated Deduction, Ar-gonne, IL, 1988. </booktitle> <volume> Volume 310, </volume> <pages> pages 538-549, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: The rule x &gt; 0 = true : factorial (x) ! x fl factorial (x 1) has only one premise in the condition. We can replace the left-hand side factorial (x) by the right-hand side only for those substitutions for which the condition "holds." See <ref> [Dershowitz et al., 1988] </ref> for different versions of the operational mechanism for checking if the condition holds. The simplest is to use rewriting itself to check that the terms in the condition have the same normal form.
Reference: [ Dershowitz and Plaisted, 1988 ] <author> N. Dershowitz and D. A. Plaisted. </author> <title> Equational programming. </title> <editor> In J. E. Hayes, D. Michie and J. Richards, editors, </editor> <booktitle> Machine Intelligence 11: The logic and acquisition of knowledge, chapter 2, </booktitle> <pages> pages 21-56, </pages> <publisher> Oxford Press, Oxford, </publisher> <year> 1988. </year>
Reference: [ Dershowitz and Sivakumar, 1987 ] <author> N. Dershowitz and G. Sivakumar. </author> <title> Solving goals in equational languages. </title> <booktitle> In Proceedings of the First International Workshop Conditional Term Rewriting System, Orsay, France, 1987. </booktitle> <volume> Volume 308, </volume> <pages> pages 45-55, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In general, we apply rules only to the top-most position in goals. * It is possible to incorporate additional pruning rules (for example, reachability analysis of <ref> [Dershowitz and Sivakumar, 1987; Chabin and Rety, 1991] </ref>) directly. 4.1 Notations for Combinatory Logic We begin with a brief discussion of notations pertaining to combinatory-logic. <p> This example shows that for RC-unification, the top-down approach works better than one based on narrowing. Similar pruning capabilities of the top-down approach for the first-order case alone has been mentioned in <ref> [Dershowitz and Sivakumar, 1987; Dershowitz et al., 1990] </ref>, and they carry over to higher-order solving also. More elaborate pruning mechanisms have been studied for the first order case by Chabin and Rety [1991], where a graph of terms based on R and the goals under question has been used. <p> Finally, the last branch does not generate a solution since it is evident from the rewrite system that a term with g at its root can never generate a c. This notion of reachability analysis was first introduced in <ref> [Dershowitz and Sivakumar, 1987; Dershowitz and Sivakumar, 1988] </ref>, and was extended in [Chabin and 71 a (b (x; y)) ! ? x 0 ; Imitate b (x; y) ! ? x 1 ; x 0 7! a (x 1 ) ; Constraint Fail a (b (x; y)) ! ? x 0
Reference: [ Dershowitz and Sivakumar, 1988 ] <author> N. Dershowitz and G. Sivakumar. </author> <title> Goal-directed equation solving. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <address> St. Paul, MN, </address> <pages> pages 166-170, </pages> <year> 1988. </year>
Reference-contexts: draw a 38 directed arc from f to all the nodes in the graph, while for rules like f (l 1 ; : : : ; l n ) ! g (r 1 ; : : : ; r m ), we draw an arc from f to g (see <ref> [Dershowitz and Sivakumar, 1988] </ref> for further details). Notice that the reachability test can be incorporated into the narrowing process too, with similar results. In fact, more recently, Chabin and Rety [1991] have developed an extension of the reachability test discussed here, for a narrowing based approach. <p> Finally, the last branch does not generate a solution since it is evident from the rewrite system that a term with g at its root can never generate a c. This notion of reachability analysis was first introduced in <ref> [Dershowitz and Sivakumar, 1987; Dershowitz and Sivakumar, 1988] </ref>, and was extended in [Chabin and 71 a (b (x; y)) ! ? x 0 ; Imitate b (x; y) ! ? x 1 ; x 0 7! a (x 1 ) ; Constraint Fail a (b (x; y)) ! ? x 0 <p> For this example, we have used the notion of reachability from <ref> [Dershowitz and Sivakumar, 1988] </ref>.
Reference: [ Dougherty, 1991 ] <author> D. J. Dougherty. </author> <title> Adding algebra to the untyped lambda-calculus. </title> <booktitle> In Proceedings of the Fourth International Conference on Rewriting Techniques and Applications, Como, Italy, 1991. </booktitle> <volume> Volume 488, </volume> <pages> pages 37-48, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: This was, in fact, pointed out in [Dougherty and Johann, 1990], wherein a more efficient system for general E-unification has been presented. 48 4 HIGHER-ORDER UNIFICATION There have been different proposals to combine higher-order features with first order equational reasoning (including <ref> [Breazu-Tannen, 1988; Dougherty, 1991] </ref>, and others). These proposals deal with the combination of lambda-calculus and a first-order equational theory.
Reference: [ Dougherty, 1993 ] <author> D. J. Dougherty. </author> <title> Higher-order unification via combinators. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 114, </volume> <pages> pages 273-298, </pages> <year> 1993. </year>
Reference: [ Dougherty and Johann, 1990 ] <author> D. J. Dougherty and P. Johann. </author> <title> An improved general E-unification method. </title> <booktitle> In Proceedings of the Tenth Conference on Automated Deduction, 133 1990. </booktitle> <volume> Volume 449, </volume> <pages> pages 261-275, </pages> <booktitle> of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: This action (called top-unification) reduces the positions where further paramodulation can be applied, and therefore results in a better system. See <ref> [Dougherty and Johann, 1990] </ref> for further details. Another suggestion, mentioned in [Hsiang and Jouannaud, 1988], is to consider more 20 cases for the terms on the two sides of the goals, and to perform variable bindings eagerly. <p> However, they have used symmetric goals, and therefore generate some redundant solutions. This was, in fact, pointed out in <ref> [Dougherty and Johann, 1990] </ref>, wherein a more efficient system for general E-unification has been presented. 48 4 HIGHER-ORDER UNIFICATION There have been different proposals to combine higher-order features with first order equational reasoning (including [Breazu-Tannen, 1988; Dougherty, 1991], and others).
Reference: [ Dougherty and Johann, 1992 ] <author> D. J. Dougherty and P. Johann. </author> <title> A combinatory logic approach to higher-order E-unification. </title> <booktitle> In Proceedings of the Eleventh Conference on Automated Deduction, </booktitle> <address> Saratoga Springs, New York, </address> <booktitle> 1992. </booktitle> <volume> Volume 607, </volume> <pages> pages 79-93, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Recently, Dougherty and Johann ([Dougherty and Johann, 1992; Dougherty, 1993]) proposed a method for higher-order reasoning by transforming lambda-calculus terms to combinatory logic, that is, they use a combination of combinatory-logic with an equational theory as the formulation of higher-order reasoning. In <ref> [Dougherty and Johann, 1992] </ref>, they also provide a complete set of transformations for solving the satisfiability problem in such a combined system. Some of the main advantages (pointed out in [Dougherty and Johann, 1992]) of using combinatory logic as the basis of higher-order unification (as opposed to the traditional lambda-calculus based <p> In <ref> [Dougherty and Johann, 1992] </ref>, they also provide a complete set of transformations for solving the satisfiability problem in such a combined system. Some of the main advantages (pointed out in [Dougherty and Johann, 1992]) of using combinatory logic as the basis of higher-order unification (as opposed to the traditional lambda-calculus based methods such as [Snyder, 1990; Nipkow and Qian, 1991], etc.) are: it eliminates some technical problems associated with bound variables, allows easy incorporation of type-variables, and facilitates the use of <p> We extend the first-order unification procedure from Section 3.1 to develop a complete method for solving the satisfiability problem in (typed) combinatory logic, together with a set of algebraic axioms R, when R can be presented as a convergent rewrite system. The main problem with the approach used of <ref> [Dougherty and Johann, 1992] </ref> is that narrowing as a method for solving equations provides very little control, since a complete method based on narrowing has to, in general, apply rules to all possible positions in terms. <p> In this chapter we combine the higher-order formulation of combinatory-logic with the first order top-down approach outlined in Chapter 3. Thus, the combination enjoys the following additional advantages (over <ref> [Dougherty and Johann, 1992] </ref>): 49 * It provides more control on positions where rules get applied. <p> The set of transformation rules (called IR, for innermost reduce) shown is Table 4.1 can be used to solve this problem. The transformation rules that we provide here are a refinement of the set RVT used by <ref> [Dougherty and Johann, 1992] </ref> (see Section 2.2). For simplicity of exposition we consider the rewrite system to be left-linear. However, techniques similar to those outlined in [Dougherty and Johann, 1992] could be used to incorporate non-left-linear rules. <p> The transformation rules that we provide here are a refinement of the set RVT used by <ref> [Dougherty and Johann, 1992] </ref> (see Section 2.2). For simplicity of exposition we consider the rewrite system to be left-linear. However, techniques similar to those outlined in [Dougherty and Johann, 1992] could be used to incorporate non-left-linear rules. In Table 4.1, we use C to denote the weak reduction rules of combinatory logic, while R stands for the convergent rewrite system. The only major difference between IR and RVT of [Dougherty and Johann, 1992] is in Reduce; herein <p> However, techniques similar to those outlined in <ref> [Dougherty and Johann, 1992] </ref> could be used to incorporate non-left-linear rules. In Table 4.1, we use C to denote the weak reduction rules of combinatory logic, while R stands for the convergent rewrite system. The only major difference between IR and RVT of [Dougherty and Johann, 1992] is in Reduce; herein we suggest that any rewrite step must be applied to some innermost position. Furthermore, our system allows additional arguments only when the corresponding terms are irreducible (with respect to C [ R). <p> We indicate a straight forward proof of the lemma by constructing an equivalent RVT reduction sequence. Note that IR is a restriction of RVT. Thus, from Theorem 2.5 of <ref> [Dougherty and Johann, 1992] </ref> it follows that whenever G is trivial, s = RC t must hold. For the other part, suppose s = RC t. Compare the IR transformation sequence under question with a possible RVT sequence. <p> Thus, IR is sufficient to prove extensional (RC) equality between CL terms, with respect to a left-linear rewrite system R. 52 Since IR is a restriction of RVT, we also have that every sequence of IR transformations is terminating (by virtue of a similar observations made about RVT in <ref> [Dougherty and Johann, 1992] </ref>). <p> Nevertheless, every transformation rule must be type preserving. We also insist that only pure terms are bound to variables (in Eliminate and Bind). Furthermore, we would restrict our attention to left-linear rewrite systems alone. The more general case can be handled using ideas developed in <ref> [Dougherty and Johann, 1992] </ref>. The transformation rules in Table 3.2 form the crux of the higher-order semantic unification procedure, since they provide a strategy of unification with respect to weak-combinatory equality. However, weak combinatory equality is not identical to = RC . <p> In this case, the appropriate ordering consists of an extension of the one used to show that all IR sequences are terminating (that is, the ordering used in <ref> [Dougherty and Johann, 1992] </ref> to show that all RVT sequences are terminating). Any innermost reduction steps can be simulated using WR (with respect to C [R). <p> Note that a term with A at its head can never be RC-unified with a term with B as its head, since there are no rules to change one to the other. Now consider the goal: A (xZ) ? = BZ. Using the approach of <ref> [Dougherty and Johann, 1992] </ref>, the subterm xZ could be narrowed indefinitely: xZ ; x 1 Z (y 1 Z); x 7! (Sx 1 )y 1 However, using the approach outlined in this thesis, we first transform the goal to get fA (xZ) ! ? x 0 ; x 00 7! (BZ)g,
Reference: [ Dowek, 1992 ] <author> G. Dowek. </author> <title> Third-order matching is decidable. </title> <booktitle> In Proceedings of the 7th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 1-10, </pages> <address> Santa Cruz, California, </address> <year> 1992. </year>
Reference-contexts: Higher-order matching seems to be significantly simpler than higher-order unification [Baader and Siekmann, 1993]. Huet [1975] himself showed that second-order matching is decidable and conjectured that this decidability result holds in general, which is still an open problem, except for the third-order case <ref> [Dowek, 1992] </ref>. It may be easier to formulate the higher-order matching problem in combinatory logic and get a better notion of termination of the resulting system of transformation rules, using the completeness result from Section 3.5 together with techniques from Chapter 7.
Reference: [ Fages, 1984 ] <author> F. Fages. </author> <title> Associative-commutative unification. </title> <booktitle> In Proceedings of the Seventh International Conference on Automated Deduction, 1984. </booktitle> <volume> Volume 170, </volume> <pages> pages 194-208, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes <ref> [Stickel, 1981; Fages, 1984; Kirchner, 1989] </ref> A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g)
Reference: [ Fay, 1979 ] <author> M. Fay. </author> <title> First-order unification in an equational theory. </title> <booktitle> In Proceedings of the Fourth Workshop on Automated Deduction, </booktitle> <pages> pages 161-167, </pages> <address> Austin, TX, </address> <year> 1979. </year>
Reference-contexts: The narrowing strategy discussed above is complete for confluent rewrite systems (actually, narrowing is complete with respect to irreducible solutions for confluent and non-terminating systems). In fact, if the system is convergent it is possible to use simplification deterministically <ref> [Fay, 1979] </ref>. For such systems, another refinement of narrowing, which uses a notion of basic positions (a proper subset of all available positions) for applying rules from R, was proposed in [Hullot, 1980]. <p> In normalized narrowing, whenever a term admits a rewrite step, such a step is taken deterministically, without considering any of the other possible narrowings of the term. Such a strategy is complete whenever the rewrite system is convergent <ref> [Fay, 1979] </ref>. In our system, we have to add the transformation rule described in Table 3.3 to have similar effects.
Reference: [ Fribourg, 1985 ] <author> L. Fribourg. Slog: </author> <title> a logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic Programming, </booktitle> <pages> pages 172-184, </pages> <address> Boston, MA, </address> <year> 1985. </year>
Reference-contexts: The main advantage of the method outlined in this thesis, over narrowing, is that our approach provides more control on positions where rules get applied to goals. Completeness of narrowing strategies (for example, outer narrowing [You, 1989] and innermost narrowing <ref> [Fribourg, 1985] </ref>) have been investigated. These strategies are complete only when the rewrite system has additional restrictions, over and above convergence. The method outlined in this thesis, on the other hand, is complete for any convergent presentation.
Reference: [ Gallier and Snyder, 1989 ] <author> J. H. Gallier and W. Snyder. </author> <title> Complete sets of transformations for general E-unification. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 67, </volume> <pages> pages 203-260, </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: Martelli and Monta-nari [1982] used transformations on systems of equations to describe syntactic unification. The method was later adapted in [Martelli et al., 1989] to provide a complete unification procedure for convergent rewrite systems. Furthermore, Gallier and Snyder have used transformations for describing equational and higher-order unification <ref> [Gallier and Snyder, 1989; Snyder and Gallier, 1989] </ref>, while Kirchner [1984] uses the technique for unification in syntactic theories. Our method is a variant of narrowing, based on the top-down approach outlined in [Martelli et al., 1989]. <p> For example, in our case, by virtue of Lemma 2, we know that Bind and Eliminate are solution preserving, and therefore we can deterministically bind variables whenever they appear as the left-hand side of a directed goal. (See Section 10 of <ref> [Gallier and Snyder, 1989] </ref> for a discussion of the problems of proving completeness in presence of eager binding if symmetric goals are used.) Therefore, in essence, our method combines the advantages of [Martelli et al., 1989] and [Nutt et al., 1989] in a single unified framework. <p> : : : ; t n ) ; Imitate' x ! ? y ; Var-Param x ! ? y ; where f (l 1 ; : : : ; l n ) ! r is a renamed rule in R Table 8.2: Transformation rules for satisfiability of ! ? of <ref> [Gallier and Snyder, 1989; Snyder, 1991] </ref>, since, in our system, we would get E-unification if we used both variants (l ! r and r ! l) of every equation l = r 2 E.
Reference: [ Goguen and Meseguer, 1984 ] <author> J. A. Goguen and J. Meseguer. </author> <title> Equality, types, modules and generics for logic programming. </title> <booktitle> In Proc. of the Second International Logic Programming Conference, </booktitle> <pages> pages 115-125, </pages> <year> 1984. </year>
Reference: [ Hanus, 1993 ] <author> M. </author> <title> Hanus. </title> <journal> Presonal Communication, </journal> <month> summer </month> <year> 1993. </year>
Reference: [ Heilbrunner and Holldobler, 1987 ] <author> S. Heilbrunner and S. Holldobler. </author> <title> The undecidability of the unification and matching problem for canonical theories. </title> <journal> Acta Informatica, </journal> <volume> Volume 24, </volume> <pages> pages 157-171, </pages> <year> 1987. </year> <month> 134 </month>
Reference-contexts: However, it is well-known that both these problems are, in general, undecidable <ref> [Bockmayr, 1987; Heilbrunner and Holldobler, 1987; Dershowitz and Jouannaud, 1990] </ref>. Hullot [1980], Kapur and Narendran [1987] and Christian [1992] have provided different syntactic restrictions on the rewrite system which result in decidable unification in theories defined by convergent systems. <p> which has similar properties (that is, the matching problem is decidable, while the unification problem is not): Example 20. 0 + x ! x 0 fl x ! 0 s (x) fl s (y) ! s (y + (x fl s (y))) The next example that we use is from <ref> [Heilbrunner and Holldobler, 1987] </ref>, wherein a scheme to construct a convergent system of rewrite rules has been discussed, given two (simple) context-free grammars in Greibach normal form. Here we provide an example (see [Heilbrunner and Holldobler, 1987] for details about termination and confluence of the resulting rewrite system): Example 21. <p> (y) ! s (y + (x fl s (y))) The next example that we use is from <ref> [Heilbrunner and Holldobler, 1987] </ref>, wherein a scheme to construct a convergent system of rewrite rules has been discussed, given two (simple) context-free grammars in Greibach normal form. Here we provide an example (see [Heilbrunner and Holldobler, 1987] for details about termination and confluence of the resulting rewrite system): Example 21. <p> Therefore, in general, there can be no decision procedure to solve the problem f (S 1 $; S 2 $; x) ? = f ($; $; $) (since such a decision procedure would also decide if the intersection of two simple context-free languages is empty, which is undecidable <ref> [Heilbrunner and Holldobler, 1987] </ref>). 7.2 Decidable Matching As noted earlier, in the most general case, semantic matching can be as difficult as full semantic unification: For example, adding a new rule eq (x; x) ! true to the system of Example 19 makes the problem of unifying two terms s and <p> Example 22. By the above result, the following system has a decidable semantic matching problem. app (nil; x) ! x In <ref> [Heilbrunner and Holldobler, 1987] </ref>, there is an example of a system with a single defined function in every right-hand side, which has an undecidable semantic matching problem (Example 21 shows the construction for a particular case). <p> It is undecidable if a function symbol is depth non-decreasing. Proof. Consider the system: g (x) ! h (f (S 1 $; S 2 $; x); x) where f is as detailed in <ref> [Heilbrunner and Holldobler, 1987] </ref> (Example 21 shows the construction of f for a particular set of context-free grammars). Assuming convergence of f , it is easy to show that this combined system is also convergent. <p> If we drop restriction 2 matching becomes equivalent to solving the emptiness problem for the intersection of two context-free languages, which is undecidable; see <ref> [Heilbrunner and Holldobler, 1987] </ref> for the construction. In the remaining cases, we show that matching of certain goals would result in unification in the theories of addition (+) and multiplication (fl). Notice that the definitions of + and fl in Example 20 obey all the syntactic restrictions of Theorem 25.
Reference: [ Henderson, 1980 ] <author> P. Henderson. </author> <title> Functional programming: application and implementation. </title> <booktitle> Prentice-Hall International Series in Computer Science, </booktitle> <year> 1980. </year>
Reference-contexts: 1 INTRODUCTION 1.1 Motivation Functional programming (see <ref> [Henderson, 1980] </ref> for an introductory exposition), which originated from the study of the Lambda-Calculus, is a style of programming based on recursive function definitions.
Reference: [ Hermann, 1992 ] <author> M. Hermann. </author> <title> On the relation between primitive recursion, schematization and divergence. </title> <booktitle> In Proceedings of the Third International Conference on Algebraic and Logic Programming, Volterra, Italy, 1992. </booktitle> <volume> Volume 632, </volume> <pages> pages 115-127, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Another approach for a recurrent schematization of an infinite family of terms (using the so called primal grammars) has been mentioned in <ref> [Hermann, 1992] </ref>, wherein a narrowing-like strategy has been used for unification of such families of terms.
Reference: [ Holldobler, 1987 ] <author> S. Holldobler. </author> <title> A unification algorithm for confluent theories. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Automata, Languages and Programming, 1987. </booktitle> <volume> Volume 267, </volume> <pages> pages 31-41, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: We started with unification in confluent systems, in which case, narrowing is complete with respect to irreducible solutions, whereas the method of <ref> [Holldobler, 1987] </ref> is complete even with respect to reducible solutions. For convergent systems, narrowing and variants of it, such as normalized and basic narrowing (and a combination thereof, due to [Nutt et al., 1989]) are all complete strategies.
Reference: [ Hopcroft and Ullman, 1979 ] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages and computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Proof. We show that semantic matching in such theories can be used to simulate the undecidable Post's Correspondence Problem (PCP, <ref> [Hopcroft and Ullman, 1979] </ref>). An instance of PCP consists of two lists A = w 1 ; : : :; w k and B = x 1 ; : : :; x k , of strings over some alphabet .
Reference: [ Hsiang and Jouannaud, 1988 ] <author> J. Hsiang and J.-P. Jouannaud. </author> <title> General E-unification revisited. </title> <booktitle> In Proceedings of the Second International Workshop on Unification, </booktitle> <year> 1988. </year>
Reference-contexts: This action (called top-unification) reduces the positions where further paramodulation can be applied, and therefore results in a better system. See [Dougherty and Johann, 1990] for further details. Another suggestion, mentioned in <ref> [Hsiang and Jouannaud, 1988] </ref>, is to consider more 20 cases for the terms on the two sides of the goals, and to perform variable bindings eagerly.
Reference: [ Huet, 1975 ] <author> G. P. Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> Volume 1, </volume> <pages> Pages 27-57, </pages> <year> 1975. </year>
Reference: [ Huet and Oppen, 1980 ] <author> G. Huet and D. C. Oppen. </author> <title> Equations and rewrite rules: a survey. </title> <editor> In, R. Book, editor, </editor> <booktitle> Formal Language Theory: Perspectives and Open Problems, </booktitle> <pages> pages 349-405, </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: We also briefly recall important results about semantic unification. 2.1 Terminology In this section we describe and review basic notation, and indicate some important results that are needed in the remainder of this thesis. For surveys of rewrite systems refer to <ref> [Huet and Oppen, 1980; Dershowitz and Jouannaud, 1990; Klop, 1992] </ref>. Most of the notations that we use in this thesis have been borrowed from [Dershowitz and Jouannaud, 1990].
Reference: [ Hullot, 1980 ] <author> J.-M. Hullot. </author> <title> Canonical forms and unification. </title> <booktitle> In Proceedings of the Fifth International Conference on Automated Deduction, Les Arcs, France, 1980. </booktitle> <volume> Volume 87, </volume> <pages> pages 318-334, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In fact, if the system is convergent it is possible to use simplification deterministically [Fay, 1979]. For such systems, another refinement of narrowing, which uses a notion of basic positions (a proper subset of all available positions) for applying rules from R, was proposed in <ref> [Hullot, 1980] </ref>. Basic narrowing is complete for convergent systems, but not for systems that are confluent and non-terminating; see [Middeldorp and Hamoen, 1992] for a counterexample. Recently, narrowing based unification methods have been studied by way of their optimality. <p> g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes <ref> [Hullot, 1980] </ref> A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) <p> This gives basic-narrowing-like capabilities without having to keep explicit markers for basic positions <ref> [Hullot, 1980] </ref>. <p> Thus, for every such sequence emanating from a mutation, we now have a decrease in . Theorem 26 is a slight extension of one in <ref> [Hullot, 1980] </ref>, which considers only ground terms or variables on the right-hand sides. 101 For the next result we need the following definition: Definition 20 (Subterm Composing).
Reference: [ Josephson and Dershowitz, 1989 ] <author> N. A. Josephson and N. Dershowitz. </author> <title> An implementation of narrowing. </title> <journal> Journal of Logic Programming, </journal> <volume> Volume 6 (1&2), </volume> <pages> pages 57-77, </pages> <year> 1989. </year>
Reference-contexts: One popular idea is based on conditional equational theories [Dershowitz and Josephson, 1984; Goguen and Meseguer, 1984; Fribourg, 1985; Lindstrom, 1985; Dershowitz and Plaisted, 1988; Cheong and Fribourg, 1993]. In the equational programming paradigm proposed by Dershowitz and Plaisted [1988] (see also <ref> [Josephson and Dershowitz, 1989; Dershowitz and Okada, 1990] </ref>), computation consists of solving an equation in the theory specified by the program (program being a set of conditional equations that define unique normal forms).
Reference: [ Jouannaud et al., 1983 ] <editor> J.-P. Jouannaud, C. Kirchner and H. Kirchner. </editor> <title> Incremental construction of unification algorithms in equational theories. </title> <booktitle> In Proceedings of the International Colloquium on Automata, Languages and Programming, 1983. </booktitle> <volume> Volume 154, </volume> <pages> pages 361-373, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher> <pages> 135 </pages>
Reference-contexts: ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes <ref> [Jouannaud et al., 1983] </ref> A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo D (f; g),A (f ),C (f ) no Szabo D (f; g)
Reference: [ Jouannaud and Kirchner, 1991 ] <author> J.-P. Jouannaud and C. Kirchner. </author> <title> Solving equations in ab-stract algebras: a rule-based survey of unification. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity [Stickel, 1981], and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see <ref> [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] </ref> for surveys on unification. Here, we study the unification problem with respect to convergent systems, where some of the function symbols in the system additionally satisfy the equivalences of associativity and commutativity. <p> Another suggestion, mentioned in [Hsiang and Jouannaud, 1988], is to consider more 20 cases for the terms on the two sides of the goals, and to perform variable bindings eagerly. Unfortunately, a proof of completeness of this system is still forthcoming (see <ref> [Jouannaud and Kirchner, 1991] </ref> for the actual system of transformation rules). 2.2.4 Semantic Unification in Specific Equational Theories In this section we provide a brief summary of results for unification in specific equational the ories. Almost all the material in this section has been adapted from [Jouannaud and Kirchner, 1991]. <p> is still forthcoming (see <ref> [Jouannaud and Kirchner, 1991] </ref> for the actual system of transformation rules). 2.2.4 Semantic Unification in Specific Equational Theories In this section we provide a brief summary of results for unification in specific equational the ories. Almost all the material in this section has been adapted from [Jouannaud and Kirchner, 1991]. Other surveys of unification include [Siekmann, 1989; Baader and Siekmann, 1993].
Reference: [ Kamin, 1990 ] <author> S. N. Kamin. </author> <title> Programming languages: an interpreter-based approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [ Kapur and Narendran, 1987 ] <author> D. Kapur and P. Narendran. </author> <title> Matching, unification and complexity. </title> <journal> ACM SIGSAM Bulletin, </journal> <volume> Volume 21, Number 4, </volume> <pages> pages 6-9, </pages> <year> 1987. </year>
Reference-contexts: The rest of the proof is similar to the one for Theorem 26. Theorem 27 is an extension of a decidability result in <ref> [Kapur and Narendran, 1987] </ref>, which deals with rewrite systems in which every right-hand side is a subterm of the corresponding left-hand side (that is, for their rules, the constructor context C in Theorem 27 is always empty, P is the singleton set containing the root position, and r 1 r is
Reference: [ Kapur et al., 1990 ] <author> D. Kapur, G. Sivakumar and H. Zhang. </author> <title> A new method for proving termination of AC-rewrite systems. </title> <booktitle> In Proceedings of the Tenth International Conference of Foundations of Software Technology and Theoretical Computer Science, 1990. </booktitle> <volume> Volume 472, </volume> <pages> pages 133-148, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in <ref> [Kapur et al., 1990] </ref>. <p> Extensions of path orderings that do handle associative and commutative functions properly ([Bachmair and Plaisted, 1985], for example) have been proposed, most recently in <ref> [Kapur et al., 1990] </ref>. However, the ordering of [Kapur et al., 1990] is difficult to implement, because it requires many nondeterministic operations (like pseudocopying; see Section 6.2). 73 In this chapter, we show that if a rewrite system can be proved terminating using the recursive path ordering (RPO), then it is <p> Extensions of path orderings that do handle associative and commutative functions properly ([Bachmair and Plaisted, 1985], for example) have been proposed, most recently in <ref> [Kapur et al., 1990] </ref>. However, the ordering of [Kapur et al., 1990] is difficult to implement, because it requires many nondeterministic operations (like pseudocopying; see Section 6.2). 73 In this chapter, we show that if a rewrite system can be proved terminating using the recursive path ordering (RPO), then it is also AC-terminating|provided that when comparing two terms with <p> Case 4 of this definition uses the operation ), which may be one of the following: pseudo-copying, elevation or flattening. Here we briefly explain these notions; for details refer to <ref> [Kapur et al., 1990] </ref>. Pseudo-copying is used to allow a single big (that is, with a top-level function which is higher than f in the precedence relation f ) subterm on the left-hand side to handle multiple subterms on the right. <p> The essential idea in this ordering is to partition the subterms of the AC functions and compare the components, using ) to make the relation transitive. It is shown in <ref> [Kapur et al., 1990] </ref> that this ordering is well-founded and AC-compatible. We are ready for a proof of the theorem: Proof. We show that for any two terms s and t, if t bpc s then t ac s, by induction on the sizes of s and t. <p> The interesting point about bpc is that it is easy to implement; much easier than the ordering of <ref> [Kapur et al., 1990] </ref>. 6.3 Examples The binary path condition developed in the previous section, like ac , and unlike [Bachmair and Plaisted, 1985], has no restriction on the precedence relation f , and can therefore be used to prove termination of a large class of rewrite systems. 78 Example 17 <p> The restriction disallows comparison of two terms with equivalent top-level AC functions when both subterms on the right-hand side are dominated by only one subterm on the left-hand side. Independently, Bachmair [1992] presented an AC-compatible rewrite-relation, also based on <ref> [Kapur et al., 1990] </ref>, and proved its termination using a minimal counterexample argument. Our termination condition is essentially the same as one rewrite step of [Bachmair, 1992], with the possibility of multiset status added. <p> <ref> [Kapur et al., 1990] </ref>, and proved its termination using a minimal counterexample argument. Our termination condition is essentially the same as one rewrite step of [Bachmair, 1992], with the possibility of multiset status added. It is believed that the transitive closure of our relation is identical to the ordering in [Kapur et al., 1990], but this remains to be proved. It will be interesting to be able to extend the relation defined here to cases where simple multiset comparisons may be allowed for subterms of the AC-terms. <p> The binary path condition as a sufficient condition for AC-termination was presented in [Der-showitz and Mitra, 1992]. More recently, Rubio and Nieuwenhuis [1993] have extended the ordering of <ref> [Kapur et al., 1990] </ref> to one that is total on (non-AC equivalent) ground terms. However, one inconvenience with their ordering is that it orients the distributivity axiom (for example, x fl (y + z) = x fl y + x fl z) the "wrong" way. <p> However, one inconvenience with their ordering is that it orients the distributivity axiom (for example, x fl (y + z) = x fl y + x fl z) the "wrong" way. We believe that a lexicographic combination of BPC (or, for that matter, any other ordering, for example, <ref> [Kapur et al., 1990; Bachmair, 1992; Delor and Puel, 1993] </ref>, that orients distributivity the right way) together with the ordering of [Rubio and Nieuwenhuis, 1993] would solve the problem. 80 7 DECIDABLE EQUATION SOLVING The transformation systems described in Chapter 3 are complete for unification and matching in convergent rewrite systems.
Reference: [ Kapur and Zhang, 1987 ] <author> D. Kapur and H. Zhang. RRL: </author> <title> a rewrite rule laboratory, user's manual, </title> <year> 1987. </year>
Reference-contexts: The transcripts are taken using the software, SUTRA, which is a Common Lisp version of RRL (Rewrite Rule Laboratory) <ref> [Kapur and Zhang, 1987] </ref>. The parts of this system which interest us are: 1. Completion procedure for converting an equational system into a set of rewrite rules, 2. Special completion for theories with AC-functions, 3. Rewriting techniques for deriving the normal form of terms modulo a conditional theory, 4.
Reference: [ Kirchner, 1984 ] <author> C. Kirchner. </author> <title> A new equational unification method: a generalization of Martelli-Montanari's algorithm. </title> <booktitle> In Proceedings of the Seventh International Conference on Automated Deduction, </booktitle> <year> 1984. </year>
Reference-contexts: For completeness sake, we will also mention important results relating to unification in specific equational theories. We will express all the unification procedures in this thesis using transformation rules, as in <ref> [Martelli and Montanari, 1982; Kirchner, 1984] </ref>. 2.2.1 Narrowing Narrowing is complete for unification in convergent rewrite systems. The method uses (syntactic) unification (instead of matching) between the left-hand side of a rule and some subterm in one side of the goal.
Reference: [ Kirchner, 1986 ] <editor> C. Kirchner. </editor> <booktitle> Computing unification algorithms. In Proceedings of the first IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 206-216, </pages> <year> 1986. </year>
Reference-contexts: g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes <ref> [Siekmann, 1979; Kirchner, 1986] </ref> I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f )
Reference: [ Kirchner, 1989 ] <author> C. Kirchner. </author> <title> From unification in combination of equational theories to a new AC-unification algorithm. </title> <editor> In H. Ait-Kaci and M. Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures, </booktitle> <volume> Volume 2, </volume> <pages> pages 171-210, </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes <ref> [Stickel, 1981; Fages, 1984; Kirchner, 1989] </ref> A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g)
Reference: [ Klop, 1992 ] <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. M. Gabbay and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Volume 2, </volume> <pages> pages 1-117, </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: We also briefly recall important results about semantic unification. 2.1 Terminology In this section we describe and review basic notation, and indicate some important results that are needed in the remainder of this thesis. For surveys of rewrite systems refer to <ref> [Huet and Oppen, 1980; Dershowitz and Jouannaud, 1990; Klop, 1992] </ref>. Most of the notations that we use in this thesis have been borrowed from [Dershowitz and Jouannaud, 1990].
Reference: [ Kowalski, 1979 ] <author> R. A. Kowalski. </author> <title> Logic for problem solving. </title> <publisher> North Holland Publishing Company, </publisher> <year> 1979. </year> <month> 136 </month>
Reference-contexts: Logic programming is another programming methodology with similar features, which grew as an outcome of efforts to mechanize mathematical logic. See <ref> [Kowalski, 1979] </ref> for a survey on logic programming.
Reference: [ Lankford, 1979 ] <author> D. S. Lankford. </author> <title> On proving term rewriting systems are Noetherian. </title> <institution> Memo MTP-3, Mathematics Department, Louisiana Tech. University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: Polynomials can be used to prove termination of rewriting modulo AC when AC-equivalent terms have the same interpretation. But this severely restricts the degree of polynomial that can be used. (See <ref> [Lankford, 1979] </ref> and [Ben Cherifa and Lescanne, 1987].) Path orderings have been commonly used in theorem provers, even for AC-rewriting (see the discussion in [Bjorner, 1982, page 350]), despite the fact that they do not establish termination in the AC case (see the counterexamples in [Dershowitz et al., 1983]).
Reference: [ Lescanne, 1990 ] <author> P. Lescanne. </author> <title> On the recursive decomposition ordering with lexicographic status and other related orderings. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Volume 6, </volume> <pages> pages 39-49, </pages> <year> 1990. </year>
Reference: [ Lindstrom, 1985 ] <author> G. Lindstrom. </author> <title> Functional programming and the logical variable. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1985. </year>
Reference: [ Makanin, 1977 ] <author> G. S. Makanin. </author> <title> The problem of solvability of equations in a free semigroup, </title> <year> 1977. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity <ref> [Plotkin, 1972; Makanin, 1977] </ref>, associativity and com-mutativity [Stickel, 1981], and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] for surveys on unification. <p> (f (z; x); f (z; y)) D (f; g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes <ref> [Plotkin, 1972; Makanin, 1977] </ref> C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al.,
Reference: [ Martelli and Montanari, 1982 ] <author> A. Martelli and U. Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Volume 4, Number 2, </volume> <pages> pages 258-282, </pages> <year> 1982. </year>
Reference-contexts: For completeness sake, we will also mention important results relating to unification in specific equational theories. We will express all the unification procedures in this thesis using transformation rules, as in <ref> [Martelli and Montanari, 1982; Kirchner, 1984] </ref>. 2.2.1 Narrowing Narrowing is complete for unification in convergent rewrite systems. The method uses (syntactic) unification (instead of matching) between the left-hand side of a rule and some subterm in one side of the goal. <p> (y; z)) Dl (f; g) Left Distributivity f (z; g (x; y)) = g (f (z; x); f (z; y)) D (f; g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes <ref> [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] </ref> A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann
Reference: [ Martelli et al., 1989 ] <author> A. Martelli, G. F. Rossi and C. Moiso. </author> <title> Lazy unification algorithms for canonical rewrite systems. </title> <editor> In H. Ait-Kaci and M. Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures, </booktitle> <pages> pages 245-274, </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Martelli and Monta-nari [1982] used transformations on systems of equations to describe syntactic unification. The method was later adapted in <ref> [Martelli et al., 1989] </ref> to provide a complete unification procedure for convergent rewrite systems. Furthermore, Gallier and Snyder have used transformations for describing equational and higher-order unification [Gallier and Snyder, 1989; Snyder and Gallier, 1989], while Kirchner [1984] uses the technique for unification in syntactic theories. <p> Furthermore, Gallier and Snyder have used transformations for describing equational and higher-order unification [Gallier and Snyder, 1989; Snyder and Gallier, 1989], while Kirchner [1984] uses the technique for unification in syntactic theories. Our method is a variant of narrowing, based on the top-down approach outlined in <ref> [Martelli et al., 1989] </ref>. We achieve the effects of basic and normal narrowing in a lazy, top-down approach, and the introduction of directed goals (asymmetric goals, unlike the symmetric goals used, for example, by [Martelli et al., 1989]) removes problems of generating extraneous reducible solutions. <p> Our method is a variant of narrowing, based on the top-down approach outlined in <ref> [Martelli et al., 1989] </ref>. We achieve the effects of basic and normal narrowing in a lazy, top-down approach, and the introduction of directed goals (asymmetric goals, unlike the symmetric goals used, for example, by [Martelli et al., 1989]) removes problems of generating extraneous reducible solutions. <p> Another approach for semantic unification, therefore, attempts to look at terms in a top-down (or almost top-down) fashion. In this section we briefly discuss the top-down strategy due to <ref> [Martelli et al., 1989] </ref>. Martelli and others [1989] used an idea similar to syntactic unification to provide a system of transformation rules which is complete for unification with respect to convergent rewrite 16 systems. Their system of transformation rules appear in Table 2.2. <p> However, we noted that none of these methods is completely satisfactory, since they have to apply rules non-deterministically at all possible positions, most of the time. The top-down solution proposed by <ref> [Martelli et al., 1989] </ref> overcomes this difficulty, but has certain other problems of its own, since it uses goals in a symmetric manner. <p> Even when we use the approach outlined in <ref> [Martelli et al., 1989] </ref>, we have a similar problem: f (x) = g (x) ; Mutate (3:14) x ? ? ; f (x 0 ) = g (g (x 0 )); x 7! g (x 0 ) ? 39 However, if we were to use the procedure outlined in this thesis, <p> Furthermore, we only use basic positions for rule application, and have deterministic simplification to reduce branching in the solution tree. 47 Methods based on top-down decomposition are known to be complete for convergent sys-tems <ref> [Martelli et al., 1989] </ref>. However, in this case, a different problem occurs because they use symmetric goals, thus allowing mutation of subterms introduced through the left-hand sides of previous rule applications (see Example 3). <p> deterministically bind variables whenever they appear as the left-hand side of a directed goal. (See Section 10 of [Gallier and Snyder, 1989] for a discussion of the problems of proving completeness in presence of eager binding if symmetric goals are used.) Therefore, in essence, our method combines the advantages of <ref> [Martelli et al., 1989] </ref> and [Nutt et al., 1989] in a single unified framework. Gallier and Snyder [1989] have addressed a more general problem, that of unification in arbitrary equational theories, and, as a special case, they discuss the problem of unification in ground convergent rewrite systems.
Reference: [ Middeldorp and Hamoen, 1992 ] <author> A. Middledorp and E. Hamoen. </author> <title> Counterexamples to completeness results for basic narrowing. </title> <booktitle> In Proceedings of the Third International Conference on Algebraic and Logic Programming, Volterra, Italy, 1992. </booktitle> <volume> Volume 632, </volume> <pages> pages 244-258, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: For such systems, another refinement of narrowing, which uses a notion of basic positions (a proper subset of all available positions) for applying rules from R, was proposed in [Hullot, 1980]. Basic narrowing is complete for convergent systems, but not for systems that are confluent and non-terminating; see <ref> [Middeldorp and Hamoen, 1992] </ref> for a counterexample. Recently, narrowing based unification methods have been studied by way of their optimality. In general, unification in theories defined by convergent rewrite systems is an undecidable problem (see Chapter 7 for details), and therefore the usual notions of complexity cannot be used.
Reference: [ Mitra, 1990 ] <author> S. Mitra. </author> <title> Top-down equation solving and extensions to associative and commutative theories. </title> <type> Master's thesis, </type> <institution> Department of Computer and Information Sciences, University of Delaware, Newark, DE, </institution> <year> 1990. </year>
Reference: [ Mitra and Sivakumar, 1991 ] <author> S. Mitra and G. Sivakumar. </author> <title> AC-equation solving. </title> <booktitle> In Proceedings of the Eleventh International Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <address> New Delhi, India, </address> <booktitle> 1991. </booktitle> <volume> Volume 560, </volume> <pages> pages 40-56, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher> <pages> 137 </pages>
Reference-contexts: This method|of delaying AC-goals by abstracting and solving subgoals first|was initially presented in <ref> [Mitra and Sivakumar, 1991] </ref>. Notice that an extension of narrowing (using AC-unification and extended rules) would also provide a complete strategy for the semantic unification problem (see Section 3 of [Mitra and Sivakumar, 1991] for more details). <p> This method|of delaying AC-goals by abstracting and solving subgoals first|was initially presented in <ref> [Mitra and Sivakumar, 1991] </ref>. Notice that an extension of narrowing (using AC-unification and extended rules) would also provide a complete strategy for the semantic unification problem (see Section 3 of [Mitra and Sivakumar, 1991] for more details). In this section we provide an example to illustrate that the method outlined here performs better than the one based on narrowing. 70 In the method outlined in Section 5.2, we have simply "frozen" the AC-goals while we solve their corresponding subgoals.
Reference: [ Nipkow and Qian, 1991 ] <author> T. Nipkow and Z. Qian. </author> <title> Modular higher-order E-unification. </title> <booktitle> In Proceedings of the Fourth International Conference on Rewriting Techniques and Applications, Como, Italy, 1991. </booktitle> <volume> Volume 488, </volume> <pages> pages 200-214, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Some of the main advantages (pointed out in [Dougherty and Johann, 1992]) of using combinatory logic as the basis of higher-order unification (as opposed to the traditional lambda-calculus based methods such as <ref> [Snyder, 1990; Nipkow and Qian, 1991] </ref>, etc.) are: it eliminates some technical problems associated with bound variables, allows easy incorporation of type-variables, and facilitates the use of substitution like in the first-order case.
Reference: [ Nutt et al., 1989 ] <author> W. Nutt, P. Rety and G. Smolka. </author> <title> Basic narrowing revisited. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Volume 7, </volume> <pages> pages 295-317, </pages> <year> 1989. </year>
Reference-contexts: For convergent systems, narrowing and variants of it, such as normalized and basic narrowing (and a combination thereof, due to <ref> [Nutt et al., 1989] </ref>) are all complete strategies. However, we noted that none of these methods is completely satisfactory, since they have to apply rules non-deterministically at all possible positions, most of the time. <p> Let R be the convergent rewrite system given below: f (g (x)) ! f (x) (3.14) f (f (x)) ! f (x) (3.16) Consider the goal f (x) ? = g (x). Using normalized-narrowing (see <ref> [Nutt et al., 1989] </ref> for details), we would get: f (x) = g (x) ; Narrow (3:14) f (x 0 ) ? ; Normalize f (x 0 ) ? There are other ways to narrow the initial goal (we could either narrow f (x) using Rule 3.16, or narrow g (x) <p> appear as the left-hand side of a directed goal. (See Section 10 of [Gallier and Snyder, 1989] for a discussion of the problems of proving completeness in presence of eager binding if symmetric goals are used.) Therefore, in essence, our method combines the advantages of [Martelli et al., 1989] and <ref> [Nutt et al., 1989] </ref> in a single unified framework. Gallier and Snyder [1989] have addressed a more general problem, that of unification in arbitrary equational theories, and, as a special case, they discuss the problem of unification in ground convergent rewrite systems.
Reference: [ Paulson, 1991 ] <author> L. C. Paulson. </author> <title> ML for the working programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 INTRODUCTION 1.1 Motivation Functional programming (see [Henderson, 1980] for an introductory exposition), which originated from the study of the Lambda-Calculus, is a style of programming based on recursive function definitions. For example, in a typical functional programming language such as ML (see <ref> [Paulson, 1991] </ref> for the syntax), we could define append and reverse on lists as: val rec append = fn (x; y) ) if x = nil then y else hd x append (tl x; y); val rec reverse = fn (x) ) if x = nil then nil else append (reverse
Reference: [ Paterson and Wegman, 1978 ] <author> M. S. Paterson and M. N. Wegman. </author> <title> Linear unification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Volume 16, Number 2, </volume> <pages> pages 158-167, </pages> <year> 1978. </year>
Reference-contexts: (y; z)) Dl (f; g) Left Distributivity f (z; g (x; y)) = g (f (z; x); f (z; y)) D (f; g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes <ref> [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] </ref> A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann
Reference: [ Plotkin, 1972 ] <author> G. Plotkin. </author> <title> Building in equational theories. </title> <journal> Machine Intelligence, </journal> <volume> Volume 7, </volume> <pages> pages 73-90, </pages> <year> 1972. </year>
Reference-contexts: In order to have a refutationally complete deduction system in such cases, complete sets of unifiers (in the theories under consideration) are required, as shown in <ref> [Plotkin, 1972] </ref>. The simpler variant of the problem, semantic matching, where one side of the goal is a ground (variable free) term, is also of interest. <p> A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity <ref> [Plotkin, 1972; Makanin, 1977] </ref>, associativity and com-mutativity [Stickel, 1981], and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] for surveys on unification. <p> (f (z; x); f (z; y)) D (f; g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes <ref> [Plotkin, 1972; Makanin, 1977] </ref> C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al.,
Reference: [ Reddy, 1986 ] <author> U. S. Reddy. </author> <title> On the relationship between logic and functional languages. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 3-36, </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference: [ Rety, 1987 ] <author> P. Rety. </author> <title> Improving basic narrowing techniques. </title> <booktitle> In Proceedings of the Second International Conference on Rewriting Techniques and Applications, Bordeaux, France, 1987. </booktitle> <volume> Volume 256, </volume> <pages> pages 228-241, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Rety also uses a similar solution when he extends the concept of basic positions to weakly-basic position; see <ref> [Rety, 1987] </ref>. 3.3.2 Inductive Simplification In Section 3.3.1 we have shown that it is possible to use normalization and have a complete unification strategy. The main advantage of using simplification (normalization) during unification is to keep goals reduced, and even eliminate infinite branches (see Example 11).
Reference: [ Robinson, 1965 ] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> Volume 12, Number 1, </volume> <pages> pages 23-41, </pages> <year> 1965. </year>
Reference-contexts: (y; z)) Dl (f; g) Left Distributivity f (z; g (x; y)) = g (f (z; x); f (z; y)) D (f; g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes <ref> [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] </ref> A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann
Reference: [ Robinson and Wos, 1969 ] <author> G. A. Robinson and L. Wos. </author> <title> Paramodulation and theorem proving in first order theories with equality. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> Volume 4, </volume> <publisher> American Elsevier, </publisher> <address> New York, </address> <pages> pages 135-150, </pages> <year> 1969. </year>
Reference: [ Rubio and Nieuwenhuis, 1993 ] <author> A. Rubio and R. Nieuwenhuis. </author> <title> A precedence-based total AC-compatible ordering. </title> <booktitle> In Proceedings of the Fifth International Conference on Rewriting Techniques and Applications, Montreal, Canada, 1993. </booktitle> <volume> Volume 690, </volume> <pages> pages 374-388, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher> <pages> 138 </pages>
Reference-contexts: In this thesis, we develop a precedence-based binary relation for proving termination of extended rewriting, modulo associativity and commutativity. Our ordering was inspired by the one in [Kapur et al., 1990]. Similar research has been reported in [Bachmair and Plaisted, 1985; Bachmair, 1992], and recently in <ref> [Delor and Puel, 1993; Rubio and Nieuwenhuis, 1993] </ref>. 1.2 Outline of the Thesis In Chapter 2 we introduce most of the notations that we are going to use, and briefly provide some historical perspective on semantic unification. <p> We believe that a lexicographic combination of BPC (or, for that matter, any other ordering, for example, [Kapur et al., 1990; Bachmair, 1992; Delor and Puel, 1993], that orients distributivity the right way) together with the ordering of <ref> [Rubio and Nieuwenhuis, 1993] </ref> would solve the problem. 80 7 DECIDABLE EQUATION SOLVING The transformation systems described in Chapter 3 are complete for unification and matching in convergent rewrite systems. <p> Recently, Rubio and Nieuwenhuis [1993] have extended a similar ordering to one that is total on (non-AC equivalent) ground terms. However, their ordering orients the distributivity axiom the "wrong" way. It would be interesting to see if a combination of our ordering and the one proposed in <ref> [Rubio and Nieuwenhuis, 1993] </ref> would result in an AC ordering which has the advantages of both. 112 Another important problem, which has not been addressed in this thesis, is that of proving ground convergence.
Reference: [ Siekmann, 1979 ] <author> J. H. Siekmann. </author> <title> Unification of commutative terms. </title> <booktitle> In Proceedings of the Conference on Symbolic and Algebraic Manipulation, 1979. </booktitle> <volume> Volume 72, </volume> <pages> pages 531-545, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: g) Distributivity Dl (f; g) [ Dr (f; g) I (f ) Idempotence f (x; x) = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes <ref> [Siekmann, 1979; Kirchner, 1986] </ref> I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f )
Reference: [ Siekmann, 1989 ] <author> J. H. Siekmann. </author> <title> Unification theory. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Volume 7 (3 & 4), </volume> <pages> pages 207-274, </pages> <year> 1989. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity [Stickel, 1981], and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see <ref> [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] </ref> for surveys on unification. Here, we study the unification problem with respect to convergent systems, where some of the function symbols in the system additionally satisfy the equivalences of associativity and commutativity. <p> Almost all the material in this section has been adapted from [Jouannaud and Kirchner, 1991]. Other surveys of unification include <ref> [Siekmann, 1989; Baader and Siekmann, 1993] </ref>.
Reference: [ Siekmann and Szabo, 1984 ] <author> J. H. Siekmann and P. Szabo. </author> <title> Universal unification and classification of equational theories. </title> <booktitle> In Proceedings of the Seventh International Conference on Automated Deduction, 1984. </booktitle> <volume> Volume 170, </volume> <pages> pages 1-42, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes [Stickel, 1981; Fages, 1984; Kirchner, 1989] A (f ),I (f ) yes <ref> [Siekmann and Szabo, 1984; Baader, 1986] </ref> C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g) yes [Arnborg and Tiden, 1985] D (f; g),A (f ) no Szabo
Reference: [ Sivakumar, 1989 ] <author> G. Sivakumar. </author> <title> Proofs and computations in conditional equational theories. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1989. </year>
Reference-contexts: Like in the case of unconditional equational theories we can talk of rewrite rules derived from conditional equations. Furthermore, similar concepts like ordering, termination and confluence also carry over to the case of conditional theories. For a detailed survey of conditional rewrite systems refer to <ref> [Sivakumar, 1989] </ref>. Conditional rules are also very important in equational programming. The rule x &gt; 0 = true : factorial (x) ! x fl factorial (x 1) has only one premise in the condition.
Reference: [ Snyder, 1990 ] <author> W. Snyder. </author> <title> Higher-order E-unification. </title> <booktitle> In Proceedings of the Tenth International Conference on Automated Deduction, Kaiserslautern, FRG, 1990. </booktitle> <volume> Volume 449, </volume> <pages> pages 573-587, </pages> <booktitle> of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: Some of the main advantages (pointed out in [Dougherty and Johann, 1992]) of using combinatory logic as the basis of higher-order unification (as opposed to the traditional lambda-calculus based methods such as <ref> [Snyder, 1990; Nipkow and Qian, 1991] </ref>, etc.) are: it eliminates some technical problems associated with bound variables, allows easy incorporation of type-variables, and facilitates the use of substitution like in the first-order case.
Reference: [ Snyder, 1991 ] <author> W. Snyder. </author> <title> A proof theory for general E-unification. </title> <booktitle> Volume 11, Progress in Computer Science and Applied Logic, </booktitle> <publisher> Birkhauser, </publisher> <year> 1991. </year>
Reference-contexts: : : : ; t n ) ; Imitate' x ! ? y ; Var-Param x ! ? y ; where f (l 1 ; : : : ; l n ) ! r is a renamed rule in R Table 8.2: Transformation rules for satisfiability of ! ? of <ref> [Gallier and Snyder, 1989; Snyder, 1991] </ref>, since, in our system, we would get E-unification if we used both variants (l ! r and r ! l) of every equation l = r 2 E.
Reference: [ Snyder and Gallier, 1989 ] <author> W. Snyder and J. Gallier. </author> <title> Higher-order unification revisited: complete sets of transformations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> Volume 8, </volume> <pages> pages 101-140, </pages> <year> 1989. </year>
Reference-contexts: Martelli and Monta-nari [1982] used transformations on systems of equations to describe syntactic unification. The method was later adapted in [Martelli et al., 1989] to provide a complete unification procedure for convergent rewrite systems. Furthermore, Gallier and Snyder have used transformations for describing equational and higher-order unification <ref> [Gallier and Snyder, 1989; Snyder and Gallier, 1989] </ref>, while Kirchner [1984] uses the technique for unification in syntactic theories. Our method is a variant of narrowing, based on the top-down approach outlined in [Martelli et al., 1989].
Reference: [ Socher-Ambrosius, 1993 ] <author> R. Socher-Ambrosius. </author> <title> Unification of terms with exponents. </title> <type> Technical Report, </type> <institution> MPI-I-93-217, Max-Plank Institute fur Informatik, </institution> <year> 1993. </year>
Reference-contexts: Therefore, whenever we have multiple such subgoals to solve, we have to find the language in the intersection of two such recurrent schemata, which can be done, using a result from <ref> [Socher-Ambrosius, 1993] </ref>, which itself is an extension of a theorem from [Comon, 1992] (see discussion after Example 35). Example 34. <p> Therefore, in solving a constraint of the form x = y, where both x and y could be bound to such term patterns, we have to "unify" these patterns. These patterns are exactly the ones considered in <ref> [Socher-Ambrosius, 1993, Section 4] </ref>. In fact, our patterns are slightly simpler than the ones handled by [Socher-Ambrosius, 1993], because we have terms which could be iterated along a single path alone, and additionally, all the variables|flexible-variables in their terminology| 106 are linear in our case. <p> These patterns are exactly the ones considered in [Socher-Ambrosius, 1993, Section 4]. In fact, our patterns are slightly simpler than the ones handled by <ref> [Socher-Ambrosius, 1993] </ref>, because we have terms which could be iterated along a single path alone, and additionally, all the variables|flexible-variables in their terminology| 106 are linear in our case. The claim in Section 4 of [Socher-Ambrosius, 1993] is that the unification algorithm is terminating in the general case (that is, even <p> In fact, our patterns are slightly simpler than the ones handled by <ref> [Socher-Ambrosius, 1993] </ref>, because we have terms which could be iterated along a single path alone, and additionally, all the variables|flexible-variables in their terminology| 106 are linear in our case. The claim in Section 4 of [Socher-Ambrosius, 1993] is that the unification algorithm is terminating in the general case (that is, even with non-linear flexible variables) using the same proof which is sketched in Section 3 (for a similar system without flexible variables) of [Socher-Ambrosius, 1993]. <p> The claim in Section 4 of <ref> [Socher-Ambrosius, 1993] </ref> is that the unification algorithm is terminating in the general case (that is, even with non-linear flexible variables) using the same proof which is sketched in Section 3 (for a similar system without flexible variables) of [Socher-Ambrosius, 1993]. <p> The requirement that every rule should be left- and right-linear for Theorem 28 seems to be overly restrictive. It may be possible to use a different language (or even an extension of the one in <ref> [Socher-Ambrosius, 1993] </ref>) to relax these restrictions. However, for decidability, the restriction that each function symbol may have at most one rule with a flat right-hand side is necessary: Lemma 30. <p> Before our work, almost no such characterization was known for decidable matching problems, and the ones for unification were very restrictive. At the end of Section 7.3 we mentioned a problem about a result from <ref> [Socher-Ambrosius, 1993] </ref>. We believe that a correct proof of termination of the unification procedure mentioned therein would help generalize decidability results for systems with flat right-hand sides (by allowing non-linear variables in rules).
Reference: [ Stickel, 1981 ] <author> M. E. Stickel. </author> <title> A unification algorithm for associative-commutative functions. </title> <journal> JACM, </journal> <volume> Volume 28, </volume> <pages> pages 423-434, </pages> <year> 1981. </year>
Reference-contexts: A number of researchers have addressed the problem of unification in specific equational theories, for example, associativity [Plotkin, 1972; Makanin, 1977], associativity and com-mutativity <ref> [Stickel, 1981] </ref>, and different variants of distributivity [Arnborg and Tiden, 1985; Contejean, 1992]; see [Siekmann, 1989; Jouannaud and Kirchner, 1991; Baader and Siekmann, 1993] for surveys on unification. <p> AC-unification is a costly operation and, in general, it produces a finite complete basis set of unifiers <ref> [Stickel, 1981] </ref>, which could potentially be very large. 9 An equation is an unordered pair of terms written in the form s = t, where either or both of s and t may contain variables, which are understood as being universally quantified. <p> = x Table 2.5: Common equational axioms Name Decidable Some References yes [Robinson, 1965; Paterson and Wegman, 1978; Martelli and Montanari, 1982] A (f ) yes [Plotkin, 1972; Makanin, 1977] C (f ) yes [Siekmann, 1979; Kirchner, 1986] I (f ) yes [Hullot, 1980] A (f ),C (f ) yes <ref> [Stickel, 1981; Fages, 1984; Kirchner, 1989] </ref> A (f ),I (f ) yes [Siekmann and Szabo, 1984; Baader, 1986] C (f ),I (f ) yes [Jouannaud et al., 1983] A (f ),C (f ),I (f ) yes [Baader and Buttner, 1988] Dr (f; g) yes [Arnborg and Tiden, 1985] Dl (f; g)
Reference: [ Subrahmanyam and You, 1986 ] <author> P. A. Subrahmanyam and J.-H. You. Funlog: </author> <title> a computational model integrating logic programming and functional programming. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 157-200, </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year> <month> 139 </month>

References-found: 101

