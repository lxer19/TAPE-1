URL: ftp://theory.lcs.mit.edu/pub/people/oded/bgg-ip.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/complexity.html
Root-URL: 
Email: e-mail: mihir@watson.ibm.com.  e-mail: oded@cs.technion.ac.il.  e-mail: shafi@theory.lcs.mit.edu.  
Title: Randomness in Interactive Proofs  
Author: Mihir Bellare Oded Goldreich Shafi Goldwasser 
Keyword: Interactive proof systems, Arthur-Merlin games, randomness, sampling methods, error reduction, expander graphs, pairwise independent random variables.  
Note: Work done while author was at MIT supported in part by NSF grant No. CCR-8719689 and DARPA grant No. N00014-89-J-1988.  Partially supported by grants No. 86-00301 and 89-00312 from the United States Israel Binational Science Foundation (BSF).  Supported in part by NSF grant No. CCR-8657527, DARPA grant No. DAAL03-86-K-0171 and grants No. 86-00301 and 89-00312 from the United States Israel Binational Science Foundation (BSF).  
Address: PO Box 704, Yorktown Heights, NY 10598.  Israel.  545 Technology Square, Cambridge, MA 02139.  
Affiliation: IBM T.J. Watson Research Center,  Computer Science Department, Technion, Haifa,  MIT Laboratory for Computer Science,  
Date: (August 24, 1991)  
Abstract: A Preliminary version of this paper appeared in Proceedings of the 31st Annual IEEE Symposium Abstract This paper initiates a study of the quantitative aspects of randomness in interactive proofs. Our main result, which applies to the equivalent form of IP known as Arthur-Merlin (AM) games, is a randomness-efficient technique for decreasing the error probability. Given an AM proof system for L which achieves error probability 1=3 at the cost of Arthur sending l(n) random bits per round, and given a polynomial k = k(n), we show how to construct an AM proof system for L which, in the same number of rounds as the original proof system, achieves error 2 k(n) at the cost of Arthur sending only O(l + k) random bits per round. Underlying the transformation is a novel sampling method for approximating the average value of an arbitrary function f : f0; 1g l ! [0; 1]. The method evaluates the function on O(* 2 log ffi 1 ) sample points generated using only O(l + log ffi 1 ) coin tosses to get an estimate which with probability 1 ffi is within * of the average value of the function. on the Foundations of Computer Science, IEEE (1990).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman. </author> <title> Two Theorems on Random Polynomial Time. </title> <booktitle> Proceedings of the 19th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1978). </booktitle>
Reference-contexts: In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [11] and BPP is contained in non-uniform P <ref> [1] </ref>. The IP counterpart of the first was open for several years and finally proved in [42], while the IP analogue of the second (i.e. IP is contained in non-uniform NP) is not believed to be true. 1.4 Techniques Our result involves a novel techniques for randomness-efficient sampling. <p> More specifically, we consider the task of estimating the average value E [f ] def x2f0;1g l f (x) of a given function f : f0; 1g l ! <ref> [0; 1] </ref>. Our interest is in primitives for this task which we call (l; *; ffi)-approximators. An (l; *; ffi)-approximator is a two stage process. <p> Our technique is optimal in the number of sample points, and, amongst the techniques that use this number of sample points, optimal in the number of coin tosses (both up to constant factors). It works for all functions f : f0; 1g l ! <ref> [0; 1] </ref>. The tools we rely on are low independence distributions and random walks on explicitly constructed expander graphs. <p> It is interesting to note that (l; 1=6; ffi)-approximators for Boolean functions would suffice for error-reduction in BPP whereas our error-reduction for IP relies on (l; *; ffi)-approximators of arbitrary functions ranging in <ref> [0; 1] </ref> with * 1 being a polynomial. 1.5 Related Work and Avenues for Further Investigation Bellare and Rompel [10] have investigated the randomness complexity of the operation of reducing the number of rounds of an AM game by one-half. <p> The error probability of A on input w with respect to a language L is defined as err L ( acc A (w) otherwise. The error probability of A with respect to L is the map from N ! <ref> [0; 1] </ref> whose value at n is sup jwj=n err L A (w). <p> Let c be &gt; 0 and let A = (; G; l; q; s) be an Arthur strategy with error probability 1 2 n c with respect to the language L. Let *: N ! <ref> [0; 1] </ref> have polynomially bounded inverse. Then we can construct another Arthur strategy A fl = ( fl ; G; ffl; G 3 A n 2c * 1 q; s) with error probability * with respect to L. <p> For each i = 1; : : :; m define X i : f0; 1g c P l ! <ref> [0; 1] </ref> by X i (s) = acc A (w; r i 1 : : : r i t1 :P (1 l ; i; s)). <p> This concludes the proof of Theorem 5.1. 6 Randomness-Efficient Approximation Implicit in the previous sections is a new sampling method. An application of particular interest is to the problem of approximating the average value of an arbitrary real valued function. 6.1 Definitions For f : f0; 1g n ! <ref> [0; 1] </ref> we let E [f ] = 2 n P x2f0;1g n f (x) denote the average value of f . An (l; *; ffi)-approximator is a two stage process. <p> If F n is for each integer n a set of functions mapping f0; 1g n to <ref> [0; 1] </ref> then we will refer to F = fF n g as a class of functions. We can now say what is an (l; *; ffi)-approximator for a class of functions F . Definition 6.3 Let l: N ! N and *; ffi: N ! [0; 1]. <p> f0; 1g n to <ref> [0; 1] </ref> then we will refer to F = fF n g as a class of functions. We can now say what is an (l; *; ffi)-approximator for a class of functions F . Definition 6.3 Let l: N ! N and *; ffi: N ! [0; 1]. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as <p> Definition 6.3 Let l: N ! N and *; ffi: N ! <ref> [0; 1] </ref>. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as a random variable over the uniform distribution on f0; 1g (n) . <p> N and *; ffi: N ! <ref> [0; 1] </ref>. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as a random variable over the uniform distribution on f0; 1g (n) . <p> Let us now proceed to our theorem. Theorem 6.5 Let l: N ! N and *; ffi: N ! <ref> [0; 1] </ref> with l; * 1 and lg ffi 1 polynomially bounded and polynomial time computable. Then there exists an (l; *; ffi)-approximator for all functions which uses O (* 2 log ffi 1 ) sample points and O (l + log ffi 1 ) coin tosses. <p> For the analysis, fix f : f0; 1g l ! <ref> [0; 1] </ref>. Call a seed s 2 f0; 1g c P l bad if fi fi fi t i=1 fi fi fi where r i = P (1 n ; i; s) for i = 1; : : :; m.
Reference: [2] <author> W. Aiello, S. Goldwasser and J. H -astad. </author> <title> On the Power of Interaction. </title> <type> Combinatorica 10(1), </type> <month> 3-25 </month> <year> (1990). </year>
Reference-contexts: So the real question lies in understanding what happens in between these extremes. In this regard the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of 3 randomness in interactive proofs. <p> Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Much attention has been devoted to understanding the hierarchy AM = IP = c0 AM [n c ]. We now briefly review what is known. Babai [5] showed that any constant number of rounds is equivalent to two: AM [k] = AM <ref> [2] </ref> for any integer k 2. Probably the most interesting positive result to date however is that of Babai and Moran [6] who showed that the number of rounds in an Arthur-Merlin game can always be cut 4 in half. <p> Whether or not AM = AM <ref> [2] </ref> remains an open question. Boppana, H-astad and Zachos [15] provide some indication that co-NP does not have constant round interactive proofs by showing that if it did then the polynomial time hierarchy would collapse to the second level. Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 <p> Whether or not AM = AM <ref> [2] </ref> remains an open question. Boppana, H-astad and Zachos [15] provide some indication that co-NP does not have constant round interactive proofs by showing that if it did then the polynomial time hierarchy would collapse to the second level. Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of [40, 45] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [33, 20]. <p> However, we note that the results of [40, 45] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [33, 20]. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of <ref> [2] </ref>. 1.2 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense. The specific problem we consider is that of reducing the error probability of an Arthur-Merlin game in a randomness-efficient manner.
Reference: [3] <author> M. Ajtai, J. Komlos and E. Szemeredi. </author> <title> Deterministic Simulation in Logspace. </title> <booktitle> Proceedings of the 19th Annual ACM Symposium on the Theory of Computing, ACM (1987). </booktitle>
Reference-contexts: Cohen and Wigderson [21] and Impagliazzo and Zuckermann [37], using techniques of Ajtai, Komlos and Szemeredi <ref> [3] </ref>, showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations. <p> Furthermore, techniques based on assumptions of computational difficulty are of no use against a prover who has the power to invert one-way functions. Thus the verifier cannot use pseudo-random sequences in place of random ones. We note however that our construction will exploit techniques from [19] and <ref> [3] </ref> but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [11] and BPP is contained in non-uniform P [1]. <p> Then P [Y j 1 2 B j 1 ; : : :; Y j b 2 B j b ] (2*) b=2 . We call the expansion constant of G; it depends only on the second eigenvalue of G. A proof of Lemma 5.7, following the ideas of <ref> [3] </ref>, appears in Appendix A. <p> A somewhat coarser kind of approximation to the average of a boolean functions f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 21, 37] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi. <p> Namely, a BPP algorithm which has error 1 3 with respect to L and uses r = r (n) coins can be transformed into one which has error 2 k and uses O (r + k) coins <ref> [3, 21, 37] </ref>. * Can our result be generalized to (general) interactive proof systems? We don't know of any direct non-trivial error-reduction technique for general interactive proof systems.
Reference: [4] <author> N. Alon. </author> <title> Eigenvalues and Expanders. </title> <type> Combinatorica 6(2), </type> <month> 83-96 </month> <year> (1986). </year>
Reference-contexts: Gabber and Galil [24] demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [24] to achieve this; via Alon's result <ref> [4] </ref> we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [24] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2.
Reference: [5] <author> L. Babai. </author> <title> Trading Group Theory for Randomness. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. First indications to such potential were presented by Babai <ref> [5] </ref> and Goldreich, Micali and Wigderson [30]. But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. And here the truth was startling: interactive proofs exist for any language which can be recognized in polynomial space (cf. <p> So the real question lies in understanding what happens in between these extremes. In this regard the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of 3 randomness in interactive proofs. <p> This error probability can be decreased to 2 k (n) for any polynomial k (n) by standard techniques. Let IP denote the class of languages that possess interactive proofs. Arthur-Merlin (AM) games, introduced by Babai <ref> [5] </ref> (see also Babai and Moran [6]), can be viewed as special kinds of interactive proof systems; they are sometimes called interactive proof systems with public coins. Merlin is the prover and Arthur the verifier. <p> Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. Much attention has been devoted to understanding the hierarchy AM = IP = c0 AM [n c ]. We now briefly review what is known. Babai <ref> [5] </ref> showed that any constant number of rounds is equivalent to two: AM [k] = AM [2] for any integer k 2. <p> It is well known that this error probability can be decreased to 2 k for any polynomially bounded k = k (n) by running the game O (k) times in parallel and taking a majority vote on the outcomes <ref> [5, 6] </ref>. Note that this maintains the number of rounds. Supposing that Arthur sent l = l (n) random bits per round in the original game, this results in a game in each round of which Arthur sends O (lk) random bits. <p> A specific question is to find a randomness-efficient technique of reducing the error probability of a zero-knowledge proof. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai <ref> [5] </ref> and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game has two players called Merlin and Arthur. <p> As we said above, it actually suffices to consider an "optimal Merlin" that chooses all its messages in a way maximizing Arthur's accepting probability. This leads to the much more convenient formulation of Arthur-Merlin games in terms of max-average combinatorial games as developed by <ref> [5, 6] </ref>. We capture this formulation below with the definition of the accepting probability function of the game. Note that the optimal Merlin strategy depends on the Arthur strategy A. <p> For any Arthur strategy A we fix a particular optimal Merlin strategy which we denote by M opt A . 2.3 The Accepting Probability Function The game tree and its accepting probability function which we now describe are a convenient way of analyzing an Arthur Merlin game (cf. <ref> [5, 6] </ref>). Fix an input length n. We visualize a tree of depth equal to the number of moves 2g (n). Nodes in this tree are named according to their level: those at even levels are called Arthur nodes while those at odd levels are called Merlin nodes. <p> As an introduction to our error-reduction technique it is helpful to review the standard one <ref> [5, 6] </ref>. 3.1 The Standard Error-Reduction Technique Given A = (; g; l; q) defining an Arthur-Merlin proof system for L with error 1=3 we are required to design A fl defining an error 2 k Arthur-Merlin proof system for L. <p> This continues for g rounds (see Figure 1). Finally, A fl will accept in the new game iff a majority of the subgames were accepting for the original A. The result is Theorem 3.1 <ref> [5, 6] </ref> There is a constant ff such that the following is true. Let A = (; g; l; q; s) be an Arthur strategy which has error 1=3 with respect to L. Let k: N ! N be polynomially bounded and polynomial time computable. Let m = ffk.
Reference: [6] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes. </title> <journal> J. Computer and System Sciences 36, </journal> <month> 254-276 </month> <year> (1988). </year>
Reference-contexts: So the real question lies in understanding what happens in between these extremes. In this regard the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of 3 randomness in interactive proofs. <p> This error probability can be decreased to 2 k (n) for any polynomial k (n) by standard techniques. Let IP denote the class of languages that possess interactive proofs. Arthur-Merlin (AM) games, introduced by Babai [5] (see also Babai and Moran <ref> [6] </ref>), can be viewed as special kinds of interactive proof systems; they are sometimes called interactive proof systems with public coins. Merlin is the prover and Arthur the verifier. Merlin plays just like a prover in an interactive proof system; the specialty is in the role of Arthur. <p> Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> We now briefly review what is known. Babai [5] showed that any constant number of rounds is equivalent to two: AM [k] = AM [2] for any integer k 2. Probably the most interesting positive result to date however is that of Babai and Moran <ref> [6] </ref> who showed that the number of rounds in an Arthur-Merlin game can always be cut 4 in half. That is, AM [2g (n)] = AM [g (n)] for any polynomial g (n). <p> That is, AM [2g (n)] = AM [g (n)] for any polynomial g (n). It is important to note that in constructing a g (n) round Arthur-Merlin proof system for L from a 2g (n) round one the proof of <ref> [6] </ref> blows up the message lengths of both parties by polynomial factors, and thus we cannot iterate the collapse more than a constant number of times. Whether or not AM = AM [2] remains an open question. <p> It is well known that this error probability can be decreased to 2 k for any polynomially bounded k = k (n) by running the game O (k) times in parallel and taking a majority vote on the outcomes <ref> [5, 6] </ref>. Note that this maintains the number of rounds. Supposing that Arthur sent l = l (n) random bits per round in the original game, this results in a game in each round of which Arthur sends O (lk) random bits. <p> This improves on the construction of <ref> [6] </ref> in which Arthur sent O (lqg 3 log g) random bits per round in the g (n) round game. We looked at how the power of IP varies with the amount of randomness. <p> A specific question is to find a randomness-efficient technique of reducing the error probability of a zero-knowledge proof. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran <ref> [6] </ref>, introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game has two players called Merlin and Arthur. <p> As we said above, it actually suffices to consider an "optimal Merlin" that chooses all its messages in a way maximizing Arthur's accepting probability. This leads to the much more convenient formulation of Arthur-Merlin games in terms of max-average combinatorial games as developed by <ref> [5, 6] </ref>. We capture this formulation below with the definition of the accepting probability function of the game. Note that the optimal Merlin strategy depends on the Arthur strategy A. <p> For any Arthur strategy A we fix a particular optimal Merlin strategy which we denote by M opt A . 2.3 The Accepting Probability Function The game tree and its accepting probability function which we now describe are a convenient way of analyzing an Arthur Merlin game (cf. <ref> [5, 6] </ref>). Fix an input length n. We visualize a tree of depth equal to the number of moves 2g (n). Nodes in this tree are named according to their level: those at even levels are called Arthur nodes while those at odd levels are called Merlin nodes. <p> More formally, we have the following definition of the accepting probability function for an Arthur strategy A = (; g; l; q; 1). This is a variation of what <ref> [6] </ref> call the payoff function. * The value at a conversation (leaf of the tree) is the value of A's deciding predicate: acc A (w; r 1 y 1 : : : r g y g ) = (w; r 1 y 1 : : : r g y g ) <p> As an introduction to our error-reduction technique it is helpful to review the standard one <ref> [5, 6] </ref>. 3.1 The Standard Error-Reduction Technique Given A = (; g; l; q) defining an Arthur-Merlin proof system for L with error 1=3 we are required to design A fl defining an error 2 k Arthur-Merlin proof system for L. <p> This continues for g rounds (see Figure 1). Finally, A fl will accept in the new game iff a majority of the subgames were accepting for the original A. The result is Theorem 3.1 <ref> [5, 6] </ref> There is a constant ff such that the following is true. Let A = (; g; l; q; s) be an Arthur strategy which has error 1=3 with respect to L. Let k: N ! N be polynomially bounded and polynomial time computable. Let m = ffk.
Reference: [7] <author> L. Babai and S. Moran. </author> <title> Proving Properties of Interactive Proofs by a Generalized Counting Technique. </title> <booktitle> Information and Computation 82, </booktitle> <month> 185-197 </month> <year> (1989). </year>
Reference-contexts: So the real question lies in understanding what happens in between these extremes. In this regard the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of 3 randomness in interactive proofs.
Reference: [8] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> Perfect Zero-Knowledge in Constant Rounds. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [9] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> The True Complexity of Statistical Zero-Knowledge. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [10] <author> M. Bellare and J. Rompel. </author> <title> Randomness-Efficient Sampling of Arbitrary Functions. </title> <type> MIT LCS Tech. </type> <note> Memo. TM-433. </note>
Reference-contexts: Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> This requires O (tl) coin tosses and m function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [19, 10, 21, 37, 41] </ref> that save coins over the standard method suffer from various restrictions (see x6 for details). <p> interesting to note that (l; 1=6; ffi)-approximators for Boolean functions would suffice for error-reduction in BPP whereas our error-reduction for IP relies on (l; *; ffi)-approximators of arbitrary functions ranging in [0; 1] with * 1 being a polynomial. 1.5 Related Work and Avenues for Further Investigation Bellare and Rompel <ref> [10] </ref> have investigated the randomness complexity of the operation of reducing the number of rounds of an AM game by one-half. <p> For the purpose of the discussion that follows it is helpful to have the following Definition 6.4 <ref> [10] </ref> An (l; *; ffi)-approximator (S; E) is called oblivious if E (1 n ; (x 1 ; : : : ; x t (n) )) = t (n) i=1 for all n and (x 1 ; : : : ; x t (n) ) 2 R l (n) , where <p> Obliviousness is useful in some applications (cf. <ref> [10] </ref>). 23 6.2 Approximation Methods The standard approximation method is to select t = O (* 2 log ffi 1 ) independent and uniformly distributed sample points and use as estimate the average value of the function on these sample points. <p> Using higher independence and an iterated sampling technique, Bellare and Rompel <ref> [10] </ref> are able to remove this restriction.
Reference: [11] <author> C. Bennet and J. Gill. </author> <title> Relative to a random Oracle A, P A 6= NP A 6= coNP A , with probability 1. </title> <journal> SIAM J. on Computing 10, </journal> <month> 96-113 </month> <year> (1981). </year>
Reference-contexts: We note however that our construction will exploit techniques from [19] and [3] but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P <ref> [11] </ref> and BPP is contained in non-uniform P [1]. The IP counterpart of the first was open for several years and finally proved in [42], while the IP analogue of the second (i.e.
Reference: [12] <author> M. Blum, A. De Santis, S. Micali and G. Persiano. </author> <title> Non-Interactive Zero-Knowledge. </title> <type> MIT LCS Tech. </type> <note> Memo. TM-430.b. </note>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [13] <author> M. Blum, P. Feldman and S. Micali. </author> <title> Non-Interactive Zero-Knowledge and its Applications. </title> <booktitle> Proceedings of the 20th Annual ACM Symposium on the Theory of Computing, ACM (1988). </booktitle>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [14] <author> M. Blum and S. Micali. </author> <title> How to Generate Cryptographically Strong Sequences of Pseudo-Random Bits. </title> <note> SIAM Journal on Computing 13 (4), </note> <month> 850-864 </month> <year> (1984). </year>
Reference-contexts: Cohen and Wigderson [21] and Impagliazzo and Zuckermann [37], using techniques of Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). Furthermore, pseudo-random sequences <ref> [14, 48] </ref> can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c.
Reference: [15] <author> R. Boppana, J. Hastad and S. Zachos. </author> <title> Does coNP have Short Interactive Proofs? Info. </title> <journal> Processing Letters 25, </journal> <month> 127-132 </month> <year> (1987). </year>
Reference-contexts: So the real question lies in understanding what happens in between these extremes. In this regard the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of 3 randomness in interactive proofs. <p> Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Whether or not AM = AM [2] remains an open question. Boppana, H-astad and Zachos <ref> [15] </ref> provide some indication that co-NP does not have constant round interactive proofs by showing that if it did then the polynomial time hierarchy would collapse to the second level.
Reference: [16] <author> G. Brassard, C. Cr epeau and M. Yung. </author> <title> Everything in NP can be Argued in Perfect Zero-Knowledge in a Constant Number of Rounds. </title> <booktitle> Proceedings of ICALP 89 </booktitle> . 
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [17] <author> R. Canetti, G. Even and O. Goldreich. </author> <title> Lower bounds for sampling algorithms for estimating the average. </title> <institution> TR-686, Computer Science Dept., Technion, Haifa, Israel, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Namely, any (l; *; ffi)-approximator (even for just the class of boolean functions) must use (* 2 log ffi 1 ) sample points (cf. <ref> [17] </ref>). Furthermore, among methods using the optimal number of sample points, our method is nearly optimal in the number of coin tosses used (for a wide range of natural choices for the parameters). <p> Namely, any (l; *; ffi)-approximator (even for boolean functions) which uses O (* 2 log ffi 1 ) sample points must use at least l + lg ffi 1 lg * 2 O (1) coin tosses (cf. <ref> [17] </ref> and consider ffi &lt; * !(1) ). Let us now proceed to our theorem. Theorem 6.5 Let l: N ! N and *; ffi: N ! [0; 1] with l; * 1 and lg ffi 1 polynomially bounded and polynomial time computable.
Reference: [18] <author> L. Carter and M. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> J. Computer and System Sciences 18, </journal> <month> 143-154 </month> <year> (1979). </year>
Reference-contexts: a O (l) bit string s and, in time polynomial in l and m, specify a sequence of m 2 l strings of l bits each with the property that if s is chosen at random then the resulting sequence is pairwise independent and uniform over f0; 1g l (cf. <ref> [18] </ref>). Accordingly, we make the following Definition 4.4 Let P (; ; ) be a polynomial time algorithm which outputs strings of length equal to the length of its first input.
Reference: [19] <author> B. Chor and O. Goldreich. </author> <title> On the Power of Two-Point Based Sampling. </title> <editor> J. </editor> <booktitle> of Complexity 5, </booktitle> <month> 96-106 </month> <year> (1989). </year>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [47] and Santha [43]. The first constructions were obtained by Karp, Pippinger and Sipser [38] and Chor and Goldreich <ref> [19] </ref> who showed that the error-probability of a BPP algorithm which used r = r (n) coin tosses could be reduced to n c for any given constant c while using only O (r) coin tosses. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations. <p> Furthermore, techniques based on assumptions of computational difficulty are of no use against a prover who has the power to invert one-way functions. Thus the verifier cannot use pseudo-random sequences in place of random ones. We note however that our construction will exploit techniques from <ref> [19] </ref> and [3] but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [11] and BPP is contained in non-uniform P [1]. <p> This requires O (tl) coin tosses and m function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [19, 10, 21, 37, 41] </ref> that save coins over the standard method suffer from various restrictions (see x6 for details). <p> For completeness, let us sketch two implementations. The first implementation <ref> [19] </ref> uses finite fields. We identify the sets f0; 1g l and [2 l ] with GF (2 l ). <p> Chor and Goldreich <ref> [19] </ref>). The cost is in the number of sample points which now grows in proportion to ffi 1 rather than the lg ffi 1 of the standard method; if we want the number of sample points to be polynomial in n then we cannot attain exponentially small (in n) error.
Reference: [20] <author> B. Chor, O. Goldreich and J. Hastad. </author> <title> The Random Oracle Hypothesis is False. </title> <institution> TR-631, Computer Science Dept., Technion, Haifa, Israel, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: However, we note that the results of [40, 45] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them <ref> [33, 20] </ref>. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of [2]. 1.2 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense.
Reference: [21] <author> A. Cohen and A. Wigderson. Dispersers, </author> <title> Deterministic Amplification, and Weak Random Sources. </title> <booktitle> Proceedings of the 30th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1989). </booktitle>
Reference-contexts: Cohen and Wigderson <ref> [21] </ref> and Impagliazzo and Zuckermann [37], using techniques of Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Furthermore, pseudo-random sequences [14, 48] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of <ref> [21, 37] </ref> and [36, 34] we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant *. Error-reduction for AM games, however, seems more difficult to handle. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations. <p> This requires O (tl) coin tosses and m function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [19, 10, 21, 37, 41] </ref> that save coins over the standard method suffer from various restrictions (see x6 for details). <p> A somewhat coarser kind of approximation to the average of a boolean functions f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 21, 37] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi. <p> Namely, a BPP algorithm which has error 1 3 with respect to L and uses r = r (n) coins can be transformed into one which has error 2 k and uses O (r + k) coins <ref> [3, 21, 37] </ref>. * Can our result be generalized to (general) interactive proof systems? We don't know of any direct non-trivial error-reduction technique for general interactive proof systems. <p> A BPP algorithm which has error 1 3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [38] described in <ref> [21] </ref>) and one can then apply [21, 37] to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research, and Silvio Micali for helpful discussions. 26 <p> which has error 1 3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [38] described in [21]) and one can then apply <ref> [21, 37] </ref> to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research, and Silvio Micali for helpful discussions. 26
Reference: [22] <author> S. Cook. </author> <title> The Complexity of Theorem Proving Procedures. </title> <booktitle> Proceedings of the 3rd Annual ACM Symposium on the Theory of Computing, ACM (1971). </booktitle>
Reference-contexts: 1 Introduction The notion of an "efficiently verifiable proof" plays a fundamental role in the study of efficient computation. Traditionally this notion is associated with the complexity class NP <ref> [22] </ref>, the set of languages with short (polynomial length) and polynomial-time verifiable proofs of membership. In other words, NP as a proof system consists of a prover who provides a short proof and a verifier who checks it.
Reference: [23] <author> U. Feige and A. Shamir. </author> <title> Witness Indistinguishable and Witness Hiding Protocols. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [24] <author> O. Gabber and Z. Galil. </author> <title> Explicit Construction of Linear Sized Superconcentrators. </title> <journal> J. Computer and System Sciences 22, </journal> <month> 407-420 </month> <year> (1981). </year>
Reference-contexts: We call 2 (G) = sup l1 2 (G l ) the second eigenvalue of G. Definition 5.4 Let G be a family of d-regular graphs. We call G a (family of) expanders if 2 (G) &lt; 1. Gabber and Galil <ref> [24] </ref> demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [24] to achieve this; via Alon's result [4] we can be sure that <p> Gabber and Galil <ref> [24] </ref> demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [24] to achieve this; via Alon's result [4] we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [24] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2. <p> By adding edges we can easily modify the construction of <ref> [24] </ref> to achieve this; via Alon's result [4] we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [24] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2. Let G be a d-regular undirected graph and A the matrix obtained by dividing every entry of the adjacency matrix of G by d.
Reference: [25] <author> O. Goldreich, R. Impagliazzo, L. Levin, R. Venkatesan and D. Zuckermann. </author> <title> Security Preserving Amplification of Hardness. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: We call the expansion constant of G; it depends only on the second eigenvalue of G. A proof of Lemma 5.7, following the ideas of [3], appears in Appendix A. A variant of this lemma appears in <ref> [25] </ref>. 5.2 The Protocol: Overview We will play in parallel v = O (k= log (kg)) copies of the game presented in x4, setting m such that the error in each of these games is at most an appropriately chosen *.
Reference: [26] <author> O. Goldreich and A. Kahan. </author> <title> Using Claw-Free Permutations to Construct Constant Round Zero-Knowledge Proofs for NP. </title>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [27] <author> O. Goldreich and H. Krawczyk. </author> <title> On the Composition of Zero-Knowledge Proof Systems. </title> <booktitle> Proceedings of ICALP 90, Lecture Notes in Computer Science Vol. </booktitle> <volume> 443, </volume> <publisher> Springer Verlag (1990). </publisher>
Reference-contexts: The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [28] <author> O. Goldreich and L. Levin. </author> <title> A Hard-Core Predicate for any One-Way Function. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: It is easy to see that if P is a pairwise independent generator then its associated constant c P is 2. So the above implementation is optimal in the number of random bits used. Goldreich and Levin <ref> [28] </ref> propose an alternative implementation which, although it uses slightly more random bits, has the advantage of being more efficient in practice. <p> In order to describe it we first recall that a l-by-l matrix [a ij ] is Toeplitz if a i;j = a i1;j1 for each i; j = 2; : : :; l, and thus such a matrix is specified by its first row and column. The implementation of <ref> [28] </ref> consists of using a 3l 1 bit seed s to specify an l bit vector b and an l by l (0; 1)-Toeplitz matrix M and setting P (1 l ; i; s) = M i + b, where i is being regarded as a l bit vector and the
Reference: [29] <author> O. Goldreich, Y. Mansour, and M. Sipser. </author> <title> Interactive Proof Systems: Provers that never Fail and Random Selection. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle>
Reference-contexts: Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 29, 10] </ref>) are proved. In the rest of this paper we consider AM proof systems. Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction.
Reference: [30] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that Yield Nothing but their Validity. </title> <type> Technical Report #498, </type> <institution> Technion, </institution> <year> 1988. </year> <booktitle> Preliminary version in Proceedings of the 27th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1986). </booktitle>
Reference-contexts: The original motivation for their introduction was the introduction of zero-knowledge interactive proofs [31], which in turn were suggested as a principal tool for cryptographic protocol design [31]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson <ref> [30] </ref>, yielding a dramatic effect on the theory and practice of cryptography. However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. <p> However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. First indications to such potential were presented by Babai [5] and Goldreich, Micali and Wigderson <ref> [30] </ref>. But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. And here the truth was startling: interactive proofs exist for any language which can be recognized in polynomial space (cf.
Reference: [31] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <journal> SIAM J. Computing 18(1), </journal> <month> 186-208 </month> <year> (1989). </year>
Reference-contexts: How the prover found the proof is immaterial; as long as the verifier can check it via some mechanical procedure then the proof is valid. More recently, Goldwasser, Micali and Rackoff suggested that the notion of "efficiently verifiable proofs" be extended to include interactive proof systems <ref> [31] </ref>. Interactive proof systems augment NP proof systems with two ingredients: interaction and randomness. The verifier is now no longer a silent partner; he is allowed to ask the prover questions. <p> Since their inception interactive proofs have proven to be very useful. The original motivation for their introduction was the introduction of zero-knowledge interactive proofs <ref> [31] </ref>, which in turn were suggested as a principal tool for cryptographic protocol design [31]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson [30], yielding a dramatic effect on the theory and practice of cryptography. <p> Since their inception interactive proofs have proven to be very useful. The original motivation for their introduction was the introduction of zero-knowledge interactive proofs <ref> [31] </ref>, which in turn were suggested as a principal tool for cryptographic protocol design [31]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson [30], yielding a dramatic effect on the theory and practice of cryptography. <p> Next we turn to randomness, and describe our results and techniques. We conclude by discussing related work and possible avenues for further investigation. 1.1 Interactive Proofs and Arthur-Merlin Games An interactive proof system <ref> [31] </ref> consists of two communicating parties, the prover and the verifier. The verifier is restricted to probabilistic polynomial time while the prover is not computationally restricted. On a common input w they exchange a sequence of messages, with the number of messages polynomial in the length n of w. <p> The current situation for zero-knowledge exactly parallels that which existed for IP before our work. Namely, although there are many results known on reducing interaction <ref> [31, 8, 9, 26, 27, 23, 16, 13, 12] </ref>, nothing is known about reducing randomness.
Reference: [32] <author> S. Goldwasser and M. Sipser. </author> <title> Private Coins versus Public Coins in Interactive Proof Systems. </title> <booktitle> Proceedings of the 18th Annual ACM Symposium on the Theory of Computing, ACM (1986). </booktitle>
Reference-contexts: AM proof systems for a language L are defined just like interactive ones. Goldwasser and Sipser <ref> [32] </ref> showed that any language having an interactive proof system also has an AM proof system; the two systems are thus of equal power as far as language recognition is concerned. Moreover, the equivalence established by [32] preserves the number of rounds. <p> Goldwasser and Sipser <ref> [32] </ref> showed that any language having an interactive proof system also has an AM proof system; the two systems are thus of equal power as far as language recognition is concerned. Moreover, the equivalence established by [32] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and [5, 2, 6, 15, 29, 10]) are proved. In the rest of this paper we consider AM proof systems.
Reference: [33] <author> J. Hartmanis, R. Chang, D. Ranjan and P. Rohatgi. </author> <title> Structural Complexity Theory: Recent Surprizes. </title> <type> Technical Report 90-1117, </type> <institution> Dept. of Computer Science, Cornell University (April 1990). </institution>
Reference-contexts: However, we note that the results of [40, 45] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them <ref> [33, 20] </ref>. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of [2]. 1.2 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense.
Reference: [34] <author> J. H -astad. </author> <title> Pseudo-random generators under Uniform Assumptions. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: Furthermore, pseudo-random sequences [14, 48] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of [21, 37] and <ref> [36, 34] </ref> we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant *. Error-reduction for AM games, however, seems more difficult to handle.
Reference: [35] <author> R. Impagliazzo. </author> <title> Private communication (December 1990). </title> <type> 28 </type>
Reference-contexts: Recently Impagliazzo <ref> [35] </ref> presented a general technique to extend these kinds of results to real valued functions. 6.3 Our (l; *; ffi)-approximator We construct an (l; *; ffi)-approximator which uses O (l + log ffi 1 ) coin tosses and O (* 2 log ffi 1 ) sample points, and works for all
Reference: [36] <author> R. Impagliazzo, L. Levin and M. Luby. </author> <title> Pseudo-Random Generation from One-Way Functions. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: Furthermore, pseudo-random sequences [14, 48] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of [21, 37] and <ref> [36, 34] </ref> we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant *. Error-reduction for AM games, however, seems more difficult to handle.
Reference: [37] <author> R. Impagliazzo and D. Zuckerman. </author> <title> How to Recycle Random Bits. </title> <booktitle> Proceedings of the 30th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1989). </booktitle>
Reference-contexts: Cohen and Wigderson [21] and Impagliazzo and Zuckermann <ref> [37] </ref>, using techniques of Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Furthermore, pseudo-random sequences [14, 48] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of <ref> [21, 37] </ref> and [36, 34] we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant *. Error-reduction for AM games, however, seems more difficult to handle. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations. <p> This requires O (tl) coin tosses and m function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [19, 10, 21, 37, 41] </ref> that save coins over the standard method suffer from various restrictions (see x6 for details). <p> Using the techniques of Impagliazzo and Zuckermann <ref> [37] </ref> one can construct an (l; *; ffi)- approximator for the class of boolean functions which uses O (* 2 log ffi 1 ) sample points and l + O (* 4 log 2 ffi 1 ) coin tosses as long as l = !(* 2 log ffi 1 ). <p> A somewhat coarser kind of approximation to the average of a boolean functions f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 21, 37] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi. <p> Namely, a BPP algorithm which has error 1 3 with respect to L and uses r = r (n) coins can be transformed into one which has error 2 k and uses O (r + k) coins <ref> [3, 21, 37] </ref>. * Can our result be generalized to (general) interactive proof systems? We don't know of any direct non-trivial error-reduction technique for general interactive proof systems. <p> which has error 1 3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [38] described in [21]) and one can then apply <ref> [21, 37] </ref> to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research, and Silvio Micali for helpful discussions. 26
Reference: [38] <author> R. Karp, N. Pippinger and M. Sipser. </author> <title> A Time-Randomness Tradeoff. </title> <booktitle> In AMS Conference on Probabilistic Computational Complexity, </booktitle> <address> Durham, New Hampshire (1985). </address>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [47] and Santha [43]. The first constructions were obtained by Karp, Pippinger and Sipser <ref> [38] </ref> and Chor and Goldreich [19] who showed that the error-probability of a BPP algorithm which used r = r (n) coin tosses could be reduced to n c for any given constant c while using only O (r) coin tosses. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations. <p> A BPP algorithm which has error 1 3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of <ref> [38] </ref> described in [21]) and one can then apply [21, 37] to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research, and Silvio Micali for helpful discussions. 26
Reference: [39] <author> A. Lubotzky, R. Phillips and P. Sarnak. </author> <title> Explicit Expanders and the Ramanujan Conjectures. </title> <booktitle> Proceedings of the 18th Annual ACM Symposium on the Theory of Computing, ACM (1986). </booktitle>
Reference: [40] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. And here the truth was startling: interactive proofs exist for any language which can be recognized in polynomial space (cf. Lund, Fortnow, Karloff and Nisan <ref> [40] </ref> and Shamir [45]). Hence, IP (the class of languages possessing interactive proofs of membership) is probably much larger than NP. We conclude that interaction and randomness make a potent brew. <p> Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of <ref> [40, 45] </ref> indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [33, 20].
Reference: [41] <author> N. Nisan. </author> <title> Pseudorandom Generators for Space Bounded Computation. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: This requires O (tl) coin tosses and m function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [19, 10, 21, 37, 41] </ref> that save coins over the standard method suffer from various restrictions (see x6 for details). <p> This is useful for many applications such as randomness-efficient error-reduction for BPP algorithms. Other randomness-efficient sampling techniques include that of Nisan <ref> [41] </ref> who shows how O (l log t) random bits suffice to produce a sequence of l bit strings r 1 ; : : : ; r t such that jP [f (r 1 ) = = f (r t ) = 1] E [f ] t j &lt; 2 l
Reference: [42] <author> N. Nisan and A. Wigderson. </author> <title> Hardness vs. Randomness. </title> <booktitle> Proceedings of the 29th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1988). </booktitle>
Reference-contexts: Notable examples are results such as BPP equals almost-P [11] and BPP is contained in non-uniform P [1]. The IP counterpart of the first was open for several years and finally proved in <ref> [42] </ref>, while the IP analogue of the second (i.e. IP is contained in non-uniform NP) is not believed to be true. 1.4 Techniques Our result involves a novel techniques for randomness-efficient sampling.
Reference: [43] <author> M. Santha. </author> <title> On Using Deterministic Functions to Reduce Randomness in Probabilistic Algorithms. </title> <booktitle> Information and Computation 74(3), </booktitle> <month> 241-249 </month> <year> (1987). </year>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [47] and Santha <ref> [43] </ref>. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations.
Reference: [44] <author> A. </author> <title> Schrift. </title> <type> Chapter 4 of Ph.D Thesis, </type> <institution> Dept. of Applied Mathematics and Computer Science, Weiz-mann Institute. </institution>
Reference-contexts: This improves on the construction of [6] in which Arthur sent O (lqg 3 log g) random bits per round in the g (n) round game. We looked at how the power of IP varies with the amount of randomness. A different direction was taken by Schrift <ref> [44] </ref> who investigated how the power of an interactive proof varies with the quality of the random bits used. She shows that interactive proofs retain their power even when the parties do not have access to truly random bits, but rather to certain kinds of sources of weak randomness.
Reference: [45] <author> A. Shamir. IP=PSPACE. </author> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. And here the truth was startling: interactive proofs exist for any language which can be recognized in polynomial space (cf. Lund, Fortnow, Karloff and Nisan [40] and Shamir <ref> [45] </ref>). Hence, IP (the class of languages possessing interactive proofs of membership) is probably much larger than NP. We conclude that interaction and randomness make a potent brew. We are well motivated then, to understand more the precise role played by these ingredients in the granting of so much power. <p> Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of <ref> [40, 45] </ref> indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [33, 20].
Reference: [46] <author> V. Shoup. </author> <title> New Algorithms for Finding Irreducible Polynomials over Finite Fields. </title> <booktitle> Proceedings of the 29th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1988). </booktitle>
Reference-contexts: For completeness, let us sketch two implementations. The first implementation [19] uses finite fields. We identify the sets f0; 1g l and [2 l ] with GF (2 l ). Using Shoup's (deterministic) algorithm <ref> [46] </ref> we can find a degree l irreducible polynomial over GF (2) in time polynomial in l, and this yields the ability to do polynomial time arithmetic in the field.
Reference: [47] <author> M. Sipser. Expanders, </author> <title> Randomness, or Time Versus Space. Structure in Complexity Theory (1986). </title>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser <ref> [47] </ref> and Santha [43]. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [47, 43, 38, 19, 21, 37, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifiers coins, the search of the verifier for rejecting computations.
Reference: [48] <author> A. Yao. </author> <title> Theory and Applications of Trapdoor Functions. </title> <booktitle> Proceedings of the 23rd Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1982). </booktitle> <pages> 29 </pages>
Reference-contexts: Cohen and Wigderson [21] and Impagliazzo and Zuckermann [37], using techniques of Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). Furthermore, pseudo-random sequences <ref> [14, 48] </ref> can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c.
References-found: 48

