URL: http://www.cs.ucsd.edu/~wgg/Abstracts/bowdidge.thesis.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/bowdidge.thesis.html
Root-URL: http://www.cs.ucsd.edu
Title: Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization  
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Computer Science by Robert William Bowdidge Committee in charge: Professor William G. Griswold, Chair Professor Edwin Hutchins Professor Keith Marzullo Professor Joseph Pasquale Professor Richard N. Taylor  
Date: 1995  
Affiliation: UNIVERSITY OF CALIFORNIA, SAN DIEGO  
Abstract-found: 0
Intro-found: 1
Reference: [NeX 90] <institution> NeXT Computer, Inc., </institution> <address> Redwood City, CA. </address> <booktitle> NeXT Step Reference, </booktitle> <volume> Volume I, </volume> <year> 1990. </year>
Reference-contexts: However, the size of such an interface is comparable with the number of functions in Text widgets for GUIs. For example, the Text class in NeXTStep user interface requires 41 instance variables and sixty methods directly concerned with text processing and manipulation <ref> [NeX 90] </ref>. Although current buffer may not be a typical variable to encapsulate, a programmer certainly could wish to encapsulate it with a restructuring tool.
Reference: [Adams 80] <author> S. Adams. </author> <title> Pirate's adventure. </title> <journal> Byte, </journal> <volume> 5(12) </volume> <pages> 192-212, </pages> <year> 1980. </year>
Reference-contexts: This example also suggests the appearance of other star diagrams that, 86 for space reasons, cannot be presented in their entirety (Section V.B). The program we will examine, adventure, is a dungeon exploration game <ref> [Adams 80] </ref>. The game allows the player to move around a virtual world, divided into rooms, in order to solve a puzzle.
Reference: [Aho 80] <author> A. V. Aho. </author> <title> Pattern matching in strings. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Formal Language Theory: Perspectives and Open Problems, </booktitle> <pages> pages 325-347. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: Because the programmer needs to look at all references to identify similarities, keeping the occurrences of the data structure scattered only complicates the programmer's task. More commonly, programmers use a text searching tool such as grep <ref> [Aho 80] </ref> to provide assistance in locating direct references (Figure I.8). To encapsulate a variable, the programmer searches for the variable name, and grep returns a global view of how that variable is used throughout that program, formatted as a list of relevant lines in the program.
Reference: [Aho et al. 86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1986. </year>
Reference-contexts: The star diagram thus identifies printf as cohesive with the call to foo. The star diagram algorithm identifies these situations where statements are connected by calculating def-use chains for the variable being set. Although def-use chains are relatively simple to generate <ref> [Aho et al. 86] </ref> the Scheme implementation extracts def-use information from the program dependence graph (PDG) provided by the restructuring tool. Using dataflow to identify cohesive expression occurs when the connecting variable is local to the current scope.
Reference: [Atkinson et al. 95] <author> D. C. Atkinson, W. G. Griswold, and C. McCurdy. </author> <title> Fast, flexible syntactic pattern matching and processing. </title> <booktitle> In 18th International Conference on Software Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: Preprocessing macros allows us to parse the source code and create the AST, but strips out one kind of abstraction that may be in a program. A better approach, suggested by Atkinson, Griswold, and McCurdy, uses an extended parser that attempts to process macros during parsing <ref> [Atkinson et al. 95] </ref>. If the code is a macro mimicking an inlined function, then the parser simply treats the macro as a function call.
Reference: [Ballance & Maccabe 92] <author> R. A. Ballance and A. B. Maccabe. </author> <title> Program dependence graphs for the rest of us. </title> <type> Technical Report CS92-10, </type> <institution> Department of Computer Science, University of New Mexico, </institution> <year> 1992. </year>
Reference-contexts: The star diagram shows that a simple cohesion metric such as enclosed in and same operation as can identify tightly cohesive statements. As others have shown, the parsed source code allows quick analysis for some dataflow and control flow <ref> [Cousot & Cousot 77, Ballance & Maccabe 92] </ref>. The star diagram presents a case where the imprecise dataflow enables us to generate abstractions of the code that are meaningful to the programmer for the task of encapsulation.
Reference: [Balzer et al. 76] <author> R. Balzer, N. Goldman, and D. Wile. </author> <title> On the transformational implementation approach to programming. </title> <booktitle> In 2nd International Conference on Software Engineering, </booktitle> <pages> pages 337-344, </pages> <year> 1976. </year>
Reference-contexts: Transformational systems let the user describe the program as a specification that is semi-automatically made concrete by a series of specification-to-implementation transformations. Modifications can be performed by reasoning about and changing the specification, then allowing the transformation system to automatically propagate changes down into the implementation automatically <ref> [Bull 90, Balzer et al. 76] </ref>. In such a system, the programmer could reason about a restructuring as a change to the specification (for example, stating that the instantiation of two variables should occur in the same scopes), and then let the system rederive the implementation.
Reference: [Bentley et al. 92] <author> R. Bentley, J. A. Hughes, D. Randall, T. Rodden, P. Sawyer, D. Shapiro, and I. Sommerville. </author> <title> Ethnographically-informed systems design for air traffic control. </title> <booktitle> In Computer-supported Collaborative Work '92, </booktitle> <pages> pages 123-129, </pages> <year> 1992. </year>
Reference-contexts: Weick documents previous uses of real-world observations as a method for retrieving meaningful contextual information about a system being studied [Weick 68]. Examples of studies that observed workers situated in their environment include domains such as airline gate assignment [Suchman & Trigg 91], air traffic control <ref> [Bentley et al. 92] </ref>, subway control [Heath & Luff 92], and shipboard navigation [Hutchins 90]. Observational techniques have also been used to understand how programmers work.
Reference: [Bergland 81] <author> G. D. Bergland. </author> <title> A guided tour of program design methodologies. </title> <journal> IEEE Computer, </journal> <volume> 14(10) </volume> <pages> 18-37, </pages> <year> 1981. </year>
Reference-contexts: permuted index the quick brown fox jumped over the lazy dog brown the quick dog lazy fox jumped over the jumped over the fox lazy dog over the fox jumped quick brown the the fox jumped over the quick brown Figure II.1: Sample execution of the KWIC Index program. tasks <ref> [Bergland 81] </ref> [Stevens et al. 74]. The entire program operates by performing four major tasks when creating the index. First, the program reads the input text file into memory, then rotates the lines to create the circularly-shifted lines. The program then sorts the lines and finally outputs the index.
Reference: [Berlin & Jeffries 92] <author> L. Berlin and R. Jeffries. Consultants and apprentices: </author> <title> Observations about learning and collaborative problem solving. </title> <booktitle> In Computer-Supported Cooperative Work '92, </booktitle> <pages> pages 130-137, </pages> <year> 1992. </year>
Reference-contexts: Berlin and Jeffries had novice programmers audiotape meetings with experts over the course of several months in order to identify the types of information experts provide that is normally not available in documentation <ref> [Berlin & Jeffries 92] </ref>. Studies involving cognitive or problem-solving issues are usually performed in a laboratory setting. The setting allows the experimenter to choose tasks and programs designed to elicit specific behavior, and to easily record observations.
Reference: [Biggerstaff 89] <author> T. J. Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <journal> IEEE Computer, </journal> <volume> 22(7) </volume> <pages> 36-49, </pages> <year> 1989. </year> <pages> 180 181 </pages>
Reference-contexts: Better reasoning and understanding capabilities may help these tools understand when a given bad structure actually is worth preserving <ref> [Biggerstaff 89, Quilici 93, Soni 91] </ref>. Intelligent program analysis tools could recognize common cases where poor structure actually helps the programmer understand the code, and could then avoid restructuring such cases. <p> Programmer feedback in such a tool could be minimal (similar to the goto removers of the past [Bush 85, de Balbine 75]) or significant. By recognizing concepts and identifying appropriate changes, such tools could restructure the program automatically, or present suggestions to a programmer <ref> [Biggerstaff 89, Quilici 93, Soni 91] </ref>. Alternatively, like an old version of the restructuring tool, the programmer could identify a common concept, then let the restructuring tool find and restructure similar code. VII.B.3 Approaches for Supporting Encapsulation Several approaches could help the programmer restructure. <p> A number of metrics exist for identifying cohesive statements in a program; such methods could be used to identify candidate interface functions for an automatic encapsulation tool [Ott & Thuss 89, Schwanke 91]. By recognizing concepts and identifying appropriate changes, such tools could restructure the program automatically <ref> [Biggerstaff 89, Quilici 93] </ref>. Alternatively, a restructuring tool could let the user specify a pattern describing expressions to extract, then allow the tool to automatically match and restructure similar expressions. Encapsulation tools could also rely on programmer input for the more difficult decisions, and automate the simpler tasks.
Reference: [Boehm 75] <author> B. W. Boehm. </author> <title> The high cost of software. </title> <editor> In E. Horowitz, editor, </editor> <title> Practical Strategies for Developing Large Software Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: Lientz and Swanson observed that large companies spent 50% of their programming effort on maintenance [Lientz & Swanson 80]. Boehm documented an Air Force project where the cost to develop the program was $30 per line, and cost to maintain the program was $4,000 per line <ref> [Boehm 75] </ref>. Maintenance of software systems becomes more expensive over time as repeated modifications degrade the software's structure.
Reference: [Brooks 87] <author> F. P. Brooks. </author> <title> No silver bullet: </title> <journal> Essence and accidents of software engineering. IEEE Computer, </journal> <volume> 20(4) </volume> <pages> 10-19, </pages> <year> 1987. </year>
Reference-contexts: Other tools might manipulate other aspects of programs, such as the order of functions in the source code to ensure a clean and logical ordering. The inherent number of relations between code fragments in the source code of a program <ref> [Brooks 87] </ref> makes multiple visualizations of a program necessary. 53 II.G Summary The description of the star diagram and of a sample encapsulation describe how the star diagram presents relationships between operations that appear relevant to programmers performing restructuring. <p> All teams used this feature. Because of the inherent unvisualizability of software <ref> [Brooks 87] </ref>, we postulate that interleaved planning and restructuring may be more practical than complete planning. VI.D Validity of the Study We can expect that the studies presented here reasonably capture the behavior of programmers in the real world. <p> The star diagram presents a case where the imprecise dataflow enables us to generate abstractions of the code that are meaningful to the programmer for the task of encapsulation. Focused Visualizations Support Restructuring Software contains multiple constraints and connections between statements, and is often described as unvisualizable. <ref> [Brooks 87] </ref> However, the star diagram succeeds as a visualization primarily because it is a focused representation intended to help the programmer with one specific task.
Reference: [Bull 90] <author> T. Bull. </author> <title> An introduction to the WSL program transformer. </title> <booktitle> In Conference on Software Maintenance 1990, </booktitle> <pages> pages 242-250, </pages> <year> 1990. </year>
Reference-contexts: Transformational systems let the user describe the program as a specification that is semi-automatically made concrete by a series of specification-to-implementation transformations. Modifications can be performed by reasoning about and changing the specification, then allowing the transformation system to automatically propagate changes down into the implementation automatically <ref> [Bull 90, Balzer et al. 76] </ref>. In such a system, the programmer could reason about a restructuring as a change to the specification (for example, stating that the instantiation of two variables should occur in the same scopes), and then let the system rederive the implementation.
Reference: [Bush 85] <author> E. Bush. </author> <title> The automatic restructuring of COBOL. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 35-41, </pages> <year> 1985. </year>
Reference-contexts: Some software engineering tools automatically convert code into a supposedly more desirable form, such as changing goto-laden COBOL code into a structured programming style <ref> [Bush 85, de Balbine 75] </ref>. Although these tools may help programmers avoid the tedious aspects of maintenance and avoid introducing bugs into the source code, such tools shift decisions about the desired form of the program to the tool creator, not the tool user. <p> Rather than help the programmer visualize and understand the entire structure, automated tools could perform the understanding and restructuring steps. Programmer feedback in such a tool could be minimal (similar to the goto removers of the past <ref> [Bush 85, de Balbine 75] </ref>) or significant. By recognizing concepts and identifying appropriate changes, such tools could restructure the program automatically, or present suggestions to a programmer [Biggerstaff 89, Quilici 93, Soni 91].
Reference: [Chen 96] <author> M. Chen. </author> <title> A tool for planning restructuring of data abstractions in large systems. </title> <type> Master's thesis, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1996. </year>
Reference-contexts: Because the star diagram is primarily a tree representation, with arms combining only at the far right side of the diagram, the star diagram could be laid out with a tree layout algorithm, then have the function definition nodes added after <ref> [Chen 96] </ref>. <p> The tool user could manipulate the star diagram to plan a design, then receive a list of the transformations performed and suggested details on what lines of code to change <ref> [Chen 96] </ref>. Extracting Multi-statement Functions: The star diagram currently does not support either identifying or creating functions made up of multiple syntactically independent expressions or statements.
Reference: [Chi 94] <author> M. T. H. Chi. </author> <title> Analyzing the content of verbal data to represent knowledge: A practical guide. </title> <note> Submitted to Journal of Learning Sciences, </note> <year> 1994. </year>
Reference-contexts: However, the narratives were not useful in focusing analysis. Our inexperience and lack of guidance from the literature probably played a role, but also restructuring decisions and the subsequent actions tended to be distributed throughout a session. Transcripts were analyzed both bottom-up and top-down <ref> [Chi 94] </ref>.
Reference: [Cousin & Collofello 92] <author> L. Cousin and J. S. Collofello. </author> <title> A task-based approach to improving the software maintenance process. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 118-126, </pages> <year> 1992. </year>
Reference-contexts: Letovsky observed programmers' browsing strategies [Letovsky 86] and program comprehension methods [Letovsky & Soloway 85]. Sutcliffe and Maiden explored mental behavior of analysts during problem solving [Sutcliffe & Maiden 92]. Cousin <ref> [Cousin & Collofello 92] </ref> used observations of programmers to identify information that should be provided in a software engineering environment. Lange and Rosson both documented reuse strategies in an object-oriented programming environment [Lange & Moher 89, Rosson & Carroll 93].
Reference: [Cousot & Cousot 77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fix-points. </title> <booktitle> In Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: III.B Algorithm for Generating a Star Diagram At a high level, the star diagram algorithm creates the star diagram primarily by examining the AST. (Such methods of deriving behavior of the running code from analysis of the static representation of the code is often referred to as abstract interpretation <ref> [Cousot & Cousot 77] </ref>.) To demonstrate the algorithm, we present a small example. Figure III.2 shows some fragments of code using the *line-storage* variable, the corresponding AST, and the resulting star diagram. To generate a star diagram, the algorithm first parses the source code and generates the abstract syntax tree. <p> The star diagram shows that a simple cohesion metric such as enclosed in and same operation as can identify tightly cohesive statements. As others have shown, the parsed source code allows quick analysis for some dataflow and control flow <ref> [Cousot & Cousot 77, Ballance & Maccabe 92] </ref>. The star diagram presents a case where the imprecise dataflow enables us to generate abstractions of the code that are meaningful to the programmer for the task of encapsulation.
Reference: [de Balbine 75] <author> G. de Balbine. </author> <title> Better manpower utilization using automatic restructuring. </title> <booktitle> In National Computer Conference, </booktitle> <year> 1975. </year>
Reference-contexts: Some software engineering tools automatically convert code into a supposedly more desirable form, such as changing goto-laden COBOL code into a structured programming style <ref> [Bush 85, de Balbine 75] </ref>. Although these tools may help programmers avoid the tedious aspects of maintenance and avoid introducing bugs into the source code, such tools shift decisions about the desired form of the program to the tool creator, not the tool user. <p> Rather than help the programmer visualize and understand the entire structure, automated tools could perform the understanding and restructuring steps. Programmer feedback in such a tool could be minimal (similar to the goto removers of the past <ref> [Bush 85, de Balbine 75] </ref>) or significant. By recognizing concepts and identifying appropriate changes, such tools could restructure the program automatically, or present suggestions to a programmer [Biggerstaff 89, Quilici 93, Soni 91].
Reference: [Dumas & Parsons 95] <author> J. Dumas and P. Parsons. </author> <title> Discovering the ways programmers think about new programming environments. </title> <journal> Communications of the ACM, </journal> <volume> 38(6) </volume> <pages> 45-56, </pages> <year> 1995. </year>
Reference-contexts: Lange and Rosson both documented reuse strategies in an object-oriented programming environment [Lange & Moher 89, Rosson & Carroll 93]. Other studies tested the design of a database-style programming environment for the Dylan language <ref> [Dumas & Parsons 95] </ref> and listed common problems in Macintosh programming environments [Houde & Sellman 94]. Our study is modeled on Flor's studies of organization within teams of programmers in a laboratory setting [Flor & Hutchins 91, Flor 94].
Reference: [Dybvig 87] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: Scheme, a Lisp-like language, contains all the features of programming languagespointers, side effects, and assignmentwhich make program analysis difficult <ref> [Dybvig 87] </ref>. The current restructuring tool supports twenty basic transformations [Griswold & Notkin 93], although composite transformations can be created from the existing transformations. The basic transformations can be divided into four categories. * Scoping transformations change where functions and variables are defined and visible.
Reference: [Embley & Woodfield 88] <author> D. W. Embley and S. N. Woodfield. </author> <title> Assessing the quality of abstract data types written in Ada. </title> <booktitle> In 10th International Conference on Software Engineering, </booktitle> <pages> pages 144-153, </pages> <year> 1988. </year>
Reference-contexts: This approach places no special emphasis on types or names of data structures. In contrast, Embley and Woodfield's clustering method focuses on the types and operations exported from a module and the types used within a module <ref> [Embley & Woodfield 88] </ref>. The method identifies modules that act on more than one abstract data type or act on only subparts of a type, thus suggesting poor cohesion or inappropriate coupling.
Reference: [Ericsson & Simon 93] <author> K. A. Ericsson and H. A. Simon. </author> <title> Protocol Analysis: Verbal Reports as Data. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: Observational techniques have also been used to understand how programmers work. Approaches range from using analysis of video and transcripts to answer a very specific research hypothesis <ref> [Gray & Anderson 87, Ericsson & Simon 93] </ref> to using verbal data for exploratory understanding of planning, behavior, and problem solving. The exploratory studies can be divided into observations in the workplace and 120 observations in an experimental setting. <p> Bottom-up analysis looks for interesting patterns and then turns them into hypotheses for top-down analysis. Some of the analysis involved explicitly coding the transcripts <ref> [Ericsson & Simon 93] </ref>; some issues involved less formal analysis of the transcripts. VI.B Observations and Model of the Encapsulation Process VI.B.1 Model To understand the relationships amongst the different teams, a model of the teams' behaviors is beneficial.
Reference: [Ferrante et al. 87] <author> J. Ferrante, K. J. Ottstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <year> 1987. </year> <month> 182 </month>
Reference-contexts: Figure I.2 presents an example of the inline-parameter transformation. These transformations often mimic common operations performed by program mers restructuring programs by hand. The restructuring tool uses a program dependence graph (PDG) to explicitly represent control and data dependencies between operations of a program <ref> [Kuck et al. 81, Ferrante et al. 87] </ref>. The restructuring tool uses the dependence information in the PDG to check that a given transformation will not change the output behavior of the code being restructured. <p> II.C.2 Star Diagram Visualization The star diagram visualization itself appears in the lower portion of the star diagram's window. To a first approximation, the star diagram is like a data flow graph <ref> [Ferrante et al. 87] </ref>, with nodes of the star diagram corresponding to operations, 32 Figure II.4: Major parts of the star diagram window. and edges in the star diagram corresponding to data flow between operations.
Reference: [Flor & Hutchins 91] <author> N. V. Flor and E. L. Hutchins. </author> <title> Analyzing distributed cognition in software teams: A case study of team programming during perfective software maintenance. </title> <editor> In J. Koenemann-Belliveau, T. G. Moher, and S. P. Robertson, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Fourth Workshop, </booktitle> <pages> pages 36-64. </pages> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1991. </year>
Reference-contexts: Other studies tested the design of a database-style programming environment for the Dylan language [Dumas & Parsons 95] and listed common problems in Macintosh programming environments [Houde & Sellman 94]. Our study is modeled on Flor's studies of organization within teams of programmers in a laboratory setting <ref> [Flor & Hutchins 91, Flor 94] </ref>. Flor's work differs from the other programmer studies because he used teams of two programmers working together as subjects. This technique, known as constructive interaction [Miyake 86, Wildman 95] provides a more natural way to elicit programmer talking than single-person think-aloud methods.
Reference: [Flor 94] <author> N. Flor. </author> <title> Dynamic Organization in Multi-Agent Distributed Cognitive Systems. </title> <type> PhD dissertation, </type> <institution> Cognitive Science Department, University of California, </institution> <address> San Diego, </address> <year> 1994. </year>
Reference-contexts: Other studies tested the design of a database-style programming environment for the Dylan language [Dumas & Parsons 95] and listed common problems in Macintosh programming environments [Houde & Sellman 94]. Our study is modeled on Flor's studies of organization within teams of programmers in a laboratory setting <ref> [Flor & Hutchins 91, Flor 94] </ref>. Flor's work differs from the other programmer studies because he used teams of two programmers working together as subjects. This technique, known as constructive interaction [Miyake 86, Wildman 95] provides a more natural way to elicit programmer talking than single-person think-aloud methods.
Reference: [Gray & Anderson 87] <author> W. D. Gray and J. R. Anderson. </author> <title> Change episodes in coding: When and how do programmers change their code? In G. </title> <editor> M. Olson, S. Sheppard, and E. Soloway, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Second Workshop, </booktitle> <pages> pages 185-197. </pages> <publisher> Ablex Publishing Corporation, </publisher> <address> Norwood, NJ, </address> <year> 1987. </year>
Reference-contexts: Observational techniques have also been used to understand how programmers work. Approaches range from using analysis of video and transcripts to answer a very specific research hypothesis <ref> [Gray & Anderson 87, Ericsson & Simon 93] </ref> to using verbal data for exploratory understanding of planning, behavior, and problem solving. The exploratory studies can be divided into observations in the workplace and 120 observations in an experimental setting.
Reference: [Griswold & Bowdidge 93] <author> W. G. Griswold and R. W. Bowdidge. </author> <title> Program restructuring via design-level manipulation. </title> <booktitle> In Workshop on Studies of Software Design, </booktitle> <year> 1993. </year>
Reference-contexts: As a result, graphical design notations portray conceptual objects at a much higher level than the star diagram. In previous research, we tested the idea of restructuring through notations used for paper designs. We designed and implemented a direct-manipulation graphical restructuring interface <ref> [Griswold & Bowdidge 93] </ref> based on structure charts [Stevens et al. 74]. Figure II.11 shows the structure diagram, the manipulable visualization we created. The structure diagram reveals the high-level structure of the program and allows the tool user to directly change the structure through manipulations on the view.
Reference: [Griswold & Notkin 92] <author> W. G. Griswold and D. Notkin. </author> <title> Computer-aided vs. manual program restructuring. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(1) </volume> <pages> 1-1, </pages> <year> 1992. </year>
Reference-contexts: However, restructuring by hand is both error prone and difficult because a programmer's changes can introduce subtle flaws and bugs into a previously working program <ref> [Griswold & Notkin 92] </ref>. As a result, programmers must work methodically and carefully to produce a correct, restructured program. <p> We know of only one study of programmers performing restructuring of any kind <ref> [Griswold & Notkin 92] </ref>, and it was ad hoc and focused on the mechanics of the change. Also, our restructuring tool is a prototype that can only be used on small Scheme programs, so a case study in an industrial setting is currently infeasible.
Reference: [Griswold & Notkin 93] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 228-269, </pages> <year> 1993. </year>
Reference-contexts: For example, Griswold and Notkin specifically used the concept of restructuring to achieve data encapsulation in a suggested process of adding an enhancement to an existing program <ref> [Griswold & Notkin 93] </ref>. According to this process, the programmer should first create a new data abstraction that localizes those design decisions formerly distributed across the entire program into a single module. Then, the programmer should modify the new module in order to add the enhancement. <p> expression into another in accordance with a mathematical rule; esp: a change of variables or coordinates in which a function of new variables or coordinates is substituted for each original variable or coordinate. 7 The transformations are meaning-preserving; they change the structure of the program without affecting the program's output <ref> [Griswold & Notkin 93] </ref>. <p> Scheme, a Lisp-like language, contains all the features of programming languagespointers, side effects, and assignmentwhich make program analysis difficult [Dybvig 87]. The current restructuring tool supports twenty basic transformations <ref> [Griswold & Notkin 93] </ref>, although composite transformations can be created from the existing transformations. The basic transformations can be divided into four categories. * Scoping transformations change where functions and variables are defined and visible.
Reference: [Griswold 93] <author> W. G. Griswold. </author> <title> Direct update of dataflow representations for a meaning-preserving program restructuring tool. </title> <booktitle> In ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 42-55, </pages> <year> 1993. </year>
Reference-contexts: (When programming in Scheme and Lisp, asterisks around a variable name are used as a convention for indicating global variables.) the program's behavior will not change [Yang et al. 89]), or would change the program dependence graph in a manner that guarantees the behavior of the program would remain constant <ref> [Griswold 93] </ref>. I.A.4 Text-based Restructuring Tool In order to simplify application of the transformations to maintain and restructure programs, we implemented a restructuring tool where the tool user selects and manipu lates the source code of the program with a mouse-based graphical user interface.
Reference: [Harel et al. 90] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <year> 1990. </year>
Reference-contexts: The Garden project [Reiss 87] notes that programmers benefit from using many notations during design, each view suited to a design technique. The STATEMATE environment, for instance, supports this need by providing physical layout, dataflow, and state machine notations to describe and prototype reactive systems <ref> [Harel et al. 90] </ref>. Garden permits the programmer to define custom textual and graphical notations and describe designs with these notations.
Reference: [Heath & Luff 92] <author> C. Heath and P. Luff. </author> <title> Collaboration and control: Crisis management and multimedia technology in London Underground line control rooms. Computer-supported Collaborative Work, </title> <address> 1(1-2):69-94, </address> <year> 1992. </year>
Reference-contexts: Examples of studies that observed workers situated in their environment include domains such as airline gate assignment [Suchman & Trigg 91], air traffic control [Bentley et al. 92], subway control <ref> [Heath & Luff 92] </ref>, and shipboard navigation [Hutchins 90]. Observational techniques have also been used to understand how programmers work.
Reference: [Horwitz & Reps 92] <author> S. Horwitz and T. Reps. </author> <title> The use of program dependence graphs in software engineering. </title> <booktitle> In 14th International Conference on Software Engineering, </booktitle> <pages> pages 392-411, </pages> <year> 1992. </year>
Reference-contexts: Calculating the slice requires finding all statements reaching the variable use by dataflow or conditionally affecting its execution (See Figure VII.1). Weiser's original definition of slicing identified the set of statements that could affect the value of a variable. These have been described as forward slices <ref> [Horwitz & Reps 92] </ref>, while slices that indicate all statements that could be affected by the value of a variable have been called backward slices. More recently, slicing has been proposed as a tool for helping 146 programmers understand large programs.
Reference: [Houde & Sellman 94] <author> S. Houde and R. Sellman. </author> <title> In search of design principles for programming environments. </title> <booktitle> In Human Factors in Computing Systems (CHI '94), </booktitle> <pages> pages 424-430, </pages> <year> 1994. </year> <month> 183 </month>
Reference-contexts: Lange and Rosson both documented reuse strategies in an object-oriented programming environment [Lange & Moher 89, Rosson & Carroll 93]. Other studies tested the design of a database-style programming environment for the Dylan language [Dumas & Parsons 95] and listed common problems in Macintosh programming environments <ref> [Houde & Sellman 94] </ref>. Our study is modeled on Flor's studies of organization within teams of programmers in a laboratory setting [Flor & Hutchins 91, Flor 94]. Flor's work differs from the other programmer studies because he used teams of two programmers working together as subjects.
Reference: [Hutchins 90] <author> E. Hutchins. </author> <title> The technology of team navigation. </title> <editor> In J. Galegher, R. E. Kraut, and C. Egido, editors, </editor> <title> Intellectual teamwork: Social and technical bases of collaborative work. </title> <publisher> Lawrence Erlbaum, Inc., </publisher> <address> Hillsdale, NJ, </address> <year> 1990. </year>
Reference-contexts: Examples of studies that observed workers situated in their environment include domains such as airline gate assignment [Suchman & Trigg 91], air traffic control [Bentley et al. 92], subway control [Heath & Luff 92], and shipboard navigation <ref> [Hutchins 90] </ref>. Observational techniques have also been used to understand how programmers work. Approaches range from using analysis of video and transcripts to answer a very specific research hypothesis [Gray & Anderson 87, Ericsson & Simon 93] to using verbal data for exploratory understanding of planning, behavior, and problem solving.
Reference: [Hutchins et al. 85] <author> E. L. Hutchins, J. D. Hollan, and D. A. Norman. </author> <title> Direct manipulation interfaces. </title> <journal> Human-Computer Interaction, </journal> <volume> 1 </volume> <pages> 311-338, </pages> <year> 1985. </year>
Reference-contexts: For example, the star diagram does not display let scope constructs, and so the transformations for manipulating let scopes are ignored. II.C.5 Direct Manipulation of the Star Diagram. To allow manipulating the program through the star diagram, the tool user uses a direct-manipulation interface <ref> [Hutchins et al. 85, Schneiderman 83] </ref> to specify a restructuring change.
Reference: [Kay 95] <author> J. S. Kay. </author> <title> Path IDs: a mechanism for reducing software latency. </title> <type> PhD dissertation, </type> <institution> Computer Science and Engineering Department, University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: As a result, programmers must work methodically and carefully to produce a correct, restructured program. One example of restructuring by hand occurred during a fellow graduate student's research <ref> [Kay 95] </ref>, where the structure of the networking code for the UNIX kernel proved inappropriate for an intended change.
Reference: [Kernighan & Ritchie 78] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: Specifically, some pro 92 gramming styles encourage programmers to use macros to generate visible abstractions in the source code. Macro processors commonly used by programmers include cpp, the preprocessor used for the C programming language <ref> [Kernighan & Ritchie 78] </ref>, and m4 [Kernighan & Ritchie 86]. Macros generally are removed via a preprocessing step before compiling. As a result, any tool that relies on parsing source code in a language with preprocessor macros only sees expanded macros and not the uses of the macros.
Reference: [Kernighan & Ritchie 86] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The m4 macro processor. In UNIX Programmer's Supplementary Documents, Volume 1 (PS1), 4.3 Berkeley Software Distribution, Virtual VAX-11 Version. </title> <booktitle> USENIX Association, </booktitle> <address> Berkeley, CA, </address> <year> 1986. </year>
Reference-contexts: Specifically, some pro 92 gramming styles encourage programmers to use macros to generate visible abstractions in the source code. Macro processors commonly used by programmers include cpp, the preprocessor used for the C programming language [Kernighan & Ritchie 78], and m4 <ref> [Kernighan & Ritchie 86] </ref>. Macros generally are removed via a preprocessing step before compiling. As a result, any tool that relies on parsing source code in a language with preprocessor macros only sees expanded macros and not the uses of the macros.
Reference: [Kuck et al. 81] <author> D. J. Kuck, R. H. Kuhn, B. Leasure, D. A. Padua, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In 8th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-218, </pages> <year> 1981. </year>
Reference-contexts: Figure I.2 presents an example of the inline-parameter transformation. These transformations often mimic common operations performed by program mers restructuring programs by hand. The restructuring tool uses a program dependence graph (PDG) to explicitly represent control and data dependencies between operations of a program <ref> [Kuck et al. 81, Ferrante et al. 87] </ref>. The restructuring tool uses the dependence information in the PDG to check that a given transformation will not change the output behavior of the code being restructured.
Reference: [Lampson 84] <author> B. Lampson. </author> <title> Hints for computer system design. </title> <journal> IEEE Computer, </journal> <volume> 1(1) </volume> <pages> 11-28, </pages> <year> 1984. </year>
Reference-contexts: In general, the set of functions should be intuitive, orthogonal, minimal, and insensitive to anticipated changes <ref> [Lampson 84, Parnas 79] </ref>. The functions forming the operations on the abstract data type should also be cohesive. Cohesion and its complement, coupling, are subjective criteria that can be used when evaluating a system's structure [Stevens et al. 74].
Reference: [Lange & Moher 89] <author> B. M. Lange and T. G. Moher. </author> <title> Some strategies of reuse in an object-oriented programming environment. </title> <booktitle> In Human Factors of Computing Systems - CHI '89, </booktitle> <pages> pages 69-73, </pages> <year> 1989. </year>
Reference-contexts: Sutcliffe and Maiden explored mental behavior of analysts during problem solving [Sutcliffe & Maiden 92]. Cousin [Cousin & Collofello 92] used observations of programmers to identify information that should be provided in a software engineering environment. Lange and Rosson both documented reuse strategies in an object-oriented programming environment <ref> [Lange & Moher 89, Rosson & Carroll 93] </ref>. Other studies tested the design of a database-style programming environment for the Dylan language [Dumas & Parsons 95] and listed common problems in Macintosh programming environments [Houde & Sellman 94].
Reference: [Larus & Hilfinger 88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN '88 Conference on Programming Languages Design and Implementation (PLDI), </booktitle> <pages> pages 21-34, </pages> <year> 1988. </year>
Reference-contexts: Type encapsulation naturally avoids the alias problem by including all references of the type, including references through pointers of that type. 77 However, even in the current Scheme star diagram, aliasing can be handled. The underlying restructuring tool generates alias information when building the PDG <ref> [Larus & Hilfinger 88] </ref>, so that aliases can be detected and treated as references to the variable being encapsulated when displaying the star diagram. One possible problem with this approach is that the analysis is conservative, so extra aliases may be identified.
Reference: [Leffler et al. 88] <author> S. J. Leffler, M. K. McKusick, M. J. Karels, and J. S. Quarterman. </author> <title> The design and implementation of the 4.3 BSD UNIX operating system. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: The programmer was trying to change the format of the mbuf data structure in the kernel's TCP/IP networking code. (The code was derived from the 4.3 BSD UNIX implementation <ref> [Leffler et al. 88] </ref>.) The mbuf data structures are blocks of memory that can be chained together in a linked list. These data structures permit efficient implementation of complex buffer operations, such as adding headers and trailers to the front and back of each outbound message.
Reference: [Lehman & Belady 85] <author> M. M. Lehman and L. A. Belady. </author> <title> Program Evolution: Processes of software change. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Over time, programmers layer modifications upon the existing program to meet the needs and demands of users, resulting in more time needed to understand the code, apply the change, then fix bugs resulting from the change <ref> [Lehman & Belady 85] </ref>. Some of the structural problems are caused by modifications that do not fit well into the original design of the program. Although good software engineering practices encourage programmers to plan for future modifications, not every future design change can be predicted.
Reference: [Letovsky & Soloway 85] <author> S. Letovsky and E. Soloway. </author> <title> Strategies for documenting delo-calized plans. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 144-151, </pages> <year> 1985. </year>
Reference-contexts: Studies involving cognitive or problem-solving issues are usually performed in a laboratory setting. The setting allows the experimenter to choose tasks and programs designed to elicit specific behavior, and to easily record observations. Letovsky observed programmers' browsing strategies [Letovsky 86] and program comprehension methods <ref> [Letovsky & Soloway 85] </ref>. Sutcliffe and Maiden explored mental behavior of analysts during problem solving [Sutcliffe & Maiden 92]. Cousin [Cousin & Collofello 92] used observations of programmers to identify information that should be provided in a software engineering environment.
Reference: [Letovsky 86] <author> S. Letovsky. </author> <title> Cognitive processes in program comprehension. </title> <booktitle> In First Workshop on Empirical Studies of Programmers, </booktitle> <pages> pages 58-79, </pages> <year> 1986. </year> <month> 184 </month>
Reference-contexts: Studies involving cognitive or problem-solving issues are usually performed in a laboratory setting. The setting allows the experimenter to choose tasks and programs designed to elicit specific behavior, and to easily record observations. Letovsky observed programmers' browsing strategies <ref> [Letovsky 86] </ref> and program comprehension methods [Letovsky & Soloway 85]. Sutcliffe and Maiden explored mental behavior of analysts during problem solving [Sutcliffe & Maiden 92]. Cousin [Cousin & Collofello 92] used observations of programmers to identify information that should be provided in a software engineering environment.
Reference: [Lientz & Swanson 80] <author> B. Lientz and E. Swanson. </author> <booktitle> Software Maintenance Management: </booktitle>
Reference-contexts: The exact cost of software maintenance varies with the kind of program, condition of documentation, and structure of source code, but the figures documented in the literature suggest the enormity of the cost. Lientz and Swanson observed that large companies spent 50% of their programming effort on maintenance <ref> [Lientz & Swanson 80] </ref>. Boehm documented an Air Force project where the cost to develop the program was $30 per line, and cost to maintain the program was $4,000 per line [Boehm 75]. Maintenance of software systems becomes more expensive over time as repeated modifications degrade the software's structure.
References-found: 50

