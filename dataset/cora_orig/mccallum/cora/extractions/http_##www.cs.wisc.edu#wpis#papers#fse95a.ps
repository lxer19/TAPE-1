URL: http://www.cs.wisc.edu/wpis/papers/fse95a.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: 1 Demand Interprocedural Dataflow Analysis paths) solutions to a large class of problems. g It
Author: Susan Horwitz, Thomas Reps, and Mooly Sagiv 
Note: valid  
Affiliation: University of Wisconsin  
Abstract: This paper presents a new demand algorithm for inter-procedural dataflow analysis. The new algorithm has three important properties: g It provides precise (meet over all interprocedurally
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data flow analysis: Part II. Demand analysis, </title> <note> Acta Informa-tica 10(3) pp. </note> <month> 265-272 (October </month> <year> 1978). </year>
Reference-contexts: -m, 0 | m N * - /* This set is preserved across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ ReachableNodesRelevantToDemand: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin <ref> [1] </ref> ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let <p> ACM SIGSOFT Symp. on the Foundations of Software Engineering (October 1995) - 7 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare G # = (N # , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin <ref> [1] </ref> while EdgeWorkList do [2] Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList [3] switch n [4] case n a return-site node : [5] let c be the call node that corresponds to n, and q be the procedure called at c [6] <p> Relation to Previous Work Until very recently, work on demand-driven dataflow analysis only considered the intraprocedural case (cf. <ref> [1] </ref>) and work on interprocedural dataflow analysis only considered the exhaustive case (cf. [23,6,5,15]).
Reference: 2. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, </title> <booktitle> in Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> (1986). </year>
Reference-contexts: - /* This set is preserved across calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ ReachableNodesRelevantToDemand: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := <ref> [2] </ref> Visit (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at <p> Node n9, g is inserted into VisitedNodes and into NodeWorkList by the call to Visit on line <ref> [2] </ref>. 2. Node n9, g is removed from NodeWorkList (line [4]); the default case (line [19]) is taken, and node n8, g is inserted into VisitedNodes and NodeWorkList by pro cedure Visit. 3. <p> the Foundations of Software Engineering (October 1995) - 7 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare G # = (N # , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do <ref> [2] </ref> Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList [3] switch n [4] case n a return-site node : [5] let c be the call node that corresponds to n, and q be the procedure called at c [6] for each d 3
Reference: 3. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conference Record of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Antonio, TX, </address> <month> January 29-31, </month> <year> 1979), </year> <month> (January </month> <year> 1979). </year>
Reference-contexts: calls */ VisitedNodes: global node set, initially empty /* This set is preserved across calls */ ReachableNodesRelevantToDemand: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) <ref> [3] </ref> while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each <p> , E # ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList <ref> [3] </ref> switch n [4] case n a return-site node : [5] let c be the call node that corresponds to n, and q be the procedure called at c [6] for each d 3 such that exit q , d 3 fi n, d 2 E # do Propagate (exit q
Reference: 4. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <address> (San Diego, CA, </address> <month> March </month> <year> 1987), </year> <month> (March </month> <year> 1987). </year>
Reference-contexts: node set, initially empty /* This set is preserved across calls */ ReachableNodesRelevantToDemand: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) [3] while NodeWorkList do <ref> [4] </ref> Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit <p> Node n9, g is inserted into VisitedNodes and into NodeWorkList by the call to Visit on line [2]. 2. Node n9, g is removed from NodeWorkList (line <ref> [4] </ref>); the default case (line [19]) is taken, and node n8, g is inserted into VisitedNodes and NodeWorkList by pro cedure Visit. 3. Node n8, g is removed from NodeWorkList; the case on line [6] is selected, and BackwardTabulateSLRPs is called for the first time. <p> ): global exploded supergraph declare PathEdge, SummaryEdge: global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList [3] switch n <ref> [4] </ref> case n a return-site node : [5] let c be the call node that corresponds to n, and q be the procedure called at c [6] for each d 3 such that exit q , d 3 fi n, d 2 E # do Propagate (exit q , d 3
Reference: 5. <author> Callahan, D., Cooper, K.D., Kennedy, K., and Torczon, L., </author> <title> Interprocedural constant propagation, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices 21(7) pp. </journal> <month> 152-161 (July </month> <year> 1986). </year>
Reference-contexts: calls */ ReachableNodesRelevantToDemand: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList <ref> [5] </ref> switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate <p> global edge set, initially empty /* These sets are preserved across calls */ procedure BackwardTabulateSLRPs (EdgeWorkList: edge set) begin [1] while EdgeWorkList do [2] Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList [3] switch n [4] case n a return-site node : <ref> [5] </ref> let c be the call node that corresponds to n, and q be the procedure called at c [6] for each d 3 such that exit q , d 3 fi n, d 2 E # do Propagate (exit q , d 3 fi exit q , d 3 ,
Reference: 6. <author> Callahan, D., </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference-contexts: global node set function IsMemberOfSolution (n h h : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n <ref> [6] </ref> case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate (exit p , <p> Node n9, g is removed from NodeWorkList (line [4]); the default case (line [19]) is taken, and node n8, g is inserted into VisitedNodes and NodeWorkList by pro cedure Visit. 3. Node n8, g is removed from NodeWorkList; the case on line <ref> [6] </ref> is selected, and BackwardTabulateSLRPs is called for the first time. This causes summary edge n7, g fi n8, g to be inserted into SummaryEdge (and causes several other edges to be inserted into PathEdge). 4. <p> [1] while EdgeWorkList do [2] Select and remove an edge n, d 2 fi exit p , d 1 from EdgeWorkList [3] switch n [4] case n a return-site node : [5] let c be the call node that corresponds to n, and q be the procedure called at c <ref> [6] </ref> for each d 3 such that exit q , d 3 fi n, d 2 E # do Propagate (exit q , d 3 fi exit q , d 3 , EdgeWorkList) od [7] for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge)
Reference: 7. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIG-PLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year>
Reference-contexts: : exploded supergraph node) returns boolean declare NodeWorkList, EdgeWorkList: edge set begin [1] ReachableNodesRelevantToDemand := ; NodeWorkList := [2] Visit (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : <ref> [7] </ref> let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od <p> be the call node that corresponds to n, and q be the procedure called at c [6] for each d 3 such that exit q , d 3 fi n, d 2 E # do Propagate (exit q , d 3 fi exit q , d 3 , EdgeWorkList) od <ref> [7] </ref> for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let [9] end case [10] case n the start node of procedure p : [11] for each c
Reference: 8. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> January 11-13, </month> <year> 1989), </year> <month> (January </month> <year> 1989). </year>
Reference-contexts: (n h h , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c <ref> [8] </ref> EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, <p> 2 E # do Propagate (exit q , d 3 fi exit q , d 3 , EdgeWorkList) od [7] for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od <ref> [8] </ref> end let [9] end case [10] case n the start node of procedure p : [11] for each c Callers (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d
Reference: 9. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven program analysis, </title> <type> Technical Report TR-93-15, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA (October 1993). </address>
Reference-contexts: , NodeWorkList) [3] while NodeWorkList do [4] Select and remove a node n, d from NodeWorkList [5] switch n [6] case n is a return-site node : [7] let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := <ref> [9] </ref> for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od <p> do Propagate (exit q , d 3 fi exit q , d 3 , EdgeWorkList) od [7] for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let <ref> [9] </ref> end case [10] case n the start node of procedure p : [11] for each c Callers (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, <p> The implementation is based on array indexing and linked lists, and involves neither term-unification nor term-matching. A different approach to obtaining demand versions of dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa, first for intraprocedural problems <ref> [9] </ref> and subsequently for interprocedural problems [10]. In their approach, for each demand of the form Is fact d in the solution set at flowgraph node x?, a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: 10. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven computation of interprocedural data flow, </title> <booktitle> in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> January 23-25, </month> <year> 1995), </year> <month> (January </month> <year> 1995). </year>
Reference-contexts: let c be the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od <ref> [10] </ref> BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d <p> The practical consequences of this extra work are explored in Section 4. The interesting aspect of the backwards traversal performed by IsMemberOfSolution is the way it ensures that only realizable paths are followed. This is accomplished by the call to BackwardTabulateSLRPs at line <ref> [10] </ref>, which occurs when the node n, d removed from NodeWorkList corresponds to a return-site node (i.e., n is a return-site node in G * ). <p> q , d 3 fi exit q , d 3 , EdgeWorkList) od [7] for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let [9] end case <ref> [10] </ref> case n the start node of procedure p : [11] for each c Callers (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, d 2 E <p> The implementation is based on array indexing and linked lists, and involves neither term-unification nor term-matching. A different approach to obtaining demand versions of dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa, first for intraprocedural problems [9] and subsequently for interprocedural problems <ref> [10] </ref>. In their approach, for each demand of the form Is fact d in the solution set at flowgraph node x?, a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: 11. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables [12], copy constant propagation <ref> [11, pp. 660] </ref>, and possibly-uninitialized variables. The IFDS framework was defined in [21], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> the call node that corresponds to n, and let p be the procedure called at c [8] EdgeWorkList := [9] for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) <ref> [11] </ref> for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, <p> Summary edges are recorded in the (global) set named Sum-maryEdge. After calling BackwardTabulateSLRPs, IsMemberOfSolution can continue its backward traversal across the newly discovered summary edges (line <ref> [11] </ref>). IsMemberOfSolution calls several auxiliary subprograms: function Callers (p) returns the set of call nodes that represent calls on p; procedures Propagate and Backward-TabulateSLRPs are shown in Figure 4. As discussed above, the purpose of BackwardTabulateSLRPs is to find summary edges, and to record them in the set named Sum-maryEdge. <p> This causes summary edge n7, g fi n8, g to be inserted into SummaryEdge (and causes several other edges to be inserted into PathEdge). 4. Node n7, g is inserted into VisitedNodes and NodeWorkList by procedure Visit (called at line <ref> [11] </ref>). 5. Node n7, g is removed from NodeWorkList; the default case is taken, and node n6, g is inserted into VisitedNodes and NodeWorkList. 6. Node n6, g is removed from NodeWorkList; the default case is taken, but there are no edges that satisfy the for-loop condition (line [20]). 7. <p> , EdgeWorkList) od [7] for each d 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let [9] end case [10] case n the start node of procedure p : <ref> [11] </ref> for each c Callers (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d
Reference: 12. <author> Giegerich, R., Moncke, U., and Wilhelm, R., </author> <title> Invariance of approximative semantics with respect to program transformations., pp. </title> <booktitle> 1-10 in Informatik-Fachberichte 50, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin Heidelberg New York (1981). </address>
Reference-contexts: We call this class of problems the interprocedural, finite, distributive, subset problems, or IFDS problems, for short. The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables <ref> [12] </ref>, copy constant propagation [11, pp. 660], and possibly-uninitialized variables. The IFDS framework was defined in [21], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> for each d such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od <ref> [12] </ref> end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : <p> 3 such that c, d 3 fi n, d 2 (E # SummaryEdge) do Propagate (c, d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let [9] end case [10] case n the start node of procedure p : [11] for each c Callers (p) do <ref> [12] </ref> let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d 4 E # do [14] if c, <p> All three algorithms were implemented in C and used with a front end that analyzes a C program and generates the corresponding exploded supergraph for two dataflow problems: the possibly-uninitialized variables problem that we have used as our running example, and the truly-live variables problem <ref> [12] </ref>.
Reference: 13. <author> Horwitz, S. and Teitelbaum, T., </author> <title> Generating editing environments based on relations and attributes, </title> <journal> ACM Transactions on Programming Languages and Systems 8(4) pp. </journal> <month> 577-608 (October </month> <year> 1986). </year>
Reference-contexts: such that exit p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let <ref> [13] </ref> end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each <p> d 3 fi exit p , d 1 , EdgeWorkList) od [8] end let [9] end case [10] case n the start node of procedure p : [11] for each c Callers (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c <ref> [13] </ref> for each d 4 , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d 4 E # do [14] if c, d 5 fi r, d 4 / SummaryEdge then [15] Insert c, d 5 fi r,
Reference: 14. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Bos-ton, MA, </address> <month> October 1-3, </month> <year> 1973), </year> <month> (October </month> <year> 1973). </year>
Reference-contexts: These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem <ref> [14] </ref> to the meet-over-all valid-paths solution of an interprocedural dataflow-analysis problem. <p> p , d fi n, d E # do Propagate (exit p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case <ref> [14] </ref> case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such <p> (p) do [12] let q be c's procedure, and r be the return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d 4 E # do <ref> [14] </ref> if c, d 5 fi r, d 4 / SummaryEdge then [15] Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3
Reference: 15. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler,Springer-Verlag, </editor> <address> New York, NY (1992). </address>
Reference-contexts: That definition is summarized below. The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis [23], with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters <ref> [15] </ref>. These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem [14] to the meet-over-all valid-paths solution of an interprocedural dataflow-analysis problem. <p> p , d fi exit p , d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : <ref> [15] </ref> for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, <p> return-site node that corresponds to c [13] for each d 4 , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d 4 E # do [14] if c, d 5 fi r, d 4 / SummaryEdge then <ref> [15] </ref> Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case [22]
Reference: 16. <author> Linton, M.A., </author> <title> Implementing relational views of programs, pp. </title> <booktitle> 132-140 in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <month> (April </month> <year> 1984). </year>
Reference-contexts: d, EdgeWorkList) od [10] BackwardTabulateSLRPs (EdgeWorkList) [11] for each d such that c, d fi n, d (E # SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do <ref> [16] </ref> for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] <p> , d 5 such that c, d 5 fi n, d 2 E # and exit p , d 1 fi r, d 4 E # do [14] if c, d 5 fi r, d 4 / SummaryEdge then [15] Insert c, d 5 fi r, d 4 into SummaryEdge <ref> [16] </ref> for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case [22] default : [23] for each m, d 3 such that m,
Reference: 17. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Research Center, Palo Alto, </institution> <note> CA (January 1980). </note>
Reference-contexts: SummaryEdge) do Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od <ref> [17] </ref> od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : <p> 5 fi r, d 4 / SummaryEdge then [15] Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od <ref> [17] </ref> fi [19] end let [21] end case [22] default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case [25] end switch [26] od procedure
Reference: 18. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> Technical Report 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, </institution> <address> Denmark (April 1994). </address>
Reference-contexts: In <ref> [18] </ref> we have shown that dataflow fact d holds at supergraph node n iff there is a realizable path in G # from node start main , 0 (which represents the fact that no dataflow facts hold at the start of procedure main) to node n, d. Example. <p> Visit (c, d, NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od <ref> [18] </ref> end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph <p> In each case, the time given is the worst-case time for a single demand. The details of the analysis of the running time of the Demand-Tabulation Algorithm can be found in <ref> [18] </ref>. The most efficient exhaustive algorithm known for the class of IFDS problems is the one given in [21].
Reference: 19. <author> Reps, T., </author> <title> Demand interprocedural program analysis using logic databases, in Applications of Logic Databases, </title> <editor> ed. R. </editor> <publisher> Ramakrishnan,Kluwer Academic Publishers, </publisher> <address> Boston, MA (1994). </address>
Reference-contexts: NodeWorkList) od [12] end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case <ref> [19] </ref> default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node <p> Node n9, g is inserted into VisitedNodes and into NodeWorkList by the call to Visit on line [2]. 2. Node n9, g is removed from NodeWorkList (line [4]); the default case (line <ref> [19] </ref>) is taken, and node n8, g is inserted into VisitedNodes and NodeWorkList by pro cedure Visit. 3. Node n8, g is removed from NodeWorkList; the case on line [6] is selected, and BackwardTabulateSLRPs is called for the first time. <p> r, d 4 / SummaryEdge then [15] Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi <ref> [19] </ref> end let [21] end case [22] default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case [25] end switch [26] od procedure Propagate (e:
Reference: 20. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, pp. </title> <booktitle> 389-403 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edin-burgh, Scotland, </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson,Springer-Verlag, </editor> <address> New York, NY (1994). </address>
Reference-contexts: end let [13] end case [14] case n is the start node of procedure p : [15] for each c Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : <ref> [20] </ref> for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] <p> Node n7, g is removed from NodeWorkList; the default case is taken, and node n6, g is inserted into VisitedNodes and NodeWorkList. 6. Node n6, g is removed from NodeWorkList; the default case is taken, but there are no edges that satisfy the for-loop condition (line <ref> [20] </ref>). 7. NodeWorkList is now empty, so UpdateReacha-bleNodes is called. There are no nodes in the set ReachableNodesRelevantToDemand, so no new nodes are inserted into ReachableNodes. 8. Finally, the return statement in IsMemberOfSolution is executed. Node n h h is not in ReachableNodes, so the function returns false. ` 3.1.
Reference: 21. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Precise interpro-cedural dataflow analysis via graph reachability, </title> <booktitle> in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> January 23-25, </month> <year> 1995), </year> <month> (January </month> <year> 1995). </year>
Reference-contexts: g It provides precise (meet over all interprocedurally valid paths) solutions to a large class of problems. g It has a polynomial worst-case cost for both a single demand and a sequence of all possible demands. g It has the same-worst-case-cost property with respect to the exhaustive algorithm given in <ref> [21] </ref>, which is currently the best exhaustive algorithm for the class of dataflow problems that can be handled precisely by our demand algorithm. The remainder of the paper is organized as follows: Section 2 provides background material. <p> The IFDS problems include all locally separable problemsthe interprocedural versions of classical bit-vector or gen-kill problems (e.g., reaching definitions, available expressions, and live variables)as well as non-locally-separable problems such as truly-live variables [12], copy constant propagation [11, pp. 660], and possibly-uninitialized variables. The IFDS framework was defined in <ref> [21] </ref>, where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. <p> Callers (p) do [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od <ref> [21] </ref> end case [22] end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] if n # ReachableNodes then Insert n # into ReachableNodesRelevantToDemand [27] else if n # / VisitedNodes then Insert n <p> This is necessary to guarantee that the Demand-Tabulation Algorithm has the same-worst-case-cost property with respect to the algorithm of <ref> [21] </ref> (see Section 3.2). Note that the traversal performed by UpdateReachableNodes only involves edges already visited by IsMemberOfSolution during the same invocation, so this does not increase the asymptotic cost of the algorithm when it is used for just a single demand. <p> / SummaryEdge then [15] Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi [19] end let <ref> [21] </ref> end case [22] default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case [25] end switch [26] od procedure Propagate (e: edge, EdgeWorkList: edge <p> In each case, the time given is the worst-case time for a single demand. The details of the analysis of the running time of the Demand-Tabulation Algorithm can be found in [18]. The most efficient exhaustive algorithm known for the class of IFDS problems is the one given in <ref> [21] </ref>. Its worst-case running times are almost identical to the times given above; the only difference is that for an intraprocedural, locally separable problem, the bound for the exhaustive algorithm is O (ED), while the bound for the Demand-Tabulation Algorithm is O (E). <p> The Same-Worst-Case-Cost Property We have designed the Demand-Tabulation Algorithm so that it has the same-worst-case-cost property with respect to the exhaustive algorithm of <ref> [21] </ref>. In particular, a call to IsMemberOfSolution can re-use the sets ReachableNodes, VisitedNodes, PathEdge, and SummaryEdge, whose values are preserved across calls. <p> information accumulated in sets PathEdge and Sum-maryEdge prevents procedure BackwardTabulateSLRPs from performing additional work, and the information accumulated in ReachableNodes and VisitedNodes prevents IsMemberOfSolution proper from performing additional work.) This is the same amount of work that could be performed in the worst case by the exhaustive algorithm given in <ref> [21] </ref>. Thus, the Demand-Tabulation Algorithm has the same-worst-case-cost property with respect to the exhaustive algorithm. <p> Experimental Results 4.1. Background to the Experiments We have carried out two experiments to compare the performance of the Demand-Tabulation Algorithm to that of the exhaustive algorithm of <ref> [21] </ref>, and two further experiments to study the trade-off between the benefit and overhead of the caching performed by the Demand-Tabulation Algorithm. <p> returns true as soon as it encounters a node of the form m, 0, does not maintain the set ReachableNodes, and reinitializes the set VisitedNodes to after each invocation of IsMemberOfSolution, but does preserve the sets PathEdge and SummaryEdge across calls to IsMemberOfSolution), and (3) the exhaustive algorithm reported in <ref> [21] </ref>. All three algorithms were implemented in C and used with a front end that analyzes a C program and generates the corresponding exploded supergraph for two dataflow problems: the possibly-uninitialized variables problem that we have used as our running example, and the truly-live variables problem [12].
Reference: 22. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference-contexts: [16] for each d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case <ref> [22] </ref> end switch [23] od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] if n # ReachableNodes then Insert n # into ReachableNodesRelevantToDemand [27] else if n # / VisitedNodes then Insert n # into VisitedNodes; <p> [15] Insert c, d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case <ref> [22] </ref> default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case [25] end switch [26] od procedure Propagate (e: edge, EdgeWorkList: edge set) begin [27]
Reference: 23. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interpro-cedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: The IFDS framework was defined in [21], where we presented an efficient exhaustive algorithm for solving IFDS problems. That definition is summarized below. The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis <ref> [23] </ref>, with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters [15]. <p> d such that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch <ref> [23] </ref> od [24] UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] if n # ReachableNodes then Insert n # into ReachableNodesRelevantToDemand [27] else if n # / VisitedNodes then Insert n # into VisitedNodes; Insert n # <p> d 5 fi r, d 4 into SummaryEdge [16] for each d 3 such that r, d 4 fi exit q , d 3 PathEdge do Propagate (c, d 5 fi exit q , d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case [22] default : <ref> [23] </ref> for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case [25] end switch [26] od procedure Propagate (e: edge, EdgeWorkList: edge set) begin [27] if e /
Reference: 24. <author> Ullman, J.D., </author> <title> Principles of Database and Knowledge-Base Systems, Volume II: The New Technologies, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD (1989). </address>
Reference-contexts: that c, d fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od <ref> [24] </ref> UpdateReachableNodes () [25] return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] if n # ReachableNodes then Insert n # into ReachableNodesRelevantToDemand [27] else if n # / VisitedNodes then Insert n # into VisitedNodes; Insert n # into NodeWorkList <p> exit q , d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case [22] default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od <ref> [24] </ref> end case [25] end switch [26] od procedure Propagate (e: edge, EdgeWorkList: edge set) begin [27] if e / PathEdge then Insert e into PathEdge; Insert e into EdgeWorkList fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Example.
Reference: 25. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year> <title> To Appear In: </title> <booktitle> Proc. of the 3rd ACM SIGSOFT Symp. on the Foundations of Software Engineering (October 1995) </booktitle>
Reference-contexts: fi n, d E # do Visit (c, d, NodeWorkList) od [17] od [18] end case [19] default : [20] for each m, d such that m, d fi n, d E # do Visit (m, d, NodeWorkList) od [21] end case [22] end switch [23] od [24] UpdateReachableNodes () <ref> [25] </ref> return (n h h ReachableNodes) end procedure Visit (n # : exploded supergraph node, NodeWorkList: node set) begin [26] if n # ReachableNodes then Insert n # into ReachableNodesRelevantToDemand [27] else if n # / VisitedNodes then Insert n # into VisitedNodes; Insert n # into NodeWorkList fi [28] fi <p> d 3 , EdgeWorkList) od [17] fi [19] end let [21] end case [22] default : [23] for each m, d 3 such that m, d 3 fi n, d 2 E # do Propagate (m, d 3 fi exit p , d 1 , EdgeWorkList) od [24] end case <ref> [25] </ref> end switch [26] od procedure Propagate (e: edge, EdgeWorkList: edge set) begin [27] if e / PathEdge then Insert e into PathEdge; Insert e into EdgeWorkList fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Example.
References-found: 25

