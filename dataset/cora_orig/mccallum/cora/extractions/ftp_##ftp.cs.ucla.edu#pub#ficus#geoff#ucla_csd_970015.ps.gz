URL: ftp://ftp.cs.ucla.edu/pub/ficus/geoff/ucla_csd_970015.ps.gz
Refering-URL: http://ficus-www.cs.ucla.edu/project-members/geoff/pubs.html
Root-URL: http://www.cs.ucla.edu
Title: Seer: Predictive File Hoarding for Disconnected Mobile Operation  
Author: Geoffrey H. Kuenning Gerald J. Popek, co-chair Wesley W. Chu, co-chair Leonard Kleinrock Rajive Bagrodia Bennett Lientz 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Computer Science  Thesis committee:  
Date: May, 1997  
Address: Los Angeles  
Affiliation: University of California,  UCLA Computer Science Department  
Pubnum: Technical Report UCLA-CSD-970015  
Abstract-found: 0
Intro-found: 1
Reference: [Akyurek and Salem 1995] <author> Sedat Akyurek and Kenneth Salem. </author> <title> "Adaptive Block Rearrangement." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(2) </volume> <pages> 89-121, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Recent studies <ref> [Akyurek and Salem 1995] </ref> have suggested that dramatic performance improvements can be achieved by rearranging blocks on the disk in response to access patterns.
Reference: [Alexandrov et al. 1997] <author> Albert D. Alexandrov, Maximilian Ibel, Klaus E. Schauser, and Chris J. Scheiman. </author> <title> "Extending the Operating System at the User-Level: the Ufo Global File System." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 77-90, </pages> <address> Anaheim, California, </address> <month> January </month> <year> 1997. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Options include: 1. Modify the application to report the necessary information. 2. Run the application under a tracing or debugging facility, interrupting it at appropriate times to collect system calls and their parameters <ref> [Alexandrov et al. 1997] </ref>. 3. Implement a pseudo-NFS file system that traces I/O operations as a side effect of executing them [Duch amp 1997]. 4. Replace the shared library containing the system-call routines with one that collects the information. 5. Modify the operating-system kernel to collect the information.
Reference: [Alonso et al. 1990] <author> Rafael Alonso, Daniel Barbara, and Luis L. Cova. </author> <title> "Using Stashing to Increase Node Autonomy in Distributed File Systems." </title> <booktitle> In Proceedings of the Ninth IEEE Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pp. 12-21, </pages> <month> October </month> <year> 1990. </year>
Reference: [Baker et al. 1991] <author> Mary G. Baker, John H. Hartman, Michael D. Kupfer, Ken W. Sherriff, and John K. Ousterhout. </author> <title> "Measurements of a Distributed File System." </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 198-211. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference: [Beresford 1995] <author> Mike Beresford, </author> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: Many of these applications pose significant research problems of their own. For example, a Web predictor should be able to draw inferences even in the face of the daily link-name changes used by a number of information providers. 6 This idea was first suggested by Mike Beresford <ref> [Beresford 1995] </ref>. 10.4. ANCILLARY RESEARCH 119 10.4 Ancillary Research The development of Seer has raised several side issues that, while not directly relevant, are nevertheless interesting in a larger context. Hoard Residence Lifetimes.
Reference: [Blaze and Alonso 1992] <author> Matthew Blaze and Rafael Alonso. </author> <title> "Dynamic Hierarchical Caching for Large-Scale Distributed File Systems." </title> <booktitle> In Proceedings of the Twelfth International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 521-528, </pages> <month> June </month> <year> 1992. </year>
Reference: [Bock 1974] <author> Hans Hermann Bock. </author> <title> Automatische Klassifikation: </title> <institution> Theoretische und praktische Methoden zur Gruppierung und Strukturierung von Daten. Vandenhoeck & Ruprecht, Gottingen, Germany, </institution> <year> 1974. </year>
Reference: [Buck and Coyne 1991] <author> A. Lester Buck and Robert A. Coyne, Jr. </author> <title> "Dynamic Hierarchies and Optimization in Distributed Storage Systems." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 85-91, </pages> <address> Monterey, California, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Cao et al. 1994] <author> Pei Cao, Edward W. Felten, , and Kai Li. </author> <title> "Implementation and Performance of Application-Controlled File Caching." </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pp. 165-178. </pages> <publisher> USENIX, </publisher> <month> November </month> <year> 1994. </year>
Reference: [Curewitz et al. 1993] <author> Kenneth M. Curewitz, P. Krishnan, and Jeffrey Scott Vitter. </author> <title> "Practical Prefetching via Data Compression." </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pp. 257-266. </pages> <note> ACM, 1993. Also available as SIGMOD Record 22, </note> <month> 2 (June </month> <year> 1993). </year>
Reference: [Drakopoulos and Merges 1991] <author> Elias Drakopoulos and Matt Merges. </author> <title> "Performance Study of Client-Server Storage Systems." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 67-72, </pages> <address> Monterey, California, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Duchamp 1997] <author> Dan Duchamp. </author> <title> "A Toolkit Approach to Partially Connected Operation." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 305-318, </pages> <address> Anaheim, California, </address> <month> January </month> <year> 1997. </year> <title> USENIX. </title> <type> 149 150 REFERENCES </type>
Reference: [Duran and Odell 1974] <author> Benamin S. Duran and Patrick L. Odell. </author> <title> Cluster Analysis: A Survey, </title> <booktitle> volume 100 of Lecture Notes in Economics and Mathematical Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Iterative clustering algorithms are amenable to this approach. We would like to investigate adapting one of these algorithms to Seer's needs, in hopes of improving the performance at clustering time. Hierarchical Clustering. Clustering algorithms are generally divided into two classes: hierarchical and non-hierarchical <ref> [Duran and Odell 1974, Hartigan 1975, Spath 1980] </ref>. The former class naturally produces a tree of "nested" clusters, generally rooted by a single cluster containing all objects.
Reference: [Ebling et al. 1994] <author> Maria R. Ebling, Lily B. Mummert, and David C. Steere. </author> <title> "Overcoming the Network Bottleneck in Mobile Computing." </title> <booktitle> In Proceedings of the Workshop on Mobile Computing Systems and Applications 1994, </booktitle> <pages> pp. 34-36, </pages> <month> December </month> <year> 1994. </year>
Reference: [Floyd and Ellis 1989] <author> Richard A. Floyd and Carla Schlatter Ellis. </author> <title> "Directory Reference Patterns in Hierarchical File Systems." </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 238-247, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: One way to find boundaries without user interaction might be to detect a reference to a file that has been unused for a relatively long time. Categorizing Files by Hand. A similar idea, first suggested in <ref> [Floyd and Ellis 1989] </ref>, is to hand-categorize users and their files into gross major categories, and then to take advantage of these categories to apply more specialized algorithms for project detection.
Reference: [Foglesong et al. 1990] <author> Joy Foglesong, George Richmond, Loellyn Cassell, Carole Hogan, John Kordas, and Michael Nemanic. </author> <title> "The Livermore Distributed Storage System: Implementation and Experiences." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Tenth IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 18-25, </pages> <address> Monterey, California, May 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Foster and Habermehl 1991] <author> Antony Foster and David Habermehl. </author> <title> "Renaissance: Managing the Network Computer and its Storage Requirements." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 3-10, </pages> <address> Monterey, California, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Garey and Johnson 1979] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Co., </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: Cluster analysis is compute-intensive. If a cluster-quality metric is available, optimal clustering (assigning objects to an arbitrary set of clusters such that the metric is maximized) has been shown to be NP-hard <ref> [Garey and Johnson 1979, p. 281] </ref>.
Reference: [Gibson et al . 1992] <author> Garth A. Gibson, R. Hugo Patterson, and Mahadev Satyanarayanan. </author> <title> "Disk Reads with DRAM Latency." </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 126-131, </pages> <address> Key Biscayne, FL, </address> <month> April </month> <year> 1992. </year> <note> IEEE. </note>
Reference: [Goel 1996] <author> Ashvin Goel, </author> <year> 1996. </year> <type> Personal communication. </type>
Reference-contexts: This feedback could then be used to modify the parameters of the semantic-distance or clustering algorithms so that they would perform better in the future. Considering Communication Costs. Currently, Seer assumes that communication is cheap when changing hoard contents. Ashvin Goel <ref> [Goel 1996] </ref> has noted that if the hoard is being updated over a slow link, file size might be an important factor in the equation. <p> ANCILLARY RESEARCH 119 10.4 Ancillary Research The development of Seer has raised several side issues that, while not directly relevant, are nevertheless interesting in a larger context. Hoard Residence Lifetimes. Ashvin Goel has suggested <ref> [Goel 1996] </ref> that it would be interesting to track statistics on how long files spend in and out of the hoard. There are actually two distributions of interest: the time spent in the hoard, and the time spent as a member of the daily or weekly working set.
Reference: [Griffioen and Appleton 1994] <author> James Griffioen and Randy Appleton. </author> <title> "Reducing File System Latency Using a Predictive Approach." </title> <booktitle> In Proceedings of the Summer USENIX Conference Proceedings, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1994. </year> <note> USENIX. Also available as University of Kentucky Technical Report CS247-94. </note>
Reference-contexts: We will review a previous approach to summarizing the information in H before presenting our own methods. 3.3. THE DISTANCE HISTOGRAM 29 3.3.1 Appleton's Probabilities Appleton <ref> [Griffioen and Appleton 1994] </ref> has defined a set of probabilities characterizing which file is likely to be accessed soon, where "soon" is a parameter of the algorithm.
Reference: [Grimsrud et al . 1993] <author> Knut Stener Grimsrud, James K. Archibald, and Brent E. Nelson. </author> <title> "Multiple Prefetch Adaptive Disk Caching." </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(1) </volume> <pages> 88-103, </pages> <month> February </month> <year> 1993. </year>
Reference: [Gunter 1995] <author> Michial A. Gunter, </author> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: avoid multiplying by zero, we increment ` in defining the geometric mean lifetime distance: 5 g L fl = N fl `2D fl g L $ = N $ `2D $ g L ! = N ! Y (1 + `) 4 This example was first suggested by Michial Gunter <ref> [Gunter 1995] </ref>. 5 This modification does not affect the validity of the measure, since for our purposes we are interested in relative, rather than absolute, values. 3.3.
Reference: [Gunter 1997] <author> Michial Allen Gunter. "Rumor: </author> <title> A Reconciliation-Based User-Level Optimistic Replication System for Mobile Computers.". </title> <type> Master's thesis, </type> <institution> University of California, </institution> <address> Los Angeles, Los Angeles, CA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: a selected subset) * Seer-independent hoard changes * Conflict detection * Status queries * Location queries * Command batching * Disconnected queries In addition to implementing only limited capabilities, Cheap Rumor does not address some of the more subtle and complex issues handled by the Ficus [Guy 1991] and Rumor <ref> [Gunter 1997, Reiher et al. 1996] </ref> systems. For example, Rumor goes to great lengths to detect and properly process rare pathological cases involving files that have changed and had their modification times reset during a 1-second window while Rumor is reading their contents.
Reference: [Guy 1991] <author> Richard G. Guy. Ficus: </author> <title> A Very Large Scale Reliable Distributed File System. </title> <type> Ph.D. dissertation, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> June </month> <year> 1991. </year> <note> Also available as UCLA technical report CSD-910018. </note>
Reference-contexts: In particular, shared data is the lifeblood of modern interconnected computing. A natural solution to the problem, then, is to simply store replicas of all the shared data, using a system such as Ficus <ref> [Guy 1991, Heidemann et al . 1992] </ref>, Rumor [Reiher et al . 1996], or Coda [Kistler and Satyanarayanan 1992]. This approach assumes that the portable machine has enough free space to store this data. <p> Much of the effort in Coda was directed toward replication, specifically the problem of allowing disconnected writes as in Ficus <ref> [Guy 1991, Heidemann et al . 1992] </ref>, but its most significant contribution was the provision of mechanisms that, while connected, could semi-automatically hoard files that might be used after disconnection. The Coda hoard manager decided which files to keep by integrating LRU data 9.2. <p> and a slave stores a selected subset) * Seer-independent hoard changes * Conflict detection * Status queries * Location queries * Command batching * Disconnected queries In addition to implementing only limited capabilities, Cheap Rumor does not address some of the more subtle and complex issues handled by the Ficus <ref> [Guy 1991] </ref> and Rumor [Gunter 1997, Reiher et al. 1996] systems. For example, Rumor goes to great lengths to detect and properly process rare pathological cases involving files that have changed and had their modification times reset during a 1-second window while Rumor is reading their contents.
Reference: [Hartigan 1975] <author> John A. Hartigan. </author> <title> Clustering Algorithms. </title> <publisher> Wiley, </publisher> <address> New York, NY, </address> <year> 1975. </year>
Reference-contexts: Iterative clustering algorithms are amenable to this approach. We would like to investigate adapting one of these algorithms to Seer's needs, in hopes of improving the performance at clustering time. Hierarchical Clustering. Clustering algorithms are generally divided into two classes: hierarchical and non-hierarchical <ref> [Duran and Odell 1974, Hartigan 1975, Spath 1980] </ref>. The former class naturally produces a tree of "nested" clusters, generally rooted by a single cluster containing all objects.
Reference: [Heidemann et al. 1992] <author> John S. Heidemann, Thomas W. Page, Jr., Richard G. Guy, and Gerald J. Popek. </author> <title> "Primarily Disconnected Operation: Experiences with Ficus." </title> <booktitle> In Proceedings of the Second Workshop on Management of Replicated Data, </booktitle> <pages> pp. 2-5. </pages> <institution> University of California, Los Angeles, IEEE, </institution> <month> November </month> <year> 1992. </year>
Reference: [Hogan et al. 1990] <author> Carole Hogan, Loellyn Cassell, Joy Foglesong, John Kordas, Michael Nemanic, and George Richmond. </author> <title> "The Livermore Distributed Storage System: Requirements and Overview." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Tenth IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 6-17, </pages> <address> Monterey, California, May 1990. </address> <publisher> IEEE Computer Society Press. </publisher> <address> REFERENCES 151 </address>
Reference: [Honeyman et al. 1992] <author> Peter Honeyman, Larry Huston, Jim Rees, and Dave Bachmann. </author> <title> "The Little Work Project." </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 11-14. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1992. </year>
Reference: [Howard et al . 1988] <author> John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanaraya-nan, Robert Sidebotham, and Michael West. </author> <title> "Scale and Performance in a Distributed File System." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Because Coda is the system most often discussed in the literature, we will devote more attention to it than to other related work. Overview of Coda Coda was an outgrowth of the Andrew File System (AFS) <ref> [Howard et al . 1988] </ref>, which was an early distributed file system that did not support optimistic replication. A major goal of the project was to extend AFS to the mobile environment by supporting disconnected operation [Kistler 1993, Section 2.2.1].
Reference: [Huston and Honeyman 1993] <author> L. B. Huston and Peter Honeyman. </author> <title> "Disconnected Operation for AFS." </title> <booktitle> In Proceedings of the USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <pages> pp. 1-10. </pages> <publisher> USENIX, </publisher> <year> 1993. </year>
Reference-contexts: For example, Coda [Kistler 1993] requires the user to build a list of all important files, together with numerical values that indicates their relative worth. Face [Alonso et al . 1990] and Little Work <ref> [Honeyman et al . 1992, Huston and Honeyman 1993] </ref> are even more invasive, suggesting that immediately before disconnection the user must actually access all files that will be needed until the next time a connection is achieved (Face also supports user specification in the manner of Coda, but with less flexibility). <p> There are currently five hoarding managers: LRU The LRU manager fills the hoard on a simple LRU basis. This hoarding algorithm is the same as that used by Little Work <ref> [Huston and Honeyman 1993] </ref>. Bounded LRU The bounded LRU manager modifies plain LRU by allowing the user to provide an instruction file that specifies bounds on the perceived LRU age of particular files. <p> Previous systems have devoted a major part of their implementation effort to solving this single problem <ref> [Kistler 1993, Huston and Honeyman 1993] </ref>. However, with the advent of generalized replication systems such as Ficus, Coda, and Rumor, Seer is able to separate the problem of choosing hoard contents from the problem of managing a selectively replicated file system. <p> level of user involvement, the system made major contributions by implementing the first client-server optimistic-replication system, and by demonstrating that disconnected operation could work at all. 9.2.2 Face, Little Work, and Laputa Besides Coda, disconnected operation has also been supported in Face [Alonso et al . 1990] and Little Work <ref> [Honeyman et al . 1992, Huston and Honeyman 1993] </ref>. However, the developers of these systems have concentrated primarily on the problem of optimistic file replication, and only secondarily on hoard loading. Little Work uses a simple LRU scheme for choosing the files to be cached. <p> However, the developers of these systems have concentrated primarily on the problem of optimistic file replication, and only secondarily on hoard loading. Little Work uses a simple LRU scheme for choosing the files to be cached. Before a user disconnects, he or she is expected <ref> [Huston and Honeyman 1993] </ref> : : : only to use the laptop on a network for a Little While: : : If she performs work similar to what she intends to do on the road, the cache will contain all the files necessary to support her needs.
Reference: [Jain 1991] <author> Raj Jain. </author> <title> The Art of Computer Systems Performance Analysis. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The experiments were divided into two groups so that they could be run in parallel on two different machines. Within each group, experiments were chosen at random (again using /dev/random) to avoid introducing errors due to unexpected trends in experimental conditions <ref> [Jain 1991] </ref>. Simulation of Hand Hoard Management Under our simulation methodology, the three parameterized LRU-style managers (weighted, bounded, and linear LRU) performed more poorly than they would if the user were actively managing the hoard, since the control information is not modified for each disconnection period.
Reference: [Jarvis and Patrick 1973] <author> R. A. Jarvis and E. A. Patrick. </author> <title> "Clustering using a similarity measure based on shared near neighbors." </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-22(11):1025-1034, </volume> <month> November </month> <year> 1973. </year>
Reference-contexts: number of members in each cluster, while finding the new centroids of a cluster divided in two requires examining every member.) For this reason, divisive methods are rarely used. 4.1.2 The Algorithm of Jarvis and Patrick The algorithm used by Seer is based on one developed by Jarvis and Patrick <ref> [Jarvis and Patrick 1973] </ref>. Because the Jarvis and Patrick algorithm is both simpler and more generalized than that used in Seer, we summarize it here before describing our modification. The algorithm operates in two phases: neighbor finding and clustering.
Reference: [Kistler 1993] <author> James Jay Kistler. </author> <title> Disconnected Operation in a Distributed File System. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Hand Specification Several previous researchers have solved the problem of choosing files by leaving it up to the user. For example, Coda <ref> [Kistler 1993] </ref> requires the user to build a list of all important files, together with numerical values that indicates their relative worth. <p> Many modern applications use files of which the user is completely unaware [Kuenning 1994]. Kistler's dissertation tells of a incident in which even expert computer scientists were unable to explain why a windowing system was sometimes unusable due to missing files <ref> [Kistler 1993, p. 193] </ref>. If a computer researcher cannot do the job accurately, it is certain that the average businessman will be helpless in the face of such an exacting task. <p> replicated on two or more computers, and the system would be required to automatically resolve these conflicts after the fact in a manner similar to the Coda or Ficus distributed file systems [Kumar and Satyanarayanan 1995, Reiher et al . 1994], to force the user to resolve them by hand <ref> [Kistler 1993] </ref>, or to limit writing to only one user. We examined conflicting writes within a 24-hour period (corresponding to taking a machine home overnight) and a 7-day period (corresponding to traveling with a machine). An attention shift occurs when a single user radically changes his or her working set. <p> Previous systems have devoted a major part of their implementation effort to solving this single problem <ref> [Kistler 1993, Huston and Honeyman 1993] </ref>. However, with the advent of generalized replication systems such as Ficus, Coda, and Rumor, Seer is able to separate the problem of choosing hoard contents from the problem of managing a selectively replicated file system. <p> SYSTEM DESIGN 5.5.1 Other Replication Substrates Some replication substrates (e.g., Coda) do not provide all of the necessary features listed above. Nevertheless, such systems can sometimes be supported by loosening Seer's control. For example, Seer can be configured to produce .hoardrc files <ref> [Kistler 1993, Section 5.3.1.4] </ref> that can then be loaded into Coda's hoard manager. <p> need to store a directory both when connected and when disconnected depends on the underlying replication system: some may require all directories to be present to support remote access to files not hoarded on the portable computer, and most require that all directories leading to a hoarded file be present <ref> [Kistler 1993, Ratner 1995] </ref> so that the file itself can be reached. The directory structure can also convey valuable information to the user. <p> Some qualitative information is given in both <ref> [Kistler 1993] </ref> and [Satyanarayanan et al. 1993], but there are no tables or graphs showing the effectiveness of the algorithms. 1 A list of suggested evaluation methods is given in [Satyanarayanan et al. 1993, Section 7.2], although there is no indication whether any were ever implemented. <p> Real-World Deployment The second candidate for experimentation is to simply deploy the system in a real-world environment, let users live with it, and record the results. In the past, this approach has been used primarily for qualitative evaluation <ref> [Kistler 1993, Tait et al. 1995] </ref>. The major advantage of this method is that it inarguably reflects the actual behavior of real users. <p> Overview of Coda Coda was an outgrowth of the Andrew File System (AFS) [Howard et al . 1988], which was an early distributed file system that did not support optimistic replication. A major goal of the project was to extend AFS to the mobile environment by supporting disconnected operation <ref> [Kistler 1993, Section 2.2.1] </ref>. Coda used a client/server architecture, with the servers replicated for reliability. Clients, which could be fixed workstations or portable machines, cached whole files retrieved from the servers. <p> Before disconnection, Coda attempted to fill the hoard with files that would be useful to the user. These files were chosen according to a formula <ref> [Kistler 1993, Section 5.3.2.1] </ref> that combined LRU information with user-provided adjustments. The hoard was automatically filled ("walked") at regular intervals, or alternatively the user could explicitly request that the hoard be filled. The hoard was generally kept as full as possible, within the limits of local disk space. <p> There was a capability for recursive specification, so that the same adjustment could be applied to an entire directory tree. The Coda Hoarding Formula As mentioned above, Coda combined LRU information on all files with user-provided adjustments from one or more .hoardrc files. The formula in <ref> [Kistler 1993] </ref> gives p f , the hoarding priority of file f , in terms of h f , the user-specified hoard priority for that file, and a f , the time (in references) since the file was last referenced. a f is set to 0 at the most recent reference <p> each other and given these priorities, Coda would tend to keep C in preference to A, which again probably reflects the user's intentions. (But if the files were separated by 4000 references, the user-specified priorities would dominate, regardless of reference order.) Published Experience with Coda The published results on Coda <ref> [Kistler and Satyanarayanan 1992, Kistler 1993, Satyanarayanan et al . 1993] </ref> have given relatively few quantitative results on the success of the hoarding methods. <p> Most of the material in <ref> [Kistler 1993] </ref> is concerned with the implementation of disconnected operation, and all of the quantitative results in both [Kistler 1993] and [Satyanarayanan et al. 1993] involve measurements of the performance of the disconnection/reintegration process and of user working sets (which are not significantly affected by disconnection, though as discussed in Chapter <p> Most of the material in <ref> [Kistler 1993] </ref> is concerned with the implementation of disconnected operation, and all of the quantitative results in both [Kistler 1993] and [Satyanarayanan et al. 1993] involve measurements of the performance of the disconnection/reintegration process and of user working sets (which are not significantly affected by disconnection, though as discussed in Chapter 2 they have a large impact on the feasibility of hoarding). <p> The problem is that modern applications make use of numerous files, many of which are stored in multiple directories. The user is often unaware of the complete list of files involved in running a particular application. 2 The developers of Coda were aware of this problem; for example, <ref> [Kistler 1993, Section 5.3.1.4] </ref> discusses the challenges of generating cache "hints" for the benefit of a hoard manager: The cost of generating cache hints can be significant. <p> Hint generation may involve scanning directories, gratuitously executing programs, even examining source code. 2 For example, <ref> [Kistler 1993, p. 193] </ref> relates a situation in which the windowing system would hang when started in disconnected mode; this turned out to be because fonts were stored in a compressed format, requiring the uncompress program to use them. <p> Other options allowed the user more low-level control of the hoard contents. Spy Utility also introduced "generalized bookends," which were a convenient way for the user to inform the system of the beginning and end of a user-defined activity|for example, an edit-compile-debug cycle. This automation of Coda's spy program <ref> [Kistler 1993] </ref> was an improvement on that system's requirement for expertise, though it still placed more burden on the user than one would like. Spy Utility was a major step forward, but was still less ambitious than Seer.
Reference: [Kistler and Satyanarayanan 1992] <author> James J. Kistler and Mahadev Satyanarayanan. </author> <title> "Disconnected Operation in the Coda File System." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 3-25, </pages> <year> 1992. </year>
Reference-contexts: In particular, shared data is the lifeblood of modern interconnected computing. A natural solution to the problem, then, is to simply store replicas of all the shared data, using a system such as Ficus [Guy 1991, Heidemann et al . 1992], Rumor [Reiher et al . 1996], or Coda <ref> [Kistler and Satyanarayanan 1992] </ref>. This approach assumes that the portable machine has enough free space to store this data. In general, even with the huge disks that are becoming available in small form factors, this assumption will not be true. <p> each other and given these priorities, Coda would tend to keep C in preference to A, which again probably reflects the user's intentions. (But if the files were separated by 4000 references, the user-specified priorities would dominate, regardless of reference order.) Published Experience with Coda The published results on Coda <ref> [Kistler and Satyanarayanan 1992, Kistler 1993, Satyanarayanan et al . 1993] </ref> have given relatively few quantitative results on the success of the hoarding methods. <p> The earlier paper <ref> [Kistler and Satyanarayanan 1992] </ref> presents the material at a high conceptual level. These results are discussed further below. Several possible metrics for evaluating a hoarding system are suggested in [Satyanarayanan et al. 1993]. All of these metrics are repeated and discussed in Section 7.1.2 of this dissertation (p. 76). <p> It is invoked either periodically or when the number of deleted files grows beyond a threshold parameter. Save The save manager periodically checkpoints the file table to disk, to protect against crashes. Initially, we followed the design of Coda <ref> [Kistler and Satyanarayanan 1992] </ref> in allowing management to be initiated either periodically or by explicit user request. However, we found that the periodic feature was not useful in our environment, and it added unnecessary system load, so we disabled it.
Reference: [Kleinrock 1994] <author> Leonard Kleinrock, </author> <year> 1994. </year> <type> Personal communication. </type>
Reference-contexts: This section discusses some of the more interesting applications of the concept of prediction. Directory Reorganization. Leonard Kleinrock has suggested <ref> [Kleinrock 1994] </ref> that Seer could be used as an aid to directory reorganization.
Reference: [Kohl et al . 1993] <author> John T. Kohl, Carl Staelin, and Michael Stonebraker. "HighLight: </author> <title> Using a Log-structured File System for Tertiary Storage Management." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 435-447. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1993. </year>
Reference: [Korner 1990] <author> K. Korner. </author> <title> "Intelligent Caching for Remote File Service." </title> <booktitle> In Proceedings of the Tenth International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1990. </year>
Reference: [Kotz and Ellis 1990] <author> David D. Kotz and Carla Schlatter Ellis. </author> <title> "Practical Prefetching Techniques for Parallel File Systems." </title> <booktitle> In Proceedings of the Tenth International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 182-189, </pages> <address> Miami Beach, Florida, </address> <month> December </month> <year> 1990. </year>
Reference: [Krishna et al. 1997] <author> P. Krishna, N. H. Vaidya, M. Chatterjee, and D. K. Pradhan. </author> <title> "A Cluster-based Approach for Routing in Dynamic Networks." </title> <journal> ACM Computer Communication Review, </journal> <volume> 27(2) </volume> <pages> 49-64, </pages> <month> April </month> <year> 1997. </year>
Reference: [Kroeger 1996] <author> Tom Kroeger, </author> <year> 1996. </year> <type> Personal communication. </type>
Reference-contexts: However, further research will be needed to develop algorithms for implementing these concepts. Analyzing Variance in Semantic Distance. Tom Kroeger <ref> [Kroeger 1996] </ref> has suggested that the cor-relator could dynamically monitor the variance of semantic-distance values, and then use the variance to estimate the reliability of the measurement. Semantic distances with low coefficients of variation would be given more weight in the clustering algorithm. Weighting Distance in Process Trees.
Reference: [Kroeger and Long 1996] <author> Thomas M. Kroeger and Darrell D. E. </author> <title> Long. "Predicting File System Actions from Prior Events." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 319-328, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1996. </year> <booktitle> USENIX. </booktitle>
Reference: [Kuenning 1994] <author> Geoffrey H. Kuenning. </author> <title> "Design of the SEER Predictive Caching System." </title> <booktitle> In Proceedings of the Workshop on Mobile Computing Systems and Applications, </booktitle> <address> Santa Cruz, CA, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: In the first place, hand specification is inconvenient, distracting the user from the real work that is the point of using a portable computer. In the second, hand specification is difficult and error-prone. Many modern applications use files of which the user is completely unaware <ref> [Kuenning 1994] </ref>. Kistler's dissertation tells of a incident in which even expert computer scientists were unable to explain why a windowing system was sometimes unusable due to missing files [Kistler 1993, p. 193]. <p> Again, however, users have not proven receptive to amount of work required to use this system. In addition, we have found it difficult to express the linear transformation in intuitively simple terms. Clustering The clustering manager uses an entirely new approach to making hoarding decisions, first described in <ref> [Kuenning 1994] </ref>. Semantic distance and information from external investigators are integrated by a clustering algorithm, which generates overlapping clusters that represent the user's projects. Hoarding decisions are then made based an LRU age that is representative of the entire cluster. <p> The independent streams from these activities are intermixed when observed by Seer, and create incorrect and spurious file relationships if not properly handled. We had originally hypothesized <ref> [Kuenning 1994] </ref> that the data reductions discussed in Section 3.3 (p. 28) would provide a noise-filtering mechanism adequate to eliminate the effects of these spurious relationships.
Reference: [Kuenning 1995] <author> Geoffrey H. Kuenning. "Kitrace: </author> <title> Precise Interactive Measurement of Operating Systems Kernels." </title> <journal> Software|Practice and Experience, </journal> <volume> 25(1) </volume> <pages> 1-22, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: All measurements were carried out on a Texas Instruments Travelmate TM 6030, which is a Pentium-based laptop machine. The particular configuration used operated at 133 MHz and had 64 Mb of RAM, running the Linux operating system. Elapsed times within the kernel were collected using the kitrace measurement tool <ref> [Kuenning 1995] </ref>. 8.3.1 Kernel Performance System Calls As discussed in Section 5.2, p. 52, a small hook is placed into the operating-system kernel to allow Seer to observe selected system calls.
Reference: [Kuenning et al. 1994] <author> Geoffrey H. Kuenning, Gerald J. Popek, and Peter Reiher. </author> <title> "An Analysis of Trace Data for Predictive File Caching in Mobile Computing." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 291-306. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1994. </year> <note> 152 REFERENCES </note>
Reference-contexts: Analysis of the data we have collected shows that these characteristics are present in a number of different application domains. 1 Most of the material in this chapter appeared previously as <ref> [Kuenning et al. 1994] </ref>. 7 8 CHAPTER 2. FEASIBILITY 2.2 Methodology We collected our traces at Locus Computing Corporation, a software development and consulting firm, during the summer of 1993.
Reference: [Kumar and Satyanarayanan 1993] <author> Puneet Kumar and Mahadev Satyanarayanan. </author> <title> "Log-Based Directory Resolution in the Coda File System." </title> <booktitle> In Proceedings of the Second International Conference on Parallel and Distributed Information Systems, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [Kumar and Satyanarayanan 1995] <author> Puneet Kumar and Mahadev Satyanarayanan. </author> <title> "Flexible and Safe Resolution of File Conflicts." </title> <booktitle> In Proceedings of the USENIX Conference Proceedings, </booktitle> <address> p. xxx, New Orleans, LA, </address> <month> January </month> <year> 1995. </year> <title> USENIX. [Kure 1988] ivind Kure. "Optimization of File Migration in Distributed Systems." </title> <type> Technical Report UCB/CSD 88/413, </type> <institution> University of California, Berkeley, </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: In a mobile environment, a conflicted file might be replicated on two or more computers, and the system would be required to automatically resolve these conflicts after the fact in a manner similar to the Coda or Ficus distributed file systems <ref> [Kumar and Satyanarayanan 1995, Reiher et al . 1994] </ref>, to force the user to resolve them by hand [Kistler 1993], or to limit writing to only one user.
Reference: [Lazowska et al. 1986] <author> Edward D. Lazowska, John Zahorjan, David R. Cheriton, and Willy Zwaenepoel. </author> <title> "File Access Performance of Diskless Workstations." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(3) </volume> <pages> 238-268, </pages> <month> August </month> <year> 1986. </year>
Reference: [Lei and Duchamp 1997] <author> Hui Lei and Dan Duchamp. </author> <title> "An Analytical Approach to File Prefetching." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 275-288, </pages> <address> Anaheim, California, </address> <month> January </month> <year> 1997. </year> <booktitle> USENIX. </booktitle>
Reference: [Locus 1993] <institution> Locus Computing Corporation, Inglewood, California. </institution> <note> PC/Interface Reference Manual, Feb-ruary 1993. </note>
Reference-contexts: FEASIBILITY 2.2 Methodology We collected our traces at Locus Computing Corporation, a software development and consulting firm, during the summer of 1993. One of Locus' products, PC/Interface TM (PCI) <ref> [Locus 1993] </ref>, is a pseudo-disk driver that makes the Unix r file system available to MS-DOS r computers over an Ethernet. In the environments monitored, the local MS-DOS filesystem was used to store some applications software, but all shared corporate data was accessed via PCI.
Reference: [Majumdar and Bunt 1986] <author> Shikharesh Majumdar and Richard B. Bunt. </author> <title> "Measurement and Analysis of Locality Phases in File Referencing Behavior." </title> <booktitle> In Proceedings of Performance 86 and ACM Sigmetrics 86, Joint Conference on Computer Performance Modeling, Measurement and Evaluation, </booktitle> <pages> pp. 180-192, </pages> <address> Raleigh, NC, </address> <month> May </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: Because of these two assumptions, the attention-shift ages reported in this paper are only a lower bound on the true ages that would be encountered by a predictive hoarding system. The bounded locality intervals discussed in <ref> [Majumdar and Bunt 1986] </ref> are similar to attention shifts, but are parameterized on working-set sizes rather than on the expected length of a disconnection. The statistics we report are: Working-set statistics. For each day and week, we calculated the working set size in files, Mb, and number of accesses.
Reference: [Manber and Wu 1994] <author> Udi Manber and Sun Wu. "GLIMPSE: </author> <title> A Tool to Search Through Entire File Systems." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 23-32, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1994. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: enough files on a portable disk to satisfy the average user, 7 although some software or user behavior may have to change when disconnected. (For example, instead of relying on a large grep, a user might use an inverted index to locate the files containing references to a particular string <ref> [Manber and Wu 1994] </ref>.) 2.4.2 Attention Shifts Tables 2.3 and 2.4 summarize the attention shifts observed. Figures 2.6-2.8 show the sensitivity of attention-shift rates to the parameter p.
Reference: [Mecozzi and Minton 1991] <author> Donna Mecozzi and James Minton. </author> <title> "Design for a Transparent, Distributed File System." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 77-84, </pages> <address> Monterey, California, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Mills 1989] <author> Dave L. Mills. </author> <title> "Network Time Protocol (version 2) specification and implementation." RFC 1119, Internet Request For Comments, </title> <month> September </month> <year> 1989. </year>
Reference-contexts: If the correlator is talking to multiple observers (see Section 5.2, p. 52), it will read and process packets in timestamp order. Ordered processing assumes that clocks are synchronized fairly well, which is true in modern systems that run a protocol such as NTP <ref> [Mills 1989, Mills 1994] </ref>. Timestamp synchronization is discussed further in Section B.2.2. B.2 Correlator Design As outlined in Section 5.3 (p. 53), the correlator is the heart of Seer and has many responsibilities, which are reviewed in that section. Details of these operations are given below. <p> If a connection does not currently have a pending packet, the correlator skips it in this computation. This design assumes that the clocks on the observed machines are reasonably well synchronized, which will be true if they are running a time-synchronization protocol such as NTP <ref> [Mills 1989, Mills 1994] </ref>. If they are not, it is possible that the correlator will see some packets that are out of timestamp order, 6 but the validity of the results will not be affected because the timestamps are not used in the actual semantic-distance calculations.
Reference: [Mills 1994] <author> David L. Mills. </author> <title> "Precise Synchronization of Computer Network Clocks." </title> <journal> ACM Computer Communication Review, </journal> <volume> 24(4) </volume> <pages> 28-43, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: If the correlator is talking to multiple observers (see Section 5.2, p. 52), it will read and process packets in timestamp order. Ordered processing assumes that clocks are synchronized fairly well, which is true in modern systems that run a protocol such as NTP <ref> [Mills 1989, Mills 1994] </ref>. Timestamp synchronization is discussed further in Section B.2.2. B.2 Correlator Design As outlined in Section 5.3 (p. 53), the correlator is the heart of Seer and has many responsibilities, which are reviewed in that section. Details of these operations are given below. <p> If a connection does not currently have a pending packet, the correlator skips it in this computation. This design assumes that the clocks on the observed machines are reasonably well synchronized, which will be true if they are running a time-synchronization protocol such as NTP <ref> [Mills 1989, Mills 1994] </ref>. If they are not, it is possible that the correlator will see some packets that are out of timestamp order, 6 but the validity of the results will not be affected because the timestamps are not used in the actual semantic-distance calculations.
Reference: [Mummert et al . 1995] <author> Lily B. Mummert, Maria R. Ebling, and Mahadev Satyanarayanan. </author> <title> "Exploiting Weak Connectivity for Mobile File Access." </title> <booktitle> In Proceedings of the 15th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 143-155, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December </month> <year> 1995. </year> <note> ACM. </note>
Reference: [Muntz and Honeyman 1992] <author> Dan Muntz and Peter Honeyman. </author> <title> "Multi-Level Caching in Distributed File Systems." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 305-313, </pages> <address> San Francisco, </address> <month> January </month> <year> 1992. </year> <booktitle> USENIX. </booktitle>
Reference: [Noble 1997] <author> Brian Noble, </author> <month> May </month> <year> 1997. </year> <type> Personal communication via e-mail. </type>
Reference-contexts: In most such cases the user was able to switch to another task for which the required objects were cached. Indeed, it was often possible for a user to "fall-back" on different tasks two or three times before they gave up and terminated the session. 3 Brian Noble <ref> [Noble 1997] </ref> has indicated that direct sharing has recently increased, partly due to use of a relatively unfamiliar software package for which a single expert has created a standardized hoard profile.. 108 CHAPTER 9.
Reference: [Nydick et al. 1991] <author> Daniel Nydick, Kathy Benninger, Brett Bosley, James Ellis, Jonathan Goldick, Chris-topher Kirby, Michael Levine, Christopher Maher, and Matt Mathis. </author> <title> "An AFS TM -Based Mass Storage System at the Pittsburgh Supercomputing Center." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 117-122, </pages> <address> Monterey, California, </address> <month> October </month> <year> 1991. </year> <title> IEEE, </title> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Ousterhout 1990] <author> John K. Ousterhout. </author> <title> "TCL: An Embeddable Command Language." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 133-146. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1990. </year> <note> REFERENCES 153 </note>
Reference-contexts: More details are give in Section B.3, p. 145. During the development of Seer, two graphical interfaces were created to sugar-coat the Unix commandline nature of the controller and to display manager output in a friendlier form. The first was written in the TCL <ref> [Ousterhout 1990] </ref> scripting language, while the second was written using HTML forms and CGI scripts, so that a Web browser would serve as a convenient interface.
Reference: [Ousterhout et al . 1985] <author> John K. Ousterhout, Herve Da Costa, David Harrison, John A. Kunze, Mike Kup-fer, and James G. Thompson. </author> <title> "A Trace-Driven Analysis of the Unix 4.2 BSD File System." </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 15-24. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year>
Reference: [Palmer and Zdonik 1991] <author> M. L. Palmer and Stanley B. Zdonik. </author> <title> "Fido: A Cache that Learns to Fetch." </title> <type> Technical Report CS-91-15, </type> <institution> Brown University Department of Computer Science, </institution> <month> February </month> <year> 1991. </year>
Reference: [Patterson et al. 1995] <author> R. Hugo Patterson, Garth A. Gibson, Eka Ginting, Daniel Stodolsky, and Jim Zelenka. </author> <title> "Informed Prefetching and Caching." </title> <booktitle> In Proceedings of the 15th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 79-95, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December </month> <year> 1995. </year> <note> ACM. </note>
Reference: [Pawlowski et al. 1994] <author> Brian Pawlowski, Chet Juszczak, Peter Staubach, Carl Smith, Diane Lebel, and David Hitz. </author> <title> "NFS Version 3 Design and Implementation." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 137-152. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: To avoid this problem, the trace mechanism does not record calls made by the observer and correlator themselves. However, experience showed that this step was not enough. Some of the system calls made by Seer can activate daemons, notably those that support the Network File System (NFS) <ref> [Pawlowski et al. 1994] </ref>, and deadlock can occur due to calls made by these processes. We solved this problem by modifying the kernel so that it doesn't trace most calls made by the superuser ("root"). However, we still trace file renames, file destruction, and process exits performed by the superuser.
Reference: [Peterson 1991] <author> Anthony L. Peterson. </author> <title> "E-Systems Modular Automated Storage System (EMASS) Software Functionality." </title> <editor> In Karen D. Friedman and Bernard T. O'Lear, editors, </editor> <booktitle> Proceedings of the Eleventh IEEE Symposium on Mass Storage Systems, </booktitle> <pages> pp. 73-76, </pages> <address> Monterey, California, </address> <month> October </month> <year> 1991. </year> <title> IEEE, </title> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Popek 1996] <author> Gerald J. Popek, </author> <year> 1996. </year> <type> Personal communication. </type>
Reference-contexts: Another approach would be to hand-classify files into major types, as suggested above; however, real systems have large numbers of types, 3 so that hand classification may be impractical. 1 Jerry Popek has observed <ref> [Popek 1996] </ref> that utility programs are the "ands" and "ofs" of clustering. 2 Some files, such as programs in development, might be both operators and objects. 3 For example, consider the number of types supported by the Apple Macintosh r , or the number of lines in /etc/magic on Unix systems.
Reference: [Popek and Walker 1985] <author> Gerald J. Popek and Bruce J. Walker. </author> <title> The Locus Distributed System Architecture. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: This server was traced for 1563 hours (65.1 days, or 9.3 weeks), 2 recording 4,637,924 accesses. In the second environment, referred to as "programming," the server was a cluster of 10 machines running IBM's Transparent Computing Facility, an adaption of the Locus distributed operating system <ref> [Popek and Walker 1985] </ref>, which provides a single-system image to users of multiple machines. Each machine ran a separate PCI server, and logs from these servers were later combined for analysis. Most of the users of this server were programmers working on DOS-based software.
Reference: [Ratner 1995] <author> David H. Ratner. </author> <title> "Selective Replication: Fine-Grain Control of Replicated Files." </title> <type> Technical Report CSD-950007, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> March </month> <year> 1995. </year> <type> Master's Thesis. </type>
Reference-contexts: It is still possible for this data to exceed the capacity of the local disk (especially if the user is browsing the network or using large video or sound files), but most of the time everything will fit quite nicely. Using a system that supports selective replication <ref> [Ratner 1995] </ref>, the user can store copies of only the files needed for a day's (or week's) work, propagating updates back to the network when a connection is available. The problem of selectively replicating files on a small scale is well-understood and amenable to efficient solution. <p> need to store a directory both when connected and when disconnected depends on the underlying replication system: some may require all directories to be present to support remote access to files not hoarded on the portable computer, and most require that all directories leading to a hoarded file be present <ref> [Kistler 1993, Ratner 1995] </ref> so that the file itself can be reached. The directory structure can also convey valuable information to the user.
Reference: [Reiher 1995] <author> Peter Reiher, </author> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: All told, the complete Seer system, including miscellaneous utilities but excluding Cheap Rumor, totals about 7000 lines of scripts, 500 lines of makefiles, and 40,000 lines of C and C ++ code that contain slightly over 10,000 semicolons. 1 This term was suggested by Peter Reiher <ref> [Reiher 1995] </ref>. 51 52 CHAPTER 5.
Reference: [Reiher et al. 1994] <author> Peter Reiher, John S. Heidemann, David Ratner, Gregory Skinner, and Gerald J. Popek. </author> <title> "Resolving File Conflicts in the Ficus File System." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 183-195. </pages> <institution> University of California, Los Angeles, USENIX, </institution> <month> June </month> <year> 1994. </year>
Reference: [Reiher et al. 1996] <author> Peter Reiher, Jerry Popek, Michial Gunter, John Salomone, and David Ratner. </author> <title> "Peer-to-peer Reconciliation Based Replication for Mobile Computers." </title> <booktitle> In Proceedings of ECOOP'96 II Workshop on Mobility and Replication, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: a selected subset) * Seer-independent hoard changes * Conflict detection * Status queries * Location queries * Command batching * Disconnected queries In addition to implementing only limited capabilities, Cheap Rumor does not address some of the more subtle and complex issues handled by the Ficus [Guy 1991] and Rumor <ref> [Gunter 1997, Reiher et al. 1996] </ref> systems. For example, Rumor goes to great lengths to detect and properly process rare pathological cases involving files that have changed and had their modification times reset during a 1-second window while Rumor is reading their contents.
Reference: [Salem et al . 1992] <author> Kenneth Salem, Daniel Barbara, and Richard J. Lipton. </author> <title> "Probabilistic Diagnosis of Hot Spots." </title> <booktitle> In 8th International Conference on Data Engineering, </booktitle> <pages> pp. 30-39. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1992. </year>
Reference: [Satyanarayanan 1996] <author> Mahadev Satyanarayanan. </author> <title> "Mobile Information Access." </title> <journal> IEEE Personal Communications Magazine, </journal> <volume> 3(1) </volume> <pages> 26-33, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: To the contrary, the advent of multimedia and ever-more-complex applications, with their associated graphics and configuration files, will only exacerbate the shortage of disk space. Furthermore, even though portable disks are large, they are inherently incapable of storing as much data as can be kept on a non-portable machine <ref> [Satyanarayanan 1996] </ref>, and the very existence of a network means that the total available data will be larger than can fit on any one disk.
Reference: [Satyanarayanan et al. 1990] <author> Mahadev Satyanarayanan, James J. Kistler, Puneet Kumar, Maria E. Okasaki, Ellen H. Siegel, and David C. Steere. "Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment." </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference: [Satyanarayanan et al. 1993] <author> Mahadev Satyanarayanan, James J. Kistler, Lily B. Mummert, Maria R. Ebling, Puneet Kumar, and Qi Lu. </author> <title> "Experience with Disconnected Operation in a Mobile Computing Environment." </title> <booktitle> In Proceedings of the USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <pages> pp. 11-28, </pages> <address> Cambridge, MA, </address> <month> August </month> <year> 1993. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Some qualitative information is given in both [Kistler 1993] and <ref> [Satyanarayanan et al. 1993] </ref>, but there are no tables or graphs showing the effectiveness of the algorithms. 1 A list of suggested evaluation methods is given in [Satyanarayanan et al. 1993, Section 7.2], although there is no indication whether any were ever implemented. These include: Time to first miss. <p> Some qualitative information is given in both [Kistler 1993] and [Satyanarayanan et al. 1993], but there are no tables or graphs showing the effectiveness of the algorithms. 1 A list of suggested evaluation methods is given in <ref> [Satyanarayanan et al. 1993, Section 7.2] </ref>, although there is no indication whether any were ever implemented. These include: Time to first miss. The amount of time 2 that elapses between disconnection and the first hoard miss. <p> Most of the material in [Kistler 1993] is concerned with the implementation of disconnected operation, and all of the quantitative results in both [Kistler 1993] and <ref> [Satyanarayanan et al. 1993] </ref> involve measurements of the performance of the disconnection/reintegration process and of user working sets (which are not significantly affected by disconnection, though as discussed in Chapter 2 they have a large impact on the feasibility of hoarding). <p> The earlier paper [Kistler and Satyanarayanan 1992] presents the material at a high conceptual level. These results are discussed further below. Several possible metrics for evaluating a hoarding system are suggested in <ref> [Satyanarayanan et al. 1993] </ref>. All of these metrics are repeated and discussed in Section 7.1.2 of this dissertation (p. 76). However, the published results do not include evaluation of any of these measures. <p> An indication of the complexity of the problem is given in <ref> [Satyanarayanan et al. 1993, Section 5.1.1] </ref>: Most users employ about 5-10 profiles at any one time. Typically, this includes one profile representing the `personal' data: the contents of his or her root directory, notes and mail directories, etc. <p> increase as our user community grows, and as less sophisticated users begin to use Coda." However, increased sharing has not been subsequently reported, possibly because writing a successful hoard profile is a difficult, user-specific task that is accessible only to the expert. 3 Success of Coda Hoarding Section 5.1.2 of <ref> [Satyanarayanan et al. 1993] </ref> discusses experience with hoard misses: Many disconnected sessions experienced by our users, including many sections of extended dur ation, involved no cache misses whatsoever. <p> This observation applies to all hoarding systems, including Seer, although one of the advantages of Seer is that it requires less user adaptation of this sort. The same section of <ref> [Satyanarayanan et al. 1993] </ref> also states: When disconnected misses did occur, they often were not fatal to the session. In most such cases the user was able to switch to another task for which the required objects were cached.
Reference: [Schroeder et al . 1985] <author> Michael D. Schroeder, David K. Gifford, and Roger M. Needham. </author> <title> "A Caching File System for a Programmer's Workstation." </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 25-34. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year> <note> 154 REFERENCES </note>
Reference: [Skopp and Kaiser 1993] <author> Peter D. Skopp and Gail E. Kaiser. </author> <title> "Disconnected Operation in a Multi-User Software Development Environment." </title> <booktitle> In Proceedings of the IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <address> Princeton, NJ, </address> <month> October </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: This work predates Coda, but it apparently was not carried to fruition, and no usage data of any sort has been reported, so it has had less impact. Finally, a planned system named Laputa was described in <ref> [Skopp and Kaiser 1993] </ref>, though no further results have been published to date.
Reference: [Smith 1981] <author> Alan J. Smith. </author> <title> "Analysis of Long Term File Reference Patterns for Application to File Migration Algorithms." </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(4), </volume> <month> July </month> <year> 1981. </year>
Reference: [Sokal 1977] <author> Robert R. Sokal. </author> <title> "Clustering and Classification: Background and Current Directions." </title> <editor> In J. Van Ryzin, editor, </editor> <booktitle> Classification and Clustering, </booktitle> <pages> pp. 1-15. </pages> <publisher> Academic Press, </publisher> <year> 1977. </year> <title> Proceedings of an Advanced Seminar Conducted by the University of Wisconsin at Madison, </title> <month> May 3-5, </month> <year> 1976. </year>
Reference: [Spath 1980] <author> Helmuth Spath. </author> <title> Cluster Analysis Algorithms. </title> <publisher> Ellis Horwood, Ltd., </publisher> <address> Chichester, England, </address> <year> 1980. </year>
Reference-contexts: The extra distance measures must be incorporated into the clustering calculation in some way. One obvious method would be to use a standard distance-reduction method, such as Euclidean or Mahalanobis <ref> [Spath 1980] </ref> distance, to combine these distances with the semantic distance. These modified semantic distances would then be used to form a new nearest-neighbor list for the clustering algorithm. However, combining the investigated distances directly with the semantic distance introduces a difficulty: the need to calculate a new nearest-neighbor list. <p> Iterative clustering algorithms are amenable to this approach. We would like to investigate adapting one of these algorithms to Seer's needs, in hopes of improving the performance at clustering time. Hierarchical Clustering. Clustering algorithms are generally divided into two classes: hierarchical and non-hierarchical <ref> [Duran and Odell 1974, Hartigan 1975, Spath 1980] </ref>. The former class naturally produces a tree of "nested" clusters, generally rooted by a single cluster containing all objects.
Reference: [Staelin and Garcia-Molina 1990] <author> Carl Staelin and Hector Garcia-Molina. </author> <title> "File System Design using Large Memories." </title> <booktitle> In Proceedings of the Fifth Jerusalem Conference on Information Technology, </booktitle> <pages> pp. 11-21. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Ideally, the weight would based on the cost of moving the entire cluster, which would be affected both by the sizes of other members and by which members were already present in the local hoard. Cluster Temperatures. Some other researchers <ref> [Salem et al. 1992, Staelin and Garcia-Molina 1990] </ref> have suggested using a "temperature" to characterize the activity or popularity of a cache object. The idea is that the temperature rises higher (usually in a linear fashion) whenever an object is accessed, and decays over time, usually exponentially.
Reference: [Steere and Satyanarayanan 1994] <author> David C. Steere and Mahadev Satyanarayanan. </author> <title> "A Case for Dynamic Sets in Operating Systems." </title> <type> Technical Report CMU-CS-94-216, </type> <institution> Carnegie-Mellon University, </institution> <month> November </month> <year> 1994. </year>
Reference: [Tait 1997] <author> Carl Tait, </author> <year> 1997. </year> <type> Personal communication by e-mail. </type>
Reference-contexts: Nor could it recognize relationships between two files accessed by two related subprocesses, except through the existence of those subprocesses themselves. Attention shifts were recognized only when a top-level executable file was activated <ref> [Tait 1997] </ref>. On the other hand, the bookend facility allowed users to provide hints that could go a long way towards alleviating this difficulty. 4 Tait has commented [Tait 1997] that "this was probably the biggest motivation for bookends." 110 CHAPTER 9. <p> Attention shifts were recognized only when a top-level executable file was activated <ref> [Tait 1997] </ref>. On the other hand, the bookend facility allowed users to provide hints that could go a long way towards alleviating this difficulty. 4 Tait has commented [Tait 1997] that "this was probably the biggest motivation for bookends." 110 CHAPTER 9. RELATED WORK Chapter 10 Future Work During any project of this magnitude, a number of ideas and suggestions arise that are not practical to implement within the available time frame.
Reference: [Tait and Duchamp 1991] <author> Carl D. Tait and Dan Duchamp. </author> <title> "Detection and Exploitation of File Working Sets." </title> <booktitle> In Proceedings of the Eleventh International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 2-9, </pages> <year> 1991. </year>
Reference-contexts: behavior: * The working set of files, as observed over a period of days or weeks, must be small enough to fit on a portable's disk. * It must be possible to predict the working set in advance, using hints such as the current working set, historical file access patterns <ref> [Tait and Duchamp 1991] </ref>, or known patterns in user behavior. Analysis of the data we have collected shows that these characteristics are present in a number of different application domains. 1 Most of the material in this chapter appeared previously as [Kuenning et al. 1994]. 7 8 CHAPTER 2. <p> Unlike Coda, Face, and Little Work, Tait attempted to detect an application's working set automatically, building on his previous work in file prefetching <ref> [Tait and Duchamp 1991] </ref>. The primary innovation of Spy Utility was the observation of process trees to generate projects for hoarding. For each executable program in the system, a record was kept of the identity and ordering of the files accessed by that program.
Reference: [Tait et al . 1995] <author> Carl D. Tait, Hui Lei, Swarup Acharya, and Henry Chang. </author> <title> "Intelligent File Hoarding for Mobile Computers." </title> <booktitle> In Proceedings of the MobiCom '95: The First International Conference on Mobile Computing and Networking, </booktitle> <pages> pp. 119-125, </pages> <address> Berkeley, CA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Directory distance is the only measure that can be calculated between any pair of files in the database; Seer calculates it on demand for files that have some other relationship recorded so that it does not have an O (N 2 ) efficiency impact. We follow Tait <ref> [Tait et al . 1995] </ref> in assuming that being in a different directory implies that files are unrelated, rather than assuming that being in the same directory implies a relationship. <p> However, with the exception of Tait's Spy Utility <ref> [Tait et al . 1995] </ref>, these systems place most or all of the file-specification burden directly on the user. 9.2.1 Coda The first system providing significant support for disconnected operation appears to be Coda [Kistler and Satyanarayanan 1992, Kistler 1993, Kumar and Satyanarayanan 1993, Mummert et al . 1995, Satyanarayanan et <p> the manner of Coda, plus a rule-based system that used detailed knowledge of the user's work process, possibly generated by a human expert. 9.2.3 Spy Utility To date, the most ambitious hoard-filling project is the Spy Utility built by Tait et al. to run on the OS/2 r operating system <ref> [Tait et al . 1995] </ref>, and now marketed by IBM r as part of their Mobile File Sync product. Unlike Coda, Face, and Little Work, Tait attempted to detect an application's working set automatically, building on his previous work in file prefetching [Tait and Duchamp 1991].
Reference: [Tichy 1982] <author> W. F. Tichy. </author> <title> "Design, Implementation, and Evaluation of a Revision Control System." </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering, </booktitle> <month> September </month> <year> 1982. </year>
Reference-contexts: An investigator that locates relationships based on common naming conventions, such as source and object files, source and revision-history files, and C ++ header and implementation files. Files are considered related if they differ only in their suffix, or if they follow well-known relationships such as SCCS or RCS <ref> [Tichy 1982] </ref> files. 58 CHAPTER 5. SYSTEM DESIGN fifotest: fifotest.o fifo.o $(CC) $(CFLAGS) -o fifotest fifotest.o fifo.o C includes. An investigator that reads C and C ++ source files and determines relationships among source and header files. <p> The automounter support discussed in Section 6.11 (p. 70) is an example of a non-transparent space. 7 In some cases, this feature is more than just convenient. For example, if an RCS history file <ref> [Tichy 1982] </ref> is not present, the ci command will create one, causing a future conflict with the correct history file. This situation illustrates one of the pitfalls of the concept of hoarding, albeit one that can be solved by a sufficiently powerful replication substrate. 60 CHAPTER 5.
Reference: [Vitter and Krishnan 1996] <author> Jeffrey Scott Vitter and P. Krishnan. </author> <title> "Optimal Prefetching via Data Compression." </title> <journal> Journal of the ACM, </journal> <volume> 43(5) </volume> <pages> 771-793, </pages> <month> September </month> <year> 1996. </year>
Reference: [Wall and Schwartz 1991] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming Perl. </title> <publisher> O'Reilly and Associates, </publisher> <address> Sebastopol, CA, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Our prototype replication substrate, Cheap Rumor (described in Appendix A), is about 5400 lines of Perl <ref> [Wall and Schwartz 1991] </ref> code. * A hoarding interface that converts decisions by Seer into commands to the replication substrate. The hoarding interface for Cheap Rumor is a single script of about 400 lines. <p> T E X includes. An investigator that reads T E X documents to discover required style files, option files, and subsidiary documents. The name investigator is implemented as a special-purpose awk script, while the latter two are based on a generalized pattern-driven Perl <ref> [Wall and Schwartz 1991] </ref> program written by Andrew Louie. 5.4.3 Cluster Investigators We also implemented a cluster investigator that examines Makefiles to discover clusters implied by the dependencies. Figure 5.3 shows a typical Makefile dependency entry. <p> Cheap Rumor ignores situations of this sort, instead expecting that the user will avoid Byzantine behavior. A.2 Design of Cheap Rumor Cheap Rumor consists of two simple programs, cheap_control and cheap_reconcile, both written in the Perl <ref> [Wall and Schwartz 1991] </ref> scripting language. Cheap_control handles replication control (subset 125 126 APPENDIX A. A SIMPLE REPLICATION SYSTEM replication), status reporting, and the creation of new Cheap Rumor volumes, while cheap_reconcile handles update propagation and conflict detection.
Reference: [Zupan 1982] <author> Jure Zupan. </author> <title> Clustering of Large Data Sets. </title> <publisher> Research Studies Press, </publisher> <year> 1982. </year>
References-found: 89

