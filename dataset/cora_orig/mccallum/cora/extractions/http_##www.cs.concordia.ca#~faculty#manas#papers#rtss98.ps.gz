URL: http://www.cs.concordia.ca/~faculty/manas/papers/rtss98.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/manas/research/sel-pubs.html
Root-URL: http://www.cs.concordia.ca
Note: IEEE COPYRIGHT NOTICE  
Abstract: c fl1998 IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Burns and A. Wellings. </author> <title> Real-time Systems: Specification, Verification and Analysis, chapter Advanced Fixed Priority Scheduling, </title> <address> pages 32-65. </address> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: structure of the system such that ROOM models built with the ObjecTime toolset could be compiled with the modified run-time system. 4 Schedulability Analysis of ROOM Models In this section we analyze ROOM model implementations and show how they may be subjected to schedulability analysis based on real-time scheduling theory <ref> [1, 5, 12] </ref>. Rather than develop a comprehensive schedulability analysis model, we just show how simple periodic tasks can be implemented and analyzed. <p> The message queues of an actor (actually a controller) are accessed by other threads during an inter-thread send operation. Thus, a blocking is incurred if a task is activated when a lower priority task is sending a message to this thread. Using Immediate Priority Ceiling Inheritance Protocol <ref> [1] </ref>, this blocking time can be bounded to the cost of one inter-thread send operation. We refer to this blocking time as: B MQ In our implementation, we access shared message queues at the highest priority.
Reference: [2] <author> P. Freedman. </author> <title> Investigating the suitability of objectime for the software development of embedded control systems. </title> <booktitle> In Proceedings, ObjecTime Worksop on Research in Real-Time Object-Oriented Modeling, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: The train tilting system modeled here represents a realistic and representative (future generation) computerized control system. Previous work on the application of ROOM/ObjecTime for the development of the train tilting system <ref> [2] </ref> had revealed serious timing problems due to the use of static thread priorities. 2 Overview of ROOM Concepts Modeling of systems with ROOM is performed by designing actors, which are encapsulated, concurrent objects, communicating via point-to-point links.
Reference: [3] <author> D. Harel. Statecharts: </author> <title> A visual approach to complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1987. </year>
Reference-contexts: A message is a tuple consisting of a signal name, a message body (i.e., data associated with the message), and an associated message priority. The behavior of an actor is represented by an extended state machine called a ROOMchart, based on the statechart formalism <ref> [3] </ref>. Each actor remains dormant until an event occurs, i.e., when a message is received by an actor. Incoming messages trigger transitions associated with the actor's finite state machine. Actions may be associated with transitions, as well as entry and exit points of a state.
Reference: [4] <author> D. Katcher, H. Arakawa, and J. Strosnider. </author> <title> Engineering and Analysis of Fixed Priority Schedulers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(9), </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: The predicted response times were then compared with the measured response times. Each periodic task executed a spinloop, as given below, with loopCount decided based on its desired execution time <ref> [4] </ref>. while (i &lt; loopCount) - j = &i; i++;- All our experiments were done on a Sun UltraSPARC-I, with a 167MHz clock, 128MB main memory, and running Solaris 2.5. Using measurements, it was estimated that 10.3 loops were required for each microsecond of execution time.
Reference: [5] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harbour. </author> <title> A Practitioner's Handbook for Real-Time Analysis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: The time-driven style has evolved to develop methods that can predict timeliness aspects of a system, and is particularly suitable for systems whose performance critically depends on meeting deadlines. The predictability of event-arrivals makes it easier to do such analysis. The maturity of real-time scheduling theory <ref> [5] </ref> has led to a range of techniques, mostly based on fixed priority scheduling theory, that a designer/developer can use to perform timing and schedulability analysis of a time-driven real-time system. <p> structure of the system such that ROOM models built with the ObjecTime toolset could be compiled with the modified run-time system. 4 Schedulability Analysis of ROOM Models In this section we analyze ROOM model implementations and show how they may be subjected to schedulability analysis based on real-time scheduling theory <ref> [1, 5, 12] </ref>. Rather than develop a comprehensive schedulability analysis model, we just show how simple periodic tasks can be implemented and analyzed. <p> We will further assume that the computation neither blocks nor sends a message to another actor. The basic model can easily be extended for more complex systems, as has been done in real-time scheduling theory literature <ref> [12, 5] </ref>. Let o 1 ; o ; : : : ; o n be a set of periodic tasks as described above. Each task o i is characterized by its period T i , and its computation time C i .
Reference: [6] <author> D. Lanoix. </author> <title> Bombardier's New Generation Tilting System. </title> <journal> IEEE Canadian Review, </journal> <month> Spring/Summer </month> <year> 1995. </year>
Reference-contexts: As a result, this new model does not necessarily reflect Bombardier's current or planned technologies. 5.1 Train Tilting Systems New-generation train tilting technology allows passenger trains to travel faster on conventional (non-banked) tracks, making medium-speed train service more competitive with airlines for passenger travel <ref> [6] </ref>. By physically tilting the body of the passenger cars during the curves, the permissible train speed in the curves may be increased without exceeding the maximum allowable transient and steady state lateral acceleration experienced by the passengers.
Reference: [7] <author> ObjecTime Limited. </author> <title> ObjecTime TargetRTS Guide. </title> <publisher> Objec-Time Limited, </publisher> <address> Kanata, Canada. </address>
Reference-contexts: The Ob-jecTime Developer Toolset is a CASE tool that provides a fully integrated development environment to support the ROOM methodology, with features such as graphical and textual editing for actor construction, and C++ code generation from the model [9]. The ObjecTime toolset includes a target run-time system (TargetRTS) <ref> [7] </ref>, which is linked with the application code to provide a standalone executable that may be run on either a workstation (emulation) environment, or on a target environment with an underlying real-time operating system such as VxWorks, QNX, pSOS, and VRTX. 3.1 Single vs Multi-Threaded Implementation The simplest approach to implement
Reference: [8] <author> M. Saksena, P. Freedman, and P. Rodziewicz. </author> <title> Guidelines for Automated Implementation of Executable Object Oriented Models for Real-Time Embedded Contol Systems. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <year> 1997. </year>
Reference-contexts: In the absence of deterministic arrival of events, it is hard to determine response times, and thus hard to analyze a system for real-time performance. On the other hand, in a recent paper <ref> [8] </ref>, we showed that it is possible to perform such analysis. The key is to realize that even though a given system may be processing many events in a state-dependent manner, only a relatively small number of event-sequences are time-critical and need to be analyzed for timeliness. <p> Thus, if we can (1) prioritize events to reflect their time-criticality, and (2) implement a system that bounds priority inversions for event-processing, then it becomes simpler to analyze the time behavior of the time-critical event-sequences. The key aspects of our guidelines presented in <ref> [8] </ref> were the need for (1) preempt-ability of event processing, which requires multiple threads of control performing event-processing, and (2) managing thread priorities dynamically to minimize and bound priority inversions for event-processing. <p> In other words, threads of control and thread priorities must be viewed as artifacts of implementation for preemptability, and events and event-priorities must be viewed as design elements. In this paper, we present our experience with the application of the guidelines presented in <ref> [8] </ref> for implementation of real-time object-oriented models. As in [8], our work uses the ROOM modeling language [9] and the ObjecTime Developer Toolset from ObjecTime Inc. The ROOM modeling language and the ObjecTime Developer Toolset are representative of the new generation of modeling and development tools for event-driven real-time software. <p> In this paper, we present our experience with the application of the guidelines presented in <ref> [8] </ref> for implementation of real-time object-oriented models. As in [8], our work uses the ROOM modeling language [9] and the ObjecTime Developer Toolset from ObjecTime Inc. The ROOM modeling language and the ObjecTime Developer Toolset are representative of the new generation of modeling and development tools for event-driven real-time software. <p> The main contribution of this paper is in presenting experimental evidence of the soundness of the ideas presented in <ref> [8] </ref> showing that it is possible to perform a priori schedu-lability analysis of automated implementations of real-time object-oriented software models. We have modified Objec-Time's run-time system in accordance with the guidelines presented in [8], and then used the implementation to develop a schedulability analysis model taking into account the implementation aspects <p> contribution of this paper is in presenting experimental evidence of the soundness of the ideas presented in <ref> [8] </ref> showing that it is possible to perform a priori schedu-lability analysis of automated implementations of real-time object-oriented software models. We have modified Objec-Time's run-time system in accordance with the guidelines presented in [8], and then used the implementation to develop a schedulability analysis model taking into account the implementation aspects and the overheads. This model is then used to illustrate how schedulability analysis can be performed for a simple set of periodic tasks; we also validate the model through measurements. <p> Note that, while each of these system monitoring activities may be relatively small, the aggregate of all such activities (over a time interval of interest) may be large, and can cause significant priority inversion. This problem was identified in <ref> [8] </ref>, and it was suggested that the run-time system should automatically manage thread priorities to reflect the priority of pending messages for the thread. Thus, each thread can have a dynamic priority, which is increased whenever a higher priority message arrives for one of the actors managed by the thread. <p> The work builds on our previous paper <ref> [8] </ref> which presented some guidelines on how priority inversions can be avoided to make schedulability analysis feasible.
Reference: [9] <author> B. Selic, G. Gullekson, and P. T. Ward. </author> <title> Real-Time Object-Oriented Modeling. </title> <publisher> John Wiley and Sons, </publisher> <year> 1994. </year>
Reference-contexts: In this paper, we present our experience with the application of the guidelines presented in [8] for implementation of real-time object-oriented models. As in [8], our work uses the ROOM modeling language <ref> [9] </ref> and the ObjecTime Developer Toolset from ObjecTime Inc. The ROOM modeling language and the ObjecTime Developer Toolset are representative of the new generation of modeling and development tools for event-driven real-time software. <p> The Ob-jecTime Developer Toolset is a CASE tool that provides a fully integrated development environment to support the ROOM methodology, with features such as graphical and textual editing for actor construction, and C++ code generation from the model <ref> [9] </ref>.
Reference: [10] <author> B. Selic and J. Rumbaugh. </author> <title> Using UML for Modeling Complex Real-Time Systems. </title> <note> White Paper, Published by Objec-Time, and available from www.objectime.com, March 1998. </note>
Reference-contexts: Indeed, a recent joint press release from ObjecTime and Rational states that Rational and ObjecTime are defining a comprehensive approach for the application of UML to the development of complex real-time systems. A recent white paper <ref> [10] </ref> also describes how the ROOM modeling concepts may be derived from the general UML modeling concepts, and suggests a domain specific specialization of UML for real-time based on ROOM modeling language.
Reference: [11] <author> B. Selic and P. Ward. </author> <title> The challenges of real-time software design. </title> <booktitle> Embedded Systems Programming, </booktitle> <pages> pages 66-82, </pages> <month> Oc-tober </month> <year> 1996. </year>
Reference-contexts: 1 Introduction In a recent article entitled The Challenges of Real-Time Software Design <ref> [11] </ref>, Selic and Ward use the words event-driven and time-driven to describe two basic `styles' of real-time software. The time-driven style corresponds to using fl Department of Computer Science, Concordia University, Montreal, Canada. Email: manas@cs.concordia.ca. y Centre de recherche informatique de Montreal (CRIM), and Canadian Space Agency, Montreal, Canada.
Reference: [12] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> An extendible approach for analysing fixed priority hard real-time tasks. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 6(2) </volume> <pages> 133-152, </pages> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: structure of the system such that ROOM models built with the ObjecTime toolset could be compiled with the modified run-time system. 4 Schedulability Analysis of ROOM Models In this section we analyze ROOM model implementations and show how they may be subjected to schedulability analysis based on real-time scheduling theory <ref> [1, 5, 12] </ref>. Rather than develop a comprehensive schedulability analysis model, we just show how simple periodic tasks can be implemented and analyzed. <p> We will further assume that the computation neither blocks nor sends a message to another actor. The basic model can easily be extended for more complex systems, as has been done in real-time scheduling theory literature <ref> [12, 5] </ref>. Let o 1 ; o ; : : : ; o n be a set of periodic tasks as described above. Each task o i is characterized by its period T i , and its computation time C i . <p> Also, let G i denote the thread to which a task o i is allocated. Then, if R i denotes the worst-case response time for task o i , it can be calculated (ignoring all overheads, and assuming R i &lt; T i ) using the following equation <ref> [12] </ref>. R i = j&lt;i where I j (R i ) represents the interference from higher priority task o j , and B i represents the blocking time from lower priority tasks. Typically, through the use of priority inheritance protocols, the blocking time can be bounded.
References-found: 12

