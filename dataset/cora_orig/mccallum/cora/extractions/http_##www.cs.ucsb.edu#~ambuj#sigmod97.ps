URL: http://www.cs.ucsb.edu/~ambuj/sigmod97.ps
Refering-URL: http://www.cs.ucsb.edu/~ambuj/research.html
Root-URL: http://www.cs.ucsb.edu
Title: Efficient View Maintenance at Data Warehouses  
Author: D. Agrawal A. El Abbadi A. Singh T. Yurek 
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: We present incremental view maintenance algorithms for a data warehouse derived from multiple distributed autonomous data sources. We begin with a detailed framework for analyzing view maintenance algorithms for multiple data sources with concurrent updates. Earlier approaches for view maintenance in the presence of concurrent updates typically require two types of messages: one to compute the view change due to the initial update and the other to compensate the view change due to interfering concurrent updates. The algorithms developed in this paper instead perform the compensation locally by using the information that is already available at the data warehouse. The first algorithm, termed SWEEP, ensures complete consistency of the view at the data warehouse in the presence of concurrent updates. Previous algorithms for incremental view maintenance either required a quiescent state at the data warehouse or required an exponential number of messages in terms of the data sources. In contrast, this algorithm does not require that the data warehouse be in a quiescent state for incorporating the new views and also the message complexity is linear in the number of data sources. The second algorithm, termed Nested SWEEP, attempts to compute a composite view change for multiple updates that occur concurrently while maintaining strong consistency. 
Abstract-found: 1
Intro-found: 1
Reference: [BCP96] <author> Elena Baralis, Stefano Ceri, and Stefano Paraboschi. </author> <title> Conservative Timestamp Revisited for Materialized View Maintenance in a Data Warehouse. </title> <booktitle> In Workshop on VIEWS'96, </booktitle> <year> 1996. </year>
Reference: [BLT86] <author> J. A. Blakeley, P. A. Larson, and F. W. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <year> 1986. </year>
Reference: [CGL + 96] <author> L. S. Colby, T. Griffin, L. Libkin, I. S. Mu-mick, and H. Trickey. </author> <title> Algorithms for Deferred View Maintenance. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 469-492, </pages> <year> 1996. </year>
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 577-589, </pages> <year> 1991. </year>

Reference: [GJM96] <author> Ashish Gupta, H.V. Jagadish, and Inder--pal Singh Mumick. </author> <title> Data Integration using Self- Maintainable Views. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Theory, </booktitle> <year> 1996. </year>
Reference-contexts: Example work includes the ECA algorithm [ZGMHW95] designed for a system with a central database site, the Strobe algorithms [ZGMW96] handling multiple, distributed sites, a hybrid system [HZ96a] combining different regions of the spectrum. Self-maintainable views which lie towards the fully materialized end of the spectrum <ref> [GJM96, QGMW96] </ref>, or full replication [HZ96b] do not require additional querying of the sources. These different approaches come with varying overheads and costs as discussed later in the paper.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental Maintenance of Views with Duplicates. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 328-339, </pages> <year> 1995. </year>
Reference: [GM95] <author> A. Gupta and I. S. Mumick. </author> <title> Maintenance of Materialized Views: Problems, Techniques, </title> <journal> and Applications. IEEE Bulletin of the Technical Committee on Data Engineering, </journal> <volume> 18(2) </volume> <pages> 3-18, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: In this case, when an update R i , i.e., an update to the base relation R i , is received at the data warehouse, the incremental changes are computed by querying the other data sources by sending appropriate parts of the following query <ref> [HJ91, HZ96a, GM95, GHJ96] </ref>: Y ProjAttr SelectCond (R 1 1 1 R i 1 1 R n ) : We illustrate the concept of incremental view maintenance with the following example.
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, and V. S. Subrama-nian. </author> <title> Maintaining Views Incrementally. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 157-166, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: However, it is assumed that the multiplicity of a tuple is maintained in terms of a control field that maintains the occurrence of each tuple <ref> [GMS93] </ref>.
Reference: [HGMW + 95] <author> J. Hammer, H. Garcia-Molina, J. Widom, W. Labio, and Y. Zhuge. </author> <title> The Stanford Data Warehousing Project. </title> <journal> IEEE Bulletin of the Technical Committee on Data Engineering, </journal> <volume> 18(2) </volume> <pages> 41-48, </pages> <month> June </month> <year> 1995. </year>
Reference: [HJ91] <author> R. Hull and D. Jacobs. </author> <title> Language Constructs for Programming Active Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 455-468, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: In this case, when an update R i , i.e., an update to the base relation R i , is received at the data warehouse, the incremental changes are computed by querying the other data sources by sending appropriate parts of the following query <ref> [HJ91, HZ96a, GM95, GHJ96] </ref>: Y ProjAttr SelectCond (R 1 1 1 R i 1 1 R n ) : We illustrate the concept of incremental view maintenance with the following example.
Reference: [HZ96a] <author> Richard Hull and Gang Zhou. </author> <title> A Framework for Supporting Data Integration Using the Materialized and Virtual Approaches. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 481-492, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: However, this approach may necessitate a solution in which the sources have to be contacted for additional information to ensure correctness. Example work includes the ECA algorithm [ZGMHW95] designed for a system with a central database site, the Strobe algorithms [ZGMW96] handling multiple, distributed sites, a hybrid system <ref> [HZ96a] </ref> combining different regions of the spectrum. Self-maintainable views which lie towards the fully materialized end of the spectrum [GJM96, QGMW96], or full replication [HZ96b] do not require additional querying of the sources. These different approaches come with varying overheads and costs as discussed later in the paper. <p> The two algorithms SWEEP and Nested SWEEP are presented in Sections 5 and 6. The paper concludes with a summary of the results in Section 7. 2 The Data Warehouse Model We adopt the data warehouse model developed in <ref> [ZGMW96, HZ96a, HZ96b] </ref>. In this model, updates occurring at the data sources are classified into three categories: 1. Single update transactions where each update is exe cuted at a single data source. 2. Source local transactions where a sequence of updates are performed as a single transaction. <p> The updates at the data sources can be handled at the data warehouse in different ways. Depending on how the updates are incorporated into the view at the data warehouse, different notions of consistency of the view have been identified in <ref> [ZGMW96, HZ96a] </ref>. <p> In this case, when an update R i , i.e., an update to the base relation R i , is received at the data warehouse, the incremental changes are computed by querying the other data sources by sending appropriate parts of the following query <ref> [HJ91, HZ96a, GM95, GHJ96] </ref>: Y ProjAttr SelectCond (R 1 1 1 R i 1 1 R n ) : We illustrate the concept of incremental view maintenance with the following example. <p> In ECA the size of query messages is quadratic in the number of interfering updates. Instead of generalizing ECA for a distributed data warehouse model, Zhuge et al. [ZGMW96] proposed a new algorithm called Strobe for maintaining views incrementally 1 Hull and Zhou <ref> [HZ96a] </ref> refer to this as the problem of "missing" contribution. in an environment with multiple data sources. In the basic version of Strobe, the error term due to concurrent updates is handled by making the following assumptions about the base relations and the materialized view. <p> Hence, the algorithm ensures complete consistency. The algorithm presented here is motivated from the brief description of an incremental view update approach presented in <ref> [HZ96a] </ref>. 5.1 The SWEEP algorithm We begin by describing the update and query server component employed at each data source to facilitate incremental view maintenance at the data warehouse. Figure 3 shows the code for the update and query server at a data source.
Reference: [HZ96b] <author> Richard Hull and Gang Zhou. </author> <title> Towards the Study of Performance Trade-offs Between Materialized and Virtual Integrated Views. </title> <booktitle> In Workshop on VIEWS'96, </booktitle> <year> 1996. </year>
Reference-contexts: Self-maintainable views which lie towards the fully materialized end of the spectrum [GJM96, QGMW96], or full replication <ref> [HZ96b] </ref> do not require additional querying of the sources. These different approaches come with varying overheads and costs as discussed later in the paper. <p> The two algorithms SWEEP and Nested SWEEP are presented in Sections 5 and 6. The paper concludes with a summary of the results in Section 7. 2 The Data Warehouse Model We adopt the data warehouse model developed in <ref> [ZGMW96, HZ96a, HZ96b] </ref>. In this model, updates occurring at the data sources are classified into three categories: 1. Single update transactions where each update is exe cuted at a single data source. 2. Source local transactions where a sequence of updates are performed as a single transaction.
Reference: [QGMW96] <author> Dallan Quass, Ashish Gupta, Inderpal Mu-mick, and Jennifer Widom. </author> <title> Making Views Self-Maintainable for Data Warehousing. </title> <booktitle> In Proceedings of the International Conference on Parallel and Distributed Information Systems, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: Example work includes the ECA algorithm [ZGMHW95] designed for a system with a central database site, the Strobe algorithms [ZGMW96] handling multiple, distributed sites, a hybrid system [HZ96a] combining different regions of the spectrum. Self-maintainable views which lie towards the fully materialized end of the spectrum <ref> [GJM96, QGMW96] </ref>, or full replication [HZ96b] do not require additional querying of the sources. These different approaches come with varying overheads and costs as discussed later in the paper.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental Recomputation of Active Relational Expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <year> 1991. </year>
Reference: [RBS96] <author> RBS. </author> <title> Data Warehouse Applications. Red Brick Systems, </title> <year> 1996. </year>
Reference-contexts: In this paper, we first describe an algorithm that ensures complete consistency of the views. Later we relax this requirement to achieve strong consistency. Commercially available data warehouse products such as Red Brick systems <ref> [RBS96] </ref> only ensure convergence. The architecture of the data warehouse is as shown in data warehouse consists of n sites for data sources and another site for storing and maintaining the materialized view of the data warehouse.
Reference: [SI84] <author> O. Shmueli and I. Itai. </author> <title> Maintenance of Views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1984. </year>
Reference: [Yur97] <author> T. Yurek. </author> <title> Efficient View Maintenance at Data Warehouses. </title> <type> Master's thesis, </type> <institution> University of California at Santa Barbara, Department of Computer Science, UCSB, Santa Barbara, </institution> <address> CA 93106, </address> <year> 1997. </year>
Reference-contexts: A detailed analysis of this algorithm appears in <ref> [Yur97] </ref>. 6.2 Discussion Although Nested SWEEP does not guarantee complete consistency, it ensures that the state transformations occur in the order of the arrival of the updates. Hence, in that sense Nested SWEEP guarantees strong consistency of the materialized view at the data warehouse. <p> However, if there are multiple updates, Nested SWEEP constructs the view change collectively for all the updates. Thus the message cost is amortized over these multiple updates. We have developed an analytical model to characterize the performance of Nested SWEEP <ref> [Yur97] </ref>. Unlike Strobe which also performs cumulative view change for multiple updates, Nested SWEEP does not require absolute quiescence where all updates must cease. It, however, does require that there not be a sequence of alternating updates which interfere with each other.
Reference: [ZGMHW95] <author> Yue Zhuge, Hector Garcia-Molina, Joachim Hammer, and Jennifer Widom. </author> <title> View Maintenance in a Warehousing Environment. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 316-327, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: The updates done against the base relations are propagated to the materialized view and the view is maintained incrementally. However, this approach may necessitate a solution in which the sources have to be contacted for additional information to ensure correctness. Example work includes the ECA algorithm <ref> [ZGMHW95] </ref> designed for a system with a central database site, the Strobe algorithms [ZGMW96] handling multiple, distributed sites, a hybrid system [HZ96a] combining different regions of the spectrum. <p> Several consistency notions have been associated with the views at the data warehouse, viz., complete consistency, strong consistency, weak consistency, and convergence <ref> [ZGMHW95, ZGMW96] </ref>. We develop two efficient algorithms in this paper. <p> Hence, the data warehouse problem is to maintain the views incrementally in the presence of concurrent updates occurring at the data sources. The ECA <ref> [ZGMHW95] </ref> and Strobe [ZGMW96] algorithms are examples of two approaches for addressing this problem. In the case of ECA, the data warehouse model is restricted in that the number of data sources is limited to a single data source. However, the data source may store several base relations. <p> In particular, Q 2 in this example will be formulated as: (R 1 1 R 2 1 R 3 ) (R 1 1 R 2 1 R 3 ) It is interesting to note that with the above formulation, it is easy to identify an optimization for ECA <ref> [ZGMHW95] </ref>. <p> However, this is still a very high value, and renders the algorithm unscalable for a large number of data sources. 4 On-line Error Correction Of Incremental View Compu tations All of the above algorithms, ECA <ref> [ZGMHW95] </ref>, Strobe, and C-Strobe [ZGMW96], completely evaluate the answer to a query before doing any compensation. As a consequence, all updates that are received at the data warehouse between the time when the query is initiated up to the time it is fully evaluated are considered concurrent updates.
Reference: [ZGMW96] <author> Yue Zhuge, Hector Garcia-Molina, and Janet L. Wiener. </author> <title> The Strobe Algorithms for Multi-Source Warehouse Consistency. </title> <booktitle> In Proceedings of the International Conference on Parallel and Distributed Information Systems, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: However, this approach may necessitate a solution in which the sources have to be contacted for additional information to ensure correctness. Example work includes the ECA algorithm [ZGMHW95] designed for a system with a central database site, the Strobe algorithms <ref> [ZGMW96] </ref> handling multiple, distributed sites, a hybrid system [HZ96a] combining different regions of the spectrum. Self-maintainable views which lie towards the fully materialized end of the spectrum [GJM96, QGMW96], or full replication [HZ96b] do not require additional querying of the sources. <p> Several consistency notions have been associated with the views at the data warehouse, viz., complete consistency, strong consistency, weak consistency, and convergence <ref> [ZGMHW95, ZGMW96] </ref>. We develop two efficient algorithms in this paper. <p> The two algorithms SWEEP and Nested SWEEP are presented in Sections 5 and 6. The paper concludes with a summary of the results in Section 7. 2 The Data Warehouse Model We adopt the data warehouse model developed in <ref> [ZGMW96, HZ96a, HZ96b] </ref>. In this model, updates occurring at the data sources are classified into three categories: 1. Single update transactions where each update is exe cuted at a single data source. 2. Source local transactions where a sequence of updates are performed as a single transaction. <p> However, all of the updates are directed to a single data source. 3. Global transactions where the updates involve multiple data sources. For the purpose of this paper, we assume that the updates being handled at the data warehouse are of types 1 and 2. The approaches described in <ref> [ZGMW96] </ref> can be used to extend the algorithms presented in this paper for type 3 updates. The updates at the data sources can be handled at the data warehouse in different ways. <p> The updates at the data sources can be handled at the data warehouse in different ways. Depending on how the updates are incorporated into the view at the data warehouse, different notions of consistency of the view have been identified in <ref> [ZGMW96, HZ96a] </ref>. <p> However, we assume that for a given data source, updates are executed atomically. As shown in source to the data warehouse. All the updates performed atomically at a data source are sent as a single unit from the source to the data warehouse <ref> [ZGMW96] </ref>. We assume that the view function used at the data warehouse for the materialized view is defined by the SPJ-expression (selection-projection-join). <p> Hence, the data warehouse problem is to maintain the views incrementally in the presence of concurrent updates occurring at the data sources. The ECA [ZGMHW95] and Strobe <ref> [ZGMW96] </ref> algorithms are examples of two approaches for addressing this problem. In the case of ECA, the data warehouse model is restricted in that the number of data sources is limited to a single data source. However, the data source may store several base relations. <p> There is no need to send individual incremental queries corresponding to each update fl R 2 . In ECA the size of query messages is quadratic in the number of interfering updates. Instead of generalizing ECA for a distributed data warehouse model, Zhuge et al. <ref> [ZGMW96] </ref> proposed a new algorithm called Strobe for maintaining views incrementally 1 Hull and Zhou [HZ96a] refer to this as the problem of "missing" contribution. in an environment with multiple data sources. <p> In fact, the materialized view will never get updated if there is no period of quiescence in the system. Strobe ensures strong consistency but not complete consistency since it incorporates the effects of several updates collectively. Zhuge et al. <ref> [ZGMW96] </ref> propose another algorithm called C-strobe, to circumvent the necessity of quiescence in the Strobe algorithm. In C-strobe, each update is handled completely at the data warehouse before handling subsequent updates. In this sense, C-strobe provides complete consistency. <p> If there are at most K concurrent updates that can arrive between the time a query is sent and its answer is received, then the authors show that at most K n2 queries need to be sent for a single update <ref> [ZGMW96] </ref>. Zhuge et al. [ZGMW96] optimize the C-strobe algorithm by exploiting the unique key attribute in SPJ expression and by classifying updates into inserts and deletes. When the initial update is a delete of a tuple it is immediately incorporated locally at the data warehouse. <p> If there are at most K concurrent updates that can arrive between the time a query is sent and its answer is received, then the authors show that at most K n2 queries need to be sent for a single update <ref> [ZGMW96] </ref>. Zhuge et al. [ZGMW96] optimize the C-strobe algorithm by exploiting the unique key attribute in SPJ expression and by classifying updates into inserts and deletes. When the initial update is a delete of a tuple it is immediately incorporated locally at the data warehouse. This is possible due to the unique key assumption. <p> However, this is still a very high value, and renders the algorithm unscalable for a large number of data sources. 4 On-line Error Correction Of Incremental View Compu tations All of the above algorithms, ECA [ZGMHW95], Strobe, and C-Strobe <ref> [ZGMW96] </ref>, completely evaluate the answer to a query before doing any compensation. As a consequence, all updates that are received at the data warehouse between the time when the query is initiated up to the time it is fully evaluated are considered concurrent updates.
References-found: 19

