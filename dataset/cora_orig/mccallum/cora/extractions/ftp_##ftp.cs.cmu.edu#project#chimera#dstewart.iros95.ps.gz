URL: ftp://ftp.cs.cmu.edu/project/chimera/dstewart.iros95.ps.gz
Refering-URL: http://www.cs.cmu.edu/~kem/ri/unused_pages/aml-pubs.html
Root-URL: 
Abstract: Component-based real-time software speeds devel-opment and lowers cost of robotics applications. It enables the use of rapid prototyping or incremental software process models. The Chimera Methodology is a software engineering paradigm targeted at developing and integrating dynamically reconfigurable and reusable real-time software components. It is founded upon the notion of port-based objects. The focus of this paper is how to apply the Chimera Methodology specifically to the development of robotic applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. A. Arbib and H. Ehrig, </author> <title> Linking Schemas and Module Specifications for Distributed Systems, </title> <booktitle> in Proc. of 2nd IEEE Workshop on Future Trends of Distributed Computing Systems, </booktitle> <address> Cairo, Egypt, </address> <month> September </month> <year> 1990. </year>
Reference: [2] <author> J. J. Craig, </author> <title> Introduction to Robotics, 2nd Ed., </title> <address> (Reading, Massa-chusetts: </address> <publisher> Addison Wesley), </publisher> <year> 1989. </year>
Reference-contexts: The component can be configured for different types of hardware, and can be used in different applications. An example of a generic component for robotics is a module that performs the forward kinematics using the Denavit-Hartenberg (DH) parameters <ref> [2] </ref>. The DH parameters are used to describe the link and joint characteristics of a robotic manipulator. A forward kinematics generic component can be configured for any manipulator by obtaining these parameters during initialization.
Reference: [3] <author> M. W. Gertz, </author> <title> A Visual Programming Environment for Real-Time Sensor-Based Systems, </title> <type> Ph.D. Dissertation, </type> <institution> Dept. of Electrical and Computer Engr, Carnegie Mellon University, </institution> <month> Nov. </month> <note> 1994; http://www.glue.umd.edu/~dstewart/bib/thesis/. </note>
Reference-contexts: To select a module is as easy as clicking on an icon representing a component in a library. The GUI then shows not only the modules selected, but all the port connections as well. An example of a task set displayed by Onika <ref> [3] </ref>, a GUI designed especially to support port-based objects, is shown in Figure 4. Cartesian teleoperation of an RMMS The RMMS is a robot which can quickly be constructed out of standard joints and links [6] . As such, it is the most flexible robotic manipulator available.
Reference: [4] <author> M.W. Gertz, D.B. Stewart, B. Nelson, and P.K. Khosla, </author> <title> Using hypermedia and reconfigurable software assembly to support virtual laboratories and factories, </title> <booktitle> in Proc. of 5th International Symposium on Robotics and Manufacturing (ISRAM), Maui, Hawaii, </booktitle> <pages> pp. 493-500, </pages> <month> August </month> <year> 1994. </year>
Reference: [5] <author> L. Kelmar and P.Khosla, </author> <title> Automatic generation of forward and inverse kinematics for a reconfigurable modular manipulators systems, </title> <journal> in J. Robotics Systems, vol.7, </journal> <volume> no.4, </volume> <pages> pp. 599-619, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Forward Kinematics Compute Forward Kinematics for a Puma 560 Robot. pinvkin Puma Inverse Kinematics Compute Inverse Kinematics for a Puma 560 Robot. tball 6-DOF Trackball Interface A hardware dependent interface to a 6 degree-of-freedom trackball. graphically assembling port-based objects. verse kinematics must be generalized, typically based on the DH parameters <ref> [5] </ref> . A task set for Cartesian teleoperation of the RMMS can be created by using the tball, cinterp, gfwdkin, ginvkin, and rmms components, as shown in Figure 5. The dotted lines represent configuration constants, while the solid lines represent state variables.
Reference: [6] <author> D. E. Schmitz, P. K. Khosla, and T. Kanade, </author> <title> The CMU reconfigurable modular manipulator system, </title> <booktitle> in Proc. of the International Symposium and Exposition on Robots (designated 19th ISIR), </booktitle> <address> Sydney, Australia, </address> <pages> pp. 473-488, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: An example of a task set displayed by Onika [3], a GUI designed especially to support port-based objects, is shown in Figure 4. Cartesian teleoperation of an RMMS The RMMS is a robot which can quickly be constructed out of standard joints and links <ref> [6] </ref> . As such, it is the most flexible robotic manipulator available. Due to its generality, the configuration of the robot is not known until run-time, and thus it is not feasible to use hardware specific control algorithms.
Reference: [7] <author> D. B. Stewart, M. W. Gertz, and P. K. Khosla, </author> <title> Software assembly for real-time applications based on a distributed shared memory model, </title> <booktitle> in Proc. of the 1994 Complex Systems Engineering Synthesis and Assessment Technology Workshop (CSESAW 94), </booktitle> <address> Silver Spring, MD, </address> <pages> pp. 217-224, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Assume that initially there are no application dependent com ponents required. 4.2 Stage 2: Assembly of Reusable Components The second stage is to create a task set by assembling reusable components <ref> [7] </ref>. In this section, several examples of task sets are given to demonstrate the use of the different types of software components, and how they can all be interchanged when defined using the port-based object model. The first example is Cartesian teleoperation of a Reconfigurable Modular Manipulator System (RMMS).
Reference: [8] <author> D.B. Stewart, P. Khosla, </author> <title> The Chimera Methodology: Designing Dynamically Reconfigurable and Reusable Real-Time Software using Port-Based Objects, </title> <note> to appear in International Journal of Software Engineering and Knowledge Engineering, </note> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Component-based real-time software speeds development and lowers cost of robotics applications. It enables the use of rapid prototyping or incremental software process models. The Chimera Methodology is a software engineering paradigm targeted at developing and integrating real-time software components <ref> [8] </ref>. It is founded upon the notion of port-based objects. It combines the port automaton computation model of a concurrent process with object-based design of software. <p> The Chimera Methodology is targeted towards distributed shared memory hardware architectures, in order to support real-time applications. Only Chimera is specific for dynamically reconfigurable real-time systems implemented in a distributed shared memory environment. An in-depth comparison of the Chimera Methodology to other frameworks for component-based software is presented in <ref> [8] </ref>. For sake of brevity, it is not repeated here. 3. <p> Much of the research in developing the Chimera Methodology addresses these integration components. The solution that forms part of the methodology is to create a standard set of integration components, and to incorporate them as services provided by the underlying RTOS <ref> [8] </ref>. Therefore, the need to write new integration components is eliminated and development time and cost for new applications is significantly reduced. See Section 5 for a discussion of the RTOS services required to support the Chimera Methodology. 4. <p> Development at this level uses the dynamic reconfiguration capabilities of the Chimera implementation of port-based objects <ref> [8] </ref>. Every function to be performed by the manipulator can be developed independently, by designing a task set for that one function only. That configuration is then saved as an entity, called a job.
Reference: [9] <author> D. B. Stewart, </author> <title> Real-Time Software Design and Analysis of Reconfigurable Multi-Sensor Based Systems, </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie Mellon University (Pittsburgh, </institution> <address> PA) April 1994. http://www.glue.umd.edu/~dstewart/bib/thesis/. </address>
Reference-contexts: Therefore, a task can execute autonomously since it never has to lock the local table. The local and global tables are updated to always contain the most recent data, and the local table is never updated while a task is using the table <ref> [9] </ref>. The Chimera Methodology is targeted towards distributed shared memory hardware architectures, in order to support real-time applications. Only Chimera is specific for dynamically reconfigurable real-time systems implemented in a distributed shared memory environment. <p> The assembly of software components at this stage can be performed either by a a command line interface, a graphical user interface (GUI), or for autonomous assembly from a C-program. Software assembly using a command line or C-program is described in detail in <ref> [9] </ref>. The easiest method, however, is to use the GUI. To select a module is as easy as clicking on an icon representing a component in a library. The GUI then shows not only the modules selected, but all the port connections as well. <p> Task frequency is also a configuration parameter for all tasks. After initialization, each task executes at its pre-determined frequency, and the task set can be scheduled using any popular real-time scheduling algorithm <ref> [9] </ref>. The tball and cinterp modules do not require any configuration constants from the RMMS, since it outputs data as Cartesian coordinates, which is independent of the robot in use. Cartesian teleoperation of a Puma 560 Suppose that a Puma 560 robot is to be used instead of the RMMS. <p> Tasks that are common to both task sets (such as the robot interface module, which would be common to all jobs in a subsystem) continue to execute. The Chimera implementation of the task manager and global state variable table implementation allow tasks to be activated and deactivated in real-time <ref> [9] </ref>. The primary concern is maintaining stability of the hardware during reconfiguration. Currently, this is achieved by using a pessimistic approach: dynamic reconfiguration is only performed when the physical hardware i.e. the robot is at rest.
Reference: [10] <author> D. B. Stewart and P. K. Khosla, </author> <title> Chimera 3.0 Real-Time Programming Environment, Program Documentation, </title> <institution> Dept. of Electrical and Computer Engr, Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213; http://www.glue.umd.edu/~dstewart/bib/manuals/. </address>
Reference-contexts: To create these modules, the programmer simply fills in the blanks of a C-language template. The template code handles all of the objects interfacing, communication, and synchronization. The programmer must only add the algorithms to produce the output response based on the input response. The template is defined in <ref> [10] </ref>. In preparation for the examples given to demonstrate the next stage, suppose that the generic components shown in Table 1 and the HD components shown in Table 2 are developed, and placed into a robotic manipulator domain library. <p> Optional services that improve the environment include an advanced real-time scheduler which supports aperiodic servers and soft real-time tasks, automatic task profiling, configuration file utilities, and a graphical user interface. These services have all been implemented as part of the Chimera RTOS, and is described in detail in <ref> [10] </ref>. Error handling is performed using a global error handling paradigm. Whenever an error is encountered, an error signal is generated. Any task, but typically the task manager, can catch the error, and perform handling as necessary.
Reference: [11] <author> M. Steenstrup, M. A. Arbib, and E. G. Manes, </author> <title> Port automata and the algebra of concurrent processes, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 27, no. 1, </volume> <pages> pp. 29-50, </pages> <month> August </month> <year> 1983. </year>
Reference: [12] <institution> Trident Robotics and Research, Inc., </institution> <note> TRC004 Users Manual, 2516 Matterhorn Dr., Wexford, PA 15090. </note>
Reference-contexts: An example of an interface component is a robot interface software module. Different robots require different signals to control them. For example, a PUMA robot can be controlled through a Trident Robotics Robot Control Board <ref> [12] </ref>, while a Robotics Research Arm is controlled through a Multibus-based custom controller. <p> control algorithms such as the forward and in Table 2: Example of software components in a hardware-dependent software library Name Function Description rmms RMMS Interface Hardware dependent interface to the Reconfigurable Modular Manipulator System (RMMS) puma Puma 560 Interface Hardware dependent interface to Puma robot, using the Trident Robotics TRC004 <ref> [12] </ref> to bypass VAL pfwdkin Puma Forward Kinematics Compute Forward Kinematics for a Puma 560 Robot. pinvkin Puma Inverse Kinematics Compute Inverse Kinematics for a Puma 560 Robot. tball 6-DOF Trackball Interface A hardware dependent interface to a 6 degree-of-freedom trackball. graphically assembling port-based objects. verse kinematics must be generalized, typically
Reference: [13] <author> P. Wegner, </author> <title> Concepts and paradigms of object-oriented programming, </title> <type> OOPS Messenger, vol.1, </type> <institution> no.1, pp.7-87, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Finally, the research is summarized in Section 6. 2. Background The port-based object is an abstraction for real-time software components that applies the port automaton computational model for concurrent processes [1][11] to object-based design <ref> [13] </ref>. A port-based object has all the properties associ ated with standard objects, including internal state, code and data encapsulation, and characterization by its methods. It also has input, output, and resource ports for real-time communication.
References-found: 13

