URL: http://www.cs.ucsd.edu/users/goguen/ps/ha.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: A Hidden Agenda  
Author: Joseph Goguen Grant Malcolm 
Date: April 1997  
Address: San Diego  
Affiliation: Dept. of Computer Science Engineering University of California at  Connect Centre Dept. of Computer Science University of Liverpool  
Pubnum: Report CS97-538,  
Abstract: This paper unveils and motivates an ambitious programme of hidden algebraic research in software engineering, beginning with our general goals, continuing with an overview of results, and including some future plans. Selected literature on concurrency and the object paradigm is reviewed, and a new perspective on nondeter-minism is developed. The main contribution is powerful hidden coinduction techniques for proving behavioral correctness of concurrent systems; several mechanical proofs are given using OBJ3. We also show how modularization, bisimulation, transition systems, concurrency and combinations of the functional, constraint, logic and object paradigms fit into hidden algebra. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Samson Abramsky. </author> <title> Interaction categories and communicating sequential processes. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. Hoare, </booktitle> <pages> pages 1-15. </pages> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: But as noted by Abramsky <ref> [1] </ref>, the veritable Babel of formalisms ... suggests that the current methodologies for concurrency are insufficiently constrained, or perhaps that some key ideas are still missing. <p> Despite these limitations, we have been much inspired by the many deep insights that can be found in the mainstream of concurrency research. Abramsky <ref> [1] </ref> introduces interaction categories, a very elegant categorical approach to processes, having some similarities to our approach to concurrency that deserve further exploration. <p> Approaches based on set theoretic semantic models, such as Z [91] and CSP [69], can lead to very difficult proofs involving properties of sets and hence axioms for set theory 6 . Denotational semantic models (e.g., [4]) are no better in this respect, and as Abramsky <ref> [1] </ref> remarks, have only been really successful for functional languages; this should not be surprising, because denotational semantics is so strongly based on the -calculus. For the ambitious verifier, set theoretic and denotational semantic definitions lead into a dangerous semantic swamp, infested with alligator-mouth-like 2s and/or sharkfin-like s.
Reference: [2] <author> Peter Aczel and Nax Mendler. </author> <title> A final coalgebra theorem. </title> <editor> In D.H. Pitt et al., editor, </editor> <booktitle> Category Theory and Computer Science. Springer, 1989. Lecture Notes in Computer Science, </booktitle> <volume> Volume 389. </volume>
Reference-contexts: There is also a distinguished tradition of research in coalgebra. One thread in this tradition seeks to show existence of final transition systems, which give rise to an abstract notion of bisimulation and can be used to give a semantics for process algebras <ref> [2, 6] </ref>. Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14].
Reference: [3] <author> Jiri Adamek. </author> <title> Observability and Nerode equivalence in concrete categories. </title> <editor> In Ferenc Gecseg, editor, </editor> <booktitle> Fundamentals of Computation Theory. Springer-Verlag Lecture Notes in Computer Science 117, </booktitle> <year> 1981. </year>
Reference: [4] <author> Pierre America, Jaco de Bakker, Joost Kok, and Jan Rutten. </author> <title> Denotational semantics of a parallel object-oriented language. </title> <journal> Information and Computation, </journal> <volume> 83(2) </volume> <pages> 152-205, </pages> <year> 1990. </year>
Reference-contexts: Approaches based on set theoretic semantic models, such as Z [91] and CSP [69], can lead to very difficult proofs involving properties of sets and hence axioms for set theory 6 . Denotational semantic models (e.g., <ref> [4] </ref>) are no better in this respect, and as Abramsky [1] remarks, have only been really successful for functional languages; this should not be surprising, because denotational semantics is so strongly based on the -calculus.
Reference: [5] <author> Jan Baeten and W.P. Weijland. </author> <title> Process Algebra. Cambridge, </title> <booktitle> 1990. Cambridge Tracts in Theoretical Computer Science, </booktitle> <volume> Volume 18. </volume>
Reference-contexts: So called `process algebras' (also called concurrency calculi), like CCS [79], ACP <ref> [5] </ref> and CSP [69], are typically presented using systems of equations. Equations are used very differently in process algebra than in hidden algebra. In process algebra, variables range over processes and operators combine processes.
Reference: [6] <author> Michael Barr. </author> <title> Terminal coalgebras in well-founded set theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 114 </volume> <pages> 299-315, </pages> <year> 1993. </year>
Reference-contexts: There is also a distinguished tradition of research in coalgebra. One thread in this tradition seeks to show existence of final transition systems, which give rise to an abstract notion of bisimulation and can be used to give a semantics for process algebras <ref> [2, 6] </ref>. Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14].
Reference: [7] <author> Michel Bidoit, Rolf Hennicker, and Martin Wirsing. </author> <title> Behavioural and abstractor specifications. </title> <journal> Science of Computer Programming, </journal> <note> to appear, 1996. 37 </note>
Reference-contexts: Behavioral equivalence of states, a generalization of bisimulation, appeared in [48], which also first recognized the connection between tree automata and software engineering. Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see <ref> [7, 21, 22] </ref> and the survey [81]. In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. <p> of signature arrows are appropriate for different purposes, and show that the one that should form an institution (morphisms) in fact does so (see also Section 4). 5 The first effective algebraic proof technique for behavioral properties was context induction, introduced by Hennicker [67] and further developed with Bidoit (e.g, <ref> [7] </ref>). This research programme is similar to ours in many ways; their approach is more concerned with semantics than with proofs, and their context induction can be very awkward to apply in practice (see [24] for a discussion of some of the difficulties).
Reference: [8] <author> Garrett Birkhoff. </author> <title> On teh structure of abstract algebras. </title> <booktitle> proceedings of the Cambridge Philosphical Society, </booktitle> <volume> 31 </volume> <pages> 433-454, </pages> <year> 1935. </year>
Reference-contexts: We build software tools to help deal with these huge algebras. 4. We build new kinds of algebra, to get better results in building software. All this is within the general framework of universal (also called `general') algebra, as pioneered by Birkhoff <ref> [8] </ref> and Tarski (among others). Our programme of research can be seen as a natural extension of universal algebra that takes account of the realities of modern software, and this paper reports on our work as algebraic engineers in the fourth sense.
Reference: [9] <author> Barry Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Most of the literature addresses code verification, but this is very difficult in practice, and empirical studies have shown that little of the cost of software arises from errors in coding: most comes from errors in design and requirements <ref> [9] </ref>. Moreover, many of the most important programs are written in obscure and/or obsolete languages, with complex ugly semantics (like Cobol, Jovial and Mumps), are very poorly documented, are indispensable to some enterprise, and are very large, often several million lines, sometimes more. <p> However, this is an area where mathematics can make a contribution. It is well known that most of the effort in programming goes into debugging and maintenance (i.e., into improving and updating programs) <ref> [9] </ref>. Therefore anything that can be done to ease these processes has enormous economic potential. <p> However, we contend that this isolation is actually an advantage. Empirical studies show that little of the difficulty of software development lies in the code itself (only about 5% <ref> [9] </ref>); much more of the difficulty lies in specification and design, and our approach addresses these directly, without assuming the heavy burden of a messy programming language semantics. But of course we can use algebraic semantics to verify code if we wish, as extensively illustrated in [45].
Reference: [10] <author> Rod Burstall. </author> <title> Programming with modules as typed functional programming. </title> <booktitle> Proceedings, International Conference on Fifth Generation Computing Systems, </booktitle> <year> 1985. </year>
Reference: [11] <author> Rod Burstall and Razvan Diaconescu. </author> <title> Hiding and behaviour: an institutional approach. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. Hoare, </booktitle> <pages> pages 75-92. </pages> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: The first systematic exposition of hidden algebra is given in [41], with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in <ref> [11] </ref>. Order sorted hidden algebra is further developed in [43] and [75], and [40] shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with [43, 75], in the context of correctness proofs for refinement of objects and abstract machines. <p> In [19], behavioral specification is applied to rewriting logic, through the sophisticated semantic definition of behavioral satisfaction between rewriting logic models and (conditional) rules that arises from the very general `institutional 4 ' approach to behavior developed in <ref> [11] </ref>. So called `process algebras' (also called concurrency calculi), like CCS [79], ACP [5] and CSP [69], are typically presented using systems of equations. Equations are used very differently in process algebra than in hidden algebra. In process algebra, variables range over processes and operators combine processes. <p> In practice, the best implementations are often neither initial nor final, but somewhere between. However, final hidden algebras are important for our theoretical development, and in particular, they play a key role in justifying hidden coinduction. The construction of a final algebra F below follows <ref> [11] </ref>, and should help our intuition to grasp what is going on. <p> The quotient under this equivalence gives an algebra which is used in <ref> [11] </ref> to define behavioral satisfaction. The constructions for initial and final abstract machines given in [48] are very similar to those given here, and are perhaps the first in the literature. 3.2 A Categorical Hat Trick Those who are antagonistic to and/or ignorant about category theory should skip this subsection.
Reference: [12] <author> Rod Burstall and Joseph Goguen. </author> <title> Putting theories together to make specifications. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> Proceedings, Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1045-1058. </pages> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1977. </year>
Reference: [13] <author> Graham Button and Wes Sharrock. </author> <title> Occasioned practises in the work of implementing development methodologies. </title> <editor> In Marina Jirotka and Joseph Goguen, editors, </editor> <booktitle> Requirements Engineering: Social and Technical Issues, </booktitle> <pages> pages 217-240. </pages> <publisher> Academic, </publisher> <year> 1994. </year>
Reference-contexts: However, we would emphasize that our results apply to ordinary programs and their components, because these can be regarded as abstract machines. 2 Empirical studies show that real software development projects involve many false starts, redesigns, prototypes, patches, etc. <ref> [13] </ref>. <p> Thus we have achieved a significant separation of concerns. 23 Empirical studies show that this view of software development is naive; real development projects involve many false starts, redesigns, prototypes, patches, etc. <ref> [13] </ref>.
Reference: [14] <author> Corina C^rstea. </author> <title> A Semantic Study of the Object Paradigm. </title> <type> Transfer thesis, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1996. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm <ref> [86, 70, 71, 72, 14] </ref>. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. <p> ) [ I ' , where I ' represents the noninterference axioms of Definition 57, and where we recall that E i = fc [e] j e 2 E i ; c 2 C i [z] v g : It is straightforward to check that this is an initial connection <ref> [14] </ref>. 2 Thus the specification XY of Example 55 is the concurrent connection of X and Y synchronized over the sort State, where the shared part P might (for example) be th STATE is sort State . pr DATA . endth where DATA contains at least NAT and the Booleans. <p> The concurrent connection of two objects without synchronization is their coproduct in the category having appropriate specifications as objects and certain refinements as morphisms; more generally, Corina C^rstea has shown that concurrent connection with synchronization is colimit in this category <ref> [14] </ref>. Finally, we emphasize that the definition of concurrent connection in this section is not really suitable for proofs, but instead provides an abstract characterization of the intended semantics.
Reference: [15] <author> Corina C^rstea. </author> <title> Coalgebra semantics for hidden algebra: parameterized objects and inheritance. </title> <booktitle> Paper presented at the 12th Workshop on Algebraic Development Techniques, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. Reichel [86] was the first to apply coalgebra explicitly to the object paradigm, and his basic construction can be used to show that hidden algebra extends coalgebra with generalised constants <ref> [74, 15] </ref>. It is precisely this extension that allows the treatment of nondeterminism we advocate in this paper.
Reference: [16] <author> Razvan Diaconescu. </author> <title> The logic of Horn clauses is equational. </title> <type> Technical Report PRG-TR-3-93, </type> <institution> Programming Research Group, University of Oxford, </institution> <year> 1993. </year> <note> Written in 1990. </note>
Reference-contexts: The work in this section (and also on refinement in Section 4) extends to Horn clause logic with equality, by applying a construction that reduces that logic to hidden equational logic (see [47], extending Diaconescu <ref> [16] </ref>). This gives a paradigm that unifies the object paradigm with equational logic programming and traditional Horn clause logic programming [49]. 3 Behavior and Hidden Coinduction Induction is a standard technique for proving properties of initial (or more generally, reachable) algebras of a theory.
Reference: [17] <author> Razvan Diaconescu. </author> <title> Category-based Semantics for Equational and Constraint Logic Programming. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1994. </year>
Reference-contexts: It should be possible to combine the object, logic, and constraint paradigms along the lines of [42], using the very elegant category theoretic approach to constraint logic programming described in <ref> [17, 18] </ref>. Note that ordinary imperative programming is the special case of hidden algebra where the objects correspond to program variables; hence our work will apply to traditional concurrent and sequential programming 7 . <p> There are no hidden equations. 2 Hidden algebra can be regarded as an instance of the constraint logic as described in <ref> [17, 18] </ref>: (V; ) is the signature of builtins, D the model of builtins, and is an extension of the `logical' signature; however, hidden algebras differ from constraint logic models, because the builtins are protected. 2.3 Nondeterminism Modern distributed programming paradigms cannot do without nondeterminism, because the nodes of a network
Reference: [18] <author> Razvan Diaconescu. </author> <title> A category-based equational logic semantics to constraint programming. </title> <editor> In Magne Haveraaen, Olaf Owe, and Ole-Johan Dahl, editors, </editor> <title> Recent Trends in Data Type Specification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> pages 200-222. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: It should be possible to combine the object, logic, and constraint paradigms along the lines of [42], using the very elegant category theoretic approach to constraint logic programming described in <ref> [17, 18] </ref>. Note that ordinary imperative programming is the special case of hidden algebra where the objects correspond to program variables; hence our work will apply to traditional concurrent and sequential programming 7 . <p> There are no hidden equations. 2 Hidden algebra can be regarded as an instance of the constraint logic as described in <ref> [17, 18] </ref>: (V; ) is the signature of builtins, D the model of builtins, and is an extension of the `logical' signature; however, hidden algebras differ from constraint logic models, because the builtins are protected. 2.3 Nondeterminism Modern distributed programming paradigms cannot do without nondeterminism, because the nodes of a network
Reference: [19] <author> Razvan Diaconescu. </author> <title> Foundations of behavioural specification in rewriting logic. </title> <booktitle> In Proceedings, First International Workshop on Rewriting Logic and its Applications. Asilomar, </booktitle> <address> California, </address> <month> September </month> <year> 1996. </year> <note> North-Holland, to appear 1996. </note>
Reference-contexts: However, its treatment of objects (and messages), based on an associative-commutative (AC) `soupification 3 ' operation, seems to raise substantial difficulties for proving properties of large systems, due to the computational complexity of AC unification, and the concrete level of its representations. In <ref> [19] </ref>, behavioral specification is applied to rewriting logic, through the sophisticated semantic definition of behavioral satisfaction between rewriting logic models and (conditional) rules that arises from the very general `institutional 4 ' approach to behavior developed in [11].
Reference: [20] <author> Razvan Diaconescu, Joseph Goguen, and Petros Stefaneas. </author> <title> Logical support for modularisation. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Environments, </booktitle> <pages> pages 83-130. </pages> <address> Cambridge, </address> <year> 1993. </year> <title> Proceedings of a Workshop held in Edinburgh, </title> <address> Scotland, </address> <month> May </month> <year> 1991. </year>
Reference: [21] <author> Hartmut Ehrig, Hans-Jorg Kreowski, Bernd Mahr, and Peter Padawitz. </author> <title> Algebraic implementation of abstract data types. </title> <journal> Theoretical Computer Science, </journal> <volume> 20 </volume> <pages> 209-263, </pages> <year> 1983. </year>
Reference-contexts: Behavioral equivalence of states, a generalization of bisimulation, appeared in [48], which also first recognized the connection between tree automata and software engineering. Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see <ref> [7, 21, 22] </ref> and the survey [81]. In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39].
Reference: [22] <author> Hartmut Ehrig, Fernando Orejas, Felix Cornelius, and Michael Baldamus. </author> <title> Abstract and behaviour module specifications. </title> <type> Technical Report 93-25, </type> <institution> Technische Universitat Berlin, </institution> <year> 1993. </year>
Reference-contexts: Behavioral equivalence of states, a generalization of bisimulation, appeared in [48], which also first recognized the connection between tree automata and software engineering. Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see <ref> [7, 21, 22] </ref> and the survey [81]. In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. <p> In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in <ref> [22] </ref>, which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [23] <author> Samuel Eilenberg and Jesse Wright. </author> <title> Automata in general algebras. </title> <journal> Information and Control, </journal> <volume> 11 </volume> <pages> 452-470, </pages> <year> 1967. </year>
Reference-contexts: Hidden algebra also generalizes automaton theory, which again has a long tradition in computing science; we would particularly mention the pioneering work of Eilenberg and Wright <ref> [23] </ref>, which took a categorical approach to `tree automata,' generalizing traditional state transition automata. The first systematic exposition of hidden algebra is given in [41], with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in [11].
Reference: [24] <author> Marie-Claude Gaudel and Igor Privara. </author> <title> Context induction: an exercise. </title> <type> Technical Report 687, </type> <institution> LRI, Universite de Paris-Sud, </institution> <year> 1991. </year>
Reference-contexts: This research programme is similar to ours in many ways; their approach is more concerned with semantics than with proofs, and their context induction can be very awkward to apply in practice (see <ref> [24] </ref> for a discussion of some of the difficulties). We propose hidden coinduction as a way to eliminate the awkwardness of context induction. Reichel's seminal work on behavioral satisfaction was in part motivated by an insight on how to unify initial and final semantics [84].
Reference: [25] <author> V. Giarrantana, F. Gimona, and Ugo Montanari. </author> <title> Observability concepts in abstract data specifications. </title> <booktitle> In Proceedings, Conference on Mathematical Foundations of Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1976. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 45. </volume>
Reference-contexts: We propose hidden coinduction as a way to eliminate the awkwardness of context induction. Reichel's seminal work on behavioral satisfaction was in part motivated by an insight on how to unify initial and final semantics [84]. Behavioral and final semantics were perhaps first advocated by Montanari et al. <ref> [25] </ref>, though Wand [95] also made an early contribution. Finality is also used for treating states in [84, 48, 78, 74], among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86].
Reference: [26] <author> Joseph Goguen. </author> <title> Semantics of computation. </title> <editor> In Ernest G. Manes, editor, </editor> <booktitle> Proceedings, First International Symposium on Category Theory Applied to Computation and Control, </booktitle> <pages> pages 151-163. </pages> <publisher> Springer, </publisher> <year> 1975. </year> <note> Lecture Notes in Computer Science, Volume 25; also in Proceedings, </note> <institution> University of Massachusetts at Amherst, </institution> <year> 1974, </year> <pages> pages 234-249. 38 </pages>
Reference-contexts: We begin before the beginning, with algebra. Although algebra has its roots in mathematics, computing science has made several contributions, starting with a simplification of notation for many sorted algebra <ref> [26] </ref>, and continuing with initial algebra semantics (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently <p> We begin before the beginning, with algebra. Although algebra has its roots in mathematics, computing science has made several contributions, starting with a simplification of notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) <ref> [26, 57, 58] </ref>, then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> The founding paper in hidden algebra is [33], which builds on earlier algebraic work on abstract data types <ref> [26, 57, 58] </ref>, and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines [48, 78].
Reference: [27] <author> Joseph Goguen. </author> <title> Parameterized programming. </title> <journal> Transactions on Software Engineering, </journal> <volume> SE-10(5):528--543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [28] <author> Joseph Goguen. </author> <title> Suggestions for using and organizing libraries in software development. </title> <editor> In Steven Kar-tashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, First International Conference on Supercomputing Systems, </booktitle> <pages> pages 349-360. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1985. </year> <note> Also in Supercomputing Systems, </note> <editor> Steven and Svetlana Kartashev, Eds., </editor> <publisher> Elsevier, </publisher> <year> 1986. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [29] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [30] <author> Joseph Goguen. </author> <title> Higher-order functions considered unnecessary for higher-order programming. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 309-352. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year> <institution> University of Texas at Austin Year of Programming Series. </institution>
Reference-contexts: However, for expository simplicity, this paper treats only hidden many sorted algebra. The module system of parameterized programming gives us other forms of inheritance, plus all the power of higher order functional programming in a first order setting which facilitates both proving and programming <ref> [30] </ref>. Modularization is weak in many contemporary languages, especially in object and logic languages; moreover, it can be surprisingly hard to reuse code in practice, and methods to support development remain vague.
Reference: [31] <author> Joseph Goguen. Hyperprogramming: </author> <title> A formal approach to software environments. </title> <booktitle> In Proceedings, Symposium on Formal Approaches to Software Environment Technology. Joint System Development Corporation, </booktitle> <address> Tokyo, Japan, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [32] <author> Joseph Goguen. </author> <title> Proving and rewriting. </title> <editor> In Helene Kirchner and Wolfgang Wechler, editors, </editor> <booktitle> Proceedings, Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 1-24. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 463. </volume>
Reference-contexts: This proof was fairly straightforward to construct, except for the lemma. However, our style of using OBJ greatly facilitated even this, by producing an expression that suggested lemma; this is typical of our experience with OBJ proof scores <ref> [32, 45, 37] </ref>. Notice that in this implementation the term top empty is given the concrete value 0; however, it could have been given any other value, for example, by adding one of the equations eq top 0 || A = s 0 .
Reference: [33] <author> Joseph Goguen. </author> <title> Types as theories. </title> <editor> In George Michael Reed, Andrew William Roscoe, and Ralph F. Wachter, editors, </editor> <booktitle> Topology and Category Theory in Computer Science, </booktitle> <pages> pages 357-390. </pages> <address> Oxford, </address> <year> 1991. </year> <booktitle> Proceedings of a Conference held at Oxford, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra <ref> [33, 41, 43] </ref>, or hidden algebra for short. The hidden approach differs from earlier approaches in its explicit connections to the object paradigm, including concurrency, its use of a fixed universe of data values, and its use of behavioral satisfaction. <p> The hidden approach differs from earlier approaches in its explicit connections to the object paradigm, including concurrency, its use of a fixed universe of data values, and its use of behavioral satisfaction. The founding paper in hidden algebra is <ref> [33] </ref>, which builds on earlier algebraic work on abstract data types [26, 57, 58], and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines [48, 78]. <p> In fact, it seems difficult to treat nondeterminism at all in a purely coalgebraic approach, since the obvious move of using power objects in the defining functor compromises the effectiveness of equational reasoning. Hidden algebra was developed with the object paradigm in mind <ref> [33, 41] </ref>, but it also supports combining the functional, logic (see Section 2.4) and object paradigms [34, 47] and [44]. The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49].
Reference: [34] <author> Joseph Goguen. </author> <title> An approach to situated adaptive software. </title> <booktitle> In Proceedings, International Workshop on New Models of Software Architecture, </booktitle> <pages> pages 7-20. </pages> <address> NEDO, </address> <year> 1993. </year>
Reference-contexts: Hidden algebra was developed with the object paradigm in mind [33, 41], but it also supports combining the functional, logic (see Section 2.4) and object paradigms <ref> [34, 47] </ref> and [44]. The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49].
Reference: [35] <author> Joseph Goguen. </author> <title> Requirements engineering as the reconciliation of social and technical issues. </title> <editor> In Marina Jirotka and Joseph Goguen, editors, </editor> <booktitle> Requirements Engineering: Social and Technical Issues, </booktitle> <pages> pages 165-200. </pages> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: 24: Given a consistent lexic hidden theory (; E), then an initial (; E)-algebra G behaviorally satisfies a -query q iff every (; E)-algebra behaviorally satisfies q. 2 15 However, real software development processes involve much more, including constantly evolving requirements and the resulting need to constantly evolve the software <ref> [35] </ref>. 18 We can always choose a canonical term algebra [57] for G, and thus use narrowing to solve queries, as illustrated in [47]; of course, more efficient methods can be used in special cases.
Reference: [36] <author> Joseph Goguen. </author> <title> Parameterized programming and software architecture. </title> <booktitle> In Proceedings, Reuse'96, </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1996. </year> <type> Invited keynote address. </type>
Reference: [37] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: This principle allows us to justify our proof techniques model theoretically, reflecting our view that 1 semantics is fundamental at the meta level (for showing correctness for proof rules), while syntax is fundamental at the object level (for building, describing and verifying systems). (See <ref> [37] </ref> for further discussion and examples of this viewpoint.) Since we use hidden sorts to specify classes of objects, order sorted algebra provides a very natural way to handle multiple inheritance; it also allows specifying partial functions, non-terminating systems, subtypes of various kinds, error definition and recovery, coercions, overwriting, multiple representations, <p> Of course, much of the `interesting' work could also be automated, including the examples in this paper, but this is certainly impossible in general. We assume some familiarity with basic many sorted algebra and with OBJ. The relevant background (and much more!) can be found in <ref> [45, 37, 57, 60] </ref> and [78], among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. <p> Principles of induction can be justified from the fact that an initial algebra has no proper subalgebras (e.g., <ref> [37, 78] </ref>). We will see that final (terminal) algebras play an analogous role in justifying reasoning about behavioral properties with hidden coinduction. <p> : Flag Flag -&gt; Bool . var F1 F2 : Flag . eq F1 R F2 = (up? F1 == up? F2) . ops f1 f2 : -&gt; Flag . close The new constants f1, f2 are introduced to stand for universally quantified variables (using the ordinary theorem of constants <ref> [45, 37] </ref>). <p> This proof was fairly straightforward to construct, except for the lemma. However, our style of using OBJ greatly facilitated even this, by producing an expression that suggested lemma; this is typical of our experience with OBJ proof scores <ref> [32, 45, 37] </ref>. Notice that in this implementation the term top empty is given the concrete value 0; however, it could have been given any other value, for example, by adding one of the equations eq top 0 || A = s 0 .
Reference: [38] <author> Joseph Goguen and Rod Burstall. </author> <title> CAT, a system for the structured elaboration of correct programs from structured specifications. </title> <type> Technical Report CSL-118, </type> <institution> SRI Computer Science Lab, </institution> <month> October </month> <year> 1980. </year>
Reference: [39] <author> Joseph Goguen and Rod Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 39(1) </volume> <pages> 95-146, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' <ref> [39] </ref>. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction. <p> The perhaps initially mysterious fact that mappings go in opposite directions for specifications and for models is explained at a higher level of abstraction by the theory of institutions <ref> [39] </ref>, which shows that in logics satisfying certain mild assumptions, it is natural that the maps induced by a signature morphism on models and on theories should go in opposite directions. Hence, the duality between model based and theory based refinement is very natural.
Reference: [40] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> An Oxford survey of order sorted algebra. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 4 </volume> <pages> 363-392, </pages> <year> 1994. </year>
Reference-contexts: The relevant background (and much more!) can be found in [45, 37, 57, 60] and [78], among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. We try to avoid 1 <ref> [40] </ref> discusses polymorphism, dynamic binding and overwriting, and [50] discusses errors, coercions, etc. 2 category theory, but in some cases its greater elegance and power was so compelling that we could not resist. <p> notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations <ref> [40, 52, 50] </ref>), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> The first systematic exposition of hidden algebra is given in [41], with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in [43] and [75], and <ref> [40] </ref> shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with [43, 75], in the context of correctness proofs for refinement of objects and abstract machines. <p> We first specify a non-deterministic stack. (Since this paper is limited to many sorted algebra, the handling of errors is weak; <ref> [40, 52] </ref> show how to do it better with order sorted algebra.) Example 18: Here the operation push nondeterministically puts a new natural number on top of a stack.
Reference: [41] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> Towards an algebraic semantics for the object paradigm. </title> <editor> In Hartmut Ehrig and Fernando Orejas, editors, </editor> <booktitle> Proceedings, Tenth Workshop on Abstract Data Types, </booktitle> <pages> pages 1-29. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 785. </volume>
Reference-contexts: (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra <ref> [33, 41, 43] </ref>, or hidden algebra for short. The hidden approach differs from earlier approaches in its explicit connections to the object paradigm, including concurrency, its use of a fixed universe of data values, and its use of behavioral satisfaction. <p> The first systematic exposition of hidden algebra is given in <ref> [41] </ref>, with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in [43] and [75], and [40] shows how to handle overwriting of methods using a special kind of signature. <p> In fact, it seems difficult to treat nondeterminism at all in a purely coalgebraic approach, since the obvious move of using power objects in the defining functor compromises the effectiveness of equational reasoning. Hidden algebra was developed with the object paradigm in mind <ref> [33, 41] </ref>, but it also supports combining the functional, logic (see Section 2.4) and object paradigms [34, 47] and [44]. The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49]. <p> This section describes an elegant construction of composite systems from components using the concurrent connection (a weaker version of this construction was called the independent sum when first introduced in <ref> [41] </ref>). As motivation, consider the following: 34 Example 55: Recall the specification X of an integer cell X in Example 8, and define another integer cell, Y , by everywhere replacing X and x with Y and y, respectively. <p> Although the components P i must have just one hidden sort, the candidate connections Q need not have this property. However, the proof of the result below (slightly generalizing the proof in <ref> [41] </ref>) shows that it does have just one hidden sort. 35 Theorem 58: Every synchronization ' 1 : P ! P 1 ; ' 2 : P ! P 2 has a concurrent connection.
Reference: [42] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> An introduction to category-based equational logic. In V.S. </title> <editor> Alagar and Maurice Nivat, editors, </editor> <booktitle> Proceedings, </booktitle> <volume> AMAST 95, </volume> <pages> pages 91-126. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 936. </volume>
Reference-contexts: The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49]. It should be possible to combine the object, logic, and constraint paradigms along the lines of <ref> [42] </ref>, using the very elegant category theoretic approach to constraint logic programming described in [17, 18]. Note that ordinary imperative programming is the special case of hidden algebra where the objects correspond to program variables; hence our work will apply to traditional concurrent and sequential programming 7 .
Reference: [43] <author> Joseph Goguen and Grant Malcolm. </author> <title> Proof of correctness of object representation. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. Hoare, </booktitle> <pages> pages 119-142. </pages> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra <ref> [33, 41, 43] </ref>, or hidden algebra for short. The hidden approach differs from earlier approaches in its explicit connections to the object paradigm, including concurrency, its use of a fixed universe of data values, and its use of behavioral satisfaction. <p> The first systematic exposition of hidden algebra is given in [41], with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in <ref> [43] </ref> and [75], and [40] shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with [43, 75], in the context of correctness proofs for refinement of objects and abstract machines. <p> The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in [43] and [75], and [40] shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with <ref> [43, 75] </ref>, in the context of correctness proofs for refinement of objects and abstract machines. The hidden approach uses behavioral satisfaction to get an algebraic treatment of state that abstracts away from implementation details. <p> Theorem 27 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. This justifies a variety of techniques for proving behavioral equivalence (see also <ref> [43, 75] </ref>). In this context, a relation may be called a candidate relation before it is proved to be a hidden congruence. <p> Another possibility would be to use a different candidate relation, say S1 R S2 = top S1 == top S2 and (pop S1) R (pop S2) . This relation would of course require a different correctness proof <ref> [43] </ref>. It is also worth noting that although this specification has two hidden sorts, but we are mainly interested in one of them, namely Stack; both sorts have visible-valued operations, but only the Stack sort's (single) visible-valued operation (namely top) is an attribute.
Reference: [44] <author> Joseph Goguen and Grant Malcolm. </author> <title> Situated adaptive software: beyond the object paradigm. </title> <booktitle> In Proceedings, International Symposium on New Models of Software Architecture, </booktitle> <pages> pages 126-142. </pages> <institution> Information-Technology Promotion Agency, </institution> <year> 1995. </year> <month> 39 </month>
Reference-contexts: Hidden algebra was developed with the object paradigm in mind [33, 41], but it also supports combining the functional, logic (see Section 2.4) and object paradigms [34, 47] and <ref> [44] </ref>. The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49]. <p> For us, the most important of these is existential quantification, because it provides the existential queries that are the basis of our combined logic-object paradigm <ref> [47, 44] </ref>: Definition 23: An (existential) query is a sentence of the form (9X) t 1 = t 0 m and is behaviorally satisfied by a -algebra A iff there is some assignment : X ! A such that fl (c j [t j ]) = fl (c j [t 0 <p> Applications of this paradigm <ref> [44] </ref> may involve queries to an object oriented database where the resulting object is not just retrieved, but actually created.
Reference: [45] <author> Joseph Goguen and Grant Malcolm. </author> <title> Algebraic Semantics of Imperative Programs. </title> <publisher> MIT, </publisher> <year> 1996. </year>
Reference-contexts: Of course, much of the `interesting' work could also be automated, including the examples in this paper, but this is certainly impossible in general. We assume some familiarity with basic many sorted algebra and with OBJ. The relevant background (and much more!) can be found in <ref> [45, 37, 57, 60] </ref> and [78], among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. <p> 6 Of course, any algebraic laws that have been shown to hold can be used, but because any such rule set must be incomplete, such an approach is necessarily limited. 7 This does not mean that traditional pre- and post-condition techniques cannot be used; in fact, our `executable' algebraic text <ref> [45] </ref> on the semantics of imperative programs shows how order sorted algebra and rewriting can add greatly to their effectiveness. 7 1.3 Acknowledgements The research described in this paper has been supported in part by Fujitsu Laboratories Ltd., the cec under esprit-2 bra Working Groups 6071, is-core (Information Systems COrrectness and <p> The underbar characters indicate where an argument goes, so that the successor operator s_ has prefix syntax, and the inequality operator _&lt;_ has infix syntax. The rest of the OBJ3 syntax used here should be fairly self-evident; for more on OBJ3, see <ref> [45, 60] </ref>. Our examples assume a fixed OBJ3 module DATA giving a signature and axioms for D (D need not be a term model for DATA, or even an initial model). <p> : Flag Flag -&gt; Bool . var F1 F2 : Flag . eq F1 R F2 = (up? F1 == up? F2) . ops f1 f2 : -&gt; Flag . close The new constants f1, f2 are introduced to stand for universally quantified variables (using the ordinary theorem of constants <ref> [45, 37] </ref>). <p> But of course we can use algebraic semantics to verify code if we wish, as extensively illustrated in <ref> [45] </ref>. Thus we have achieved a significant separation of concerns. 23 Empirical studies show that this view of software development is naive; real development projects involve many false starts, redesigns, prototypes, patches, etc. [13]. <p> Some subtle points regarding our use of OBJ3's builtin equality relation == are discussed in Section 1.1 of <ref> [45] </ref>. 2 Exercise 50: Show that the use of the lemma in the congruence proof is not circular, because its use there depends only on R being transitive and symmetric, not on its being a congruence. <p> This proof was fairly straightforward to construct, except for the lemma. However, our style of using OBJ greatly facilitated even this, by producing an expression that suggested lemma; this is typical of our experience with OBJ proof scores <ref> [32, 45, 37] </ref>. Notice that in this implementation the term top empty is given the concrete value 0; however, it could have been given any other value, for example, by adding one of the equations eq top 0 || A = s 0 .
Reference: [46] <author> Joseph Goguen and Grant Malcolm. </author> <title> More higher order programming in OBJ3. </title> <editor> In Joseph Goguen and Grant Malcolm, editors, </editor> <title> Algebraic Specification with OBJ: An Introduction with Case Studies. </title> <note> To appear. </note>
Reference: [47] <author> Joseph Goguen, Grant Malcolm, and Tom Kemp. </author> <title> A hidden Herbrand theorem, </title> <note> to appear. </note>
Reference-contexts: Hidden algebra was developed with the object paradigm in mind [33, 41], but it also supports combining the functional, logic (see Section 2.4) and object paradigms <ref> [34, 47] </ref> and [44]. The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in [49]. <p> This motivates: 12 Definition 10: A hidden theory is consistent iff it has at least one model. 2 Some techniques for guaranteeing consistent specifications from <ref> [47] </ref> are summarized in Theorem 13 below, which uses the following concepts: Definition 11: A (X)-term is local iff it is a constant or a variable (i.e., is in D or in X); a (X)-term that is not a (X)-term is local iff all visible proper subterms are local. <p> For us, the most important of these is existential quantification, because it provides the existential queries that are the basis of our combined logic-object paradigm <ref> [47, 44] </ref>: Definition 23: An (existential) query is a sentence of the form (9X) t 1 = t 0 m and is behaviorally satisfied by a -algebra A iff there is some assignment : X ! A such that fl (c j [t j ]) = fl (c j [t 0 <p> The following result is from <ref> [47] </ref>: Theorem 24: Given a consistent lexic hidden theory (; E), then an initial (; E)-algebra G behaviorally satisfies a -query q iff every (; E)-algebra behaviorally satisfies q. 2 15 However, real software development processes involve much more, including constantly evolving requirements and the resulting need to constantly evolve the <p> E)-algebra behaviorally satisfies q. 2 15 However, real software development processes involve much more, including constantly evolving requirements and the resulting need to constantly evolve the software [35]. 18 We can always choose a canonical term algebra [57] for G, and thus use narrowing to solve queries, as illustrated in <ref> [47] </ref>; of course, more efficient methods can be used in special cases. Applications of this paradigm [44] may involve queries to an object oriented database where the resulting object is not just retrieved, but actually created. <p> The work in this section (and also on refinement in Section 4) extends to Horn clause logic with equality, by applying a construction that reduces that logic to hidden equational logic (see <ref> [47] </ref>, extending Diaconescu [16]). This gives a paradigm that unifies the object paradigm with equational logic programming and traditional Horn clause logic programming [49]. 3 Behavior and Hidden Coinduction Induction is a standard technique for proving properties of initial (or more generally, reachable) algebras of a theory.
Reference: [48] <author> Joseph Goguen and Jose Meseguer. </author> <title> Universal realization, persistent interconnection and implementation of abstract modules. </title> <editor> In M. Nielsen and E.M. Schmidt, editors, </editor> <booktitle> Proceedings, 9th International Conference on Automata, Languages and Programming, </booktitle> <pages> pages 265-281. </pages> <publisher> Springer, </publisher> <year> 1982. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 140. </volume>
Reference-contexts: The founding paper in hidden algebra is [33], which builds on earlier algebraic work on abstract data types [26, 57, 58], and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines <ref> [48, 78] </ref>. Hidden algebra also generalizes automaton theory, which again has a long tradition in computing science; we would particularly mention the pioneering work of Eilenberg and Wright [23], which took a categorical approach to `tree automata,' generalizing traditional state transition automata. <p> The hidden approach uses behavioral satisfaction to get an algebraic treatment of state that abstracts away from implementation details. The elegant idea of behavioral satisfaction was introduced by Reichel [84] in the context of partial algebras; see also [85]. Behavioral equivalence of states, a generalization of bisimulation, appeared in <ref> [48] </ref>, which also first recognized the connection between tree automata and software engineering. Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. <p> Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand [95] also made an early contribution. Finality is also used for treating states in <ref> [84, 48, 78, 74] </ref>, among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86]. <p> Some sophisticated results on computability for initial and final algebras appear in [80]; both initiality and finality results compatible with the hidden paradigm were proved in <ref> [48] </ref>. This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag [62, 63]. <p> The quotient under this equivalence gives an algebra which is used in [11] to define behavioral satisfaction. The constructions for initial and final abstract machines given in <ref> [48] </ref> are very similar to those given here, and are perhaps the first in the literature. 3.2 A Categorical Hat Trick Those who are antagonistic to and/or ignorant about category theory should skip this subsection. <p> Exercise 51: Specify sets and lists and, by verifying an appropriate refinement, show that sets can be implemented with lists. 2 A more sophisticated view of refinement <ref> [48, 89, 67, 81] </ref> allows the concrete implementation to rename or even identify some of the abstract sorts and operations, thus giving rise to a hidden signature map from the abstract to the concrete signature: Definition 52: A hidden signature map ' : (H; ) ! (H 0 ; 0 )
Reference: [49] <author> Joseph Goguen and Jose Meseguer. </author> <title> Eqlog: Equality, types, and generic modules for logic programming. </title> <editor> In Douglas DeGroot and Gary Lindstrom, editors, </editor> <booktitle> Logic Programming: Functions, Relations and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice Hall, </publisher> <year> 1986. </year> <title> An earlier version appears in Journal of Logic Programming, </title> <journal> Volume 1, </journal> <volume> Number 2, </volume> <pages> pages 179-210, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: The key to combining different paradigms is to combine their underlying semantics at an appropriate level of abstraction, as advocated in <ref> [49] </ref>. It should be possible to combine the object, logic, and constraint paradigms along the lines of [42], using the very elegant category theoretic approach to constraint logic programming described in [17, 18]. <p> = 1; :::; m and all appropriate contexts c j . 2 To establish our combined logic-object paradigm, we need a hidden Herbrand theorem to reduce reasoning over arbitrary models (e.g., of object oriented databases) to reasoning over a single `Herbrand universe' term algebra, as in ordinary logic programming (see <ref> [49] </ref> for a precise statement of the corresponding result for equational logic programming). <p> This gives a paradigm that unifies the object paradigm with equational logic programming and traditional Horn clause logic programming <ref> [49] </ref>. 3 Behavior and Hidden Coinduction Induction is a standard technique for proving properties of initial (or more generally, reachable) algebras of a theory. Principles of induction can be justified from the fact that an initial algebra has no proper subalgebras (e.g., [37, 78]).
Reference: [50] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor selector, multiple representation and coercion problems. </title> <booktitle> In Proceedings, Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 18-29. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1987. </year>
Reference-contexts: We try to avoid 1 [40] discusses polymorphism, dynamic binding and overwriting, and <ref> [50] </ref> discusses errors, coercions, etc. 2 category theory, but in some cases its greater elegance and power was so compelling that we could not resist. <p> notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations <ref> [40, 52, 50] </ref>), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> us by Razvan Diaconescu.) To summarize, hidden coinduction is the proof technique where we define a relation, show it is a hidden congruence, and then show behavioral equivalence of two terms by showing they are congruent. 19 More information on constructors and selectors in order sorted algebra is given in <ref> [50] </ref>. 21 Exercise 33: Prove that the equation eq putx (M,putx (N,S)) = putx (M,S) . is a behavioral consequence of the theory X in Example 8, and that it is not strictly satisfied. (A proof for the satisfaction part of this exercise appears in Appendix B.) 2 The way we
Reference: [51] <author> Joseph Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming, with logical semantics. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT, </publisher> <year> 1987. </year>
Reference: [52] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 217-273, </pages> <year> 1992. </year> <note> Drafts exists from as early as 1985. </note>
Reference-contexts: notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) [26, 57, 58], then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations <ref> [40, 52, 50] </ref>), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> We first specify a non-deterministic stack. (Since this paper is limited to many sorted algebra, the handling of errors is weak; <ref> [40, 52] </ref> show how to do it better with order sorted algebra.) Example 18: Here the operation push nondeterministically puts a new natural number on top of a stack.
Reference: [53] <author> Joseph Goguen, Jose Meseguer, and David Plaisted. </author> <title> Programming with parameterized abstract objects in OBJ. </title> <editor> In Domenico Ferrari, Mario Bolognani, and Joseph Goguen, editors, </editor> <booktitle> Theory and Practice of Software Technology, </booktitle> <pages> pages 163-193. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [54] <author> Joseph Goguen, Akira Mori, Kai Lin, Girgore Ro~su, and Akiyoshi Sato. </author> <title> Web-based Formal Methods Tools. </title> <note> Submitted for publication, </note> <year> 1997. </year>
Reference-contexts: Of course, much work remains to meet the challenge set by the applications and mechanical support of the more established approaches. We are experimenting with ways to organize hidden proofs as active websites, using html, Java, JavaScript, etc., and a website editor called Kumo <ref> [55, 54] </ref>, which provides direct support for hidden coinduction and automatically generates an entire website for a proof, including executable OBJ3 proof scores, links to background material, and to explanation pages.
Reference: [55] <author> Joseph Goguen and Akira Mori. </author> <title> Semiotics, ProofWebs, and Distributed Cooperative Proving. To appear in Proceedings, User Interfaces for Theorem Provers, </title> <address> Sophie-Antipolis, France, </address> <year> 1997. </year>
Reference-contexts: Of course, much work remains to meet the challenge set by the applications and mechanical support of the more established approaches. We are experimenting with ways to organize hidden proofs as active websites, using html, Java, JavaScript, etc., and a website editor called Kumo <ref> [55, 54] </ref>, which provides direct support for hidden coinduction and automatically generates an entire website for a proof, including executable OBJ3 proof scores, links to background material, and to explanation pages.
Reference: [56] <author> Joseph Goguen and Adolfo Socorro. </author> <title> Module composition and system design for the object paradigm. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 7(9) </volume> <pages> 47-55, </pages> <month> February </month> <year> 1995. </year>
Reference: [57] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, IV, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice Hall, </publisher> <year> 1978. </year>
Reference-contexts: Of course, much of the `interesting' work could also be automated, including the examples in this paper, but this is certainly impossible in general. We assume some familiarity with basic many sorted algebra and with OBJ. The relevant background (and much more!) can be found in <ref> [45, 37, 57, 60] </ref> and [78], among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. <p> We begin before the beginning, with algebra. Although algebra has its roots in mathematics, computing science has made several contributions, starting with a simplification of notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) <ref> [26, 57, 58] </ref>, then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> The founding paper in hidden algebra is [33], which builds on earlier algebraic work on abstract data types <ref> [26, 57, 58] </ref>, and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines [48, 78]. <p> an initial (; E)-algebra G behaviorally satisfies a -query q iff every (; E)-algebra behaviorally satisfies q. 2 15 However, real software development processes involve much more, including constantly evolving requirements and the resulting need to constantly evolve the software [35]. 18 We can always choose a canonical term algebra <ref> [57] </ref> for G, and thus use narrowing to solve queries, as illustrated in [47]; of course, more efficient methods can be used in special cases. Applications of this paradigm [44] may involve queries to an object oriented database where the resulting object is not just retrieved, but actually created.
Reference: [58] <author> Joseph Goguen, James Thatcher, Eric Wagner, and Jesse Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: We begin before the beginning, with algebra. Although algebra has its roots in mathematics, computing science has made several contributions, starting with a simplification of notation for many sorted algebra [26], and continuing with initial algebra semantics (for abstract syntax and abstract data types) <ref> [26, 57, 58] </ref>, then order sorted algebra (giving a systematic approach to subtypes that also allows specifying partial recursive functions, partially defined functions, error definition and recovery, coercions and multiple representations [40, 52, 50]), and most recently in this tradition, hidden sorted algebra [33, 41, 43], or hidden algebra for short. <p> The founding paper in hidden algebra is [33], which builds on earlier algebraic work on abstract data types <ref> [26, 57, 58] </ref>, and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines [48, 78].
Reference: [59] <author> Joseph Goguen and Will Tracz. </author> <title> An implementation-oriented semantics for module composition, </title> <note> 1997. Submitted for publication. </note>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey [81]. In order to get the powerful module and type system of parameterized programming <ref> [53, 27, 29, 28, 31, 59] </ref>, it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. What we call `half institutions' are used in [22], which claims that one cannot get a full institution for the object paradigm with behavioral satisfaction.
Reference: [60] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouannaud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Algebraic Specification with OBJ: An Introduction with Case Studies. </title> <note> To appear. Also Technical Report, SRI International. </note>
Reference-contexts: Of course, much of the `interesting' work could also be automated, including the examples in this paper, but this is certainly impossible in general. We assume some familiarity with basic many sorted algebra and with OBJ. The relevant background (and much more!) can be found in <ref> [45, 37, 57, 60] </ref> and [78], among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. <p> The hidden approach seems the first to address both concurrency and effective proof techniques for systems of objects within the algebraic tradition, although we should certainly mention rewriting logic [77], which also works in the algebraic specification tradition, and indeed, also builds on OBJ <ref> [60] </ref>. This elegant approach views actions as inference steps in a `rewriting logic,' which is essentially equational logic without the law of symmetry. A strong point of this approach is its ability to model many different approaches to concurrency in natural and simple ways. <p> The underbar characters indicate where an argument goes, so that the successor operator s_ has prefix syntax, and the inequality operator _&lt;_ has infix syntax. The rest of the OBJ3 syntax used here should be fairly self-evident; for more on OBJ3, see <ref> [45, 60] </ref>. Our examples assume a fixed OBJ3 module DATA giving a signature and axioms for D (D need not be a term model for DATA, or even an initial model).
Reference: [61] <author> Andrew D. Gordon. </author> <title> Bisimilarity as a theory of functional programming. </title> <booktitle> Electronic Notes in Theoretical Computer Science, </booktitle> <volume> 1, </volume> <year> 1995. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming <ref> [64, 73, 61] </ref>, to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [62] <author> John Guttag. </author> <title> The Specification and Application to Programming of Abstract Data Types. </title> <type> PhD thesis, </type> <institution> University of Toronto, 1975. Computer Science Department, </institution> <note> Report CSRG-59. 40 </note>
Reference-contexts: Some sophisticated results on computability for initial and final algebras appear in [80]; both initiality and finality results compatible with the hidden paradigm were proved in [48]. This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag <ref> [62, 63] </ref>. The hidden approach seems the first to address both concurrency and effective proof techniques for systems of objects within the algebraic tradition, although we should certainly mention rewriting logic [77], which also works in the algebraic specification tradition, and indeed, also builds on OBJ [60].
Reference: [63] <author> John Guttag. </author> <title> Abstract data types and the development of data structures. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 20 </volume> <pages> 297-404, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: Some sophisticated results on computability for initial and final algebras appear in [80]; both initiality and finality results compatible with the hidden paradigm were proved in [48]. This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag <ref> [62, 63] </ref>. The hidden approach seems the first to address both concurrency and effective proof techniques for systems of objects within the algebraic tradition, although we should certainly mention rewriting logic [77], which also works in the algebraic specification tradition, and indeed, also builds on OBJ [60]. <p> Call a ground term invisible iff it is of hidden sort and has no contexts; then all invisible terms are defined. 4. P is lexic if it has no hidden (generalized) constants. 2 Having no undefined ground terms corresponds to Guttag's notion of sufficient completeness <ref> [63] </ref>. However, not only do we not require this condition, but we claim that undefined terms are very 14 useful in system development, and even at run time.
Reference: [64] <author> Tatsuya Hagino. </author> <title> A typed lambda calculus with categorical type constructors. </title> <editor> In D.H. Pitt, A. Poigne and D.E. Rydeheard, editors, </editor> <booktitle> Category Theory and Computer Science, </booktitle> <pages> pages 140-157. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 283. </volume> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming <ref> [64, 73, 61] </ref>, to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [65] <author> Lutz Hamel. </author> <title> Behavioural Verification and Implementation of an Optimizing Compiler for OBJ3. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Lab, </institution> <year> 1996. </year>
Reference-contexts: Hidden algebra and the proof techniques described in this paper can be useful in many areas of computing science; for example, they have been used to prove the correctness of a rather sophisticated optimizing compiler for OBJ <ref> [66, 65] </ref>. 6 Of course, any algebraic laws that have been shown to hold can be used, but because any such rule set must be incomplete, such an approach is necessarily limited. 7 This does not mean that traditional pre- and post-condition techniques cannot be used; in fact, our `executable' algebraic <p> Traceability is very important when constructing complex new proofs, and we intend to explore use of the toor hypermedia tool [83] for this purpose. We have already done one rather substantial hidden proof, namely the correctness of an optimizing compiler for OBJ3, based on an abstract term rewriting machine <ref> [66, 65] </ref>, and several smaller examples are on the web, including the stack example of Section 4. This paper has restricted attention to hidden many sorted algebra.
Reference: [66] <author> Lutz Hamel and Joseph Goguen. </author> <title> Towards a provably correct compiler for OBJ3. </title> <editor> In Manuel Hermenegildo and Jaan Penjam, editors, </editor> <booktitle> Proceedings, Conference on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 132-146. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 844. </volume>
Reference-contexts: Hidden algebra and the proof techniques described in this paper can be useful in many areas of computing science; for example, they have been used to prove the correctness of a rather sophisticated optimizing compiler for OBJ <ref> [66, 65] </ref>. 6 Of course, any algebraic laws that have been shown to hold can be used, but because any such rule set must be incomplete, such an approach is necessarily limited. 7 This does not mean that traditional pre- and post-condition techniques cannot be used; in fact, our `executable' algebraic <p> Traceability is very important when constructing complex new proofs, and we intend to explore use of the toor hypermedia tool [83] for this purpose. We have already done one rather substantial hidden proof, namely the correctness of an optimizing compiler for OBJ3, based on an abstract term rewriting machine <ref> [66, 65] </ref>, and several smaller examples are on the web, including the stack example of Section 4. This paper has restricted attention to hidden many sorted algebra.
Reference: [67] <author> Rolf Hennicker. </author> <title> Context induction: a proof principle for behavioural abstractions. </title> <editor> In A. Miola, editor, </editor> <booktitle> Proceedings, International Symposium on the Design and Implementation of Symbolic Computation Systems, volume 429 of Lecture Notes in Computer Science, </booktitle> <pages> pages 101-110. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: In [75], we suggest these two kinds of signature arrows are appropriate for different purposes, and show that the one that should form an institution (morphisms) in fact does so (see also Section 4). 5 The first effective algebraic proof technique for behavioral properties was context induction, introduced by Hennicker <ref> [67] </ref> and further developed with Bidoit (e.g, [7]). This research programme is similar to ours in many ways; their approach is more concerned with semantics than with proofs, and their context induction can be very awkward to apply in practice (see [24] for a discussion of some of the difficulties). <p> Exercise 51: Specify sets and lists and, by verifying an appropriate refinement, show that sets can be implemented with lists. 2 A more sophisticated view of refinement <ref> [48, 89, 67, 81] </ref> allows the concrete implementation to rename or even identify some of the abstract sorts and operations, thus giving rise to a hidden signature map from the abstract to the concrete signature: Definition 52: A hidden signature map ' : (H; ) ! (H 0 ; 0 )
Reference: [68] <author> C.A.R. Hoare. </author> <title> Proof of correctness of data representation. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The proposition above says that a refinement can be proved correct using the concrete equations to verify both the congruence property of () and the satisfaction of the equations '(c [e]). 4.2 Model Based Refinement Early studies of refinement were model oriented <ref> [68] </ref>, considering refinement a relationship between two models, one `abstract' and the other `concrete.' Then it makes sense to map from concrete variables to the abstract objects they represent.
Reference: [69] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: So called `process algebras' (also called concurrency calculi), like CCS [79], ACP [5] and CSP <ref> [69] </ref>, are typically presented using systems of equations. Equations are used very differently in process algebra than in hidden algebra. In process algebra, variables range over processes and operators combine processes. <p> Abramsky [1] introduces interaction categories, a very elegant categorical approach to processes, having some similarities to our approach to concurrency that deserve further exploration. Approaches based on set theoretic semantic models, such as Z [91] and CSP <ref> [69] </ref>, can lead to very difficult proofs involving properties of sets and hence axioms for set theory 6 .
Reference: [70] <editor> Bart Jacobs. Mongruences and cofree coalgebras. In Maurice Nivat, editor, </editor> <booktitle> Algebraic Methodology and Software Technology (AMAST95), </booktitle> <pages> pages 245-260. </pages> <publisher> Springer, </publisher> <year> 1995. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 936. </volume>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm <ref> [86, 70, 71, 72, 14] </ref>. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [71] <author> Bart Jacobs. </author> <title> Objects and classes, </title> <editor> coalgebraically. In B. Freitag, Cliff Jones, C. Lengauer and H.-J. Schek, editors, </editor> <booktitle> Object-Orientation with Parallelism and Persistence, </booktitle> <pages> pages 83-103. </pages> <publisher> Kluwer, </publisher> <year> 1996. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm <ref> [86, 70, 71, 72, 14] </ref>. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [72] <author> Bart Jacobs. </author> <title> Invariants, bisimulations and the correctness of coalgebraic refinements. </title> <type> Technical Report CSI-R9704, </type> <institution> Computer Science Institute, University of Nijmegen, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm <ref> [86, 70, 71, 72, 14] </ref>. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [73] <author> Grant Malcolm. </author> <title> Data structures and program transformation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14, </volume> <year> 1990. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming <ref> [64, 73, 61] </ref>, to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [74] <author> Grant Malcolm. </author> <title> Behavioural equivalence, bisimilarity, and minimal realisation. </title> <editor> In Magne Haveraaen and Olaf Owe and Ole-Johan Dahl, editors, </editor> <title> Recent Trends in Data Type Specifications. </title> <publisher> Springer, </publisher> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 389. </volume>
Reference-contexts: Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand [95] also made an early contribution. Finality is also used for treating states in <ref> [84, 48, 78, 74] </ref>, among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86]. <p> An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. Reichel [86] was the first to apply coalgebra explicitly to the object paradigm, and his basic construction can be used to show that hidden algebra extends coalgebra with generalised constants <ref> [74, 15] </ref>. It is precisely this extension that allows the treatment of nondeterminism we advocate in this paper. <p> Theorem 27 is not hard to prove (a simple but very abstract proof is given in Section 3.2). The proof generalizes the well known construction of an abstract machine as a quotient of the term algebra by the behavioral equivalence relation (usually called the Nerode equivalence in that context) <ref> [78, 74] </ref>, and uses the existence of final algebras that is proved in Section 3.1. Theorem 27 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. <p> Proof: This follows straightforwardly from the definition of behavioral equivalence and the `magic formula' that defines F . 2 In other words, behavioral equivalence on an algebra is the kernel of the unique homomorphism to the final algebra <ref> [74] </ref>. The quotient under this equivalence gives an algebra which is used in [11] to define behavioral satisfaction.
Reference: [75] <author> Grant Malcolm and Joseph Goguen. </author> <title> Proving correctness of refinement and implementation. </title> <type> Technical Monograph PRG-114, </type> <institution> Programming Research Group, University of Oxford, </institution> <year> 1994. </year> <note> Submitted for publication. </note>
Reference-contexts: The first systematic exposition of hidden algebra is given in [41], with many new ideas, including our approach to concurrency. The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in [43] and <ref> [75] </ref>, and [40] shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with [43, 75], in the context of correctness proofs for refinement of objects and abstract machines. <p> The problem of combining hidden with ordered sorts was first solved in [11]. Order sorted hidden algebra is further developed in [43] and [75], and [40] shows how to handle overwriting of methods using a special kind of signature. The development of our coinduction method began with <ref> [43, 75] </ref>, in the context of correctness proofs for refinement of objects and abstract machines. The hidden approach uses behavioral satisfaction to get an algebraic treatment of state that abstracts away from implementation details. <p> However, this is because they fail to distinguish between fixed data values and hidden states, and between the use of hidden signature maps for vertical structure (refinements) and hidden signature morphisms for horizontal structure (module composition). In <ref> [75] </ref>, we suggest these two kinds of signature arrows are appropriate for different purposes, and show that the one that should form an institution (morphisms) in fact does so (see also Section 4). 5 The first effective algebraic proof technique for behavioral properties was context induction, introduced by Hennicker [67] and <p> Theorem 27 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. This justifies a variety of techniques for proving behavioral equivalence (see also <ref> [43, 75] </ref>). In this context, a relation may be called a candidate relation before it is proved to be a hidden congruence. <p> We now give some results to simplify hidden coinduction proofs. Suppose = [ ; the letters and are intended to suggest generators (also called constructors) and destructors (also called selectors), respectively 19 <ref> [75] </ref>. In Example 28, contains up? and contains all the other flag operations. Corollary 29: If = [ and if on -algebra A is preserved by , then = on A. More generally, if = [ and is preserved by , then = . <p> 0 j E for every ( 0 ; E 0 )-algebra A 0 . 2 33 (In the above, 'A 0 denotes 0 A viewed as a -algebra.) It can be shown that ' is a refinement if all visible consequences of the abstract specification hold in the concrete specification <ref> [75] </ref>: Proposition 53: A hidden signature map ' : (; E) ! ( 0 ; E 0 ) is a refinement if E 0 j= '(c [e]) for each e 2 E and each visible -context c, where if e is the equation (8X) t = t 0 , then c <p> -context c, where if e is the equation (8X) t = t 0 , then c [e] denotes the equation (8X) c [t] = c [t 0 ]. 2 The following consequence of Corollary 29 justifies the use of hidden coinduction for proving correctness of refinements; some examples appear in <ref> [75] </ref>. <p> The extension to hidden order sorted algebra is not really difficult, but it cannot be trivial, since it covers nonterminating systems, partial recursive functions, multiple inheritance, error definition and handling, coercion, overwriting, multiple representation, and more; many details appear in <ref> [75] </ref>, but there is still more work to be done. We also wish to further explore connections with other approaches, including coalgebra and concurrent logic programming; it would be interesting to find morphisms between the relevant institutions, generalizing the adjunctions of Winskel [96].
Reference: [76] <author> Grant Malcolm and James Worrell. </author> <title> Toposes of abstract machines with observational semantics. </title> <type> Draft, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1997. </year>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory <ref> [87, 88, 76] </ref>, and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. <p> This is another way of looking at coinduction: two states of a transition system are bisimilar iff those states are behaviorally equivalent in the transition system viewed as an algebra of a hidden signature (cf. Theorem 41). More details on transition systems and hidden algebras will appear elsewhere <ref> [76] </ref>. It is possible to relate hidden algebras and nondeterministic transition systems via an adjunction. This says that for every nondeterministic transistion system, there is a `best' hidden algebra with the given behaviour, and vice-versa.
Reference: [77] <author> Jose Meseguer. </author> <title> Conditional rewriting as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference-contexts: This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag [62, 63]. The hidden approach seems the first to address both concurrency and effective proof techniques for systems of objects within the algebraic tradition, although we should certainly mention rewriting logic <ref> [77] </ref>, which also works in the algebraic specification tradition, and indeed, also builds on OBJ [60]. This elegant approach views actions as inference steps in a `rewriting logic,' which is essentially equational logic without the law of symmetry.
Reference: [78] <author> Jose Meseguer and Joseph Goguen. Initiality, </author> <title> induction and computability. </title> <editor> In Maurice Nivat and John Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 459-541. </pages> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: We assume some familiarity with basic many sorted algebra and with OBJ. The relevant background (and much more!) can be found in [45, 37, 57, 60] and <ref> [78] </ref>, among many other places; Appendix Section A summarizes certain aspects of this work in a way that is particularly suited to proof orientation of this paper. <p> The founding paper in hidden algebra is [33], which builds on earlier algebraic work on abstract data types [26, 57, 58], and is a natural extension of prior work by Goguen and Meseguer on (what they then called) abstract machines <ref> [48, 78] </ref>. Hidden algebra also generalizes automaton theory, which again has a long tradition in computing science; we would particularly mention the pioneering work of Eilenberg and Wright [23], which took a categorical approach to `tree automata,' generalizing traditional state transition automata. <p> Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand [95] also made an early contribution. Finality is also used for treating states in <ref> [84, 48, 78, 74] </ref>, among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86]. <p> Principles of induction can be justified from the fact that an initial algebra has no proper subalgebras (e.g., <ref> [37, 78] </ref>). We will see that final (terminal) algebras play an analogous role in justifying reasoning about behavioral properties with hidden coinduction. <p> Theorem 27 is not hard to prove (a simple but very abstract proof is given in Section 3.2). The proof generalizes the well known construction of an abstract machine as a quotient of the term algebra by the behavioral equivalence relation (usually called the Nerode equivalence in that context) <ref> [78, 74] </ref>, and uses the existence of final algebras that is proved in Section 3.1. Theorem 27 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent.
Reference: [79] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, Parts I and II. </title> <institution> Technical Report ECS-LFCS-89-85 and -86, Computer Science Department, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: In [19], behavioral specification is applied to rewriting logic, through the sophisticated semantic definition of behavioral satisfaction between rewriting logic models and (conditional) rules that arises from the very general `institutional 4 ' approach to behavior developed in [11]. So called `process algebras' (also called concurrency calculi), like CCS <ref> [79] </ref>, ACP [5] and CSP [69], are typically presented using systems of equations. Equations are used very differently in process algebra than in hidden algebra. In process algebra, variables range over processes and operators combine processes.
Reference: [80] <author> Lawrence Moss, Jose Meseguer, and Joseph Goguen. </author> <title> Final algebras, cosemicomputable algebras, and degrees of unsolvability. </title> <journal> Theoretical Computer Science, </journal> <volume> 100 </volume> <pages> 267-302, </pages> <year> 1992. </year> <note> Original version from March 1987. </note>
Reference-contexts: Some sophisticated results on computability for initial and final algebras appear in <ref> [80] </ref>; both initiality and finality results compatible with the hidden paradigm were proved in [48]. This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag [62, 63].
Reference: [81] <author> Fernando Orejas, Marisa Navarro, and Ana Sanchez. </author> <title> Algebraic implementation of abstract data types: a survey of concepts and new compositionality results. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 6(1), </volume> <year> 1996. </year>
Reference-contexts: Reichel's notion of behavioral theory has been developed further in several different directions within the algebraic specification community, mainly using partial algebras, e.g., see [7, 21, 22] and the survey <ref> [81] </ref>. In order to get the powerful module and type system of parameterized programming [53, 27, 29, 28, 31, 59], it is necessary that the signatures (with their morphisms), models and axioms form what is called an `institution' [39]. <p> Hidden algebra uses a loose behavioral semantics over a fixed data algebra. Contrary to <ref> [81] </ref>, there is no competition between this and initial algebra semantics, because they are used for different purposes. <p> Exercise 51: Specify sets and lists and, by verifying an appropriate refinement, show that sets can be implemented with lists. 2 A more sophisticated view of refinement <ref> [48, 89, 67, 81] </ref> allows the concrete implementation to rename or even identify some of the abstract sorts and operations, thus giving rise to a hidden signature map from the abstract to the concrete signature: Definition 52: A hidden signature map ' : (H; ) ! (H 0 ; 0 )
Reference: [82] <author> David Parnas. </author> <title> Information distribution aspects of design methodology. </title> <booktitle> Information Processing '72 , 71 </booktitle> <pages> 339-344, </pages> <year> 1972. </year> <booktitle> Proceedings of 1972 IFIP Congress. </booktitle>
Reference-contexts: The crucial advance was to recognize that operations should be associated with data representations; 3 this is exactly the same insight that advanced algebra from mere sets to algebras, which are sets with their associated operations. In software engineering this insight seems to have been due to David Parnas <ref> [82] </ref>, and in algebra to Emmy Noether.
Reference: [83] <author> Francisco Pinheiro and Joseph Goguen. </author> <title> An object-oriented tool for tracing requirements. </title> <journal> IEEE Software, </journal> <pages> pages 52-64, </pages> <month> March </month> <year> 1996. </year> <note> Special issue of papers from ICRE '96. </note>
Reference-contexts: We intend to link this tool to decision methods for special domains beyond canonical term rewriting theories, such as Presburger arithmetic. Traceability is very important when constructing complex new proofs, and we intend to explore use of the toor hypermedia tool <ref> [83] </ref> for this purpose. We have already done one rather substantial hidden proof, namely the correctness of an optimizing compiler for OBJ3, based on an abstract term rewriting machine [66, 65], and several smaller examples are on the web, including the stack example of Section 4.
Reference: [84] <author> Horst Reichel. </author> <title> Behavioural equivalence a unifying concept for initial and final specifications. </title> <booktitle> In Proceedings, Third Hungarian Computer Science Conference. Akademiai Kiado, 1981. </booktitle> <address> Budapest. </address>
Reference-contexts: The hidden approach uses behavioral satisfaction to get an algebraic treatment of state that abstracts away from implementation details. The elegant idea of behavioral satisfaction was introduced by Reichel <ref> [84] </ref> in the context of partial algebras; see also [85]. Behavioral equivalence of states, a generalization of bisimulation, appeared in [48], which also first recognized the connection between tree automata and software engineering. <p> We propose hidden coinduction as a way to eliminate the awkwardness of context induction. Reichel's seminal work on behavioral satisfaction was in part motivated by an insight on how to unify initial and final semantics <ref> [84] </ref>. Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand [95] also made an early contribution. <p> Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand [95] also made an early contribution. Finality is also used for treating states in <ref> [84, 48, 78, 74] </ref>, among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86].
Reference: [85] <author> Horst Reichel. </author> <title> Behavioural validity of conditional equations in abstract data types. In Contributions to General Algebra 3. </title> <booktitle> Teubner, 1985. Proceedings of the Vienna Conference, </booktitle> <month> June 21-24, </month> <year> 1984. </year>
Reference-contexts: The hidden approach uses behavioral satisfaction to get an algebraic treatment of state that abstracts away from implementation details. The elegant idea of behavioral satisfaction was introduced by Reichel [84] in the context of partial algebras; see also <ref> [85] </ref>. Behavioral equivalence of states, a generalization of bisimulation, appeared in [48], which also first recognized the connection between tree automata and software engineering.
Reference: [86] <author> Horst Reichel. </author> <title> An approach to object semantics based on terminal co-algebras. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5 </volume> <pages> 129-152, </pages> <year> 1995. </year>
Reference-contexts: Finality is also used for treating states in [84, 48, 78, 74], among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm <ref> [86] </ref>. Some sophisticated results on computability for initial and final algebras appear in [80]; both initiality and finality results compatible with the hidden paradigm were proved in [48]. This flood of work on finality and behavioral abstraction validates some intuitions expressed long ago by Guttag [62, 63]. <p> Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm <ref> [86, 70, 71, 72, 14] </ref>. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. <p> An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. Reichel <ref> [86] </ref> was the first to apply coalgebra explicitly to the object paradigm, and his basic construction can be used to show that hidden algebra extends coalgebra with generalised constants [74, 15]. It is precisely this extension that allows the treatment of nondeterminism we advocate in this paper.
Reference: [87] <author> Jan Rutten and Daniele Turi. </author> <title> Initial algebra and final coalgebra semantics for concurrency. </title> <editor> In Jaco de Bakker, Jan Willem de Roever, and Gregorz Rozenberg, editors, </editor> <booktitle> Proc. REX Symposium `A Decade of Concurrency', </booktitle> <pages> pages 530-582. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 803. </volume>
Reference-contexts: Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory <ref> [87, 88, 76] </ref>, and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [88] <author> Jan J.M.J. Rutten. </author> <title> Universal coalgebra: a theory of systems. </title> <type> Technical Report CS-R9652, </type> <institution> CWI, </institution> <year> 1996. </year>
Reference-contexts: One thread in this tradition seeks to show existence of final transition systems, which give rise to an abstract notion of bisimulation and can be used to give a semantics for process algebras [2, 6]. Another thread views coalgebra as a variation on universal algebra <ref> [88] </ref>, and applies it to functional programming [64, 73, 61], to automata theory [87, 88, 76], and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93]. <p> Another thread views coalgebra as a variation on universal algebra [88], and applies it to functional programming [64, 73, 61], to automata theory <ref> [87, 88, 76] </ref>, and to the object paradigm [86, 70, 71, 72, 14]. An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics [93].
Reference: [89] <author> Donald Sannella and Andrzej Tarlecki. </author> <title> Toward formal development of programs from algebraic specifications. </title> <journal> Acta Informatica, </journal> <volume> 25 </volume> <pages> 233-281, </pages> <year> 1988. </year>
Reference-contexts: Exercise 51: Specify sets and lists and, by verifying an appropriate refinement, show that sets can be implemented with lists. 2 A more sophisticated view of refinement <ref> [48, 89, 67, 81] </ref> allows the concrete implementation to rename or even identify some of the abstract sorts and operations, thus giving rise to a hidden signature map from the abstract to the concrete signature: Definition 52: A hidden signature map ' : (H; ) ! (H 0 ; 0 )
Reference: [90] <author> Adolfo Socorro. </author> <title> Design, Implementation, and Evaluation of a Declarative Object Oriented Language. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1994. </year>
Reference: [91] <author> J. Michael Spivey. </author> <title> Understanding Z. </title> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: Abramsky [1] introduces interaction categories, a very elegant categorical approach to processes, having some similarities to our approach to concurrency that deserve further exploration. Approaches based on set theoretic semantic models, such as Z <ref> [91] </ref> and CSP [69], can lead to very difficult proofs involving properties of sets and hence axioms for set theory 6 .
Reference: [92] <author> Will Tracz. </author> <title> Parameterized programming in lileanna. </title> <booktitle> In Proceedings, Second International Workshop on Software Reuse, </booktitle> <month> March </month> <year> 1993. </year> <pages> Lucca, </pages> <address> Italy. </address>
Reference: [93] <author> Daniele Turi and Gordon Plotkin. </author> <title> Towards a mathematical operational semantics. </title> <booktitle> In Proceedings, Logic in Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: An interesting recent development combines algebra and coalgebra to describe denotational and operational semantics <ref> [93] </ref>. Reichel [86] was the first to apply coalgebra explicitly to the object paradigm, and his basic construction can be used to show that hidden algebra extends coalgebra with generalised constants [74, 15]. It is precisely this extension that allows the treatment of nondeterminism we advocate in this paper.
Reference: [94] <author> Simone Veglioni. </author> <title> Integrating Static and Dynamic Aspects in the Specification of Open, Object-based and Distributed Systems. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, </institution> <month> submitted November </month> <year> 1997. </year>
Reference-contexts: Some examples of hidden correctness proofs for asynchronous communication protocols are given in <ref> [94] </ref>. The concurrent connection of two objects without synchronization is their coproduct in the category having appropriate specifications as objects and certain refinements as morphisms; more generally, Corina C^rstea has shown that concurrent connection with synchronization is colimit in this category [14].
Reference: [95] <author> Mitchell Wand. </author> <title> Final algebra semantics and data type extension. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 19 </volume> <pages> 27-44, </pages> <year> 1979. </year>
Reference-contexts: Reichel's seminal work on behavioral satisfaction was in part motivated by an insight on how to unify initial and final semantics [84]. Behavioral and final semantics were perhaps first advocated by Montanari et al. [25], though Wand <ref> [95] </ref> also made an early contribution. Finality is also used for treating states in [84, 48, 78, 74], among many other places, including the present paper; there is some elegant more recent by work by Reichel on co-algebraic semantics for the object paradigm [86].
Reference: [96] <author> Glynn Winskel. </author> <title> Categories of models for concurrency. </title> <editor> In Steven Brooks, A. William Roscoe, and Glynn Winskel, editors, </editor> <booktitle> Proceedings, Workshop on the Semantics of Concurrency, </booktitle> <pages> pages 246-267. </pages> <publisher> Springer, </publisher> <year> 1984. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 197. </volume>
Reference-contexts: We also wish to further explore connections with other approaches, including coalgebra and concurrent logic programming; it would be interesting to find morphisms between the relevant institutions, generalizing the adjunctions of Winskel <ref> [96] </ref>. We feel that hidden algebra is a natural next step in the evolution of algebraic specification, carrying forward the intentions of its founders in a simple and elegant way to the realities of modern software.
References-found: 96

