URL: ftp://ftp.csd.uu.se/pub/papers/reports/0111.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Title: A tool for developing Prolog dataflow analyzers  
Author: Magnus Nordin Thomas Lindgren H-akan Millroth 
Keyword: automatic generation, abstract domains, program analysis, logic programming  
Address: Box 311, S-751 05 Uppsala, Sweden  Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department, Uppsala University  
Note: Igor:  
Email: e-mail: fmgn,thomasl,hakanmg@csd.uu.se  
Phone: Phone: +46 18 182500 Fax: +46 18 511925  Phone: +481818 25 00 Fax: +461851 19 25  
Abstract: UPMAIL Technical Report No. 111 July 15, 1995 ISSN 1100-0686 Abstract We describe a tool, Igor, for implementing, testing, modifying, and evaluating abstract domains for analysis of Prolog programs. A high-level specification language is used for specifying abstract domains that are compiled into Prolog and interfaced with an fixpoint engine to make up a complete analyzer. The compiler automatically generates code for basic domain operations from special domain type definitions. These definition are also used to combine and reduce domains. The special purpose language provides primitives, such as set and lattice operations, and a concise method for specifying abstract interpretation of built-in predicates. We evaluate the tool and show that the high-level specifications are close to an order of magnitude less voluminous than the corresponding Prolog code and that the execution speed of the generated code is close to that of hand-written analyzers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Armstrong, K. Marriott, P. Schacte & H. Sondergaard, </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation, Static Analysis Symp. 94, </title> <publisher> Springer LNCS, </publisher> <year> 1994. </year>
Reference-contexts: The language does not provide support for type graphs [11] or definite boolean functions <ref> [1] </ref>.
Reference: [2] <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Exploiting recursion parallelism in Prolog, </title> <booktitle> Intl. Conf. </booktitle> <editor> PARLE-93 (eds. A. Bode, M. Reeve & G. Wolf), </editor> <publisher> Springer LNCS 694, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog [12] was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog <ref> [2, 14] </ref> was compared with Dep. The compared domains are not identical but similar enough to serve for our approximate comparisons. Only the execution time for analysis is included in the measurments. Program loading, code preparation, presentation of the results and similar phases are left out.
Reference: [3] <author> M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nilsson, T. Sjoland, </author> <title> SICStus Prolog User's Manual, </title> <institution> Swedish Institute of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: All measurements were made on a Sun 630 MP with a 55 Mhz processor and 128 Mb of memory. The time unit is seconds. The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog <ref> [3] </ref> version 2.1.9, with the fastcode option on, was used.
Reference: [4] <author> M. Codish, A. Mulkers, M. Bruynooghe, M. Garca de la Banda & M. Hermenegildo, </author> <title> Improving abstract interpretations by combining do 13 mains, </title> <booktitle> Proc. Symp. Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <institution> PEPM'91, Yale University, </institution> <address> Connecticut, </address> <year> 1991. </year>
Reference: [5] <author> A. Cortesi, B. Le Charlier & P. van Hentenryck, </author> <title> Conceptual and soft ware support for abstract domain design: Generic structural domain and open product, </title> <booktitle> Proc. Symp. Principles of Programming Languages, </booktitle> <address> POPL'94, </address> <year> 1994. </year>
Reference-contexts: The specifications are interpreted rather than compiled. Tjiang [18] describes a tool that greatly simplifies the implementation of optimizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs and is aimed at imperative rather than declarative languages. Cortesi et al <ref> [5] </ref> propose two kinds of support for domain construction. Generic pattern domains is software support for upgrading simpler domains to include structural information. This upgrade results in more accurate domains. Open products is a method for combining domains to obtain a more sophisticated domain.
Reference: [6] <author> P. Cousot & R. Cousot, </author> <title> Systematic design of program analysis frame works, </title> <booktitle> Proc. 6th Conf. Principles of Programming Languages, </booktitle> <pages> pp. 269-282, </pages> <year> 1979. </year>
Reference-contexts: Generic pattern domains is software support for upgrading simpler domains to include structural information. This upgrade results in more accurate domains. Open products is a method for combining domains to obtain a more sophisticated domain. This method is succesfully used in Igor-specifications. Cousot and Cousot <ref> [6] </ref> proposed methods for systematic design of new abstract domains out of old ones, by combinations of domains and application of various transformations on domains. Van Roy [16] notes that the use of analysis results is less well-researched, as compared to generic analysis frameworks or abstract domains.
Reference: [7] <author> S.K. Debray, </author> <title> Static inference of modes and data dependencies in logic programs, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> Vol. 11, No. 3, </volume> <pages> pp. 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [17]; J&L, Jacobs's and Langen's sharing domain [13]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain <ref> [7] </ref>. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [16]. 5.1 Domain and compilation statistics The size of the specifications of domains we have implemented range between 1 to 3 pages of non-commented code.
Reference: [8] <author> S.K. Debray, </author> <title> Efficient dataflow analysis of logic programs, </title> <journal> J. ACM , Vol. </journal> <volume> 39, No. 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: The user can override these operations with his own if needed. The mode domain above must be combined with a domain for variable aliasing (since it is not substitution-closed <ref> [8] </ref>). We can specify an aliasing domain that is a set of sets of variables in a clause C as follows. type aliasing (C) =&gt; set (set (variables (C))). <p> SICStus Prolog [3] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [17]; J&L, Jacobs's and Langen's sharing domain [13]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains <ref> [8] </ref>; Dep, Debray's mode and dependency domain [7]. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [16]. 5.1 Domain and compilation statistics The size of the specifications of domains we have implemented range between 1 to 3 pages of non-commented code.
Reference: [9] <author> S.K. Debray, QD-Janus: </author> <title> a sequential implementation of Janus in Pro log, </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. 23(12), </volume> <month> December </month> <year> 1993. </year>
Reference: [10] <author> T.W. Getzinger, </author> <title> Abstract interpretation for the compile-time optimiza tion of logic programs, </title> <type> Ph.D. Thesis, </type> <institution> University of South California, </institution> <type> Report 93/09, </type> <year> 1993. </year>
Reference-contexts: Domain specifications are written in a first-order, statically typed strict functional language. This language has operations for manipulating sets and lattices, for projecting domains, and for combining domains. Specifications are compiled to Prolog code and optionally linked with an analysis framework based on Getzinger's algorithm <ref> [10] </ref>. There is a completely customizable interface to the automatically-generated domain code for users that want to provide their own fixpoint engines. The system provides support for concise specification of builtin operations and for communicating analysis results to the subsequent phases of the compiler. <p> - 4.12 4.31 3.08 2.58 5.71 6.41 serialise 0.63 0.81 2.48 31.19 1.09 1.07 0.45 0.37 0.79 0.83 analyzer - 8.27 8.17 4.83 3.90 14.32 12.37 tak 0.06 0.08 0.02 0.04 0.31 0.33 0.08 0.10 0.18 0.19 zebra - 2.75 5.24 1.62 2.53 8.21 7.53 Table 3: Analysis execution times. <ref> [10] </ref> performs an evaluation of the advantages gained from of a large number of domains, when used to compile logic programs.
Reference: [11] <author> P. van Hentenryck, A. Cortesi & B. Le Charlier, </author> <title> Type analysis of prolog using type graphs, </title> <journal> J. Logic Programming, </journal> <year> 1995. </year>
Reference-contexts: The tool should be instrumental in helping to change the task of implementing static analysis domains from being a black art into routine tasks on the same level as using lex or yacc for lexical analysis and parsing. The language does not provide support for type graphs <ref> [11] </ref> or definite boolean functions [1].
Reference: [12] <author> M. Hermenegildo & K. Greene, </author> <title> The &-Prolog system: Exploiting inde pendent and-parallelism, </title> <journal> New Generation Computing, </journal> <volume> Vol. 9(3,4), </volume> <pages> pp. 233-257, </pages> <year> 1991. </year>
Reference-contexts: The majority of this time is spent in the type-checker. The details of these domain and compilation statistics are given in Table 1. 5.2 Efficiency of generated code Comparisons of hand-coded with auto-generated domains were performed as follows. The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog <ref> [12] </ref> was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog [2, 14] was compared with Dep. The compared domains are not identical but similar enough to serve for our approximate comparisons. Only the execution time for analysis is included in the measurments.
Reference: [13] <author> D. Jacobs & A. Langen, </author> <title> Accurate and efficient approximation of vari able aliasing in logic programs, </title> <booktitle> Proc. North American Conf. Logic Programming 1989, </booktitle> <pages> pp. 154-165, </pages> <year> 1989. </year>
Reference-contexts: The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog [3] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [17]; J&L, Jacobs's and Langen's sharing domain <ref> [13] </ref>; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain [7].
Reference: [14] <author> T. Lindgren, </author> <title> The compilation and execution of recursion-parallel Prolog on shared-memory multiprocessors, </title> <booktitle> Licentiate of Philosophy Thesis, Uppsala Theses in Computer Science 18/93, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog [12] was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog <ref> [2, 14] </ref> was compared with Dep. The compared domains are not identical but similar enough to serve for our approximate comparisons. Only the execution time for analysis is included in the measurments. Program loading, code preparation, presentation of the results and similar phases are left out.
Reference: [15] <author> M. Nordin, Igor: </author> <title> A tool for developing abstract domains for Prolog, </title> <booktitle> Licentiate of Philosophy Thesis, </booktitle> <publisher> forthcoming, </publisher> <year> 1995. </year>
Reference-contexts: The system provides support for concise specification of builtin operations and for communicating analysis results to the subsequent phases of the compiler. A full description of the Igor tool is available elsewhere <ref> [15] </ref>. 2 A simple example The user specifies domain types. Several kinds of domain types are supported: sets ordered by inclusion, product domains, atomic function domains, finite lattices, recursive domains, and disjunctive domains.
Reference: [16] <author> P.L. van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming?, </title> <type> Ph.D. Thesis, </type> <institution> UCB/CSD 90/600, Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1990. </year> <month> 14 </month>
Reference-contexts: The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks <ref> [16] </ref>. 5.1 Domain and compilation statistics The size of the specifications of domains we have implemented range between 1 to 3 pages of non-commented code. <p> This method is succesfully used in Igor-specifications. Cousot and Cousot [6] proposed methods for systematic design of new abstract domains out of old ones, by combinations of domains and application of various transformations on domains. Van Roy <ref> [16] </ref> notes that the use of analysis results is less well-researched, as compared to generic analysis frameworks or abstract domains.
Reference: [17] <author> R. Sundararajan, </author> <title> An abstract interpretation scheme for groundness, freeness, and sharing analysis of logic programs, </title> <type> Technical Report CIS-TR-91-06, </type> <institution> Dept. of Computer and Information Science, University of Oregon, </institution> <year> 1991 </year>
Reference-contexts: The time unit is seconds. The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog [3] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity <ref> [17] </ref>; J&L, Jacobs's and Langen's sharing domain [13]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain [7].
Reference: [18] <author> S.W-K. Tjiang, </author> <title> Automatic Generation of Data-Flow Analyzers: A Tool for Building Optimzers, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Venkatesh [19] designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The specifications are interpreted rather than compiled. Tjiang <ref> [18] </ref> describes a tool that greatly simplifies the implementation of optimizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs and is aimed at imperative rather than declarative languages. Cortesi et al [5] propose two kinds of support for domain construction.
Reference: [19] <author> G.A. Venkatesh, </author> <title> A framework for construction and evaluation of high level specifications for program analysis techniques, </title> <booktitle> SIGPLAN Conf. Programming Language Design and Implementation, PLDI'89, </booktitle> <pages> pp. 1-12, </pages> <year> 1989. </year>
Reference-contexts: Venkatesh <ref> [19] </ref> designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The specifications are interpreted rather than compiled. Tjiang [18] describes a tool that greatly simplifies the implementation of optimizers by using high-level specifications to combine several simpler optimization specifications.
Reference: [20] <author> K. Yi & W.L. Harrison III, </author> <title> Automatic generation and management of interprocedural program analyses, </title> <booktitle> The 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: As can be seen in Tables 3-4, significant gains can be achieved by using the bit vector representation when the domains rely heavily on union, intersection, and member operations performed on very large sets (Sund and J&L). 6 Related work The Z1 system <ref> [20] </ref> allows the programmer to specify an analyzer and an abstract domain which is compiled into executable code. Our system extends the capabilities of Z1 with disjunctive and structure-based domains and more flexible projection operations. Igor is furthermore substantially faster.
References-found: 20

