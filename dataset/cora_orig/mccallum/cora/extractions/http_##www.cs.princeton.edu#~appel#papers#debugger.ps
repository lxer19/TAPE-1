URL: http://www.cs.princeton.edu/~appel/papers/debugger.ps
Refering-URL: http://www.cs.princeton.edu/~appel/papers/
Root-URL: http://www.cs.princeton.edu
Email: email: apt@cs.pdx.edu  email: appel@cs.princeton.edu  
Title: A Debugger for Standard ML  
Author: ANDREW TOLMACH ANDREW W. APPEL 
Address: P.O. Box 751, Portland, OR, USA 97207-0751  35 Olden Street, Princeton, NJ USA 08544-2087  
Affiliation: Dept. of Computer Science, Portland State University  Dept. of Computer Science, Princeton University,  
Date: 1 (1): 1-000, January 1993  
Note: J. Functional Programming  c 1993 Cambridge University Press 1  
Abstract: We have built a portable, instrumentation-based, replay debugger for the Standard ML of New Jersey compiler. Traditional "source-level" debuggers for compiled languages actually operate at machine level, which makes them complex, difficult to port, and intolerant of compiler optimization. For secure languages like ML, however, debugging support can be provided without reference to the underlying machine, by adding instrumentation to program source code before compilation. Because instrumented code is (almost) ordinary source, it can be processed by the ordinary compiler. Our debugger is thus independent from the underlying hardware and runtime system, and from the optimization strategies used by the compiler. The debugger also provides reverse execution, both as a user feature and an internal mechanism. Reverse execution is implemented using a checkpoint and replay system; checkpoints are represented primarily by first-class continuations.
Abstract-found: 1
Intro-found: 1
Reference: <author> Agrawal, H., DeMillo, R. A., and Spafford, E. H. </author> <year> (1991). </year> <title> An execution-backtracking approach to debugging. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 21-26. </pages>
Reference-contexts: These include visualization (Teitelbaum and Reps, 1981); "flow-back analysis," the automated display of the assignments that have led a variable to have a particular value (Balzer, 1969; Choi et al., 1991); and dynamic program slicing <ref> (Agrawal et al., 1991) </ref>. We could build similar tools on top of our time-travel primitives. 9.3 Checkpointing One important source of simplicity in the debugger is the use of callcc to capture most of the program's state at a checkpoint.
Reference: <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <year> (1986). </year> <title> Compilers: Principles, Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: Iterating this process produces the event record of the caller's caller, and so forth. The caller and binding fields are similar to the control (or dynamic) and access (or static) links, respectively, used to link activation records in languages with nested procedures, such as Pascal <ref> (Aho et al., 1986, Chapter 7) </ref>. A Pascal compiler typically generates code to maintain static links and relies on the hardware stack to maintain dynamic links; SML/NJ generates code to maintain similar information in the form of closure and continuation pointers.
Reference: <author> Appel, A. W. </author> <year> (1987). </year> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279. </pages>
Reference-contexts: Of course, there are allocation and garbage collection costs associated with using a heap representation, although these costs might not be higher than those of stack management <ref> (Appel, 1987) </ref>. 3.2 Problems with Machine-Based Debugging The number and complexity of SML/NJ's optimizations and the nature of its run-time system make the prospect of writing a conventional machine-based debugger quite daunting.
Reference: <author> Appel, A. W. </author> <year> (1989a). </year> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(2) </volume> <pages> 153-162. </pages>
Reference-contexts: runtime values themselves do not carry precise type tags? To solve this problem, the debugger relies on the fact that the dynamic type of a value doesn't change when it is passed to a function; i.e., the dynamic type of the formal parameter must match that of the actual argument <ref> (Appel, 1989a) </ref>. To find the actual argument's type, the debugger looks up the call chain to find the event where the function was called and consults the corresponding code site.
Reference: <author> Appel, A. W. </author> <year> (1989b). </year> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software|Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183. </pages>
Reference-contexts: These optimizations cannot be disabled; they are intrinsic to SML/NJ's compilation approach. The SML/NJ system also contains a runtime component, implemented in C, that provides access to operating-system facilities, including I/O and signals, and a garbage collector for the heap. SML/NJ uses a two-generation copying collector <ref> (Appel, 1989b) </ref>; frequent minor collections scavenge the younger generation, and occasional major collections scavenge the entire heap. The heap is very heavily used, because SML/NJ has no runtime stack of activation records.
Reference: <author> Appel, A. W. </author> <year> (1992). </year> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press. </publisher>
Reference-contexts: All function operands must be atomic, i.e., they must already have been explicitly evaluated and bound to a variable. Also, functions never return; they terminate by calling a continuation function representing "the rest of the program." Most of SML/NJ's optimizing is done on the CPS representation <ref> (Appel, 1992) </ref>. CPS optimizations include in-line expansion, -reduction and splitting, flattening of tuple arguments and uncurrying, and code hoisting. After optimization, the CPS is further rewritten to convert references to free variables into explicit code to create and access heap-allocated closure records.
Reference: <author> Appel, A. W. and MacQueen, D. B. </author> <year> (1991). </year> <title> Standard ML of New Jersey. </title> <editor> In Wirsing, M., editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> New York. </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> Archer, Jr., J. E., Conway, R., and Schneider, F. B. </author> <year> (1984). </year> <title> User recovery and reversal in interactive systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 1-19. </pages>
Reference: <author> Balzer, R. M. </author> <year> (1969). </year> <title> EXDAMS-EXtendable Debugging and Monitoring System. </title> <booktitle> In Proceedings AFIPS 1969 Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 567-580, </pages> <address> Montvale, NJ. </address> <publisher> AFIPS Press. </publisher>
Reference: <author> Beander, B. </author> <year> (1983). </year> <title> VAX DEBUG: An interactive, symbolic, multilingual debugger. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High Level Debugging, </booktitle> <pages> pages 173-179. </pages> <note> Published as SIGPLAN Notices, 18(8), </note> <month> Aug. </month> <year> 1983. </year>
References-found: 10

