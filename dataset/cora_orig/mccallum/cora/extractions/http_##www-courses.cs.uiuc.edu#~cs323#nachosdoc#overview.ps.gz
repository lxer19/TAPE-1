URL: http://www-courses.cs.uiuc.edu/~cs323/nachosdoc/overview.ps.gz
Refering-URL: http://www-courses.cs.uiuc.edu/~cs323/
Root-URL: http://www.cs.uiuc.edu
Title: The Nachos Instructional Operating System  
Author: Wayne A. Christopher, Steven J. Procter, and Thomas E. Anderson 
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division University of California  
Abstract: In teaching operating systems at an undergraduate level, it is very important to provide a project that is realistic enough to show how real operating systems work, yet simple enough that the students can understand and modify it in significant ways. A number of these instructional systems have been created over the last two decades, but recent changes in hardware and software design, along with the increasing power of available computational resources, have changed the basis for many of the tradeoffs made by these systems. We have implemented an instructional operating system, called Nachos, and designed a series of assignments to go with it. Our system includes CPU and device simulators, and runs as a regular UNIX process. Nachos illustrates and takes advantage of modern OS technology, such as threads and remote procedure calls, recent hardware advances, such as RISC's and the prevalence of memory hierarchies, and modern software design techniques, such as object-oriented programming and distributed computing. We have used Nachos in the undergraduate operating systems class at Berkeley, with positive results. Nachos is freely available, and we would like to see it widely used for undergraduate instruction. 
Abstract-found: 1
Intro-found: 1
Reference: [Aguirre et al. 1991] <author> Aguirre, G., Errecalde, M., Guerrero, R., Kavka, C., Leguizamon, G., Printista, M., and Gallard, R. </author> <title> Experiencing MINIX as a Didactical Aid for Operating Systems Courses. </title> <journal> Operating Systems Review, </journal> <volume> 25 </volume> <pages> 32-39, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: This paper discusses an operating system, simulation environment, and set of assignments that we developed for the undergraduate operating systems course at Berkeley. Over the years, numerous projects have been developed for teaching operating systems; among the published ones are Tunis [Holt 1983] and Minix <ref> [Tanenbaum 1987b, Aguirre et al. 1991] </ref>. Many of these projects were motivated by the development of UNIX [Ritchie & Thompson 1974] in the mid 70's.
Reference: [Anderson et al. 1989] <author> Anderson, T., Lazowska, E., and Levy, H. </author> <title> The Performance Implications of Thread Management Alternatives for Shared Memory Multiprocessors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(12) </volume> <pages> 1631-1644, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In retrospect, the result was that many students were still making concurrency errors even in the final phase of the project. Our thread system is based on FastThreads <ref> [Anderson et al. 1989] </ref>. Our primary goal was simplicity, to reduce the effort required for students to trace the behavior of the thread system. 4 Our implementation is a total of about 10 pages of C++ and a page of MIPS assembly code.
Reference: [Bedichek 1990] <author> Bedichek, R. </author> <title> Some Efficient Architecture Simulation Techniques. </title> <booktitle> In Proceedings of the 1990 USENIX Winter Conference, </booktitle> <pages> pp. 53-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: This vastly simplifies operating systems development, by reducing the compile-execute-debug cycle and by allowing the use of off-the-shelf symbolic debuggers. Because of these advantages, many commercial operating system development efforts now routinely use simulated machines <ref> [Bedichek 1990] </ref>. However, recent advances in operating systems, hardware architecture, and software engineering have left many operating systems projects developed over the past two decades out of date. Networking and distributed applications are now commonplace. Threads are crucial for the construction of both operating systems and higher-level concurrent applications.
Reference: [Birrell 1989] <author> Birrell, A. </author> <title> An Introduction to Programming with Threads. </title> <type> Technical Report #35, </type> <institution> Digital Equipment Corporation's Systems Research Center, Palo Alto, California, </institution> <month> January </month> <year> 1989. </year>
Reference: [Chandy & Misra 1981] <author> Chandy, K. and Misra, J. </author> <title> Asynchronous Distributed Simulation via a Sequence of Parallel Computations. </title> <journal> Communications of the ACM, </journal> <volume> 24(11) </volume> <pages> 198-206, </pages> <month> Novem-ber </month> <year> 1981. </year>
Reference-contexts: Perhaps the biggest limitation of our current implementation is that we do not model network performance correctly, because we do not keep the timers on each of the Nachos machines synchronized with one another. There are well-known ways of doing this <ref> [Chandy & Misra 1981, Jefferson et al. 1987] </ref>, but we have not implemented one of them yet.
Reference: [Daley & Dennis 1968] <author> Daley, R. and Dennis, J. </author> <title> Virtual Memory, Processes and Sharing in MUL-TICS. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 306-312, </pages> <month> May </month> <year> 1968. </year> <month> 9 </month>
Reference-contexts: Many of these projects were motivated by the development of UNIX [Ritchie & Thompson 1974] in the mid 70's. Earlier operating systems, such as MULTICS <ref> [Daley & Dennis 1968] </ref> and OS/360 [Mealy et al. 1966] were far too complicated for an undergraduate to understand, much less modify, in a A copy of Nachos can be obtained by anonymous ftp from sprite.berkeley.edu, file "nachos/nachos-2.0.tar". The authors' e-mail addresses are ffaustus,procter,teag@cs.berkeley.edu.
Reference: [Dijkstra 1989] <author> Dijkstra, E. </author> <title> On the Cruelty of Really Teaching Computer Science. </title> <journal> Communications of the ACM, </journal> <volume> 32(12) </volume> <pages> 1398-1404, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In much the same way as pointers for beginning programmers, understanding concurrency requires a conceptual leap on the part of students. Contrary to Dijkstra <ref> [Dijkstra 1989] </ref>, we believe that the best way to teach concurrency is with a "hands-on" approach. Nachos helps in two ways.
Reference: [Holt 1983] <author> Holt, R. </author> <title> Concurrent Euclid, the UNIX System, and TUNIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: This paper discusses an operating system, simulation environment, and set of assignments that we developed for the undergraduate operating systems course at Berkeley. Over the years, numerous projects have been developed for teaching operating systems; among the published ones are Tunis <ref> [Holt 1983] </ref> and Minix [Tanenbaum 1987b, Aguirre et al. 1991]. Many of these projects were motivated by the development of UNIX [Ritchie & Thompson 1974] in the mid 70's. <p> Precisely because C and C++ allow nothing to be swept under the covers, concurrency may be easier to understand (although harder to use) in these programming languages than in those explicitly designed for concurrency, such as Ada [Mundie & Fisher 1986], Modula-3 [Nelson 1991], and Concurrent Euclid <ref> [Holt 1983] </ref>. Second, a working thread system, as in Nachos, allows students to practice writing concurrent programs and to test out those programs.
Reference: [Jefferson et al. 1987] <author> Jefferson, D., Beckman, B., Wieland, F., Blume, L., DiLoreto, M., Hontabas, P., Laroche, P., Studevant, K., Tupman, J., Warren, V., Wedel, J., Younger, H., and Bellenot, S. </author> <title> Distributed Simulation and the Time Warp Operating System. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 77-93, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Perhaps the biggest limitation of our current implementation is that we do not model network performance correctly, because we do not keep the timers on each of the Nachos machines synchronized with one another. There are well-known ways of doing this <ref> [Chandy & Misra 1981, Jefferson et al. 1987] </ref>, but we have not implemented one of them yet.
Reference: [Kane 1987] <author> Kane, G. </author> <title> MIPS R2000 RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: of its operation. 2 2 Nachos Overview Like many of its predecessor instructional operating systems, the Nachos kernel and hardware simulator run together in the same UNIX process. 2 Nachos has several significant differences with earlier systems: * Because we simulate a standard, well-documented, instruction set (MIPS R2/3000 integer instructions <ref> [Kane 1987] </ref>), we can run normal C programs as user programs on our operating system. In the past, operating systems projects typically simulated their own ad hoc instruction set, requiring user programs to be written in assembly language.
Reference: [Lam et al. 1991] <author> Lam, M., Rothberg, E., and Wolf, M. </author> <title> The Cache Performance and Optimizations of Blocked Algorithms. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 63-74, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Further, the application illustrates some of the problems with caching | small changes in the implementation of matrix multiply can have a large impact on performance <ref> [Lam et al. 1991] </ref>. 3.5 Networking Although distributed systems have become increasingly important commercially, most instructional operating systems have not included any networking components. To address this, the capstone of the project is to write a significant and interesting distributed application.
Reference: [Lampson & Redell 1980] <author> Lampson, B. and Redell, D. </author> <title> Experiences with Processes and Monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 104-117, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: We provide students with a basic working thread system and an implementation of semaphores; the assignment is to implement Mesa-style locks and condition variables <ref> [Lampson & Redell 1980] </ref> using semaphores, and then to implement solutions to a number of concurrency problems using these synchronization primitives. For instance, we ask students to program a simple producer-consumer interaction through a bounded buffer, using condition variables to denote the "buffer empty" and "buffer full" states.
Reference: [Le*er et al. 1989] <author> Le*er, S., McKusick, K., Karels, M., and Quarterman, J. </author> <title> Design and Implementation of the 4.3 BSD Unix Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: toss out when a new page frame is needed, in what circumstances (if any) to do read-ahead, whether or not to write unused, dirty pages back to disk in advance to speed later page fault handling, and how many pages to bring in before initially starting to run a program <ref> [Levy & Lipman 1982, Le*er et al. 1989] </ref>. These policy questions can have a large impact on overall system performance, in part because of the large and increasing gap between CPU speed and disk latency | this gap has widened by two orders of magnitude in only the last decade.
Reference: [Levy & Lipman 1982] <author> Levy, H. and Lipman, P. </author> <title> Virtual Memory Management in the VAX/VMS Operating System. </title> <booktitle> Computer, </booktitle> <pages> pp. 35-41, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: toss out when a new page frame is needed, in what circumstances (if any) to do read-ahead, whether or not to write unused, dirty pages back to disk in advance to speed later page fault handling, and how many pages to bring in before initially starting to run a program <ref> [Levy & Lipman 1982, Le*er et al. 1989] </ref>. These policy questions can have a large impact on overall system performance, in part because of the large and increasing gap between CPU speed and disk latency | this gap has widened by two orders of magnitude in only the last decade.
Reference: [Lions 1977] <author> Lions, J. </author> <title> A Commentary on the UNIX Operating System, </title> <month> June </month> <year> 1977. </year> <institution> Department of Computer Science, University of New South Wales. </institution>
Reference-contexts: Even UNIX itself is too complicated for this purpose, but UNIX showed that operating systems need only a few simple but powerful interfaces, and that the core of an operating system can be written in only a few dozen pages <ref> [Lions 1977] </ref>. Indeed, the project previously used at Berkeley, the TOY Operating System, was originally developed by Brian Kernighan in 1973. The introduction of minicomputers, and later, workstations, also aided the development of instructional operating systems.
Reference: [McKusick et al. 1984] <author> McKusick, M., Joy, W., Le*er, S., and Fabry, R. </author> <title> A Fast File System for UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference: [Mealy et al. 1966] <author> Mealy, G., Witt, B., and Clark, W. </author> <title> The Functional Structure of OS/360. </title> <journal> IBM Systems Journal, </journal> <volume> 5(1) </volume> <pages> 3-51, </pages> <month> January </month> <year> 1966. </year>
Reference-contexts: Many of these projects were motivated by the development of UNIX [Ritchie & Thompson 1974] in the mid 70's. Earlier operating systems, such as MULTICS [Daley & Dennis 1968] and OS/360 <ref> [Mealy et al. 1966] </ref> were far too complicated for an undergraduate to understand, much less modify, in a A copy of Nachos can be obtained by anonymous ftp from sprite.berkeley.edu, file "nachos/nachos-2.0.tar". The authors' e-mail addresses are ffaustus,procter,teag@cs.berkeley.edu.
Reference: [Mundie & Fisher 1986] <author> Mundie, D. and Fisher, D. </author> <title> Parallel Processing in Ada. </title> <journal> IEEE Computer Magazine, </journal> <volume> 19(8) </volume> <pages> 20-25, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: We believe this experience is crucial to de-mystifying concurrency. Precisely because C and C++ allow nothing to be swept under the covers, concurrency may be easier to understand (although harder to use) in these programming languages than in those explicitly designed for concurrency, such as Ada <ref> [Mundie & Fisher 1986] </ref>, Modula-3 [Nelson 1991], and Concurrent Euclid [Holt 1983]. Second, a working thread system, as in Nachos, allows students to practice writing concurrent programs and to test out those programs.
Reference: [Nelson 1991] <author> Nelson, G., </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Precisely because C and C++ allow nothing to be swept under the covers, concurrency may be easier to understand (although harder to use) in these programming languages than in those explicitly designed for concurrency, such as Ada [Mundie & Fisher 1986], Modula-3 <ref> [Nelson 1991] </ref>, and Concurrent Euclid [Holt 1983]. Second, a working thread system, as in Nachos, allows students to practice writing concurrent programs and to test out those programs.
Reference: [Patterson 1992] <author> Patterson, D. </author> <title> Has CS Changed in 20 Years? Computing Research News, </title> <booktitle> 4(2) </booktitle> <pages> 2-3, </pages> <month> March </month> <year> 1992. </year>
Reference: [Ritchie & Thompson 1974] <author> Ritchie, D. and Thompson, K. </author> <title> The Unix Time-Sharing System. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: Over the years, numerous projects have been developed for teaching operating systems; among the published ones are Tunis [Holt 1983] and Minix [Tanenbaum 1987b, Aguirre et al. 1991]. Many of these projects were motivated by the development of UNIX <ref> [Ritchie & Thompson 1974] </ref> in the mid 70's. <p> We provide a basic working file system that is as stripped of as much functionality as possible. While the file system has an interface similar to that of UNIX <ref> [Ritchie & Thompson 1974] </ref> (cast in terms of C++ objects), it also has many significant limitations with respect to commercial file systems: there is no synchronization (only one thread can access the file system at a time), files have a very small maximum size, files have a fixed size once created,
Reference: [Rosenblum & Ousterhout 1992] <author> Rosenblum, M. and Ousterhout, J. </author> <title> The Design and Implementation of a Log-Structured File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 26-52, </pages> <month> February </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: We also initially gave students the option of which limitations to fix; from our experience, we found that students learned the most from fixing the first four listed above. The result is that, even though virtually all modern file systems include some form of write-ahead logging or log-structure <ref> [Rosenblum & Ousterhout 1992] </ref>, the assignment now completely ignores the issue of crash 5 recovery.
Reference: [Tanenbaum 1987a] <author> Tanenbaum, A. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference: [Tanenbaum 1987b] <author> Tanenbaum, A. </author> <title> A UNIX Clone with Source Code for Operating Systems Courses. </title> <journal> Operating Systems Review, </journal> <volume> 21(1) </volume> <pages> 20-29, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This paper discusses an operating system, simulation environment, and set of assignments that we developed for the undergraduate operating systems course at Berkeley. Over the years, numerous projects have been developed for teaching operating systems; among the published ones are Tunis [Holt 1983] and Minix <ref> [Tanenbaum 1987b, Aguirre et al. 1991] </ref>. Many of these projects were motivated by the development of UNIX [Ritchie & Thompson 1974] in the mid 70's.
Reference: [Wulf et al. 1974] <author> Wulf, W., Cohen, E., Corwin, W., Jones, A., Levin, R., Pierson, C., and Pollack, F. HYDRA: </author> <title> The Kernel of a Multiprocessor Operating System. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-344, </pages> <month> June </month> <year> 1974. </year> <month> 11 </month>
Reference-contexts: One important topic we chose to leave out (again, as a tradeoff against time constraints) is the trend toward a small-kernel operating system structure, where pieces of the operating system are split off into user-level servers <ref> [Wulf et al. 1974] </ref>.
References-found: 25

