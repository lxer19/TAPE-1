URL: file://dream.dai.ed.ac.uk/pub/papers/PS/rp349.ps.gz
Refering-URL: http://www.dai.ed.ac.uk:80/staff/personal_pages/bundy/drafts/ripple-faq.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The Use of Explicit Plans to Guide Inductive Proofs  
Author: Alan Bundy 
Note: DAI Research Paper No. Copyright (c) 1987 Alan Bundy Shorter version to appear in the proceedings of CADE-9.  
Abstract-found: 0
Intro-found: 1
Reference: [Aubin 75] <author> R. Aubin. </author> <title> Some generalization heuristics in proofs by induction. </title> <editor> In G. Huet and G. Kahn, editors, </editor> <booktitle> Actes du Colloque Construction: </booktitle> <institution> Amelioration et verification de Programmes. Institut de recherche d'informatique et d'automatique, </institution> <year> 1975. </year>
Reference-contexts: Following Darlington, [Darlington 81], we call a single application of the step equation an unfold 3 . This analysis of the ripple-out process is suggested by the work of Aubin, <ref> [Aubin 75] </ref>. We describe this work in more detail in section 9.2. <p> We conclude this paper with a discussion of some of the limitations of our rational reconstruction. Some of the extensions below are taken from the work of Boyer and Moore, some from the work of their student, Aubin <ref> [Aubin 75] </ref>, and some are based on our own analyses. Each of these suggests improvements to the methods we have defined. These improvements could be hand-coded or they could be used as examples to test the automatic learning techniques mentioned above. <p> These are the variables which occur at the innermost positions of a sequence of nested recursive functions each occurring in the recursive position of the previous one. Aubin, <ref> [Aubin 75] </ref>, calls these the primary recursion variables. We would like to apply induction just to these two occurrences 9 .
Reference: [Boyer & Moore 79] <author> R.S. Boyer and J.S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year> <journal> ACM monograph series. </journal> <volume> 21 </volume>
Reference-contexts: In logic and functional programs, recursion is used in place of the imperative program constructs of iteration, eg while, until, do, etc. We are thus particularly interested in inductive proofs. The best work to date on the guidance of inductive proofs is that by Boyer and Moore, <ref> [Boyer & Moore 79] </ref>. Figure 1 on page 3 contains a simple example of the kind of inductive proof found by their theorem prover. Hence, we have been adapting the techniques embedded in the Boyer-Moore theorem prover to the NuPRL environment, [Stevens 88]. <p> In order to adapt the Boyer-Moore work we first need to understand why it works. Their program contains a large amount of heuristic information which is highly successful in guiding inductive proofs. However, the descriptions of these heuristics in <ref> [Boyer & Moore 79] </ref> are not always clear about why they are successful nor why they are applied in a particular order. Some heuristics are not appropriate in the NuPRL system, or require modification to make them appropriate.
Reference: [Bundy & Welham 81] <author> A. Bundy and B. Welham. </author> <title> Using meta-level inference for select-ive application of multiple rewrite rules in algebraic manipulation. </title> <journal> Artificial Intelligence, </journal> <volume> 16(2) </volume> <pages> 189-212, </pages> <year> 1981. </year> <note> Also available from Ed-inburgh as DAI Research Paper 121. </note>
Reference-contexts: a current research project in the mathematical reasoning group at Edinburgh to develop automatic search control for the NuPRL program synthesis system, [Constable et al 86], and it was inspired by an earlier project of the group on the use of meta-level inference to guide an equation solving system, PRESS, <ref> [Bundy & Welham 81, Sterling et al 82] </ref>. In meta-level inference we use a sorted meta-logic to reason about the problem to be solved and the methods available to solve it: matching one against the other. <p> Consider, for instance, the attraction and collection methods for equation solving described in <ref> [Bundy & Welham 81] </ref>. The effect of attraction is to reduce the overall distance between the occurrences of the equation's unknown, x. The effect of collection is to merge two or more occurrences of x into one. Both work by applying rewrite rules of a suitable syntactic form.
Reference: [Bundy 87a] <author> A. Bundy. </author> <title> The derivation of tactic specifications. Blue Book Note 356, </title> <institution> Department of Artificial Intelligence, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: carried out this programme for earlier versions of the methods described in section 5, ie given the expectancy formula for the method unfold I have proved the expectancy formula for the method ripple-out, then given them for: induction; take-out, f ertilization and simplify, I have proved one for basic-plan (see <ref> [Bundy 87a] </ref> for details). The structure of each proof is: super-method preconditions ! sub-method preconditions ! sub-method effects ! super-method effects The steps going between super- and sub-methods require the tactic definition for the appropriate link. The other step is by assumption.
Reference: [Bundy 87b] <author> A. Bundy. </author> <title> How to improve the reliability of expert systems. </title> <editor> In S. Moralee, editor, </editor> <booktitle> Research and Development in Expert Systems IV, </booktitle> <pages> pages 3-17. </pages> <booktitle> British Computer Society Specialist Group on Expert Systems, C.U.P., </booktitle> <year> 1987. </year> <note> Also available from Edinburgh as DAI Research Paper No. 336. </note>
Reference-contexts: We are able to say, not only what kind of conclusion can, in principle, be inferred, but how likely it is that any particular conclusion will be. For more discussion of this issue see <ref> [Bundy 87b] </ref>. * Explanatory Power: By expressing the control decisions in a meta-logic we have provided an alternative language for explaining them, ie instead of answering "why" questions by printing out a sequence of object-level rule firings, we can describe the current method and its place in the overall plan.
Reference: [Constable et al 86] <editor> R.L. Constable, S.F. Allen, H.M. Bromley, et al. </editor> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: This proposal was motivated by a current research project in the mathematical reasoning group at Edinburgh to develop automatic search control for the NuPRL program synthesis system, <ref> [Constable et al 86] </ref>, and it was inspired by an earlier project of the group on the use of meta-level inference to guide an equation solving system, PRESS, [Bundy & Welham 81, Sterling et al 82].
Reference: [Darlington 81] <author> J. Darlington. </author> <title> An experimental program transformation and synthesis system. </title> <journal> Artificial Intelligence, </journal> <volume> 16(3) </volume> <pages> 1-46, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: The step equations merely ripple the occurrences of s out once. By applying these step equations repeatedly the occurrences of s are rippled out from their innermost to the outermost position. Following Darlington, <ref> [Darlington 81] </ref>, we call a single application of the step equation an unfold 3 . This analysis of the ripple-out process is suggested by the work of Aubin, [Aubin 75]. We describe this work in more detail in section 9.2.
Reference: [Desimone 87] <author> R.V. Desimone. </author> <title> Learning control knowledge within an explanation-based learning framework. </title> <editor> In I. Bratko and N. Lavrac, editors, </editor> <booktitle> Progress in Machine Learning Proceedings of 2nd European Working Session on Learning, </booktitle> <address> EWSL-87, Bled, Yugoslavia. </address> <publisher> Sigma Press, </publisher> <month> May </month> <year> 1987. </year> <note> Also available from Edinburgh as DAI Research Paper 321. </note>
Reference-contexts: Our representation of method is based on that of Precondition Analysis. Desimone has been extending this technique by removing some technical limitations which made it inapplicable to general proofs, <ref> [Desimone 87] </ref>. Precondition Analysis is also capable of learning new methods, ie the specifications of unknown tactics. Also relevant is the work of Knoblock and Constable, [Knoblock & Constable 86], who have shown how NuPRL can be applied to the synthesis of its own tactics.
Reference: [Fikes et al 71] <author> R.E. Fikes, , and N.J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> <volume> 2 </volume> <pages> 189-208, </pages> <year> 1971. </year>
Reference-contexts: Our specification formalism was adapted from that used in the LP system, [Silver 84, Silver 85], which was an extension of PRESS. The LP formalism was itself based on that of STRIPS, <ref> [Fikes et al 71] </ref>. However, note that, unlike the plans formed in STRIPS-type plan formation, our plans will contain subroutines and recursion. Following PRESS, we call the specification of a tactic, a method. A method is a frame containing information about the preconditions and effects of a tactic.
Reference: [Gordon et al 79] <author> M.J. Gordon, A.J. Milner, </author> <title> and C.P. Wadsworth. Edinburgh LCF - A mechanised logic of computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Note that the round bracket notation is unsound if the normal rules for substitution are applied to it. This is discussed further in section 10. Each arc is labelled with the name of the step that justifies the rewriting. Following LCF, <ref> [Gordon et al 79] </ref>, we call these steps tactics. A p sign beside a tactic indicates that it is guaranteed to succeed, whereas a ? indicates that it might fail.
Reference: [Knoblock & Constable 86] <author> T. B. Knoblock and R.L. Constable. </author> <title> Formalized metareasoning in type theory. </title> <booktitle> In Proceedings of LICS, </booktitle> <pages> pages 237-248. </pages> <publisher> IEEE, </publisher> <year> 1986. </year>
Reference-contexts: Desimone has been extending this technique by removing some technical limitations which made it inapplicable to general proofs, [Desimone 87]. Precondition Analysis is also capable of learning new methods, ie the specifications of unknown tactics. Also relevant is the work of Knoblock and Constable, <ref> [Knoblock & Constable 86] </ref>, who have shown how NuPRL can be applied to the synthesis of its own tactics.
Reference: [Mitchell et al 86] <author> T.M. Mitchell, R.M. Keller, and S.T. Kedar-Cabelli. </author> <title> Explanation-based generalization: A unifying view. </title> <journal> Machine Learning, </journal> <volume> 1(1) </volume> <pages> 47-80, </pages> <year> 1986. </year> <note> Also available as Tech. Report ML-TR-2, </note> <institution> SUNJ Rutgers, </institution> <year> 1985. </year>
Reference-contexts: We have chosen to represent our plans in a sorted meta-logic. This gives an explicit representation to reason with, and also allows the plans to be very general (generality). Other researchers have experimented with proof plans formed by combining object-level operators using explanation-based generalization (see eg <ref> [Mitchell et al 86] </ref>). These plans are restricted to the particular sequence of operators used in the object-level plan. To lift this restriction, and allow a variety of similar operators at each step, requires a meta-level description of the similarity between the operators.
Reference: [Silver 84] <author> B. Silver. </author> <title> Precondition analysis: Learning control information. In R.S. </title> <editor> Michalski, J.G. Carbonell, and T.M. Mitchell, editors, </editor> <booktitle> Machine Learning 2. </booktitle> <publisher> Tioga Publishing Company, </publisher> <year> 1984. </year>
Reference-contexts: Below we propose such a specification, which we plan to implement within the NuPRL or a similar framework. Our specification formalism was adapted from that used in the LP system, <ref> [Silver 84, Silver 85] </ref>, which was an extension of PRESS. The LP formalism was itself based on that of STRIPS, [Fikes et al 71]. However, note that, unlike the plans formed in STRIPS-type plan formation, our plans will contain subroutines and recursion. <p> We are also interested in the use of the techniques of plan formation and/or automatic program synthesis to construct such proof plans automatically. Of relevance here is the work of Silver, <ref> [Silver 84, Silver 85] </ref>, who developed the technique of Precondition Analysis for learning proof plans from examples in the domain of equation solving. Our representation of method is based on that of Precondition Analysis.
Reference: [Silver 85] <author> B. Silver. </author> <title> Meta-level inference: </title> <booktitle> Representing and Learning Control Information in Artificial Intelligence. </booktitle> <publisher> North Holland, </publisher> <year> 1985. </year> <note> Revised version of the author's PhD thesis, DAI 1984. </note>
Reference-contexts: Below we propose such a specification, which we plan to implement within the NuPRL or a similar framework. Our specification formalism was adapted from that used in the LP system, <ref> [Silver 84, Silver 85] </ref>, which was an extension of PRESS. The LP formalism was itself based on that of STRIPS, [Fikes et al 71]. However, note that, unlike the plans formed in STRIPS-type plan formation, our plans will contain subroutines and recursion. <p> We are also interested in the use of the techniques of plan formation and/or automatic program synthesis to construct such proof plans automatically. Of relevance here is the work of Silver, <ref> [Silver 84, Silver 85] </ref>, who developed the technique of Precondition Analysis for learning proof plans from examples in the domain of equation solving. Our representation of method is based on that of Precondition Analysis.
Reference: [Sterling et al 82] <author> L. Sterling, A. Bundy, L. Byrd, R. O'Keefe, and B. Silver. </author> <title> Solving symbolic equations with PRESS. </title> <editor> In J. Calmet, editor, </editor> <booktitle> Computer Algebra, Lecture Notes in Computer Science No. </booktitle> <volume> 144., </volume> <pages> pages 109-116. </pages> <publisher> Springer Verlag, </publisher> <year> 1982. </year> <note> Also available from Edinburgh as DAI Research Paper 171. 22 </note>
Reference-contexts: a current research project in the mathematical reasoning group at Edinburgh to develop automatic search control for the NuPRL program synthesis system, [Constable et al 86], and it was inspired by an earlier project of the group on the use of meta-level inference to guide an equation solving system, PRESS, <ref> [Bundy & Welham 81, Sterling et al 82] </ref>. In meta-level inference we use a sorted meta-logic to reason about the problem to be solved and the methods available to solve it: matching one against the other.
Reference: [Stevens 88] <author> A. Stevens. </author> <title> A rational reconstruction of Boyer-Moore recursion ana-lysis. </title> <type> Research Paper 360, </type> <institution> Dept. of Artificial Intelligence, Edin-burgh, </institution> <year> 1988. </year> <note> Also in Proceedings of ECAI-88. 23 </note>
Reference-contexts: Figure 1 on page 3 contains a simple example of the kind of inductive proof found by their theorem prover. Hence, we have been adapting the techniques embedded in the Boyer-Moore theorem prover to the NuPRL environment, <ref> [Stevens 88] </ref>. In doing this we want also to exploit the advantages of the meta-level inference framework. In order to adapt the Boyer-Moore work we first need to understand why it works. Their program contains a large amount of heuristic information which is highly successful in guiding inductive proofs. <p> The idea is to use the occurrence of recursive functions in the conjecture to suggest what induction scheme to use (one corresponding to the recursive structure of the function) and what variable (s) to induce on (those that occur in the recursive argument position (s) of the function). See <ref> [Stevens 88] </ref> for a more detailed analysis and rational reconstruction of this heuristic. The equations that recursively define F are then applied to the base and step cases of the resulting formula, using the tactics take-out and ripple-out, respectively. <p> We have begun just such an implementation of the Boyer-Moore heuristics, <ref> [Stevens 88] </ref>. However, such an implementation would not meet all the required properties of a proof plan. In particular, we require the ability to reason about the tactics in order to construct a proof plan for a problem and to replan when an existing proof plan fails. <p> This sort of analysis is built into the Boyer-Moore theorem prover. We call it recursion analysis. Stevens has recently built a rational reconstruction of recursion analysis, implemented as a set of tactics in the NuPRL system, <ref> [Stevens 88] </ref>. 9.2 Generalisation Apart The following example illustrates the need for a form of generalization which enables the ripple-out tactic to succeed.
References-found: 16

