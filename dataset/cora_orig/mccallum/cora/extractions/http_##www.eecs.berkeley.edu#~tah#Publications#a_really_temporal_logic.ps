URL: http://www.eecs.berkeley.edu/~tah/Publications/a_really_temporal_logic.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/a_really_temporal_logic.html
Root-URL: 
Title: A Really Temporal Logic  
Author: Rajeev Alur Thomas A. Henzinger 
Address: 600 Mountain Avenue  Murray Hill, NJ 07974 Ithaca, NY 14853  
Affiliation: AT&T Bell Laboratories Computer Science Department  Cornell University  
Abstract: We introduce a temporal logic for the specification of real-time systems. Our logic, TPTL, employs a novel quantifier construct for referencing time: the freeze quantifier binds a variable to the time of the local temporal context. TPTL is both a natural language for specification and a suitable formalism for verification. We present a tableau-based decision procedure and a model checking algorithm for TPTL. Several generalizations of TPTL are shown to be highly undecidable.
Abstract-found: 1
Intro-found: 1
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D.L. Dill. </author> <title> Model checking for real-time systems. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained <ref> [ACD90, AH90, AFH91, WME92] </ref>.
Reference: [AFH91] <author> R. Alur, T. Feder, and T.A. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <booktitle> In Proceedings of the Tenth Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 139-152. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year> <month> 22 </month>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained <ref> [ACD90, AH90, AFH91, WME92] </ref>.
Reference: [AH89] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <booktitle> In Proceedings of the 30th An--nual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 164-169. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: In the case of XCTL, all formulas are quantifier-free and their variables are implicitly universally quantified, which makes it difficult to compose requirements, like asserting that an implementation implies a specification. We will find both restrictions unnecessary. Since an earlier version of this paper was published <ref> [AH89] </ref>, many new results concerning real-time temporal logics have been obtained [ACD90, AH90, AFH91, WME92].
Reference: [AH90] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time logics: complexity and expressiveness. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 390-401. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained <ref> [ACD90, AH90, AFH91, WME92] </ref>. <p> It is also this restriction that leads to a generalization of the PTL-based tableau algorithms for verification. While the tableau method for TPTL will be developed in Section 3, the validity problem for TPTL with unconstrained classical quantification was recently shown to be nonelementary <ref> [AH90] </ref>. TPTL versus bounded temporal operators Several researchers have proposed to add an infinite supply of real-time modalities such as 3 ffi ("eventually within ffi time units") to PTL [PH88, Koy90] or branching-time logics [EMSS89]. These bounded temporal operators are definable in TPTL. <p> The extra exponential is caused by the succinct representation of time constants in TPTL and is typical for many real-time specification languages <ref> [AH90] </ref>. Theorem 2 (Complexity of TPTL) The validity problem for TPTL is EXP-SPACE-complete (with respect to polynomial-time reduction). Proof of Theorem 2 The proof proceeds in two parts; we first show that TPTL is in EXPSPACE, and then that it is EXPSPACE-hard. <p> All of these formalisms admit addition over time as a primitive, which renders them undecidable (see <ref> [AH90] </ref>). 4.4 Dense TPTL An alternative way of extending the expressive power of TPTL is to relax the semantics by adopting a dense time domain; that is, between any two given points in time there is another time point. We show that the resulting logic is, again, highly undecidable.
Reference: [AH92] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained [ACD90, AH90, AFH91, WME92]. We point to [Hen90] for a complete axiomatization of TPTL and to <ref> [AH92] </ref> for a survey of recent results. 2 Timed Temporal Logic We define Timed Propositional Temporal Logic, TPTL, and demonstrate its adequacy as a real-time specification language. 2.1 Timed state sequences The formulas of TPTL are interpreted over timed state sequences. <p> Reasoning about dense time, on the other hand, may be prohibitively difficult (see Section 4). As a compromise, the fictitious-clock (or digital-clock ) assumption for real-time systems has enjoyed increasing popularity <ref> [AH92, HMP92] </ref>: the true, dense times of events are recorded with the finite precision of a discrete clock. <p> of INITIAL , MOVE , and ACCEPT are O (nlog n), O (n), and O (1), respectively (recall that constants are represented in binary), thus implying the desired O (n log n)-bound for X . 3.3 Real-time verification Researchers have proposed a variety of different languages for defining real-time systems <ref> [AH92] </ref>. Instead of siding with a particular syntax, we represent finite-state real-time systems by abstract state graphs with timing information. Typically, it is not difficult to compile a given concrete syntax into timed state graphs (consult, for example, [Hen91] for the translation of timed transition systems into timed state graphs).
Reference: [BH81] <author> A. Bernstein and P.K. Harter, Jr. </author> <title> Proving real-time properties of programs with temporal logic. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Operating System Principles, </booktitle> <pages> pages 1-11. </pages> <publisher> ACM Press, </publisher> <year> 1981. </year>
Reference-contexts: The analysis of systems with hard real-time requirements, such as bounded response time, calls, however, for the development of formalisms with explicit time. Several attempts have been made to introduce time explicitly in PTL, and to interpret it over models that associate a time with every system state <ref> [BH81, PH88, Koy90, Ost90] </ref>. While these logics allow the specification of typical real-time requirements, most of the important decidability and complexity questions have not been answered. In particular, it has not been understood which timing constraints may be permitted in PTL without sacrificing the decidability of the verification problem.
Reference: [BMP81] <author> M. Ben-Ari, Z. Manna, and A. Pnueli. </author> <title> The temporal logic of branching time. </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 164-176. </pages> <publisher> ACM Press, </publisher> <year> 1981. </year>
Reference-contexts: It originated with the propositional calculus [Smu68] and was first applied to obtain a decision procedure for a modal logic of computation in the case of dynamic logic [Pra80]. We follow the standard presentation of the tableau-based decision procedure for PTL <ref> [BMP81, Wol83] </ref> and begin by constructing the initial tableau for . Checking the satisfiability of can then be reduced to checking if the finite initial tableau for contains certain infinite paths.
Reference: [EMSS89] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reasoning. </title> <booktitle> Presented at the First Annual Workshop on Computer-aided Verification, </booktitle> <address> Grenoble, France, </address> <year> 1989. </year>
Reference-contexts: Alternative approaches to the automatic verification of real-time systems using temporal logic include work on the branching-time logic RTCTL <ref> [EMSS89] </ref> and the explicit-clock logic XCTL [HLP90]. RTCTL makes the simplifying assumption of modeling synchronous real-time systems, all of whose events occur with the ticks of a global clock. <p> TPTL versus bounded temporal operators Several researchers have proposed to add an infinite supply of real-time modalities such as 3 ffi ("eventually within ffi time units") to PTL [PH88, Koy90] or branching-time logics <ref> [EMSS89] </ref>. These bounded temporal operators are definable in TPTL. For instance, the bounded-eventuality operator 3 ffi can be expressed by the TPTL-formula x: 3y: (y x + ffi ^ ): While bounded temporal operators always relate the times of adjacent temporal contexts, TPTL admits constraints between distant contexts. <p> For reasoning about synchronous real-time systems, "next state" can be identified with "next time" and timing constraints may be expressed in PTL using the next operator. In this case, bounded temporal operators are abbreviations for nested next formulas <ref> [EMSS89] </ref>. We can restrict TPTL to the synchronous case by postulating 2x: fl y: y = x + 1: 3 Timed Tableaux We present a tableau-based decision procedure for TPTL. We then justify the doubly-exponential-time cost of the decision procedure by showing that the validity problem for TPTL is EXPSPACE-complete.
Reference: [GPSS80] <author> D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi. </author> <title> On the temporal analysis of fairness. </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173. </pages> <publisher> ACM Press, </publisher> <year> 1980. </year>
Reference-contexts: The size of a formula will be important for locating the computational complexity of problems whose input includes formulas of TPTL. The temporal operators. TPTL is based on the two temporal operators of PTL <ref> [GPSS80] </ref>. The next formula flp asserts about a timed state sequence that the second state in the sequence satisfies the proposition p.
Reference: [Hal91] <author> J.Y. Halpern. </author> <title> Presburger arithmetic with unary predicates is 1 1 -complete. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 56(2) </volume> <pages> 637-642, </pages> <year> 1991. </year>
Reference-contexts: As a corollary we infer that the first-order theory of the natural numbers with , multiplication by 2, and monadic predicates is 1 1 -complete. A similar result has been obtained independently in <ref> [Hal91] </ref>, where it is shown that Presburger arithmetic becomes 1 1 -complete with the addition of a single unary predicate. 21 The proof technique we used to show Presburger TPTL undecidable can be applied to many real-time specification languages, including the logics RTL [JM86], GCTL [Har88], RTTL [Ost90], and MTL [Koy90].
Reference: [Har88] <author> E. Harel. </author> <title> Temporal analysis of real-time systems. </title> <type> Master's thesis, </type> <institution> The Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1988. </year>
Reference-contexts: The explicit quantification of variables, however, is typically omitted from first-order temporal specifications [PH88, Ost90]. Moreover, specification languages are often restricted to formulas with implicit or explicit quantifier prefixes <ref> [Har88, HLP90] </ref>. The condition (2) is an example that the choice of quantifiers that provides the intended meaning may not be obvious and, indeed, may not correspond to any prefix. <p> has been obtained independently in [Hal91], where it is shown that Presburger arithmetic becomes 1 1 -complete with the addition of a single unary predicate. 21 The proof technique we used to show Presburger TPTL undecidable can be applied to many real-time specification languages, including the logics RTL [JM86], GCTL <ref> [Har88] </ref>, RTTL [Ost90], and MTL [Koy90].
Reference: [Hen90] <author> T.A. Henzinger. </author> <title> Half-order modal logic: how to prove real-time properties. </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 281-296. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained [ACD90, AH90, AFH91, WME92]. We point to <ref> [Hen90] </ref> for a complete axiomatization of TPTL and to [AH92] for a survey of recent results. 2 Timed Temporal Logic We define Timed Propositional Temporal Logic, TPTL, and demonstrate its adequacy as a real-time specification language. 2.1 Timed state sequences The formulas of TPTL are interpreted over timed state sequences.
Reference: [Hen91] <author> T.A. Henzinger. </author> <title> The Temporal Specification and Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: Instead of siding with a particular syntax, we represent finite-state real-time systems by abstract state graphs with timing information. Typically, it is not difficult to compile a given concrete syntax into timed state graphs (consult, for example, <ref> [Hen91] </ref> for the translation of timed transition systems into timed state graphs). Model checking is an algorithmic verification technique that compares the temporal-logic specification of a system against a state-graph description of the system. <p> The size of T S typically is exponentially larger than the description of S itself <ref> [Hen91] </ref>; we have seen that the size of T () can be two exponentials larger than .
Reference: [HLP90] <author> E. Harel, O. Lichtenstein, and A. Pnueli. </author> <title> Explicit-clock temporal logic. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 402-413. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: Alternative approaches to the automatic verification of real-time systems using temporal logic include work on the branching-time logic RTCTL [EMSS89] and the explicit-clock logic XCTL <ref> [HLP90] </ref>. RTCTL makes the simplifying assumption of modeling synchronous real-time systems, all of whose events occur with the ticks of a global clock. <p> The explicit quantification of variables, however, is typically omitted from first-order temporal specifications [PH88, Ost90]. Moreover, specification languages are often restricted to formulas with implicit or explicit quantifier prefixes <ref> [Har88, HLP90] </ref>. The condition (2) is an example that the choice of quantifiers that provides the intended meaning may not be obvious and, indeed, may not correspond to any prefix.
Reference: [HMP92] <author> T.A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> What good are digital clocks? In W. </title> <editor> Kuich, editor, </editor> <booktitle> ICALP 92: Automata, Languages, and Programming, Lecture Notes in Computer Science 623, </booktitle> <pages> pages 545-558. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Reasoning about dense time, on the other hand, may be prohibitively difficult (see Section 4). As a compromise, the fictitious-clock (or digital-clock ) assumption for real-time systems has enjoyed increasing popularity <ref> [AH92, HMP92] </ref>: the true, dense times of events are recorded with the finite precision of a discrete clock.
Reference: [HPS83] <author> D. Harel, A. Pnueli, and J. Stavi. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26(2) </volume> <pages> 222-243, </pages> <year> 1983. </year> <month> 23 </month>
Reference-contexts: The problem of deciding if a nondeterministic Turing machine has, over the empty tape, a computation in which the starting state is visited infinitely often, has been shown 1 1 -complete <ref> [HPS83] </ref>. Along the same lines we obtain the following result. Lemma 8 (Complexity of 2-counter machines) The problem of deciding if a given nondeterministic 2-counter machine has a recurring computation, is 1 1 -hard. <p> Proof of Lemma 8 Every 1 1 -formula is equivalent to a 1 1 -formula of the form 9f: (f (0) = 1 ^ 8x: g (f (x); f (x + 1))); for a recursive predicate g <ref> [HPS83] </ref>. For any such we can construct a nondeterministic 2-counter machine M that has a recurring computation iff is true. 19 Let M start by computing f (0) = 1, and proceed, indefinitely, by nondeterministically guessing the next value of f .
Reference: [HU79] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: The first part follows the argument that PTL is in PSPACE, which builds on a nondeterministic version of the tableau-based decision procedure [Wol83]; the hardness part is patterned after a proof that the universality problem of regular expressions with exponentiation is EXPSPACE-hard <ref> [HU79] </ref>. [EXPSPACE] It suffices to show that the complementary problem of checking the satisfiabil-ity of a TPTL-formula is in nondeterministic EXPSPACE and, hence, by Savitch's theorem, in (deterministic) EXPSPACE.
Reference: [JM86] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <year> 1986. </year>
Reference-contexts: similar result has been obtained independently in [Hal91], where it is shown that Presburger arithmetic becomes 1 1 -complete with the addition of a single unary predicate. 21 The proof technique we used to show Presburger TPTL undecidable can be applied to many real-time specification languages, including the logics RTL <ref> [JM86] </ref>, GCTL [Har88], RTTL [Ost90], and MTL [Koy90].
Reference: [Koy90] <author> R. Koymans. </author> <title> Specifying real-time properties with metric temporal logic. </title> <booktitle> Real-time Systems, </booktitle> <volume> 2(4) </volume> <pages> 255-299, </pages> <year> 1990. </year>
Reference-contexts: The analysis of systems with hard real-time requirements, such as bounded response time, calls, however, for the development of formalisms with explicit time. Several attempts have been made to introduce time explicitly in PTL, and to interpret it over models that associate a time with every system state <ref> [BH81, PH88, Koy90, Ost90] </ref>. While these logics allow the specification of typical real-time requirements, most of the important decidability and complexity questions have not been answered. In particular, it has not been understood which timing constraints may be permitted in PTL without sacrificing the decidability of the verification problem. <p> TPTL versus bounded temporal operators Several researchers have proposed to add an infinite supply of real-time modalities such as 3 ffi ("eventually within ffi time units") to PTL <ref> [PH88, Koy90] </ref> or branching-time logics [EMSS89]. These bounded temporal operators are definable in TPTL. <p> [Hal91], where it is shown that Presburger arithmetic becomes 1 1 -complete with the addition of a single unary predicate. 21 The proof technique we used to show Presburger TPTL undecidable can be applied to many real-time specification languages, including the logics RTL [JM86], GCTL [Har88], RTTL [Ost90], and MTL <ref> [Koy90] </ref>.
Reference: [LA92] <author> L. Lamport and M. Abadi. </author> <title> An old-fashioned recipe for real time. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 1-27. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: preliminary version of this paper appeared in the Proceedings of the 30th IEEE Symposium on Foundations of Computer Science (FOCS 1989), pp. 164-169, and an extended version appeared in The Journal of the ACM 41, 1994, pp. 181-204. employs first-order temporal logic, with one of the state variables representing time <ref> [PH88, Ost90, LA92] </ref>. We claim that the unconstrained quantification of time variables allowed by this approach does not restrict the user to reasonable and readable specifications.
Reference: [LP84] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite-state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107. </pages> <publisher> ACM Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 Introduction Linear temporal logic is a widely accepted language for specifying properties of reactive systems and their behavior over time [Pnu77, OL82, MP92]. The tableau-based satisfiability algorithm for its propositional version, PTL, forms the basis for the automatic verification and synthesis of finite-state systems <ref> [LP84, MW84] </ref>. PTL is interpreted over models that abstract away from the actual times at which events occur, retaining only temporal ordering information about the states of a system. <p> Furthermore, suppose that the specification of S is given as a formula of a linear temporal logic. The verification problem asks if all possible runs of the system S satisfy the specification . In the case of PTL, the tableau construction can be used to solve the verification problem <ref> [LP84] </ref>. The initial tableau T (:) for the negated specification : captures precisely the models of the formula :. <p> Check if T contains an initialized :-path. The system S meets the specification iff this is not the case. According to different notions of system fairness, various variants of computations through timed state graphs can be defined, and checked for, as in the untimed case <ref> [LP84] </ref>. Since a structure can be checked for -paths in polynomial time, the running time of the model checking algorithm is determined by the size of the tableau product T , which contains O (jT S jjT ()j) vertices.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Linear temporal logic is a widely accepted language for specifying properties of reactive systems and their behavior over time <ref> [Pnu77, OL82, MP92] </ref>. The tableau-based satisfiability algorithm for its propositional version, PTL, forms the basis for the automatic verification and synthesis of finite-state systems [LP84, MW84].
Reference: [MW84] <author> Z. Manna and P. Wolper. </author> <title> Synthesis of communicating processes from temporal-logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 68-93, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Linear temporal logic is a widely accepted language for specifying properties of reactive systems and their behavior over time [Pnu77, OL82, MP92]. The tableau-based satisfiability algorithm for its propositional version, PTL, forms the basis for the automatic verification and synthesis of finite-state systems <ref> [LP84, MW84] </ref>. PTL is interpreted over models that abstract away from the actual times at which events occur, retaining only temporal ordering information about the states of a system.
Reference: [OL82] <author> S. Owicki and L. Lamport. </author> <title> Proving liveness properties of concurrent programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 455-495, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Linear temporal logic is a widely accepted language for specifying properties of reactive systems and their behavior over time <ref> [Pnu77, OL82, MP92] </ref>. The tableau-based satisfiability algorithm for its propositional version, PTL, forms the basis for the automatic verification and synthesis of finite-state systems [LP84, MW84].
Reference: [Ost90] <author> J.S. Ostroff. </author> <title> Temporal Logic of Real-time Systems. </title> <publisher> Research Studies Press, </publisher> <year> 1990. </year>
Reference-contexts: The analysis of systems with hard real-time requirements, such as bounded response time, calls, however, for the development of formalisms with explicit time. Several attempts have been made to introduce time explicitly in PTL, and to interpret it over models that associate a time with every system state <ref> [BH81, PH88, Koy90, Ost90] </ref>. While these logics allow the specification of typical real-time requirements, most of the important decidability and complexity questions have not been answered. In particular, it has not been understood which timing constraints may be permitted in PTL without sacrificing the decidability of the verification problem. <p> preliminary version of this paper appeared in the Proceedings of the 30th IEEE Symposium on Foundations of Computer Science (FOCS 1989), pp. 164-169, and an extended version appeared in The Journal of the ACM 41, 1994, pp. 181-204. employs first-order temporal logic, with one of the state variables representing time <ref> [PH88, Ost90, LA92] </ref>. We claim that the unconstrained quantification of time variables allowed by this approach does not restrict the user to reasonable and readable specifications. <p> The explicit quantification of variables, however, is typically omitted from first-order temporal specifications <ref> [PH88, Ost90] </ref>. Moreover, specification languages are often restricted to formulas with implicit or explicit quantifier prefixes [Har88, HLP90]. The condition (2) is an example that the choice of quantifiers that provides the intended meaning may not be obvious and, indeed, may not correspond to any prefix. <p> obtained independently in [Hal91], where it is shown that Presburger arithmetic becomes 1 1 -complete with the addition of a single unary predicate. 21 The proof technique we used to show Presburger TPTL undecidable can be applied to many real-time specification languages, including the logics RTL [JM86], GCTL [Har88], RTTL <ref> [Ost90] </ref>, and MTL [Koy90].
Reference: [PH88] <author> A. Pnueli and E. Harel. </author> <title> Applications of temporal logic to the specification of real-time systems. </title> <editor> In M. Joseph, editor, </editor> <booktitle> Formal Techniques in Real-time and Fault-tolerant Systems, Lecture Notes in Computer Science 331, </booktitle> <pages> pages 84-98. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The analysis of systems with hard real-time requirements, such as bounded response time, calls, however, for the development of formalisms with explicit time. Several attempts have been made to introduce time explicitly in PTL, and to interpret it over models that associate a time with every system state <ref> [BH81, PH88, Koy90, Ost90] </ref>. While these logics allow the specification of typical real-time requirements, most of the important decidability and complexity questions have not been answered. In particular, it has not been understood which timing constraints may be permitted in PTL without sacrificing the decidability of the verification problem. <p> preliminary version of this paper appeared in the Proceedings of the 30th IEEE Symposium on Foundations of Computer Science (FOCS 1989), pp. 164-169, and an extended version appeared in The Journal of the ACM 41, 1994, pp. 181-204. employs first-order temporal logic, with one of the state variables representing time <ref> [PH88, Ost90, LA92] </ref>. We claim that the unconstrained quantification of time variables allowed by this approach does not restrict the user to reasonable and readable specifications. <p> The explicit quantification of variables, however, is typically omitted from first-order temporal specifications <ref> [PH88, Ost90] </ref>. Moreover, specification languages are often restricted to formulas with implicit or explicit quantifier prefixes [Har88, HLP90]. The condition (2) is an example that the choice of quantifiers that provides the intended meaning may not be obvious and, indeed, may not correspond to any prefix. <p> TPTL versus bounded temporal operators Several researchers have proposed to add an infinite supply of real-time modalities such as 3 ffi ("eventually within ffi time units") to PTL <ref> [PH88, Koy90] </ref> or branching-time logics [EMSS89]. These bounded temporal operators are definable in TPTL.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1977. </year>
Reference-contexts: 1 Introduction Linear temporal logic is a widely accepted language for specifying properties of reactive systems and their behavior over time <ref> [Pnu77, OL82, MP92] </ref>. The tableau-based satisfiability algorithm for its propositional version, PTL, forms the basis for the automatic verification and synthesis of finite-state systems [LP84, MW84].
Reference: [Pra80] <author> V.R. Pratt. </author> <title> A near-optimal method for reasoning about action. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 20(2) </volume> <pages> 231-254, </pages> <year> 1980. </year>
Reference-contexts: The tableau method searches systematically for a model of . It originated with the propositional calculus [Smu68] and was first applied to obtain a decision procedure for a modal logic of computation in the case of dynamic logic <ref> [Pra80] </ref>. We follow the standard presentation of the tableau-based decision procedure for PTL [BMP81, Wol83] and begin by constructing the initial tableau for . Checking the satisfiability of can then be reduced to checking if the finite initial tableau for contains certain infinite paths.
Reference: [Rog67] <author> H. Rogers, Jr. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1967. </year>
Reference-contexts: Both extensions are shown to be 1 1 -complete, by reducing a 1 1 -hard problem of 2-counter machines to the respec tive satisfiability problems. It follows that they cannot even be (recursively) axiomatized (for an exposition of the analytical hierarchy consult <ref> [Rog67] </ref>). 4.1 A 1 1 -complete problem A nondeterministic 2-counter machine M consists of two counters C and D, and a sequence of n instructions, each of which may increment or decrement one of the counters, or jump, conditionally upon one of the counters being zero.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logics. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: timed state sequences is essential for the tableau method to work, the progress condition on timed state sequences (and -paths) can be omitted. 14 3.2 Complexity of TPTL The following theorem establishes TPTL as being exponentially harder to decide than its untimed base PTL, which has a PSPACE-complete decision problem <ref> [SC85] </ref>. The extra exponential is caused by the succinct representation of time constants in TPTL and is typical for many real-time specification languages [AH90]. Theorem 2 (Complexity of TPTL) The validity problem for TPTL is EXP-SPACE-complete (with respect to polynomial-time reduction).
Reference: [Smu68] <author> R.M. Smullyan. </author> <title> First-order Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1968. </year>
Reference-contexts: Throughout this subsection, we are given a formula of TPTL and wish to determine if is satisfiable. The tableau method searches systematically for a model of . It originated with the propositional calculus <ref> [Smu68] </ref> and was first applied to obtain a decision procedure for a modal logic of computation in the case of dynamic logic [Pra80]. We follow the standard presentation of the tableau-based decision procedure for PTL [BMP81, Wol83] and begin by constructing the initial tableau for .
Reference: [WME92] <author> F. Wang, A.K. Mok, and E.A. Emerson. </author> <title> Asynchronous propositional temporal logic. </title> <booktitle> In Proceedings of the 12th ICSE, </booktitle> <year> 1992. </year>
Reference-contexts: We will find both restrictions unnecessary. Since an earlier version of this paper was published [AH89], many new results concerning real-time temporal logics have been obtained <ref> [ACD90, AH90, AFH91, WME92] </ref>.
Reference: [Wol83] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> 56(1/2):72-99, 1983. 
Reference-contexts: It originated with the propositional calculus [Smu68] and was first applied to obtain a decision procedure for a modal logic of computation in the case of dynamic logic [Pra80]. We follow the standard presentation of the tableau-based decision procedure for PTL <ref> [BMP81, Wol83] </ref> and begin by constructing the initial tableau for . Checking the satisfiability of can then be reduced to checking if the finite initial tableau for contains certain infinite paths. <p> This can be achieved by a straightforward modification of the standard techniques for marking all vertices of a graph that lie on an infinite path along which all eventualities are satisfied <ref> [Wol83] </ref>. The remaining state graph is called the final tableau for . It follows that a TPTL-formula has a -bounded model iff its final tableau is not empty. <p> The algorithm we have outlined can, of course, be improved in many ways. In particular, we may avoid the construction of the entire initial tableau by starting with the initial state, which contains , and successively adding new states only when needed <ref> [Wol83] </ref>. This stepwise procedure, however, does not lower the doubly exponential deterministic-time bound; as we will show in the following subsection, the decision problem for TPTL is EXPSPACE-hard. <p> Proof of Theorem 2 The proof proceeds in two parts; we first show that TPTL is in EXPSPACE, and then that it is EXPSPACE-hard. The first part follows the argument that PTL is in PSPACE, which builds on a nondeterministic version of the tableau-based decision procedure <ref> [Wol83] </ref>; the hardness part is patterned after a proof that the universality problem of regular expressions with exponentiation is EXPSPACE-hard [HU79]. [EXPSPACE] It suffices to show that the complementary problem of checking the satisfiabil-ity of a TPTL-formula is in nondeterministic EXPSPACE and, hence, by Savitch's theorem, in (deterministic) EXPSPACE.
References-found: 33

