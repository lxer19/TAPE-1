URL: ftp://ftp.cs.princeton.edu/pub/lcc/contrib/interface.ps.gz
Refering-URL: http://www.cs.princeton.edu/software/lcc/doc/
Root-URL: http://www.cs.princeton.edu
Title: A Code Generation Interface for ANSI C  
Author: CHRISTOPHER W. FRASER AND DAVID R. HANSON 
Keyword: KEY WORDS intermediate languages code generation compilers ANSI C  
Address: 600 Mountain Avenue 2C-464, Murray Hill, NJ 07974 U.S.A.  Princeton, NJ 08544 U.S.A.  
Affiliation: AT&T Bell Laboratories,  Department of Computer Science, Princeton University,  
Note: SOFTWARE---PRACTICE AND EXPERIENCE, VOL. 00(00), 000--000 (MONTH  
Email: SUMMARY  
Date: 1995)  
Abstract: lcc is a retargetable, production compiler for ANSI C; it has been ported to the VAX, Motorola 68020, SPARC, and MIPS R3000, and some versions have been in use for over a year and a half. It is smaller and faster than generally available alternatives, and its local code is comparable. This paper describes the interface between the target-independent front end and the target-dependent back ends. The interface consists of shared data structures, a few functions, and a dag language. While this approach couples the front and back ends tightly, it results in efficient, compact compilers. The interface is illustrated by detailing a code generator that emits naive VAX code. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> American National Standard for Information Systems, Programming Language C ANSI X3.159-1989, American National Standards Institute, Inc., </institution> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Likewise, there is no CVDU; conversion of a double d to an unsigned is done by the equivalent of d &gt;= x+1 ? (unsigned)(int)(d-(x+1)) + x+1 : (unsigned)(int)d where x is the maximum value for a signed integer. ASGN stores the value of kids <ref> [1] </ref> in the cell addressed by kids [0]. ASGNB implements structure assignment and other `block moves' (e.g., initialization of automatic arrays). For ASGNB, syms [0] points to a symbol for an integer constant that gives the number of bytes to be moved. <p> The front end `un-nests' function calls, so ARG nodes are always associated with the next CALL node in the forest. ARG nodes establish the value computed by kids [0] as the next argument. A CODE GENERATION INTERFACE 17 syms [0] and syms <ref> [1] </ref> point to symbol table entries for integer constants that give the size of the argument and its alignment, respectively. In CALL nodes, kids [0] computes the address of the callee. CALLB calls functions that return structures; kids [1] computes the address of a temporary local variable to hold the returned <p> A CODE GENERATION INTERFACE 17 syms [0] and syms <ref> [1] </ref> point to symbol table entries for integer constants that give the size of the argument and its alignment, respectively. In CALL nodes, kids [0] computes the address of the callee. CALLB calls functions that return structures; kids [1] computes the address of a temporary local variable to hold the returned value. There is no RETB; the front end uses a RETV preceded by an ASGNB to the structure addressed by the first local. The CALLB code and the function prologue must collaborate to store the CALLB's kids [1] <p> <ref> [1] </ref> computes the address of a temporary local variable to hold the returned value. There is no RETB; the front end uses a RETV preceded by an ASGNB to the structure addressed by the first local. The CALLB code and the function prologue must collaborate to store the CALLB's kids [1] into the callee's first local. function, local, and the code emitted below for CALLB illustrate such collaboration. CALLB nodes have a count of 0 because the front end references the temporary wherever the returned value is referenced. <p> a single node. static void ralloc (Node p) - switch (generic (p-&gt;op)) - case ARG: argoffset = roundup (argoffset, p-&gt;syms <ref> [1] </ref>->u.c.v.i); p-&gt;x.argoffset = argoffset; argoffset += p-&gt;syms [0]->u.c.v.i; if (argoffset &gt; argbuildsize) argbuildsize = roundup (argoffset, 4); break; case CALL: argoffset = 0; break; - putreg (p-&gt;kids [0]); putreg (p-&gt;kids [1]); p-&gt;x.busy = rmask; if (needsreg (p)) getreg (p); - generic strips the type suffix from an operator and thus simplifies the switch. ralloc calls putreg to release the registers allocated for the node's children and then it calls 20 C. W. FRASER AND D. R. <p> CALL and ARG nodes require extra steps. ARG nodes produce no result; instead, they store the value computed by kids [0] into the next location in the argument build area. syms [0] and syms <ref> [1] </ref> point to constant symbols that give the size and alignment of the argument. argoffset is the running offset into the argument build area. argoffset is rounded up to the appropriate alignment boundary, saved in the node's x.argoffset for use in emit, and incremented by the size of the argument. argbuildsize <p> The sample walks down the list and switches on the opcode to identify the code to emit: void emit (Node p) - for (; p; p = p-&gt;x.next) - Node a = p-&gt;kids [0], b = p-&gt;kids <ref> [1] </ref>; int r = p-&gt;x.reg; switch (p-&gt;op) - case CNSTC: case CNSTI: case CNSTP: case CNSTS: case CNSTU: print ("movl $%s,r%d"n", p-&gt;syms [0]->x.name, r); break; case ADDRGP: case ADDRFP: case ADDRLP: print ("moval %s,r%d"n", p-&gt;syms [0]->x.name, r); break; ... - The individual cases emit naive code for a single operator.
Reference: 2. <author> C. W. Fraser, </author> <title> `A language for writing code generators', </title> <journal> SIGPLAN Notices, </journal> <volume> 24, </volume> <month> 238--245 </month> <year> (1989). </year>
Reference: 3. <author> C. W. Fraser and D. R. Hanson, </author> <title> `A code generation interface for ANSI C', </title> <institution> Research Report CS-TR-270-90, Princeton University, Department of Computer Science, Princeton, NJ, </institution> <month> July </month> <year> 1990. </year>
Reference: 4. <author> A. V. Aho, M. Ganapathi, and S. W. K. Tjiang, </author> <title> `Code generation using tree matching and dynamic programming,' </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 11, </volume> <month> 491--516 </month> <year> (1989). </year>
Reference-contexts: For example, in struct node - struct node *link; int count; a; f () - int b [10]; b <ref> [4] </ref> = a.count; ... - suppose a and b point to the symbols for a and b, respectively. a-&gt;x.name is set to "a" by defsymbol, and b-&gt;x.name is set to "-40" by local. address (q1,a,4) is called with q1 representing the address of a.count, and q1-&gt;x.name is set to "a+4". <p> Likewise, address (q2,b,16) sets q2-&gt;x.name to "-40+16", which is the address of b <ref> [4] </ref>. 5.2 Compound Statements Source-language blocks bracket the lifetime of locals. gencode announces the beginning and end of a block by calling blockbeg (e) and blockend (e), respectively.
Reference: 5. <author> A. S. Tanenbaum, H. van Staveren and J. W. Stevenson, </author> <title> `Using peephole optimization on intermediate code', </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 4, </volume> <month> 21--36 </month> <year> (1982). </year>
Reference: 6. <author> K. V. Nori, U. Ammann, K. Jensen, H. H. Nageli, and C. </author> <title> Jacobi, `Pascal-P Implementation Notes', Pascal | The Language and its Implementation, </title> <editor> D. W. Barron, ed., 83--123, </editor> <publisher> John Wiley & Sons, </publisher> <year> 1981. </year>
Reference: 7. <author> D. R. Perkins and R. L. </author> <title> Sites, `Machine-independent Pascal code optimization', </title> <journal> SIGPLAN Notices, </journal> <volume> 14, </volume> <month> 201--207 </month> <year> (1979). </year>
Reference: 8. <author> M. C. Newey, P. C. Poole, and W. M. Waite, </author> <title> `Abstract machine modelling to produce portable software --- A review and evaluation', </title> <journal> Software|Practice & Experience, </journal> <volume> 2, </volume> <month> 107--136 </month> <year> (1972). </year>
Reference: 9. <author> A. S. Tanenbaum, M. Frans Kaashoek, K. G. Langendoen and C. J. H. Jacobs, </author> <title> `The design of very fast portable compilers', </title> <journal> SIGPLAN Notices, </journal> <volume> 24, </volume> <month> 125--131 </month> <year> (1989). </year>
Reference: 10. <author> J. W. Davidson and C. W. Fraser, </author> <title> `Code selection through object code optimization', </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 6, </volume> <month> 505--526 </month> <year> (1988). </year>
Reference-contexts: For example, in struct node - struct node *link; int count; a; f () - int b <ref> [10] </ref>; b [4] = a.count; ... - suppose a and b point to the symbols for a and b, respectively. a-&gt;x.name is set to "a" by defsymbol, and b-&gt;x.name is set to "-40" by local. address (q1,a,4) is called with q1 representing the address of a.count, and q1-&gt;x.name is set to
Reference: 11. <author> R. M. Stallman, </author> <title> Using and Porting GNU CC, Free Software Foundation, </title> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference: 12. <author> M. E. Benitez, P. Chan, and J. W. Davidson, A. M. Holler, S. Meloy, and V. Santhanam, `ANDF: </author> <title> Finally an UNCOL after 30 years', </title> <type> Technical Report TR-91-05, </type> <institution> University of Virginia, Department of Computer Science, </institution> <address> Charlottesville, VA, </address> <month> March </month> <year> 1991. </year>
Reference: 13. <author> T. E. Leonard, ed., </author> <title> VAX Architecture Reference Manual, </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1987. </year>
Reference: 14. <author> C. W. Fraser and D. R. Hanson, </author> <title> `Simple register spilling in a retargetable compiler', </title> <journal> Software| Practice & Experience, </journal> <note> submitted. </note>
Reference: 15. <author> R. L. Bernstein, </author> <title> `Producing good code for the case statement', </title> <journal> Software|Practice & Experience, </journal> <volume> 15, </volume> <month> 1021--1024 </month> <year> (1985). </year>
Reference: 16. <author> N. Wirth, </author> <title> `The programming language Oberon', </title> <journal> Software|Practice & Experience, </journal> <volume> 18, </volume> <month> 670-- 690 </month> <year> (1988). </year>
References-found: 16

