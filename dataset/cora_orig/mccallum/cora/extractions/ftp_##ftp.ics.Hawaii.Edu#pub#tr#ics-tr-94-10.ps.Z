URL: ftp://ftp.ics.Hawaii.Edu/pub/tr/ics-tr-94-10.ps.Z
Refering-URL: http://www.csd.uu.se/~bjornfot/r2.html
Root-URL: 
Email: corbett@hawaii.edu  
Title: An Empirical Evaluation of Three Methods for Deadlock Analysis of Ada Tasking Programs  
Author: James C. Corbett 
Address: Manoa  
Affiliation: Information and Computer Science Department University of Hawaii at  
Abstract: Static analysis of Ada tasking programs has been hindered by the well known state explosion problem that arises in the verification of concurrent systems. Many different techniques have been proposed to combat this state explosion. All proposed methods excel on certain kinds of systems, but there is little empirical data comparing the performance of the methods. In this paper, we select one representative from each of three very different approaches to the state explosion problem: partial-orders (representing state-space reductions), symbolic model checking (representing OBDD-based approaches), and inequality necessary conditions (representing integer programming-based approaches). We apply the methods to several scalable concurrency examples from the literature and to one real Ada tasking program. The results of these experiments are presented and their significance is discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques <ref> [1, 16] </ref>. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. In addition, there is not much empirical data comparing the performance of the different techniques. <p> In this paper, we conduct an empirical comparison of three very different methods: a partial order state-space reduction [8], symbolic model checking [3], and inequality necessary conditions <ref> [1] </ref>. We selected these three methods for several reasons. First, they represent three very different approaches to the state explosion problem. <p> Unfortunately, the Inequality Necessary Condition Analyzer (INCA), like many research tools, has none of these desirable properties, but since we constructed most of the components that are currently in use, this was not a problem. INCA is descended from the constrained expression toolset <ref> [1] </ref>, but it supports more powerful analysis techniques [5, 6] and is more efficient. This paper is organized as follows. Section 2 gives a necessarily brief introduction to the three methods evaluated. Section 3 discusses the methodology used for the evaluation. <p> Masticola and Ryder [14] used dataflow techniques to search for potential cyclic waits. Here, we consider a more general technique that uses linear inequalities. Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock <ref> [1] </ref>, general safety and liveness properties [5], and real-time properties [6]. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. <p> These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods. <p> The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 7, 12, 22, 24] </ref>. We model each of the n philosophers and n forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> Each of the n reader tasks and n writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 7, 12] </ref>. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in [1, 7, 12, 21]. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. <p> This system has been analyzed in [1, 7, 12]. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in <ref> [1, 7, 12, 21] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change. <p> We analyzed versions with one operator task, two pump tasks, and n customer tasks. The interaction among these tasks is much more complex than in the dining philosophers and readers/writers systems. We analyzed two different versions of this example. In the original version (GASQ) from <ref> [1, 9] </ref>, the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order.
Reference: [2] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <year> 1992. </year>
Reference-contexts: first method, a representative of state-space reduction approaches, attempts to make a standard state-space search more tractable by reducing the number of states generated. (An excellent comparison of several state-space reduction methods is given in [7].) The second method, a representative of approaches based on Ordered Binary Decision Diagrams (OBDDs) <ref> [2] </ref>, uses a symbolic representation of the state-space which, for many systems, may be far more compact than an explicit enumeration of the states. <p> One way to represent symbolically is to encode the relation as a boolean function represented by an Ordered Binary Decision Diagram (OBDD) <ref> [2] </ref>. OBDDs represent many frequently occurring boolean functions very com-pactly (e.g., symmetric functions, addition).
Reference: [3] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking <ref> [3, 15] </ref>, abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> There is growing recognition that software engineering research must focus on designing and carrying out experiments that yield quantifiable and reproducible results [20]. In this paper, we conduct an empirical comparison of three very different methods: a partial order state-space reduction [8], symbolic model checking <ref> [3] </ref>, and inequality necessary conditions [1]. We selected these three methods for several reasons. First, they represent three very different approaches to the state explosion problem. <p> The OBDD for R can be used to check for reachable states with certain properties (e.g., deadlock). In fact, model checking of temporal logic formulas can be performed in this framework without ever constructing an explicit representation of the transition system M <ref> [3] </ref>. See [15] for details. 2.3 Inequality Necessary Conditions Yet another approach to making deadlock detection more tractable is to forgo any representation of the state-space.
Reference: [4] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proceedings of the 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction <ref> [4] </ref>, compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard.
Reference: [5] <author> J. C. Corbett. </author> <title> Verifying general safety and live-ness properties with integer programming. </title> <editor> In G. v. Bochmann and D. K. Probst, editors, </editor> <booktitle> Computer Aided Verification, 4th International Workshop Proceedings, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 357-369, </pages> <address> Montreal, Canada, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: INCA is descended from the constrained expression toolset [1], but it supports more powerful analysis techniques <ref> [5, 6] </ref> and is more efficient. This paper is organized as follows. Section 2 gives a necessarily brief introduction to the three methods evaluated. Section 3 discusses the methodology used for the evaluation. <p> Here, we consider a more general technique that uses linear inequalities. Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock [1], general safety and liveness properties <ref> [5] </ref>, and real-time properties [6]. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. This flow represents the path M i takes in the trace being sought (i.e., the trace violating P ).
Reference: [6] <author> J. C. Corbett and G. S. Avrunin. </author> <title> A practical method for bounding the time between events in concurrent real-time systems. </title> <booktitle> In Ostrand and Weyuker [18], </booktitle> <pages> pages 110-116. </pages>
Reference-contexts: INCA is descended from the constrained expression toolset [1], but it supports more powerful analysis techniques <ref> [5, 6] </ref> and is more efficient. This paper is organized as follows. Section 2 gives a necessarily brief introduction to the three methods evaluated. Section 3 discusses the methodology used for the evaluation. <p> Here, we consider a more general technique that uses linear inequalities. Necessary conditions in the form of linear inequalities have been used to verify a variety of different properties of concurrent system, including freedom from deadlock [1], general safety and liveness properties [5], and real-time properties <ref> [6] </ref>. The basic idea is to view each FSA M i as a flowgraph and find a flow from the start state to some final state. This flow represents the path M i takes in the trace being sought (i.e., the trace violating P ).
Reference: [7] <author> S. Duri, U. Buy, R. Devarapalli, and S. M. Shatz. </author> <title> Using state space reduction methods for deadlock analysis in ada tasking. </title> <booktitle> In Ostrand and Weyuker [18], </booktitle> <pages> pages 51-60. </pages>
Reference-contexts: First, they represent three very different approaches to the state explosion problem. The first method, a representative of state-space reduction approaches, attempts to make a standard state-space search more tractable by reducing the number of states generated. (An excellent comparison of several state-space reduction methods is given in <ref> [7] </ref>.) The second method, a representative of approaches based on Ordered Binary Decision Diagrams (OBDDs) [2], uses a symbolic representation of the state-space which, for many systems, may be far more compact than an explicit enumeration of the states. <p> These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods. <p> The tools were applied to several families of scalable examples, and one non-scalable actual program. 4.1 Examples We chose standard examples from the concurrency analysis literature to facilitate comparisons with other techniques we did not evaluate (e.g., <ref> [7] </ref>). The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example [1, 7, 12, 22, 24]. We model each of the n philosophers and n forks with a task. <p> The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 7, 12, 22, 24] </ref>. We model each of the n philosophers and n forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> Each of the n reader tasks and n writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 7, 12] </ref>. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in [1, 7, 12, 21]. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. <p> This system has been analyzed in [1, 7, 12]. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in <ref> [1, 7, 12, 21] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change. <p> We analyzed two different versions of this example. In the original version (GASQ) from [1, 9], the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order. In the non-queuing version (GASNQ) from <ref> [7] </ref>, the operator does not enforce a first-come-first-serve order on the customers and must only record the number of customers waiting for each pump in order to activate the pump when any waiting customers remain. <p> In the non-queuing version (GASNQ) from [7], the operator does not enforce a first-come-first-serve order on the customers and must only record the number of customers waiting for each pump in order to activate the pump when any waiting customers remain. Border Defense System (BDS) This example, analyzed in <ref> [7, 14] </ref>, is the communication skeleton of a real Ada tasking program that simulates a border defense system. The original source code was written by T. Griest of LabTek Corporation and comprised 11K lines of Ada. <p> Our re-sults agree with those in <ref> [7] </ref>, however, in that a relatively naive model of the system (such as might be generated by an automated tool) can hinder the method's efficacy. The partial order method allowed larger sizes of most examples to be analyzed.
Reference: [8] <author> P. Godefroid and D. Pirottin. </author> <title> Refining dependencies improves partial-order verification methods. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Computer Aided Verification, 5th International Conference Proceedings, </booktitle> <pages> pages 438-449, </pages> <address> Elounda, Greece, </address> <year> 1993. </year>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions <ref> [8, 13, 21, 22] </ref>, symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> There is growing recognition that software engineering research must focus on designing and carrying out experiments that yield quantifiable and reproducible results [20]. In this paper, we conduct an empirical comparison of three very different methods: a partial order state-space reduction <ref> [8] </ref>, symbolic model checking [3], and inequality necessary conditions [1]. We selected these three methods for several reasons. First, they represent three very different approaches to the state explosion problem. <p> Another, perhaps decisive, reason for selecting these methods was the availability of their implementations. Patrice Godefroid, Didier Pirottin and Pierre Wolper of the University of Liege have implemented a partial order method <ref> [8] </ref> as as an extension to a very fast protocol analyzer called SPIN, which was written by Gerard Holzmann at AT&T Bell Labs [11]. We refer to SPIN with the Partial Order package installed as SPIN+PO. Kenneth McMillan of AT&T Bell Labs has implemented the Symbolic Model Verifier (SMV) [15]. <p> In the example of Figure 1, fa; cg is one such set of transitions enabled in the system's start state. By firing only one of these transitions, we represent only one possible order of the two events, reducing the number of states generated. See <ref> [8] </ref> for further details. 2.2 Symbolic Model Checking A different approach to making deadlock detection more tractable is to use a different representation for M . State-space searches typically generate the states of M explicitly and store them in a hash table.
Reference: [9] <author> D. Helmbold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Each of the n reader tasks and n writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in [1, 7, 12]. Gas Station This example, which models a self-service gas station, originated in <ref> [9] </ref> and has been analyzed in [1, 7, 12, 21]. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. <p> We analyzed versions with one operator task, two pump tasks, and n customer tasks. The interaction among these tasks is much more complex than in the dining philosophers and readers/writers systems. We analyzed two different versions of this example. In the original version (GASQ) from <ref> [1, 9] </ref>, the operator task queues customer requests and must keep track of which customers are waiting for each pump and in what order.
Reference: [10] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: We encountered this problem once in our experiments, as will be discussed in Section 4. 3.3 SPIN Translator Here, we describe the how the communicating FSAs representing a concurrent system were translated into Promela, the input language for SPIN. Promela is a guarded command language like CSP <ref> [10] </ref>, with a C-like syntax. It directly supports communicating processes, thus the translation is relatively straightforward. Each FSA is represented by a process created using the proctype declaration. Each state of the FSA is represented by a statement labeled with the name of the state.
Reference: [11] <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Patrice Godefroid, Didier Pirottin and Pierre Wolper of the University of Liege have implemented a partial order method [8] as as an extension to a very fast protocol analyzer called SPIN, which was written by Gerard Holzmann at AT&T Bell Labs <ref> [11] </ref>. We refer to SPIN with the Partial Order package installed as SPIN+PO. Kenneth McMillan of AT&T Bell Labs has implemented the Symbolic Model Verifier (SMV) [15]. Both of these tools are publicly available, stable, and reasonably robust.
Reference: [12] <author> G. M. Karam and R. J. Buhr. </author> <title> Starvation and critical race analyzers for Ada. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 16(8) </volume> <pages> 829-843, </pages> <year> 1990. </year>
Reference-contexts: These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods. <p> The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 7, 12, 22, 24] </ref>. We model each of the n philosophers and n forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> Each of the n reader tasks and n writer tasks must synchronize with a controller task before accessing and when finished accessing the database. This system has been analyzed in <ref> [1, 7, 12] </ref>. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in [1, 7, 12, 21]. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. <p> This system has been analyzed in [1, 7, 12]. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in <ref> [1, 7, 12, 21] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change.
Reference: [13] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 44-52, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions <ref> [8, 13, 21, 22] </ref>, symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard.
Reference: [14] <author> S. P. Masticola and B. G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 78-87, </pages> <year> 1990. </year>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis <ref> [14] </ref>, and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. In addition, there is not much empirical data comparing the performance of the different techniques. <p> Unlike the previous two methods, however, this kind of method can yield an inconclusive result (of course, for any method, an intractable analysis is inconclusive). Different kinds of necessary conditions have been used for deadlock analysis in Ada tasking. Masticola and Ryder <ref> [14] </ref> used dataflow techniques to search for potential cyclic waits. Here, we consider a more general technique that uses linear inequalities. <p> These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods. <p> In the non-queuing version (GASNQ) from [7], the operator does not enforce a first-come-first-serve order on the customers and must only record the number of customers waiting for each pump in order to activate the pump when any waiting customers remain. Border Defense System (BDS) This example, analyzed in <ref> [7, 14] </ref>, is the communication skeleton of a real Ada tasking program that simulates a border defense system. The original source code was written by T. Griest of LabTek Corporation and comprised 11K lines of Ada.
Reference: [15] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1993. </year>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking <ref> [3, 15] </ref>, abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> We refer to SPIN with the Partial Order package installed as SPIN+PO. Kenneth McMillan of AT&T Bell Labs has implemented the Symbolic Model Verifier (SMV) <ref> [15] </ref>. Both of these tools are publicly available, stable, and reasonably robust. Unfortunately, the Inequality Necessary Condition Analyzer (INCA), like many research tools, has none of these desirable properties, but since we constructed most of the components that are currently in use, this was not a problem. <p> The OBDD for R can be used to check for reachable states with certain properties (e.g., deadlock). In fact, model checking of temporal logic formulas can be performed in this framework without ever constructing an explicit representation of the transition system M [3]. See <ref> [15] </ref> for details. 2.3 Inequality Necessary Conditions Yet another approach to making deadlock detection more tractable is to forgo any representation of the state-space. To verify that a system has a property P , the method generates necessary conditions for the existence of a trace of M violating P . <p> For example, we use an interleaving model of concurrency rather than a simultaneous model (in which multiple actions can occur simultaneously). OBDD-based methods generally perform better on simultaneous models, although this depends on the communication structure of the system <ref> [15] </ref>. Another bias against the OBDD-based method results from the hiding of task variable values within a monolithic task state. Large FSAs are generated by data intensive tasks containing variables that must be encoded into the state of the task for accurate modeling of the task's synchronization behavior.
Reference: [16] <author> T. Murata, B. Shenker, and S. M. Shatz. </author> <title> Detection of Ada static deadlocks using Petri net invariants. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(3) </volume> <pages> 314-326, </pages> <year> 1989. </year>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques <ref> [1, 16] </ref>. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. In addition, there is not much empirical data comparing the performance of the different techniques.
Reference: [17] <author> L. Osterweil and L. Clarke. </author> <title> A proposed testing and analysis research initiative. </title> <journal> IEEE Software, </journal> <pages> pages 89-96, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Concurrent software is increasingly a part of safety critical systems, thus research fl This research was supported by National Science Foundation grant CCR-9308067. into methods and tools for increasing the reliability of such software is badly needed <ref> [17] </ref>. In this paper, we focus on the problem of automatically detecting deadlocks in Ada tasking programs. Static reachability analysis provides a method for detecting possible deadlocks automatically.
Reference: [18] <editor> T. Ostrand and E. Weyuker, editors. </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [19] <author> R. N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta In-formatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results <ref> [19] </ref> indicate that they are all heuristic since deadlock detection in this model is NP-hard. In addition, there is not much empirical data comparing the performance of the different techniques.
Reference: [20] <author> W. Tichy, N. Habermann, and L. </author> <title> Prechelt. </title> <booktitle> Summary of the Dagstuhl workshop on future directions in software engineering. ACM Sigsoft, </booktitle> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Nevertheless, this kind of data is essential for assessing the practical value of the methods and in assisting developers in selecting a method for their particular application. There is growing recognition that software engineering research must focus on designing and carrying out experiments that yield quantifiable and reproducible results <ref> [20] </ref>. In this paper, we conduct an empirical comparison of three very different methods: a partial order state-space reduction [8], symbolic model checking [3], and inequality necessary conditions [1]. We selected these three methods for several reasons. First, they represent three very different approaches to the state explosion problem.
Reference: [21] <author> S. Tu, S. M. Shatz, and T. Murata. </author> <title> Theory and application of Petri net reduction for Ada-tasking deadlock analysis. </title> <type> Technical Report 91-15, </type> <institution> EECS Department, University of Illinois, Chicago, </institution> <year> 1991. </year>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions <ref> [8, 13, 21, 22] </ref>, symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> This system has been analyzed in [1, 7, 12]. Gas Station This example, which models a self-service gas station, originated in [9] and has been analyzed in <ref> [1, 7, 12, 21] </ref>. Customers arrive and pay the operator for gas. The operator activates a pump, at which the customer then pumps gas. When the customer is finished, the pump reports the amount of gas actually pumped to the operator, who then gives the customer her change.
Reference: [22] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Computer-Aided Verification '90, number 3 in DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 25-41, </pages> <address> Providence, RI, 1991. </address> <publisher> American Mathematical Society. </publisher>
Reference-contexts: Its application in practice, however, has been limited by the state explosion problem: the number of states in a concurrent system tends to increase exponentially with the number of tasks. Many techniques have been proposed to combat this explosion, including state-space reductions <ref> [8, 13, 21, 22] </ref>, symbolic model checking [3, 15], abstraction [4], compositional techniques [23], dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 7, 12, 22, 24] </ref>. We model each of the n philosophers and n forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented. <p> 238 22 33 5 8 345 fi 805 245 278 9 12 1365 fi 4015 9035 9219 GASQ 1 4 38 fi 36 1 4 2 5 91 fi 116 5 13 4 7 1003 fi 2232 7773 8267 Table 4: INCA states generated to a quadratic function of n <ref> [22] </ref>. Our re-sults agree with those in [7], however, in that a relatively naive model of the system (such as might be generated by an automated tool) can hinder the method's efficacy. The partial order method allowed larger sizes of most examples to be analyzed.
Reference: [23] <author> W. J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <institution> ACM SIGSOFT, Association for Computing Machinery. </institution>
Reference-contexts: Many techniques have been proposed to combat this explosion, including state-space reductions [8, 13, 21, 22], symbolic model checking [3, 15], abstraction [4], compositional techniques <ref> [23] </ref>, dataflow analysis [14], and integer programming techniques [1, 16]. Most of these methods excel on certain examples, but complexity results [19] indicate that they are all heuristic since deadlock detection in this model is NP-hard. <p> These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods.
Reference: [24] <author> M. Young, R. N. Taylor, K. Forester, and D. Brod-beck. </author> <title> Integrated concurrency analysis in a software development environment. </title> <editor> In R. A. Kemmerer, editor, </editor> <booktitle> Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis and Verification, </booktitle> <pages> pages 200-209, </pages> <year> 1989. </year> <note> Appeared as Software Engineering Notes, 14(8). </note>
Reference-contexts: These examples are described in Section 4 and are intended to represent structures present in concurrent software. Our choice of Ada to specify the concurrent systems reflects a standard in the field of concurrent software analysis <ref> [1, 7, 12, 14, 23, 24] </ref>. To insure a good implementation for the partial order and OBDD-based methods, we used tools written by the developers of those methods. <p> The examples analyzed were: Dining Philosophers Although not a very realistic problem, it does contain a nontrivial deadlock and is probably the most commonly analyzed example <ref> [1, 7, 12, 22, 24] </ref>. We model each of the n philosophers and n forks with a task. These tasks synchronize to model forks being acquired and released. In addition to the standard version (DP), which can deadlock, we also analyzed several versions of the problem where deadlock is prevented.
References-found: 24

