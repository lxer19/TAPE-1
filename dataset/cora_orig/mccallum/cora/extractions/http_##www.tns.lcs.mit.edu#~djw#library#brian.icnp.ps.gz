URL: http://www.tns.lcs.mit.edu/~djw/library/brian.icnp.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: fbrian,jjg@cse.ucsc.edu  
Title: A Comparison of Known Classes of Reliable Multicast Protocols  
Author: Brian Neil Levine and JJ Garcia-Luna-Aceves 
Address: Santa Cruz, CA 95064, USA  
Affiliation: Computer Engineering Department University of California,  
Abstract: We analyze the maximum throughput that the known classes of reliable multicast protocols can attain. A new taxonomy of reliable multicast protocols is introduced based on the premise that the mechanisms used to release data at the source after correct delivery should be decoupled from the mechanisms used to pace the transmission of data and to effect error recovery. Receiver-initiated protocols, which are based entirely on negative acknowledgments (NAKs) sent from the receivers to the sender, have been proposed to avoid the implosion of acknowledgments (ACKs) to the source. However, these protocols are shown to require infinite buffers in order to prevent deadlocks. Two other solutions to the ACK-implosion problem are tree-based protocols and ring-based protocols. The first organize the receivers in a tree and send ACKs along the tree; the latter send ACKs to the sender along a ring of receivers. These two classes of protocols are shown to operate correctly with finite buffers. Following our taxonomy, the maximum attainable throughput by the known classes of reliable multicast protocols is analyzed. It is shown that tree-based protocols constitute the most scalable class of all reliable multicast protocols proposed to date. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ballardie, P. Francis, and J. Crowcroft. </author> <title> Core based trees (CBT): An architecture for scalable inter-domain multicast routing. </title> <booktitle> In Proc. ACM SIGCOMM'93, </booktitle> <pages> pages 8595, </pages> <note> Octo ber 1993. </note>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) <ref> [1] </ref> or Protocol Independent Multicast (PIM) [7]. 2.1. Sender-Initiated Protocols In the past [15, 16], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [1, 7, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver. <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] U + p (E <ref> [M r jM r &gt; 1] </ref> 1) E [Y n ] 2 It follows from the distribution of M r that [15, 16] E [M r jM r &gt; 1] = 1 p E [M r jM r &gt; 2] = 1 p Substituting Equations 22, 31, and 32 into Eq. <p> obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] U + p (E <ref> [M r jM r &gt; 1] </ref> 1) E [Y n ] 2 It follows from the distribution of M r that [15, 16] E [M r jM r &gt; 1] = 1 p E [M r jM r &gt; 2] = 1 p Substituting Equations 22, 31, and 32 into Eq. 30 we have E [Y ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + <p> The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [15, 16] E [X ] fi fi = A [1] 1 p 3 p : (38) Using Equations 38, 13, and 27 we can derive the following s for tree-based and ring-based protocols, respectively: [R] = E [X A ] H1 = <p> receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [15, 16] E [X ] fi fi = A [1] 1 p 3 p : (38) Using Equations 38, 13, and 27 we can derive the following s for tree-based and ring-based protocols, respectively: [R] = E [X A ] H1 = E [X A ] + (E [M ] 1)(2) + B E [M ](1 p)) protocol.
Reference: [2] <author> D. Bertsekas and R. Gallager. </author> <title> Data Networks. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: The proof of correctness for ring-based protocols is given by Chang and Maxemchuk [3]. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager <ref> [2] </ref>). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity. <p> Therefore, the proof follows from the correctness proof of unicast retransmission protocols presented by Bertsekas and Gallager <ref> [2] </ref>. For h &gt; 1, assume the theorem holds for any t such that (1 t &lt; h). We must prove the theorem holds for some t = h. <p> For clarity, we assume a single ack tree rooted at the source in the analysis of tree-based protocols. A selective repeat retransmission strategy is assumed in all the protocol classes since it is well known to be the retransmission strategy with the highest throughput (e.g., see Bert-sekas and Gallager <ref> [2] </ref>), and its requirement of keeping buffers at the receivers is a non-issue given the small of cost memory. Assumptions specific to each protocol are listed in Section 2, and are in the interest of modeling maximum throughput. <p> + (1 p) E [Y p ] + E [Y f ] U + p (E [M r jM r &gt; 1] 1) E [Y n ] 2 It follows from the distribution of M r that [15, 16] E [M r jM r &gt; 1] = 1 p E <ref> [M r jM r &gt; 2] </ref> = 1 p Substituting Equations 22, 31, and 32 into Eq. 30 we have E [Y ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + p E [Y p ] p Assuming all operations have
Reference: [3] <author> J.-M. Chang and N. F. Maxemchuk. </author> <title> Reliable broadcast proto cols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3):251273, </volume> <month> August </month> <year> 1984. </year>
Reference-contexts: Although reliable broadcast protocols have existed for quite some time (e.g., see <ref> [3] </ref>), viable approaches on the provision of reliable multicasting over the Internet are just emerging. The reliable multicast problem facing the future Internet is compounded by its current size and continuing growth, which makes the handling of acknowledgments a major challenge commonly referred to as the acknowledgment (ACK) implosion problem. <p> Ring-Based Protocols Token-ring based protocols for reliable multicast were originally developed to provide support for applications that require an atomic and total ordering of transmissions at all receivers. One of the first proposals for reliable multicasting is the token ring protocol (TRP) <ref> [3] </ref>; its aim was to combine the throughput advantages of NAKs with the reliability of ACKs. The Reliable Multicast Protocol (RMP) [19] discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings. <p> Extensions of the generic tree-based protocols that ensure liveness and safety when nodes can fail are discussed by Levine, Lavo, and Garcia-Luna-Aceves [11]. The proof of correctness for ring-based protocols is given by Chang and Maxemchuk <ref> [3] </ref>. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager [2]). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity.
Reference: [4] <author> D. D. Clark, M. L. Lambert, and L. Zhang. NETBLT: </author> <title> A high throughput transport protocol. </title> <journal> In Proc. ACM SIG COMM. ACM Computer Communication Review, </journal> <pages> pages 353 359, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP [10]) or separate windows (e.g., NETBLT <ref> [4] </ref>). It will become apparent that this decoupling is critical in obtaining an accurate understanding of why reliable unicast-ing and multicasting protocols scale and work correctly with finite memory. Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols.
Reference: [5] <author> S. Deering. </author> <title> Multicast routing in a datagram internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, Palo Alto, California, </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [1, 7, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver.
Reference: [6] <author> S. Deering and D. Cheriton. </author> <title> Multicast routing in datagram inter-networks and extended lans. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2):85110, </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP <ref> [6] </ref>, Core Based Trees (CBT) [1] or Protocol Independent Multicast (PIM) [7]. 2.1. Sender-Initiated Protocols In the past [15, 16], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender.
Reference: [7] <author> S. Deering, D. Estrin, D. Farinacci, V. Jacobson, and others. </author> <title> An architecture for wide-area multicast routing. </title> <booktitle> In ACM SIG COMM'94, </booktitle> <pages> pages 126135, </pages> <year> 1994. </year>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1] or Protocol Independent Multicast (PIM) <ref> [7] </ref>. 2.1. Sender-Initiated Protocols In the past [15, 16], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [1, 7, 5] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver.
Reference: [8] <author> S. Floyd, V. Jacobson, S. McCanne, C.-G. Liu, and L. Zhang. </author> <title> A reliable multicast framework for light-weight sessions and application level framing. </title> <booktitle> In Proc. ACM SIGCOMM'95. ACM Computer Communication Review, </booktitle> <pages> pages 342356, </pages> <note> Au gust 1995. </note>
Reference-contexts: Section 6 provides concluding remarks. 2. A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and mul-ticast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [15, 16, 8] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> However, as suggested by the results reported by Floyd et al. <ref> [8] </ref>, a better approach for pacing a multicast session is for each receiver to set its own timeout. <p> To remedy this problem, previous work on receiver-initiated protocols <ref> [15, 16, 8] </ref> adopts the NAK-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with NAK-avoidance (RINA) protocols have been shown [15, 16] to have improved the performance over the basic receiver-initiated protocol. <p> The generic RINA protocol we have just described constitutes the basis for the operation of the scalable reliable multicasting (SRM) algorithm <ref> [8] </ref>. SRM has been successfully embedded into a internet collaborative whiteboard application called wb. SRM sets timers based on low-rate, periodic, session-messages multi-cast by every receiver.
Reference: [9] <author> H. Holbrook, S. K. Singhal, and D. R. Cheriton. </author> <title> Log-based receiver-reliable multicast for distributed interactive simula tion. </title> <booktitle> In Proc. ACM SIGCOMM'95, </booktitle> <pages> pages 328341, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Another example of a receiver-initiated protocol is the log-based receiver-reliable multicast (LBRM) <ref> [9] </ref>, which uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. Using log servers is feasible only for applications that can afford the servers and leaves many issues unresolved.
Reference: [10] <author> Jon B. Postel, ed. </author> <title> Transmission control protocol. </title> <type> RFC 793, </type> <month> September </month> <year> 1981. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP <ref> [10] </ref>) or separate windows (e.g., NETBLT [4]). It will become apparent that this decoupling is critical in obtaining an accurate understanding of why reliable unicast-ing and multicasting protocols scale and work correctly with finite memory.
Reference: [11] <author> B. N. Levine, D. Lavo, and J. Garcia-Luna-Aceves. </author> <title> The case for concurrent reliable multicasting using shared ack trees. </title> <booktitle> In Proc. ACM Multimedia, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: We assume that there exists some non-zero probability that a packet is received error-free, and that all senders and receivers have finite memory. Extensions of the generic tree-based protocols that ensure liveness and safety when nodes can fail are discussed by Levine, Lavo, and Garcia-Luna-Aceves <ref> [11] </ref>. The proof of correctness for ring-based protocols is given by Chang and Maxemchuk [3]. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager [2]). <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. The results for sender-initiated, receiver-initiated, and tree-NAPP protocols are taken from the analysis presented by these authors <ref> [11] </ref> and Pingali et al. [15, 16]. The rest of this section analyzes tree- and ring-based protocols. 4.1. Tree-Based Protocols We denote this class of protocols simply byH1, and use that superscript in all variables related to the protocol class. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 Sender-initiated [15, 16] O p ln R Receiver-initiated NAK-avoidance [15, 16] O p ln R Ring-based (unicast retrans.) O (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP <ref> [11] </ref> O 1p+p ln B+p 2 (14p) Table 1. Analytical bounds. <p> The graph represents the inverse of Equations 14 and 27, respectively, which are the throughputs for the tree-based and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [15, 16, 11] </ref> for sender-initiated, receiver-initiated, and tree-NAPP protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. The performance of NAK-avoidance protocols, especially tree-NAPP protocols, is clearly superior. <p> The number of tree hops from the receiver to the source is also a factor in how quickly the source can release data from memory in the presence of node failures, as discussed by Levine, Lavo, and Garcia-Luna-Aceves <ref> [11] </ref>. the different classes, relative to processor speed requirements. This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. [15, 16]. <p> for trees is set at 10. 1 (E [M ](4+B (2+B)p)1); (39) R 1 E [T ] 1 (R 1)p (1 + 1) = E [X A ] 3 + (1 p) : (40) The number of supportable receivers derived for sender-initiated, receiver-initiated, and tree-NAPP protocols are shown to be <ref> [15, 16, 11] </ref>, A 1 E [M ](2 + R (1 p)); N1 1 (1 + E [M ] + Rp=(1 p)); N2 1 (2 E [M ]); H2 1 ((4 p) E [M ] 1:9 + 0:1B 2 3 2p 2 : Because the exact value of E [M ]
Reference: [12] <author> J. C. Lin and S. Paul. RMTP: </author> <title> A reliable multicast transport protocol. </title> <booktitle> In IEEE Infocom, </booktitle> <pages> pages 14141425, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: The first application of tree-based protocols to reliable multi-casting over the internet was reported by Paul et al. [14], who compare three basic schemes for reliable point-to-multipoint multicast-ing using hierarchical structures. Their results have been fully de 3 veloped as the reliable multicast transport protocol (RMTP) <ref> [12] </ref>. While our generic protocol sends a HACK for every packet sent by the source, RMTP sends HACKs only periodically, so as to conserve bandwidth. RMTP has been implemented on several platforms and has been used successfully in AT&T's call detail data distribution network [13].
Reference: [13] <author> S. Paul, R. Buskens, K. Sabnani, M. Siddiqui, J. Lin, and S. Bhattacharya. </author> <title> Reliable multicasting. </title> <booktitle> Slides presented at IEEE Computer Communications Workshop, </booktitle> <address> Orcas Island, Washington, </address> <month> Sept </month> <year> 1995. </year>
Reference-contexts: While our generic protocol sends a HACK for every packet sent by the source, RMTP sends HACKs only periodically, so as to conserve bandwidth. RMTP has been implemented on several platforms and has been used successfully in AT&T's call detail data distribution network <ref> [13] </ref>. Tree-based protocols eliminate the ACK implosion problem and free the source from having to know the receiver set, work with finite memory, provide maximum end-to-end delays that are bounded, and operate solely on messages exchanged in local groups (between a node and its children in the ack tree).
Reference: [14] <author> S. Paul, K. K. Sabnani, and D. K. Kristol. </author> <title> Multicast transport protocols for high speed networks. </title> <booktitle> In International Confer ence on Network Protocols, </booktitle> <pages> pages 414, </pages> <year> 1994. </year>
Reference-contexts: Because our analysis focuses on maximum attainable throughput of protocol classes, we will assume that the ack tree perfectly mirrors the multicast routing tree created by the underlying multicast routing protocol. The first application of tree-based protocols to reliable multi-casting over the internet was reported by Paul et al. <ref> [14] </ref>, who compare three basic schemes for reliable point-to-multipoint multicast-ing using hierarchical structures. Their results have been fully de 3 veloped as the reliable multicast transport protocol (RMTP) [12].
Reference: [15] <author> S. Pingali. </author> <title> Protocol and Real-Time Scheduling Issues for Multimedia Applications. </title> <type> PhD thesis, </type> <institution> University of Mas sachusetts Amherst, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: This work was supported in part by the Office of Naval Research under Grant N00014-94-1-0688. The first comparative analysis of sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [15, 16] </ref>. <p> This paper addresses the question of whether a reliable multi-cast protocol can be designed that enjoys all the scaling properties of receiver-initiated protocols, while still being able to operate correctly with finite memory. To address this question, the previous analysis by Pingali et al. <ref> [15, 16] </ref> is extended to consider the maximum throughput of generic ring-based protocols, and two classes of tree-based protocols. These classes are the other three known approaches that can be used to solve the ACK-implosion problem. <p> Section 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy, showing that the type of receiver-initiated protocols proposed to date require infinite memory. Section 4 extends the analysis by Pingali et al. <ref> [15, 16] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local NAK-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Section 6 provides concluding remarks. 2. A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and mul-ticast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [15, 16, 8] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> In the internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1] or Protocol Independent Multicast (PIM) [7]. 2.1. Sender-Initiated Protocols In the past <ref> [15, 16] </ref>, sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. However, this characterization is overly restrictive and does not reflect the way in which several reliable multicast protocols that rely on positive acknowledgments from the receivers to the source have been designed. <p> The two known methods that address this limitation are: (a) using NAKs instead of ACKs, and (b) delegating retransmission responsibility to members of the receiver set by organizing the receivers into a ring or a tree. We discuss both approaches subsequently. 2.2. Receiver-Initiated Protocols Previous work <ref> [15, 16] </ref> characterizes receiver-initiated protocols as placing the responsibility for ensuring reliable packet delivery at each receiver. The critical aspect of these protocols for our taxonomy is that no ACKs are used. <p> To remedy this problem, previous work on receiver-initiated protocols <ref> [15, 16, 8] </ref> adopts the NAK-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with NAK-avoidance (RINA) protocols have been shown [15, 16] to have improved the performance over the basic receiver-initiated protocol. <p> To remedy this problem, previous work on receiver-initiated protocols [15, 16, 8] adopts the NAK-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with NAK-avoidance (RINA) protocols have been shown <ref> [15, 16] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [15, 16]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> Receiver-initiated with NAK-avoidance (RINA) protocols have been shown <ref> [15, 16] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [15, 16]: The sender multicasts all packets and state information, giving priority to retransmissions. Whenever a receiver detects a packet loss, it waits for a random time period and then multicasts a NAK to the sender and all other receivers. <p> Maximum Throughput Analysis To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Section 2 can achieve, we use the same model used by Pingali et al. <ref> [15, 16] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Even with this handicap, our analysis shows that tree-NAPP protocols are better than RINA protocols. Following the notation introduced by Pingali et al. <ref> [15, 16] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively, and H2 on tree-NAPP protocols. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. The results for sender-initiated, receiver-initiated, and tree-NAPP protocols are taken from the analysis presented by these authors [11] and Pingali et al. <ref> [15, 16] </ref>. The rest of this section analyzes tree- and ring-based protocols. 4.1. Tree-Based Protocols We denote this class of protocols simply byH1, and use that superscript in all variables related to the protocol class. <p> expectations, we have E [X ] = E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] H1 What we have derived so far is extremely similar to Equations (1) and (2) in the analysis by Pingali et al. <ref> [15, 16] </ref>. In fact, we can use all of that analysis, with the understanding that B is the size of the receiver subset from which the source collects HACKs. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [15, 16] </ref> O p ln R Receiver-initiated NAK-avoidance [15, 16] O p ln R Ring-based (unicast retrans.) O (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP [11] O 1p+p ln B+p 2 (14p) Table 1. Analytical bounds. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [15, 16] </ref> O p ln R Receiver-initiated NAK-avoidance [15, 16] O p ln R Ring-based (unicast retrans.) O (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP [11] O 1p+p ln B+p 2 (14p) Table 1. Analytical bounds. <p> expected cost at the source node as E [X ] = E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] Because inH1 the number of receivers R = B, the expected num ber of transmissions per packet is <ref> [17, 15, 16] </ref> E [M ] = i=1 B i+1 1 : (5) Pingali et al. [15, 16] show E [M ] is bounded by E [M ] 2 O 1 + 1 p Using Eq. 6, we can bound Eq. 4 as follows E [X ] 2 O B (1 <p> E [M ] E [X p ] + (E [M ] 1) E [X t ] Because inH1 the number of receivers R = B, the expected num ber of transmissions per packet is [17, 15, 16] E [M ] = i=1 B i+1 1 : (5) Pingali et al. <ref> [15, 16] </ref> show E [M ] is bounded by E [M ] 2 O 1 + 1 p Using Eq. 6, we can bound Eq. 4 as follows E [X ] 2 O B (1 + 1 p It then follows that when p is a constant E [X H1 ] <p> Notice that leaf nodes in the H1 protocol will process fewer retransmissions and thus send fewer ac knowledgments than receivers in the A protocol. We can again use an analysis similar to the one by Pingali et al. <ref> [15, 16] </ref> for receivers using a sender-initiated protocol. <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] U + p (E [M r jM r &gt; 1] 1) E [Y n ] 2 It follows from the distribution of M r that <ref> [15, 16] </ref> E [M r jM r &gt; 1] = 1 p E [M r jM r &gt; 2] = 1 p Substituting Equations 22, 31, and 32 into Eq. 30 we have E [Y ] = E [X a ] + (1 p) E [Y p ] + E [Y <p> The graph represents the inverse of Equations 14 and 27, respectively, which are the throughputs for the tree-based and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [15, 16, 11] </ref> for sender-initiated, receiver-initiated, and tree-NAPP protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. The performance of NAK-avoidance protocols, especially tree-NAPP protocols, is clearly superior. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [15, 16] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [15, 16] </ref> E [X ] fi fi = A [1] 1 p 3 p : (38) Using Equations 38, 13, and 27 we can derive the following s for tree-based and ring-based protocols, respectively: [R] = E [X A ] H1 = E [X A ] + (E [M ] 1)(2) <p> for trees is set at 10. 1 (E [M ](4+B (2+B)p)1); (39) R 1 E [T ] 1 (R 1)p (1 + 1) = E [X A ] 3 + (1 p) : (40) The number of supportable receivers derived for sender-initiated, receiver-initiated, and tree-NAPP protocols are shown to be <ref> [15, 16, 11] </ref>, A 1 E [M ](2 + R (1 p)); N1 1 (1 + E [M ] + Rp=(1 p)); N2 1 (2 E [M ]); H2 1 ((4 p) E [M ] 1:9 + 0:1B 2 3 2p 2 : Because the exact value of E [M ] <p> (1 + E [M ] + Rp=(1 p)); N2 1 (2 E [M ]); H2 1 ((4 p) E [M ] 1:9 + 0:1B 2 3 2p 2 : Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation <ref> [15, 16] </ref>, E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: [16] <author> S. Pingali, D. Towsley, and J. F. Kurose. </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast pro tocols. </title> <journal> In Performance Evaluation Review, </journal> <volume> volume 22, </volume> <pages> pages 221230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This work was supported in part by the Office of Naval Research under Grant N00014-94-1-0688. The first comparative analysis of sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [15, 16] </ref>. <p> This paper addresses the question of whether a reliable multi-cast protocol can be designed that enjoys all the scaling properties of receiver-initiated protocols, while still being able to operate correctly with finite memory. To address this question, the previous analysis by Pingali et al. <ref> [15, 16] </ref> is extended to consider the maximum throughput of generic ring-based protocols, and two classes of tree-based protocols. These classes are the other three known approaches that can be used to solve the ACK-implosion problem. <p> Section 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy, showing that the type of receiver-initiated protocols proposed to date require infinite memory. Section 4 extends the analysis by Pingali et al. <ref> [15, 16] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local NAK-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Section 6 provides concluding remarks. 2. A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and mul-ticast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [15, 16, 8] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> In the internet, these trees will be built using such protocols as DVMRP [6], Core Based Trees (CBT) [1] or Protocol Independent Multicast (PIM) [7]. 2.1. Sender-Initiated Protocols In the past <ref> [15, 16] </ref>, sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. However, this characterization is overly restrictive and does not reflect the way in which several reliable multicast protocols that rely on positive acknowledgments from the receivers to the source have been designed. <p> The two known methods that address this limitation are: (a) using NAKs instead of ACKs, and (b) delegating retransmission responsibility to members of the receiver set by organizing the receivers into a ring or a tree. We discuss both approaches subsequently. 2.2. Receiver-Initiated Protocols Previous work <ref> [15, 16] </ref> characterizes receiver-initiated protocols as placing the responsibility for ensuring reliable packet delivery at each receiver. The critical aspect of these protocols for our taxonomy is that no ACKs are used. <p> To remedy this problem, previous work on receiver-initiated protocols <ref> [15, 16, 8] </ref> adopts the NAK-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with NAK-avoidance (RINA) protocols have been shown [15, 16] to have improved the performance over the basic receiver-initiated protocol. <p> To remedy this problem, previous work on receiver-initiated protocols [15, 16, 8] adopts the NAK-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with NAK-avoidance (RINA) protocols have been shown <ref> [15, 16] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [15, 16]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> Receiver-initiated with NAK-avoidance (RINA) protocols have been shown <ref> [15, 16] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [15, 16]: The sender multicasts all packets and state information, giving priority to retransmissions. Whenever a receiver detects a packet loss, it waits for a random time period and then multicasts a NAK to the sender and all other receivers. <p> Maximum Throughput Analysis To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Section 2 can achieve, we use the same model used by Pingali et al. <ref> [15, 16] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Even with this handicap, our analysis shows that tree-NAPP protocols are better than RINA protocols. Following the notation introduced by Pingali et al. <ref> [15, 16] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively, and H2 on tree-NAPP protocols. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. The results for sender-initiated, receiver-initiated, and tree-NAPP protocols are taken from the analysis presented by these authors [11] and Pingali et al. <ref> [15, 16] </ref>. The rest of this section analyzes tree- and ring-based protocols. 4.1. Tree-Based Protocols We denote this class of protocols simply byH1, and use that superscript in all variables related to the protocol class. <p> expectations, we have E [X ] = E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] H1 What we have derived so far is extremely similar to Equations (1) and (2) in the analysis by Pingali et al. <ref> [15, 16] </ref>. In fact, we can use all of that analysis, with the understanding that B is the size of the receiver subset from which the source collects HACKs. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [15, 16] </ref> O p ln R Receiver-initiated NAK-avoidance [15, 16] O p ln R Ring-based (unicast retrans.) O (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP [11] O 1p+p ln B+p 2 (14p) Table 1. Analytical bounds. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [15, 16] </ref> O p ln R Receiver-initiated NAK-avoidance [15, 16] O p ln R Ring-based (unicast retrans.) O (R1)p Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP [11] O 1p+p ln B+p 2 (14p) Table 1. Analytical bounds. <p> expected cost at the source node as E [X ] = E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] Because inH1 the number of receivers R = B, the expected num ber of transmissions per packet is <ref> [17, 15, 16] </ref> E [M ] = i=1 B i+1 1 : (5) Pingali et al. [15, 16] show E [M ] is bounded by E [M ] 2 O 1 + 1 p Using Eq. 6, we can bound Eq. 4 as follows E [X ] 2 O B (1 <p> E [M ] E [X p ] + (E [M ] 1) E [X t ] Because inH1 the number of receivers R = B, the expected num ber of transmissions per packet is [17, 15, 16] E [M ] = i=1 B i+1 1 : (5) Pingali et al. <ref> [15, 16] </ref> show E [M ] is bounded by E [M ] 2 O 1 + 1 p Using Eq. 6, we can bound Eq. 4 as follows E [X ] 2 O B (1 + 1 p It then follows that when p is a constant E [X H1 ] <p> Notice that leaf nodes in the H1 protocol will process fewer retransmissions and thus send fewer ac knowledgments than receivers in the A protocol. We can again use an analysis similar to the one by Pingali et al. <ref> [15, 16] </ref> for receivers using a sender-initiated protocol. <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] U + p (E [M r jM r &gt; 1] 1) E [Y n ] 2 It follows from the distribution of M r that <ref> [15, 16] </ref> E [M r jM r &gt; 1] = 1 p E [M r jM r &gt; 2] = 1 p Substituting Equations 22, 31, and 32 into Eq. 30 we have E [Y ] = E [X a ] + (1 p) E [Y p ] + E [Y <p> The graph represents the inverse of Equations 14 and 27, respectively, which are the throughputs for the tree-based and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [15, 16, 11] </ref> for sender-initiated, receiver-initiated, and tree-NAPP protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. The performance of NAK-avoidance protocols, especially tree-NAPP protocols, is clearly superior. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [15, 16] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [15, 16] </ref> E [X ] fi fi = A [1] 1 p 3 p : (38) Using Equations 38, 13, and 27 we can derive the following s for tree-based and ring-based protocols, respectively: [R] = E [X A ] H1 = E [X A ] + (E [M ] 1)(2) <p> for trees is set at 10. 1 (E [M ](4+B (2+B)p)1); (39) R 1 E [T ] 1 (R 1)p (1 + 1) = E [X A ] 3 + (1 p) : (40) The number of supportable receivers derived for sender-initiated, receiver-initiated, and tree-NAPP protocols are shown to be <ref> [15, 16, 11] </ref>, A 1 E [M ](2 + R (1 p)); N1 1 (1 + E [M ] + Rp=(1 p)); N2 1 (2 E [M ]); H2 1 ((4 p) E [M ] 1:9 + 0:1B 2 3 2p 2 : Because the exact value of E [M ] <p> (1 + E [M ] + Rp=(1 p)); N2 1 (2 E [M ]); H2 1 ((4 p) E [M ] 1:9 + 0:1B 2 3 2p 2 : Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation <ref> [15, 16] </ref>, E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: [17] <author> S. Ramakrishnan and B. N. Jain. </author> <title> A negative acknowledgment with periodic polling protocol for multicast over lan. </title> <booktitle> In IEEE Infocom, </booktitle> <pages> pages 502511, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: A protocol similar to NETBLT is the Negative Acknowledgments with Periodic Polling (NAPP) protocol <ref> [17] </ref>. This protocol is a broadcast protocol for LANs. Like NETBLT, NAPP groups together large partitions of the data that are periodically ACKed, while lost packets within the partition are NAKed. NAPP advances the cw by NAKs and periodically advances the mw by ACKs. <p> We define a tree-NAPP protocol as a tree-based protocol that uses NAK-avoidance and periodic polling <ref> [17] </ref> in the local groups. NAKS alone are not sufficient to guarantee reliability with finite memory, so receivers send a periodic positive (hierarchical) acknowledgment to their parents to advance the cw. <p> expected cost at the source node as E [X ] = E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] Because inH1 the number of receivers R = B, the expected num ber of transmissions per packet is <ref> [17, 15, 16] </ref> E [M ] = i=1 B i+1 1 : (5) Pingali et al. [15, 16] show E [M ] is bounded by E [M ] 2 O 1 + 1 p Using Eq. 6, we can bound Eq. 4 as follows E [X ] 2 O B (1 <p> TRP and RMP limit their throughput by requiring retransmissions to be unicast. It would be possible to reduce the cost bound to O (ln R), assuming p to be a constant, if the NAK-avoidance techniques presented by Ramakrishnan and Jain <ref> [17] </ref> were used. Our analysis shows that trees are the answer to the scalability problem for reliable multicasting. Only tree-based and tree-NAPP classes have a throughput that is constant with respect to the number of receivers even when the probability of packet loss is not negligible.
Reference: [18] <author> W. T. Strayer, B. Dempsey, and A. Weaver. XTP: </author> <title> The Xpress Transfer Protocol. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: The use of periodic polling limits NAPP to LANs, because the source can still suffer from an ACK-implosion problem even if ACKs occur less often. Other sender-initiated protocols, like the Xpress Transfer Protocol (XTP) <ref> [18] </ref>, were created for use on an internet, but still suffer from the ACK-implosion problem. The main limitation of sender-initiated protocols is not that ACKs are used, but the need for the source to process all of the ACKs and to know the receiver set.
Reference: [19] <author> B. Whetten, S. Kaplan, and T. Montgomery. </author> <title> A high performance totally ordered multicast protocol. </title> <note> Available from research.ivv.nasa.gov by ftp /pub/doc/RMP/RMP dagstuhl.ps, </note> <month> August </month> <year> 1994. </year>
Reference-contexts: One of the first proposals for reliable multicasting is the token ring protocol (TRP) [3]; its aim was to combine the throughput advantages of NAKs with the reliability of ACKs. The Reliable Multicast Protocol (RMP) <ref> [19] </ref> discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings. Therefore, RMP has the same throughput bounds as TRP.
Reference: [20] <author> R. Yavatkar, J. Griffioen, and M. Sudan. </author> <title> A reliable dissem ination protocol for interactive collaborative applications. </title> <booktitle> In Proc. ACM Multimedia, </booktitle> <pages> pages 33344, </pages> <year> 1995. </year> <month> 10 </month>
Reference-contexts: Note that messages sent for the setting of timers needed for NAK-avoidance are limited to the local group, which is scalable. The tree-based mul-ticast transport protocol (TMTP) <ref> [20] </ref> is the only specification of a tree-NAPP protocol to date. 2.5. Ring-Based Protocols Token-ring based protocols for reliable multicast were originally developed to provide support for applications that require an atomic and total ordering of transmissions at all receivers.
References-found: 20

