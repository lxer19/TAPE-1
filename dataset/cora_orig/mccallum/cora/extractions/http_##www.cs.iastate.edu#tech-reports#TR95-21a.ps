URL: http://www.cs.iastate.edu/tech-reports/TR95-21a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Polymorphic Type-Checking in Scheme  
Author: Steven L. Jenkins and Gary T. Leavens 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: May 1995, Revised May 1996  
Pubnum: TR#91-21a  
Abstract: Keywords: abstract data type, type inference, supertype abstraction. 1995 CR Categories: D.3.3 [Programming Languages] Language Constructs - abstract data types, data types and structures. D.3.4 [Programming Languages] Processors - preprocessors. F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs - type structure. Submitted for publication. (c) Steven L. Jenkins and Gary T. Leavens 1995. Copies may be made for research and scholarly purposes, but not for direct commercial advantage. All rights reserved. Some funding for the project was provided by NSF grant CCR 9593168. 
Abstract-found: 1
Intro-found: 1
Reference: [AbS85] <author> Harold Abelson, Gerald Sussman and Julie Sussman, </author> <title> Structure and Interpretation of Computer Programs, 13th edition, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: To demonstrate the applicability of the system, we ran it on the code from the first ten chapters of [SpF89] (SAP) have been checked, as well as sample student code from exercises. Also, code from the first chapter of <ref> [AbS85] </ref> (SICP) was examined. The procedure for checking this body of code was to type-check each file containing code, and examine the output. <p> For example, a version of member? , has type (A_nv (B_nv . C_nv) =&gt; bool) in Lindig's system, while it has type (-&gt; (T (list T)) boolean) in ours. In his paper, Lindig provides some results from type-checking code from <ref> [AbS85] </ref>, and his system appears quite practical. Soft Scheme [WrC93] infers types, and, instead of producing error messages on untypable expressions, inserts runtime checks. The system covers all of R4RS Scheme, is very poweful, and, according to the authors, has been shown to perform well.
Reference: [Car87] <author> Luca Cardelli, </author> <title> Basic Polymorphic Typechecking, </title> <booktitle> Science of Computer Programming, </booktitle> <month> 8,2 (April </month> <year> 1987). </year>
Reference-contexts: Most of the notation follows Cardelli's presentation of type rules for his subset of ML <ref> [Car87] </ref>. For type environments, the expression x: t is the binding of variable x to type t . If A and B are type environments, then AB is A extended by B. <p> TYPE INFERENCE ALGORITHM The algorithm used to infer types is essentially the j algorithm from Milner's original paper on type inference [Mil78], <ref> [Car87] </ref>. In the following subsections we discuss extensions to the standard algorithm. 3.1 And-types The system treats and-types by doing an ordered search over the possible types of a procedure. The order of the rules is very important.
Reference: [CR91] <editor> William Clinger and Jonathan Rees (eds.), </editor> <title> Revised 4 Report on the Algorithmic Language Scheme, </title> <year> 1991. </year>
Reference-contexts: TYPE SYSTEM This section covers the type system used in this paper. The first subsection discusses the subset of Scheme that the type inference system operates over, and the second subsection presents the type inference rules. 2.1. Domain of the type inference system This system covers all of R4RS <ref> [CR91] </ref> except the following: declarations of procedures with variable arity all but the last expression in a begin expression must have a type of void the second and third arguments to an if expression must have the same type the first argument to an if expression must have type boolean mutation:
Reference: [Cur90] <author> Pavel Curtis, </author> <title> Constrained Quantification in Polymorphic Type Analysis, </title> <note> Xerox PARC Technical Report CSL-90-1, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: Related work In this section we attempt to place our type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT <ref> [Cur90] </ref>, STYLE [Lin93], Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. The work of Curtis [Cur90] provides an example of a typesystem for a <p> We will take a brief look at PLEAT <ref> [Cur90] </ref>, STYLE [Lin93], Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. The work of Curtis [Cur90] provides an example of a typesystem for a small, functional language, PLEAT, much in the style of Scheme. However, the types produced by the system are far too complex for beginning students to handle.
Reference: [DH94] <author> Hsianlin Dzeng and Christopher T. Haynes, </author> <title> Type Reconstruction for Variable-Arity Procedures, </title> <note> 1994, to be published. </note>
Reference-contexts: The work of Dzeng and Haynes <ref> [DH94] </ref> could be used to infer the types of such procedures. 1 This treatment of make-vector described here is not entirely satisfactory. The type system could be extended with a better treatment of polymorphic mutable data as in [WrC93]. <p> The work of Olin Shivers [Sh88] might be one direction to pursue along these lines. Other future work involves extending the system to be more practical. One extension is to infer the types of procedures with variable numbers of arguments (following <ref> [DH94] </ref>). Another is to allow users to infer (or declare in .def files) the types of procedures (like cons ) that require and-polymorphism. The procedure make-vector should be handled in some fashion, perhaps as in SoftScheme [WrC93]. Some facility for dealing with ADT type generators and recursive types is needed.
Reference: [Fa90] <author> M. Fagan, </author> <title> Soft Typing: An Approach to Type Checking for Dynamically Typed Languages, </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: Instead it uses facilities for defining record structures. These, however, are more suited for more advanced programmers, not students learning about ADTs. Its handling of recursive types and intersection types is based on the work of Fagan <ref> [Fa90] </ref> and is richer, yet more complicated, than ours. The complexity of the types presented to the user are comparable with those of PLEAT. 10 5. FUTURE DIRECTIONS Future work for this system involves a treatment of union types and ad hoc polymorphism.
Reference: [Hin69] <author> R. Hindley, </author> <title> The principal type scheme of an object in combinatory logic, </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> Volume 146, </volume> <month> December </month> <year> 1969, </year> <pages> pp. 29-60. </pages>
Reference: [Lin93] <author> Christian Lindig, </author> <title> STYLE: A Practical Type Checker for Scheme, </title> <publisher> Technische Universitt Braunschweig, Informatik-Bericht Nr. </publisher> <pages> 93-10, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: 1. INTRODUCTION This paper presents a type inference system for Scheme that is designed to aid students in an introductory course. While other type-inference systems have been developed for Scheme; for example, STYLE <ref> [Lin93] </ref> and Soft Scheme [WrC93], the complexity of the types output by these systems is often daunting for beginners. Thus a primary goal for the system is to infer types that are simple enough for students to understand. <p> Related work In this section we attempt to place our type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT [Cur90], STYLE <ref> [Lin93] </ref>, Soft-Scheme [WrC93], and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. <p> The other major problem with SPS is that it has no facilities for ADTs along the lines of SAP [SpF89]. A type system that is very close to ours is Christian Lindig's STYLE <ref> [Lin93] </ref>. It offers a type system that operates over all of Scheme, as well as provides a solid type system. Like PLEAT, a major drawback of STYLE is its complex types. For example, a version of member? , has type (A_nv (B_nv .
Reference: [MP87] <author> John Mitchell and Gordon Plotkin, </author> <title> Abstract Types have Existential Type, </title> <booktitle> Conference Record of the 12th Annual ACM Symposium on Principles of Programming Languages, ACM, </booktitle> <month> January </month> <year> 1985, </year> <pages> 37-51. </pages>
Reference-contexts: In general, the types inferred for the procedures in the code file must unify with the given types, after the abstract type is replaced by the representation type <ref> [MP87] </ref>. In the current system, every .def file must contain exactly one defrep expression. However, this restriction could be relaxed in the future if desired. 7 4. DISCUSSION This section discusses how effective the system is in inferring types for code.
Reference: [Mil78] <author> Robin Milner, </author> <title> A Theory of Type Polymorphism in Programming, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 (1978), </volume> <pages> 348-375. </pages>
Reference-contexts: TYPE INFERENCE ALGORITHM The algorithm used to infer types is essentially the j algorithm from Milner's original paper on type inference <ref> [Mil78] </ref>, [Car87]. In the following subsections we discuss extensions to the standard algorithm. 3.1 And-types The system treats and-types by doing an ordered search over the possible types of a procedure. The order of the rules is very important.
Reference: [Sh88] <author> Olin Shivers, </author> <title> Control Flow Analysis in Scheme, </title> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> 164-174. </pages>
Reference-contexts: One direction is to follow SoftScheme by inserting runtime checks, but it would seem more effective for teaching to have the system propagate the knowledge of type tests (such as number? ) to the contexts controlled by such type tests. The work of Olin Shivers <ref> [Sh88] </ref> might be one direction to pursue along these lines. Other future work involves extending the system to be more practical. One extension is to infer the types of procedures with variable numbers of arguments (following [DH94]).
Reference: [SpF89] <author> George Springer and Daniel P. Friedman, </author> <title> Scheme and the Art of Programming, </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1989. </year>
Reference-contexts: Thus a primary goal for the system is to infer types that are simple enough for students to understand. The textbook used in the course, Scheme and the Art of Programming <ref> [SpF89] </ref> also introduces the concept of abstract data types (ADTs), but implements them directly in Scheme. Hence the use of auxillary declarations as done in STYLE or Soft Scheme would be unacceptable. <p> To see how these goals have been achieved, we will look at the ADT ratl, i.e., rationals. This is the first ADT mentioned in Scheme and the Art of Programming <ref> [SpF89] </ref>. (define makeratl (lambda (numr denr) (if (zero? denr) (error "The denominator cannot be zero.") (list numr denr))))) (define numr (lambda (ratl) (car ratl))) (define denr (lambda (ratl) (cadr ratl))) The types of these procedures can be inferred, and the types will be as follows: makeratl: ( D (number number) (list <p> In most cases the type inference system correctly catches type errors, and correctly inferred the types of syntactically correct procedures. To demonstrate the applicability of the system, we ran it on the code from the first ten chapters of <ref> [SpF89] </ref> (SAP) have been checked, as well as sample student code from exercises. Also, code from the first chapter of [AbS85] (SICP) was examined. The procedure for checking this body of code was to type-check each file containing code, and examine the output. <p> Chapter 2 of <ref> [SpF89] </ref> produced 4 errors: three of these were problems with procedures taking advantage of Scheme's using any non#f value to mean true. The only other problem was with a procedure that performed ad hoc polymorphism, and, thus, is beyond the scope of our system. <p> The code for that procedure is shown below. (define describe (lambda (s) (cond ((null? s) (quote '())) ((number? s) s) ((symbol? s) (list 'quote s)) ((pair? s) (list 'cons (describe (car s)) (describe (cdr s)))) (else s)))) Chapter 3 of <ref> [SpF89] </ref> produced no errors. Even though much of the procedures deal with the ADT ratls, all the procedures built on top of the ADT successfully checked since we included a .def file. Almost all of the problems in chapters 4 and 5 of [SpF89] were caused by procedures that operate over <p> (cdr s)))) (else s)))) Chapter 3 of <ref> [SpF89] </ref> produced no errors. Even though much of the procedures deal with the ADT ratls, all the procedures built on top of the ADT successfully checked since we included a .def file. Almost all of the problems in chapters 4 and 5 of [SpF89] were caused by procedures that operate over trees. <p> In chapter 6 of <ref> [SpF89] </ref>, all of the problems were caused by interactive procedures. <p> Chapter 7 of <ref> [SpF89] </ref> had problems with trees, also, and the system's inability to infer types for procedures with variable arity. 9 Chapter 9 of [SpF89] produced errors due to the use of make-vector with only one argument. This produces vectors of unusable types. <p> Chapter 7 of <ref> [SpF89] </ref> had problems with trees, also, and the system's inability to infer types for procedures with variable arity. 9 Chapter 9 of [SpF89] produced errors due to the use of make-vector with only one argument. This produces vectors of unusable types. From this data it is clear that a large portion of Scheme code used in introductory classes can be successfully type-checked using our system. <p> The only other option would be to teach the students the syntax of SPS, in addition to the regular syntax of Scheme. The other major problem with SPS is that it has no facilities for ADTs along the lines of SAP <ref> [SpF89] </ref>. A type system that is very close to ours is Christian Lindig's STYLE [Lin93]. It offers a type system that operates over all of Scheme, as well as provides a solid type system. Like PLEAT, a major drawback of STYLE is its complex types. <p> For our purposes it is unusable. The system is quite large, and requires a great amount of overhead to run. Aside from the practical considerations, however, the only problem with the system is that it doesn't handle ADTs in the same manner that <ref> [SpF89] </ref> does. Instead it uses facilities for defining record structures. These, however, are more suited for more advanced programmers, not students learning about ADTs. Its handling of recursive types and intersection types is based on the work of Fagan [Fa90] and is richer, yet more complicated, than ours.
Reference: [Wa89] <author> Mitchell Wand, </author> <title> Semantic Prototyping System (SPS) Reference Manual, Version 1.4 (Chez Scheme), </title> <institution> Northeastern University, </institution> <year> 1989. </year>
Reference: [WrC93] <author> Andrew Wright and Robert Cartwright, </author> <title> A Practical Soft Type System for Scheme, </title> <institution> Rice University Technical Report, TR93-218, </institution> <month> December 6, </month> <year> 1993. </year> <month> 12 </month>
Reference-contexts: 1. INTRODUCTION This paper presents a type inference system for Scheme that is designed to aid students in an introductory course. While other type-inference systems have been developed for Scheme; for example, STYLE [Lin93] and Soft Scheme <ref> [WrC93] </ref>, the complexity of the types output by these systems is often daunting for beginners. Thus a primary goal for the system is to infer types that are simple enough for students to understand. <p> The work of Dzeng and Haynes [DH94] could be used to infer the types of such procedures. 1 This treatment of make-vector described here is not entirely satisfactory. The type system could be extended with a better treatment of polymorphic mutable data as in <ref> [WrC93] </ref>. As it is, a vector of datum is practically worthless. 6 3.4.5. ADTs A major innovation of this project is handling ADTs. <p> Related work In this section we attempt to place our type inference sytem in context with other type systems for Scheme, as well as other functional languages. We will take a brief look at PLEAT [Cur90], STYLE [Lin93], Soft-Scheme <ref> [WrC93] </ref>, and SPS [Wan89], with the emphasis in the section being on STYLE and Soft-Scheme. We will look at three main areas: domain of the type systems, representation of types, and complexity of code. <p> For example, a version of member? , has type (A_nv (B_nv . C_nv) =&gt; bool) in Lindig's system, while it has type (-&gt; (T (list T)) boolean) in ours. In his paper, Lindig provides some results from type-checking code from [AbS85], and his system appears quite practical. Soft Scheme <ref> [WrC93] </ref> infers types, and, instead of producing error messages on untypable expressions, inserts runtime checks. The system covers all of R4RS Scheme, is very poweful, and, according to the authors, has been shown to perform well. For our purposes it is unusable. <p> Another is to allow users to infer (or declare in .def files) the types of procedures (like cons ) that require and-polymorphism. The procedure make-vector should be handled in some fashion, perhaps as in SoftScheme <ref> [WrC93] </ref>. Some facility for dealing with ADT type generators and recursive types is needed. Finally, some treatment of mutation is needed. The problem is that mutable storage cannot contain polymorphic values (if the soundness of the system is to be preserved).
References-found: 14

