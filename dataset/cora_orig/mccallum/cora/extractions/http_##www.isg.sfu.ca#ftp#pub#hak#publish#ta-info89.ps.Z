URL: http://www.isg.sfu.ca/ftp/pub/hak/publish/ta-info89.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: LIFE, a Natural Language for Natural Language  
Author: Hassan At-Kaci Patrick Lincoln 
Date: 1989  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Aho, V.A., Hopcroft, J.E., and Ullman, J.D., </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address> <year> 1974. </year>
Reference-contexts: Nodes which are shared in the graph correspond to tagged subterms. Such graphs are quite like finite-state automata with -sorted nodes (Moore machines) and where the transitions are attribute symbols. In fact, the -term unification algorithm is an immediate adaptation of the algorithm deciding equivalence of finite-state automata <ref> [1] </ref>. This algorithm merges nodes which are reached by equal transition paths into coreference classes, starting from the roots and following all reachable strings of attributes from them. Each merged class is assigned the type symbol in which is the GLB of the types of all nodes in the class.
Reference: 2. <author> At-Kaci, H., </author> <title> A Lattice-Theoretic Approach to Computation Based on a Calculus of Partially-Ordered Type Structures. </title> <type> Ph.D. Thesis. </type> <institution> Computer and Information Science, University of Pennsylvania. </institution> <address> Philadelphia, PA. </address> <year> 1984. </year>
Reference-contexts: Finally, the most original part of LIFE is the structure-oriented component which consists of a calculus of type structures|the -calculus <ref> [2, 4] </ref>|and rigorously accounts for some of the (multiple) inheritance convenience typically found in so called object-oriented languages. <p> The inconsistent type ? (the least element in ) may result which makes the whole unification fail. Incidentally, if least upper bounds (LUBs) are defined as well in , so are they for -terms. Thus, a lattice structure can be extended from to -terms <ref> [2, 4] </ref>. For example, for these two -terms, their LUB (denoting their most specific generalization) is: person (advisor ) faculty (secretary ) employee, assistant ) person); roommate ) person)): Although it may turn out interesting in other contexts, we shall not use this generalization operation here. <p> These are no longer graphs but hypergraphs. Of course, one can always expand out all nested disjunctions in such an expression, reducing it to a canonical form consisting of a set of non-disjunctive -terms. The process is described in <ref> [2] </ref>, and is akin to converting a non-deterministic finite-state automaton to its deterministic form, or a first-order logic formula to its disjunctive normal form. However, more for pragmatic efficiency than just notational convenience, it is both desirable to keep -terms in their non-canonical form. <p> L : list) ) L: append ([HjT : list]; L : list) ) [Hjappend (T; L)]: Higher-order definition and currying are also naturally allowed in FOOL; e.g., map ([]; ) ) []: map ([HjT]; F) ) [F (H)jmap (T; F)]: Thus, the expression map ([1; 2; 3]; +1) evaluates to <ref> [2; 3; 4] </ref>. The -term subsumption ordering replaces the first-order matching ordering on constructor terms. In particular, disjunctive patterns may be used.
Reference: 3. <author> At-Kaci, H. and Nasr, R., </author> <title> "LOGIN: A Logic Programming Language with Built-in Inheritance." </title> <journal> Journal of Logic Programming 3(3), </journal> <pages> pp. 187-215. </pages> <year> 1986. </year>
Reference-contexts: attempting to tailor programming languages, typically logic programming, for linguistic analysis. (As has been pointed out in [12], order-sorted logic is quite convenient for parsing.) Among those known to us CIL [17, 18] is one that comes close to LIFE's spirit in that it combines partial features of Log In <ref> [3] </ref> (see Section 2.2.2) with delayed evaluation handled with an explicit freeze meta-predicate borrowed from Prolog-II [11]. CIL's constructs are called Partially Specified Terms (PST's) which are exactly the same as feature matrices used in Unification Grammars [23], and are a strict particular case of Log In's -terms. <p> Intuitively, as expounded in <ref> [3] </ref>, the -calculus is an attempt at obtaining a convenience for representing record-like data structures in logic and functional programming more adequate than first-order terms without loss of the well-appreciated instantiation ordering and unification operation. <p> Since it is beyond the informal scope of this paper, we shall abstain from giving a complete formal definition of -term syntax. (Such may be found elsewhere <ref> [4, 3] </ref>.) Nevertheless, it is important to distinguish among the three kinds of symbols which participate in a -term expression. Thus we assume given a signature of type constructor symbols, a set A of access function symbols (also called attribute symbols), and a set R of reference tag symbols. <p> tag renaming) yields the term: W : workstudy (advisor ) f 1 (secretary ) Z : workstudy (representative ) Z); assistant ) W ); roommate ) Z; helper ) w 1 (spouse ) W )). 1989 LIFE, a Natural Language 11 A detailed unification algorithm for -terms is given in <ref> [3] </ref>. This algorithm is an adaptation of an efficient unification algorithm based on a rooted labeled (directed) graph representation of -terms, such as is illustrated in Figure 2. The nodes are labeled with type symbols from , and the arcs are labeled with attribute symbols. <p> Thus the -term syntax may be enriched with disjunction denoting type union. 3 See [7] for a description of an efficient method for computing such GLB's. 1989 12 Hassan At-Kaci and Patrick Lincoln For a more complete formal treatment of disjunctive -terms, the reader is referred to [4] and to <ref> [3] </ref>. It will suffice to indicate here that a disjunctive -term is a set of incomparable -terms, written ft 1 ; . . . ; t n g where the t i 's are basic -terms. A basic -term is one which is non-disjunctive. <p> Next, X becomes the identity function, thus releasing the residuation and instantiating Ans to 1. Finally, the equation sq (1) = 1 is immediately verified, yielding success. 2.2.2 -Calculus: Log In Log In is simply Prolog where first-order constructor terms have been replaced by -terms, with type definitions <ref> [3] </ref>. Its operational semantics is the immediate adaptation of that of Prolog's SLD resolution described in Section 2.1.2. <p> L : list) ) L: append ([HjT : list]; L : list) ) [Hjappend (T; L)]: Higher-order definition and currying are also naturally allowed in FOOL; e.g., map ([]; ) ) []: map ([HjT]; F) ) [F (H)jmap (T; F)]: Thus, the expression map ([1; 2; 3]; +1) evaluates to <ref> [2; 3; 4] </ref>. The -term subsumption ordering replaces the first-order matching ordering on constructor terms. In particular, disjunctive patterns may be used.
Reference: 4. <author> At-Kaci, H., </author> <title> "An Algebraic Semantics Approach to the Effective Resolution of Type Equations." </title> <journal> Journal of Theoretical Computer Science 45, </journal> <pages> pp. 293-351. </pages> <year> 1986. </year>
Reference-contexts: Finally, the most original part of LIFE is the structure-oriented component which consists of a calculus of type structures|the -calculus <ref> [2, 4] </ref>|and rigorously accounts for some of the (multiple) inheritance convenience typically found in so called object-oriented languages. <p> Since it is beyond the informal scope of this paper, we shall abstain from giving a complete formal definition of -term syntax. (Such may be found elsewhere <ref> [4, 3] </ref>.) Nevertheless, it is important to distinguish among the three kinds of symbols which participate in a -term expression. Thus we assume given a signature of type constructor symbols, a set A of access function symbols (also called attribute symbols), and a set R of reference tag symbols. <p> The inconsistent type ? (the least element in ) may result which makes the whole unification fail. Incidentally, if least upper bounds (LUBs) are defined as well in , so are they for -terms. Thus, a lattice structure can be extended from to -terms <ref> [2, 4] </ref>. For example, for these two -terms, their LUB (denoting their most specific generalization) is: person (advisor ) faculty (secretary ) employee, assistant ) person); roommate ) person)): Although it may turn out interesting in other contexts, we shall not use this generalization operation here. <p> adequate interpretation. 3 Thus the -term syntax may be enriched with disjunction denoting type union. 3 See [7] for a description of an efficient method for computing such GLB's. 1989 12 Hassan At-Kaci and Patrick Lincoln For a more complete formal treatment of disjunctive -terms, the reader is referred to <ref> [4] </ref> and to [3]. It will suffice to indicate here that a disjunctive -term is a set of incomparable -terms, written ft 1 ; . . . ; t n g where the t i 's are basic -terms. A basic -term is one which is non-disjunctive. <p> L : list) ) L: append ([HjT : list]; L : list) ) [Hjappend (T; L)]: Higher-order definition and currying are also naturally allowed in FOOL; e.g., map ([]; ) ) []: map ([HjT]; F) ) [F (H)jmap (T; F)]: Thus, the expression map ([1; 2; 3]; +1) evaluates to <ref> [2; 3; 4] </ref>. The -term subsumption ordering replaces the first-order matching ordering on constructor terms. In particular, disjunctive patterns may be used.
Reference: 5. <author> At-Kaci, H., Lincoln, P. and Nasr, R., </author> <title> "Le Fun: Logic, equations, and Functions." </title> <booktitle> Proceedings of the ACM Symposium on Logic Programming, </booktitle> <pages> pp. 17-23. </pages> <address> San Francisco, </address> <month> September </month> <year> 1987. </year> <title> 1989 LIFE, a Natural Language 29 </title>
Reference-contexts: That is, we describe the edges of the triangle of LIFE in informal style, illustrating key points with examples. 2.2.1 -Calculus: Le Fun We now introduce a relational and functional programming language called Le Fun <ref> [5, 6] </ref> where first-order terms are generalized by the inclusion of applicative expressions as defined by Landin [15] (atoms, abstractions, and applications) augmented with first-order constructor terms. Thus, interpreted functional expressions may participate as bona fide arguments in logical expressions.
Reference: 6. <author> At-Kaci, H. and Nasr, R., </author> <title> "Integrating Logic and Functional Programming." </title> <booktitle> Lisp and Symbolic Computation 2, </booktitle> <pages> pp. 51-89. </pages> <year> 1989. </year>
Reference-contexts: On the programming language side, there is a growing multitude dealing with integrating logic and functional programming. However, none of them worries about bringing in frame-like unification or inheritance, and few have higher-order functions. We refer the reader to <ref> [6] </ref> for a survey of prominent approaches. LIFE stands apart as the only formalism we know which encompasses such a breadth of functionality. <p> That is, we describe the edges of the triangle of LIFE in informal style, illustrating key points with examples. 2.2.1 -Calculus: Le Fun We now introduce a relational and functional programming language called Le Fun <ref> [5, 6] </ref> where first-order terms are generalized by the inclusion of applicative expressions as defined by Landin [15] (atoms, abstractions, and applications) augmented with first-order constructor terms. Thus, interpreted functional expressions may participate as bona fide arguments in logical expressions.
Reference: 7. <author> At-Kaci, H., Boyer, R., Lincoln, P., and Nasr, R., </author> <title> "Efficient Implementation of Lattice Operations." </title> <journal> ACM Transactions on Programming Languages and Systems 11(1), </journal> <pages> pp. 115-146. </pages> <month> January, </month> <year> 1989. </year>
Reference-contexts: However, the set of their maximal common lower bounds offers the most general choice of candidates. Clearly, the disjunctive type fjohn; maryg is an adequate interpretation. 3 Thus the -term syntax may be enriched with disjunction denoting type union. 3 See <ref> [7] </ref> for a description of an efficient method for computing such GLB's. 1989 12 Hassan At-Kaci and Patrick Lincoln For a more complete formal treatment of disjunctive -terms, the reader is referred to [4] and to [3].
Reference: 8. <author> At-Kaci, H., </author> <title> The WAM: A (Real) Tutorial. PRL Research Report No. </title> <type> 5, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, Rueil-Malmaison, France. </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: chart parser" what is implemented is a parser that could perform best first search if we had the empirical evidence from English text about which forms are truly most often successful.) It is our belief that once a LIFE compiler is implemented with, in particular, indexing facilities as in Prolog's <ref> [8] </ref>, the parser will perform in much more reasonable, even competitive time. In conclusion, with this paper, we hope to have achieved our goal to illustrate the unique adequacy of LIFE's functionality for the specific purpose of Natural Language Processing.
Reference: 9. <author> At-Kaci, H., and Podelski, A., </author> <title> The Meaning of LIFE. </title> <type> Forthcoming PRL Research Report, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, Rueil-Malmaison, France. </institution> <year> 1990. </year>
Reference-contexts: This document consists essentially of two parts: an informal overview of LIFE (Section 2) and a particular experiment applying LIFE to linguistic analysis meant as an illustration of its adequacy (Section 3). For a formal semantics of LIFE, the reader is referred to <ref> [9] </ref> where all aspects of LIFE are given a rigorous mathematical meaning. 1989 2 Hassan At-Kaci and Patrick Lincoln 2 The Chemistry of LIFE LIFE is a trinity.
Reference: 10. <author> Burstall, R., MacQueen, D., and Sanella, D., </author> <title> Hope: an Experimental Applicative Language. </title> <type> Technical Report No. </type> <institution> CSR-62-80, Department of Computer Science, University of Edinburgh, Edinburgh, UK. </institution> <month> May </month> <year> 1980. </year>
Reference-contexts: The function-oriented component of LIFE is directly derived from functional programming languages standing on foundations in the -calculus like HOPE <ref> [10] </ref>, SASL [26], ML [13], or Miranda [27]. The convenience offered by this style of programming is essentially one in which expressions of any order are first-class objects and computation is determinate.
Reference: 11. <author> Colmerauer, A., et al, Prolog-II: </author> <title> Reference Manual and Theoretical Model. </title> <institution> Groupe d'Intelligence Artificielle, Faculte des Sciences d'Aix-Luminy. </institution> <address> Marseille, France. </address> <year> 1982. </year>
Reference-contexts: in [12], order-sorted logic is quite convenient for parsing.) Among those known to us CIL [17, 18] is one that comes close to LIFE's spirit in that it combines partial features of Log In [3] (see Section 2.2.2) with delayed evaluation handled with an explicit freeze meta-predicate borrowed from Prolog-II <ref> [11] </ref>. CIL's constructs are called Partially Specified Terms (PST's) which are exactly the same as feature matrices used in Unification Grammars [23], and are a strict particular case of Log In's -terms.
Reference: 12. <author> Frisch, A., </author> <title> Parsing with Restricted Quantification. </title> <institution> Cognitive Science Research Paper No. CSRP-043, School of Social Sciences. University of Sussex, </institution> <address> Brighton, UK. </address> <month> February </month> <year> 1985. </year>
Reference-contexts: LIFE happens to reconcile all these approaches, therefore offering a unique experimental tool for the computational linguist. To be sure, there are other efforts attempting to tailor programming languages, typically logic programming, for linguistic analysis. (As has been pointed out in <ref> [12] </ref>, order-sorted logic is quite convenient for parsing.) Among those known to us CIL [17, 18] is one that comes close to LIFE's spirit in that it combines partial features of Log In [3] (see Section 2.2.2) with delayed evaluation handled with an explicit freeze meta-predicate borrowed from Prolog-II [11].
Reference: 13. <author> Gordon, M., Milner, A., Wadsworth, C., </author> <title> Edinburgh LCF. </title> <publisher> LNCS 78. Springer Verlag, </publisher> <address> Berlin, FRG. </address> <year> 1979. </year>
Reference-contexts: The function-oriented component of LIFE is directly derived from functional programming languages standing on foundations in the -calculus like HOPE [10], SASL [26], ML <ref> [13] </ref>, or Miranda [27]. The convenience offered by this style of programming is essentially one in which expressions of any order are first-class objects and computation is determinate.
Reference: 14. <author> Lambek, J., </author> <title> "The Mathematics of Sentence Structure," </title> <journal> American Mathematical Monthly 65, </journal> <pages> pp. 154-169. </pages> <year> 1958. </year>
Reference: 15. <author> Landin, P.J., </author> <title> "The Mechanical Evaluation of Expressions." </title> <journal> Computer Journal 6(4), </journal> <pages> pp. 308-320. </pages> <year> 1963. </year>
Reference-contexts: we describe the edges of the triangle of LIFE in informal style, illustrating key points with examples. 2.2.1 -Calculus: Le Fun We now introduce a relational and functional programming language called Le Fun [5, 6] where first-order terms are generalized by the inclusion of applicative expressions as defined by Landin <ref> [15] </ref> (atoms, abstractions, and applications) augmented with first-order constructor terms. Thus, interpreted functional expressions may participate as bona fide arguments in logical expressions.
Reference: 16. <author> Meyer, R., and At-Kaci, H., </author> <title> Wild Life, a User Manual. PRL Technical Note No. </title> <type> 1, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, Rueil-Malmaison, France. </institution> <month> August </month> <year> 1990. </year>
Reference: 17. <author> Mukai, K., </author> <title> "Anadic Tuples in Prolog," </title> <note> Report draft from lecture presented at the Workshop on Foundations of Deductive Databases and Logic Programming organized by J. </note> <editor> Minker. </editor> <address> Washington, DC. </address> <month> August </month> <year> 1986. </year>
Reference-contexts: To be sure, there are other efforts attempting to tailor programming languages, typically logic programming, for linguistic analysis. (As has been pointed out in [12], order-sorted logic is quite convenient for parsing.) Among those known to us CIL <ref> [17, 18] </ref> is one that comes close to LIFE's spirit in that it combines partial features of Log In [3] (see Section 2.2.2) with delayed evaluation handled with an explicit freeze meta-predicate borrowed from Prolog-II [11].
Reference: 18. <author> Mukai, K., </author> <title> "A System of Logic Programming for Linguistic Analysis," </title> <booktitle> Report draft from lecture presented at the Workshop on Semantic Issues on Human and Computer Languages organized by J. </booktitle> <editor> Barwise, D. Israel, and S. Peters. Half-Moon Bay, </editor> <address> CA. </address> <month> March </month> <year> 1987. </year>
Reference-contexts: To be sure, there are other efforts attempting to tailor programming languages, typically logic programming, for linguistic analysis. (As has been pointed out in [12], order-sorted logic is quite convenient for parsing.) Among those known to us CIL <ref> [17, 18] </ref> is one that comes close to LIFE's spirit in that it combines partial features of Log In [3] (see Section 2.2.2) with delayed evaluation handled with an explicit freeze meta-predicate borrowed from Prolog-II [11].
Reference: 19. <author> Partee, B. (Ed.), </author> <title> Montague Grammars. </title> <publisher> Academic Press, </publisher> <address> New York, NY. </address> <year> 1976. </year> <note> 1989 30 Hassan At-Kaci and Patrick Lincoln </note>
Reference: 20. <author> Pereira, F., and Warren, </author> <title> D.H.D.,"Definite Clause Grammars for Language Analysis|A Survey of the Formalism and a Comparison with Augmented Transition Networks," </title> <booktitle> Artificial Intelligence 13, </booktitle> <pages> pp. 231-278. </pages> <year> 1980. </year>
Reference-contexts: Thus, LIFE emerged as the synthesis of three computational atomic components which we refer to as function-oriented, relation-oriented, and structure-oriented, each being an operational rendition of a well-defined underlying model. Formalisms for linguistic analysis have emerged, based on Horn clause logic <ref> [20] </ref>, frame unification [23], -calculus [25], each proving itself adequate for particular aspects of Natural Language Processing (NLP). LIFE happens to reconcile all these approaches, therefore offering a unique experimental tool for the computational linguist.
Reference: 21. <editor> Peyton Jones, S.L., </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall. </publisher> <year> 1987. </year>
Reference-contexts: However, this is not strictly required as LL (1) parsing or even implementation of recursion with Y are necessary, especially when efficiency rather than simplicity of implementation is sought <ref> [21] </ref>. Thus, we shall dispense from such explicit rec mentions, (mutual) recursion being systematically implicit when and only when free occurring constants appear in definitions (as in the first of the two foregoing definitions). <p> Not only are pattern-directed definitions more perspicuous, they also lead to more efficient code generation. An efficient implementation will avoid the conditional by using the argument pattern as index key as well as using pattern-matching to bind the structure variables to their homologues in the actual argument patterns <ref> [21] </ref>. Clearly, when it comes to programming convenience, linear lists as a universal symbolic construction facility can become quickly tedious and cumbersome. More flexible data structures such as first-order constructor terms can be used with the convenience and efficiency of pattern-directed definitions.
Reference: 22. <author> Smolka, G., and At-Kaci, H., </author> <title> "Inheritance Hierarchies: Semantics and Unification." </title> <journal> Journal of Symbolic Computation 7, </journal> <pages> pp. 343-370. </pages> <year> 1989. </year>
Reference-contexts: Inheritance of attributes of all supertypes to a type is done in accordance to -term subsumption and unification. Unification in the context of such an inheritance hierarchy amounts to solving equations in an order-sorted algebra as explained in <ref> [22] </ref>, to which the reader is referred for a full formal account. For example, given a signature for the specification of linear lists = flist; cons; nilg 4 with nil &lt; list and cons &lt; list, it is yet possible to specify that cons has an attribute tail ) list.
Reference: 23. <author> Shieber, S., </author> <title> An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes 4, Center for the Study of Language and Information, </title> <institution> Stanford University. </institution> <year> 1986. </year>
Reference-contexts: Thus, LIFE emerged as the synthesis of three computational atomic components which we refer to as function-oriented, relation-oriented, and structure-oriented, each being an operational rendition of a well-defined underlying model. Formalisms for linguistic analysis have emerged, based on Horn clause logic [20], frame unification <ref> [23] </ref>, -calculus [25], each proving itself adequate for particular aspects of Natural Language Processing (NLP). LIFE happens to reconcile all these approaches, therefore offering a unique experimental tool for the computational linguist. <p> CIL's constructs are called Partially Specified Terms (PST's) which are exactly the same as feature matrices used in Unification Grammars <ref> [23] </ref>, and are a strict particular case of Log In's -terms. To our knowledge PST's do not accommodate disjunctive constructs, nor do they use a type hierarchy, let alone type definitions.
Reference: 24. <author> Sterling, L., and Shapiro, E., </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1986. </year>
Reference-contexts: The convenience offered by this style of programming is essentially one in which expressions of any order are first-class objects and computation is determinate. The relation-oriented component of LIFE is essentially one inspired by the Prolog <ref> [24] </ref> language, taking its origin in theorem-proving as Horn clause calculus with a specific and well-defined control strategy|SLD-resolution.
Reference: 25. <author> Thomason, R. (Ed.), </author> <title> Formal Philosophy, Selected Papers of Richard Montague. </title> <publisher> Yale University Press, </publisher> <address> New Haven, CT. </address> <year> 1973. </year>
Reference-contexts: Thus, LIFE emerged as the synthesis of three computational atomic components which we refer to as function-oriented, relation-oriented, and structure-oriented, each being an operational rendition of a well-defined underlying model. Formalisms for linguistic analysis have emerged, based on Horn clause logic [20], frame unification [23], -calculus <ref> [25] </ref>, each proving itself adequate for particular aspects of Natural Language Processing (NLP). LIFE happens to reconcile all these approaches, therefore offering a unique experimental tool for the computational linguist.
Reference: 26. <author> Turner, D., </author> <title> "Recursion Equations as a Programming Language," </title> <editor> in J. Darlington et al (Eds.), </editor> <booktitle> Functional Programming and its Applications, </booktitle> <pages> pp. 1-28. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK. </address> <year> 1982. </year>
Reference-contexts: The function-oriented component of LIFE is directly derived from functional programming languages standing on foundations in the -calculus like HOPE [10], SASL <ref> [26] </ref>, ML [13], or Miranda [27]. The convenience offered by this style of programming is essentially one in which expressions of any order are first-class objects and computation is determinate.
Reference: 27. <author> Turner, D., </author> <title> "Miranda|Non-Strict Functional Language with Polymorphic Types," </title> <editor> in J.P. Jouannaud (Ed.), </editor> <booktitle> Proceedings on the Conference on Functional Programming Languages and Computer Architecture (Nancy, France). </booktitle> <volume> LNCS 201, </volume> <pages> pp. 1-16. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, FRG. </address> <year> 1985. </year>
Reference-contexts: The function-oriented component of LIFE is directly derived from functional programming languages standing on foundations in the -calculus like HOPE [10], SASL [26], ML [13], or Miranda <ref> [27] </ref>. The convenience offered by this style of programming is essentially one in which expressions of any order are first-class objects and computation is determinate.
Reference: 28. <author> Wittenburg, K., </author> <title> Natural Language Parsing with Combinatory Categorial Grammar in a Graph-Unification-Based Formalism. </title> <type> Ph.D. Thesis, </type> <institution> Linguistics, University of Texas. Austin, TX. </institution> <year> 1986. 1989 </year>
Reference-contexts: As we have demonstrated, a unification-based grammar could easily be encoded in LIFE thanks to its native structured type calculus. Higher-order functions being also a basic feature in LIFE, they ought to come as handy to formulate a Categorial Unification Grammars such as proposed by Wittenburg <ref> [28] </ref>. We are in the process of implementing a Categorial Grammar in LIFE. The lexical category functions on which these grammars are based, with their attendant type raising and function composition, can be easily encoded as higher-order functions in LIFE. In Categorial Grammars, each word has an associated function. <p> The search strategy using such a grammar could be encoded, as above, using the nondeterministic mechanism of logic programming. In the near future we hope to build a Categorial Unification Grammar following Wittenburg's approach closely <ref> [28] </ref>. 4.3 Limitations of Current System The current system was constructed in less than two weeks for demonstration purposes. Although improvements have been made, the scope of this project has been limited by time more than technical difficulties. Thus, the user must type perfect English.
References-found: 28

