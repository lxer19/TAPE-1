URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW251.ps.gz
Refering-URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/CW1997.html
Root-URL: 
Title: To Parse or Not To Parse  
Author: Wim Vanhoof Bern Martens 
Affiliation: Department of Computing Science, K.U.Leuven  
Date: 251, June 1997  
Pubnum: Report CW  
Abstract: Writing meta interpreters is a well-known technique to enhance the expressive power of logic programs. However, the resulting interpretation overhead considerably slows down program execution. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program, thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques. In this paper, we reconsider the problem of specialising the vanilla meta interpreter through fully automatic and completely general methods. In particular, we study how the homeomorphic embedding relation guides specialisation of the interpreter. We focus on the so-called parsing problem, i.e. in essence removing meta-interpretation overhead, in particular parsing conjunctive goals, and demonstrate that further control refinements are necessary to properly deal with it. In particular, we modify local control on the basis of information imported from the global level. Subsequently, we use this technique to specialise an extended meta interpreter, dealing with compositions of logic programs, and obtain satisfying results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barklund. </author> <title> Metaprogramming in logic. </title> <editor> In A. Kent and J.G. Williams, editors, </editor> <booktitle> Encyclopedia of Computer Science and Technology. </booktitle> <publisher> Marcell Dekker, Inc., </publisher> <address> New York. </address> <note> To Appear. </note>
Reference-contexts: 1 Introduction Writing meta interpreters is a well-known technique to enhance the expressive power of logic programs (see e.g. <ref> [36, 1, 18] </ref>). However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead.
Reference: [2] <author> K. Benkerimi and P. M. Hill. </author> <title> Supporting transformations for the partial evaluation of logic programs. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3(5) </volume> <pages> 469-486, </pages> <year> 1993. </year>
Reference: [3] <author> R. Bol. </author> <title> Loop checking in partial deduction. </title> <journal> Journal of Logic Programming, </journal> 16(1&2):25-46, 1993. 
Reference: [4] <author> A. F. Bowers and C. A. Gurr. </author> <title> Towards fast and declarative meta-programming. </title> <editor> In K. R. Apt and F. Turini, editors, </editor> <booktitle> Meta-logics and Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction Writing meta interpreters is a well-known technique to enhance the expressive power of logic programs (see e.g. [36, 1, 18]). However, the resulting interpretation overhead considerably slows down program execution <ref> [4] </ref>. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. <p> A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task <ref> [4, 28] </ref>. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20].
Reference: [5] <author> A. Brogi and S. Contiero. </author> <title> Godel as a meta language for composing logic programs. </title> <editor> In A. Turini, editor, </editor> <booktitle> Proceedings Meta'94. </booktitle> <institution> University of Pisa, </institution> <year> 1994. </year>
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions <ref> [8, 9, 5, 7] </ref>. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> Single object programs, then, are represented by statement (P; H; B) facts, where P is the program name, H the clause head and B the clause body. See <ref> [8, 9, 5, 7] </ref> for an elaborated discussion of these composition operators. In the following, D will denote the extended vanilla interpreter. The combination of D and a fully instantiated composition of object programs e will be denoted by D e .
Reference: [6] <author> A. Brogi and S. Contiero. </author> <title> A program specialiser for meta-level compositions of logic programs. </title> <type> Technical Report TR-96-20, </type> <institution> Dipartimento di Informatica, Universita di Pisa, Pisa, Italy, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Unfolding some of the parsing calls, however, seems appropriate. This leaves us with several open issues, to which we will briefly return in Section 5. 4 Specialising An Extended Vanilla Meta Interpreter In <ref> [7, 6] </ref>, Brogi and Contiero discuss specialisation of the following extended vanilla meta inter preter, adapted here to our notation: demo (E; true) demo (E; (A; B)) demo (E; A); demo (E; B): demo (E; H ) clause (E; H; B); demo (E; B): clause (union (E 1 ; E 2
Reference: [7] <author> A. Brogi and S. Contiero. </author> <title> Specialising meta-level compositions of logic programs. </title> <editor> In J. Gal-lagher, editor, </editor> <booktitle> Proceedings LOPSTR'96, </booktitle> <address> Stockholm, 1997. </address> <publisher> Springer-Verlag, LNCS 1207. </publisher>
Reference-contexts: Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper <ref> [7] </ref>, Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions [8, 9, 5, 7]. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions <ref> [8, 9, 5, 7] </ref>. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> The resulting control strategy, while remaining fully general, leads to excellent specialisation of vanilla like meta programs. Parsing is always specialised, but appropriately, as we will show not always completely removed. Finally, as a concrete application, we subject the extended vanilla meta interpreter of <ref> [7] </ref> to our techniques, showing we get at least the same degree of specialisation as in [7], and often even more. The outline of the paper is as follows. <p> Parsing is always specialised, but appropriately, as we will show not always completely removed. Finally, as a concrete application, we subject the extended vanilla meta interpreter of <ref> [7] </ref> to our techniques, showing we get at least the same degree of specialisation as in [7], and often even more. The outline of the paper is as follows. In Section 2, we briefly recapitulate some aspects of the automatic partial deduction strategy we use, largely referring to the literature for further and more general information. <p> Section 3 considers specialisation of the vanilla meta interpreter and constitutes the main body of this paper. Subsequently, in Section 4, specialisation of the program composition interpreter in <ref> [7] </ref> is addressed. We conclude with a discussion of our results and the ensuing plans for further research in Section 5. <p> Unfolding some of the parsing calls, however, seems appropriate. This leaves us with several open issues, to which we will briefly return in Section 5. 4 Specialising An Extended Vanilla Meta Interpreter In <ref> [7, 6] </ref>, Brogi and Contiero discuss specialisation of the following extended vanilla meta inter preter, adapted here to our notation: demo (E; true) demo (E; (A; B)) demo (E; A); demo (E; B): demo (E; H ) clause (E; H; B); demo (E; B): clause (union (E 1 ; E 2 <p> Single object programs, then, are represented by statement (P; H; B) facts, where P is the program name, H the clause head and B the clause body. See <ref> [8, 9, 5, 7] </ref> for an elaborated discussion of these composition operators. In the following, D will denote the extended vanilla interpreter. The combination of D and a fully instantiated composition of object programs e will be denoted by D e . <p> See [8, 9, 5, 7] for an elaborated discussion of these composition operators. In the following, D will denote the extended vanilla interpreter. The combination of D and a fully instantiated composition of object programs e will be denoted by D e . In <ref> [7] </ref>, a specific program specialisation technique is developed in order to deal with these program compositions. A thorough discussion of the specialisation method is outside the scope of 7 this extended abstract, but it is noteworthy that the method relies heavily on knowledge about D. <p> In case no enc operation is present in e, specialisation of D e will lead to a program where all manipulations of e are removed. <ref> [7] </ref> also notice that this program can be transformed into an equivalent object program. No indication, however, is given how to automate this transformation, possibly also relying on information about D. In case e contains an enc operation, the method of [7] removes all explicit handling of e, but the resulting <p> a program where all manipulations of e are removed. <ref> [7] </ref> also notice that this program can be transformed into an equivalent object program. No indication, however, is given how to automate this transformation, possibly also relying on information about D. In case e contains an enc operation, the method of [7] removes all explicit handling of e, but the resulting program is, in essence, a set of different solve vanilla meta interpreters, each with an associated pclause database. Thus no overhead due to the interpretation of a single program is removed.
Reference: [8] <author> A. Brogi, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Composition operators for logic theories. </title> <editor> In J. W. Lloyd, editor, </editor> <booktitle> Proceedings of the Esprit Symposium on Computational Logic, </booktitle> <pages> pages 117-134. </pages> <publisher> Springer-Verlag, </publisher> <month> November </month> <year> 1990. </year>
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions <ref> [8, 9, 5, 7] </ref>. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> Single object programs, then, are represented by statement (P; H; B) facts, where P is the program name, H the clause head and B the clause body. See <ref> [8, 9, 5, 7] </ref> for an elaborated discussion of these composition operators. In the following, D will denote the extended vanilla interpreter. The combination of D and a fully instantiated composition of object programs e will be denoted by D e .
Reference: [9] <author> A. Brogi, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Meta for modularising logic programming. </title> <editor> In A. Pettorossi, editor, </editor> <booktitle> Proceedings Meta'92, </booktitle> <pages> pages 105-119. </pages> <publisher> Springer-Verlag, LNCS 649, </publisher> <year> 1992. </year>
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions <ref> [8, 9, 5, 7] </ref>. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> Single object programs, then, are represented by statement (P; H; B) facts, where P is the program name, H the clause head and B the clause body. See <ref> [8, 9, 5, 7] </ref> for an elaborated discussion of these composition operators. In the following, D will denote the extended vanilla interpreter. The combination of D and a fully instantiated composition of object programs e will be denoted by D e .
Reference: [10] <author> M. Bruynooghe, D. De Schreye, and B. Martens. </author> <title> A general criterion for avoiding infinite unfolding during partial deduction. </title> <journal> New Generation Computing, </journal> <volume> 11(1) </volume> <pages> 47-79, </pages> <year> 1992. </year>
Reference: [11] <author> D. De Schreye, M. Leuschel, and B. Martens. </author> <title> Tutorial on program specialisation (abstract). </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proceedings ILPS'95, </booktitle> <pages> pages 615-616, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: On the other hand, research on partial deduction of logic programs meanwhile resulted in fully automatic and completely general specialisation techniques, not requiring any specific a priori knowledge about the kind of programs to be specialised, nor any help from the programmer (e.g. <ref> [14, 11, 24] </ref>). fl Supported by a specialisation grant of the Flemish Institute for the Promotion of Scientific-Technological Research in Industry (IWT), Belgium. y Postdoctoral Fellow of the K.U.Leuven Research Council, Belgium. 1 In this paper, we reconsider the problem of specialising the vanilla meta interpreter through such fully automatic methods. <p> We conclude with a discussion of our results and the ensuing plans for further research in Section 5. Throughout this paper, we only consider definite logic programs. 2 Automatic Partial Deduction We assume the reader is familiar with the basic correctness [27] and control <ref> [14, 11, 25] </ref> notions of automatic (on-line) partial deduction (see also Appendix A). In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper.
Reference: [12] <author> J. Gallagher. </author> <title> Transforming logic programs by specialising interpreters. </title> <booktitle> In Proceedings ECAI'86, </booktitle> <pages> pages 109-122, </pages> <year> 1986. </year>
Reference-contexts: However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program <ref> [12, 37, 32] </ref>, thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20].
Reference: [13] <author> J. Gallagher. </author> <title> A system for specialising logic programs. </title> <type> Technical Report TR-91-32, </type> <institution> Computer Science Department, University of Bristol, U.K., </institution> <month> November </month> <year> 1991. </year>
Reference: [14] <author> J. Gallagher. </author> <title> Specialisation of logic programs: A tutorial. </title> <booktitle> In Proceedings PEPM'93, ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 88-98, </pages> <address> Copenhagen, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: On the other hand, research on partial deduction of logic programs meanwhile resulted in fully automatic and completely general specialisation techniques, not requiring any specific a priori knowledge about the kind of programs to be specialised, nor any help from the programmer (e.g. <ref> [14, 11, 24] </ref>). fl Supported by a specialisation grant of the Flemish Institute for the Promotion of Scientific-Technological Research in Industry (IWT), Belgium. y Postdoctoral Fellow of the K.U.Leuven Research Council, Belgium. 1 In this paper, we reconsider the problem of specialising the vanilla meta interpreter through such fully automatic methods. <p> We conclude with a discussion of our results and the ensuing plans for further research in Section 5. Throughout this paper, we only consider definite logic programs. 2 Automatic Partial Deduction We assume the reader is familiar with the basic correctness [27] and control <ref> [14, 11, 25] </ref> notions of automatic (on-line) partial deduction (see also Appendix A). In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper.
Reference: [15] <author> J. Gallagher and M. Bruynooghe. </author> <title> Some low-level source transformations for logic programs. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings Meta'90, </booktitle> <pages> pages 229-244, </pages> <address> Leuven, </address> <month> April </month> <year> 1990. </year>
Reference: [16] <author> J. Gallagher and M. Bruynooghe. </author> <title> The derivation of an algorithm for program specialisation. </title> <journal> New Generation Computing, </journal> 9(3&4):305-333, 1991. <volume> 10 </volume>
Reference: [17] <author> R. Gluck, J. Jtrgensen, B. Martens, and M. H. Strensen. </author> <title> Controlling conjunctive partial deduction of definite logic programs. </title> <editor> In H. Kuchen and S.D. Swierstra, editors, </editor> <booktitle> Proceedings PLILP'96, </booktitle> <pages> pages 152-166, </pages> <address> Aachen, Germany, </address> <month> September </month> <year> 1996. </year> <note> Springer-Verlag, LNCS 1140. </note>
Reference-contexts: In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper. Experiments were conducted using the ecce automatic partial deduction system [26]. 2.1 Local control As a starting point for local control, we use the one proposed in Section 4.2 of <ref> [17] </ref>, partially imported by [34, 24]. The following definitions are taken from that paper. Definition 2.1 Given an SLD-tree t . <p> Independently of whether it is selectable according to definition 2.3, often we will denote the selected atom (under any unfolding rule) in a goal G by s (G), leaving the unfolding rule implicit. An important observation is that U fi always terminates <ref> [17] </ref>. For a program P and a goal G, t U (P; G) will denote the SLD-tree built by unfolding rule U for G in P , often simply written as t U (G) or t G . <p> On the other hand, we demonstrated that keeping the object atoms together in one solve atom can cause more specialisation to be achieved. In the near future, we will investigate to what extent similar effects can be obtained through conjunctive partial deduction <ref> [23, 17] </ref>. Keeping the object atoms together in one solve atom often results in what we called specialised parsing.
Reference: [18] <author> P. M. Hill and J. Gallagher. </author> <title> Meta-programming in logic programming. </title> <type> Technical Report 94.22, </type> <institution> School of Computer Studies, University of Leeds, U.K., </institution> <month> August </month> <year> 1994. </year> <booktitle> To appear in Volume V of the Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <publisher> Oxford University Press. </publisher>
Reference-contexts: 1 Introduction Writing meta interpreters is a well-known technique to enhance the expressive power of logic programs (see e.g. <ref> [36, 1, 18] </ref>). However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead.
Reference: [19] <author> P. M. Hill and J. W. Lloyd. </author> <title> Analysis of meta-programs. </title> <editor> In H. D. Abramson and M. H. Rogers, editors, </editor> <booktitle> Proceedings Meta'88, </booktitle> <pages> pages 23-51. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter <ref> [35, 19, 36, 29] </ref>, extended in order to deal with program compositions [8, 9, 5, 7]. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> We will in particular concentrate on the so called "parsing problem" [20, 28]: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter <ref> [35, 19, 36, 29] </ref>. Definition 3.1 The vanilla meta interpreter V : (1) solve (true) (2) solve ((A; B)) solve (A); solve (B): (3) solve (H ) pclause (H; B); solve (B): 3 As usual, an object program will be represented as a database of pclause-facts.
Reference: [20] <author> A. Lakhotia and L. Sterling. </author> <title> How to control unfolding when specializing interpreters. </title> <journal> New Generation Computing, </journal> <volume> 8(1) </volume> <pages> 61-70, </pages> <year> 1990. </year>
Reference-contexts: Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques <ref> [20] </ref>. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter [35, 19, 36, 29], extended in order to deal with program compositions [8, 9, 5, 7]. <p> In particular, we study how the homeomorphic embedding relation guides specialisation of the interpreter. We focus on the so-called parsing problem, i.e. in essence removing meta-interpretation overhead, in particular parsing conjunctive goals <ref> [20, 28] </ref>, and demonstrate that further control refinements are necessary to properly deal with it. In particular, we modify local control on the basis of information imported from the global level. The resulting control strategy, while remaining fully general, leads to excellent specialisation of vanilla like meta programs. <p> G using the techniques as introduced above. 3 Behaviour of U fi When Unfolding Meta Interpreters In this section, we investigate automatic partial deduction of non-ground, vanilla meta programs, using the general technique presented in Section 2. We will in particular concentrate on the so called "parsing problem" <ref> [20, 28] </ref>: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter [35, 19, 36, 29]. <p> In <ref> [20] </ref>, it was noticed that always unfolding parsing calls seems a good idea, although no indication was given how to incorporate this idea in a general, automatic partial deduction technique. <p> P , goal G = solve (p (X)) with p a predicate in P , using the global control techniques described in Section 2 and the enhanced unfolding rule U + fi , P D (V P ; G) is meta structure free. 3.3 Specialised Parsing Opposite to observations in <ref> [20] </ref>, where it is argued that (parsing) calls should always be unfolded, U fi as well as U + fi will often stop unfolding at such calls: solve (C) where C is a meta representation of an object level conjunction. <p> Always simply imposing the latter gives rise to unwanted clause predicates in the global tree. The effect of always unfolding parsing calls, as described in <ref> [20] </ref>, can be achieved by altering U + fi : instead of only using U ext on atoms that would cause a generalisation when brought in the global tree, U ext could be applied to every atom that is brought in the global tree.
Reference: [21] <author> M. Leuschel. </author> <title> Ecological partial deduction: Preserving characteristic trees without constraints. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proceedings of LOPSTR'95, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, LNCS 1048, </publisher> <year> 1996. </year>
Reference: [22] <author> M. Leuschel and D. De Schreye. </author> <title> An almost perfect abstraction operation for partial deduction using characteristic trees. </title> <type> Technical Report CW215, </type> <institution> Departement Computerweten-schappen, K.U.Leuven, Belgium, </institution> <month> October </month> <year> 1995. </year> <note> Submitted for Publication. Accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference: [23] <author> M. Leuschel, D. De Schreye, and A. de Waal. </author> <title> A conceptual embedding of folding into partial deduction: Towards a maximal integration. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings JICSLP'96, </booktitle> <pages> pages 319-332, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: On the other hand, we demonstrated that keeping the object atoms together in one solve atom can cause more specialisation to be achieved. In the near future, we will investigate to what extent similar effects can be obtained through conjunctive partial deduction <ref> [23, 17] </ref>. Keeping the object atoms together in one solve atom often results in what we called specialised parsing.
Reference: [24] <author> M. Leuschel and B. Martens. </author> <title> Global control for partial deduction through characteristic atoms and global trees. </title> <editor> In O. Danvy, R. Gluck, and P. Thiemann, editors, </editor> <booktitle> Proceedings Dagstuhl Seminar on Partial Evaluation, </booktitle> <pages> pages 263-283, </pages> <address> Schloss Dagstuhl, Germany, </address> <year> 1996. </year> <note> Springer-Verlag, LNCS 1110. Extended version as Technical Report CW220, K.U. Leuven. Accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference-contexts: On the other hand, research on partial deduction of logic programs meanwhile resulted in fully automatic and completely general specialisation techniques, not requiring any specific a priori knowledge about the kind of programs to be specialised, nor any help from the programmer (e.g. <ref> [14, 11, 24] </ref>). fl Supported by a specialisation grant of the Flemish Institute for the Promotion of Scientific-Technological Research in Industry (IWT), Belgium. y Postdoctoral Fellow of the K.U.Leuven Research Council, Belgium. 1 In this paper, we reconsider the problem of specialising the vanilla meta interpreter through such fully automatic methods. <p> Experiments were conducted using the ecce automatic partial deduction system [26]. 2.1 Local control As a starting point for local control, we use the one proposed in Section 4.2 of [17], partially imported by <ref> [34, 24] </ref>. The following definitions are taken from that paper. Definition 2.1 Given an SLD-tree t . <p> Given an SLD-tree t , AL (t ) denotes the set of atoms in its leaves. 2.2 Global control We adopt the framework for global control of <ref> [24, 25] </ref> and introduce some notation. For any program P and a goal G, partial deduction of P w.r.t. G leads to a global tree, denoted by G (P; G), containing the roots of the SLD-trees built locally. <p> If A has an ancestor A 0 2 G (P; G) such that charatom (A 0 ) fi charatom (A), then A 0 is replaced by msg (A 0 ; A), where charatom (A) denotes A's characteristic atom (this generalisation ensures termination). For further details, we refer to <ref> [24, 25] </ref> and Appendix A. <p> Omitting the formal definition, we just include an example. Example 3.2 Consider as object program P , reverse with an accumulating parameter, where a type check on the accumulator is added <ref> [24] </ref>, and its meta representation C (P ). reverse (L; R) rev (L; []; R) pclause (reverse (L; R); rev (L; []; R)) rev ([]; L; L) pclause (rev ([]; L; L); true) rev ([X jX s ]; L; R) ls (L); rev (X s ; [X jL]; R): pclause (rev <p> In some examples (e.g. Example 3.12), the use of characteristic atoms was a key factor in obtaining object specialisation. On the other hand, experiments indicated that the way in which a characteristic tree is imposed upon a generalisation <ref> [24, 25] </ref> should be refined through further unfolding the greatest common initial subtree. Always simply imposing the latter gives rise to unwanted clause predicates in the global tree.
Reference: [25] <author> M. Leuschel, B. Martens, and D. De Schreye. </author> <title> Controlling generalisation and polyvari-ance in partial deduction of normal logic programs. </title> <type> Technical Report CW248, </type> <address> De-partement Computerwetenschappen, K.U.Leuven, Belgium, </address> <month> February </month> <year> 1997. </year> <note> Accessible via http://www.cs.kuleuven.ac.be/publicaties/rapporten/CW1997.html. </note>
Reference-contexts: We conclude with a discussion of our results and the ensuing plans for further research in Section 5. Throughout this paper, we only consider definite logic programs. 2 Automatic Partial Deduction We assume the reader is familiar with the basic correctness [27] and control <ref> [14, 11, 25] </ref> notions of automatic (on-line) partial deduction (see also Appendix A). In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper. <p> Given an SLD-tree t , AL (t ) denotes the set of atoms in its leaves. 2.2 Global control We adopt the framework for global control of <ref> [24, 25] </ref> and introduce some notation. For any program P and a goal G, partial deduction of P w.r.t. G leads to a global tree, denoted by G (P; G), containing the roots of the SLD-trees built locally. <p> If A has an ancestor A 0 2 G (P; G) such that charatom (A 0 ) fi charatom (A), then A 0 is replaced by msg (A 0 ; A), where charatom (A) denotes A's characteristic atom (this generalisation ensures termination). For further details, we refer to <ref> [24, 25] </ref> and Appendix A. <p> In some examples (e.g. Example 3.12), the use of characteristic atoms was a key factor in obtaining object specialisation. On the other hand, experiments indicated that the way in which a characteristic tree is imposed upon a generalisation <ref> [24, 25] </ref> should be refined through further unfolding the greatest common initial subtree. Always simply imposing the latter gives rise to unwanted clause predicates in the global tree.
Reference: [26] <author> Michael Leuschel. </author> <title> The ecce partial deduction system and the dppd library of benchmarks. </title> <note> Obtainable via http://www.cs.kuleuven.ac.be/~lpai, 1996. </note>
Reference-contexts: In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper. Experiments were conducted using the ecce automatic partial deduction system <ref> [26] </ref>. 2.1 Local control As a starting point for local control, we use the one proposed in Section 4.2 of [17], partially imported by [34, 24]. The following definitions are taken from that paper. Definition 2.1 Given an SLD-tree t .
Reference: [27] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> Journal of Logic Programming, </journal> 11(3&4):217-242, 1991. 
Reference-contexts: We conclude with a discussion of our results and the ensuing plans for further research in Section 5. Throughout this paper, we only consider definite logic programs. 2 Automatic Partial Deduction We assume the reader is familiar with the basic correctness <ref> [27] </ref> and control [14, 11, 25] notions of automatic (on-line) partial deduction (see also Appendix A). In this section, we briefly describe the essential ingredients of the partial deduction method we use in this paper. <p> For any program P and a goal G, partial deduction of P w.r.t. G leads to a global tree, denoted by G (P; G), containing the roots of the SLD-trees built locally. To ensure the coveredness condition of <ref> [27] </ref> in a maximally precise way, for atoms appearing in the leaf of an SLD-tree, a fresh such tree needs to be built when there is not yet one with (a variant of ) the given atom as its root.
Reference: [28] <author> B. Martens. </author> <title> On the Semantics of Meta-Programming and the Control of Partial Deduction in Logic Programming. </title> <type> PhD thesis, </type> <institution> Departement Computerwetenschappen, K.U.Leuven, Bel-gium, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task <ref> [4, 28] </ref>. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. <p> In particular, we study how the homeomorphic embedding relation guides specialisation of the interpreter. We focus on the so-called parsing problem, i.e. in essence removing meta-interpretation overhead, in particular parsing conjunctive goals <ref> [20, 28] </ref>, and demonstrate that further control refinements are necessary to properly deal with it. In particular, we modify local control on the basis of information imported from the global level. The resulting control strategy, while remaining fully general, leads to excellent specialisation of vanilla like meta programs. <p> G using the techniques as introduced above. 3 Behaviour of U fi When Unfolding Meta Interpreters In this section, we investigate automatic partial deduction of non-ground, vanilla meta programs, using the general technique presented in Section 2. We will in particular concentrate on the so called "parsing problem" <ref> [20, 28] </ref>: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter [35, 19, 36, 29].
Reference: [29] <author> B. Martens and D. De Schreye. </author> <title> Why untyped non-ground meta-programming is not (much of) a problem. </title> <journal> Journal of Logic Programming, </journal> <volume> 22(1) </volume> <pages> 47-99, </pages> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter <ref> [35, 19, 36, 29] </ref>, extended in order to deal with program compositions [8, 9, 5, 7]. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> We will in particular concentrate on the so called "parsing problem" [20, 28]: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter <ref> [35, 19, 36, 29] </ref>. Definition 3.1 The vanilla meta interpreter V : (1) solve (true) (2) solve ((A; B)) solve (A); solve (B): (3) solve (H ) pclause (H; B); solve (B): 3 As usual, an object program will be represented as a database of pclause-facts. <p> looks as follows: d 1 ([]; []) d 2 ([]; []; X 1 ; [X 1 ]) d 2 ([X 1 jX 2 ]; []; X 3 ; [X 3 ; X 1 jX 2 ]) d 3 (X 2 ): d 3 ([]) 1 For more formal details, see <ref> [29] </ref>. 2 If G = solve (X), the definition of the predicate, created from this root, will contain meta structure, in order to parse the top level goal.
Reference: [30] <author> B. Martens and D. De Schreye. </author> <title> Automatic finite unfolding using well-founded measures. </title> <journal> Journal of Logic Programming, </journal> <volume> 28(2) </volume> <pages> 89-146, </pages> <year> 1996. </year> <note> Abridged and revised version of Technical Report CW180, Departement Computerwetenschappen, K.U.Leuven, October 1993, accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference-contexts: Note however, that this restriction does not diminish the generality of our technique. 4 3.2 In Case Generalisations Take Place U fi (and similar unfolding rules <ref> [30] </ref>) performs well when predicate arguments either shrink or grow throughout the unfolding process. Unfolding is allowed as long as information is consumed and appropriately halted when such is no longer the case.
Reference: [31] <author> B. Martens and J. Gallagher. </author> <title> Ensuring global termination of partial deduction while allowing flexible polyvariance. </title> <editor> In L. Sterling, editor, </editor> <booktitle> Proceedings ICLP'95, </booktitle> <pages> pages 597-611, </pages> <address> Shonan Village Center, Kanagawa, Japan, June 1995. </address> <publisher> MIT Press. </publisher>
Reference: [32] <author> S. Safra and E. Shapiro. </author> <title> Meta interpreters for real. </title> <editor> In H.-J. Kugler, editor, </editor> <booktitle> Information Processing 86, </booktitle> <pages> pages 271-278, </pages> <year> 1986. </year>
Reference-contexts: However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program <ref> [12, 37, 32] </ref>, thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20].
Reference: [33] <author> D. Sahlin. Mixtus: </author> <title> An automatic partial evaluator for full Prolog. </title> <journal> New Generation Computing, </journal> <volume> 12(1) </volume> <pages> 7-51, </pages> <year> 1993. </year>
Reference: [34] <author> M. H. Strensen and R. Gluck. </author> <title> An algorithm of generalization in positive supercompilation. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proceedings ILPS'95, </booktitle> <pages> pages 465-479, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Experiments were conducted using the ecce automatic partial deduction system [26]. 2.1 Local control As a starting point for local control, we use the one proposed in Section 4.2 of [17], partially imported by <ref> [34, 24] </ref>. The following definitions are taken from that paper. Definition 2.1 Given an SLD-tree t .
Reference: [35] <author> L. Sterling and R. D. Beer. </author> <title> Meta interpreters for expert system construction. </title> <journal> Journal of Logic Programming, </journal> 6(1&2):163-178, 1989. 
Reference-contexts: Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter <ref> [35, 19, 36, 29] </ref>, extended in order to deal with program compositions [8, 9, 5, 7]. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> We will in particular concentrate on the so called "parsing problem" [20, 28]: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter <ref> [35, 19, 36, 29] </ref>. Definition 3.1 The vanilla meta interpreter V : (1) solve (true) (2) solve ((A; B)) solve (A); solve (B): (3) solve (H ) pclause (H; B); solve (B): 3 As usual, an object program will be represented as a database of pclause-facts.
Reference: [36] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Writing meta interpreters is a well-known technique to enhance the expressive power of logic programs (see e.g. <ref> [36, 1, 18] </ref>). However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program [12, 37, 32], thus removing the overhead. <p> Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20]. In a recent paper [7], Brogi and Contiero address specialisation of a non-ground vanilla-like meta interpreter <ref> [35, 19, 36, 29] </ref>, extended in order to deal with program compositions [8, 9, 5, 7]. Again, the interpretion overhead is removed by an ad hoc specialiser, specifically constructed to handle the extended interpreter. <p> We will in particular concentrate on the so called "parsing problem" [20, 28]: To what extent is our general technique able to remove meta-interpretation overhead, including the parsing of conjunctions in clause (2) of V . Let us first repeat the definition of the well-known vanilla meta interpreter <ref> [35, 19, 36, 29] </ref>. Definition 3.1 The vanilla meta interpreter V : (1) solve (true) (2) solve ((A; B)) solve (A); solve (B): (3) solve (H ) pclause (H; B); solve (B): 3 As usual, an object program will be represented as a database of pclause-facts.
Reference: [37] <author> A. Takeuchi and K. Furukawa. </author> <title> Partial evaluation of Prolog programs and its application to metaprogramming. </title> <editor> In H.-J. Kugler, editor, </editor> <booktitle> Information Processing 86, </booktitle> <pages> pages 415-420, </pages> <year> 1986. </year> <month> 12 </month>
Reference-contexts: However, the resulting interpretation overhead considerably slows down program execution [4]. A natural approach to solving this efficiency problem consists in specialising the interpreter with respect to a given object program <ref> [12, 37, 32] </ref>, thus removing the overhead. Fully achieving the latter goal however, turns out to be a non trivial task [4, 28]. Satisfying results could often only be obtained at the cost of using not fully automatic and/or ad hoc techniques [20].
References-found: 37

