URL: http://www.cs.jhu.edu/~scott/specdiag/Papers/FMOODS99.ps
Refering-URL: http://www.cs.jhu.edu/~scott/specdiag/
Root-URL: http://www.cs.jhu.edu
Email: scott@cs.jhu.edu  clt@cs.stanford.edu  
Phone: 2  
Title: MODULAR REASONING FOR ACTOR SPECIFICATION DIAGRAMS  
Author: Scott F. Smith and Carolyn L. Talcott 
Affiliation: 1 The Johns Hopkins University  Stanford University  
Abstract: Specification diagrams are a novel form of graphical notation for specifying open distributed object systems. The design goal is to define notation for specifying message-passing behavior that is expressive, intuitively understandable, and that has formal semantic underpinnings. The notation generalizes informal notations such as UML's Sequence Diagrams and broadens their applicability to later in the design cycle. In this paper we show how it is possible to reason rigorously and modularly about specification diagrams. An Actor Theory Toolkit is used to great advantage for this purpose. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Henry G. Baker and Carl Hewitt. </author> <title> Laws for communicating parallel processes. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 987992. </pages> <publisher> IFIP, </publisher> <month> August </month> <year> 1977. </year>
Reference-contexts: We omit mention of fActs (l) if it is the set of internal actors of s 0 and also omit mention of empty sets of created actors, received or sent message packets The set of rules must satisfy the fundamental actor locality laws of <ref> [1, 3] </ref>. Operational semantics of an actor theory. The operational semantics of an actor theory is given by a labelled transition relation on actor system configurations. A configuration has an interface and an interior.
Reference: [2] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. Computer Networks and ISDN Systems, </title> <address> 14:2559, </address> <year> 1987. </year>
Reference-contexts: Parallel composition and choice is of a similar sort in specification diagrams and process algebra. Message send and receive is partly analogous to the related concepts in the asynchronous p-calculus [11]. A number of full specification languages based on process algebra have been developed; examples include LOTOS <ref> [2] </ref>, which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [12]. Recently temporal logics for distributed object based systems have been developed [7, 5].
Reference: [3] <author> W. D. Clinger. </author> <title> Foundations of Actor Semantics. </title> <type> PhD thesis, </type> <institution> MIT, 1981. MIT Artificial Intelligence Laboratory AI-TR-633. </institution>
Reference-contexts: We omit mention of fActs (l) if it is the set of internal actors of s 0 and also omit mention of empty sets of created actors, received or sent message packets The set of rules must satisfy the fundamental actor locality laws of <ref> [1, 3] </ref>. Operational semantics of an actor theory. The operational semantics of an actor theory is given by a labelled transition relation on actor system configurations. A configuration has an interface and an interior. <p> Message passing diagrams have a long history in software specification and are now most widely known as UML Sequence Diagrams [16]. The Examples Section gave a detailed contrast between specification diagrams and sequence diagrams. In the actor model, event diagrams <ref> [8, 10, 3] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [4] <institution> Rational Software Corporation. </institution> <note> UML Notation Guide, version 1.1. September 1997. Obtained From http://www.rational.com. </note>
Reference-contexts: However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification. The left diagram of Figure 4 is a UML sequence diagram which is presented in <ref> [4] </ref> (we have removed temporal constraints since specification diagrams are not real-time). On the right side is the same example re-expressed as a specification diagram. This example also brings out the usefulness of the send-receive cross-edges in specification diagrams.
Reference: [5] <author> G. Denker. </author> <title> DTL + : A Distributed Temporal Logic Supporting Several Communication Principles. </title> <type> Technical Report , SRI International, </type> <institution> Computer Science Laboratory, </institution> <address> 333 Ravenswood Ave, Menlo Park, CA 94025, </address> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [12]. Recently temporal logics for distributed object based systems have been developed <ref> [7, 5] </ref>. While such logics express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems. Specification diagrams themselves can serve the purpose of a logic by directly expressing safety and liveness properties, as was illustrated by the examples.
Reference: [6] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics, </title> <booktitle> volume 14 of Texts and Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This interpretation is analogous to the assume predicate of Dijkstra's predicate calculus <ref> [6] </ref>. assertion (assert (f)) An arbitrary assertion is made. Unlike constrain, an assert that fails indicates failure of some property, and has no programmatic meaning. This is analogous to Dijkstra's assert predicate. assign (x := y) A variable is dynamically assigned a new value.
Reference: [7] <author> C. H. </author> <title> C Duarte. A proof-theoretic approach to the design of object-based mobility. </title> <editor> In H. Bowman and J. Derrick, editors, </editor> <booktitle> Formal Methods for Open Object-based Distributed Systems, </booktitle> <volume> Volume 2, </volume> <pages> pages 3753. </pages> <publisher> Chapman & Hall, </publisher> <year> 1997. </year>
Reference-contexts: Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [12]. Recently temporal logics for distributed object based systems have been developed <ref> [7, 5] </ref>. While such logics express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems. Specification diagrams themselves can serve the purpose of a logic by directly expressing safety and liveness properties, as was illustrated by the examples.
Reference: [8] <author> I. Greif. </author> <title> Semantics of communicating parallel processes. </title> <type> Technical Report 154, </type> <institution> MIT, Project MAC, </institution> <year> 1975. </year>
Reference-contexts: Message passing diagrams have a long history in software specification and are now most widely known as UML Sequence Diagrams [16]. The Examples Section gave a detailed contrast between specification diagrams and sequence diagrams. In the actor model, event diagrams <ref> [8, 10, 3] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [9] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8(3):231274, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Many specification languages that have achieved widespread usage have a graphical presentation format, primarily because engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include Universal Modeling Language (UML) and its predecessors [16], Petri nets, and Statecharts <ref> [9] </ref>. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. <p> The use of embedded non-computational assertions is very similar to forms found in Dijkstra-style weakest precondition logics for non-concurrent programs [14]. Finite automata are useful for specifying systems which have a strong state-based behavior. The Statecharts automata formalism <ref> [9] </ref> has become particularly popular in industry. The primary weakness of finite automata is that a complex software system may not have a meaningful global state.
Reference: [10] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3):323 364, </volume> <year> 1977. </year>
Reference-contexts: Message passing diagrams have a long history in software specification and are now most widely known as UML Sequence Diagrams [16]. The Examples Section gave a detailed contrast between specification diagrams and sequence diagrams. In the actor model, event diagrams <ref> [8, 10, 3] </ref> graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work. Specification diagrams also share commonalities with other approaches to precise specification. Process algebra notation may be used to formally specify the communication actions of concurrent systems.
Reference: [11] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP, volume 512 of LNCS, </booktitle> <pages> pages 133147. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Process algebra notation may be used to formally specify the communication actions of concurrent systems. Parallel composition and choice is of a similar sort in specification diagrams and process algebra. Message send and receive is partly analogous to the related concepts in the asynchronous p-calculus <ref> [11] </ref>. A number of full specification languages based on process algebra have been developed; examples include LOTOS [2], which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [12].
Reference: [12] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A number of full specification languages based on process algebra have been developed; examples include LOTOS [2], which is based on CSP; it is now an an ISO standard. Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [12] </ref>. Recently temporal logics for distributed object based systems have been developed [7, 5]. While such logics express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems.
Reference: [13] <author> I. A. Mason and C. L. Talcott. </author> <title> Actor languages their syntax, semantics, translation, and equivalence, </title> <note> 1999. to appear. </note>
Reference-contexts: More detail about the framework can be found in <ref> [19, 13] </ref>. Actor theories The actor theory framework is a general mathamatical framework for defining and reasoning about the semantics of actor systems. It can be used to define operational semantics for actor programming languages or the specification diagram language (a main use here).
Reference: [14] <author> Greg Nelson. </author> <title> A generalization of dijkstra's calculus. </title> <journal> TOPLAS, </journal> <volume> 11:517561, </volume> <year> 1987. </year>
Reference-contexts: Specification diagrams themselves can serve the purpose of a logic by directly expressing safety and liveness properties, as was illustrated by the examples. The use of embedded non-computational assertions is very similar to forms found in Dijkstra-style weakest precondition logics for non-concurrent programs <ref> [14] </ref>. Finite automata are useful for specifying systems which have a strong state-based behavior. The Statecharts automata formalism [9] has become particularly popular in industry. The primary weakness of finite automata is that a complex software system may not have a meaningful global state.
Reference: [15] <author> Jim Rumbaugh and Grady Booch. </author> <title> Unified Method for Object Oriented Development, </title> <note> version 0.8. 1996. Obtained From http://www.rational.com. </note>
Reference-contexts: Comparison with UML Sequence Diagrams Specification diagrams were partly inspired by UML sequence diagrams [16] (to be specific, by an early version known as a message trace diagram <ref> [15] </ref>), and the two share concepts. However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification.
Reference: [16] <author> Jim Rumbaugh, Ivar Jacobson, and Grady Booch. </author> <title> Unified Modeling Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1998. </year>
Reference-contexts: Many specification languages that have achieved widespread usage have a graphical presentation format, primarily because engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include Universal Modeling Language (UML) and its predecessors <ref> [16] </ref>, Petri nets, and Statecharts [9]. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. <p> The ability to express assertions diagrammatically means there is less need to learn a spe cialized logic in which assertions are written. Comparison with UML Sequence Diagrams Specification diagrams were partly inspired by UML sequence diagrams <ref> [16] </ref> (to be specific, by an early version known as a message trace diagram [15]), and the two share concepts. However, sequence diagrams are primarily designed to show possible scenarios of execution, and not to give all possible scenarios. They are primarily for informal design and not rigorous specification. <p> Specification diagrams are most closely related to other forms of message-passing diagram, diagrams with vertical lines for processes/threads, and horizontal lines for messages. Message passing diagrams have a long history in software specification and are now most widely known as UML Sequence Diagrams <ref> [16] </ref>. The Examples Section gave a detailed contrast between specification diagrams and sequence diagrams. In the actor model, event diagrams [8, 10, 3] graphically model scenarios of actor computation by message-passing edges between actors, and were another source of inspiration for this work.
Reference: [17] <author> S. Smith. </author> <title> On specification diagrams for actor systems. </title> <editor> In C. Talcott A. Gordon, A .Pitts, editor, </editor> <booktitle> Proceedings of the Second Workshop on Higher-Order Techniques in Semantics, Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1998. </year> <note> http://www.elsevier.nl/locate/entcs/volume10.html. </note>
Reference-contexts: Following is a section outlining how diagrams may be given operational meaning via an actor theory, and lastly we conclude with an example proof of correspondence between diagrams. By necessity many technical details are missing from this abbreviated presentation; see [18] for a more complete exposition. <ref> [17] </ref> is the initial paper on this topic. Actor Concepts We provide a brief overview of the underlying actor basis at this point. The Actor Theory Section below builds the actor theory framework over this basis. Actors are distributed, object-based message passing entities. <p> The acquaintance and internal actors operations are defined by acq (hjD; iAji) = acq (D) [ acq (iA), and iacts (hjD; iAji) = iA. The labelled reaction rules RR sd are a rigorous version of the informal descriptions given in the Syntax section. See <ref> [18, 17] </ref> for the complete ruleset RR sd . Here we illustrate the rules via an example computation. Recall the function composer system FC of the Examples Section. We will show one complete pass through the loop.
Reference: [18] <author> S. Smith and C. Talcott. </author> <title> Specification diagrams for actor systems. </title> <note> See http://www.cs.jhu.edu/~scott/specdiag. </note>
Reference-contexts: Following is a section outlining how diagrams may be given operational meaning via an actor theory, and lastly we conclude with an example proof of correspondence between diagrams. By necessity many technical details are missing from this abbreviated presentation; see <ref> [18] </ref> for a more complete exposition. [17] is the initial paper on this topic. Actor Concepts We provide a brief overview of the underlying actor basis at this point. The Actor Theory Section below builds the actor theory framework over this basis. Actors are distributed, object-based message passing entities. <p> The acquaintance and internal actors operations are defined by acq (hjD; iAji) = acq (D) [ acq (iA), and iacts (hjD; iAji) = iA. The labelled reaction rules RR sd are a rigorous version of the informal descriptions given in the Syntax section. See <ref> [18, 17] </ref> for the complete ruleset RR sd . Here we illustrate the rules via an example computation. Recall the function composer system FC of the Examples Section. We will show one complete pass through the loop.
Reference: [19] <author> C. L. Talcott. </author> <title> Composable semantic models for actor theories. Higher-Order and Symbolic Computation, </title> <type> 11(3), </type> <year> 1998. </year>
Reference-contexts: More detail about the framework can be found in <ref> [19, 13] </ref>. Actor theories The actor theory framework is a general mathamatical framework for defining and reasoning about the semantics of actor systems. It can be used to define operational semantics for actor programming languages or the specification diagram language (a main use here).
Reference: [20] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 675788. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Two concrete notions of satisfaction are now presented. Loose Satisfaction. The standard notion of satisfaction in the literature is that the implementation refines the specification. We term this loose satisfaction. In algebraic specification for example <ref> [20] </ref>, this is the only relation defined to assert an implementation meets a specification. This form of satisfaction is a subset relationship on interaction path behaviors: Definition 1 (loose satisfaction): hD I i r r r r Loose Satisfaction and the Ticker.
References-found: 20

