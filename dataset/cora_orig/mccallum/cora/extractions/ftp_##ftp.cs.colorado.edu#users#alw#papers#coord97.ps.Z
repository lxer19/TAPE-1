URL: ftp://ftp.cs.colorado.edu/users/alw/papers/coord97.ps.Z
Refering-URL: http://www.cs.colorado.edu/users/alw/AvailablePubs.html
Root-URL: http://www.cs.colorado.edu
Phone: 3  
Title: Checking Assumptions in Component Dynamics at the Architectural Level  
Author: Paola Inverardi Alexander L. Wolf and Daniel Yankelevich 
Address: I-67010 L'Aquila, Italy Boulder, CO 80309 USA  Buenos Aires, Argentina  
Affiliation: 1 Dipartimento di Matematica 2 Department of Computer Science Universita di L'Aquila University of Colorado  Departmento de Computacion Universidad de Buenos Aires  
Date: 1997 46  
Note: From the Proceedings of the Second International Conference on Coordination Models and Languages, LNCS 1282, Springer, Berlin,  
Abstract: A critical challenge faced by the developer of a software system is to understand whether the system's components correctly integrate. While type theory has provided substantial help in detecting and preventing errors in mismatched static properties, much work remains in the area of dynamics. In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. We have begun to formulate a method that addresses this problem. The method operates at the architectural level so that behavioral integration errors, such as deadlock, can be revealed early in development. For each component, a specification is given both of its own interaction behavior and of the assumptions that it makes about the interaction behavior of the external context in which it expects to operate. We have defined an algorithm that, given such specifications for a set of components, performs "adequacy" checks between the component context assumptions and the component interaction behaviors. A configuration of a system is possible if and only if a successful way of "matching" actual behaviors with assumptions can be found. In effect, we are extending the usual notion of type checking to include the checking of behavioral compatibility. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Allen and D. Garlan. </author> <title> Formalizing Architectural Connection. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: In that work, a description of potential behavior is given by a regular expression in which atomic elements represented calls to the module. The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan <ref> [1, 2] </ref>. In their architectural description language Wright [19], each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: 2. <author> R. Allen and D. Garlan. </author> <title> A Case Study in Architectural Modeling: </title> <booktitle> The AEGIS System. In Proceedings of the 8th International Workshop on Software Specification and Design, </booktitle> <pages> pages 6-15. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: In that work, a description of potential behavior is given by a regular expression in which atomic elements represented calls to the module. The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan <ref> [1, 2] </ref>. In their architectural description language Wright [19], each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: 3. <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> The Gamma Model and its Discipline of Programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 15 </volume> <pages> 55-77, </pages> <year> 1990. </year> <month> 63 </month>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma ( ) formalism for parallel programming, in which programs can be seen as multiset transformers <ref> [3, 4] </ref>. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [11] and the CCS process calculus [15].
Reference: 4. <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> Programming by Multiset Transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma ( ) formalism for parallel programming, in which programs can be seen as multiset transformers <ref> [3, 4] </ref>. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [11] and the CCS process calculus [15].
Reference: 5. <author> G. Berry and G. Boudol. </author> <title> The Chemical Abstract Machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: In previous work [8, 12, 13], we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism <ref> [5] </ref>. The CHAM formalism had, until then, been used primarily to 47 describe the semantics of various models of concurrency and the semantics of various concurrent programming languages. We showed how it could be used instead to describe actual software systems. <p> described, but your assumptions about the global party context| that the host will introduce you to the partner|must also be described. 3 Background The CHAM formalism was developed by Berry and Boudol in the domain of theoretical computer science for the principal purpose of defining a generalized 49 computational framework <ref> [5] </ref>. It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma ( ) formalism for parallel programming, in which programs can be seen as multiset transformers [3, 4]. The CHAM formalism provides a powerful set of primitives for computational modeling.
Reference: 6. <author> G. Boudol. </author> <title> Some Chemical Abstract Machines. In A Decade of Concurrency, </title> <booktitle> number 803 in Lecture Notes in Computer Science, </booktitle> <pages> pages 92-123. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [11] and the CCS process calculus [15]. Boudol <ref> [6] </ref> points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation.
Reference: 7. <author> R.H. </author> <title> Campbell and A.N. Habermann. The Specification of Process Synchronization by Path Expressions. </title> <booktitle> In Proceedings of an International Symposium on Operating Systems, number 16 in Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1974. </year>
Reference-contexts: However, as it was aimed at modules and assembly of modules, the dynamics of the system are not considered. The use of sequences of actions associated locally to modules (components) to describe the behavior of the allowed interactions was introduced in Path Expressions <ref> [7] </ref>. In that work, a description of potential behavior is given by a regular expression in which atomic elements represented calls to the module.
Reference: 8. <author> D. Compare and P. Inverardi. </author> <title> Modelling Interoperability by CHAM: A Case Study. </title> <booktitle> In Proceedings of the First International Conference on Coordination Models and Languages, number 1061 in Lecture Notes in Computer Science, </booktitle> <pages> pages 428-431. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 12, 13] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to 47 describe the semantics of various models of concurrency and the semantics of various concurrent programming languages.
Reference: 9. <author> D. Compare, P. Inverardi, and A.L. Wolf. </author> <title> Uncovering Architectural Mismatch in Dynamic Behavior. </title> <type> Technical Report CU-CS-828-97, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Colorado, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: In this paper we give an initial demonstration of the feasibility of our approach by describing its application to a system, the Compressing Proxy, first investigated by Garlan, Kindred, and Wing [10], and later by Compare, Inver-ardi, and Wolf <ref> [9] </ref>. The system contains incompatibilities between the assumptions and the interaction behaviors of two of its components. Our algorithm successfully reveals the known fact that the error can result in a deadlock. 2 Related Work Software architectures are structures of individual components that behave independently and interact.
Reference: 10. <author> D. Garlan, D. Kindred, and J.M. Wing. </author> <title> Interoperability: Sample Problems and Solutions. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <note> In preparation. </note>
Reference-contexts: In effect, we are extending the usual notion of type checking to include the checking of behavioral compatibility. In this paper we give an initial demonstration of the feasibility of our approach by describing its application to a system, the Compressing Proxy, first investigated by Garlan, Kindred, and Wing <ref> [10] </ref>, and later by Compare, Inver-ardi, and Wolf [9]. The system contains incompatibilities between the assumptions and the interaction behaviors of two of its components. <p> Transformation rules applied to the initial solution define how the system dynamically evolves from its initial configuration. 4 The Compressing Proxy Problem In this section we present the design of the Compressing Proxy system. Our description is derived from that given by Garlan, Kindred, and Wing <ref> [10] </ref>. To improve the performance of UNIX-based World Wide Web browsers over slow networks, one could create an HTTP (Hyper Text Transfer Protocol) server that compresses and uncompresses data that it sends across the network.
Reference: 11. <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: Interaction occurs between two or more components by placing a connector between them and by associating each port in a component with a role in the connector. The semantics of ports and roles in Wright are given using a subset of the language CSP <ref> [11] </ref>. A notion of consistency is introduced via a behavioral equivalence between the CSP agents describing the semantics of corresponding ports and roles. Although roles where introduced explicitly to support connector reuse, the idea is related to our notion of expected behavior. <p> The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP <ref> [11] </ref> and the CCS process calculus [15]. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation.
Reference: 12. <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 12, 13] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to 47 describe the semantics of various models of concurrency and the semantics of various concurrent programming languages. <p> Finally, if no rules can be applied to a solution, then that solution is said to be inert. When applying the formalism to software architecture, we structure specifications into three parts <ref> [12] </ref>: 1. a description of the syntax by which components of the system (i.e., the molecules) can be represented; 2. a solution representing the initial state of the system; and 3. a set of reaction rules describing how the components interact to achieve the dynamic behavior of the system.
Reference: 13. <author> P. Inverardi and D. Yankelevich. </author> <title> Relating CHAM Descriptions of Software Architectures. </title> <booktitle> In Proceedings of the 8th International Workshop on Software Specification and Design, </booktitle> <pages> pages 66-74. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 12, 13] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to 47 describe the semantics of various models of concurrency and the semantics of various concurrent programming languages.
Reference: 14. <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Moreover, the dynamics of these structures are of interest. In this line, it is not unexpected that many languages used to express concurrency semantics are borrowed to describe software architectures. Besides CSP and CHAM, other models have been used, such as the Pi Calculus [18] and Posets <ref> [14] </ref>. We believe that our approach is independent of the particular specification language used, but one advantage of the CHAM formalism is that it has not embedded within it any particular form of interaction. In most other languages, synchronous or asynchronous broadcast, or point-to-point communications are chosen.
Reference: 15. <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [11] and the CCS process calculus <ref> [15] </ref>. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation.
Reference: 16. <author> D.E. Perry. </author> <title> The Inscape Environment. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1989. </year>
Reference-contexts: In most other languages, synchronous or asynchronous broadcast, or point-to-point communications are chosen. From the perspective of Module Interconnection Languages, informal or semiformal languages have been used to describe software architectures [20]. In those 48 cases, it is more difficult to prove properties of the systems. Perry <ref> [16] </ref> presents a model in which the semantics of connections are taken into account to check when modules match. The semantic information in the modules, given as predicates, is used to verify some properties.
Reference: 17. <author> D.E. Perry and A.L. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The syntactic description of the components is given by an algebra of molecules or, in other words, a syntax by which molecules can be built. Following Perry and Wolf <ref> [17] </ref>, we distinguish three classes of components: data elements, processing elements, and connecting elements. The processing elements are those components that perform the transformations on the data elements, while the data elements are those that contain the information that is used and transformed.
Reference: 18. <author> M. Radestock and S. Eisenbach. </author> <title> What Do You Get From a Pi-calculus Semantics? In Proceedings of PARLE'94 Parallel Architectures and Languages Europe, </title> <booktitle> number 817 in Lecture Notes in Computer Science, </booktitle> <pages> pages 635-647. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Moreover, the dynamics of these structures are of interest. In this line, it is not unexpected that many languages used to express concurrency semantics are borrowed to describe software architectures. Besides CSP and CHAM, other models have been used, such as the Pi Calculus <ref> [18] </ref> and Posets [14]. We believe that our approach is independent of the particular specification language used, but one advantage of the CHAM formalism is that it has not embedded within it any particular form of interaction. In most other languages, synchronous or asynchronous broadcast, or point-to-point communications are chosen.
Reference: 19. <author> M. Shaw and D. Garlan. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1996. </year>
Reference-contexts: The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan [1, 2]. In their architectural description language Wright <ref> [19] </ref>, each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: 20. <author> A.L. Wolf, L.A. Clarke, and J.C. Wileden. </author> <title> The AdaPIC Tool Set: Supporting Interface Control and Analysis Throughout the Software Development Process. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(3) </volume> <pages> 250-263, </pages> <month> March </month> <year> 1989. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: In most other languages, synchronous or asynchronous broadcast, or point-to-point communications are chosen. From the perspective of Module Interconnection Languages, informal or semiformal languages have been used to describe software architectures <ref> [20] </ref>. In those 48 cases, it is more difficult to prove properties of the systems. Perry [16] presents a model in which the semantics of connections are taken into account to check when modules match. The semantic information in the modules, given as predicates, is used to verify some properties.
References-found: 20

