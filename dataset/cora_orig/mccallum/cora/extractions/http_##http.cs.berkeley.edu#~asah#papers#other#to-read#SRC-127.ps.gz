URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/SRC-127.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Pictures  
Author: Leslie Lamport 
Address: 130 Lytton Avenume Palo Alto, California 94301  
Affiliation: Systems Research Center  
Note: TLA in  
Date: September 1, 1994  
Abstract: SRC Research Report 127 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <type> Research Report 118, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: This is a circuit with n binary inputs in <ref> [1] </ref>; : : : ; in [n] and one binary output out, as shown in Figure 2. As the figure indicates, we are considering the closed system consisting of the C-element together with its environment. Initially, all the inputs and the output are equal. <p> After an input changes, it must remain stable until the output changes. The behavior of a 2-input C-element and its environment is described by the predicate-action diagram of Figure 3 (a), where C is defined by C (i; j; k) = (in <ref> [1] </ref> = i) ^ (in [2] = j) ^ (out = k) The short arrows, with no originating node, identify the nodes labeled C (0; 0; 0) and C (1; 1; 1) as initial nodes. <p> The arrows connecting nodes indicate possible state transitions. For example, from a state satisfy ing C (1; 1; 1), it is possible for the system to go to a state satisfying either 4 E v r n e t - l m n in <ref> [1] </ref> out - C (0; 1; 1) or C (1; 0; 1). More precisely, these arrows indicate all steps in which the triple hin [1]; in [2]; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. <p> 1), it is possible for the system to go to a state satisfying either 4 E v r n e t - l m n in <ref> [1] </ref> out - C (0; 1; 1) or C (1; 0; 1). More precisely, these arrows indicate all steps in which the triple hin [1]; in [2]; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. <p> 4 E v r n e t - l m n in <ref> [1] </ref> out - C (0; 1; 1) or C (1; 0; 1). More precisely, these arrows indicate all steps in which the triple hin [1]; in [2]; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. The predicate-action diagram of Figure 3 (a) looks like a standard state-transition diagram. <p> More precisely, these arrows indicate all steps in which the triple hin <ref> [1] </ref>; in [2]; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. The predicate-action diagram of Figure 3 (a) looks like a standard state-transition diagram. <p> The predicate Init is C (0; 0; 0) _ C (1; 1; 1). Each F o describes the possible state changes starting from a state described by node o. For example, the formula F o for the node labeled C (1; 1; 0) is 2 <ref> [C (1; 1; 0) ) C (1; 1; 1) 0 ] </ref> hin [1];in [2];outi A predicate-action diagram represents a safety property; it does not include any fairness conditions. complicated; and there is no way to draw such a diagram for an n-input circuit. <p> ffi fl * fi A A - ffi - AU AU (b) The corresponding TLA formula. ^ C (0; 0; 0) _ C (1; 1; 1) ^ 2 [C (0; 0; 0) ) C (1; 0; 0) 0 _ C (0; 1; 0) 0 ] hin [1];in [2];outi ^ 2 <ref> [C (1; 0; 0) ) C (1; 1; 0) 0 ] </ref> hin [1];in [2];outi : : : ^ 2 [C (0; 0; 1) ) C (0; 0; 0) 0 ] hin [1];in [2];outi element, and the corresponding TLA formula. * [i 2 S 7! e (i)] denotes the function f with <p> To write the specification , we let pc be a function with domain f1; 2g, with pc [i] indicating where control resides in process i. The formula PC (p; q) can then be defined by PC (p; q) = (pc <ref> [1] </ref> = p) ^ (pc [2] = q) The semaphore actions P and V are defined by P (sem) = ^ 0 &lt; sem V (sem) = sem 0 = sem + 1 Missing from Figure 10 are a specification of the initial values of x and y, which we take <p> = "a") ^ (0 &lt; sem) ^ pc 0 = [pc except ![i] = "b"] ^ sem 0 = sem 1 fl i = ^ pc [i] = "g" ^ pc 0 = [pc except ![i] = "a"] ^ sem 0 = sem + 1 fi 1 = ^ pc <ref> [1] </ref> = "b" ^ pc 0 = [pc except ![1] = "g"] ^ x 0 = x + 1 ^ hy; semi 0 = hy; semi fi 2 = ^ pc [2] = "b" ^ pc 0 = [pc except ![2] = "g"] ^ y 0 = y + 1 ^ <p> Because TLA formulas are invariant under stuttering, we draw diagrams of particular state functions|usually tuples of variables. TLA differs from most specification methods because it is a logic. It uses simple logical operations like implication and conjunction instead of more complicated automata-based notions of simulation and composition <ref> [1] </ref>. Everything we have done with predicate-action diagrams can be done with state-transition diagrams in any purely state-based formalism. However, 17 conventional formalisms must use some notion of homomorphism between diagrams to describe what is expressed in TLA as logical implication.
Reference: [2] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: The formula Init ^ 2 [N ] v is a safety property <ref> [2] </ref>. <p> After an input changes, it must remain stable until the output changes. The behavior of a 2-input C-element and its environment is described by the predicate-action diagram of Figure 3 (a), where C is defined by C (i; j; k) = (in [1] = i) ^ (in <ref> [2] </ref> = j) ^ (out = k) The short arrows, with no originating node, identify the nodes labeled C (0; 0; 0) and C (1; 1; 1) as initial nodes. They indicate that the C-element starts in a state satisfying C (0; 0; 0) or C (1; 1; 1). <p> More precisely, these arrows indicate all steps in which the triple hin [1]; in <ref> [2] </ref>; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. <p> More precisely, these arrows indicate all steps in which the triple hin [1]; in <ref> [2] </ref>; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. The predicate-action diagram of Figure 3 (a) looks like a standard state-transition diagram. <p> precisely, these arrows indicate all steps in which the triple hin [1]; in <ref> [2] </ref>; outi changes|that is, transitions in which at least one of in [1], in [2], and out changes. Steps that change other variables| for example, variables representing circuit elements inside the environment| but leave hin [1]; in [2]; outi unchanged are also possible. The predicate-action diagram of Figure 3 (a) looks like a standard state-transition diagram. <p> To write the specification , we let pc be a function with domain f1; 2g, with pc [i] indicating where control resides in process i. The formula PC (p; q) can then be defined by PC (p; q) = (pc [1] = p) ^ (pc <ref> [2] </ref> = q) The semaphore actions P and V are defined by P (sem) = ^ 0 &lt; sem V (sem) = sem 0 = sem + 1 Missing from Figure 10 are a specification of the initial values of x and y, which we take to be zero, and a <p> 0 = [pc except ![i] = "a"] ^ sem 0 = sem + 1 fi 1 = ^ pc [1] = "b" ^ pc 0 = [pc except ![1] = "g"] ^ x 0 = x + 1 ^ hy; semi 0 = hy; semi fi 2 = ^ pc <ref> [2] </ref> = "b" ^ pc 0 = [pc except ![2] = "g"] ^ y 0 = y + 1 ^ hx; semi 0 = hx; semi N i = ff i _ fi i _ fl i w = hx; y; sem; pci = Init ^ 2 [N ] w ^
Reference: [3] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Section 2 is a brief review of TLA; a more leisurely introduction to TLA appears in <ref> [3] </ref>. Section 3 describes predicate-action diagrams, using an n-input Muller C-element as an example. It shows how diagrams are used to describe aspects of a complete specification, and to provide complementary views of a system. <p> Verification means proving that one formula implies another. A practical, relatively complete set of rules for proving such implications is described in <ref> [3] </ref>. We show here how predicate-action diagrams can be used to illustrate these proofs. We take as our example the same one treated in [3], that the specification defined in Section 4.1 below implies the specification defined in Section 2 above. 4.1 Another Specification We define a TLA formula describing a <p> Verification means proving that one formula implies another. A practical, relatively complete set of rules for proving such implications is described in <ref> [3] </ref>. We show here how predicate-action diagrams can be used to illustrate these proofs. We take as our example the same one treated in [3], that the specification defined in Section 4.1 below implies the specification defined in Section 2 above. 4.1 Another Specification We define a TLA formula describing a program with two processes, each of which repeatedly loops through the sequence of operations P (sem); increment; V (sem), where one process increments x <p> This completes the proof of condition 3. Using the predicate-action diagram does not simplify the proof. If we were to make the argument given above rigorous, we would go through precisely the same steps as in the proof described in <ref> [3] </ref>. However, the diagram does allow us to visualize the proof, which can help us to understand it. 5 Conclusion We have described three uses of diagrams that we believe are new: 16 * To describe particular aspects of a complex specification with a sim-ple diagram. <p> Diagrams (b) and (c) of Figure 10 look quite different, but they are diagrams for the same specification. * To illustrate proofs. The disjunction of the predicates labeling the nodes in Figure 12 equals the invariant I of the proof in Section 7.2 of <ref> [3] </ref>. The diagram provides a graphical representation of the invari ance proof. TLA differs from traditional specification methods in two important ways. First, all TLA specifications are interpreted over the same set of states. <p> In TLA, there are only states, not events. Systems are described in terms of changes to interface variables rather than in terms of interface events. Variables describing the internal state are hidden with the existential quantifier 999 999 described in <ref> [3] </ref>. Changes to any variable, whether internal or interface, can be indicated by node labels or edge labels. Hence, a purely state-based approach like TLA allows more flexibility in how diagrams are drawn than a method based on states and events.
Reference: [4] <author> Carver Mead and Lynn Conway. </author> <title> Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1980. </year>
Reference-contexts: allowed, but it does not require anything to happen. (The formula is satisfied by a behavior satisfying the initial condition in which no variables ever change.) Fairness conditions are used to specify that something must happen. 3 Predicate-Action Diagrams 3.1 An Example We take as an example a Muller C-element <ref> [4] </ref>. This is a circuit with n binary inputs in [1]; : : : ; in [n] and one binary output out, as shown in Figure 2. As the figure indicates, we are considering the closed system consisting of the C-element together with its environment.
Reference: [5] <author> George H. Mealy. </author> <title> A method for synthesizing sequential circuits. </title> <journal> Bell System Technical Journal, </journal> <volume> 34(5) </volume> <pages> 1045-1079, </pages> <month> September </month> <year> 1955. </year>
Reference-contexts: As an aid to understanding TLA formulas, we introduce here a type of picture called a predicate-action diagram. These diagrams are similar to the various kinds of state-transition diagrams that have been used for years to describe systems, starting with Mealy and Moore machines <ref> [5, 6] </ref>. We relate these pictures to TLA specifications by interpreting a predicate-action diagram as a TLA formula. A diagram denoting formula D is a correct description of a system with specification S iff (if and only if) S implies D.

References-found: 5

