URL: http://www.cs.arizona.edu/people/debray/papers/unboxopt.ps
Refering-URL: http://www.cs.arizona.edu/jc/
Root-URL: http://www.cs.arizona.edu
Title: A SIMPLE APPROACH TO SUPPORTING UNTAGGED OBJECTS IN DYNAMICALLY TYPED LANGUAGES  
Author: PETER A. BIGOT AND SAUMYA K. DEBRAY 
Note: J. LOGIC PROGRAMMING 1993:12:1-199 1  
Abstract: fl In many modern high-level programming languages, the exact low-level representation of data objects cannot always be predicted at compile time. Implementations usually get around this problem using descriptors ("tags") and/or indirect ("boxed") representations. However, the flexibility so gained can come at the cost of significant performance overheads. The problem is especially acute in dynamically typed languages, where both tagging and boxing are necessary in general. This paper discusses a straightforward approach to using untagged and unboxed values in dynamically typed languages. An implementation of our algorithms allows a dynamically typed language to attain performance close to that of highly optimized C code on a variety of benchmarks (including many floating-point intensive computations) and dramatically reduces heap usage. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. W. Appel, </author> <title> "Runtime tags aren't necessary", </title> <booktitle> Lisp and Symbolic Computation 2 </booktitle> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: In general, operating on values in languages such as these may involve manipulating tags and/or a level of indirection. It may be possible to avoid some of this extra work in clever implementations (e.g., tags can be elided in SML/NJ by relying on compiler-generated symbol table information <ref> [1] </ref>), or to encode the information in some clever way to reduce its cost (e.g., in common integer arithmetic operations in many Lisp systems (e.g., see [21]), and dereference operations in some Prolog systems [34, 35]). <p> The choice of how parameters for a procedure should be passed|in registers or in memory, and in tagged or untagged form|must be 2 This is not true of statically typed languages, however, and several authors have proposed tagless garbage collection schemes for statically typed languages (see, for example, <ref> [1, 17] </ref>). 9 made before any call to the procedure is generated, because it is necessary, for code generation, to know where to place inputs and where to expect outputs. The identification of arguments to a procedure that are eligible to be passed in untagged form proceeds as follows. <p> The problem of garbage collection in tagless implementations of such languages is discussed by a number of authors, including Appel <ref> [1] </ref> and Goldberg [17]. 7. Conclusions Most implementations of dynamically typed languages have historically suffered in comparison to statically typed languages because their very nature imposes overheads even when working with consistently and uniquely typed programs.
Reference: 2. <author> A. Appel, </author> <title> Compiling with Continuations, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: 3. <author> K. Appleby, M. Carlsson, S. Haridi and D. Sahlin, </author> <title> "Garbage Collection for Prolog based on WAM", </title> <journal> Communications of the ACM vol. </journal> <volume> 31 no. 6, </volume> <month> June </month> <year> 1988, </year> <pages> pp. 719-741. </pages> <publisher> ACM Press. </publisher>
Reference-contexts: be generated either as a lightweight parameterless function that is called from each point in a procedure where choice point manipulation occurs, or generated in-line 7 The garbage collector does not need to inspect the trail, since any variable recorded in the trail is also accessible from some choice point <ref> [3] </ref>. 21 at each such point, depending on the relative importance of code size vs. execution speed. It is also necessary to communicate information about the structure of choice points to the garbage collector: this can be done, as suggested above, via the symbol table of the procedure.
Reference: 4. <author> R. L. Bates, D. Dyer, and J. A. G. M. Koomen, </author> <title> "Implementation of Interlisp on the VAX", </title> <booktitle> Proc. 1982 ACM Symp. on Lisp and Functional Programming, </booktitle> <month> Aug. </month> <year> 1982, </year> <pages> pp. 81-87. </pages>
Reference-contexts: This figure would likely be much worse in numerical computations, because implementations of dynamically typed languages very often represent floating point numbers as boxed values (see, for example, <ref> [4, 7, 9] </ref>). This incurs a significant performance penalty, for a number of reasons. First, since floating point values are heap-allocated, numerical computations involving boxed floating point values fail to exploit hardware registers effectively, and generate a lot more memory traffic.
Reference: 5. <author> P. A. Bigot, D. Gudeman, and S. K. Debray, </author> <title> "Output Value Placement in Moded Logic Programs", </title> <booktitle> Proc. Eleventh International Conf. on Logic Programming, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 175-189. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: We use a cost-based model to decide whether a particular output should be returned in memory or in (tagged or untagged) registers <ref> [5] </ref>. 1 To meet the analysis requirements of Section 3.1 and allow the use of untagged registers for parameter passing requires a combination of mode analysis, which identifies the input and output arguments of a procedure; suspension analysis, which identifies procedures that can be guaranteed to not suspend during execution; and <p> This information is available under the assumptions in Section 2.1. 1 The discussion in <ref> [5] </ref> considers returns in memory and tagged registers only. Since then, we have extended our implementation, and the associated cost model, to handle untagged register returns as well. 6 Representation Analysis for a Program. 1. <p> Inter-Procedural Representation Analysis. 1. [Identification of Candidates for Untagged Representation] For each procedure p, use information obtained from mode, type, and non-suspension analyses to determine which arguments can be passed in untagged form. 2. [Determination of Argument Placements] Use the cost model of <ref> [5] </ref> to determine which output arguments should be returned in registers. 3. [Determination of Argument Representations] If an argument is a candidate for untagged representation (step (1)), and will be passed in a register (input arguments are always passed in registers; the passing of output arguments is determined in step (2)), <p> Representation Analysis Our representation analysis algorithm is summarized in Figure 1. First, inter-procedural representation analysis is used to determine how input and output arguments for each procedure will be passed. This uses a cost model, based on that described in <ref> [5] </ref>, to determine the representation and placement of output values. This fixes the representation of input and output parameters to each procedure, and therefore determines the representations of the corresponding variables in each clause for these procedures. <p> Our algorithm for representation optimization therefore relies, in a very fundamental way, on returning values in registers. 3.1. Inter-procedural Representation Analysis Previous research has indicated that returning values in registers rather than storing them into memory can have a significant impact on execution speed <ref> [5, 35] </ref>. Given that operations within the body of a procedure can be performed on untagged representations, this suggests that parameters should be passed and returned in untagged form as well where it is legitimate and profitable to do so. <p> Our current implementation passes input arguments in untagged form whenever these restrictions are satisfied. The representation of output values is determined using a low level cost model that is an extension of that described in <ref> [5] </ref>: if the cost model indicates that it is profitable to return an output argument in a register, and it is possible to return that argument in untagged form, then it is returned in an untagged register.
Reference: 6. <author> R. A. Brooks, R. P. Gabriel, and G. L. Steele Jr., </author> <title> "An Optimizing Compiler for Lexically Scoped Lisp", </title> <booktitle> Proc. SIGPLAN '82 Symp. on Compiler Construction, </booktitle> <month> June </month> <year> 1982, </year> <pages> pp. 261-275. </pages>
Reference-contexts: The problem of generating efficient numeric code for Lisp programs was considered as far back as the MacLisp compiler [30] and the S-1 Lisp compiler <ref> [6] </ref>. These systems used untagged representations for numbers in intra-procedural numerical computations, but used boxed (though not necessarily heap-allocated) values across procedure boundaries.
Reference: 7. <author> R. A. Brooks, R. P. Gabriel, and G. L. Steele, Jr., </author> <title> "S-1 Common Lisp Implementation", </title> <booktitle> Proc. 1982 ACM Symp. on Lisp and Functional Programming, </booktitle> <month> Aug. </month> <year> 1982, </year> <pages> pp. 108-113. </pages>
Reference-contexts: This figure would likely be much worse in numerical computations, because implementations of dynamically typed languages very often represent floating point numbers as boxed values (see, for example, <ref> [4, 7, 9] </ref>). This incurs a significant performance penalty, for a number of reasons. First, since floating point values are heap-allocated, numerical computations involving boxed floating point values fail to exploit hardware registers effectively, and generate a lot more memory traffic.
Reference: 8. <author> F. Bueno, D. Cabeza, M. Hermenegildo, and G. </author> <title> Puebla, "Data-flow Analysis of Standard Prolog Programs", </title> <booktitle> Proc. European Symposium on Programming, </booktitle> <month> April </month> <year> 1996, </year> <pages> pp. 108-124. </pages> <publisher> Springer-Verlag LNCS vol. </publisher> <pages> 1058. </pages>
Reference-contexts: The first problem can be handled using techniques for compositional and/or incremental program analysis <ref> [8, 12] </ref>. There are two alternatives for handling the second problem. <p> There are two alternatives for handling the second problem. If the different modules of a program are compiled and loaded in sequence, so that the code generated for one module is available while code is being generated for another module, then incremental optimization <ref> [8] </ref> using multiple entry points (see Section 3.1) can be used to avoid the overhead of passing tagged values across module boundaries where possible.
Reference: 9. <author> M. Carlsson, </author> <title> "The SICStus Prolog Emulator", </title> <type> Technical Report T91:15, </type> <institution> Swedish Institute of Computer Science, </institution> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: This figure would likely be much worse in numerical computations, because implementations of dynamically typed languages very often represent floating point numbers as boxed values (see, for example, <ref> [4, 7, 9] </ref>). This incurs a significant performance penalty, for a number of reasons. First, since floating point values are heap-allocated, numerical computations involving boxed floating point values fail to exploit hardware registers effectively, and generate a lot more memory traffic.
Reference: 10. <author> T. Chikayama, T. Fujise, and D. Sekita, </author> <title> "A Portable and Efficient Implementation of KL1", </title> <booktitle> Proc. Int. Symp. on Programming Language Implementation and Logic Programming, </booktitle> <month> Sept. </month> <year> 1994, </year> <pages> pp. 25-39 </pages>
Reference-contexts: Because Janus programs are compiled to C code which is then processed by a C compiler, most of the overall time for translation to the object code is spent in I/O operations and in the C compiler (other systems that compile to C, e.g., KLIC <ref> [10] </ref>, report similar experiences). As a result, there is no perceptible decrease in the overall compile time when dataflow analysis and optimizations are switched off. 5. Extensions The discussion thus far has not considered the question of backtracking, which is of fundamental importance in non-committed-choice logic programming languages, e.g, Prolog.
Reference: 11. <author> F. C. Chow and J. L. Hennessy, </author> <title> "The Priority-Based Coloring Approach to Register Allocation", </title> <journal> ACM Transactions on Programming Languages and Systems vol. </journal> <volume> 12 no. 4, </volume> <month> Oct. </month> <year> 1990, </year> <pages> pp. 501-536. </pages>
Reference-contexts: We believe that this conclusion extends also to larger programs, consisting of some components that are primarily numerical in nature and others that are primarily non-numerical. The reason for this is that modern register allocation algorithms (see, e.g., <ref> [11] </ref>) base their decisions on the relative usage counts of variables in different regions of a program: a variable that is heavily used in one region of a program, but not in another, will be considered for placement in a register in the first region but not in the second.
Reference: 12. <author> M. Codish, S. K. Debray, and R. Giacobazzi, </author> <title> "Compositional Analysis of Modular Logic Programs", </title> <booktitle> Proc. Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charlotte, SC, </address> <month> Jan. </month> <year> 1993, </year> <pages> pp. 451-464. 24 </pages>
Reference-contexts: The first problem can be handled using techniques for compositional and/or incremental program analysis <ref> [8, 12] </ref>. There are two alternatives for handling the second problem.
Reference: 13. <author> K. De Bosschere, S. K. Debray, D. Gudeman, and S. Kannan, </author> <title> "Call Forwarding: </title>
Reference-contexts: An alternative would be to generate multiple entry points for procedures that use untagged values, and use optimizations such as code hoisting and call forwarding <ref> [13] </ref> at link-time (see, e.g., [14, 29]) to redirect calls so as to avoid unnecessary tagging and untagging where possible. While these techniques can be used to avoid passing untagged values into a procedure, neither supports untagged return values in a straightforward way.
References-found: 13

