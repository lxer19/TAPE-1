URL: ftp://ftp.csd.uu.se/pub/papers/theses/0024.ps.gz
Refering-URL: http://www.csd.uu.se/papers/long-theses.html
Root-URL: 
Title: Denotational Semantics for Asynchronous Concurrent Languages  
Author: Sven-Olof Nystr om 
Date: 1996  
Address: UPPSALA  
Affiliation: Computing Science Department Uppsala University  
Note: UPPSALA THESES IN COMPUTING SCIENCE 24  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Samson Abramsky. </author> <title> Experiments, powerdomains and fully abstract models for applicative multiprogramming. </title> <booktitle> In Proc. Foundations of Computation Theory, volume 158 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: So, if Y = [2; 3] and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = <ref> [1; 2; 3] </ref>. As an example of a program that generates lists, we give the following definition. <p> The successive stores will contain stronger and stronger constraints for the value of X, as indicated by the sequence of constraints below. 9 Y (X = [1 j Y ]) 9 Y (X = <ref> [1; 1; 1 j Y ] </ref>) Note that the list is generated from the head, and that thus the initial part of the list is accessible before the list is completely generated. 3.9 A non-deterministic program In all examples above, the selections have been written so that no more than one <p> The `final' result is then the limit of these stores, i.e., the store in which the constraint X = <ref> [1; 1; 1; : : :] </ref> is entailed. It is worth considering what happens when we have several agents that produce infinite results. Consider, for example, an agent ones (X) ^ ones (Y ): Clearly, we want this agent to bind both X and Y to infinite lists of ones. <p> If the formulas of our language are inequalities such as the ones mentioned above, and we have one variable, X, the resulting constraint system will contain the elements in the diagram below, in which the elements are totally ordered by v. &gt; F <ref> [X &gt; 1] </ref> ? 4.2.2 Examples of constraint systems We give some simple examples of constraint systems. Note that in the presentation of a constraint system, it is sufficient to give the domain of values, the set of formulas and the truth assignment. <p> Let the agent A 1 be X = <ref> [1; 2; 3; 4] </ref>; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = [3; 4]): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in <p> Let the agent A 1 be X = [1; 2; 3; 4]; and the agent A 2 be 9 Y (X = <ref> [1; 2 j Y ] </ref> ^ Y = [3; 4]): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in two steps, so we would expect these two agents to have the same abstract <p> A typical trace of A 1 might be the trace t 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn <p> A 1 might be the trace t 1 , where v (t 1 ) = (?; X = [1; 2; 3; 4]; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = <ref> [1; 2 j Y ] </ref>); X = [1; 2; 3; 4]; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; <p> 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). <p> might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> One possible trace of a call copy (X; Y ) is one where X is first bound to a list of three elements, which are then copied to Y , i.e., the trace t where v (t) 0 = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] <p> is one where X is first bound to a list of three elements, which are then copied to Y , i.e., the trace t where v (t) 0 = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2; 3 j Y 1 ]); for i 4, <p> which are then copied to Y , i.e., the trace t where v (t) 0 = (9 X 1 X = [1; 2; 3 j X 1 ]) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = <ref> [1; 2 j Y 1 ] </ref>) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2; 3 j Y 1 ]); for i 4, We find that in t = out t = 123, and dfn t <p> = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2; 3 j Y 1 ]); for i 4, We find that in t = out t = 123, and dfn t is the least continuous function f : D ! D such that f (123) w <p> v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = <ref> [1; 2; 3 j Y 1 ] </ref>); for i 4, We find that in t = out t = 123, and dfn t is the least continuous function f : D ! D such that f (123) w 123. t u 6.6.2 Merge The set of traces for the merge node
Reference: [2] <author> Samson Abramsky. </author> <title> Semantic foundations of applicative multiprogramming. </title> <booktitle> In Proc. ICALP '83, volume 154 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-14. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: A list of n elements can be written [X 1 ; X 2 ; : : : ; X n ], where X 1 is the first element and so on. So, if Y = <ref> [2; 3] </ref> and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = [1; 2; 3]. As an example of a program that generates lists, we give the following definition. <p> So, if Y = <ref> [2; 3] </ref> and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = [1; 2; 3]. As an example of a program that generates lists, we give the following definition. <p> So, if Y = [2; 3] and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = <ref> [1; 2; 3] </ref>. As an example of a program that generates lists, we give the following definition. <p> Let the agent A 1 be X = <ref> [1; 2; 3; 4] </ref>; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = [3; 4]): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in <p> A typical trace of A 1 might be the trace t 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn <p> 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). <p> might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> One possible trace of a call copy (X; Y ) is one where X is first bound to a list of three elements, which are then copied to Y , i.e., the trace t where v (t) 0 = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] <p> is one where X is first bound to a list of three elements, which are then copied to Y , i.e., the trace t where v (t) 0 = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2; 3 j Y 1 ]); for i 4, <p> = (9 X 1 X = <ref> [1; 2; 3 j X 1 ] </ref>) v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2; 3 j Y 1 ]); for i 4, We find that in t = out t = 123, and dfn t is the least continuous function f : D ! D such that f (123) w <p> v (t) 2 = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = [1; 2 j Y 1 ]) v (t) i = (9 X 1 X = [1; 2; 3 j X 1 ] ^ 9 Y 1 Y = <ref> [1; 2; 3 j Y 1 ] </ref>); for i 4, We find that in t = out t = 123, and dfn t is the least continuous function f : D ! D such that f (123) w 123. t u 6.6.2 Merge The set of traces for the merge node <p> We thus obtain a simple programming language with the notation of context-free grammars, and an operational semantics which is close to the standard rules of context-free grammars. 7.2 Related Work It is well known that many non-deterministic languages do not have a continuous fully abstract fixpoint semantics. Abramsky <ref> [2] </ref> considered a simple non-deterministic language similar to the one examined in this and showed that there could be no continuous fully abstract fixpoint semantics. <p> Lehmann gave a powerdomain construction for !-categories in which each set can be represented. However, the construction is based on multi-sets, which means that there may be many non-isomorphic representations of the same set. The powerdomain construction has previously been used by Abramsky <ref> [2] </ref>, Panangaden and Russell [61], and Nystrom and Jonsson [58] to model various forms of indeterminacy. It is straight-forward to adapt the proof of Theorem 7.5.3 to show that there can be no fully abstract fixpoint semantics based on !-categories for our language. <p> For example, Abramsky notes (<ref> [2] </ref>, page 4) that his category-theoretic semantics can not be fully abstract. 7.8 Conclusions We have generalised the negative results of Abramsky [2] concerning fully abstract fixpoint semantics for non-deterministic languages to hold for a wide range of semantic models, in particular to non-continuous fixpoint semantics over partial orders and semantics based on continuous functions over categories. <p> The negative result is of some interest in itself since the language under consideration is no longer non-deterministic. Thus this negative result is of a different nature than other published negative results on the existence of fully abstract fixpoint semantics <ref> [2, 4] </ref> since they considered nondeterministic programming languages. 9.3 Hiding Because of the discovery that it is not possible to give a fully abstract semantics for agent-oracle pairs, we turn to a less abstract domain in which the local state of a computation is included in the semantics. <p> This powerdomain construction has previously been used by Abramsky <ref> [2] </ref>, Panangaden and Russel [61], Nystrom and Jonsson [58], and de Boer, Di Piero and Palamidessi [24] to give the fixpoint semantics of various forms of nondeterministic programming languages. Lehmann's construction relies on a special type of categories called !- categories.
Reference: [3] <author> Samson Abramsky and Stephen Vickers. Quantales, </author> <title> observational logic, and process semantics. </title> <type> Technical Report DOC 90/1, </type> <institution> Imperial College, Dept. of Computing, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: A list of n elements can be written [X 1 ; X 2 ; : : : ; X n ], where X 1 is the first element and so on. So, if Y = <ref> [2; 3] </ref> and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = [1; 2; 3]. As an example of a program that generates lists, we give the following definition. <p> A list of n elements can be written [X 1 ; X 2 ; : : : ; X n ], where X 1 is the first element and so on. So, if Y = [2; 3] and X = 1 it follows that [X j Y ] = <ref> [1 j [2; 3] </ref>] = [1; 2; 3]. As an example of a program that generates lists, we give the following definition. <p> So, if Y = <ref> [2; 3] </ref> and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = [1; 2; 3]. As an example of a program that generates lists, we give the following definition. <p> So, if Y = [2; 3] and X = 1 it follows that [X j Y ] = [1 j [2; 3]] = <ref> [1; 2; 3] </ref>. As an example of a program that generates lists, we give the following definition. <p> Suppose that C is bound to the list [push (3); push (5) j C 1 ]. The call to `stack' will recurse twice and then suspend on the variable C 1 . The internal state of the call, i.e., the second argument, i.e., the stack, is now the list <ref> [5; 3] </ref>. If C 1 is now bound to the list [pop (X) j C 2 ], the top element of the stack (5) will be popped off the stack and set to be equal to X. <p> Let the agent A 1 be X = <ref> [1; 2; 3; 4] </ref>; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = [3; 4]): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in <p> Let the agent A 1 be X = [1; 2; 3; 4]; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = <ref> [3; 4] </ref>): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in two steps, so we would expect these two agents to have the same abstract semantics. <p> A typical trace of A 1 might be the trace t 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn <p> 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). <p> might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> Other attempts to relate algebraic rules and concurrency include the work by Bergstra and Klop [7], in which algebraic rules were used to define a concurrent language, and Winskel and Nielsen [83], who relate different models of concurrency by examining their category-theoretic properties. Abramsky and Vickers <ref> [3] </ref> propose the use of quantales as a framework for the study of various aspects of concurrency. (The algebra of quantales is closely related to intuitionistic linear algebra.) We begin by giving the axiomatic definition of intuitionistic linear algebra, following Troelstra [79].
Reference: [4] <author> K. R. Apt and G. D. Plotkin. </author> <title> Countable nondeterminism and random assignment. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 724-767, </pages> <month> October </month> <year> 1986. </year> <note> First published as technical report, </note> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1982. </year>
Reference-contexts: Let the agent A 1 be X = <ref> [1; 2; 3; 4] </ref>; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = [3; 4]): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in <p> Let the agent A 1 be X = [1; 2; 3; 4]; and the agent A 2 be 9 Y (X = [1; 2 j Y ] ^ Y = <ref> [3; 4] </ref>): The two agents produce the same result, and there is no way a concurrently executing agent could see that the agent A 2 produces the list in two steps, so we would expect these two agents to have the same abstract semantics. <p> A typical trace of A 1 might be the trace t 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn <p> 1 , where v (t 1 ) = (?; X = <ref> [1; 2; 3; 4] </ref>; : : :) and a typical trace of A 2 might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = [1; 2; 3; 4]; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). <p> might be the trace t 2 , where v (t 2 ) = (?; 9 Y (X = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> = [1; 2 j Y ]); X = <ref> [1; 2; 3; 4] </ref>; : : :) We also see that fn (t 1 ) = fn (t 2 ) = (? ! X = [1; 2; 3; 4]), and lim (t 1 ) = lim (t 2 ) = (X = [1; 2; 3; 4]). The two traces have the same functionality and limit and are thus subtraces of each other. <p> Abramsky [2] considered a simple non-deterministic language similar to the one examined in this and showed that there could be no continuous fully abstract fixpoint semantics. Apt and Plotkin <ref> [4] </ref> considered an imperative programming language with unbounded non-determinism and while-loops and showed that there could be no continuous fully abstract fixpoint semantics. However, they were able to give a fully abstract least fixpoint semantics by giving up the requirement that the semantic functions should be continuous. <p> In contrast, the results of Apt and Plotkin <ref> [4] </ref> regarding a type of imperative programming languages with unbounded nondeter-minism (that is, a nondeterministic assignment statement that can assign a variable any positive integer) ruled out any continuous semantics but for this type of language it was still possible to give a fully abstract non-continuous fixpoint semantics. <p> The negative result is of some interest in itself since the language under consideration is no longer non-deterministic. Thus this negative result is of a different nature than other published negative results on the existence of fully abstract fixpoint semantics <ref> [2, 4] </ref> since they considered nondeterministic programming languages. 9.3 Hiding Because of the discovery that it is not possible to give a fully abstract semantics for agent-oracle pairs, we turn to a less abstract domain in which the local state of a computation is included in the semantics.
Reference: [5] <author> Joe Armstrong, Robert Virding, and Mike Williams. </author> <title> Concurent Programming in ERLANG. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: Suppose that C is bound to the list [push (3); push (5) j C 1 ]. The call to `stack' will recurse twice and then suspend on the variable C 1 . The internal state of the call, i.e., the second argument, i.e., the stack, is now the list <ref> [5; 3] </ref>. If C 1 is now bound to the list [pop (X) j C 2 ], the top element of the stack (5) will be popped off the stack and set to be equal to X.
Reference: [6] <author> Geoff Barret. </author> <title> The fixed point theory of unbounded non-determinism. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3 </volume> <pages> 110-128, </pages> <year> 1991. </year>
Reference-contexts: In other words, to define a fixpoint semantics it is sufficient to have semantic functions that are monotone. This approach has been applied in some recent papers, see for example Barrett <ref> [6] </ref>. A related approach was presented by Roscoe [67]. The main differences between the language we consider, and the one Apt and Plotkin examined are that our language allows arbitrary recursion and infinite computations, but not unbounded non-determinism.
Reference: [7] <author> J. A. Bergstra and J. W. Klop. </author> <title> Process algebra for synchronous communication. </title> <journal> Information and Control, </journal> <volume> 60 </volume> <pages> 109-137, </pages> <year> 1984. </year>
Reference-contexts: Thus, proving that ccp is a hyperdoctrine implies that ccp in fact forms a logic. The authors of reference [52] stress the point; ccp is logic. Other attempts to relate algebraic rules and concurrency include the work by Bergstra and Klop <ref> [7] </ref>, in which algebraic rules were used to define a concurrent language, and Winskel and Nielsen [83], who relate different models of concurrency by examining their category-theoretic properties.
Reference: [8] <author> Per Brinch Hansen. </author> <title> The nucleus of a multiprogrammed system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-250, </pages> <month> April </month> <year> 1970. </year>
Reference-contexts: A data flow program is a directed graph where the nodes are computational elements (processes) and the edges are communication channels. In the computational models described by Brinch Hansen <ref> [8] </ref> and Kahn [37] the nodes are imperative programs with explicit computational actions, but as Kahn points out, the nodes (which in his model are always deterministic) can be seen as continuous functions from input to output.
Reference: [9] <author> J. Dean Brock and William B. Ackerman. </author> <title> Scenarios: a model of non-determinate computation. </title> <editor> In Diaz and Ramos, editors, </editor> <booktitle> Formalization of Programming Concepts, LNCS 107, volume 107 of Lecture Notes in Computer Science, </booktitle> <pages> pages 252-259. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [10] <author> Jarvis Dean Brock. </author> <title> A Formal Model of Non-determinate Dataflow Computation. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1983. </year> <note> 175 176 references </note>
Reference: [11] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <year> 1984. </year>
Reference: [12] <author> S. D. Brookes and A. W. Roscoe. </author> <title> An improved failures model for communicating processes. </title> <editor> In Brookes, Roscoe, and Winskel, editors, </editor> <booktitle> Proc. Seminar on Concurrency, 1984, volume 197 of Lecture Notes in Computer Science, </booktitle> <pages> pages 268-280. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [13] <author> Stephen Brookes. </author> <title> Full abstraction for a shared variable parallel language. </title> <booktitle> In Proc. 8 th IEEE Int. Symp. on Logic in Computer Science, </booktitle> <pages> pages 98-109, </pages> <year> 1993. </year>
Reference-contexts: There are many examples of denotational semantics for languages which satisfy three of the four properties listed above. For example, Kahn's semantics [37] treats infinite computation and arbitrary recursion but does not allow non-determinism. Brookes <ref> [13] </ref> gives a fully abstract fixpoint semantics of an imperative non-deterministic language with shared variables. The semantic model also allows infinite traces and is thus able to adequately model the behaviour of infinitely running processes. However, recursion is not dealt with.
Reference: [14] <author> Manfred Broy. </author> <title> A theory for nondeterminism, parallelism, </title> <journal> communication, and concurrency. Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 1-61, </pages> <year> 1986. </year>
Reference-contexts: than one reference to the stack object we must use a merge agent and write, for example, stack (C; []); merge (C 1 ; C 2 ; C) to allow two agents to communicate with the stack. 3.15 Unbounded Nondeterminism The last example is inspired by Park [64] and Broy <ref> [14] </ref>, who showed that in a language with non-determinism and some fairness notion it was possible to write a program that exhibits unbounded non-determinism.
Reference: [15] <author> J. M. Cadiou and J. J. Levy. </author> <title> Mechanizable proofs about parallel processes. </title> <booktitle> In Switching and Automata Theory Symposium, </booktitle> <volume> volume 14, </volume> <pages> pages 34-48. </pages> <publisher> IEEE, </publisher> <year> 1973. </year>
Reference-contexts: The fixpoint semantics becomes quite simple, even though both fairness and infinite computations are taken into account. 119 120 chapter 8. oracle semantics 8.1 Related Work Many authors have used oracles to give the semantics of non-deterministic concurrent languages. For example, Cadiou and Levy <ref> [15] </ref> gave the operational semantics of a parallel imperative language in which the scheduling of processes was determined by an oracle. Milner [53] gave an operational model of a non-deterministic language in which oracles were used to determine non-deterministic choices.
Reference: [16] <author> Bjorn Carlson. </author> <title> An Approximation Theory for Constraint Logic Programs. Thesis for the Degree of Licientiate of Philosophy, </title> <institution> Uppsala University, </institution> <year> 1991. </year>
Reference-contexts: The use of ideal completion to construct a constraint system that is closed under infinite limits has previously been employed by Carlson <ref> [16] </ref> and Kwiatkowska [43].
Reference: [17] <author> Keith Clark and Steve Gregory. </author> <title> A relational language for parallel programming. </title> <booktitle> In ACM conference on Functional Programming and computer architecture, </booktitle> <pages> pages 171-178. </pages> <publisher> ACM, </publisher> <year> 1981. </year>
Reference: [18] <author> Keith Clark and Steve Gregory. </author> <title> Parlog: Parallel programming in logic. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <year> 1986. </year>
Reference: [19] <author> William Douglas Clinger. </author> <title> Foundations of Actor Semantics. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> May </month> <year> 1981. </year>
Reference: [20] <author> Rina S. Cohen and Arie Y. Gold. </author> <title> Theory of !-languages. I: Characterizations of !-context-free languages. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 15 </volume> <pages> 169-184, </pages> <year> 1977. </year>
Reference-contexts: To obtain a suitable operational semantics we will extend the set of derivations of a grammar to also allow infinite derivations. The following presentation is based on Cohen and Gold <ref> [20] </ref>. 7.4.1 Generation of infinite words Let N be an infinite set of non-terminals and T be an infinite set of terminals.
Reference: [21] <author> J. W. de Bakker and J. N. Kok. </author> <title> Uniform abstraction. atomicity and contractions in the comparative semantics of concurrent Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 347-355. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference: [22] <author> F. S. de Boer, J. N. Kok, C. Palamidessi, and J. J. M. M. Rutten. </author> <title> The failure of failures in a paradigm for asynchronous communication. </title> <booktitle> In Proceedings of CONCUR'91, number 527 in Lecture Notes in Computer Science, </booktitle> <pages> pages 111-126. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> references 177 </note>
Reference: [23] <author> Frank S. de Boer and Catuscia Palamidessi. </author> <title> A fully abstract model for concurrent constraint programming. </title> <booktitle> In Proceedings of the International Joint Conference on Theory and Practice of Software Development, number 493 in Lecture Notes in Computer Science, </booktitle> <pages> pages 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [24] <author> Frank S. de Boer, Alessandra Di Pierro, and Catuscia Palamidessi. </author> <title> Nondeterminism and infinite computations in constraint programming. </title> <journal> Theoretical Computer Science, </journal> <volume> 151 </volume> <pages> 36-78, </pages> <year> 1995. </year>
Reference-contexts: This powerdomain construction has previously been used by Abramsky [2], Panangaden and Russel [61], Nystrom and Jonsson [58], and de Boer, Di Piero and Palamidessi <ref> [24] </ref> to give the fixpoint semantics of various forms of nondeterministic programming languages. Lehmann's construction relies on a special type of categories called !- categories. Definition 9.8.1 An !-category is a category which has an initial object and in which all !-chains have colimits.
Reference: [25] <author> Jack B. Dennis. </author> <title> First version of a data flow procedure language. </title> <type> Technical Report 61, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1975. </year> <note> First published in B. </note> <editor> Robinet (ed), </editor> <booktitle> Programming Symposium: Proceedings Colloque sur la Programmation, Lecture Notes in Computer Science 19, </booktitle> <month> April </month> <year> 1974., </year> <pages> 362-376. </pages>
Reference-contexts: In the computational models described by Brinch Hansen [8] and Kahn [37] the nodes are imperative programs with explicit computational actions, but as Kahn points out, the nodes (which in his model are always deterministic) can be seen as continuous functions from input to output. Dennis <ref> [25] </ref> presented a style of data flow programming with a small, predefined set of nodes. The language defines a small set of nodes, from which the programmer is supposed to construct programs; it is not possible to invent new nodes. <p> 9 N 9 X 1 (X = [N jX 1 ]^ F 0 (N; X; Y ) :: 9 M 9 X 1 9 Y 1 (X = [M jX 1 ]^ F 0 (M; X 1 ; Y 1 ))) In the model of data flow described by Dennis <ref> [25] </ref>, the program example we have been looking at can be assembled from the following primitive nodes. First, we need a node duplicate that reads input from a channel and sends it to its two output channels (Figure 6.1 (a)).
Reference: [26] <author> E. W. Dijkstra. </author> <title> Co-operating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year> <note> First published as Technical Report EWD-123, </note> <institution> Technological University, Eindhoven, </institution> <year> 1965. </year>
Reference: [27] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> A practical programming tool. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> North American Conference on Logic Programming, </booktitle> <pages> pages 497-512. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: [28] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: introduction to Strand <ref> [28] </ref>. In the examples, we will say that a variable is bound to a value if the constraints in the store imply that the variable should have that particular value.
Reference: [29] <author> G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislowe, and D. S. Scott. </author> <title> A Compendium of Continuous Lattices. </title> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: In the constraint programming language given in next section, we will assume all ask and tell constraints to be finite. Thus, it is worthwhile to take a closer look at the finite constraints. Proposition 4.2.5 <ref> [29, Proposition 4.12 (ii)] </ref> The finite constraints are exactly those constraints that can be given in the form [], for some formula . Proof. () Let be a formula. We will show that [] is finite. Let R be a directed set such that F R w []. <p> This idea was explored in a concurrent constraint programming setting by Saraswat, Rinard, and Panangaden [71]. This section gives the definition of closure operators and some of their properties. See reference <ref> [29] </ref> for further results on closure operators. Let us look at an agent as a function f that takes a store as input, and returns a new store.
Reference: [30] <editor> Leon Henkin, J. Donald Monk, and Alfred Tarski. Cylindric Algebras, </editor> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: Given this, we use ideal completion to derive the desired 4.2. constraints 47 domain. The resulting structure satisfies all axioms of cylindric algebra <ref> [30] </ref> that do not involve negation. In contrast, Saraswat et al. [71] choose an axiomatic approach, based on axioms from cylindric algebra and techniques from Scott's information systems [72] to specify the properties of a constraint system. <p> It should not come as a surprise that the operations defined over the domain of constraints (existential quantification, equality, and least upper bound, i.e., conjunction) satisfy a number of algebraic properties. These properties correspond largely to the axioms of cylindric algebra <ref> [30] </ref>. Proposition 4.2.9 Given a pre-constraint system hF; Var; j=; Ci, let the lattice hU; vi be the corresponding domain of constraints, with ? and &gt; 52 chapter 4. formal definition of ccp the least and greatest elements of U .
Reference: [31] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-676, </pages> <month> August </month> <year> 1978. </year>
Reference: [32] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference: [33] <author> Radha Jagadeesan, Keshav Pingali, and Prakash Panangaden. </author> <title> A fully abstract semantics for a functional programming language with logic variables. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 577-625, </pages> <month> October </month> <year> 1991. </year> <note> Also in Proceedings of the IEEE Symposium on Logic in Computer Science 1989. 178 references </note>
Reference-contexts: The definition of closure operators and some of their properties will be given in the following part of this section. In the final part of this section we will briefly review the semantics of determinate ccp. 4.6.1 Closure operators Jagadeesan, Panangaden and Pingali <ref> [33] </ref> showed how a concurrent process operating over a domain that allows `logic variables', i.e., place holders for values that are to be defined later, could be viewed as a closure operator. This idea was explored in a concurrent constraint programming setting by Saraswat, Rinard, and Panangaden [71].
Reference: [34] <author> Bengt Jonsson. </author> <title> A model and proof system for asynchronous networks. </title> <booktitle> In Proc. 4 th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 49-58, </pages> <address> Minaki, Canada, </address> <year> 1985. </year>
Reference: [35] <author> Bengt Jonsson. </author> <title> A fully abstract trace model for dataflow and asynchronous networks. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 197-212, </pages> <year> 1994. </year>
Reference-contexts: Since all fully abstract semantics for a programming language are, in a sense, isomorphic, it follows that the semantics presented here must be equivalent to the ones presented by Kok [40] and Jonsson <ref> [35] </ref>. However, the formulation here involves only two aspects of a trace, the limit of its input and output, and its functionality. In contrast, Kok's and Jonsson's models explicitly treats traces as sequences of communication events.
Reference: [36] <author> Mark B. Josephs. </author> <title> Receptive process theory. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 17-31, </pages> <year> 1992. </year>
Reference: [37] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <booktitle> In Proceedings of IFIP Congress, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference-contexts: However, as shown by Saraswat, Rinard, and Panangaden [71], it turns out 4.6. closure operators and deterministic programs 63 that the agents may be represented as functions with some special properties, and that the meaning of programs may be obtained as simple fixpoints, as in Kahn's semantics <ref> [37] </ref>. The functions which represent deterministic ccp programs are called closure operators. The definition of closure operators and some of their properties will be given in the following part of this section. <p> A data flow program is a directed graph where the nodes are computational elements (processes) and the edges are communication channels. In the computational models described by Brinch Hansen [8] and Kahn <ref> [37] </ref> the nodes are imperative programs with explicit computational actions, but as Kahn points out, the nodes (which in his model are always deterministic) can be seen as continuous functions from input to output. Dennis [25] presented a style of data flow programming with a small, predefined set of nodes. <p> The language in this paper is also simpler since it is not a regular programming language and has no state or value-passing etc. There are many examples of denotational semantics for languages which satisfy three of the four properties listed above. For example, Kahn's semantics <ref> [37] </ref> treats infinite computation and arbitrary recursion but does not allow non-determinism. Brookes [13] gives a fully abstract fixpoint semantics of an imperative non-deterministic language with shared variables. The semantic model also allows infinite traces and is thus able to adequately model the behaviour of infinitely running processes.
Reference: [38] <author> Peter Kearney and John Staples. </author> <title> An extensional fixed-point semantics for nondeterministic data flow. </title> <journal> Theoretical Computer Science, </journal> <volume> 91 </volume> <pages> 129-179, </pages> <year> 1991. </year>
Reference-contexts: Milner [53] gave an operational model of a non-deterministic language in which oracles were used to determine non-deterministic choices. Keller [39], Kearney and Staples <ref> [38] </ref> and Russel [69] have presented fixpoint semantics of various non-deterministic languages in which choices are determined by an oracle.
Reference: [39] <author> Robert M. Keller. </author> <title> Denotational models for parallel programs with indeterminate operators. </title> <editor> In Neuhold, editor, </editor> <booktitle> Formal Descriptions of Programming Concepts, </booktitle> <pages> pages 337-366. </pages> <publisher> North-Holland, </publisher> <year> 1978. </year>
Reference-contexts: For example, Cadiou and Levy [15] gave the operational semantics of a parallel imperative language in which the scheduling of processes was determined by an oracle. Milner [53] gave an operational model of a non-deterministic language in which oracles were used to determine non-deterministic choices. Keller <ref> [39] </ref>, Kearney and Staples [38] and Russel [69] have presented fixpoint semantics of various non-deterministic languages in which choices are determined by an oracle.
Reference: [40] <author> Joost N. Kok. </author> <title> A fully abstract semantics for data flow nets. </title> <booktitle> In Proc. PARLE, volume 259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 351-368. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Since all fully abstract semantics for a programming language are, in a sense, isomorphic, it follows that the semantics presented here must be equivalent to the ones presented by Kok <ref> [40] </ref> and Jonsson [35]. However, the formulation here involves only two aspects of a trace, the limit of its input and output, and its functionality. In contrast, Kok's and Jonsson's models explicitly treats traces as sequences of communication events.
Reference: [41] <author> Paul R. Kosinski. </author> <title> A straight-forward denotational semantics for nonde-terminate data flow programs. </title> <booktitle> In Proc. 5 th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 214-219, </pages> <year> 1978. </year>
Reference: [42] <author> Paul Roman Kosinski. </author> <title> Denotational semantics of determinate and Nondeterminate Data Flow Programs. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> May </month> <year> 1979. </year>
Reference: [43] <author> Marta Kwiatkowska. </author> <title> Infinite behaviour and fairness in concurrent constraint programming. In Semantics: </title> <booktitle> Foundations and Applications, volume 666 of Lecture Notes in Computer Science, </booktitle> <pages> pages 348-383. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The use of ideal completion to construct a constraint system that is closed under infinite limits has previously been employed by Carlson [16] and Kwiatkowska <ref> [43] </ref>.
Reference: [44] <author> P. J. Landin. </author> <title> A correspondence between ALGOL 60 and Church's lambda notation: Part I. </title> <journal> Communications of the ACM, </journal> <volume> 8(2) </volume> <pages> 89-101, </pages> <month> February </month> <year> 1965. </year>
Reference: [45] <editor> F. William Lawvere. </editor> <booktitle> Adjointness in foundations. Dialectica, </booktitle> 23(3/4):281-296, 1969. 
Reference-contexts: The work presented in this section is influenced by the results of Mendler, Panangaden, Scott and Seely [52], who show that a semantic model of con 88 chapter 5. a fully abstract semantics for ccp current constraint programming forms a hyperdoctrine <ref> [45, 73] </ref>, a category-theoretic structure which represents the proof-theoretic structure of logics. Thus, proving that ccp is a hyperdoctrine implies that ccp in fact forms a logic. The authors of reference [52] stress the point; ccp is logic.
Reference: [46] <author> Daniel J. Lehmann. </author> <title> Categories for fixed-point semantics. </title> <booktitle> In 17th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 122-126, </pages> <year> 1976. </year> <note> references 179 </note>
Reference-contexts: when comparing different elements of the domain it must be possible to determine for each element the outcome of a particular sequence of choices. 7.7 Application to category-theoretic domains As an alternative to the use of semantic domains based on various partial orders, such as complete lattices and cpo's, Lehmann <ref> [46, 47] </ref> proposed a class of categories called !-categories. An !-category is a category which has an initial object and where !-colimits exist. An !-functor is a functor which is continuous with respect to !-colimits. It follows that each !- functor has an initial fixpoint. <p> By Theo rem 8.7.1 the two computations can be combined into a fair computation with functionality at least as strong as fn t and limit equal to lim t. t u 9.8 Category-theoretic semantics In this section, we will use a powerdomain construction by Lehmann <ref> [46, 47] </ref> to devise a fixpoint semantics which is more abstract than the oracle-based fixpoint semantics.
Reference: [47] <author> Daniel J. Lehmann. </author> <title> Categories for Fixed-point Semantics. </title> <type> PhD thesis, </type> <institution> Hebrew University of Jerusalem, </institution> <year> 1976. </year>
Reference-contexts: when comparing different elements of the domain it must be possible to determine for each element the outcome of a particular sequence of choices. 7.7 Application to category-theoretic domains As an alternative to the use of semantic domains based on various partial orders, such as complete lattices and cpo's, Lehmann <ref> [46, 47] </ref> proposed a class of categories called !-categories. An !-category is a category which has an initial object and where !-colimits exist. An !-functor is a functor which is continuous with respect to !-colimits. It follows that each !- functor has an initial fixpoint. <p> By Theo rem 8.7.1 the two computations can be combined into a fair computation with functionality at least as strong as fn t and limit equal to lim t. t u 9.8 Category-theoretic semantics In this section, we will use a powerdomain construction by Lehmann <ref> [46, 47] </ref> to devise a fixpoint semantics which is more abstract than the oracle-based fixpoint semantics. <p> We will also need the following result regarding the construction of !- functors, which is by Lehmann <ref> [47] </ref>. Given a continuous function f : D 1 ! D 2 , define the operation ^ f as follows.
Reference: [48] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <booktitle> In 4th International Conference on Logic Programming, </booktitle> <pages> pages 858-876. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [49] <author> Kim Marriott and Martin Odersky. </author> <title> A confluent calculus for concurrent constraint programming with guarded choice. </title> <booktitle> In Proceedings of 1st Conference on Principles and Practice of Constraint Programming, volume 976 of Lecture Notes in Computer Science, </booktitle> <pages> pages 310-327, </pages> <address> Cas-sis, France, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: However, in all these models the choice was assumed to be independent of input, i.e., the languages in question do not allow the definition of a merge operator which is fair when the incoming data is finite. Marriott and Odersky <ref> [49] </ref> gave a confluence result of a concurrent constraint programming language in which the syntax had been extended to allow a representation of the branching structure of non-deterministic programs.
Reference: [50] <author> David May. </author> <title> Occam. </title> <journal> SIGPLAN Notices, </journal> <volume> 18(4) </volume> <pages> 69-79, </pages> <month> April </month> <year> 1983. </year>
Reference: [51] <author> John McCarthy. </author> <title> A basis for a mathematical theory of computation. </title> <editor> In P. Brafford and D. Hirschberg, editors, </editor> <booktitle> Computer Programming and Formal Systems, </booktitle> <pages> pages 33-70. </pages> <publisher> North-Holland, </publisher> <year> 1967. </year> <note> An earlier version was presented at the Western Joint Computer Conference, </note> <month> May </month> <year> 1961. </year>
Reference-contexts: mccarthy's ambiguity operator 39 3.10 McCarthy's ambiguity operator We can give a more interesting example of a non-deterministic procedure definition. amb (X; Y; Z) :: (number (X) ) Z = X [] number (Y ) ) Z = Y ) The amb procedure, which is inspired by McCarthy's ambiguity operator <ref> [51] </ref> waits until either the first or the second argument is instantiated to a number, and then sets the third argument equal to the one of the two first that was defined.
Reference: [52] <author> Nax Paul Mendler, Prakash Panangaden, P. J. Scott, and R. A. G. Seely. </author> <title> A logical view of concurrent constraint programming. </title> <journal> Nordic Journal of Computing, </journal> <volume> 2(2) </volume> <pages> 181-220, </pages> <month> Summer </month> <year> 1995. </year>
Reference-contexts: The work presented in this section is influenced by the results of Mendler, Panangaden, Scott and Seely <ref> [52] </ref>, who show that a semantic model of con 88 chapter 5. a fully abstract semantics for ccp current constraint programming forms a hyperdoctrine [45, 73], a category-theoretic structure which represents the proof-theoretic structure of logics. <p> Thus, proving that ccp is a hyperdoctrine implies that ccp in fact forms a logic. The authors of reference <ref> [52] </ref> stress the point; ccp is logic. Other attempts to relate algebraic rules and concurrency include the work by Bergstra and Klop [7], in which algebraic rules were used to define a concurrent language, and Winskel and Nielsen [83], who relate different models of concurrency by examining their category-theoretic properties.
Reference: [53] <author> Robin Milner. </author> <title> Processes: A mathematical model of computing agents. </title> <booktitle> In in Logic Colloquium 1973, </booktitle> <pages> pages 157-173. </pages> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: For example, Cadiou and Levy [15] gave the operational semantics of a parallel imperative language in which the scheduling of processes was determined by an oracle. Milner <ref> [53] </ref> gave an operational model of a non-deterministic language in which oracles were used to determine non-deterministic choices. Keller [39], Kearney and Staples [38] and Russel [69] have presented fixpoint semantics of various non-deterministic languages in which choices are determined by an oracle.
Reference: [54] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference: [55] <author> E. Morenoff and J. B. McLean. </author> <title> Inter-program communications, program string structures, and buffer files. </title> <booktitle> In Proceedings of the AFIPS Spring Joint Computer Conference, </booktitle> <pages> pages 175-183, </pages> <year> 1967. </year>
Reference: [56] <author> M. Nivat. </author> <title> Infinite words, infinite trees, infinite computations. </title> <editor> In J.W. de Bakker and J. van Leeuven, editors, </editor> <booktitle> Foundations of Computer Science III, Mathematical Centre Tracts 109, </booktitle> <pages> pages 3-52. </pages> <publisher> Matematisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: He gives a fully abstract fixpoint semantics but does not consider infinite computations. The language we consider is based on context-free grammars. The difference is mainly that we consider strings generated by infinite left-most derivations. This very simple model of non-deterministic computation has previously been studied by Nivat <ref> [56] </ref> and Poigne [66]. 7.3 Relevance and significance Why look at the semantics of non-deterministic and non-terminating programs? These programs have a simple operational behaviour, and one would expect the same to hold for their fixpoint semantics.
Reference: [57] <author> Sven-Olof Nystrom. </author> <title> Control structures for Guarded Horn Clauses. </title> <booktitle> In Fifth International Conference Symposium on Logic Programming, </booktitle> <pages> pages 1351-1370, </pages> <year> 1988. </year>
Reference: [58] <author> Sven-Olof Nystrom and Bengt Jonsson. </author> <title> Indeterminate concurrent constraint programming: a fixpoint semantics for non-terminating computations. </title> <booktitle> In Proceedings of the 1993 International Logic Programming Symposium, </booktitle> <pages> pages 335-352. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year> <note> 180 references </note>
Reference-contexts: However, the construction is based on multi-sets, which means that there may be many non-isomorphic representations of the same set. The powerdomain construction has previously been used by Abramsky [2], Panangaden and Russell [61], and Nystrom and Jonsson <ref> [58] </ref> to model various forms of indeterminacy. It is straight-forward to adapt the proof of Theorem 7.5.3 to show that there can be no fully abstract fixpoint semantics based on !-categories for our language. <p> This powerdomain construction has previously been used by Abramsky [2], Panangaden and Russel [61], Nystrom and Jonsson <ref> [58] </ref>, and de Boer, Di Piero and Palamidessi [24] to give the fixpoint semantics of various forms of nondeterministic programming languages. Lehmann's construction relies on a special type of categories called !- categories.
Reference: [59] <author> H. Ono. </author> <title> Phase structures and quantales a semantical study of logics without structural rules. </title> <month> October </month> <year> 1990, </year> <title> Lecture delivered at the conference Logics with restricted structural rules, </title> <institution> University of Tubingen. </institution> <note> Cited in [79]. </note>
Reference-contexts: It turns out that the algebra of concurrent constraint programming agents satisfies the axioms of intuitionistic linear algebra (see Troelstra [79, chapter 8] and Ono <ref> [59] </ref>), which suggests a relationship between concurrent constraint programming and intuitionistic linear logic.
Reference: [60] <author> Erik Palmgren. </author> <title> Denotational semantics of constraint logic programs| a nonstandard approach. </title> <editor> In B. Mayoh, E. Tyugu, and J. Penjam, editors, </editor> <booktitle> Constraint Programming, NATO ASI Series F, </booktitle> <pages> pages 261-288. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We also like the basic operations of the constraint system, the existential quantification, conjunction and implication, to be continuous. Palmgren <ref> [60] </ref> gives a general method to construct a complete structure from an arbitrary structure so that the formulas valid in the constructed structure are exactly those that are valid in the original structure. However, in this thesis we use a simpler construction which directly gives a complete constraint system.
Reference: [61] <author> Prakash Panangaden and James R. Russell. </author> <title> A category-theoretic semantics for unbounded nondeterminacy. </title> <booktitle> In Mathematical Foundations of Programming Semantics, volume 442 of Lecture Notes in Computer Science, </booktitle> <pages> pages 319-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Lehmann gave a powerdomain construction for !-categories in which each set can be represented. However, the construction is based on multi-sets, which means that there may be many non-isomorphic representations of the same set. The powerdomain construction has previously been used by Abramsky [2], Panangaden and Russell <ref> [61] </ref>, and Nystrom and Jonsson [58] to model various forms of indeterminacy. It is straight-forward to adapt the proof of Theorem 7.5.3 to show that there can be no fully abstract fixpoint semantics based on !-categories for our language. <p> This powerdomain construction has previously been used by Abramsky [2], Panangaden and Russel <ref> [61] </ref>, Nystrom and Jonsson [58], and de Boer, Di Piero and Palamidessi [24] to give the fixpoint semantics of various forms of nondeterministic programming languages. Lehmann's construction relies on a special type of categories called !- categories.
Reference: [62] <author> Prakash Panangaden and Vasant Shanbhogue. </author> <title> The expressive power of indeterminate dataflow primitives. </title> <journal> Information and Computation, </journal> <volume> 98 </volume> <pages> 99-131, </pages> <year> 1992. </year>
Reference: [63] <author> D. Park. </author> <title> The `fairness' problem and nondeterministic computing networks. </title> <editor> In de Bakker and van Leeuwen, editors, </editor> <booktitle> Foundations of Computer Science IV, </booktitle> <volume> Part 2, </volume> <pages> pages 133-161, </pages> <address> Amsterdam, </address> <year> 1983. </year> <note> Mathematical Centre Tracts 159. </note>
Reference: [64] <author> David Park. </author> <title> On the semantics of fair parallelism. In Abstract Software Specifications, </title> <booktitle> Copenhagen Winter School 1979, volume 86 of Lecture Notes in Computer Science, </booktitle> <pages> pages 504-526. </pages> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: To allow more than one reference to the stack object we must use a merge agent and write, for example, stack (C; []); merge (C 1 ; C 2 ; C) to allow two agents to communicate with the stack. 3.15 Unbounded Nondeterminism The last example is inspired by Park <ref> [64] </ref> and Broy [14], who showed that in a language with non-determinism and some fairness notion it was possible to write a program that exhibits unbounded non-determinism.
Reference: [65] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, Denmark, </institution> <year> 1981. </year>
Reference-contexts: Similarly, we say that we bind a variable to a value if by adding constraints to the store we make sure that the variable is bound to the value in the resulting store. We present rules that define ! in the usual style of structural operational semantics <ref> [65] </ref>. 1. The tell constraint simply adds new information (itself) to the envi ronment. c : d ! c : c t d 2. A conjunction of agents is executed by interleaving the execution of its components.
Reference: [66] <author> Axel Poigne. </author> <title> Context-free languages of infinite words as least fixpoints. </title> <booktitle> In Proc. Int. Conf. on fundamentals on Computation Theory, Szeged, Hungary, volume 117 of Lecture Notes in Computer Science, </booktitle> <pages> pages 301-310. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The language we consider is based on context-free grammars. The difference is mainly that we consider strings generated by infinite left-most derivations. This very simple model of non-deterministic computation has previously been studied by Nivat [56] and Poigne <ref> [66] </ref>. 7.3 Relevance and significance Why look at the semantics of non-deterministic and non-terminating programs? These programs have a simple operational behaviour, and one would expect the same to hold for their fixpoint semantics.
Reference: [67] <author> A. W. Roscoe. </author> <title> Unbounded non-determinism in CSP. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3(2) </volume> <pages> 131-172, </pages> <year> 1993. </year>
Reference-contexts: In other words, to define a fixpoint semantics it is sufficient to have semantic functions that are monotone. This approach has been applied in some recent papers, see for example Barrett [6]. A related approach was presented by Roscoe <ref> [67] </ref>. The main differences between the language we consider, and the one Apt and Plotkin examined are that our language allows arbitrary recursion and infinite computations, but not unbounded non-determinism.
Reference: [68] <author> James R. Russell. </author> <title> Full abstraction for nondeterministic dataflow networks. </title> <booktitle> In Proc. 30 th Annual Symp. Foundations of Computer Science, </booktitle> <pages> pages 170-177, </pages> <year> 1989. </year>
Reference-contexts: system, and extend the result semantics to cope with infinite input, it is possible to give a proof of full abstraction that does not use infinite conjunctions. 84 chapter 5. a fully abstract semantics for ccp The proof in this section resembles a proof of full abstraction given by Russell <ref> [68] </ref>. The idea is that we assume that a representation of a trace is provided as input. It is then possible to write a procedure that `interprets' the trace and thus exhibits a behaviour similar to the agent [ t] in the previous proof. <p> This technique was first described by Russell <ref> [68] </ref>, and the idea is that we construct a net that reads a representation of a trace and emulates a deterministic node whose functionality is the functionalty given by the trace (Figure 6.6).
Reference: [69] <author> James R. Russell. </author> <title> On oraclizable networks and Kahn's principle. </title> <booktitle> In Proc. 17 th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 320-328, </pages> <year> 1990. </year> <note> references 181 </note>
Reference-contexts: Saraswat, Rinard and Panangaden [71] give fully abstract fixpoint semantics for various types of concurrent constraint programming languages. 7.3. relevance and significance 111 One of the languages is a non-deterministic language which allows arbitrary recursion. However, only finite computations are considered. A similar result is by Russel <ref> [69] </ref>, who considers a class of non-deterministic data flow networks. He gives a fully abstract fixpoint semantics but does not consider infinite computations. The language we consider is based on context-free grammars. The difference is mainly that we consider strings generated by infinite left-most derivations. <p> Milner [53] gave an operational model of a non-deterministic language in which oracles were used to determine non-deterministic choices. Keller [39], Kearney and Staples [38] and Russel <ref> [69] </ref> have presented fixpoint semantics of various non-deterministic languages in which choices are determined by an oracle.
Reference: [70] <author> Vijay A. Saraswat. </author> <title> Problems with Concurrent Prolog. </title> <type> Technical Report CMU-CS-86-100, </type> <institution> Carnegie-Mellon University, Computer Science Department, 1986,1985. </institution>
Reference: [71] <author> Vijay A. Saraswat, Martin Rinard, and Prakash Panangaden. </author> <title> Semantic foundations of concurrent constraint programming. </title> <booktitle> In Proc. 18 th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Given this, we use ideal completion to derive the desired 4.2. constraints 47 domain. The resulting structure satisfies all axioms of cylindric algebra [30] that do not involve negation. In contrast, Saraswat et al. <ref> [71] </ref> choose an axiomatic approach, based on axioms from cylindric algebra and techniques from Scott's information systems [72] to specify the properties of a constraint system. <p> In the development of the semantic models in the following chapters, the properties that will be important for us are that the constraint system satisfies the axioms of cylindric algebra listed above, and that the constraints form an algebraic lattice. In contrast, Saraswat, Rinard and Panangaden <ref> [71] </ref> require in their semantics for non-deterministic ccp that the constraint system should be finitary, i.e., that for each finite constraint there should only be a finite set of smaller finite constraints. <p> This is perhaps not completely obvious, since agents still execute concurrently, and results may be computed in different orders. However, as shown by Saraswat, Rinard, and Panangaden <ref> [71] </ref>, it turns out 4.6. closure operators and deterministic programs 63 that the agents may be represented as functions with some special properties, and that the meaning of programs may be obtained as simple fixpoints, as in Kahn's semantics [37]. <p> This idea was explored in a concurrent constraint programming setting by Saraswat, Rinard, and Panangaden <ref> [71] </ref>. This section gives the definition of closure operators and some of their properties. See reference [29] for further results on closure operators. Let us look at an agent as a function f that takes a store as input, and returns a new store. <p> Unless stated otherwise, we will assume the closure operators occurring in this paper to be continuous. 4.6.2 Semantics of deterministic ccp In this section we briefly review the results of Saraswat, Rinard, and Panan-gaden <ref> [71] </ref> concerning the semantics of deterministic ccp. The idea is that we should try to model each agent as a closure operator that takes a store as input and returns a new store. First, consider a tell constraint c. <p> We then show that the semantics obtained by applying this closure operation to the trace semantics is compositional and fully abstract with respect to the result semantics. 5.1 Related Work A similar closure operation on traces has also been presented by Saraswat, Rinard, and Panangaden <ref> [71] </ref> but that work only considers finite behaviour. In contrast our semantics handles infinite computations and the associated 73 74 chapter 5. a fully abstract semantics for ccp notion of fairness, and can be seen as a natural extension of [71] to the infinite case. <p> traces has also been presented by Saraswat, Rinard, and Panangaden <ref> [71] </ref> but that work only considers finite behaviour. In contrast our semantics handles infinite computations and the associated 73 74 chapter 5. a fully abstract semantics for ccp notion of fairness, and can be seen as a natural extension of [71] to the infinite case. See Section 2.8 for other results concerning fully abstract semantics of concurrent constraint programming. 5.2 Defining the fully abstract semantics The fully abstract semantics is based on the idea that we look at two aspects of a trace; its functionality and its limit. <p> An early version of the thesis gave an incorrect char-acterisation of the compositionality of the abstract semantics with respect to the existential quantifier. A similar error was made by Saraswat, Rinard and Panangaden <ref> [71] </ref>. When we look at the semantics of an existentially quantified agent 9 X A, it should be clear that for any trace t of the agent 9 X A there is a corresponding trace u of the agent A. <p> Are these requirements sufficient? Well, almost. It turns out that it is necessary to add a third requirement to the trace u. (This requirement is the one that was missing from a previous version of the thesis, and from <ref> [71] </ref>.) For example, consider the agent A = (X = 10 ) Y = 7 [] true ) Z = 5): The agent is non-deterministic, since if X = 10 it might either produce Y = 7, or Z = 5. <p> Brookes [13] gives a fully abstract fixpoint semantics of an imperative non-deterministic language with shared variables. The semantic model also allows infinite traces and is thus able to adequately model the behaviour of infinitely running processes. However, recursion is not dealt with. Saraswat, Rinard and Panangaden <ref> [71] </ref> give fully abstract fixpoint semantics for various types of concurrent constraint programming languages. 7.3. relevance and significance 111 One of the languages is a non-deterministic language which allows arbitrary recursion. However, only finite computations are considered. <p> In the the following chapter we will give two fixpoint semantics, one based on partial orders, and one based on category-theoretic domains. Since an agent with a given oracle is essentially deterministic it follows that we can use the techniques described by Saraswat, Rinard and Panangaden <ref> [71] </ref> and give computational behaviour as a closure operator (a function over constraints which satisfies some additional properties). <p> Thus the resulting computation is essentially deterministic and can be seen as a closure operator over the domain of constraints, in the manner described by Saraswat et al. <ref> [71] </ref>. However, this is not sufficient.
Reference: [72] <author> Dana S. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In ICALP'82, number 140 in Lecture Notes in Computer Science, </booktitle> <pages> pages 577-613. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: The resulting structure satisfies all axioms of cylindric algebra [30] that do not involve negation. In contrast, Saraswat et al. [71] choose an axiomatic approach, based on axioms from cylindric algebra and techniques from Scott's information systems <ref> [72] </ref> to specify the properties of a constraint system. The use of ideal completion to construct a constraint system that is closed under infinite limits has previously been employed by Carlson [16] and Kwiatkowska [43].
Reference: [73] <author> Robert A. G. Seely. Hyperdoctrines, </author> <title> natural deduction and the Beck condition. </title> <journal> Zeitschr. f. math. Logik und Grundlagen d. Math., </journal> <volume> 29 </volume> <pages> 505-542, </pages> <year> 1983. </year>
Reference-contexts: The work presented in this section is influenced by the results of Mendler, Panangaden, Scott and Seely [52], who show that a semantic model of con 88 chapter 5. a fully abstract semantics for ccp current constraint programming forms a hyperdoctrine <ref> [45, 73] </ref>, a category-theoretic structure which represents the proof-theoretic structure of logics. Thus, proving that ccp is a hyperdoctrine implies that ccp in fact forms a logic. The authors of reference [52] stress the point; ccp is logic.
Reference: [74] <author> Ehud Shapiro. </author> <title> Concurrent Prolog: A progress report. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 44-58, </pages> <month> August </month> <year> 1986. </year>
Reference: [75] <author> Ehud Shapiro. </author> <title> The family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 412-510, </pages> <month> September </month> <year> 1989. </year>
Reference: [76] <author> Ehud Y. Shapiro. </author> <title> A subset of Concurrent Prolog and its interpreter. </title> <type> Technical Report 003, </type> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1983. </year>
Reference-contexts: The `lazy ones' program is of course not a very interesting program in itself, but the technique of using a partially defined structure to allow communication between processes has many possible applications. Shapiro <ref> [76] </ref> shows how it is possible to write concurrent logic programs in an `object-oriented' style, where an object is represented as an agent which has a local state and reads and responds to a stream of messages. 3.14 Agents as Objects with State Even though concurrent constraint programming does not allow <p> Below we give an example of a program which implements a stack as an agent which reads a stream of messages and responds to them (Shapiro <ref> [76] </ref>).
Reference: [77] <author> Eugene W. Stark. </author> <title> A simple generalization of Kahn's principle to indeterminate dataflow networks. </title> <type> Technical report, </type> <institution> State University of New York, Stony Brook, </institution> <month> July </month> <year> 1990. </year> <note> Also published as extended abstract in Proceedings of the International BCS-FACS Workshop on Semantics for Concurrency, Leicester 1990, </note> <author> M. Z. Kwiatkowska, M. W. Shields, R. M. Thomas, </author> <booktitle> (eds.), </booktitle> <pages> pp. 157-176, </pages> <publisher> Springer-Verlag. </publisher>
Reference: [78] <author> Allen Stoughton. </author> <title> Fully abstract models of programming languages. </title> <publisher> Pitman, </publisher> <year> 1988. </year>
Reference: [79] <author> A. S. Troelstra. </author> <title> Lectures on Linear Logic. Number 29 in CSLI Lecture Notes. Center for the study of language and information, </title> <publisher> Stanford, </publisher> <year> 1992. </year>
Reference-contexts: It turns out that the algebra of concurrent constraint programming agents satisfies the axioms of intuitionistic linear algebra (see Troelstra <ref> [79, chapter 8] </ref> and Ono [59]), which suggests a relationship between concurrent constraint programming and intuitionistic linear logic. <p> Abramsky and Vickers [3] propose the use of quantales as a framework for the study of various aspects of concurrency. (The algebra of quantales is closely related to intuitionistic linear algebra.) We begin by giving the axiomatic definition of intuitionistic linear algebra, following Troelstra <ref> [79] </ref>. Intuitionistic linear algebra is to linear logic as Boolean algebra is to propositional logic, i.e., an algebraic formulation of the derivation rules of the logic.
Reference: [80] <author> Kazunori Ueda. </author> <title> Concurrent Prolog re-examined. </title> <type> Technical Report 102, </type> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1985. </year>
Reference: [81] <author> Kazunori Ueda. </author> <title> Guarded Horn Clauses. </title> <type> Technical Report 103, </type> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1985. </year>
Reference: [82] <author> Kazunori Ueda. </author> <title> Guarded Horn Clauses. </title> <type> PhD thesis, </type> <institution> University of Tokyo, </institution> <month> March </month> <year> 1986. </year> <note> 182 references </note>
Reference: [83] <author> Glynn Winskel and Mogens Nielsen. </author> <title> Models for concurrency. </title> <type> Technical Report PB-463, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1993. </year> <note> To appear in Handbook of Logic in Computer Science, Oxford University Press. </note>
Reference-contexts: The authors of reference [52] stress the point; ccp is logic. Other attempts to relate algebraic rules and concurrency include the work by Bergstra and Klop [7], in which algebraic rules were used to define a concurrent language, and Winskel and Nielsen <ref> [83] </ref>, who relate different models of concurrency by examining their category-theoretic properties.
References-found: 83

