URL: http://www.win.tue.nl/cs/pa/rikvdw/papers/Benes97.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/rikvdw/bibl.html
Root-URL: http://www.win.tue.nl
Title: A High-Speed Asynchronous Decompression Circuit for Embedded Processors  
Author: Martin Benes Andrew Wolfe Steven M. Nowick 
Note: 1: Introduction While  This work was funded in part from NSF under award MIP-9408462 and by an AT&T foundation gift. This research was funded in part by an NSF CAREER Award MIP-9501880 and by an Alfred P. Sloan Research Fellowship.  
Address: Berkeley, CA  Princeton, NJ  New York, NY  Princeton, NJ  
Affiliation: Department of EECS U.C. Berkeley  Department of EE Princeton University  Department of CS Columbia University  at Department of Electrical Engineering, Princeton University,  
Abstract: This paper describes the architecture and implementation of a high-speed decompression engine for embedded processors. The engine is targeted to processors where embedded programs are stored in compressed form, and decompressed at runtime during instruction cache refill. The decompression engine uses a unique asynchronous variable decompression rate architecture to process Huffman-encoded instructions. The resulting circuit is significantly smaller than comparable synchronous decoders, yet has a higher throughput rate than almost all existing designs. The 0.8 layout is all full-custom and contains predominantly dynamic domino logic. The top-level control, as well as several small state machines, are implemented using asynchronous logic. The design operates without a user-supplied clock. Simulations using Lsim show average throughput of 32 bits/45 ns on the output side, corresponding to about 480 Mbit/sec on the input side. The chip has been manufactured by MOSIS; tests show that the asynchronous implementation operates correctly, with an average throughput exceeding simulations: 32 bits/39 ns on the output side, corresponding to about 560 Mbit/sec on the input side. This speed is acceptable for our application. The area of the design (excluding the pad-frame overhead) is only 0.75 mm 2 . The design is the first fabricated chip for an instruction decompression unit for embedded processors. Embedded systems incorporate microprocessors or microcontrollers to implement communication and control functions for consumer electronics products. These systems are sensitive to many design constraints, including limits of size, weight, power consumption and cost. Many interesting design problems for embedded systems involve optimizing these properties for high-volume products, such as consumer electronics. Since the programs in embedded systems are generally stored in ROM, the size of the program has a direct impact on the per-unit cost of the device. In previous work, a method was proposed whereby embedded programs are stored in compressed form and decompressed at run time during instruction-cache refill [Wolfe92, Kozuch94]. Using a Huffman encoding scheme, a compression ratio of 73% was reported 
Abstract-found: 1
Intro-found: 1
Reference: [Choi95] <author> S. Choi and M. Lee, </author> <title> "High Speed Pattern Matching for a Fast Huffman Decoder", </title> <journal> IEEE Trans. On Consumer Electronics, v. </journal> <volume> 41, no.1, </volume> <pages> pp. 97-103, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: The area of this circuit is unknown. Some basic ideas for partitioning the output-symbol ROM into multiple small ROMs and for extracting symbols from the input stream with a barrel shifter are described in [Hashemian94] and <ref> [Choi95] </ref>. Similar mechanisms are employed in our design. These concepts have also been included in a decoder for the MPEG-2 DCT coefficient table that has been implemented and described in [Park95].
Reference: [Davis95] <author> A. Davis and S. M. Nowick, </author> <title> "Asynchronous Circuit Design: Motivation, Background and Methods", </title> <booktitle> Chapter in Asynchronous Digital Circuit Design, </booktitle> <pages> pp. 1-49, </pages> <publisher> Springer-Verlag (Workshops in Computing Series, </publisher> <year> 1995). </year>
Reference-contexts: In addition to providing an excellent solution to a specific application requirement, this design demonstrates the benefits of asynchronous circuits in a practical system. Asynchronous design provides numerous opportunities to optimize a design for the most common inputs <ref> [Nowick96, Nowick97, Davis95] </ref>. This feature is particularly important in the case of an entropy code like a Huffman code, where the distribution of input values is essentially known. An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. <p> The input buffer must then be refilled as space becomes available, to insure that there is adequate data for the next symbol. As many of these steps as possible must be done in parallel to obtain good performance. from memory using a simple 4-phase asynchronous handshaking protocol <ref> [Davis95] </ref>. Similarly, output data is delivered to the instruction cache using a 4-phase protocol. Existing logic within the processor generates memory addresses.
Reference: [Furber94] <editor> S.B. Furber, et al., </editor> <title> "The Design and Evaluation of an Asynchronous Microprocessor", </title> <booktitle> ICCD '94, </booktitle> <pages> pp. 217-220, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
Reference: [Furber97] <author> S.B. Furber, J.D. Garside, S. Temple, J. Liu, P. Day and N.C. Paver, "AMULET2e: </author> <title> An Asynchronous Embedded Controller", </title> <booktitle> Async97, </booktitle> <pages> pp. 290-299, </pages> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
Reference: [Hashemian94] <author> R. Hashemian, </author> <title> "Design and Implementation of a Memory Efficient Huffman Decoding", </title> <journal> IEEE Trans. On Consumer Electronics, v. </journal> <volume> 40, no. 3, </volume> <pages> pp. 345-351, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: The area of this circuit is unknown. Some basic ideas for partitioning the output-symbol ROM into multiple small ROMs and for extracting symbols from the input stream with a barrel shifter are described in <ref> [Hashemian94] </ref> and [Choi95]. Similar mechanisms are employed in our design. These concepts have also been included in a decoder for the MPEG-2 DCT coefficient table that has been implemented and described in [Park95].
Reference: [Huffman52] <author> D. A. Huffman, </author> <title> "A Method for the Construction of Minimum Redundancy Codes", </title> <booktitle> Proc. IEEE, v. </booktitle> <volume> 40, no. 10, </volume> <pages> pp. 1098-1101, </pages> <month> Sept. </month> <year> 1952. </year>
Reference-contexts: The resulting chip area is 11 mm 2 in a 1.2 process, which is over 10 times larger than ours. 3: Background and Motivation 3.1: Compression Scheme The proposed compression scheme relies on a standard entropy code <ref> [Huffman52] </ref> that represents fixed-length symbols from a source alphabet as variable-length code symbols. The key challenge in the development of a code compression scheme for existing microprocessor architectures is that the system must run existing programs correctly.
Reference: [Kessels97] <author> J. Kessels and P. Marston, </author> <title> "Designing Asynchronous Standby Circuits for a Low-Power Pager", </title> <booktitle> Async97, </booktitle> <pages> pp. 268-278, </pages> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
Reference: [Kozuch94] <author> M. Kozuch, and A. Wolfe, </author> <title> "Compression of Embedded System Programs", </title> <booktitle> ICCD '94, </booktitle> <pages> pp. 270-277, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: In previous work, a method was proposed whereby embedded programs are stored in compressed form and decompressed at run time during instruction-cache refill <ref> [Wolfe92, Kozuch94] </ref>. <p> This is accomplished by decompressing a program as it is fetched into the instruction cache. As a result, the processor core sees only uncompressed program code <ref> [Wolfe92, Kozuch94] </ref>. Since the instruction cache only holds a small fraction of the program at one time, it is not possible to decompress the entire program at once; therefore, a block-oriented compression scheme is required. <p> Figure 2 shows the corresponding histogram based on the actual frequency of occurrence of the input symbols in a given program. Using a Huffman encoding scheme, a compression ratio of 73% was reported for the MIPS instruction set <ref> [Wolfe92, Kozuch94] </ref>. The number of bits required for each symbol is approximately log 2 (1=P symbol ). In order to make it easier to decode this representation, prefix codes are used for the output alphabet. <p> The actual code that was used for this implementation is based on measurements of byte frequencies from programs for the MIPS architecture. The resulting code includes symbols ranging from 2 to 14 bits in length <ref> [Wolfe92, Kozuch94] </ref>. 3.2: Motivation for an Asynchronous Architecture There are two standard synchronous approaches to decoding Huffman encoded data (see [Rudberg96]). <p> This ROM contains the 8-bit output value and a completion bit that is slower than any other ROM value. As a performance optimization, there are actually 3 ROM arrays that have their outputs merged by additional logic outside the ROM. Since the all-zero output symbol is so common <ref> [Wolfe92, Kozuch94] </ref>, its input code bypasses the decode ROM and directly drives the merge logic to zero for additional speed. The completion signal indicates that the output code has been determined and also clocks the result into the Output Buffer.
Reference: [Martin89] <author> A.J. Martin et al., </author> <title> "The Design of an Asynchronous Microprocessor", Caltech Conference on Very Large Scale Integration, </title> <year> 1989. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
Reference: [Matsui94] <author> M. Matsui, et al., </author> <title> "200 MHz Video Compression Macrocells Using Low-Swing Differential Logic", </title> <booktitle> ISSCC 94, </booktitle> <pages> pp. 76-77, </pages> <year> 1994. </year>
Reference-contexts: The first design, at Osaka University [Onoye95], uses pipelined design with a separate stage for input shifting, length detection and symbol decoding. The VLD layout using ASIC libraries occupies about 5 mm 2 in a 0.6 process. The second design, at Toshiba Microelectronics <ref> [Matsui94] </ref>, uses one stage for length and symbol lookup (details were not given). To compensate for slow length detection, it uses a two-stage pipelined shifting scheme that removes the adder delay from the critical path.
Reference: [Nielsen96] <author> L.S. Nielsen and J. Sparso, </author> <title> "A Low-Power Asynchronous Data Path for a FIR Filter Bank", </title> <booktitle> Async96, </booktitle> <pages> pp. 197-207, </pages> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
Reference: [Nowick96] <author> S.M. Nowick, </author> <title> "Design of a Low-Latency Asynchronous Adder Using Speculative Completion", </title> <booktitle> IEE Proceedings Computers and Digital Techniques (UK), v. </booktitle> <volume> 143, no. 5, </volume> <pages> pp. 301-307, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: In addition to providing an excellent solution to a specific application requirement, this design demonstrates the benefits of asynchronous circuits in a practical system. Asynchronous design provides numerous opportunities to optimize a design for the most common inputs <ref> [Nowick96, Nowick97, Davis95] </ref>. This feature is particularly important in the case of an entropy code like a Huffman code, where the distribution of input values is essentially known. An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks.
Reference: [Nowick97] <author> S.M. Nowick, K.Y. Yun, P.A. Beerel and A.E. Dooply, </author> <title> "Speculative Completion for the Design of High-Performance Asynchronous Dynamic Adders", </title> <booktitle> Async97, </booktitle> <pages> pp. 210-223, </pages> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: In addition to providing an excellent solution to a specific application requirement, this design demonstrates the benefits of asynchronous circuits in a practical system. Asynchronous design provides numerous opportunities to optimize a design for the most common inputs <ref> [Nowick96, Nowick97, Davis95] </ref>. This feature is particularly important in the case of an entropy code like a Huffman code, where the distribution of input values is essentially known. An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks.
Reference: [Onoye95] <author> T. Onoye, et al., </author> <title> "HDTV Level MPEG2 Video Decoder VLSI", </title> <booktitle> International Conference on Microelectronics and VLSI, </booktitle> <volume> TENCON '95, </volume> <pages> pp. 468-471, </pages> <year> 1995. </year>
Reference-contexts: Two of the fastest recent decoders were developed in Japan. Both implementations integrate the VLD decoder with IDCT transform to completely decode the video stream. The first design, at Osaka University <ref> [Onoye95] </ref>, uses pipelined design with a separate stage for input shifting, length detection and symbol decoding. The VLD layout using ASIC libraries occupies about 5 mm 2 in a 0.6 process. The second design, at Toshiba Microelectronics [Matsui94], uses one stage for length and symbol lookup (details were not given).
Reference: [Park95] <author> H. Park, J. Son and S. Cho, </author> <title> "Area Efficient Fast Huffman Encoder for Multimedia Applications", </title> <booktitle> 1995 ICASSP, </booktitle> <pages> pp. 3279-3281. </pages>
Reference-contexts: Similar mechanisms are employed in our design. These concepts have also been included in a decoder for the MPEG-2 DCT coefficient table that has been implemented and described in <ref> [Park95] </ref>. The circuit area is 3.5 mm 2 in a 0.65 CMOS process, compared with only 0.75 mm 2 for our design in a 0.8 process. The authors claim a peak performance of 680 Mbit/sec, but this is based on the decoding of maximal-length 17-bit codewords at 40 MHz.
Reference: [Rudberg96] <author> M. K. Rudberg and L. Wanhammar, </author> <title> "New Approaches to High Speed Huffman Decoding", </title> <booktitle> 1996 ISCAS, </booktitle> <pages> pp. 149-152. </pages>
Reference-contexts: The structure of the code is quite simple, and the code length can be easily derived from the number of leading zeros. The complexity of this code is therefore simpler than our MIPS-based code which has 256 code words. Rudberg <ref> [Rudberg96] </ref> presents a design for a constant-input-rate synchronous Huffman decoder. His design uses aggressive pipelining to break the critical dependency loop in length detection, thereby allowing the implementation of a constant-input-rate/variable-output-rate decoder without complex state machines. <p> The resulting code includes symbols ranging from 2 to 14 bits in length [Wolfe92, Kozuch94]. 3.2: Motivation for an Asynchronous Architecture There are two standard synchronous approaches to decoding Huffman encoded data (see <ref> [Rudberg96] </ref>). In a basic constant-input-rate scheme, the input data stream is processed at a rate of one bit per cycle by traversing a Huffman code tree through the use of a finite state machine.
Reference: [Wolfe92] <author> A. Wolfe and A. Chanin, </author> <title> "Executing Compressed Programs on an Embedded RISC Architecture", </title> <booktitle> Micro-25, the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pp. 81-91, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: In previous work, a method was proposed whereby embedded programs are stored in compressed form and decompressed at run time during instruction-cache refill <ref> [Wolfe92, Kozuch94] </ref>. <p> This is accomplished by decompressing a program as it is fetched into the instruction cache. As a result, the processor core sees only uncompressed program code <ref> [Wolfe92, Kozuch94] </ref>. Since the instruction cache only holds a small fraction of the program at one time, it is not possible to decompress the entire program at once; therefore, a block-oriented compression scheme is required. <p> Figure 2 shows the corresponding histogram based on the actual frequency of occurrence of the input symbols in a given program. Using a Huffman encoding scheme, a compression ratio of 73% was reported for the MIPS instruction set <ref> [Wolfe92, Kozuch94] </ref>. The number of bits required for each symbol is approximately log 2 (1=P symbol ). In order to make it easier to decode this representation, prefix codes are used for the output alphabet. <p> The actual code that was used for this implementation is based on measurements of byte frequencies from programs for the MIPS architecture. The resulting code includes symbols ranging from 2 to 14 bits in length <ref> [Wolfe92, Kozuch94] </ref>. 3.2: Motivation for an Asynchronous Architecture There are two standard synchronous approaches to decoding Huffman encoded data (see [Rudberg96]). <p> This ROM contains the 8-bit output value and a completion bit that is slower than any other ROM value. As a performance optimization, there are actually 3 ROM arrays that have their outputs merged by additional logic outside the ROM. Since the all-zero output symbol is so common <ref> [Wolfe92, Kozuch94] </ref>, its input code bypasses the decode ROM and directly drives the merge logic to zero for additional speed. The completion signal indicates that the output code has been determined and also clocks the result into the Output Buffer.
Reference: [Wei95] <author> B.W.Y. Wei and T.H.Meng, </author> <title> "A Parallel Decoder of Programmable Huffman Codes", </title> <journal> IEEE Trans. on Circuits and Systems for Video Technology, v. </journal> <volume> 5, no. 2, </volume> <pages> pp. 175-178, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: In comparison, our asynchronous chip has an output rate of 32 bits/39 ns, which is roughly 103 MHz. At the same time, our decoder area is roughly 5 times smaller than each of these designs. Finally, Wei and Meng <ref> [Wei95] </ref> introduce a JPEG Huffman decoder which operates at 40 MHz, but can be pipelined at 80 MHz. This work focuses on programmable codes, rather than the fixed codes which we consider.
Reference: [Yun97] <author> K.Y. Yun, P.A. Beerel, V. Vakilotojar, A.E. Dooply and J. Arceo, </author> <title> "The Design and Verification of a High-Performance Low-Control-Overhead Asynchronous Differential Equation Solver", </title> <booktitle> Async97, </booktitle> <pages> pp. 140-153, </pages> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: An asynchronous methodology also allows the design of small, high-speed circuits without the risk or overhead associated with high speed clocks. Recently, a number of asynchronous chips have been successfully fabricated, both for microprocessors and DSPs <ref> [Furber94, Furber97, Kessels97, Martin89, Nielsen96, Yun97] </ref>. Our proposed decompression engine achieves its cost/performance advantage over existing designs through a combination of architectural improvements as well as aggressive circuit design.
References-found: 19

