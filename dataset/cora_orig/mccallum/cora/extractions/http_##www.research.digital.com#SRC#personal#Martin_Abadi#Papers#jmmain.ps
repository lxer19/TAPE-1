URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/jmmain.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Title: Polymorphic Languages  
Author: Martin Abadi, Luca Cardelli, Benjamin Pierce, and Didier Remy d i g i t a l 
Keyword: Dynamic Typing  
Note: in  
Date: January 26, 1994  
Abstract: SRC Research Report 120 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In this paper we investigate the integration of dynamic types into languages with explicit polymorphism (in the style of system F [10]), implicit polymorphism (in the style of ML [16]), abstract data types, and subtyping. Our study extends earlier work <ref> [1] </ref>, but keeps the same general approach and the same basic language constructs: dynamic, for tagging a value with its type, and typecase, for comparing a type tag with a pattern and branching according to whether they match. <p> The interaction of polymorphism and dynamic types gives rise to problems in binding type variables. We find that these problems can be more clearly addressed in languages with explicit polymorphism. Even then, we encounter some perplexing difficulties (as indicated in <ref> [1] </ref>). In particular, there is no unique way to match the type tag of a dynamic value with a typecase pattern. Our solution consists in constraining the syntax of typecase patterns, thus providing static guarantees of unique solutions. <p> There, a tag matches a pattern if it is a subtype of the pattern. This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. In addition to <ref> [1] </ref>, several recent studies consider languages with dynamic 1 types [12, 14, 21]. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 4. <p> The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 4. Section 2 is a brief review of dynamic typing in simply typed languages, based on <ref> [1] </ref>. Section 3 considers the addition of dynamic typing to a language with explicit polymorphism [10]. Section 4 then deals with a language with implicit polymorphism. Sections 5 and 6 discuss abstract data types and subtyping, respectively. <p> These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic <ref> [1] </ref>. Important applications of dynamics include persistence and inter-address-space communication. <p> We have deliberately avoided semantic considerations in this paper. It seems relatively straightforward to provide precise operational semantics and then prove subject-reduction theorems for our languages. These theorems would be extensions of those established for monomorphic languages in <ref> [1] </ref>, and would guarantee the soundness of evaluation for the languages. It is an entirely different matter to define denotational semantics.
Reference: [2] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Didier Remy. </author> <title> Dynamic typing in polymorphic languages. </title> <editor> In Peter Lee, editor, </editor> <booktitle> ACM Sigplan Workshop on ML and its Applications, </booktitle> <pages> pages 92-103. </pages> <note> Technical Report CMU-CS-93-105, </note> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Unfortunately, failures could be somewhat unpredictable. * At compile time, we may allow only patterns that match each tag in at most one way. This condition on patterns is called definiteness in a preliminary version of this work <ref> [2] </ref>. As definiteness seems hard to decide at compile time, an approximation to definiteness may be used instead. As in [2], we choose a compile-time solution. We propose a condition on patterns sufficient to guarantee definiteness ((1) and (2), below), in combination with an appropriate definition of matching ((3), below). <p> This condition on patterns is called definiteness in a preliminary version of this work <ref> [2] </ref>. As definiteness seems hard to decide at compile time, an approximation to definiteness may be used instead. As in [2], we choose a compile-time solution. We propose a condition on patterns sufficient to guarantee definiteness ((1) and (2), below), in combination with an appropriate definition of matching ((3), below). This condition is more restrictive than that of [2], and in some cases it may entail some code duplication. <p> As in <ref> [2] </ref>, we choose a compile-time solution. We propose a condition on patterns sufficient to guarantee definiteness ((1) and (2), below), in combination with an appropriate definition of matching ((3), below). This condition is more restrictive than that of [2], and in some cases it may entail some code duplication. On the other hand, it is easier to describe, it suffices for our examples, and in general it does not seem to affect expressiveness. <p> This restriction creates difficulties for the implicit-tagging approach: a program like (x) dynamic (x) will fail to have a principal type. It will therefore simplify matters to assume that explicit tags are given in dynamic expressions. An alternative is discussed in <ref> [2] </ref>. 4.2 Tag instantiation and tuple variables The tag of apply: apply = dynamic ((f) (x) f x:8 (X,Y)(X!Y)!(X!Y)) is equivalent to 8 (Y,X)(X!Y)!(X!Y), and an ML programmer would probably view the order of quantifiers as unimportant.
Reference: [3] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Ny-gaard. </author> <title> Simula Begin. </title> <institution> Studentlitteratur (Lund, Sweden), Bratt Institute Fuer Neues Lerned (Goch, FRG), Chartwell-Bratt Ltd. (Kent, </institution> <address> England), </address> <year> 1979. </year>
Reference-contexts: We explore the consequences of both choices. Subtyping is exploited in combination with dynamic types in languages with restricted typecase patterns, such as Simula-67 <ref> [3] </ref> and Modula-3 [8]. There, a tag matches a pattern if it is a subtype of the pattern. This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. <p> In the simplest version of this semantics, C matches A if they are identical; in languages with subtyping, it is common to allow C to be a subtype of A instead. Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 <ref> [3] </ref>, CLU [15], Cedar/Mesa [13], Amber [4], Modula-2+ [20], Oberon [23], and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [4] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year> <booktitle> Number 242 in Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU [15], Cedar/Mesa [13], Amber <ref> [4] </ref>, Modula-2+ [20], Oberon [23], and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication. <p> Further experience would be useful for understanding the interaction of Dynamic and abstract types. 6 Subtyping In simple languages with subtyping (e.g., <ref> [4, 8] </ref>) it is natural to extend typecase to perform a subtype test instead of an exact match. Consider for example the expression: let dx = dynamic (3:Nat) in typecase dx of (x:Int) ... else ...
Reference: [5] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <year> 1988. </year>
Reference-contexts: Our approach works in general and fits well with the language described in section 3.2. We intend to extend system F with subtyping along the lines of [6]. In order to incorporate also the higher-order pattern variables, we resort to power-kinds <ref> [5] </ref>. The kind structure of section 3.2 is extended in Figure 4, where it is assumed that T : K and F : K n !K. <p> (Q 1 ; : : : ; Q n ) : K; for all Q 1 : K 1 , : : : , Q n : K n , where F; G : (K 1 fi : : : fi K n !K) The axiomatization of Power (K)(T ) <ref> [5] </ref> is designed to induce the expected sub-typing rules. For example, T : Power (T ) says that T T . Because of power-kinds, we can now write patterns such as: typecase dx of fV,W (VfiV)g (x:WfiV) ... (that is: fV:Type, W:Power (Type)(VfiV)g (x:WfiV)) else ...
Reference: [6] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Theoretical Aspects of Computer Software, number 526 in Lecture Notes in Computer Science, </booktitle> <pages> pages 750-770, </pages> <address> New York, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Therefore, we take an approach different from that found in simple languages with subtyping. Our approach works in general and fits well with the language described in section 3.2. We intend to extend system F with subtyping along the lines of <ref> [6] </ref>. In order to incorporate also the higher-order pattern variables, we resort to power-kinds [5]. The kind structure of section 3.2 is extended in Figure 4, where it is assumed that T : K and F : K n !K.
Reference: [7] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: This can happen, for example, in a system with bounded quantifiers <ref> [7, 9] </ref>, and in systems where the collection of base types does not form an upper semi-lattice. Linear patterns (where each pattern variable occurs at most once) avoid these problems, but we find linearity too restrictive. Therefore, we take an approach different from that found in simple languages with subtyping.
Reference: [8] <editor> Greg Nelson (editor). </editor> <booktitle> Systems Programming in Modula-3. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: We explore the consequences of both choices. Subtyping is exploited in combination with dynamic types in languages with restricted typecase patterns, such as Simula-67 [3] and Modula-3 <ref> [8] </ref>. There, a tag matches a pattern if it is a subtype of the pattern. This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. <p> Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU [15], Cedar/Mesa [13], Amber [4], Modula-2+ [20], Oberon [23], and Modula-3 <ref> [8] </ref>. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication. <p> Further experience would be useful for understanding the interaction of Dynamic and abstract types. 6 Subtyping In simple languages with subtyping (e.g., <ref> [4, 8] </ref>) it is natural to extend typecase to perform a subtype test instead of an exact match. Consider for example the expression: let dx = dynamic (3:Nat) in typecase dx of (x:Int) ... else ...
Reference: [9] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Technical report TD-6/90, </type> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: This can happen, for example, in a system with bounded quantifiers <ref> [7, 9] </ref>, and in systems where the collection of base types does not form an upper semi-lattice. Linear patterns (where each pattern variable occurs at most once) avoid these problems, but we find linearity too restrictive. Therefore, we take an approach different from that found in simple languages with subtyping.
Reference: [10] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Hence, there are situations in programming where one would like to use dynamic types even in the presence of advanced static type systems. In this paper we investigate the integration of dynamic types into languages with explicit polymorphism (in the style of system F <ref> [10] </ref>), implicit polymorphism (in the style of ML [16]), abstract data types, and subtyping. <p> We compare their designs to ours in section 4. Section 2 is a brief review of dynamic typing in simply typed languages, based on [1]. Section 3 considers the addition of dynamic typing to a language with explicit polymorphism <ref> [10] </ref>. Section 4 then deals with a language with implicit polymorphism. Sections 5 and 6 discuss abstract data types and subtyping, respectively. We conclude in section 7. 2 Review The integration of static and dynamic typing is fairly straightforward for mono-morphic languages. <p> construct a dynamic containing their functional composition: dynCompose = (df:Dynamic) (dg:Dynamic) typecase df of fU,Vg (f:U!V) typecase dg of fWg (g:W!U) dynamic (f ffi g:W!V) else ... else ... 3 3 Explicit Polymorphism This formulation of dynamic types may be carried over almost unchanged to languages based on explicit polymorphism <ref> [10, 19] </ref>. For example, the following function checks that its argument df contains a polymorphic function f taking lists to lists. <p> In particular, we have not provided mechanisms for dealing with multiple matches at run time, in order not to complicate the language designs or their implementations. We have also ignored the possibility of adding dynamic types to F 3 , or to F ! <ref> [10] </ref>. Only more experience will reveal the most useful variants of our approach. We have deliberately avoided semantic considerations in this paper. It seems relatively straightforward to provide precise operational semantics and then prove subject-reduction theorems for our languages.
Reference: [11] <author> Mike Gordon. </author> <title> Adding Eval to ML. </title> <type> Personal communication, </type> <month> circa </month> <year> 1980. </year> <month> 21 </month>
Reference-contexts: Important applications of dynamics include persistence and inter-address-space communication. For example, the following primitives might provide input and output of a dynamic value from and to a stream: extern 2 WriterfiDynamic!Unit intern 2 Reader!Dynamic 2 Moreover, dynamics can be used to give a type for an eval primitive <ref> [11, 18] </ref>: eval 2 Exp!Dynamic We obtain a much more expressive system by allowing typecase guards to contain pattern variables.
Reference: [12] <author> Fritz Henglein. </author> <title> Dynamic typing: Syntax and proof theory. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1993. </year> <note> Special Issue on European Symposium on Programming 1992 (to appear). </note>
Reference-contexts: This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. In addition to [1], several recent studies consider languages with dynamic 1 types <ref> [12, 14, 21] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 4.
Reference: [13] <author> Butler Lampson. </author> <title> A description of the Cedar language. </title> <type> Technical Report CSL-83-15, </type> <institution> Xerox Palo Alto Research Center, </institution> <year> 1983. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU [15], Cedar/Mesa <ref> [13] </ref>, Amber [4], Modula-2+ [20], Oberon [23], and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [14] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ML. </title> <editor> In John Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture 1991, volume 523 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406-426. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. In addition to [1], several recent studies consider languages with dynamic 1 types <ref> [12, 14, 21] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 4. <p> With these restrictions, matching becomes a simple extension of first-order unification with restricted type operators; we omit the details. 4.4 Related work The work on dynamic typing most closely related to ours is that of Leroy and Mauny <ref> [14] </ref>. Their dynamics without pattern variables have been implemented in the CAML language [22]. Our work can be seen as an extension of their system with "mixed quantification." Rather than introduce a typecase statement, Leroy and Mauny merge dynamic elimination with the usual case statement of ML.
Reference: [15] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J.C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: In the simplest version of this semantics, C matches A if they are identical; in languages with subtyping, it is common to allow C to be a subtype of A instead. Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU <ref> [15] </ref>, Cedar/Mesa [13], Amber [4], Modula-2+ [20], Oberon [23], and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [16] <author> Robin Milner, Mads Tofte, and Robert W. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: In this paper we investigate the integration of dynamic types into languages with explicit polymorphism (in the style of system F [10]), implicit polymorphism (in the style of ML <ref> [16] </ref>), abstract data types, and subtyping. Our study extends earlier work [1], but keeps the same general approach and the same basic language constructs: dynamic, for tagging a value with its type, and typecase, for comparing a type tag with a pattern and branching according to whether they match.
Reference: [17] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: For example, a program may create disk files containing dynamic values, which should remain usable even after the program is recompiled, or two programs on different machines may want to exchange abstract data in the form of dynamically typed values. By viewing abstract types formally as existential types <ref> [17] </ref>, we can see exactly where the difference between these two solutions lies, and suggest a generalization of existential types that supports both. (Existential types can in turn be coded using universal types; with this coding, our design for dynamic types in the previous sections yields the second solution.) To add
Reference: [18] <author> Alan Mycroft. </author> <title> Dynamic types in ML. </title> <type> Draft article, </type> <year> 1983. </year>
Reference-contexts: Important applications of dynamics include persistence and inter-address-space communication. For example, the following primitives might provide input and output of a dynamic value from and to a stream: extern 2 WriterfiDynamic!Unit intern 2 Reader!Dynamic 2 Moreover, dynamics can be used to give a type for an eval primitive <ref> [11, 18] </ref>: eval 2 Exp!Dynamic We obtain a much more expressive system by allowing typecase guards to contain pattern variables.
Reference: [19] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, number 19 in Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: construct a dynamic containing their functional composition: dynCompose = (df:Dynamic) (dg:Dynamic) typecase df of fU,Vg (f:U!V) typecase dg of fWg (g:W!U) dynamic (f ffi g:W!V) else ... else ... 3 3 Explicit Polymorphism This formulation of dynamic types may be carried over almost unchanged to languages based on explicit polymorphism <ref> [10, 19] </ref>. For example, the following function checks that its argument df contains a polymorphic function f taking lists to lists.
Reference: [20] <author> Paul Rovner. </author> <title> On extending Modula-2 to build large, integrated systems. </title> <journal> IEEE Software, </journal> <volume> 3(6) </volume> <pages> 46-57, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU [15], Cedar/Mesa [13], Amber [4], Modula-2+ <ref> [20] </ref>, Oberon [23], and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [21] <author> Satish R. Thatte. </author> <title> Quasi-static typing (preliminary report). </title> <booktitle> In Proceedings of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <year> 1990. </year>
Reference-contexts: This sort of matching does not work out well with more general typecase patterns. We find it preferable to match type tags against patterns exactly, and then perform explicitly prescribed subtype tests. In addition to [1], several recent studies consider languages with dynamic 1 types <ref> [12, 14, 21] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 4.
Reference: [22] <author> Pierre Weis, Maria-Virginia Aponte, Alain Laville, Michel Mauny, and As-cander Suarez. </author> <title> The CAML reference manual. </title> <type> Research report 121, </type> <institution> INRIA, Rocquencourt, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Their dynamics without pattern variables have been implemented in the CAML language <ref> [22] </ref>. Our work can be seen as an extension of their system with "mixed quantification." Rather than introduce a typecase statement, Leroy and Mauny merge dynamic elimination with the usual case statement of ML.
Reference: [23] <author> Niklaus Wirth. </author> <title> From Modula to Oberon and the programming language Oberon. </title> <type> Technical Report 82, </type> <institution> Institut fur Informatik, ETH, </institution> <address> Zurich, </address> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Constructs analogous to dynamic and typecase have appeared in a number of languages, including Simula-67 [3], CLU [15], Cedar/Mesa [13], Amber [4], Modula-2+ [20], Oberon <ref> [23] </ref>, and Modula-3 [8]. These constructs have surprising expressive power; for example, fixpoint operators can already be defined at every type in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
References-found: 23

