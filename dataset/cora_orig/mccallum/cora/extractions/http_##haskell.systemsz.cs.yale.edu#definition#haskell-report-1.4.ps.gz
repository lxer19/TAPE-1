URL: http://haskell.systemsz.cs.yale.edu/definition/haskell-report-1.4.ps.gz
Refering-URL: http://haskell.systemsz.cs.yale.edu/definition/
Root-URL: http://www.cs.yale.edu
Author: John Peterson [editor] Kevin Hammond [editor] Lennart Augustsson Brian Boutel Warren Burton Joseph Fasel Andrew D. Gordon John Hughes Paul Hudak Thomas Johnsson Mark Jones Erik Meijer Simon Peyton Jones Alastair Reid Philip Wadler 
Keyword: Programming Language Haskell A Non-strict, Purely Functional Language  
Date: April 7, 1997  
Note: Version 1.4  
Abstract: Report on the Authors' affiliations: (1) Yale University, (2) University of St. Andrews, (3) Chalmers University of Technology, (4) Victoria University of Welling-ton, (5) Simon Fraser University, (6) Los Alamos National Laboratory, (7) University of Cambridge, (8) University of Glasgow, (9) University of Nottingham, (10) Utrecht University, (11) Bell Labs 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference: [2] <author> H.B. Curry and R. Feys. </author> <title> Combinatory Logic. </title> <publisher> North-Holland Pub. Co., </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference: [3] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <address> Albuquerque, N.M., </address> <month> January </month> <year> 1982. </year>
Reference-contexts: These "built-in" datatypes are described in detail in Section 6.1. 4.1 Overview of Types and Classes Haskell uses a traditional Hindley-Milner polymorphic type system to provide a static type semantics <ref> [3, 4] </ref>, but the type system has been extended with type and constructor classes (or just classes) that provide a structured way to introduce overloaded functions. 32 4. <p> With one exception, the type variables in a Haskell type expression are all assumed to be universally quantified; there is no explicit syntax for universal quantification <ref> [3] </ref>. For example, the type expression a -&gt; a denotes the type 8 a: a ! a . For clarity, however, we often write quantification explicitly when discussing the types of Haskell programs.
Reference: [4] <author> R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <month> December </month> <year> 1969. </year>
Reference-contexts: These "built-in" datatypes are described in detail in Section 6.1. 4.1 Overview of Types and Classes Haskell uses a traditional Hindley-Milner polymorphic type system to provide a static type semantics <ref> [3, 4] </ref>, but the type system has been extended with type and constructor classes (or just classes) that provide a structured way to introduce overloaded functions. 32 4.
Reference: [5] <author> P. Hudak, J. Fasel, and J. Peterson. </author> <title> A gentle introduction to Haskell. </title> <type> Technical Report YALEU/DCS/RR-901, </type> <institution> Yale University, </institution> <month> May </month> <year> 1996. </year>
Reference: [6] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: The first declaration above may be read "Int is an instance of the class Num as witnessed by these definitions (i.e. class methods) for (+) and negate." More examples of type and constructor classes can be found in the papers by Jones <ref> [6] </ref> or Wadler and Blott [11]. The term `type class' was used to describe the original Haskell 1.0 type system; `constructor class' was used to describe an extension to the original type classes. <p> For convenience, we write c =&gt; t even if the context c is empty, although in this case the concrete syntax contains no =&gt;. 4.1.3 Semantics of Types and Classes In this subsection, we provide informal details of the type system. (Wadler and Blott [11] and Jones <ref> [6] </ref> discuss type and constructor classes, respectively, in more detail.) The Haskell type system attributes a type to each expression in the program. <p> group: data C a =&gt; D a = Foo (S a) type S a = [D a] class C a where bar :: a -&gt; D a -&gt; Bool The kinds of variables, constructors, and classes within each group are determined using standard techniques of type inference and kind-preserving unification <ref> [6] </ref>. For example, in the definitions above, the parameter a appears as an argument of the function constructor (-&gt;) in the type of bar and hence must have kind fl.
Reference: [7] <author> P. Penfield, Jr. </author> <title> Principal values and branch cuts in complex APL. </title> <booktitle> In APL '81 Conference Proceedings, </booktitle> <pages> pages 248-256, </pages> <address> San Francisco, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: The precise definition of the above functions is as in Common Lisp, which in turn follows Penfield's proposal for APL <ref> [7] </ref>.
Reference: [8] <author> J. Peterson (editor). </author> <title> The Haskell Library Report. </title> <type> Technical Report YALEU/DCS/RR-1105, </type> <institution> Yale University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: There is one distinguished module, Prelude, which is imported into all programs by default (see Section 5.3), plus a set of standard library modules that may be imported as required (see the Haskell Library Report <ref> [8] </ref>). 5.1 Module Structure A module defines a mutually recursive scope containing declarations for value bindings, data types, type synonyms, classes, etc. (see Section 4). module ! module modid [exports] where body j body body ! - [impdecls ;] [[fixdecls ;] topdecls [;]] - j impdecls [;] - modid ! conid <p> There are also many predefined library modules, which provide less frequently used functions and types. For example, arrays, tables, and most of the input/output are all part of the standard libraries. These are defined in the Haskell Library Report <ref> [8] </ref>, a separate document.
Reference: [9] <editor> S.L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: order of declarations in where/let constructs is irrelevant. 2. let -d 1 ; d 2 in e = let -d 1 in (let -d 2 in e) (when no identifier bound in d 2 appears free in d 1 ) 2 A similar transformation is described in Peyton Jones' book <ref> [9] </ref>. 4.5 Static Semantics of Function and Pattern Bindings 49 4.5.2 Generalization The Hindley-Milner type system assigns types to a let-expression in two stages. First, the right-hand side of the declaration is typed, giving a type with no universal quantification.
Reference: [10] <editor> Unicode Consortium. </editor> <title> Unicode Character Data and Mappings. </title> <publisher> unicode.org. </publisher>
Reference-contexts: Haskell uses the Unicode <ref> [10] </ref> character set. However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell. Haskell uses a pre-processor to convert non-Unicode character sets into Unicode. <p> The basic boolean functions are && (and), || (or), and not. The name otherwise is defined as True to make guarded expressions more readable. 6.1.2 Characters and Strings The character type Char is an enumeration and consists of 16 bit values, conforming to the Unicode standard <ref> [10] </ref>. The lexical syntax for characters is defined in Section 2.5; character literals are nullary constructors in the datatype Char. Type Char is an instance of the classes Read, Show, Eq, Ord, Enum, and Bounded.


References-found: 10

