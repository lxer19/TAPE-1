URL: ftp://ftp.cs.toronto.edu/pub/kbms/vldb93.ps.Z
Refering-URL: ftp://ftp.cs.toronto.edu/pub/kbms/readme.html
Root-URL: 
Email: E-mail: dp@cs.toronto.edu  
Title: Integrity Constraint and Rule Maintenance in Temporal Deductive Knowledge Bases  
Author: Dimitris Plexousakis 
Address: Toronto, Ont. M5S 1A4, Canada  
Affiliation: Department of Computer Science University of Toronto  
Abstract: The enforcement of semantic integrity constraints in data and knowledge bases constitutes a major performance bottleneck. Integrity constraint simplification methods aim at reducing the complexity of formula evaluation at run-time. This paper proposes such a simplification method for large and semantically rich knowledge bases. Structural, temporal and asser-tional knowledge in the form of deductive rules and integrity constraints, is represented in Telos, a hybrid language for knowledge representation. A compilation method performs a number of syntactic, semantic and temporal transformations to integrity constraints and deductive rules, and organizes simplified forms in a dependence graph that allows for efficient computation of implicit updates. Precomputation of potential implicit updates at compile time is possible by computing the dependence graph transitive closure. To account for dynamic changes to the dependence graph by updates of constraints and rules, we propose efficient algorithms for the incremental maintenance of the computed transitive closure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Allen. </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: Telos adopts Allen's <ref> [1] </ref> interval-based time model for representing historical information about an application domain. Belief time records the history of the KB itself. The primitive notion of the time model is that of an interval. <p> Carrying out temporal simplification requires the employment of a temporal reasoner for deducing, in those cases this is possible, a temporal expression simplifying a conjunction of temporal relations. In its generality, the task may not be feasible. It has been shown <ref> [1] </ref> that certain combinations of temporal constraints introduce incomplete knowledge (disjunction). In our case however, where at least one of the temporal variables in the temporal relations introduced is instantiated, it is feasible to define a number of rules that allow to derive new temporal relations from already existing ones. <p> On the average, it is expected that the complexity of dependence graph modification will be much smaller, since only a subset of the deductive rules will match the constraint literals. To characterize the cost of insertion more precisely, let us define a function F : L ! <ref> [0; 1] </ref>, which returns, for each literal l, the frequency of its occurrences in rule heads. 7 On the average the number of edge additions required for the insertion of an integrity constraint will be equal to Cost IC insert = P Deletion: Deletion of constraints cannot cause an inconsistency.
Reference: [2] <author> F. Bry, H. Decker, and R. Manthey. </author> <title> A Uniform Approach to Constraint Satisfaction and Constraint Satisfiability in Deductive Databases. </title> <booktitle> In Proceedings of the Int. Conference on Extedning Data Base Technology, </booktitle> <pages> pages 488-505, </pages> <year> 1988. </year>
Reference-contexts: Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. A number of incremental constraint checking techniques for relational (e.g. [13]), deductive (e.g. [4], <ref> [2] </ref>, [8]) and, most recently, object-oriented databases [7] have appeared in the recent literature. Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. [3]). <p> The meaning of each restricted quantification is that the variable bound by the quantifier ranges over the extension of the class instead of the entire domain. Any constraint in this form is range-restricted [4]. This class of constraints is equivalent to both the restricted quantification form of <ref> [2] </ref> and the range form of [7]. <p> one of the above forms is transformed to its untyped form, whereas the restricted quantification form is ob 2 The belief time component of these predicates is omitted when they appear in the head of deductive rules. 3 A formula is rectified if no two quantifiers introduce the same variable <ref> [2] </ref>. tained from the range form by imposing the restriction that F is in miniscope negation normal form. <p> Our method builds on the compilation method that was initially proposed in <ref> [2] </ref> and was later adapted to an object-oriented setting in [7]. The efficiency of the method stems from the separation of the task of constraint enforcement in two separate phases: a compilation phase, performed at schema definition time and an evaluation phase performed at KB update time.
Reference: [3] <author> J. Chomicki. </author> <title> History-less Checking of Dynamic Integrity Constraints. </title> <booktitle> In 8th Int. Conference on Data Engineering, </booktitle> <pages> pages 557-564, </pages> <address> Phoenix,AZ, </address> <year> 1992. </year>
Reference-contexts: Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. <ref> [3] </ref>). To the best of our knowledge, there has been no proposal for compile-time simplification of temporal (static and dynamic) integrity constraints. We propose such a method in this paper. The presence of deductive rules also complicates constraint enforcement: explicit updates may cause implicit updates which may violate integrity constraints. <p> Temporal simplification is performed efficiently by a table lookup. Other attempts to treat uniformly static and dynamic constraints restrict attention to specific types of constraints (e.g. transition constraints) and do not contain explicit temporal information [14]. Chomicki's techniques <ref> [3] </ref> are beneficial to the enforcement of dynamic constraints since they permit their evaluation without having to consider the entire history of the KB.
Reference: [4] <author> H. Decker. </author> <title> Integrity Enforcement in Deductive Databases. </title> <booktitle> In Expert Database Systems, 1st Int. </booktitle> <pages> Conference , pages 271-285, </pages> <year> 1986. </year>
Reference-contexts: Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. A number of incremental constraint checking techniques for relational (e.g. [13]), deductive (e.g. <ref> [4] </ref>, [2], [8]) and, most recently, object-oriented databases [7] have appeared in the recent literature. Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. [3]). <p> Each C i is a Telos class. The meaning of each restricted quantification is that the variable bound by the quantifier ranges over the extension of the class instead of the entire domain. Any constraint in this form is range-restricted <ref> [4] </ref>. This class of constraints is equivalent to both the restricted quantification form of [2] and the range form of [7].
Reference: [5] <author> K. Hulsmann and G. Saake. </author> <title> Representation of the Historical Information Necessary for Temporal Integrity Monitoring. </title> <booktitle> In 2nd Int. Conference on Extending Data Base Technology, </booktitle> <pages> pages 378-392, </pages> <address> Venice, Italy, </address> <year> 1990. </year>
Reference-contexts: We consider this to be a major restriction for temporal KBs modeling an evolving domain. Techniques proposed for temporal integrity monitoring (e.g. <ref> [5] </ref>) are run-time methods, whereas we have focused on simplifying formulae as much as possible at schema definition time. Performance is less critical at compile-time. Current research focuses on the definition of an efficient hybrid theorem prover for the evaluation of temporal constraints, in the flavor of [10].
Reference: [6] <author> G. </author> <title> Italiano. Finding Paths and Deleting Edges in Directed Acyclic Graphs. </title> <journal> Information Processing Letters, </journal> <volume> 28(1) </volume> <pages> 5-11, </pages> <year> 1988. </year>
Reference-contexts: A number of algorithms have been proposed for on-line maintenance of transitive closure (e.g. <ref> [6] </ref>) but are not applicable to cyclic graphs. In [15] we propose algorithms that maintain reachability information for edge insertions and deletions in the dependence graph. These algorithms are shown to be correct for graphs with the properties of a dependence graph. We briefly describe each of them here.
Reference: [7] <author> M. Jeusfeld and M. Jarke. </author> <title> From Relational to Object-Oriented Integrity Simplification. </title> <booktitle> In Proceedings of DOOD-91, </booktitle> <pages> pages 460-477, </pages> <year> 1991. </year>
Reference-contexts: Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. A number of incremental constraint checking techniques for relational (e.g. [13]), deductive (e.g. [4], [2], [8]) and, most recently, object-oriented databases <ref> [7] </ref> have appeared in the recent literature. Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. [3]). <p> Any constraint in this form is range-restricted [4]. This class of constraints is equivalent to both the restricted quantification form of [2] and the range form of <ref> [7] </ref>. <p> Our method builds on the compilation method that was initially proposed in [2] and was later adapted to an object-oriented setting in <ref> [7] </ref>. The efficiency of the method stems from the separation of the task of constraint enforcement in two separate phases: a compilation phase, performed at schema definition time and an evaluation phase performed at KB update time. <p> During compilation, constraints and relevant rules are compiled into simplified forms whose evaluation can be triggered by the occurrence of affecting updates. Our proposal advances the method of <ref> [7] </ref> by taking time into account and by optimizing the compile-time computation of implicit updates. 3.1 Compilation of Constraints and Rules Let us first explain the rationale behind simplification by means of an example. <p> The definition of relevance found in <ref> [7] </ref> is not sufficient in the presence of time. The following definition provides sufficient conditions for "relevance" of a constraint to an update, by considering the relationships of the time intervals participating in the literals of the constraint and the update. <p> The History and Belief Time components contain the history and belief time intervals associated with the constraint. The Concerned Class for a literal L is a class C such that, inserting or deleting an instance of C can affect the truth of L <ref> [7] </ref>. The role of a concerned class is to limit the search space for constraints affected by an update. This is possible because of the fine granularity not found in relational databases provided by aggregation. In the presence of time and specialization, this definition must be refined appropriately. <p> It can however depend transitively on a rule whose conclusion literal matches a condition literal of a rule on which the constraint depends either directly or transitively. Formally, we can define the notions of dependence and direct dependence along the lines of <ref> [7] </ref>. <p> In that case, the conclusions of the rule must be derived and checked for possible constraint violations. These implicit updates may trigger 7 This type of information can be available after KB compilation and can be maintained incrementally after modifications. 8 In <ref> [7] </ref>, if this process results in isolated nodes representing simplified rules on which the deleted constraint previously depended, then these nodes are removed as well.
Reference: [8] <author> V. Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <booktitle> In 2nd International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 478-502, </pages> <address> Munich, Germany, </address> <year> 1991. </year>
Reference-contexts: Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. A number of incremental constraint checking techniques for relational (e.g. [13]), deductive (e.g. [4], [2], <ref> [8] </ref>) and, most recently, object-oriented databases [7] have appeared in the recent literature. Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. [3]). <p> A performance assessment of the method is in progress. The method needs to be compared against one-phase methods that interleave simplification and evaluation <ref> [8] </ref> and run-time methods.
Reference: [9] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year> <note> 2nd edition. </note>
Reference-contexts: According to the standard transformation of typed quantified formulae to untyped ones <ref> [9] </ref> the following equivalences hold: 8x=T F 8x T (x) ) F and 9x=T F 9x T (x) ^ F . <p> Atom A may not contain belief time, since belief time is set by the system, and variables other than x 1 ; . . .; x n . Deductive rules in this form are also range-restricted. Moreover, deductive rules are assumed to be stratified <ref> [9] </ref>. Constraints and rules are associated with history and belief time intervals. If no such association appears explicitly with their definition, both intervals are assumed to be equal to (systime..*), where systime denotes the current system time.
Reference: [10] <author> S. Miller and L. Schubert. </author> <title> Time Revisited. </title> <journal> Computational Intelligence, </journal> <volume> 6 </volume> <pages> 108-118, </pages> <year> 1990. </year>
Reference-contexts: Performance is less critical at compile-time. Current research focuses on the definition of an efficient hybrid theorem prover for the evaluation of temporal constraints, in the flavor of <ref> [10] </ref>. Such a theorem prover may be enhanced with techniques for reduction of temporal formulae referring to long histories into formulae evaluable in a pair of states only [18]. A performance assessment of the method is in progress.
Reference: [11] <author> J. Mylopoulos, A. Borgida, M. Jarke, and M. Koubarakis. </author> <title> Telos: A Language for Representing Knowledge in Information Systems. </title> <journal> ACM TOIS, </journal> <volume> 8(4) </volume> <pages> 325-362, </pages> <year> 1990. </year>
Reference-contexts: Procedural constraint specification inadvertently ties constraint enforcement with transaction specification and leads to expensive run-time integrity checks. Declarative specification of constraints permits their treatment as first-class citizens of the KB and allows automating their optimization process. Telos <ref> [11] </ref> regards constraints as objects of their own right, and as such, they can be inserted or removed, and are subject to consistency violation. Constraints in Telos are specified declaratively via a first-order assertion language. A second issue is that of efficient constraint checking. <p> Preliminary performance results are also presented and the paper is concluded in section 5 with an outlook for further research. 2 Overview of Telos The representational framework of Telos <ref> [11] </ref> is a generalization of graph-theoretic data structures used in se 1 A finer grained approach could initiate a sequence of updates so that constraints are satisfied in the resulting state. mantic networks, semantic data models and structurally object-oriented representations.
Reference: [12] <author> J. Mylopoulos, V. Chaudhri, D. Plexousakis, and T. Topaloglou. </author> <title> A Performance Oriented Approach to Knowledge Base Management. </title> <booktitle> In 1st Int. Conference on Information and Knowledge Management, </booktitle> <pages> pages 68-75, </pages> <address> Baltimore, MD, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction The problem of efficient management and enforcement of semantic integrity constraints constitutes a cornerstone issue in the development of knowledge base management systems (hereafter KBMSs) <ref> [12] </ref>. Undoubtedly knowledge bases (KBs) will form an integral part of information systems of the future. Aimed at modeling a multitude of application domains, these systems will be required to represent consistently and reason efficiently with large amounts and a wide range of knowledge. <p> To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 19th VLDB Conference Dublin, Ireland 1993 trol and integrity enforcement are needed for managing such large KBs <ref> [12] </ref>. Integrity constraints specify the valid states of a KB (static) as well as the allowable KB state transitions (dynamic).
Reference: [13] <author> J.-M. Nicolas. </author> <title> Logic for Improving Integrity Checking in Relational Databases. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: Incremental integrity checking methods are based on the premise that constraints are known to be satisfied prior to an update <ref> [13] </ref>. Only a subset of the constraints need to be verified after the update, namely those that are affected by it. Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. <p> Incremental integrity checking is made possible by specializing integrity constraints with respect to the anticipated types of updates and by performing simplifications on the specialized forms. A number of incremental constraint checking techniques for relational (e.g. <ref> [13] </ref>), deductive (e.g. [4], [2], [8]) and, most recently, object-oriented databases [7] have appeared in the recent literature. Most methods concentrate on the enforcement of static constraints. Dynamic constraint checking methods are mainly based on temporal logics and are run-time methods (e.g. [3]). <p> The actual values of the variables in the constraint are not known. They are replaced by parameters which are instantiated at evaluation time. Note however that only 8-quantified variables not governed by 9 (called instantiation variables) can be replaced by parameters. As shown in <ref> [13] </ref>, replacing 9-quantified variables or 8-quantified variables governed by 9 with constants or parameters, may lead to counterintuitive or incorrect instances. Let us introduce some terminology for formalizing the simplification method.
Reference: [14] <author> Olive, A. </author> <title> Integrity Constraints Checking in Deductive Databases. </title> <booktitle> In 17th VLDB Conference, </booktitle> <pages> pages 513-523, </pages> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: Temporal simplification is performed efficiently by a table lookup. Other attempts to treat uniformly static and dynamic constraints restrict attention to specific types of constraints (e.g. transition constraints) and do not contain explicit temporal information <ref> [14] </ref>. Chomicki's techniques [3] are beneficial to the enforcement of dynamic constraints since they permit their evaluation without having to consider the entire history of the KB.
Reference: [15] <author> D. Plexousakis. </author> <title> Integrity Maintenance in a Telos based KBMS. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: Hence, the simplification method is sound. The method is also complete in the sense that all possible temporal transformations are performed. No transformation takes place in those cases where the derived temporal relationship is a disjunction of temporal predicates. Detailed proofs are found in <ref> [15] </ref>. Dynamic Constraints Simplification is applicable in the case of dynamic (epistemic) constraints as well. <p> From the graph definition it can be seen that the graph has a particular structure: there are no edges initiating at constraint nodes. A dependence graph may contain cycles among deductive rule nodes. This happens in the case the KB contains mutually recursive rules. As shown in <ref> [15] </ref> the graph is free of trivial cycles and enjoys the property expressed in the following lemma. Lemma: For any Telos KB, dependence graph construction yields a graph that may contain cycles of length at most equal to the number of deductive rules participating in the same recursive scheme. <p> At evaluation time, reachability information does not have to be recomputed. Space restrictions do not permit a detailed analysis of the algorithm in this paper. The algorithm and its analysis are found in <ref> [15] </ref>. The implicit updates computed in this manner are only potential updates. <p> We also present results from experiments with random graphs. It will be assumed that the computed transitive closure (T C) is represented in a form that permits checking reachability between any two graph nodes in O (1) time. A detailed presentation and analysis of the algorithms is found in <ref> [15] </ref>. 4.1 Updates of Integrity Constraints Insertion: For the time being we assume the traditional semantics attributed to the insertion of an integrity constraint, namely that a new constraint must be evaluated against the KB and be accepted only if found true; otherwise it has to be rejected. <p> A number of algorithms have been proposed for on-line maintenance of transitive closure (e.g. [6]) but are not applicable to cyclic graphs. In <ref> [15] </ref> we propose algorithms that maintain reachability information for edge insertions and deletions in the dependence graph. These algorithms are shown to be correct for graphs with the properties of a dependence graph. We briefly describe each of them here.
Reference: [16] <author> D. Plexousakis. </author> <title> Semantical and Ontological Considerations in Telos: a Lanugage for Knowledge Representation. </title> <journal> Computational Intelligence, </journal> <volume> 9(1) </volume> <pages> 41-72, </pages> <year> 1993. </year>
Reference-contexts: Among the distinguishing aspects of Telos are the novel treatment of attributes, the extensibility provided by the metaclassing mechanism and the special representational and inferential capabilities for temporal knowledge. Telos has a well defined semantics based on a possible-worlds model <ref> [16] </ref>. Telos KBs are collections of propositions. A proposition, the single representational unit provided, is formally defined as a quadruple with components from, label, to and when. These denote the source, label, destination and duration of the proposition respectively and are propositions themselves.
Reference: [17] <author> G. Qaddah, L. Henschen, and J. Kim. </author> <title> Efficient Algorithms for the Instantiated Transitive Closure Queries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 296-309, </pages> <year> 1991. </year>
Reference-contexts: Following paths from rules to constraints in the graph permits us to derive implicit updates caused by explicit ones. The set of implicit updates can be precomputed at the time of graph construction using efficient algorithms for transitive closure computation, such as the ffi wavefront algorithm of <ref> [17] </ref> for solving the reachability problem. The algorithm, applicable to directed acyclic graphs, has been modified to take advantage of the dependence graph properties.
Reference: [18] <author> G. Saake and U. Lipeck. </author> <title> Foundations of Temporal Integrity Monitoring. </title> <editor> In C. Roland, editor, </editor> <booktitle> Temporal Aspects in Information Systems, </booktitle> <pages> pages 235-249. </pages> <year> 1988. </year>
Reference-contexts: Such a theorem prover may be enhanced with techniques for reduction of temporal formulae referring to long histories into formulae evaluable in a pair of states only <ref> [18] </ref>. A performance assessment of the method is in progress. The method needs to be compared against one-phase methods that interleave simplification and evaluation [8] and run-time methods.
References-found: 18

