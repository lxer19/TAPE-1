URL: http://www.cs.ucl.ac.uk/staff/a.hunter/tosem.ps
Refering-URL: http://www.cs.ucl.ac.uk/staff/A.Hunter/papers.html
Root-URL: http://www.cs.ucl.ac.uk
Email: a.hunter@cs.ucl.ac.uk  ban@doc.ic.ac.uk  
Title: Managing Inconsistent Specifications: Reasoning, Analysis and Action  
Author: Anthony Hunter Bashar Nuseibeh 
Address: Gower Street London WC1E 6BT  London SW7 2BZ, UK  
Affiliation: Department of Computer Science University College London  Department of Computing Imperial College  
Abstract: In previous work, we advocated continued development of specifications in the presence of inconsistency. To support this, we used classical logic to represent partial specifications and to identify inconsistencies between them. We now present an adaptation of classical logic, which we term quasi-classical (QC) logic, that allows continued reasoning in the presence of inconsistency. The adaptation is a weakening of classical logic that prohibits all trivial derivations, but still allows all resolvants of the assumptions to be derived. Furthermore, the connectives behave in a classical manner. We then present a development called labelled QC logic that records and tracks assumptions used in reasoning. This facilitates a logical analysis of inconsistent information. We discuss the application of labelled QC logic in the analysis of multi-perspective specifications. Such specifications are developed by multiple participants who hold overlapping, often inconsistent, views of the systems they are developing. 
Abstract-found: 1
Intro-found: 1
Reference: [AC91] <author> W Atkinson and J Cunningham. </author> <title> Proving properties of safety-critical systems. </title> <journal> BCS/IEE Software Engineering Journal, </journal> <volume> 6(2) </volume> <pages> 41-50, </pages> <year> 1991. </year>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [Bal91] <author> R Balzer. </author> <title> Tolerating inconsistency. </title> <booktitle> In Proceedings of 13th International Conference on Software Engineering (ICSE-13), </booktitle> <pages> pages 158-165. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The analysis of inconsistencies however is limited to identifying one of six predefined types of inconsistency in programming code. Balzer has proposed the notion of "tolerating inconsistency" by relaxing consistency constraints during development <ref> [Bal91] </ref>.
Reference: [BCP94] <author> C Bourley, R Caferra, and N Peltier. </author> <title> A method for building models automatically: Experiments with an extension of otter. </title> <booktitle> In Proceedings of the Twelfth Conference on Computer-Aided Deduction (CADE-12), volume 814 of Lecture Notes in Computer Science, </booktitle> <pages> pages 72-86. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [BDP93] <author> S Benferhat, D Dubois, and H Prade. </author> <title> Argumentative inference in uncertain and inconsistent knowledge bases. </title> <booktitle> In Proceedings of Uncertainty in Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use 19 of specificity [Poo85], ordered theory presentations [Rya92], preferred subtheor--ies [Bre89], explicit preferences [Pra93], and prioritised syntax-based entailment <ref> [BDP93] </ref>. 5 Towards acting on inconsistency The logical analysis of inconsistency described in this paper is part of a wider framework for handling inconsistency. The analysis described in the previous section can be used to generate a "report" that identifies inconsistencies and provides "diagnosis" of these inconsistencies.
Reference: [Bea96] <author> M Bearne. </author> <title> Hypermedia visualization for system requirements in a collaborative distributive environment. </title> <type> Technical Report TN3491, </type> <institution> Philips Research Labs, Redhill, Surrey, </institution> <year> 1996. </year>
Reference-contexts: We intend to supplement this with more sophisticated, Prolog-based, analysis and reasoning computational engines. Finally, following on from work with Philips Research Labs on a Collaborative Requirements Engineering Support Tool (CREST) <ref> [Bea96] </ref>, we are currently developing a distributed, web-based implementation of the above using Java [RNK98]. 8 Related work The overwhelming majority of work on consistency management has dealt with tools and techniques for maintaining consistency and avoiding inconsistency.
Reference: [Bel77] <author> N Belnap. </author> <title> A useful four-valued logic. </title> <editor> In G Epstein, editor, </editor> <booktitle> Modern Uses of Multiple-Valued Logic, </booktitle> <pages> pages 8-37. </pages> <publisher> Reidel, </publisher> <year> 1977. </year>
Reference-contexts: Reasoning with QC logic is a one-step process. If we want to derive an inference, we need to constrain a complete proof. There have been a number of other proposals for reasoning with classical formulae that are inconsistent. Key logics include C ! [dC74] and four-valued logic <ref> [Bel77] </ref>. QC logic differs in having a richer proof theory but at the price of loosing tautologies and prohibiting proofs to be used as lemmas in further proofs.
Reference: [Bes91] <author> Ph Besnard. </author> <title> Paraconsistent logic approach to knowledge representation. </title> <editor> In M de Glas M and D Gabbay D, editors, </editor> <booktitle> Proceedings of the First World Conference on Fundamentals of Artificial Intelligence, </booktitle> <pages> pages 107-114. </pages> <publisher> Angkor, </publisher> <year> 1991. </year>
Reference-contexts: However, this kind of weakening of the proof rules means that the connectives in the language do not behave in a classical fashion <ref> [Bes91] </ref>. For example, disjunctive syllogism does not hold, ((ff _ fi) ^:fi) ! ff, whereas modus ponens does hold, as illustrated by the following example.
Reference: [BH95] <author> Ph Besnard and A Hunter. </author> <title> Quasi-classical logic: Non-trivializable classical reasoning from inconsistent information. </title> <editor> In C Froidevaux and J Kohlas, editors, </editor> <title> Symbolic and Quantitative Approaches to Uncertainty, </title> <booktitle> volume 946 of Lecture Notes in Computer Science, </booktitle> <pages> pages 44-51, </pages> <year> 1995. </year>
Reference-contexts: There are many similar examples that could be confusing and counterintuitive for users of such a practical reasoning system. An alternative compromise is quasi-classical (QC) logic <ref> [BH95] </ref>. <p> All the QC natural deduction rules hold in classical logic, but some classical deduction rules, such as ex falso quodlibet do not hold in QC logic. For a more complete coverage of QC logic the reader is referred to <ref> [BH95, Hun96, Hun98] </ref>. We obtain labelled QC logic by using only labelled formulae as assumptions, and by amending the natural deduction rules to propagate the labels. The label of the consequent of a rule is the union of the labels of the premises of the rule.
Reference: [Bib93] <author> W Bibel. </author> <title> Deduction: Automated logic. </title> <publisher> Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [BKMS92] <author> C Baral, S Kraus, J Minker, and V Subrahmanian. </author> <title> Combining knowledge bases consisting of first order theories. </title> <journal> Computational Intelligence, </journal> <volume> 8 </volume> <pages> 45-71, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, they provide a useful vocabulary for participants in the development process to discuss the inconsistent information. 17 Handling inconsistent information using maximally consistent subsets has been considered in a number of approaches including logics (for a review see [EGH95]), combining knowledge bases (for example <ref> [BKMS92] </ref>), and truth maintenance systems (for example [Doy79, Kle86]), we go beyond this by adopting universal and free inferencing.
Reference: [Bor85] <author> A Borgida. </author> <title> Language features for flexible handling of exceptions in information systems. </title> <journal> Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 565-603, </pages> <year> 1985. </year>
Reference-contexts: Work on programming languages which are supported by exception handling mechanisms that deal with errors resulting from built-in operations (e.g., division by zero) is also relevant. Building on this work, Borgida proposed an approach to handling violations of assumptions in a database <ref> [Bor85] </ref>. His approach provides for "blaming" violations on one or more database facts. In this way, either a program can be designed to detect and treat "unusual" facts, or a database can adjust its constraints to tolerate the violation in the data.
Reference: [Bre89] <author> G Brewka. </author> <title> Preferred subtheories: An extended logical framework for default reasoning. </title> <booktitle> In Proceedings of the Eleventh International Conference on Artificial Intelligence, </booktitle> <pages> pages 1043-1048, </pages> <year> 1989. </year>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [GH98]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use 19 of specificity [Poo85], ordered theory presentations [Rya92], preferred subtheor--ies <ref> [Bre89] </ref>, explicit preferences [Pra93], and prioritised syntax-based entailment [BDP93]. 5 Towards acting on inconsistency The logical analysis of inconsistency described in this paper is part of a wider framework for handling inconsistency.
Reference: [CCB90] <author> M Costa, R Cunningham, and J Booth. </author> <title> Logical animation. </title> <booktitle> In Proceedings of the twelth International conference on software engineering, </booktitle> <pages> pages 144-149, </pages> <address> Nice, 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [CNFG96] <author> G Cugola, E Di Nitto, A Fuggetta, and C Ghezzi. </author> <title> A framework for formalizing inconsistencies and deviations in human-centered systems. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(3) </volume> <pages> 191-230, </pages> <year> 1996. </year>
Reference-contexts: Since this policy is overly restrictive, many developers attempt to fake conformance to the process definition (for example, by fooling a tool into thinking that a certain task has been performed in order to continue development). Cugola et al. <ref> [CNGM95, CNFG96] </ref> have addressed exactly this problem in their temporal logic-based approach which is used to capture and tolerate some deviations from a process description during execution.
Reference: [CNGM95] <author> G Cugola, E Di Nitto, C Ghezzi, and M Mantione. </author> <title> How to deal with deviations during process model enactment. </title> <booktitle> In Proceedings of 17th International Conference on Software Engineering (ICSE-17), </booktitle> <pages> pages 265-273, </pages> <address> Seattle, USA, 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Since this policy is overly restrictive, many developers attempt to fake conformance to the process definition (for example, by fooling a tool into thinking that a certain task has been performed in order to continue development). Cugola et al. <ref> [CNGM95, CNFG96] </ref> have addressed exactly this problem in their temporal logic-based approach which is used to capture and tolerate some deviations from a process description during execution.
Reference: [CP95] <author> R Caferra and N Peltier. </author> <title> Model building and interactive theory discovery. In Fourth Workshop on Theorem Proving with Analytic Tableaux and Related Methods, </title> <booktitle> volume 918 of Lecture Notes in Computer Science, </booktitle> <pages> pages 154-168. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [CW96] <author> E Clarke and J Wing et al. </author> <title> Formal methods: State of the art and future directions. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4) </volume> <pages> 626-646, </pages> <year> 1996. </year>
Reference-contexts: Furthermore, for both the propositional and first-order cases, it also means that there is a model of a consistent set of formulae. In addition, there has been much progress in developing technology for classical reasoning <ref> [CW96] </ref>.
Reference: [CZ93] <author> R Caferra and N Zabel. </author> <title> Building models by using tableaux extended by equational problems. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3 </volume> <pages> 3-25, </pages> <year> 1993. </year>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [dC74] <author> N C da Costa. </author> <title> On the theory of inconsistent formal systems. </title> <journal> Notre Dame Journal of Formal Logic, </journal> <volume> 15 </volume> <pages> 497-510, </pages> <year> 1974. </year>
Reference-contexts: For classical logic, trivialisation renders the specification useless, and therefore classical logic is obviously unsatisfactory for handling inconsistent information. A possible solution is to weaken classical logic by dropping some of the inferencing capability (reductio ad absurdum), such as for the C ! paraconsistent logic <ref> [dC74] </ref>. However, this kind of weakening of the proof rules means that the connectives in the language do not behave in a classical fashion [Bes91]. For example, disjunctive syllogism does not hold, ((ff _ fi) ^:fi) ! ff, whereas modus ponens does hold, as illustrated by the following example. <p> Reasoning with QC logic is a one-step process. If we want to derive an inference, we need to constrain a complete proof. There have been a number of other proposals for reasoning with classical formulae that are inconsistent. Key logics include C ! <ref> [dC74] </ref> and four-valued logic [Bel77]. QC logic differs in having a richer proof theory but at the price of loosing tautologies and prohibiting proofs to be used as lemmas in further proofs.
Reference: [Dow93] <author> M Dowson. </author> <title> Consistency maintenance in process sensitive environments. </title> <booktitle> In Proceedings of Workshop on Process Sensitive Environments Architectures, </booktitle> <address> Boulder, Colorado, USA, </address> <year> 1993. </year> <institution> Rocky Mountain Institute of Software Engineering (RMISE). </institution> <month> 34 </month>
Reference-contexts: Finally, a small body of work addresses inconsistencies that arise in software development processes themselves. For example, an inconsistency may occur 30 between a software development process definition and the actual (enacted) process instance <ref> [Dow93] </ref>. Such an inconsistency between "enactment state" and "performance state" is often avoided by blocking further development activities until some precondition is made to hold.
Reference: [Doy79] <author> J Doyle. </author> <title> A truth maintenance system. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: provide a useful vocabulary for participants in the development process to discuss the inconsistent information. 17 Handling inconsistent information using maximally consistent subsets has been considered in a number of approaches including logics (for a review see [EGH95]), combining knowledge bases (for example [BKMS92]), and truth maintenance systems (for example <ref> [Doy79, Kle86] </ref>), we go beyond this by adopting universal and free inferencing. <p> Otherwise, deviations are tolerated, recorded and propagated and "pollution analysis" (based on logical reasoning) is performed to identify possible sources of inconsistency. The framework we have described in this paper also provides more sophisticated options than truth maintenance (such as <ref> [Doy79, Kle86] </ref>) for managing inconsistency specifications. These include: (1) paraconsistent reasoning with sets of inconsistent formulae; (2) labelling strategies to allow inconsistent formulae to be tracked, and likely sources identified using meta-level information; and (3) reasoning with universal and free inferences in addition to reasoning with existential inferences.
Reference: [EGH95] <author> M Elvang-Goransson and A Hunter. </author> <title> Argumentative logics: Reasoning from classically inconsistent information. </title> <journal> Data and Knowledge Engineering Journal, </journal> <volume> 16 </volume> <pages> 125-145, </pages> <year> 1995. </year>
Reference-contexts: We can either reason with the data directly using F REE () or we can revise the data by removing the formulae corresponding to S We now use these concepts to define three qualifications for an inference from inconsistent information. The approach is a derivative of argumentative logics <ref> [EGH95] </ref>. 16 Definition 4.3 Let be a set of labelled formulae, and let ` Q i : ff hold. <p> Furthermore, they provide a useful vocabulary for participants in the development process to discuss the inconsistent information. 17 Handling inconsistent information using maximally consistent subsets has been considered in a number of approaches including logics (for a review see <ref> [EGH95] </ref>), combining knowledge bases (for example [BKMS92]), and truth maintenance systems (for example [Doy79, Kle86]), we go beyond this by adopting universal and free inferencing.
Reference: [EN95] <author> S Easterbrook and B Nuseibeh. </author> <title> Managing inconsistencies in an evolving specification. </title> <booktitle> In Proceedings of 2nd International Symposium on Requirements Engineering (RE '95), </booktitle> <pages> pages 48-55. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: They are normally prescribed as part of the method definition; e.g., "every decomposed process in a dataflow diagram must have a cor responding parent process". Domain information which is incrementally captured in an evolving specification process <ref> [EN95, EN96] </ref>. This information might pertain to the problem domain in which the system will be installed (and which is usually captured and represented separately). For example, it might include on tologies for a particular problem domain such as telecommunications.
Reference: [EN96] <author> S Easterbrook and B Nuseibeh. </author> <title> Using viewpoints for inconsistency management. </title> <journal> BCS/IEE Software Engineering Journal, </journal> <volume> 11(1) </volume> <pages> 31-43, </pages> <year> 1996. </year>
Reference-contexts: They are normally prescribed as part of the method definition; e.g., "every decomposed process in a dataflow diagram must have a cor responding parent process". Domain information which is incrementally captured in an evolving specification process <ref> [EN95, EN96] </ref>. This information might pertain to the problem domain in which the system will be installed (and which is usually captured and represented separately). For example, it might include on tologies for a particular problem domain such as telecommunications.
Reference: [FD96] <author> A Finkelstein and J Dowell. </author> <title> A comdey of errors: The London Ambulance Service case study. </title> <booktitle> In Proceedings of 8th International Workshop on Software Specification and Design (IWSSD-8), </booktitle> <pages> pages 2-4. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: This work is speculative, and is presented as an agenda for future work. Section 6 presents an example application that illustrates the different facets of our contribution. The application is taken from a case study of the Computer-Aided Despatching system for the London Ambulance Service <ref> [FD96] </ref>. It is followed in section 7 by an outline of the scope of, and our contributions to, automated support for inconsistency management as described in the paper. <p> In the following, we present excerpts of an example application: eliciting and specifying the requirements of the London Ambulance Service (LAS). This case study was the focus of, and common example used by, delegates at the Eighth International Workshop on Software Specification and Design (IWSSD-8) <ref> [FD96] </ref>. The intention is to illustrate the techniques we have described in this paper in the context of a "real world" example.
Reference: [Fea96] <author> M Feather. </author> <title> Modularized exception handling. </title> <booktitle> In Proceedings of International Workshop on Multiple Perspectives in Software Development (Viewpoints 96), </booktitle> <pages> pages 167-171. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: In this way, either a program can be designed to detect and treat "unusual" facts, or a database can adjust its constraints to tolerate the violation in the data. Balzer's approach described above is based on Borgida's mechanisms. Feather has recently also proposed an approach to modularised exception handling <ref> [Fea96] </ref> in which programs accessing a shared database of information impose their own assumptions on the database, and treat exceptions to those assumptions differently. The assumptions made by each program together with their respective exception handlers are used to provide each program with its own individual view of the database.
Reference: [FGH + 94] <author> A Finkelstein, D Gabbay, A Hunter, J Kramer, and B Nuseibeh. </author> <title> Inconsistency handling in multi-perspective specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8) </volume> <pages> 569-578, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction In a previous paper <ref> [FGH + 94] </ref> we advocated the need to tolerate inconsistencies in software development, and more importantly to be able to act in a context-dependent way in response to inconsistency. <p> For example, it might include on tologies for a particular problem domain such as telecommunications. All three kinds of information described above (and represented as facts, rules, graphs, etc.) can be translated into logical formulae <ref> [FGH + 94] </ref>. In this paper, however, we will focus on translation and inconsistency detection in specification information only. Additional assumptions can also be used to facilitate this inconsistency detection process. <p> input, we can adopt a meta-level approach to prescribe inconsistency handling rules of the form: Inconsistency implies Action One approach is to deploy an action-based temporal logic that allows us to specify the past context and source of an inconsistency in order to prescribe future actions to handle the inconsistency <ref> [GH93, FGH + 94] </ref>.
Reference: [Fit90] <author> M Fitting. </author> <title> First-order Logic and Automated Theorem Proving. </title> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation. <p> For example, negotiation-support tools can be used to facilitate removing inconsistencies and resolving conflicts. There are fewer tools available however that explicitly support reasoning and analysis in the manner we have described in this paper. Nevertheless, tools that support automated reasoning and deduction are available (for example <ref> [Fit90] </ref>). Such tools can take assumptions, logic proof rules and queries as input, and make automatic deductions from this information.
Reference: [FKN + 92] <author> A Finkelstein, J Kramer, B Nuseibeh, L Finkelstein, and M Goedicke. </author> <title> Viewpoints: A framework for multiple perspectives in system development. </title> <journal> International Journal of Software Engineering and Knowledge Engineering (Special issue on Trends and Future Research Directions in Software Engineering Environments), </journal> <volume> 2(1) </volume> <pages> 31-57, </pages> <year> 1992. </year>
Reference-contexts: We preface and conclude the paper with a discussion on the context of the work, namely, multi-perspective software development within the "ViewPoints framework" <ref> [FKN + 92] </ref>. ViewPoints provide an organisational framework within which multiple development participants hold multiple views on a problem or solution domain. Inconsistencies within and between different ViewPoints typically arise, and the work described in this paper provides a means of managing such inconsistencies. <p> Development information includes: Specification information about the actual system ("product") being developed, which in previous work we have captured as a collection of partial specifications denoted by loosely coupled, locally managed, distributable objects called "ViewPoints" <ref> [FKN + 92] </ref>. Method information about the process of development and the representation schemes used to express partial specifications. This information also includes integrity constraints between representation schemes which we have captured as "inter-ViewPoint rules" [NKF94].
Reference: [GH91] <author> D Gabbay and A Hunter. </author> <title> Making inconsistency respectable 1: A logical framework for inconsistency in reasoning. </title> <booktitle> In Fundamentals of Artificial Intelligence, volume 535 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-32. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: Hence, classical logic does not provide a means for continued deduction in the presence of inconsistency. Moreover, attempts to formalise the notion of inconsistency, and approaches for handling it, have also been generally unsuccessful since they take the view that inconsistency is "undesirable" and "unusable" <ref> [GH91, GH93] </ref>. In this paper, we present a formal yet pragmatic approach that supports continued action (including reasoning) in the presence of inconsistency, and facilitates the recording and tracking of (inconsistent) information during reasoning. The technical contributions of the paper are in two main parts.
Reference: [GH93] <author> D Gabbay and A Hunter. </author> <title> Making inconsistency respectable 2: Meta-level handling of inconsistent data. </title> <booktitle> In Proceedings of the European Conference on Symbolic and Qualitative Approaches to 35 Reasoning and Uncertainty (ECSQARU`93), volume 747 of Lecture Notes in Computer Science, </booktitle> <pages> pages 129-136. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Hence, classical logic does not provide a means for continued deduction in the presence of inconsistency. Moreover, attempts to formalise the notion of inconsistency, and approaches for handling it, have also been generally unsuccessful since they take the view that inconsistency is "undesirable" and "unusable" <ref> [GH91, GH93] </ref>. In this paper, we present a formal yet pragmatic approach that supports continued action (including reasoning) in the presence of inconsistency, and facilitates the recording and tracking of (inconsistent) information during reasoning. The technical contributions of the paper are in two main parts. <p> input, we can adopt a meta-level approach to prescribe inconsistency handling rules of the form: Inconsistency implies Action One approach is to deploy an action-based temporal logic that allows us to specify the past context and source of an inconsistency in order to prescribe future actions to handle the inconsistency <ref> [GH93, FGH + 94] </ref>.
Reference: [GH98] <author> D Gabbay and A Hunter. </author> <title> Negation and contradiction. In What is negation? Kluwer, </title> <year> 1998. </year>
Reference-contexts: There are number of ways that this approach can be developed. First, there are further intuitive ways of deriving orderings over formulae and sets of formulae. These include ordering sets of formulae according to their relative degree of contradiction <ref> [GH98] </ref>. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae.
Reference: [HK92] <author> T M Hagensen and B B Kristensen. </author> <title> Consistency in software system development: Framework, model, techniques and tools. </title> <booktitle> Software Engineering Notes (Proceedings of ACM SIGSOFT Symposium on Software Development Environments), </booktitle> <volume> 17(5) </volume> <pages> 58-67, </pages> <year> 1992. </year>
Reference-contexts: Increasingly however, researchers have begun to study the notion of consistency in software systems, and have recognised the need to formalise this notion. For example, Hagensen and Kristensen have explicitly explored the consistency perspective in software development <ref> [HK92] </ref>. The focus of their work is on the structures for representing information ("descriptions") and the relations between these structures. Consistency of descriptions is defined as relations between interpretations of descriptions. Consistency handling techniques in software systems modelled in terms descriptions, interpretations and relations, are also proposed.
Reference: [HN97] <author> A Hunter and B Nuseibeh. </author> <title> Analysing inconsistent specifications. </title> <booktitle> In Proceedings of 3rd International Symposium on Requirements Engineering, </booktitle> <pages> pages 78-86. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: This paper is a revised and extended version of <ref> [HN97] </ref>. The work was partially funded by the UK EPSRC as part of the Voila (GR J15483) and Mise (GR/L 55964) projects, the CEC as part of the Basic Research Actions Promoter II and Drums II, and the British Council.
Reference: [Hun96] <author> A Hunter. </author> <title> Reasoning with contradictory information using quasi-classical logic. </title> <type> In Technical report. </type> <institution> Department of Computer Science, University College London, </institution> <year> 1996. </year> <note> Available from www.cs.ucl.ac.uk/staff/a.hunter. </note>
Reference-contexts: We restrict this coverage to propositional clauses. For a complete account of the semantics and relevant correctness results, the reader is referred to <ref> [Hun96] </ref>. We begin our overview with the following definition of a model. 7 Definition 3.1 Let S be some set. Let O be a set of objects defined as follows, where +ff is a positive object, and ff is a negative object. <p> All the QC natural deduction rules hold in classical logic, but some classical deduction rules, such as ex falso quodlibet do not hold in QC logic. For a more complete coverage of QC logic the reader is referred to <ref> [BH95, Hun96, Hun98] </ref>. We obtain labelled QC logic by using only labelled formulae as assumptions, and by amending the natural deduction rules to propagate the labels. The label of the consequent of a rule is the union of the labels of the premises of the rule.
Reference: [Hun98] <author> A Hunter. </author> <title> Paraconsistent logics. In Handbook of Defeasible Reasoning and Uncertainty Management. </title> <publisher> Kluwer, </publisher> <year> 1998. </year>
Reference-contexts: All the QC natural deduction rules hold in classical logic, but some classical deduction rules, such as ex falso quodlibet do not hold in QC logic. For a more complete coverage of QC logic the reader is referred to <ref> [BH95, Hun96, Hun98] </ref>. We obtain labelled QC logic by using only labelled formulae as assumptions, and by amending the natural deduction rules to propagate the labels. The label of the consequent of a rule is the union of the labels of the premises of the rule. <p> Key logics include C ! [dC74] and four-valued logic [Bel77]. QC logic differs in having a richer proof theory but at the price of loosing tautologies and prohibiting proofs to be used as lemmas in further proofs. For a comparison of some paraconsistent logics see <ref> [Hun98] </ref>. 4 Logical analysis of inconsistent specifications So far we have shown how development information can be represented as logical formulae, and shown how we can undertake non-trivial reasoning with such formulae, even if they are mutually inconsistent. In this section we turn to logical analysis of inconsistent specifications.
Reference: [KC93] <author> P Krause and D Clark. </author> <title> Representing Uncertain Knowledge. </title> <publisher> Intellect, </publisher> <year> 1993. </year>
Reference-contexts: From the AI and logics communities there have been a number of other proposals that are of relevance, including fuzzy sets and non-monotonic logics (for a review, see <ref> [KC93] </ref>). Whilst they constitute important developments that could be incorporated in our framework, they are not directly oriented to the inconsistency management issues that we consider within this paper.
Reference: [Kle86] <author> J De Kleer. </author> <title> An assumption-based TMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference-contexts: provide a useful vocabulary for participants in the development process to discuss the inconsistent information. 17 Handling inconsistent information using maximally consistent subsets has been considered in a number of approaches including logics (for a review see [EGH95]), combining knowledge bases (for example [BKMS92]), and truth maintenance systems (for example <ref> [Doy79, Kle86] </ref>), we go beyond this by adopting universal and free inferencing. <p> Otherwise, deviations are tolerated, recorded and propagated and "pollution analysis" (based on logical reasoning) is performed to identify possible sources of inconsistency. The framework we have described in this paper also provides more sophisticated options than truth maintenance (such as <ref> [Doy79, Kle86] </ref>) for managing inconsistency specifications. These include: (1) paraconsistent reasoning with sets of inconsistent formulae; (2) labelling strategies to allow inconsistent formulae to be tracked, and likely sources identified using meta-level information; and (3) reasoning with universal and free inferences in addition to reasoning with existential inferences.
Reference: [LFKN95] <author> U Leonhardt, A Finkelstein, J Kramer, and B Nuseibeh. </author> <title> Decent-ralised process enactment in a multi-perspective development environment. </title> <booktitle> In Proceedings of 17th International Conference on Software Engineering (ICSE-17), </booktitle> <pages> pages 255-264. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: We have implemented a prototype to support this which uses regular expressions to specify particular situations and rules to associate actions with these situations <ref> [LFKN95] </ref>. Further work is needed to incorporate the kinds of logical analysis we have described in this paper within this ViewPoints prototype. <p> Our intention is to provide the kind of tool support described above within our multi-perspective software development environment, The Viewer [NF92]. We have already extended The Viewer to support decentralised process enactment, including consistency checking <ref> [LFKN95] </ref>. This extension allows consistency checks between partial specifications (ViewPoints) to be invoked and applied in a controlled way, by specifying actions that can take place in certain, pre-defined, "situations" (as described in section 5).
Reference: [Lin88] <author> P A Lindsay. </author> <title> A survey of mechanical support for formal reasoning. </title> <journal> BCS/IEE Software Engineering Journal (special issue on mechanical support for formal reasoning), </journal> <volume> 3(1), </volume> <year> 1988. </year>
Reference-contexts: Some theorem provers <ref> [Lin88] </ref> provide inconsistency handling support in this way by attempting to prove that a description (e.g., a specification) satisfies a set of properties or contains no contradictions. Our intention is to provide the kind of tool support described above within our multi-perspective software development environment, The Viewer [NF92].
Reference: [LWB84] <author> E Lusk L Wos, R Overbeek and J Boyle. </author> <title> Automated Reasoning: Introduction and Applications. </title> <publisher> Prentice Hall, </publisher> <year> 1984. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [McC90] <author> W McCune. </author> <title> OTTER 2.0 user's guide. </title> <type> Technical Report ANL-90/9, </type> <institution> Argonne National Laboratory, Argonne, Illinois, </institution> <year> 1990. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [NF92] <author> B Nuseibeh and A Finkelstein. </author> <title> Viewpoints: A vehicle for method and tool integration. </title> <booktitle> In Proceedings of 5th International Workshop on Computer-Aided Software Engineering (CASE '92), </booktitle> <pages> pages 50-60, </pages> <address> Montreal, Canada, 1992. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 36 </pages>
Reference-contexts: Our intention is to provide the kind of tool support described above within our multi-perspective software development environment, The Viewer <ref> [NF92] </ref>. We have already extended The Viewer to support decentralised process enactment, including consistency checking [LFKN95]. This extension allows consistency checks between partial specifications (ViewPoints) to be invoked and applied in a controlled way, by specifying actions that can take place in certain, pre-defined, "situations" (as described in section 5).
Reference: [NG92] <author> K Narayanaswamy and N Goldman. </author> <title> Lazy consistency: A basis for cooperative software development. </title> <booktitle> In Proceedings of International Conference on Computer-Supported Cooperative Work (CSCW '92), </booktitle> <pages> pages 257-264. </pages> <publisher> ACM SIGCHI and SIGOIS, </publisher> <year> 1992. </year>
Reference-contexts: This approach however provides little analysis of the kinds of inconsistency present, preferring to focus on avoiding inconsistencies and leaving any analysis to external agents. 29 Narayanaswamy and Goldman proposed "lazy" consistency as the basis for cooperative software development <ref> [NG92] </ref>. This approach favours software development architectures where impending or proposed changes as well as changes that have already occurred are "announced". This allows the consistency requirements of a system to be "lazily" maintained as it evolves.
Reference: [NKF94] <author> B Nuseibeh, J Kramer, and A Finkelstein. </author> <title> A framework for expressing the relationships between multiple views in requirements specification. </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(10) 760-773, 1994. 
Reference-contexts: Method information about the process of development and the representation schemes used to express partial specifications. This information also includes integrity constraints between representation schemes which we have captured as "inter-ViewPoint rules" <ref> [NKF94] </ref>. These rules describe relationships between representation schemes, and thus the relationships between partial specifications expressed using those representation schemes. They are normally prescribed as part of the method definition; e.g., "every decomposed process in a dataflow diagram must have a cor responding parent process". <p> Rather, our aim is to reduce the complexity of our reasoning and analysis by restricting them to smaller partial specifications, and to demonstrate its potential usefulness when used with a host of other tools from the requirements engineer's toolbox. Our earlier work <ref> [NKF94] </ref> deliberately focused on the partitioning of specifications into manageable units (ViewPoints) to which we now apply the techniques described. Inconsistency management in this setting then, addresses inconsistencies within and between selected ViewPoints.
Reference: [NR98] <author> B Nuseibeh and A Russo. </author> <title> On the consequences of acting in the presence of inconsistency. </title> <booktitle> In Proceedings of the Ninth International Workshop on Software Specification and Design, </booktitle> <address> Ise-shima, Japan, 1998. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our immediate research agenda is to examine these inconsistency handling actions further within our framework. One line of research we are investigating is the analysis of the consequences of taking different development actions to guide developers in choosing between alternatives <ref> [NR98] </ref>. QC logic allows us to assess the impact of taking different inconsistency handling actions that do not necessarily remove inconsistency from a specification. The version of QC logic presented here is effectively propositional in express-ibility.
Reference: [Nus96] <author> B Nuseibeh. </author> <title> To be and not to be: On managing inconsistency in software development. </title> <booktitle> In Proceedings of 8th International Workshop on Software Specification and Design (IWSSD-8), </booktitle> <pages> pages 164-169. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: It depends on the kinds of inconsistency that can be detected and the degree of inconsistency tolerance that can be supported. Different developers and researchers have adopted different strategies to acting in the presence of inconsistency. We have identified at least four kinds of such actions <ref> [Nus96] </ref>: Ignoring the inconsistency completely and continuing development regardless. This may be appropriate in certain circumstances where the inconsistency is isolated and the software engineer believes that it does not prevent further development from taking place.
Reference: [Poo85] <author> D Poole. </author> <title> A logical framework for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 36 </volume> <pages> 27-47, </pages> <year> 1985. </year>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [GH98]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use 19 of specificity <ref> [Poo85] </ref>, ordered theory presentations [Rya92], preferred subtheor--ies [Bre89], explicit preferences [Pra93], and prioritised syntax-based entailment [BDP93]. 5 Towards acting on inconsistency The logical analysis of inconsistency described in this paper is part of a wider framework for handling inconsistency.
Reference: [Pra93] <author> H Prakken. </author> <title> An argument framework for default reasoning. </title> <journal> In Annals of mathematics and artificial intelligence, </journal> <volume> volume 9, </volume> <year> 1993. </year>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [GH98]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use 19 of specificity [Poo85], ordered theory presentations [Rya92], preferred subtheor--ies [Bre89], explicit preferences <ref> [Pra93] </ref>, and prioritised syntax-based entailment [BDP93]. 5 Towards acting on inconsistency The logical analysis of inconsistency described in this paper is part of a wider framework for handling inconsistency.
Reference: [RNK98] <author> A Russo, B Nuseibeh, and J Kramer. </author> <title> Restructuring requirements specifications for inconsistency analysis: A case study. </title> <booktitle> In Proceedings of the Third International Conference on Requirements Engineering (ICRE98), </booktitle> <address> Colorado Springs, USA, 1998. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We intend to supplement this with more sophisticated, Prolog-based, analysis and reasoning computational engines. Finally, following on from work with Philips Research Labs on a Collaborative Requirements Engineering Support Tool (CREST) [Bea96], we are currently developing a distributed, web-based implementation of the above using Java <ref> [RNK98] </ref>. 8 Related work The overwhelming majority of work on consistency management has dealt with tools and techniques for maintaining consistency and avoiding inconsistency. Increasingly however, researchers have begun to study the notion of consistency in software systems, and have recognised the need to formalise this notion.
Reference: [Rya92] <author> M Ryan. </author> <title> Representing defaults as sentences with reduced priority. </title> <booktitle> In Principles of Knowledge Representation and Reasoning: Proceedings of the Third International Conference. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: These include ordering sets of formulae according to their relative degree of contradiction [GH98]. Second, there are a number of analyses of ways of handling ordered formulae and sets of ordered formulae. These include the use 19 of specificity [Poo85], ordered theory presentations <ref> [Rya92] </ref>, preferred subtheor--ies [Bre89], explicit preferences [Pra93], and prioritised syntax-based entailment [BDP93]. 5 Towards acting on inconsistency The logical analysis of inconsistency described in this paper is part of a wider framework for handling inconsistency.
Reference: [Sch93] <author> J Schumann. SCOTT: </author> <title> A model-guided theorem prover. </title> <booktitle> In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence (IJCAI'93), </booktitle> <pages> pages 109-114, </pages> <year> 1993. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [Sch94] <author> J Schumann. </author> <title> SETHEO V3.2: Recent developments. </title> <booktitle> In Proceedings of the Twelfth Conference on Computer-Aided Deduction (CADE-12), volume 814 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: In addition, there has been much progress in developing technology for classical reasoning [CW96]. This includes automated reasoning systems for deriving inferences from sets of formulae (see for example <ref> [LWB84, Fit90, McC90, Bib93, Sch93, Sch94] </ref>), and model building systems for giving models of consistent sets of formulae (see for example [CCB90, AC91, CZ93, BCP94, CP95, Sla96]). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [SK88] <author> R W Schwanke and G E Kaiser. </author> <title> Living with inconsistency in large systems. </title> <booktitle> In Proceedings of the International Workshop on Software Version and Configuration Control, </booktitle> <pages> pages 98-118. </pages> <editor> B G Teubner, </editor> <year> 1988. </year>
Reference-contexts: Here, the emphasis is on identifying the kind of inconsistency that has been detected in, or between, partial specifications. Tool support for this kind of activity is more limited, because there is little work that attempts to classify inconsistencies. Some tools (for example CONMAN <ref> [SK88] </ref>, described in section 10) search for one of a pre-defined number of kinds of inconsistency, and try to match the detected inconsistency with one of these. The third area is that of inconsistency handling, which offers varied and challenging scope for tool support. <p> the CONMAN programming environment) by: identifying and tracking six different kinds of inconsistencies (without requiring them to be removed); reducing the cost of restoring type safety after a change (using a technique called "smarter recompilation"); and, protecting programmers from inconsistent code (by supplying debugging and testing tools with inconsistency information) <ref> [SK88] </ref>. The analysis of inconsistencies however is limited to identifying one of six predefined types of inconsistency in programming code. Balzer has proposed the notion of "tolerating inconsistency" by relaxing consistency constraints during development [Bal91].
Reference: [Sla96] <author> J Slaney. </author> <title> FINDER: Finite domain enumerator version 3 notes and guide. </title> <type> Technical report, </type> <institution> Centre for Information Science Research, Australian National University, </institution> <year> 1996. </year>
Reference-contexts: This includes automated reasoning systems for deriving inferences from sets of formulae (see for example [LWB84, Fit90, McC90, Bib93, Sch93, Sch94]), and model building systems for giving models of consistent sets of formulae (see for example <ref> [CCB90, AC91, CZ93, BCP94, CP95, Sla96] </ref>). 5 2.2.2 Problems of reasoning with inconsistency In practical reasoning, it is common to have "too much" information about some situation.
Reference: [ZJ93] <author> P Zave and M Jackson. </author> <title> Conjunction as composition. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(4) </volume> <pages> 379-411, </pages> <year> 1993. </year> <month> 38 </month>
Reference-contexts: Zave and Jackson have proposed the construction of system specifications by composing many partial specifications, each written in a specialised language that is best suited for describing its intended area of concern <ref> [ZJ93] </ref>. They further propose the composition of partial specifications as a conjunction of their assertions in a form of classical logic. A set of partial specifications is then consistent if and only if the conjunction of their assertions is satisfiable.
References-found: 56

