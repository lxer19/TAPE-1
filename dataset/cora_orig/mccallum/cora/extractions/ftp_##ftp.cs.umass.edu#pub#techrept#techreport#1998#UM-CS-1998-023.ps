URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1998/UM-CS-1998-023.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/98-023.html
Root-URL: 
Email: fnaumovic; avruning@cs.umass.edu  
Title: A Conservative Data Flow Algorithm for Detecting All Pairs of Statements that May Happen in Parallel  
Author: Gleb Naumovich and George S. Avrunin 
Address: Amherst, MA 01003-6410  
Affiliation: Laboratory for Advanced Software Engineering Research Department of Computer Science University of Massachusetts at Amherst  
Abstract: Information about which pairs of statements in a concurrent program can execute in parallel is important for optimizing and debugging programs, for detecting anomalies, and for improving the accuracy of dataflow analysis. In this paper, we describe a new data flow algorithm that finds a conservative approximation of the set of all such pairs. We have carried out an initial comparison of the precision of our algorithm and that of the most precise of the earlier approaches, Masti-cola and Ryder's non-concurrency analysis [8], using a sample of 147 concurrent Ada programs that includes the collection assembled by Masticola. For these examples, our algorithm was almost always more precise than non-concurrency analysis, in the sense that the set of pairs identified by our algorithm as possibly happening in parallel is a proper subset of the set identified by non-concurrency analysis. In 123 cases, we were able to use reachability analysis to determine exactly the set of pairs of statements that may happen in parallel. For these cases, there were a total of only six pairs identified by our algorithm that cannot actually happen in parallel. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Callahan and J. Subhlok. </author> <title> Static analysis of low-level synchronization. </title> <booktitle> In Proceedings of the SIG-PLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <year> 1988. </year>
Reference-contexts: The goal is to find a useful tradeoff between precision and cost. Several approaches have been proposed. Callahan and Subhlok <ref> [1] </ref> proposed a data flow algorithm that computes for each statement in a concurrent program the set of statements that must be executed before this statement can be executed (B4 analysis). Duesterwald and Soffa [2] applied this approach to the Ada rendezvous model.
Reference: [2] <author> E. Duesterwald and M. L. Soffa. </author> <title> Concurrency anal-ysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT Fourth Workshop on Software Testing, Analysis, and Verification, </booktitle> <pages> pages 36-48, </pages> <address> Victoria, B.C., </address> <month> Oc-tober </month> <year> 1991. </year>
Reference-contexts: Several approaches have been proposed. Callahan and Subhlok [1] proposed a data flow algorithm that computes for each statement in a concurrent program the set of statements that must be executed before this statement can be executed (B4 analysis). Duesterwald and Soffa <ref> [2] </ref> applied this approach to the Ada rendezvous model.
Reference: [3] <author> M. Dwyer. </author> <title> Data Flow Analysis for Verifying Correctness Properties of Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Massachussetts, Amherst, </institution> <year> 1995. </year>
Reference-contexts: Section 4 presents the results of the comparison of our algorithm and non-concurrency analysis, and Section 5 discusses some conclusions and describes future work. 2 THE MHP ALGORITHM 2.1 Program representation The program representation used in this work is the trace flow graph (TFG) introduced by Dwyer and Clarke <ref> [3, 4] </ref>. This representation is conservative in the sense that it models a superset of all feasible program executions. <p> For these examples, the information computed by the MHP algorithm was remarkably close to that of the reachability technique. At present, the MHP algorithm is being used implemented as part of the FLAVERS tool <ref> [3, 11] </ref> for data flow analysis of concurrent programs. In the future, we plan to extend the MHP algorithm to programs containing conventional procedure and function calls.
Reference: [4] <author> M. Dwyer and L. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In ACM SIGSOFT'94 Software Engineering Notes, Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Section 4 presents the results of the comparison of our algorithm and non-concurrency analysis, and Section 5 discusses some conclusions and describes future work. 2 THE MHP ALGORITHM 2.1 Program representation The program representation used in this work is the trace flow graph (TFG) introduced by Dwyer and Clarke <ref> [3, 4] </ref>. This representation is conservative in the sense that it models a superset of all feasible program executions.
Reference: [5] <author> M. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: Rather than using the lattice/function space view of data flow problems <ref> [5] </ref>, we give data flow equations for TFG nodes. This is done for two reasons. First, it makes explanations and especially proving properties of this algorithm more intuitive. <p> Note that by construction a communication node can never have nodes in its IN set from the two tasks whose rendezvous it represents. On each iteration, we set M (n) = IN (n) [ GEN (n). Up to this point the algorithm is a standard forward-flow data flow algorithm <ref> [5] </ref>.
Reference: [6] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand inter-procedural dataflow analysis. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: In the case of procedures containing entry calls, we plan to use a context-sensitive approach, extending the TFG model to include procedure call and return edges, similar to the approach of <ref> [6] </ref>, and modifying the MHP algorithms accordingly. In addition, we plan to implement an algorithm that improves the precision of the MHP algorithm by taking advantage of critical sections, regions in the program that can be demonstrated to support the notion of mutual exclusion.
Reference: [7] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Informatica, </journal> <volume> 28(2) </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: In Figure 3, we give a worklist version of the MHP algorithm. Although steps (12)-(14) do not allow casting the algorithm in the general data flow algorithm form and using the standard complexity results <ref> [7] </ref> directly, we can show that the algorithm has polynomial worst case bound, as stated below in Theorem 4. To conclude the discussion of the MHP algorithm, we state some results about its termination, conservativeness, and polynomial-time boundedness. Theorem 1 (Termination).
Reference: [8] <author> S. Masticola and B. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the Twelfth of Symposium on Principles and Practices of Parallel Programming, </booktitle> <address> San Diego, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Information about this aspect of the behavior of a concurrent program has applications in debugging, optimization (both manual and automatic), detection of synchronization anomalies such as data races, and improving the accuracy of data flow analysis <ref> [8] </ref>. The problem of precisely determining the pairs of statements that can execute in parallel is known to be NP -complete [12]. <p> Duesterwald and Soffa [2] applied this approach to the Ada rendezvous model. Masticola and Ryder proposed an iterative approach they called non-concurrency analysis <ref> [8] </ref> that computes a conservative estimate of the set of pairs of communication statements that can never happen in parallel in a concurrent Ada program. (The complement of this set is a conservative approximation of the set of pairs that may occur in parallel.) In that work, it is assumed initially
Reference: [9] <author> S. P. Masticola. </author> <title> Static detection of deadlocks in polynomial time. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1993. </year>
Reference-contexts: We have conducted a preliminary empirical comparison of our algorithm and non-concurrency analysis, using a set of 147 Ada programs that includes the collection assembled by Masticola <ref> [9] </ref>. For the purposes of this comparison, we took the complement of the set of pairs of statements identified by our algorithm as possibly occurring in parallel to get a conservative approximation of the set of pairs of statements that cannot occur together, as computed by non-concurrency analysis. <p> The complexity of each of the four refinements is O (jN sync j 3 ), and the complexity of the overall approach is O (jN sync j 5 ), where N sync is the set of sync graph nodes <ref> [9] </ref>. 3.2 Deriving TFGs from Sync Graphs In order to compare information computed on sync graphs and TFGs, we construct a special restricted trace flow graph (RTFG) from a sync graph. Due to space limitations, we do not present the complete algorithm used for this translation.
Reference: [10] <author> S. P. Masticola, T. J. Marlowe, and B. G. Ryder. </author> <title> Lattice frameworks for multisource and bidirectional data flow problems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5) </volume> <pages> 777-803, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This is done for two reasons. First, it makes explanations and especially proving properties of this algorithm more intuitive. Second, one aspect of the algorithm precludes its representation as a purely forward- or backward-flow data flow problem or even as a bidirectional <ref> [10] </ref> data flow problem. We conclude the description of the algorithm by giving pseudo-code for its worklist version. Our algorithm associates three sets with each node n of the TFG: GEN (n), IN (n), and M (n).
Reference: [11] <author> G. N. Naumovich, L. A. Clarke, L. J. Osterweil, and M. B. Dwyer. </author> <title> Verification of concurrent software with FLAVERS. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 594-595, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: For these examples, the information computed by the MHP algorithm was remarkably close to that of the reachability technique. At present, the MHP algorithm is being used implemented as part of the FLAVERS tool <ref> [3, 11] </ref> for data flow analysis of concurrent programs. In the future, we plan to extend the MHP algorithm to programs containing conventional procedure and function calls.
Reference: [12] <author> R. N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: The problem of precisely determining the pairs of statements that can execute in parallel is known to be NP -complete <ref> [12] </ref>.
References-found: 12

