URL: http://ptolemy.eecs.berkeley.edu/papers/97/typesSynchronous/tcs_draft.ps.gz
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/97/typesSynchronous/
Root-URL: 
Email: samson@dcs.ed.ac.uk S.Gay@dcs.rhbnc.ac.uk  R.Nagarajan@doc.ic.ac.uk  
Title: Types for Deadlock-freedom: The Synchronous Case  
Author: Samson Abramsky Simon Gay Rajagopal Nagarajan 
Date: June 18, 1997  
Address: Mayfield Road, University of London, Edinburgh EH9 3JZ, UK. Egham, Surrey TW20 0EX, UK.  London SW7 2BZ, UK  Berkeley, CA 94720, USA.  
Affiliation: Department of Computer Science, Department of Computer Science, University of Edinburgh, Royal Holloway,  Department of Computing, Imperial College of Science, Technology and Medicine, 180 Queen's Gate,  Electronics Research Laboratory, University of California,  
Abstract: Many different notions of "program property", and many different methods of verifying such properties, arise naturally in programming. We present a general framework of Specification Structures for combining different notions and methods in a coherent fashion. We then apply the idea of specification structures to concurrency in the setting of Interaction Categories. As a specific example, a certain specification structure defined over the interaction category SProc yields a new category SProc D whose type system is strong enough to guarantee deadlock-freedom of concurrent processes. We present some techniques for manipulating typed processes in this category, and show that they allow us to reason about deadlock-freedom in synchronous networks, a class of concurrent systems which incorporates both synchronous dataflow programs and systolic algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky, S. J. Gay, and R. Nagarajan. </author> <title> Interaction categories and foundations of typed concurrent programming. </title> <editor> In M. Broy, editor, </editor> <booktitle> Deductive Program Design: Proceedings of the 1994 Marktoberdorf International Summer School, NATO ASI Series F: Computer and Systems Sciences. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Of course, non-linear patterns of refinement| trees or dags rather than sequences|can also be considered, but the tower suffices to establish the main ideas. The remainder of this paper provides a detailed development of this idea in the setting of interaction categories <ref> [1, 5, 6] </ref>, with particular reference to synchronous systems. Section 2 introduces the notion of a specification structure, which formalizes the idea of enriching a 2 semantic universe with a refined notion of property. Section 3 reviews the theory of inter-action categories and defines SProc, a category of synchronous processes. <p> of the paper, we will use specification structures defined over interaction categories to construct type systems for the specification and verification of concurrent systems. 6 3 The Interaction Category SProc The theory of Interaction Categories has been proposed as a new paradigm for the semantics of sequential and concurrent computation <ref> [1, 5, 6] </ref>. The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games [8], geometry of interaction categories [9]) as well as several new categories for concurrency. <p> Because the present paper mainly concerns the use of specification structures for deadlock-freedom, we omit the features of SProc which will not be needed in later sections. More complete definitions can be found elsewhere <ref> [1, 21] </ref>. An object of SProc is a pair A = ( A ; S A ) in which A is an alphabet (sort) of actions (labels) and S A nepref fl A is a safety specification, i.e. a non-empty prefix-closed subset of fl A . <p> It is easy to check that these are isomorphisms and that mon is natural. fl The most important feature of ffi is that it has the following unique fixed point property (UFPP) <ref> [1] </ref>. Proposition 3.8 For any objects A and B, and any morphisms f : A ! ffi A and g : ffi B ! B, there is a unique morphism It (f; g) : A ! B such that A B ? g ? commutes. <p> It is standard in concurrency theory that such a definition has a unique solution [36]. fl We will not go into the applications of this property in the present paper, except to mention that it supports guarded recursive definitions <ref> [1, 21] </ref> and is an important part of a proposed axiomatisation of interaction categories [21].
Reference: [2] <author> S. Abramsky, S. J. Gay, and R. Nagarajan. </author> <title> Specification structures and propositions-as-types for concurrency. </title> <editor> In G. Birtwistle and F. Moller, editors, </editor> <title> Logics for Concur-rency: Structure vs. </title> <booktitle> Automata|Proceedings of the VIIIth Banff Higher Order Workshop, volume 1043 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The result is a category of deadlock-free processes in which the global synchrony condition is not present. Preliminary versions of this work have appeared in <ref> [2, 21] </ref> and an improved version in [40]; a full report of this area will be the subject of a future paper. Another avenue of investigation is the development of a formal syntax, incorporating value-passing rather than simply synchronisation, with which to describe processes in SProc D .
Reference: [3] <author> S. Abramsky. </author> <title> Domain theory in logical form. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 1-77, </pages> <year> 1991. </year>
Reference-contexts: C = the category of SFP domains; P S D = K (D)(the compact-open subsets of D); U ff gV , U f 1 (V ). This yields (part of) Domain Theory in Logical Form <ref> [3] </ref>, the other part arising from the local lattice-theoretic structure of the sets P S D and its interaction with the global type structure. 7.
Reference: [4] <author> S. Abramsky. </author> <title> Computational Interpretations of Linear Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 111 </volume> <pages> 3-57, </pages> <year> 1993. </year>
Reference-contexts: Convergence means deadlock-freedom; the reason for the choice of terminology is an analogy with proofs of strong normalisation in Classical Linear Logic <ref> [23, 4] </ref>.
Reference: [5] <author> S. Abramsky. </author> <title> Interaction Categories (Extended Abstract). </title> <editor> In G. L. Burn, S. J. Gay, and M. D. Ryan, editors, </editor> <booktitle> Theory and Formal Methods 1993: Proceedings of the First Imperial College Department of Computing Workshop on Theory and Formal Methods, </booktitle> <pages> pages 57-70. </pages> <publisher> Springer-Verlag Workshops in Computer Science, </publisher> <year> 1993. </year>
Reference-contexts: Of course, non-linear patterns of refinement| trees or dags rather than sequences|can also be considered, but the tower suffices to establish the main ideas. The remainder of this paper provides a detailed development of this idea in the setting of interaction categories <ref> [1, 5, 6] </ref>, with particular reference to synchronous systems. Section 2 introduces the notion of a specification structure, which formalizes the idea of enriching a 2 semantic universe with a refined notion of property. Section 3 reviews the theory of inter-action categories and defines SProc, a category of synchronous processes. <p> of the paper, we will use specification structures defined over interaction categories to construct type systems for the specification and verification of concurrent systems. 6 3 The Interaction Category SProc The theory of Interaction Categories has been proposed as a new paradigm for the semantics of sequential and concurrent computation <ref> [1, 5, 6] </ref>. The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games [8], geometry of interaction categories [9]) as well as several new categories for concurrency. <p> The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games [8], geometry of interaction categories [9]) as well as several new categories for concurrency. The fundamental examples of concurrent interaction categories are SProc <ref> [5] </ref>, the category of synchronous processes, and ASProc [6], the category of asynchronous processes. The category SProc will be defined in this section; later we will use a specification structure over SProc to construct another interaction category.
Reference: [6] <author> S. Abramsky. </author> <title> Interaction Categories and communicating sequential processes. </title> <editor> In A. W. Roscoe, editor, </editor> <title> A Classical Mind: Essays in Honour of C. </title> <editor> A. R. </editor> <booktitle> Hoare, </booktitle> <pages> pages 1-15. </pages> <publisher> Prentice Hall International, </publisher> <year> 1994. </year>
Reference-contexts: Of course, non-linear patterns of refinement| trees or dags rather than sequences|can also be considered, but the tower suffices to establish the main ideas. The remainder of this paper provides a detailed development of this idea in the setting of interaction categories <ref> [1, 5, 6] </ref>, with particular reference to synchronous systems. Section 2 introduces the notion of a specification structure, which formalizes the idea of enriching a 2 semantic universe with a refined notion of property. Section 3 reviews the theory of inter-action categories and defines SProc, a category of synchronous processes. <p> of the paper, we will use specification structures defined over interaction categories to construct type systems for the specification and verification of concurrent systems. 6 3 The Interaction Category SProc The theory of Interaction Categories has been proposed as a new paradigm for the semantics of sequential and concurrent computation <ref> [1, 5, 6] </ref>. The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games [8], geometry of interaction categories [9]) as well as several new categories for concurrency. <p> The fundamental examples of concurrent interaction categories are SProc [5], the category of synchronous processes, and ASProc <ref> [6] </ref>, the category of asynchronous processes. The category SProc will be defined in this section; later we will use a specification structure over SProc to construct another interaction category. <p> There are many ways in which the theory described in this paper could be extended and developed. Progress has already been made on an asynchronous version of the theory, by applying the sets of processes approach to the asynchronous interaction category ASProc <ref> [6] </ref>. The result is a category of deadlock-free processes in which the global synchrony condition is not present. Preliminary versions of this work have appeared in [2, 21] and an improved version in [40]; a full report of this area will be the subject of a future paper.
Reference: [7] <author> S. Abramsky. </author> <title> Proofs as processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 135 </volume> <pages> 5-9, </pages> <year> 1994. </year>
Reference-contexts: but we avoid the use of this term since Girard has used it for a quite different rule in the context of linear logic.) The usual Cut rule ` ; A ` ; A ? allows us to plug two modules together by an interface consisting of a single port <ref> [7] </ref>, as in Figure 2. This allows us to connect processes in a tree structure, as in Figure 3 (a), but not to construct cyclic interconnection networks as in Figure 3 (b).
Reference: [8] <author> S. Abramsky and R. Jagadeesan. </author> <title> Games and full completeness for multiplicative linear logic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 59(2):543 - 574, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: C = games and partial strategies, as in [10], P A = all sets of infinite plays, U fgV iff is winning with respect to U; V in the sense of <ref> [8] </ref>. Then C S is the category of games and winning strategies of [8]. These examples show the scope and versatility of these notions. <p> C = games and partial strategies, as in [10], P A = all sets of infinite plays, U fgV iff is winning with respect to U; V in the sense of <ref> [8] </ref>. Then C S is the category of games and winning strategies of [8]. These examples show the scope and versatility of these notions. <p> The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games <ref> [8] </ref>, geometry of interaction categories [9]) as well as several new categories for concurrency. The fundamental examples of concurrent interaction categories are SProc [5], the category of synchronous processes, and ASProc [6], the category of asynchronous processes. <p> This style of definition is typical of interaction categories; definitions of fl-autonomous categories of games <ref> [8] </ref> follow the same pattern. Given objects A and B, the object A B has AB = A fi B def AB j fst fl () 2 S A ; snd fl () 2 S B g: The duality is trivial on objects: A ? def = A.
Reference: [9] <author> S. Abramsky and R. Jagadeesan. </author> <title> New foundations for the geometry of interaction. </title> <journal> Information and Computation, </journal> <volume> 111(1) </volume> <pages> 53-119, </pages> <year> 1994. </year>
Reference-contexts: The term encompasses certain known categories (the category of concrete data structures and sequential algorithms [14], categories of games [8], geometry of interaction categories <ref> [9] </ref>) as well as several new categories for concurrency. The fundamental examples of concurrent interaction categories are SProc [5], the category of synchronous processes, and ASProc [6], the category of asynchronous processes.
Reference: [10] <author> S. Abramsky, R. Jagadeesan, and P. Malacaria. </author> <title> Full abstraction for PCF (extended abstract). </title> <editor> In M. Hagiya and J. C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Computer Software. International Symposium TACS'94, number 789 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-15, </pages> <address> Sendai, Japan, April 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This yields (part of) Domain Theory in Logical Form [3], the other part arising from the local lattice-theoretic structure of the sets P S D and its interaction with the global type structure. 7. C = games and partial strategies, as in <ref> [10] </ref>, P A = all sets of infinite plays, U fgV iff is winning with respect to U; V in the sense of [8]. Then C S is the category of games and winning strategies of [8]. These examples show the scope and versatility of these notions.
Reference: [11] <author> A. Asperti and G. Longo. </author> <title> Categories, Types and Structures : An introduction to category theory for the working computer scientist. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <month> 41 </month>
Reference-contexts: The above example of structure on C is illustrative. Exactly similar definitions can be given for a range of structures, including: * models of classical (or intuitionistic) linear logic including the additives and expo nentials <ref> [11] </ref> * cartesian closed categories [18] * models of polymorphism [18]. 2.1 Examples of Specification Structures In each case we specify the category C, the assignment of properties P to objects and the Hoare triple relation. 1. <p> Then C S is the category of modest sets, seen as a full subcategory of !-Set <ref> [11] </ref>. 6. C = the category of SFP domains; P S D = K (D)(the compact-open subsets of D); U ff gV , U f 1 (V ).
Reference: [12] <author> J. C. M. Baeten and W. P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Tracts in Theo--retical Computer Science. </booktitle> <publisher> Cambridge Univ. Press, </publisher> <year> 1990. </year>
Reference-contexts: f ("; fag); (a; fbg); (a; fcg); (ab; ?); (ac; ?)g and if P = a:P , readies (P ) = f (a n ; fag j n &lt; !)g: The idea of a ready pair, and the related notions of failures and refusals, appear in the process algebra literature <ref> [12, 16, 27] </ref>. There, however, they are used to define semantic alternatives to bisimulation; the use made of ready pairs in this paper is very different. We use a orthogonality relation on ready pairs, rather than on processes as in Section 5.
Reference: [13] <author> M. Barr. </author> <title> fl-autonomous categories and linear logic. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1(2) </volume> <pages> 159-178, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: (A ( B) and axioms (' )fsymm A;B g ( ') ((' ( ) ')feval A;B g 4 (' )ff g =) 'ffl (f )g ( ( '): Going one step further, suppose that C is a fl-autonomous category, i.e. a model for the multiplicative fragment of classical linear logic <ref> [13] </ref>, with linear negation () ? , where for simplicity we assume that A ?? = A. Then we require an action () ? satisfying ' ?? = ' ? Under these circumstances all of this structure on C lifts to C S .
Reference: [14] <author> G. Berry and P.-L. Curien. </author> <title> Theory and practice of sequential algorithms: the kernel of the applicative language CDS. </title> <editor> In J. C. Reynolds and M. Nivat, editors, </editor> <booktitle> Algebraic Semantics, </booktitle> <pages> pages 35-84. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: The term encompasses certain known categories (the category of concrete data structures and sequential algorithms <ref> [14] </ref>, categories of games [8], geometry of interaction categories [9]) as well as several new categories for concurrency. The fundamental examples of concurrent interaction categories are SProc [5], the category of synchronous processes, and ASProc [6], the category of asynchronous processes.
Reference: [15] <author> R. Blute. </author> <title> Linear logic, coherence and dinaturality. </title> <journal> Theoretical Computer Science, </journal> <volume> 115(1) </volume> <pages> 3-41, </pages> <year> 1993. </year>
Reference-contexts: In the case where k = 1 this construction is the internalization of composition in the category (using the autonomous structure) so it properly generalizes the standard inter pretation of Cut. Some related notions, arising in work on coherence in compact closed categories, can be found in the literature <ref> [15, 29] </ref>. 12 3.2 Products, Coproducts and Non-determinism The binary coproduct functor is defined on objects by AB = A + B def = finl fl (s) j s 2 S A g [ finr fl (s) j s 2 S B g: If p : A ! C and q
Reference: [16] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31 </volume> <pages> 560-599, </pages> <year> 1984. </year>
Reference-contexts: f ("; fag); (a; fbg); (a; fcg); (ab; ?); (ac; ?)g and if P = a:P , readies (P ) = f (a n ; fag j n &lt; !)g: The idea of a ready pair, and the related notions of failures and refusals, appear in the process algebra literature <ref> [12, 16, 27] </ref>. There, however, they are used to define semantic alternatives to bisimulation; the use made of ready pairs in this paper is very different. We use a orthogonality relation on ready pairs, rather than on processes as in Section 5.
Reference: [17] <author> P. M. Cohn. </author> <title> Universal Algebra, </title> <booktitle> volume 6. </booktitle> <address> D. </address> <publisher> Reidel, </publisher> <year> 1981. </year>
Reference-contexts: U , 8Q 2 U:P ? Q def Orthogonality then generates an operation of negation on sets of processes, defined by U ? def = fP 2 Proc (A) j P ? U g: Defining () ? in this way from a symmetric orthogonality relation yields a self-adjoint Galois connection <ref> [17] </ref> and the following lemma holds for general reasons. Lemma 5.5 For all U; V Proc (A), 1: U V ) V ? U ? 3: U ? = U ??? : Proof 1. If P 2 V ? then 8Q 2 V:P ? Q.
Reference: [18] <author> R. L. Crole. </author> <title> Categories for Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: The above example of structure on C is illustrative. Exactly similar definitions can be given for a range of structures, including: * models of classical (or intuitionistic) linear logic including the additives and expo nentials [11] * cartesian closed categories <ref> [18] </ref> * models of polymorphism [18]. 2.1 Examples of Specification Structures In each case we specify the category C, the assignment of properties P to objects and the Hoare triple relation. 1. C = Set, P S X = X, aff gb , f (a) = b. <p> The above example of structure on C is illustrative. Exactly similar definitions can be given for a range of structures, including: * models of classical (or intuitionistic) linear logic including the additives and expo nentials [11] * cartesian closed categories <ref> [18] </ref> * models of polymorphism [18]. 2.1 Examples of Specification Structures In each case we specify the category C, the assignment of properties P to objects and the Hoare triple relation. 1. C = Set, P S X = X, aff gb , f (a) = b.
Reference: [19] <author> J. W. de Bakker. </author> <title> Mathematical Theory of Program Correctness. </title> <publisher> Prentice Hall International, </publisher> <year> 1980. </year>
Reference-contexts: Some examples follow. * Even in the most basic form of sequential programming, it has proved fruitful to separate out the aspects of partial correctness and termination, and to use different methods for these two aspects <ref> [19] </ref>. * In the field of static analysis, and particularly in the systematic framework of abstract interpretation [28], a basic ingredient of the methodology is to use a range of non standard interpretations to gain information about different properties of interest. * In concurrency, it is standard to separate out classes <p> following axioms, for f : A ! B, g : B ! C, ' 2 P S A, 2 P S B and 2 P S C: 'fid A g' (1) The axioms (1) and (2) are typed versions of the standard Hoare logic axioms for "skip" and "sequential composition" <ref> [19] </ref>. Given C and S as above, we can define a new category C S . An object of C S is a pair (A; ') with A 2 ob C and ' 2 P S A.
Reference: [20] <author> M. A. Frumkin. </author> <title> Systolic Computations, volume 83 of Mathematics and its Applications (Soviet Series). </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: As an application of the theory developed in the rest of the paper, Section 7 analyses the construction of a class of synchronous networks, which encompasses both synchronous dataflow programs in languages such as Signal [25] and Lustre [26], and systolic algorithms <ref> [20] </ref>. Finally we compare our theory with other approaches, and discuss the possibilities for further developments. 2 Specification Structures The notion of specification structure, at least in its most basic form, is quite anodyne, and indeed no more than a variation on standard notions from category theory. <p> The two main examples of synchronous networks are synchronous dataflow programs, written in languages such as Signal [25] and Lustre [26], and systolic algorithms <ref> [20] </ref>. Given that the topology of a network never changes, the operation of categorical composition (parallel composition + hiding) is suitable for forming a fixed, private connection between two nodes.
Reference: [21] <author> S. J. Gay. </author> <title> Linear Types for Communicating Processes. </title> <type> PhD thesis, </type> <institution> University of London, </institution> <year> 1995. </year>
Reference-contexts: The dynamic nature of composition in interaction categories is one of the key features, and is in sharp contrast to the functional composition typically found in categories of mathematical structures. There is not yet a definitive axiomatisation of interaction categories, although some possibilities have been considered <ref> [21] </ref>. <p> Because the present paper mainly concerns the use of specification structures for deadlock-freedom, we omit the features of SProc which will not be needed in later sections. More complete definitions can be found elsewhere <ref> [1, 21] </ref>. An object of SProc is a pair A = ( A ; S A ) in which A is an alphabet (sort) of actions (labels) and S A nepref fl A is a safety specification, i.e. a non-empty prefix-closed subset of fl A . <p> It is standard in concurrency theory that such a definition has a unique solution [36]. fl We will not go into the applications of this property in the present paper, except to mention that it supports guarded recursive definitions <ref> [1, 21] </ref> and is an important part of a proposed axiomatisation of interaction categories [21]. <p> in concurrency theory that such a definition has a unique solution [36]. fl We will not go into the applications of this property in the present paper, except to mention that it supports guarded recursive definitions [1, 21] and is an important part of a proposed axiomatisation of interaction categories <ref> [21] </ref>. <p> Therefore (X 1 fi fi X n ) " X 6= ?, as required. fl We will use the term source to describe an output which is independent of any input which forms part of a cycle under consideration. In previous work <ref> [21] </ref> the term source has been used to describe an output which is independent of all inputs, but here we will use this weaker definition. The process P in Proposition 7.4 represents the network at the last stage of construction, just before formation of the cycle. <p> It can be shown, assuming that the outputs of nodes depend functionally on the inputs and that nodes are deterministic (these conditions are always satisfied for a language such as Lustre), that sources are preserved by composition <ref> [21] </ref>. Hence it is sufficient to check that there is a source somewhere in every cycle. 7.3 Generalisations In our analysis of networks, we have simply identified each port as either an input or an output. <p> The result is a category of deadlock-free processes in which the global synchrony condition is not present. Preliminary versions of this work have appeared in <ref> [2, 21] </ref> and an improved version in [40]; a full report of this area will be the subject of a future paper. Another avenue of investigation is the development of a formal syntax, incorporating value-passing rather than simply synchronisation, with which to describe processes in SProc D .
Reference: [22] <author> G. </author> <title> Gentzen. Investigations into logical deduction. </title> <editor> In M. E. Szabo, editor, </editor> <booktitle> The Collected Papers of Gerhard Gentzen. </booktitle> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: In particular, compact closure validates a very useful typing rule which we call multi-cut. (This is actually Gentzen's MIX rule <ref> [22] </ref> but we avoid the use of this term since Girard has used it for a quite different rule in the context of linear logic.) The usual Cut rule ` ; A ` ; A ? allows us to plug two modules together by an interface consisting of a single port
Reference: [23] <author> J.-Y. Girard. </author> <title> Linear Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50(1) </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: ; C " id X = ?g CfRgD def C D = f ((x; x 0 ); (y; y 0 )) j xCy ^ x 0 Dy 0 g X = X 2 n (C [ id X ): C S is the category of coherence spaces and linear maps <ref> [23] </ref>. 5. C = Set; P S X = fs : ! * X j 8x 2 X:9n 2 !:s (n) = xg; def where ' n is the nth partial recursive function in some acceptable numbering [45]. <p> There is not yet a definitive axiomatisation of interaction categories, although some possibilities have been considered [21]. The common features of the existing examples are that they have fl-autonomous structure, which corresponds to the multiplicative fragment of classical linear logic <ref> [23] </ref>; products and coproducts, corresponding to the additives of linear logic, and additional temporal structure which enables the dynamics of process evolution to be described. 3.1 The Interaction Category SProc In this section we briefly review the definition of SProc, the category of synchronous processes. <p> We will use the notation A N B for the product of A and B, in line with the standard notation for the additive connectives of linear logic <ref> [23] </ref>. In SProc, A N B is the same object as A B, but we will use the product notation when we want to emphasise the product properties. Exploiting the self-duality of SProc objects, we can define projections and pairing as follows. <p> Convergence means deadlock-freedom; the reason for the choice of terminology is an analogy with proofs of strong normalisation in Classical Linear Logic <ref> [23, 4] </ref>.
Reference: [24] <author> J.-Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Indeed, type inference systems, even for the basic case of functional programming languages, span a broad spectrum in terms of expressive power. Thus, ML-style types [39] are relatively weak as regards expressing behavioural constraints, but correspondingly tractable as regards efficient algorithms for "type checking". System F types <ref> [24] </ref> are considerably more expressive of polymorphic behaviour, and System F typing guarantees Strong Normalization. However, System F cannot express the fact that a program of type list [nat] ) list [nat] is actually a sorting function.
Reference: [25] <author> P. Guernic, T. Gautier, M. Borgne, and C. Maire. </author> <title> Programming real-time applications with Signal. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: As an application of the theory developed in the rest of the paper, Section 7 analyses the construction of a class of synchronous networks, which encompasses both synchronous dataflow programs in languages such as Signal <ref> [25] </ref> and Lustre [26], and systolic algorithms [20]. <p> The two main examples of synchronous networks are synchronous dataflow programs, written in languages such as Signal <ref> [25] </ref> and Lustre [26], and systolic algorithms [20]. Given that the topology of a network never changes, the operation of categorical composition (parallel composition + hiding) is suitable for forming a fixed, private connection between two nodes.
Reference: [26] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous data flow programming language Lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: As an application of the theory developed in the rest of the paper, Section 7 analyses the construction of a class of synchronous networks, which encompasses both synchronous dataflow programs in languages such as Signal [25] and Lustre <ref> [26] </ref>, and systolic algorithms [20]. <p> The two main examples of synchronous networks are synchronous dataflow programs, written in languages such as Signal [25] and Lustre <ref> [26] </ref>, and systolic algorithms [20]. Given that the topology of a network never changes, the operation of categorical composition (parallel composition + hiding) is suitable for forming a fixed, private connection between two nodes.
Reference: [27] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: f ("; fag); (a; fbg); (a; fcg); (ab; ?); (ac; ?)g and if P = a:P , readies (P ) = f (a n ; fag j n &lt; !)g: The idea of a ready pair, and the related notions of failures and refusals, appear in the process algebra literature <ref> [12, 16, 27] </ref>. There, however, they are used to define semantic alternatives to bisimulation; the use made of ready pairs in this paper is very different. We use a orthogonality relation on ready pairs, rather than on processes as in Section 5.
Reference: [28] <author> N. D. Jones and F. Nielson. </author> <title> Abstract interpretation. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 4. </volume> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: * Even in the most basic form of sequential programming, it has proved fruitful to separate out the aspects of partial correctness and termination, and to use different methods for these two aspects [19]. * In the field of static analysis, and particularly in the systematic framework of abstract interpretation <ref> [28] </ref>, a basic ingredient of the methodology is to use a range of non standard interpretations to gain information about different properties of interest. * In concurrency, it is standard to separate out classes of properties such as safety, liveness, and fairness constraints, extending into a whole temporal hierarchy, and to
Reference: [29] <author> G. M. Kelly and M. L. Laplaza. </author> <title> Coherence for compact closed categories. </title> <journal> Journal of Pure and Applied Algebra, </journal> <volume> 19 </volume> <pages> 193-213, </pages> <year> 1980. </year>
Reference-contexts: In the case where k = 1 this construction is the internalization of composition in the category (using the autonomous structure) so it properly generalizes the standard inter pretation of Cut. Some related notions, arising in work on coherence in compact closed categories, can be found in the literature <ref> [15, 29] </ref>. 12 3.2 Products, Coproducts and Non-determinism The binary coproduct functor is defined on objects by AB = A + B def = finl fl (s) j s 2 S A g [ finr fl (s) j s 2 S B g: If p : A ! C and q
Reference: [30] <author> N. Kobayashi. </author> <title> A partially deadlock-free typed process calculus. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Many of them are based on the idea of identifying ports or channels as input or outputs, and checking that outputs are always connected to inputs. There are several variations which include information about how many times channels are used [31], the order of usage of channels <ref> [30] </ref>, subtyping [43], types for choice and branching behaviour [46]. The distinguishing features of our approach are as follows. First, it is based on interaction categories, a theory which emphasises the collective structure of processes and describes this structure using the language of category theory.
Reference: [31] <author> N. Kobayashi, B. C. Pierce, and D. N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In Proceedings, 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: Many of them are based on the idea of identifying ports or channels as input or outputs, and checking that outputs are always connected to inputs. There are several variations which include information about how many times channels are used <ref> [31] </ref>, the order of usage of channels [30], subtyping [43], types for choice and branching behaviour [46]. The distinguishing features of our approach are as follows.
Reference: [32] <author> D. C. Kozen and J. Tiuryn. </author> <title> Logics of programs. </title> <editor> In van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 789-840. </pages> <publisher> North Holland, </publisher> <year> 1990. </year> <month> 42 </month>
Reference-contexts: C = Rel, P S X = fflg, flfRgfl def Then C S is the category of sets and partial functions. 3. C = Rel, P X = -X, SfRgT def , 8x 2 S: fy j xRyg T . This is essentially a typed version of dynamic logic <ref> [32] </ref>, with the "Hoare triple relation" specialized to its original setting. If we take S X;Y T = S fi T X = XnS then C S becomes a model of classical linear logic. 5 4.
Reference: [33] <author> S. Mac Lane. </author> <title> Categories for the Working Mathematician. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1971. </year>
Reference-contexts: monoidal category, i.e. there is a bifunctor : C 2 ! C, an object I, and natural isomorphisms assoc A;B;C : (A B) C ~ = A (B C) unitl A : I A ~ = A unitr A : A I ~ = A satisfying the standard coherence equations <ref> [33] </ref>. <p> Similarly for a morphism 0 ! A. fl When a category has biproducts and a zero object, it is possible to define a commutative monoid structure on each homset <ref> [33] </ref>.
Reference: [34] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: is to use a range of non standard interpretations to gain information about different properties of interest. * In concurrency, it is standard to separate out classes of properties such as safety, liveness, and fairness constraints, extending into a whole temporal hierarchy, and to apply different methods for these classes <ref> [34] </ref>. The upshot of this observation is that no one monolithic type system will serve all our purposes. Moreover, we need a coherent framework for moving around this space of different classes of properties.
Reference: [35] <author> J. McKinna and R. Burstall. Deliverables: </author> <title> A categorical approach to program development in type theory. </title> <booktitle> In Proceedings of Mathematical Foundation of Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Nevertheless, it provides an alternative view of these standard notions which is highly suggestive, particularly from a Computer Science point of view. Similar notions have been studied, for a variety of purposes, by Burstall and McKinna <ref> [35] </ref>, O'Hearn and Tennent [42], and Pitts [44]. Definition 2.1 Let C be a category.
Reference: [36] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: If A is an object of SProc, a process of type A is a process P with sort A such that traces (P ) S A . Our notion of process is labelled transition system, with strong bisimulation as the equivalence <ref> [36] </ref>. It is convenient to work with synchronization trees as canonical representatives of strong bisimulation classes. We will write ST () for the set of synchronization trees over a label-set . We will usually define processes by means of labelled transition rules. <p> Proof The equational condition that the square commute, namely It (f; g) = f ; ffi It (f; g) ; g, can be read as a guarded recursive definition of It (f; g). It is standard in concurrency theory that such a definition has a unique solution <ref> [36] </ref>. fl We will not go into the applications of this property in the present paper, except to mention that it supports guarded recursive definitions [1, 21] and is an important part of a proposed axiomatisation of interaction categories [21].
Reference: [37] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: There are two major respects in which our deadlock-free type system is perhaps a little too restrictive. First, we have not yet addressed the issue of mobility <ref> [37, 38] </ref>, which has featured prominently in recent research on concurrency theory. Second, the property guaranteed by type system is extremely strong|all processes must run forever. This is the reason why, in our applications, extra analysis is needed in order to construct cyclic networks.
Reference: [38] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, II. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: There are two major respects in which our deadlock-free type system is perhaps a little too restrictive. First, we have not yet addressed the issue of mobility <ref> [37, 38] </ref>, which has featured prominently in recent research on concurrency theory. Second, the property guaranteed by type system is extremely strong|all processes must run forever. This is the reason why, in our applications, extra analysis is needed in order to construct cyclic networks.
Reference: [39] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Indeed, type inference systems, even for the basic case of functional programming languages, span a broad spectrum in terms of expressive power. Thus, ML-style types <ref> [39] </ref> are relatively weak as regards expressing behavioural constraints, but correspondingly tractable as regards efficient algorithms for "type checking". System F types [24] are considerably more expressive of polymorphic behaviour, and System F typing guarantees Strong Normalization.
Reference: [40] <author> R. Nagarajan. </author> <title> Typed Concurrent Programs: Specification & Verification. </title> <type> PhD thesis, </type> <institution> University of London, </institution> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The result is a category of deadlock-free processes in which the global synchrony condition is not present. Preliminary versions of this work have appeared in [2, 21] and an improved version in <ref> [40] </ref>; a full report of this area will be the subject of a future paper. Another avenue of investigation is the development of a formal syntax, incorporating value-passing rather than simply synchronisation, with which to describe processes in SProc D .
Reference: [41] <author> B. Nordstrom, K. Petersson, and J. M. Smith. </author> <title> Programming in Martin-Lof 's Type Theory: An Introduction, </title> <booktitle> volume 7 of International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: System F types [24] are considerably more expressive of polymorphic behaviour, and System F typing guarantees Strong Normalization. However, System F cannot express the fact that a program of type list [nat] ) list [nat] is actually a sorting function. Martin-Lof type theory <ref> [41] </ref>, with dependent types and equality types, can express complete total correctness specifications. In the richer theories, type checking is undecidable [47]. One might try to make a methodological distinction: post-hoc verification vs. constructions with intrinsic properties.
Reference: [42] <author> P. W. O'Hearn and R. D. Tennent. </author> <title> Relational parametricity and local variables. </title> <booktitle> In Proceedings, 20th ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Nevertheless, it provides an alternative view of these standard notions which is highly suggestive, particularly from a Computer Science point of view. Similar notions have been studied, for a variety of purposes, by Burstall and McKinna [35], O'Hearn and Tennent <ref> [42] </ref>, and Pitts [44]. Definition 2.1 Let C be a category.
Reference: [43] <author> B. Pierce and D. Sangiorgi. </author> <title> Types and subtypes for mobile processes. </title> <booktitle> In Proceedings, Eighth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Many of them are based on the idea of identifying ports or channels as input or outputs, and checking that outputs are always connected to inputs. There are several variations which include information about how many times channels are used [31], the order of usage of channels [30], subtyping <ref> [43] </ref>, types for choice and branching behaviour [46]. The distinguishing features of our approach are as follows. First, it is based on interaction categories, a theory which emphasises the collective structure of processes and describes this structure using the language of category theory.
Reference: [44] <author> A. M. Pitts. </author> <title> Relational properties of recursively defined domains. </title> <booktitle> In 8th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 86-97. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, </address> <year> 1993. </year>
Reference-contexts: Nevertheless, it provides an alternative view of these standard notions which is highly suggestive, particularly from a Computer Science point of view. Similar notions have been studied, for a variety of purposes, by Burstall and McKinna [35], O'Hearn and Tennent [42], and Pitts <ref> [44] </ref>. Definition 2.1 Let C be a category.
Reference: [45] <author> R. Soare. </author> <title> Recursively Enumerable Sets and Degrees. Perspectives in Mathematical Logic. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: C = Set; P S X = fs : ! * X j 8x 2 X:9n 2 !:s (n) = xg; def where ' n is the nth partial recursive function in some acceptable numbering <ref> [45] </ref>. Then C S is the category of modest sets, seen as a full subcategory of !-Set [11]. 6. C = the category of SFP domains; P S D = K (D)(the compact-open subsets of D); U ff gV , U f 1 (V ).
Reference: [46] <author> K. Takeuchi, K. Honda, and M. Kubo. </author> <title> An interaction-based language and its typing system. </title> <booktitle> In Proceedings of the 6th European Conference on Parallel Languages and Architectures, number 817 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: ready specification f (s; A (s)) j length (s) is eveng [ f (s; X) j X A (s); length (s) is oddg: A detailed development of this idea, which is a subject for future work, should lead to interesting connections with the type system proposed by Takeuchi et al. <ref> [46] </ref>. 39 8 Conclusions We have proposed a type-theoretic view of the specification and verification of concurrent systems. The relevant technical machinery is the notion of specification structures, which provides a systematic approach to the construction of a hierarchy of type systems expressing increasingly strong specifications. <p> There are several variations which include information about how many times channels are used [31], the order of usage of channels [30], subtyping [43], types for choice and branching behaviour <ref> [46] </ref>. The distinguishing features of our approach are as follows. First, it is based on interaction categories, a theory which emphasises the collective structure of processes and describes this structure using the language of category theory. <p> We have also mentioned, in Section 7, the possibility of giving a semantics to general communication patterns similar to those in the type system of Takeuchi et al. <ref> [46] </ref>. There are two major respects in which our deadlock-free type system is perhaps a little too restrictive. First, we have not yet addressed the issue of mobility [37, 38], which has featured prominently in recent research on concurrency theory.
Reference: [47] <author> J. B. Wells. </author> <title> Typability and type checking in the second-order -calculus are equivalent and undecidable. </title> <booktitle> In Proceedings, Ninth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year> <month> 43 </month>
Reference-contexts: However, System F cannot express the fact that a program of type list [nat] ) list [nat] is actually a sorting function. Martin-Lof type theory [41], with dependent types and equality types, can express complete total correctness specifications. In the richer theories, type checking is undecidable <ref> [47] </ref>. One might try to make a methodological distinction: post-hoc verification vs. constructions with intrinsic properties. However, this is more a distinction between ways in which Type Inference/Verification can be deployed than between these two formal paradigms.
References-found: 47

