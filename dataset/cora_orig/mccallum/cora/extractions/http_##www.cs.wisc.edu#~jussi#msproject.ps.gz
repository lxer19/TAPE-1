URL: http://www.cs.wisc.edu/~jussi/msproject.ps.gz
Refering-URL: http://www.cs.wisc.edu/~jussi/jussi.html
Root-URL: 
Email: jussi@cs.wisc.edu  
Keyword: Jussi Myllyma ki  
Address: Madison, WI 53706  
Affiliation: University of Wisconsin-Madison Computer Sciences Department  
Abstract: Joins On Tapes: Project Report Abstract In this paper, we report the construction of a simulator that was designed to measure the performance of various, new join methods which operate on tertiary storage devices. The simulator supports multiple device types with arbitrary number of drives of each kind. Modules and functionality found in relational database systems, such as hash tables, relation catalogs, and multi-page, interleaved input/output requests, are available in the simulator. Also included in the design principles of the simulator is an iterator function scheme which closely resembles that found in the query plan execution engine of commercial relational database systems. The new join methods are believed to offer far better performance on tertiary storage devices than conventional join methods (e.g., Grace and Hybrid Hash Joins). Indeed, new join methods such as Nested Block Join for Tape seem promising compared to their disk-based counterparts. The design and initial results of this simulator should be interesting to implementors of tertiary storage database sys tems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Haas, L., Carey, M., and Livny, M. </author> <title> "Tape Join Algorithms". </title> <note> Unpublished. </note>
Reference-contexts: Instead, large databases are often first transferred from tape to disk, and the join is then performed on disk. This project set out to build a simulator allowing us to experiment with a set of new join methods <ref> [1] </ref> which were designed for tertiary storage devices. The simulator is used to assess the usefulness of these algorithms with relatively large sets of data. In particular, the simulator was designed to support multiple device types each having totally different operating characteristics. <p> New Join Methods This section describes the new join methods being tested <ref> [1] </ref> as well as reviews the Nested Block Join for comparative purposes. For all algorithms, we assume R and S are on different tapes and R is smaller than S. Each relation fits in one tape and the tapes are already loaded in their respective drives. <p> Nested Block Join for Tape, A Variation This algorithm is a variation of the Nested Block Join for Tape and does not appear in <ref> [1] </ref>. The idea is that instead of hashing a chunk of R every time it is read from disk, we hash the chunk of S instead. <p> However, after scaling relation and disk sizes up (to represent huge databases), we expect the savings to be magnified. Future work in this project includes extending the system by providing more new join methods <ref> [1] </ref> and by refining the tape drive component of the simulator. The tape drive will be made to support multiple tracks and backward-reading. It also needs finer granularity in terms of simulating tape block retrieval and storing. The tape drive caching strategy also needs updating with these modifications.
Reference: [2] <author> Carey, M., Haas, L., and Livny, M. </author> <title> "Tapes Hold Data, Too: Challenges of Tuples on Tertiary Store". </title> <booktitle> Proc. SIGMOD, </booktitle> <address> May 1993, Washington, D.C., </address> <pages> pp. 413-417. - 24 </pages> - 
Reference-contexts: The catalog component opens a relation catalog and an attribute catalog which are relations themselves. The parameterization module sets the internal parameter values after reading the simulator configuration file and the command line. 2.2. Simulation Aspects of the I/O System In <ref> [2] </ref> and [3], Carey, Haas, and Livny argue that it is vital for a query optimizer to have a detailed I/O cost model when selecting the algorithm to be used for a particular join.
Reference: [3] <author> Haas, L., Carey, M., and Livny, M. </author> <title> "SEEKing the Truth about Ad Hoc Join Costs". </title>
Reference-contexts: The catalog component opens a relation catalog and an attribute catalog which are relations themselves. The parameterization module sets the internal parameter values after reading the simulator configuration file and the command line. 2.2. Simulation Aspects of the I/O System In [2] and <ref> [3] </ref>, Carey, Haas, and Livny argue that it is vital for a query optimizer to have a detailed I/O cost model when selecting the algorithm to be used for a particular join. They observed that in many performance studies, a simple model of counting pages read and written was used.
Reference: [4] <author> Graefe, G. </author> <title> "Query Evaluation Techniques for Large Databases". </title> <journal> ACM Comput. Surv., </journal> <volume> vol. 25, no. 2, </volume> <month> June </month> <year> 1993, </year> <pages> pp. 73-170. </pages>
Reference-contexts: Implementation of Operators We chose the "Iterator Functions" model for implementing the operators. This model is a basis for implementing a query execution engine in a relational database management system, and is much like the model found in systems such as System R, Ingrex, Informix, and Oracle <ref> [4] </ref>. The iterator model is effective for synchronization of operators and data transfer between them. Assume a system is about to execute a query plan, given as a query tree with nodes representing operators and edges representing data transfer from operators lower in the tree to higher operators. <p> It prepares the operator for subsequent Next calls. The Next function returns the next tuple to the caller, calling the Next function of its inputs as needed and performing necessary computations (e.g. joining two tuples). The Close function closes inputs channels and releases allocated memory. - 5 - In <ref> [4] </ref> and [5], Graefe lists several benefits and observations of this model of implementation: g the entire query plan is executed within a single process g operators produce one item at a time on request g the model effectively implements coroutines and demand-driven dataflow g items never wait between operators, not
Reference: [5] <author> Graefe, G. </author> <title> "Encapsulation of Parallelism in the Volcano Query Processing System". </title> <booktitle> Proc. SIGMOD, </booktitle> <address> May 1989, Portland, OR, </address> <pages> pp. 102-111. </pages>
Reference-contexts: The Next function returns the next tuple to the caller, calling the Next function of its inputs as needed and performing necessary computations (e.g. joining two tuples). The Close function closes inputs channels and releases allocated memory. - 5 - In [4] and <ref> [5] </ref>, Graefe lists several benefits and observations of this model of implementation: g the entire query plan is executed within a single process g operators produce one item at a time on request g the model effectively implements coroutines and demand-driven dataflow g items never wait between operators, not in temporary
Reference: [6] <author> Lee, E.K. and Katz, </author> <title> R.H. "An Analytic Performance Model of Disk Arrays". </title> <booktitle> Proc. SIGMETRICS, </booktitle> <month> May </month> <year> 1993, </year> <title> Santa Clara. Published in Performance Evaluation Review, </title> <journal> vol. </journal> <volume> 21, no. 1, </volume> <pages> pp. 98-109. - 25 </pages> - 
Reference-contexts: The seek cost is derived from a formula given in <ref> [6] </ref>. For disk parameters, we approximate the parameters of a Fujitsu M2652H disk drive (Table 1). Disk latency is accounted for as an average latency, and we assume it to be one half of a disk revolution. The average latency is therefore 0.5 11.1 = 5.5 milliseconds.
References-found: 6

