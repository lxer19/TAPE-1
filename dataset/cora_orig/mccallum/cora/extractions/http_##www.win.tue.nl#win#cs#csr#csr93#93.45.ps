URL: http://www.win.tue.nl/win/cs/csr/csr93/93.45.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Title: A precise clock synchronization protocol  
Author: E.J. Luit and J.M.M. Martin 
Keyword: Real-time Distributed Systems, Fault Tolerance, Physical Clock Synchronization  
Address: Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science, Eindhoven University of Technology,  
Abstract: A distributed clock synchronization protocol is presented which achieves a very high precision without the need for very frequent resynchronizations. The protocol tolerates failures of the clocks: clocks may be too slow or too fast, exhibit omission failures and report inconsistent values. Synchronization takes place in synchronization rounds as in many other synchronization protocols. At the end of each round, clock times are exchanged between the clocks. Each clock applies a convergence function (CF) to the values obtained. This function estimates the difference between its clock and an average clock and corrects its clock accordingly. Clocks are corrected for drift relative to this average clock during the next synchronization round. The protocol is based on the assumption that clock reading errors are small with respect to the required precision of synchronization. It is shown that the CF resynchronizes the clocks with high precision even when relatively large clock drifts are possible. The CF of the algorithm exploits the properties of a matrix that contains the differences between all clocks in the system. All correct processors have access to identical copies of this matrix which is disseminated by an underlying reliable message protocol. It is shown that the drift-corrected clocks remain synchronized until the end of the next synchronization round. The maximum length of a synchronization round mainly depends on the precision with which the clocks are resynchronized and on the maximum magnitude of the second time derivative of the function that describes a clock. The stability of the protocol is proven, i.e., it is shown that drift of the clocks with respect to physical time is bounded. 
Abstract-found: 1
Intro-found: 1
Reference: [Bres65] <author> Bresenham, </author> <title> J.E., Algorithm for computer control of a digital plotter, </title> <journal> IBM Systems Journal 4 (1965), </journal> <pages> pp 25-30. </pages>
Reference-contexts: Corrections are made a single tick at the time because the precision depends linearly on the size of the corrections (see section 5). The times at which the corrections must be applied are estimated with a version of Bresenham's line discretization algorithm <ref> [Bres65] </ref>. This algorithm guarantees that the corrections are always within one clock tick of the intended correction. At the end of the first phase, the measurement period starts around time T n M . Each clock sends its clock value to all other clocks. <p> est; t += nstep ; tcurr += nstep; g t = nslices - tcurr; /* last interval of synchronization period */ 'wait (t)'; if ( es &lt; 0 ) 'advance clock by 1 tick'; g The continuous part of 5.3 is estimated with a version of Bresenham's line discretization algorithm <ref> [Bres65] </ref> that can be executed by a separate thread or process. The algorithm shown in figure 3 only works for negative values of 4t iA , but can easily be adapted to handle positive values as well.
Reference: [Cris89] <author> Cristian, F., </author> <title> Probabilistic Clock Synchronization, IBM Almaden research center, </title> <booktitle> Distributed Computing 1989-3, </booktitle> <pages> pp 146-158. </pages>
Reference-contexts: The protocol was developed to achieve a precision of 100 s given a worst-case clock drift rate (or drift, for short) of 10 4 and a clock reading error of approximately 2s. With these parameters, most published protocols, e.g., [LaMe85], [MaSch85] and [SrTo87], require very frequent resynchronizations. Cristian <ref> [Cris89] </ref> describes a protocol that avoids these frequent resynchronizations because the clocks are corrected for local drift. However, he only describes a master-slave protocol. This paper describes a distributed protocol that also applies drift corrections. <p> The reading error of local clocks is small if the hardware clocks can be read out in small units. A remote clock can only be read with a small error if uncertainties in message transmission delays are small. Almost constant transmission delays can be realized with Cristian's probabilistic synchronization <ref> [Cris89] </ref>. Almost constant transmission delays are also possible in a statically scheduled system such as the DEpendable Distributed Operating System (DEDOS) [SRLH91], [VLHJ91], [LuMo92]. In most published protocols, the CF calculates a new clock time from some fault-tolerant average of all clock values exchanged instead. <p> The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], [MaSch85], [Schn86], [SrTo87], <ref> [Cris89] </ref>, [OlSh91], [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision. This must be accomplished by a different protocol.
Reference: [Lamm92] <author> Lammers, A.J.M., </author> <title> Clock Synchronization for DEDOS, </title> <type> Master's Thesis, EUT, </type> <institution> Eindhoven 1992. </institution>
Reference-contexts: This merely complicates the formulae derived in section 5 but it does not present any fundamental problems <ref> [Lamm92] </ref>. However, it is assumed that some time elapses between the moment that the clock differences are measured and the moment that the clocks are resynchro-nized. The main reason for this assumption is that future research will be directed towards a hierarchical synchronization protocol.
Reference: [LaMe85] <author> Lamport,L and Melliar-Smith, </author> <title> P.M., Synchronizing clocks in the presence of faults, </title> <journal> J. A.C.M., </journal> <volume> Vol. 32, No. 1, </volume> <month> January </month> <year> 1985, </year> <pages> pp 52-78. </pages>
Reference-contexts: The protocol was developed to achieve a precision of 100 s given a worst-case clock drift rate (or drift, for short) of 10 4 and a clock reading error of approximately 2s. With these parameters, most published protocols, e.g., <ref> [LaMe85] </ref>, [MaSch85] and [SrTo87], require very frequent resynchronizations. Cristian [Cris89] describes a protocol that avoids these frequent resynchronizations because the clocks are corrected for local drift. However, he only describes a master-slave protocol. This paper describes a distributed protocol that also applies drift corrections. <p> This is discussed in more detail in section 5. Existing software synchronization protocols do not resynchronize the clocks with sufficient precision. For example, the CFs described in [MaSch85] achieve resynchronization precision to precision ratios of 2 3 and 1 3 . Of the CFs described in <ref> [LaMe85] </ref>, only algorithm CSM achieves a ratio that is just below 1 3 with the parameters given above. However, when details such as clock setting errors are taken into account, the ratio increases above 1 3 . <p> The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols <ref> [LaMe85] </ref>, [MaSch85], [Schn86], [SrTo87], [Cris89], [OlSh91], [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision. <p> In a statically scheduled system or with probabilistic clock synchronization, the above parameters are quite realistic. The length of the synchronization period is determined in this case by the stability of the drift. Lamport and Melliar-Smith give an example in the conclusion of their paper <ref> [LaMe85] </ref> with = 50s, " = 1s and ae max = 0:5 10 6 . Notice that their ae and " differ by a factor 2 from the ae max and " as used here. With these parameters, 0 = 12 2 3 s.
Reference: [LuMo92] <author> E.J. Luit and V.A.P. Mombarg, </author> <title> The DEDOS On-Line Scheduler, </title> <booktitle> Proc. International Workshop on Real-Time Programming 1992, </booktitle> <address> June 23-26 1992, Bruges, Belgium, </address> <pages> pp 119-124. </pages>
Reference-contexts: Almost constant transmission delays can be realized with Cristian's probabilistic synchronization [Cris89]. Almost constant transmission delays are also possible in a statically scheduled system such as the DEpendable Distributed Operating System (DEDOS) [SRLH91], [VLHJ91], <ref> [LuMo92] </ref>. In most published protocols, the CF calculates a new clock time from some fault-tolerant average of all clock values exchanged instead. The CF described in this paper examines the consistency of the clock differences exchanged.
Reference: [MaSch85] <author> Mahaney,S.R. and Schneider, </author> <title> F.B., Inexact Agreement: Accuracy, Precision, and Graceful Degradation, </title> <booktitle> Proc. of the 4 th annual ACM symp. on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1985, </year> <pages> pp. 237-249. </pages>
Reference-contexts: The protocol was developed to achieve a precision of 100 s given a worst-case clock drift rate (or drift, for short) of 10 4 and a clock reading error of approximately 2s. With these parameters, most published protocols, e.g., [LaMe85], <ref> [MaSch85] </ref> and [SrTo87], require very frequent resynchronizations. Cristian [Cris89] describes a protocol that avoids these frequent resynchronizations because the clocks are corrected for local drift. However, he only describes a master-slave protocol. This paper describes a distributed protocol that also applies drift corrections. <p> Drift corrections are only useful when the ratio of the resynchronization precision and the precision is smaller than 1 3 ,. This is discussed in more detail in section 5. Existing software synchronization protocols do not resynchronize the clocks with sufficient precision. For example, the CFs described in <ref> [MaSch85] </ref> achieve resynchronization precision to precision ratios of 2 3 and 1 3 . Of the CFs described in [LaMe85], only algorithm CSM achieves a ratio that is just below 1 3 with the parameters given above. <p> The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], <ref> [MaSch85] </ref>, [Schn86], [SrTo87], [Cris89], [OlSh91], [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision.
Reference: [Mart93] <author> Martin, J.M.M., </author> <title> Clock Synchronization with reading errors and Byzantine clock-behaviour. </title> <type> Master's Thesis, EUT, </type> <institution> Eindhoven 1993. </institution>
Reference: [OlSh91] <author> Olson,A and K.G. Shin, K.G., </author> <title> Probabilistic Clock Synchronization in Large Distributed Systems, </title> <booktitle> 11 th international conference on distributed systems, </booktitle> <address> Arlington, Tx, </address> <year> 1991. </year>
Reference-contexts: The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], [MaSch85], [Schn86], [SrTo87], [Cris89], <ref> [OlSh91] </ref>, [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision. This must be accomplished by a different protocol.
Reference: [Schn86] <author> Schneider, </author> <title> F.B., A paradigm for reliable clock synchronization, Proc. Advanced Seminar Real Time Local Area Network, </title> <month> april </month> <year> 1986, </year> <pages> pp. 85-104. 30 </pages>
Reference-contexts: Drift corrections are evidently not useful if the relative drifts of the clocks can not be estimated rather precisely. Local drift must be estimated with respect to some suitably defined average clock. When a clock is resynchronized, an algorithm called the Convergence Function (CF) <ref> [Schn86] </ref> calculates a correction for the clock. This correction can be interpreted as the best estimate of the difference between this clock and the average clock. The correction applied to synchronize a clock is thus also a measure of its drift relative to the average clock. <p> The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], [MaSch85], <ref> [Schn86] </ref>, [SrTo87], [Cris89], [OlSh91], [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision.
Reference: [SRLH91] <author> P.D.V. van der Stok, O.S. van Roosmalen, E.J. Luit and D.K. Hammer, </author> <title> An object-oriented approach to dependable responsive systems, </title> <booktitle> presented to 1st Int. Workshop on Responsive Systems, </booktitle> <address> Golfe-Juan, France, </address> <month> 3-4 oct </month> <year> (1991). </year>
Reference-contexts: Almost constant transmission delays can be realized with Cristian's probabilistic synchronization [Cris89]. Almost constant transmission delays are also possible in a statically scheduled system such as the DEpendable Distributed Operating System (DEDOS) <ref> [SRLH91] </ref>, [VLHJ91], [LuMo92]. In most published protocols, the CF calculates a new clock time from some fault-tolerant average of all clock values exchanged instead. The CF described in this paper examines the consistency of the clock differences exchanged.
Reference: [StClAl93] <author> Stok, P.D.V. van der, Claessen,M. and Alstein, D., </author> <title> Hierarchical membership protocol for synchronous distributed systems, </title> <type> EUT, </type> <institution> Computing Science Note cs93-40, </institution> <year> 1993. </year>
Reference-contexts: Since this assumption is made, all correct clocks have access to identical copies of an N by N matrix that contains the time differences between all clocks in the system. An example of a protocol that realizes assumption 7 is the one described in <ref> [StClAl93] </ref>.
Reference: [SrTo87] <author> Srikanth, T.K., and Toueg, S., </author> <title> Optimal Clock Synchronization, </title> <journal> Journal of the A.C.M., </journal> <volume> Vol 34, No 3, </volume> <month> July </month> <year> 1987, </year> <pages> pp 626-645. </pages>
Reference-contexts: The protocol was developed to achieve a precision of 100 s given a worst-case clock drift rate (or drift, for short) of 10 4 and a clock reading error of approximately 2s. With these parameters, most published protocols, e.g., [LaMe85], [MaSch85] and <ref> [SrTo87] </ref>, require very frequent resynchronizations. Cristian [Cris89] describes a protocol that avoids these frequent resynchronizations because the clocks are corrected for local drift. However, he only describes a master-slave protocol. This paper describes a distributed protocol that also applies drift corrections. <p> However, when details such as clock setting errors are taken into account, the ratio increases above 1 3 . The resynchroniza-tion precision of the protocol described in <ref> [SrTo87] </ref> equals the time needed to 1) prepare a message, 2) send it to all other processors and 3) process this message.Therefore, this 2 protocol can not be used either. In this paper, a hardware clock is described by two mathematical clocks. <p> The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], [MaSch85], [Schn86], <ref> [SrTo87] </ref>, [Cris89], [OlSh91], [VeRo92]. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision.
Reference: [VLHJ91] <author> J.P.C. Verhoosel, E.J. Luit, D.K. Hammer, E. Jansen, </author> <title> A Static Scheduling Algorithm for Distributed Hard Real-Time Systems, </title> <booktitle> The Journal of Real-Time Systems 3, </booktitle> <pages> pp 227-246, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Almost constant transmission delays can be realized with Cristian's probabilistic synchronization [Cris89]. Almost constant transmission delays are also possible in a statically scheduled system such as the DEpendable Distributed Operating System (DEDOS) [SRLH91], <ref> [VLHJ91] </ref>, [LuMo92]. In most published protocols, the CF calculates a new clock time from some fault-tolerant average of all clock values exchanged instead. The CF described in this paper examines the consistency of the clock differences exchanged.
Reference: [VeRo92] <author> Verissimo, P. and Rodrigues, L., </author> <title> A posteriori Agreement for fault tolerant clock synchronization on broadcasts networks, </title> <booktitle> 22nd international symposium on fault tolerant computing, </booktitle> <address> Boston, </address> <year> 1992 </year> <month> 31 </month>
Reference-contexts: The clock reading error was approximately 6.2 s. 2 Informal description of the protocol The protocol periodically resynchronizes the clocks, like many published synchronization protocols [LaMe85], [MaSch85], [Schn86], [SrTo87], [Cris89], [OlSh91], <ref> [VeRo92] </ref>. It is assumed that incorrect clocks may be present in the system. These clocks may run too slow or too fast, exhibit omission failures or report inconsistent values. Initially, correct clocks are assumed to be synchronized within the precision. This must be accomplished by a different protocol.
References-found: 14

