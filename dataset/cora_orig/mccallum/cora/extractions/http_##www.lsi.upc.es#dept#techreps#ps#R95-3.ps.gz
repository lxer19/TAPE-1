URL: http://www.lsi.upc.es/dept/techreps/ps/R95-3.ps.gz
Refering-URL: http://www.lsi.upc.es/dept/techreps/1995.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The complexity of searching implicit graphs  
Author: Jose L. Balcazar* 
Abstract: The standard complexity classes of Complexity Theory do not allow for direct classification of most of the problems solved by heuristic search algorithms. The reason is that, in their standard definition, complexity classes are specifically tailored to explicit, instead of implicit, graphs of state or problem reduction spaces. But the usual practice works over implicit graphs. To allow for more precise comparisons with standard complexity classes, we introduce here a model for the analysis of algorithms on graphs given by vertex expansion procedures. It is based on previously studied concepts of "succinct representation" techniques, and allows us to prove PSPACE-completeness or EXPTIME-completeness of specific, natural problems on implicit graphs, such as those solved by A*, AO*, and other best-first search strategies.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Balcazar, J. Diaz, J. Gabarro: </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag 1988. </publisher> <pages> 14 </pages>
Reference-contexts: Therefore, we assume that it can be implemented with a family of boolean circuits: it is well-known that this model exactly characterizes (via completeness) polynomial time computations <ref> [1] </ref>. Let us set this idea in the perspective of previous research on succinct input representation. Problems on succinct representations The study of algorithmic graph problems on succinct representations was introduced independently in [6] and [29], and has been proven useful in other applications of Complexity Theory. <p> Therefore, its input is an instance of A, i.e. (an encoding of) a graph G on, say, n vertices, and a pair of vertices of f (G); it finds whether this pair is indeed an edge of f (G). Via a now standard transformation (see <ref> [1] </ref>), and assuming that all the bits of G are available at all times, a boolean circuit can be constructed which computes any requested bit of the output of the reduction on x. The size of the circuit is log n. <p> Without loss of generality, we have assumed that n can be easily read out from this input circuit. Examination of the circuit simulating M (see <ref> [1] </ref>) shows that it consists of layers, each layer t computing the configuration of the machine after t steps. Each layer contains gates whose output correspond to the indexing tape, and therefore mark the bit being read. The next layer needs knowledge of that bit. <p> Moreover, the space hierarchy theorem (see <ref> [1] </ref>) guarantees that there is no subpolynomial memory space solution for this problem. ("Subpolynomial" was defined in the preliminaries.) Of course, all algorithms used in practice are memory-consuming in the worst case... PSPACE-completeness implies that there is no substantially cheaper alternative. <p> A proof that sAGAP is EXPTIME-complete follows immediately from this fact. 7. Theorem. sAGAP is EXPTIME-complete. This implies, by the time hierarchy theorem (see <ref> [1] </ref>), that no polynomial (nor even subexponential) time solution exists at all for this problem: EXPTIME-complete problems are provably intractable.
Reference: [2] <author> J. L. Balcazar, A. Lozano, J. Toran: </author> <title> "The complexity of algorithmic problems on succinct instances". </title> <booktitle> In: Computer Science: Research and Applications, </booktitle> <editor> R. Baeza-Yates and U. Manber (eds.), </editor> <publisher> Plenum 1992. </publisher>
Reference-contexts: Then [24] pointed out that the use of projection reducibility allows one to prove that all known NP-complete problems become NEXP-complete under succinct input representation via circuits (see also Chapter 20 of [21]). This observation is extended in <ref> [2] </ref>, by means of logtime reducibility, to a very general result (the Conversion Lemma) relating the complexity of problems on standard input convention to their respective succinct versions, independently of the complexity classes in which they lie. <p> This last result also abstracts from the previously used graph-theoretic setting, since the Conversion Lemma works on binary encodings of arbitrary data types. Subsequently, the notion of succinct representation and variants of the results from <ref> [2] </ref> have been employed in [5] to characterize the computational complexity of a number of problems from Logic Programming and Databases (specifically, disjunctive Datalog queries under various semantics). <p> We state now the main property of this representation, from the complexity-theoretic point of view. The analogous result for other, technically different, simpler form of succinct representation was given in <ref> [2] </ref>; it used also a slightly different reducibility, and did not need the extra condition of coverability. The proof is now more complex due to the more involved definition of succinct representation, which now must provide more information. 1. Theorem. Let A and B be decisional problems defined on graphs. <p> positions encoded by words of the same length allows for implementing the polynomial time algorithm as a circuit, and therefore the games from [28] correpond to a succinct representation in terms of transition matrices (in the sense of [6]) of the GAME problem of [14], and thus it follows from <ref> [2] </ref> that there are EXPTIME-complete games. Note, however, that in principle these facts do not speak of algorithms such as AO*, which are based on vertex expansions instead of recognizing edges.
Reference: [3] <author> A. K. Chandra, D. C. Kozen, L. J. Stockmeyer: </author> <title> "Alternation". </title> <journal> Journal of the ACM 28 (1981), </journal> <pages> 114-133. </pages>
Reference-contexts: The slight difference between the standard Turing machine model and ours consists in that, since we will need to work with sublinear time computations, we cannot afford sequential access to the input. Instead, we use indexing machines <ref> [3] </ref>, in which there is a specific "indexing tape" which points to the input tape.
Reference: [4] <author> A. K. Chandra, L. J. Stockmeyer, U. Vishkin: </author> <title> "Constant depth reducibility". </title> <journal> SIAM Journal on Computing 13 (1984), </journal> <pages> 423-439. </pages>
Reference: [5] <author> T. Eiter, G. Gottlob, H. Mannila: </author> <title> "Adding disjunction to DATALOG". </title> <booktitle> In: Proc. ACM Symp. on Principles of Database Systems 1994. </booktitle>
Reference-contexts: This last result also abstracts from the previously used graph-theoretic setting, since the Conversion Lemma works on binary encodings of arbitrary data types. Subsequently, the notion of succinct representation and variants of the results from [2] have been employed in <ref> [5] </ref> to characterize the computational complexity of a number of problems from Logic Programming and Databases (specifically, disjunctive Datalog queries under various semantics).
Reference: [6] <author> H. Galperin, A. Wigderson: </author> <title> "Succinct representations of graphs". </title> <booktitle> Information and Control 56 (1983), </booktitle> <pages> 183-198. </pages>
Reference-contexts: Let us set this idea in the perspective of previous research on succinct input representation. Problems on succinct representations The study of algorithmic graph problems on succinct representations was introduced independently in <ref> [6] </ref> and [29], and has been proven useful in other applications of Complexity Theory. <p> So, a careful and detailed analysis of each input convention is necessary. In the case of decisional problems on graphs, the input is not the graph itself but (the encoding of) a boolean circuit which computes its transition matrix. For this model, <ref> [6] </ref> and [29] classify as complete in some class of the polynomial time hierarchy or the counting hierarchy (or higher up) many specific problems on succinct instances; many of these are polynomially solvable for standard input representation. <p> This 7 provides exactly the needed bit. In this way, the whole circuit calculating each bit of f (G) is obtained; call this circuit C 0 . It would qualify as a succinct representation of f (G) under the definition of <ref> [6] </ref>; but does not yet, for ours, exactly for the same reason that the previously used succinct representations did not provide an adequate model for the graph search algorithms: it computes a bit of the transition matrix, not a list of successors. Here is where coverability enters into play. <p> The proof is a simple modification of the analogous one in <ref> [6] </ref>: for time classes, given the circuit, first expand it into the whole graph, then apply an algorithm on the standard representation; for space classes, input bits are computed from the circuit (and possibly recomputed many times) whenever necessary, then discarded. <p> representations via circuits; more precisely, the condition that valid moves are between positions encoded by words of the same length allows for implementing the polynomial time algorithm as a circuit, and therefore the games from [28] correpond to a succinct representation in terms of transition matrices (in the sense of <ref> [6] </ref>) of the GAME problem of [14], and thus it follows from [2] that there are EXPTIME-complete games. Note, however, that in principle these facts do not speak of algorithms such as AO*, which are based on vertex expansions instead of recognizing edges.
Reference: [7] <author> M. R. Garey, D. S. Johnson: </author> <title> Computers and intractability: a guide to the theory of NP-completeness. </title> <publisher> Freeman 1979. </publisher>
Reference-contexts: LSI, Univ. Politecnica de Catalunya, Edif. U, Pau Gargallo 5, 08028 Barcelona, Spain: balqui@lsi.upc.es 1 actually a main source of examples of completeness for various complexity classes (see <ref> [7] </ref>, [9], [11], [12]). However, for optimization algorithms based on informed search methods from AI, some of which follow analogous intuitions, much less seems to be known. <p> This circuit is the input to a search algorithm based on node expansions. The output wanted is given, in general, by an optimality condition, but a (somewhat artificial) decisional problem can be associated to it in a standard way <ref> [7] </ref>; and the optimization problem is no easier (and possibly harder) than the decisional problem. In this case, the decisional problem is exactly (the weighted version of) sGAP, since the solution is a path and the input is a circuit describing the vertex expansion procedure 9 to construct the graph.
Reference: [8] <author> B. L. Golden, W. R. Stewart: </author> <title> Empirical analysis of heuristics. In: The Traveling Salesman Problem: A Guided Tour of Combinatorial Optimization, </title> <editor> E. L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, D. B. Shmoys (eds.), </editor> <publisher> John Wiley and Sons 1985. </publisher>
Reference-contexts: All these classes contain relevant, practical problems, and sometimes they turn out to be complete for the class. For instance, a large number of heuristic algorithms for the Traveling Salesman Problem consider tours or partial tours and "move" from one to another. Indeed, in <ref> [8] </ref> a number of heuristics for TSP are classified as "tour construction", where exploration "moves" among progressively more complete partial tours, or "tour improvement", where one tour is changed into another searching for better payoffs; mixed strategies are also considered.
Reference: [9] <author> R. Greenlaw, H. J. Hoover, W. L. Ruzzo: </author> <title> A compendium of problems complete for P. </title> <publisher> Oxford Univ. Press 1994, in press. </publisher>
Reference-contexts: LSI, Univ. Politecnica de Catalunya, Edif. U, Pau Gargallo 5, 08028 Barcelona, Spain: balqui@lsi.upc.es 1 actually a main source of examples of completeness for various complexity classes (see [7], <ref> [9] </ref>, [11], [12]). However, for optimization algorithms based on informed search methods from AI, some of which follow analogous intuitions, much less seems to be known.
Reference: [10] <author> J.-W. Hong: </author> <title> "On some deterministic space complexity problems". </title> <journal> SIAM Journal on Computing 11 (1982), </journal> <pages> 591-601. </pages>
Reference-contexts: Schemes which allow considerable savings include hierarchical representations and boolean computational models ([6], [18], [29]). The same idea can be applied to other data types via integer expressions [29] or vector languages [16], and an essentially analogous intuition (with a very different technical development) was used in <ref> [10] </ref> to obtain complete problems for deterministic linear space. We will use here a variant of the boolean circuit representation.
Reference: [11] <author> D. S. Johnson: </author> <title> A catalog of complexity classes. In: Handbook of Theoretical Computer Science, vol. A: Algorithms and Complexity, </title> <editor> J. van Leeuwen (ed.), </editor> <publisher> Elsevier 1990, </publisher> <pages> 67-161. </pages>
Reference-contexts: LSI, Univ. Politecnica de Catalunya, Edif. U, Pau Gargallo 5, 08028 Barcelona, Spain: balqui@lsi.upc.es 1 actually a main source of examples of completeness for various complexity classes (see [7], [9], <ref> [11] </ref>, [12]). However, for optimization algorithms based on informed search methods from AI, some of which follow analogous intuitions, much less seems to be known.
Reference: [12] <author> D. S. Johnson, C. H. Papadimitriou, M. Yannakakis: </author> <title> "How easy is local search?". </title> <journal> Journal of Computer and System Sciences 37 (1988), </journal> <pages> 79-100. </pages>
Reference-contexts: LSI, Univ. Politecnica de Catalunya, Edif. U, Pau Gargallo 5, 08028 Barcelona, Spain: balqui@lsi.upc.es 1 actually a main source of examples of completeness for various complexity classes (see [7], [9], [11], <ref> [12] </ref>). However, for optimization algorithms based on informed search methods from AI, some of which follow analogous intuitions, much less seems to be known. <p> But there is a different context in which a similar consideration has been made: certain classes 13 of total multivalued nondeterministically computable functions. These include PLS <ref> [12] </ref> and functions related to parity arguments [22]. All these classes contain relevant, practical problems, and sometimes they turn out to be complete for the class. For instance, a large number of heuristic algorithms for the Traveling Salesman Problem consider tours or partial tours and "move" from one to another. <p> This can be seen as the search for a path in the exponentially large graph defined by the neighborhood structure of the local search scheme; indeed, accordingly, for hard enough local search schemes this problem is PSPACE-hard <ref> [12] </ref>, [20]. However, other functional versions in which any local optimum suffices as output lie probably lower: in PLS [12]. The approach used here is, thus, consistent with the known results, and might be informative as of properties of these local search classes and problems. <p> search for a path in the exponentially large graph defined by the neighborhood structure of the local search scheme; indeed, accordingly, for hard enough local search schemes this problem is PSPACE-hard <ref> [12] </ref>, [20]. However, other functional versions in which any local optimum suffices as output lie probably lower: in PLS [12]. The approach used here is, thus, consistent with the known results, and might be informative as of properties of these local search classes and problems. Similar considerations can be made with respect to the classes introduced in [22] based on "parity" or on "pigeonhole" arguments (PPA, PPAD, and PPP).
Reference: [13] <author> N. D. Jones: </author> <title> "Space-bounded reducibility among combinatorial problems". </title> <journal> Journal of Computer and System Sciences 11 (1975), </journal> <pages> 68-75. </pages>
Reference-contexts: Theorem. sGAP is PSPACE-complete. The following lemma is needed for the proof: 5. Lemma. GAP is hard for LOGSPACE under PL-covered polylog-time m-reductions. Actually, GAP is complete in the larger class corresponding to nondeterministic logarithmic space under logarithmic space reducibility <ref> [13] </ref>, [27]. The proof of the lemma is obtained by an analysis of the completeness proofs in these references, checking that the necessary computations can be performed in polylog time on indexing machines; we simply sketch it here.
Reference: [14] <author> N. D. Jones, W. T. Laaser: </author> <title> "Complete problems for deterministic polynomial time". </title> <booktitle> Theoretical Computer Science 3 (1977), </booktitle> <pages> 105-117. </pages>
Reference-contexts: The problem GAME is proved P-complete ** The reason is that, without loss of generality, one can assume that through each path AND (universal) vertices and OR (existential) vertices alternate. The problem is often modeled equivalently with hypergraphs [26]. 12 in <ref> [14] </ref>, under logspace reducibility. That problem is simply a rephrasing of AGAP in terms of players, where there are two sets of positions (the existential and universal vertices respectively), a starting position (source), a set of winning positions (goals), and a set of allowable moves (edges). <p> The problem is to find out whether the starting position is winning for the first player (who plays on existential vertices). This is equivalent to finding out whether a solution subgraph exists. The proof of P-completeness in <ref> [14] </ref> relies on a general reduction (through an intermediate problem) that is easily seen to be computable in polylog time on indexing machines, and PL-coverable, by the same argument as for GAP. <p> condition that valid moves are between positions encoded by words of the same length allows for implementing the polynomial time algorithm as a circuit, and therefore the games from [28] correpond to a succinct representation in terms of transition matrices (in the sense of [6]) of the GAME problem of <ref> [14] </ref>, and thus it follows from [2] that there are EXPTIME-complete games. Note, however, that in principle these facts do not speak of algorithms such as AO*, which are based on vertex expansions instead of recognizing edges.
Reference: [15] <author> N. D. Jones, Y. E. Lien, W. T. Laaser: </author> <title> "New problems complete for nondeterministic log space". Math. </title> <booktitle> Systems Theory 10 (1976), </booktitle> <pages> 1-17. </pages>
Reference-contexts: A technical condition on the reductions (coverability) was necessary. It is interesting to note that several other reductions between (seemingly noncomplete) problems in nondeterministic LOGSPACE are not PL-coverable under our definition <ref> [15] </ref>; however, they become so under a somewhat more involved notion of coverability which takes into account the outdegree of the input graph. <p> We have refrained from following this more general path since the simpler definition was sufficient for our purposes, but a theory of coverable reductions (which could conceivably have other interesting applications) should be based in a more general form, capturing as many existing reductions as possible ([4], <ref> [15] </ref>).
Reference: [16] <author> M. Kowaluk, K. W. Wagner: </author> <title> "Vector language: simple description of hard instances". </title> <booktitle> In: Proc. Math. Foundations of Computer Science, Lecture Notes in Computer Science 452, </booktitle> <publisher> Springer-Verlag 1990, </publisher> <pages> 378-384. </pages>
Reference-contexts: Schemes which allow considerable savings include hierarchical representations and boolean computational models ([6], [18], [29]). The same idea can be applied to other data types via integer expressions [29] or vector languages <ref> [16] </ref>, and an essentially analogous intuition (with a very different technical development) was used in [10] to obtain complete problems for deterministic linear space. We will use here a variant of the boolean circuit representation.
Reference: [17] <author> S. Kundu: </author> <title> "A new variant of the A* algorithm which closes a node at most once". </title> <journal> Annals of Math. and Artificial Intelligence 4 (1991), </journal> <pages> 157-176. </pages>
Reference-contexts: Most of them are currently available, precompiled in libraries, ready to use very easily, as executable subroutines of C++ programs [19]. Variants of A* can be seen as a refinements of Dijkstra's algorithm through the use of so-called "admissible" heuristic information (see the discussion in <ref> [17] </ref>). But from the complexity-theoretic approach, one would consider that the input to the algorithm is the whole graph, and this would be already unacceptable to practitioners: in most practical cases, the search graph is huge enough that even linear time on its size is infeasible by far.
Reference: [18] <author> T. Lengauer, K. W. Wagner: </author> <title> "The correlation between the complexities of the nonhierarchical and hierarchical versions of graph problems". </title> <journal> Journal of Computer and System Sciences 44 (1992), </journal> <pages> 63-93. 15 </pages>
Reference-contexts: Schemes which allow considerable savings include hierarchical representations and boolean computational models ([6], <ref> [18] </ref>, [29]). The same idea can be applied to other data types via integer expressions [29] or vector languages [16], and an essentially analogous intuition (with a very different technical development) was used in [10] to obtain complete problems for deterministic linear space.
Reference: [19] <author> K. Mehlhorn, S. Naher: "LEDA: </author> <title> a platform for combinatorial and geometric comput-ing". </title> <journal> Communications of the ACM 38, </journal> <volume> 1 (1995), </volume> <pages> 96-102. </pages>
Reference-contexts: Actually, starting from Dijkstra's algorithm, and continuing with many other applications of algorithm design techniques, polynomial time algorithms solving that sort of problems exist, offering good practical performance. Most of them are currently available, precompiled in libraries, ready to use very easily, as executable subroutines of C++ programs <ref> [19] </ref>. Variants of A* can be seen as a refinements of Dijkstra's algorithm through the use of so-called "admissible" heuristic information (see the discussion in [17]).
Reference: [20] <author> C. H. Papadimitriou: </author> <title> "The complexity of the Lin-Kernighan heuristic for the Traveling Salesman Problem". </title> <journal> SIAM Journal on Computing 21 (1992), </journal> <pages> 450-465. </pages>
Reference-contexts: This can be seen as the search for a path in the exponentially large graph defined by the neighborhood structure of the local search scheme; indeed, accordingly, for hard enough local search schemes this problem is PSPACE-hard [12], <ref> [20] </ref>. However, other functional versions in which any local optimum suffices as output lie probably lower: in PLS [12]. The approach used here is, thus, consistent with the known results, and might be informative as of properties of these local search classes and problems.
Reference: [21] <author> C. H. Papadimitriou: </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley 1994. </publisher>
Reference-contexts: Then [24] pointed out that the use of projection reducibility allows one to prove that all known NP-complete problems become NEXP-complete under succinct input representation via circuits (see also Chapter 20 of <ref> [21] </ref>). This observation is extended in [2], by means of logtime reducibility, to a very general result (the Conversion Lemma) relating the complexity of problems on standard input convention to their respective succinct versions, independently of the complexity classes in which they lie. <p> We will see that this approach gives more informative characterizations of the hardness of 4 graph search problems. 2. Preliminaries Most of our notions of Complexity Theory regarding models of computation, complexity classes, and reducibilities, are standard ([1], <ref> [21] </ref>). We assume decisional problems to be encoded as sets of strings over the standard binary alphabet. Likewise, functional problems are encoded as partial functions from strings to strings.
Reference: [22] <author> C. H. Papadimitriou: </author> <title> "On the complexity of the parity argument and other inefficient proofs of existence". </title> <journal> Journal of Computer and System Sciences 48 (1994), </journal> <pages> 498-532. </pages>
Reference-contexts: But there is a different context in which a similar consideration has been made: certain classes 13 of total multivalued nondeterministically computable functions. These include PLS [12] and functions related to parity arguments <ref> [22] </ref>. All these classes contain relevant, practical problems, and sometimes they turn out to be complete for the class. For instance, a large number of heuristic algorithms for the Traveling Salesman Problem consider tours or partial tours and "move" from one to another. <p> The approach used here is, thus, consistent with the known results, and might be informative as of properties of these local search classes and problems. Similar considerations can be made with respect to the classes introduced in <ref> [22] </ref> based on "parity" or on "pigeonhole" arguments (PPA, PPAD, and PPP).
Reference: [23] <author> C. H. Papadimitriou, K. Steiglitz: </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice-Hall 1982. </publisher>
Reference-contexts: In this context, the input graph is nothing but a succinct representation of the graph of all its (partial) tours. Local search algorithms (such as those using the Lin-Kernighan-type heuristics <ref> [23] </ref>) are actually searching this large, succinctly represented graph. The problem to be solved (finding a vertex, i.e. a tour, below a given cost) lies in nondeterministic polylogarithmic time, and accordingly the succinct representation, TSP, is NP-complete in the decisional version.
Reference: [24] <author> C. H. Papadimitriou, M. Yannakakis: </author> <title> "A note on succinct representations of graphs". </title> <booktitle> Information and Control 71 (1986), </booktitle> <pages> 181-185. </pages>
Reference-contexts: This paper suggests the use of "succinct representations" to bridge this gap. This consists of encoding the input to combinatorial algorithms by means of "programs" in some specific (most frequently, boolean) model. Encoding the input via circuits was labeled as "a natural, if not practical, representation" in <ref> [24] </ref> (page 181). We will develop in this paper a close relative of this input encoding that is arguably practical, in that it captures the essence of the widely implemented AI approach to graph searching. Let's explain why. <p> For this model, [6] and [29] classify as complete in some class of the polynomial time hierarchy or the counting hierarchy (or higher up) many specific problems on succinct instances; many of these are polynomially solvable for standard input representation. Then <ref> [24] </ref> pointed out that the use of projection reducibility allows one to prove that all known NP-complete problems become NEXP-complete under succinct input representation via circuits (see also Chapter 20 of [21]).
Reference: [25] <author> J. Pearl: </author> <title> Heuristics: Intelligent Search Strategies for Computer Problem Solving. </title> <publisher> Addison-Wesley 1984. </publisher>
Reference-contexts: A common characteristic of several such algorithms, including the well-known A* and AO* algorithms employed in the Artificial Intelligence area (see e.g. <ref> [25] </ref>, [26]), is that the use of heuristic information, gained from study of the specific problem at hand, frequently allows for a dramatic cutdown of computer time needed to solve many a specific instance; but, on the other hand, little or no guarantee of fast performance can be given a priori <p> It is a task for complexity theory (which we address here) to find a framework to analyze these problems in a more satisfactory way, taking into account the astonishing sizes of the searched graphs. There are several results on the formal analysis of the complexity of these algorithms; see <ref> [25] </ref> (in particular, chapters 5 and 6). <p> We want to supplement the view obtained from the probabilistic average analysis, which is of course very useful but depends on several simplifying assumptions and on the hypothesis of some specific probability distribution <ref> [25] </ref>; we will see how to model these algorithms in such a way that the standard complexity classes give informative properties of (the problems solved by) these algorithms, in as much generality as possible, and in terms of worst-case complexity. <p> The obvious weighted variant is also useful. Again, algorithms (like AO*) exist for this problem, and various relevant algorithms are specifically tailored to games, in which the minimax principle is applied. Let us mention only alpha-beta pruning and SSS* <ref> [25] </ref>. The complexity of searching AND/OR graphs can be assessed from the abundant studies on the complexity of games. In particular, in [28] a number of games are proved to be EXPTIME-complete.
Reference: [26] <author> E. Rich, K. Knight: </author> <booktitle> Artificial Intelligence. McGraw-Hill 1991 (2nd edition). </booktitle>
Reference-contexts: A common characteristic of several such algorithms, including the well-known A* and AO* algorithms employed in the Artificial Intelligence area (see e.g. [25], <ref> [26] </ref>), is that the use of heuristic information, gained from study of the specific problem at hand, frequently allows for a dramatic cutdown of computer time needed to solve many a specific instance; but, on the other hand, little or no guarantee of fast performance can be given a priori (otherwise <p> The problem GAME is proved P-complete ** The reason is that, without loss of generality, one can assume that through each path AND (universal) vertices and OR (existential) vertices alternate. The problem is often modeled equivalently with hypergraphs <ref> [26] </ref>. 12 in [14], under logspace reducibility. That problem is simply a rephrasing of AGAP in terms of players, where there are two sets of positions (the existential and universal vertices respectively), a starting position (source), a set of winning positions (goals), and a set of allowable moves (edges).
Reference: [27] <author> W. J. Savitch: </author> <title> "Relations between nondeterministic and deterministic tape complexities". </title> <journal> Journal of Computer and System Sciences 4 (1970), </journal> <pages> 177-192. </pages>
Reference-contexts: Theorem. sGAP is PSPACE-complete. The following lemma is needed for the proof: 5. Lemma. GAP is hard for LOGSPACE under PL-covered polylog-time m-reductions. Actually, GAP is complete in the larger class corresponding to nondeterministic logarithmic space under logarithmic space reducibility [13], <ref> [27] </ref>. The proof of the lemma is obtained by an analysis of the completeness proofs in these references, checking that the necessary computations can be performed in polylog time on indexing machines; we simply sketch it here.
Reference: [28] <author> L. J. Stockmeyer, A. K. Chandra: </author> <title> "Provably difficult combinatorial games". </title> <journal> SIAM Journal on Computing 8 (1979), </journal> <pages> 151-174. </pages>
Reference-contexts: Some information about problems on AND/OR graphs is readily obtained from the rich body of literature about the complexity-theoretic approach to games via alternation (let us mention in particular <ref> [28] </ref>). But for simpler search problems, all the complexity-theoretic analyses known to this author are based on concepts, tools, and conventions essentially different from those of Structural Complexity. This paper suggests the use of "succinct representations" to bridge this gap. <p> Let us mention only alpha-beta pruning and SSS* [25]. The complexity of searching AND/OR graphs can be assessed from the abundant studies on the complexity of games. In particular, in <ref> [28] </ref> a number of games are proved to be EXPTIME-complete. In that reference, a game is defined as given by the set of positions (encoded as words of a given length, and split into existential and universal) and a polynomial time algorithm to check validity of a move. <p> There is a condition that "the board cannot be enlarged during the play", i.e. that valid moves are between positions encoded by words of the same length. Succinct representations as defined here (i.e. easy enough expansion algorithms) do not necessarily exist for the games from <ref> [28] </ref>, and for some of them the (high) degree of each vertex makes them impossible. But, actually, careful examination proves that for some of the EXPTIME-complete games from [28], polynomial time expansion algorithms (i.e. succinct representations as defined here) do exist. <p> Succinct representations as defined here (i.e. easy enough expansion algorithms) do not necessarily exist for the games from <ref> [28] </ref>, and for some of them the (high) degree of each vertex makes them impossible. But, actually, careful examination proves that for some of the EXPTIME-complete games from [28], polynomial time expansion algorithms (i.e. succinct representations as defined here) do exist. In particular, the "game" on propositional formulas labeled G 2 in that paper has easy expansion algorithms, is EXPTIME-complete, and reduces to sAGAP (i.e. can be solved by AO*). <p> Thus, we can refine the notion of reducibility (to the polylog time PL-covered case) for the P-completeness of GAME, and immediately we get EXPTIME-completeness of its succinct version, sAGAP, from our theorem 1. Note that in the definition of "game" in <ref> [28] </ref>, it is assumed that the only knowledge readily available about the game is a polynomial time test for legitimacy of a move, corresponding closely to the previously used notion of succinct representations via circuits; more precisely, the condition that valid moves are between positions encoded by words of the same <p> test for legitimacy of a move, corresponding closely to the previously used notion of succinct representations via circuits; more precisely, the condition that valid moves are between positions encoded by words of the same length allows for implementing the polynomial time algorithm as a circuit, and therefore the games from <ref> [28] </ref> correpond to a succinct representation in terms of transition matrices (in the sense of [6]) of the GAME problem of [14], and thus it follows from [2] that there are EXPTIME-complete games.
Reference: [29] <author> K. W. Wagner: </author> <title> "The complexity of combinatorial problems with succinct input representation". </title> <journal> Acta Informatica 23 (1986), </journal> <pages> 325-356. 16 </pages>
Reference-contexts: Let us set this idea in the perspective of previous research on succinct input representation. Problems on succinct representations The study of algorithmic graph problems on succinct representations was introduced independently in [6] and <ref> [29] </ref>, and has been proven useful in other applications of Complexity Theory. <p> Schemes which allow considerable savings include hierarchical representations and boolean computational models ([6], [18], <ref> [29] </ref>). The same idea can be applied to other data types via integer expressions [29] or vector languages [16], and an essentially analogous intuition (with a very different technical development) was used in [10] to obtain complete problems for deterministic linear space. <p> Schemes which allow considerable savings include hierarchical representations and boolean computational models ([6], [18], <ref> [29] </ref>). The same idea can be applied to other data types via integer expressions [29] or vector languages [16], and an essentially analogous intuition (with a very different technical development) was used in [10] to obtain complete problems for deterministic linear space. We will use here a variant of the boolean circuit representation. <p> So, a careful and detailed analysis of each input convention is necessary. In the case of decisional problems on graphs, the input is not the graph itself but (the encoding of) a boolean circuit which computes its transition matrix. For this model, [6] and <ref> [29] </ref> classify as complete in some class of the polynomial time hierarchy or the counting hierarchy (or higher up) many specific problems on succinct instances; many of these are polynomially solvable for standard input representation.
References-found: 29

