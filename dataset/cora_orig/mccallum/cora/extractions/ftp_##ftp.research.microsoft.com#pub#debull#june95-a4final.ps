URL: ftp://ftp.research.microsoft.com/pub/debull/june95-a4final.ps
Refering-URL: http://www.research.microsoft.com/research/db/debull/issues-list.htm
Root-URL: http://www.research.microsoft.com
Title: Special Issue on Materialized Views and Data Warehousing Maintenance of Materialized Views: Problems, Techniques, and
Author: .Ashish Gupta, Inderpal Singh Mumick Nick Roussopoulos, Chungmin M. Chen, Stephen Kelley, Alex Delis, Yannis Papakonstantinou Gang Zhou, Richard Hull, Roger King, Jean-Claude Franchitti Joachim Hammer, Hector Garcia-Molina, Jennifer Widom, Wilburt Labio, Yue Zhuge 
Affiliation: The Stanford  
Note: Bulletin of the Technical Committee on Data Engineering June, 1995 Vol. 18 No. 2 IEEE Computer Society Letters Letter from the Editor-in-Chief. .David Lomet 1 Letter from the Special Issue Editor. .Jennifer Widom 2  The Maryland ADMS Project: Views R Us.  Conference and Journal Notices 1996 ACM SIGMOD Conference on the Management of Data back cover  
Abstract-found: 0
Intro-found: 1
Reference: [BB82] <author> P. A. Bernstein and B. T. Blaustein. </author> <title> Fast Methods for Testing Quantified Relational Calculus Assertions. </title> <booktitle> In SIGMOD 1982, </booktitle> <pages> pages 39-50. </pages>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BBC80] <author> P. A. Bernstein, B. T. Blaustein, and E. M. Clarke. </author> <title> Fast Maintenance of Semantic Integrity Assertions Using Redundant Aggregate Data. </title> <booktitle> In 6th VLDB, </booktitle> <year> 1980, </year> <pages> pages 126-136. </pages>
Reference: [BC79] <author> Peter O. Buneman and Eric K. Clemons. </author> <title> Efficiently Monitoring Relational Databases. </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> Vol 4, No. 3, </volume> <year> 1979, </year> <pages> 368-382. </pages>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BCL89] <author> J. A. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating Derived Relations: Detecting Irrelevant and Autonomously Computable Updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog. <p> The idea of self-maintenance is not new | Autonomously computable views were defined by <ref> [BCL89] </ref> as the views that can be maintained using only the materialized view for all database instances, but for a given modification instance . They characterize a subset of SPJ views that are autonomously computable for insertions, deletions, and updates, where the deletions and updates are specified using conditions. <p> They do not consider views with self-joins or outer-joins, do not use key information, and they do not consider self-maintenance with respect to all instances of modifications. The characterization of autonomously computable views in <ref> [BCL89] </ref> for updates is inaccurate | For instance, [BCL89] determines, incorrectly, that the view "select X from r (X)" is not autonomously computable for the modification "Update (R (3) to R (4))". <p> They do not consider views with self-joins or outer-joins, do not use key information, and they do not consider self-maintenance with respect to all instances of modifications. The characterization of autonomously computable views in <ref> [BCL89] </ref> for updates is inaccurate | For instance, [BCL89] determines, incorrectly, that the view "select X from r (X)" is not autonomously computable for the modification "Update (R (3) to R (4))". Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in [BT88].
Reference: [BLT86] <author> J. A. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In SIGMOD 1986. </booktitle>
Reference-contexts: Other Counting Algorithms: [SI84] maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . <ref> [BLT86] </ref> use counts just like the counting algorithm, but only to maintain SPJ views. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog.
Reference: [BMM92] <author> F. Bry, R. Manthey, and B. Martens. </author> <title> Integrity Verification in Knowledge Bases. </title> <booktitle> In Logic Programming, LNAI 592, </booktitle> <pages> pages 114-139, </pages> <year> 1992. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BST + 93] <author> R. J. Brachman, et al.. </author> <title> Integrated support for data archaeology. </title> <journal> In International Journal of Intelligent and Cooperative Information Systems, </journal> <volume> 2 </volume> <pages> 159-185, </pages> <year> 1993. </year>
Reference-contexts: Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in [WS93], where they are called dynamic queries. Data 14 archaeology <ref> [BST + 93] </ref> is a similar application where an archaeologist discovers rules about data by formulating queries, examining the results, and then changing the query iteratively as his/her understanding improves.
Reference: [BT88] <author> J. A. Blakeley and F. W. Tompa. </author> <title> Maintaining Materialized Views without Accessing Base Data. </title> <booktitle> In Information Systems, </booktitle> <volume> 13(4) </volume> <pages> 393-406, </pages> <year> 1988. </year> <month> 16 </month>
Reference-contexts: Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in <ref> [BT88] </ref>. Subsequently this algorithm has been corrected and extended in [GB95]. 4.3 Using Materialized View and Some Base Relations: Partial-reference The partial-reference maintenance problem is to maintain a view given only a subset of the base relations and the materialized view.
Reference: [CKPS95] <author> S. Chaudhuri, R. Krishnamurthy, S. Potamianos, K. Shim. </author> <title> Query Optimization in the presence of Materialized Views. </title> <booktitle> In 11th IEEE Intl. Conference on Data Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <booktitle> In VLDB 1990. </booktitle>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In VLDB 1991. </booktitle>
Reference-contexts: They derive two expressions for each view; one to compute the insertions into the view, and another to compute the deletions into the view. 8 The Ceri-Widom algorithm <ref> [CW91] </ref>: derives production rules to maintain selected SQL views - those without duplicates, aggregation, and negation, and those where the view attributes functionally determine the key of the base relation that is updated. <p> or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. <ref> [CW91] </ref> considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system
Reference: [DJLS95] <author> S. Dar, H.V. Jagadish, A. Y. Levy, and D. Srivastava. </author> <title> Answering SQL queries with aggregation using views. </title> <type> Technical report, </type> <institution> AT&T, </institution> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [DLW95] <author> G. Dong, L. Libkin and L. Wong. </author> <title> On Impossibility of Decremental Recomputation of Recursive Queries in Relational Calculus and SQL. </title> <booktitle> In Proc. of the Intl. Wksp. on DB Prog. </booktitle> <address> Lang, </address> <year> 1995. </year>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph <ref> [DLW95] </ref>. Nontraditional Views [LMSS95a] extends the DRed algorithm to views that can have nonground tuples. [WDSY91] give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple.
Reference: [DS93] <author> G. Dong and J. Su. </author> <title> Incremental and Decremental Evaluation of Transitive Closure by First-Order Queries. </title> <booktitle> In Proceedings of the 16th Australian Computer Science Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. Transitive Closures [DT92] derive nonrecursive programs to update right-linear recursive views in response to insertions into the base relation. <ref> [DS93] </ref> give nonrecursive programs to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs.
Reference: [DT92] <author> G. Dong and R. Topor. </author> <title> Incremental Evaluation of Datalog Queries. </title> <booktitle> In ICDT, </booktitle> <year> 1992. </year>
Reference-contexts: The BDGEN system [NY83] uses counts to reflect not all derivations but only certain types of derivations. Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. Transitive Closures <ref> [DT92] </ref> derive nonrecursive programs to update right-linear recursive views in response to insertions into the base relation. [DS93] give nonrecursive programs to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs.
Reference: [Elk90] <author> C. Elkan. </author> <title> Independence of Logic Database Queries and Updates. </title> <booktitle> In 9th PODS, </booktitle> <pages> pages 154-160, </pages> <year> 1990. </year>
Reference-contexts: that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. [BLT86, BCL89] determine irrelevant updates for SPJ views while <ref> [Elk90] </ref> considers irrelevant updates for Datalog. Further, [LS93] can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in [GJM94].
Reference: [GHJ94] <author> S. Ghandeharizadeh, R. Hull, and D Jacobs. Heraclitus[Alg,C]: </author> <title> Elevating Deltas to be First-Class Citizens in a Database Programming Language. </title> <type> Tech. Rep. </type> # <institution> USC-CS-94-581, USC, </institution> <year> 1994. </year>
Reference-contexts: or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. <ref> [GHJ94] </ref> does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a multi-database environment.
Reference: [GB95] <author> A. Gupta and J. A. Blakeley. </author> <title> Maintaining Views using Materialized Views . Unpublished document. </title>
Reference-contexts: Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in [BT88]. Subsequently this algorithm has been corrected and extended in <ref> [GB95] </ref>. 4.3 Using Materialized View and Some Base Relations: Partial-reference The partial-reference maintenance problem is to maintain a view given only a subset of the base relations and the materialized view. <p> Thus, the view is change-reference-maintainable. A similar claim holds for deletions from part but not for insertions into either relation. Instance Specific Partial-reference Maintenance <ref> [GB95, Gup94] </ref> give algorithms that successfully maintain a view for some instances of the database and modification, but not for others.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan and D. Quass. </author> <title> Generalized Projections: A Powerful Approach to Aggregation. </title> <booktitle> In VLDB, </booktitle> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [GJM94] <author> A. Gupta, H. V. Jagadish, and I. S. Mumick. </author> <title> Data integration using self-maintainable views. </title> <type> Technical Memorandum 113880-941101-32, </type> <institution> AT&T Bell Laboratories, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> There is no relative ordering between the points on each dimension; they are listed in arbitrary order. Along the language dimension, chronicle algebra [JMS95] refers to languages that operate over ordered sequences that may not be stored in the database (see Section 4.3). Along the modification dimension, group updates <ref> [GJM94] </ref> refers to insertion of several tuples using information derived from a single deleted tuple. We study maintenance techniques for different points in the shown problem space. <p> View maintenance on outer-join views using the materialized view and all base relations has been discussed in <ref> [GJM94] </ref>. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views. <p> View maintenance on outer-join views using the materialized view and all base relations has been discussed in <ref> [GJM94] </ref>. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views. <p> Query (b) handles the modifications to table S similar to the manner in which query (a) handles the modifications to table R, with similar possible side-effects. The algorithm of <ref> [GJM94] </ref> handles these side effects. 3.3 Recursive Views Recursive queries or views often are expressed using rules in Datalog [Ull89], and all the work on maintaining recursive views has been done in the context of Datalog. <p> Further, [LS93] can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 11 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is <p> base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 11 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for <p> and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 11 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database <p> Thus, the view is not self-maintainable with respect to deletions from supp. In fact, the view is not self-maintainable for insertions into either supp or part. Some results from <ref> [GJM94] </ref> are stated after the following definitions. Definition 2: (Distinguished Attribute) An attribute A of a relation R is said to be distinguished in a view V if attribute A appears in the select clause defining view V . <p> Definition 3: (Exposed Attribute) An attribute A of a relation R is said to be exposed in a view V if A is used in a predicate. An attribute that is not exposed is referred to as being non-exposed. Self-Maintainability With Respect to Insertions and Deletions <ref> [GJM94] </ref> shows that most SPJ views are not self-maintainable with respect to insertions, but they are often self-maintainable with respect to deletions and updates. <p> The ability to self-maintain a view depends upon the attributes being updated. In particular, updates to non-exposed attributes are self-maintainable when the key attributes are distinguished. The complete algorithm for self-maintenance of a view in response to updates to non-exposed attributes is described in <ref> [GJM94] </ref> and relies on (a) identifying the tuples in the current view that are potentially affected by the update, and (b) computing the effect of the update on these tuples. <p> Incremental view maintenance techniques can be used to maintain the materialized views in response to these modifications. While the materialized views are available for view maintenance, access to the remote databases may be restricted or expensive. Self-Maintainable views are thus useful to maintain a data warehouse <ref> [GJM94] </ref>. For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in [ZHKF95, GJM94]. <p> For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in <ref> [ZHKF95, GJM94] </ref>. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in [ZHKF95]. <p> Materialized views are used for data integration in [ZHKF95, GJM94]. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in <ref> [GJM94] </ref>, while more general matching conditions are discussed in [ZHKF95]. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration.
Reference: [GKM92] <author> A. Gupta, D. Katiyar, and I. S. Mumick. </author> <title> Counting Solutions to the View Maintenance Problem. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: Updates are modeled directly; however since keys need to be derived for such a modeling, the update model is useful mainly for nonrecursive views. 10 Counting based algorithms can sometimes be used for recursive views. The counting algorithm of <ref> [GKM92] </ref> can be used effectively only if every tuple is guaranteed to have a finite number of derivations 1 , and even then the computation of counts can significantly increase the cost of computation.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Algebraic Differencing: introduced in [Pai84] and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and <ref> [GL95] </ref> extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [GLT95] <author> T. Griffin and L. Libkin and H. Trickey. </author> <title> A correction to "Incremental recomputation of active relational expressions" by Qian and Wiederhold. </title> <note> To appear in IEEE TKDE. </note>
Reference-contexts: Algebraic Differencing: introduced in [Pai84] and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. <ref> [GLT95] </ref> provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [GM93] <author> A. Gupta and I. S. Mumick. </author> <title> Improvements to the PF Algorithm. </title> <type> TR STAN-CS-93-1473, </type> <institution> Stanford. </institution>
Reference-contexts: However, the alternation of the steps after each semi-naive iteration also causes some tuples to be rederived several times. In addition, the PF algorithm ends up fragmenting computation and rederiving changed and deleted tuples again and again. <ref> [GM93] </ref> presents improvements to the PF algorithm that reduce rederivation of facts by using memoing and by exploiting the stratification in the program.
Reference: [GMR95] <author> A. Gupta, I. Singh Mumick, and K. A. Ross. </author> <title> Adapting materialized views after redefinitions. </title> <institution> In Columbia University TR CUCS-010-95, </institution> <month> March </month> <year> 1995. </year> <booktitle> Also in SIGMOD 1995, </booktitle> <pages> pages 211-222. </pages>
Reference-contexts: By materializing a view and incrementally recomputing it as its definition changes, the system keeps such applications interactive. <ref> [GMR95] </ref> studies the "view adaptation problem," i.e., how to incrementally recompute a materialized view in response to changes to the view definition. Mobile Systems: A common query in a personal digital assistant (PDA) is of the form "Which freeway exits are within a 5 mile radius". <p> Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95]. The view adaptation results of <ref> [GMR95] </ref> can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1. Many points on each of the three dimensions remain unconsidered, or even unrepresented.
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, and V. S. Subrahmanian. </author> <title> Maintaining Views Incrementally. </title> <booktitle> In SIGMOD 1993, </booktitle> <pages> pages 157-167. </pages> <note> (Full version in AT&T technical report # 9921214-19-TM.) </note>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) [QW91, HD92]. Alternatively, by differently tagging insertions and deletions they can be handled in one pass as in <ref> [GMS93] </ref>. 3 Using Full Information Most work on view maintenance has assumed that all the base relations and the materialized view are available during the maintenance process, and the focus has been on efficient techniques to maintain views expressed in different languages starting from select-project-join views and moving to relational algebra, <p> the language dimension into those applicable to nonrecursive views, those applicable to outer-join views, and those applicable to recursive views. 3.1 Nonrecursive Views We describe the counting algorithm for view maintenance, and then discuss several other view maintenance techniques that have been proposed in the literature. 7 The counting Algorithm <ref> [GMS93] </ref>: applies to SQL views that may or may not have duplicates, and that may be defined using UNION, negation, and aggregation. The basic idea in the counting algorithm is to keep a count of the number of derivations for each view tuple as extra information in the view. <p> We describe the DRed (Deletion and Rederivation) algorithm for view maintenance, and then discuss several other recursive view maintenance techniques that have been proposed in the literature. 9 The DRed Algorithm <ref> [GMS93] </ref>: applies to Datalog or SQL views, including views defined using recursion, UNION, and stratified negation and aggregation. However, SQL views with duplicate semantics cannot be maintained by this algorithm. The DRed algorithm computes changes to the view relations in three steps. <p> For nonrecursive views, the DRed algorithm always works better than the PF algorithm. The Kuchenhoff algorithm [Kuc91]: derives rules to compute the difference between consecutive database states for a stratified recursive program. The rules generated are similar in spirit to those of <ref> [GMS93] </ref>. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of [GMS93, HD92] is not used. <p> The rules generated are similar in spirit to those of [GMS93]. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of <ref> [GMS93, HD92] </ref> is not used. Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations.
Reference: [GSUW94] <author> A. Gupta, S. Sagiv, J. D. Ullman, and J. Widom. </author> <title> Constraint Checking with Partial Information. </title> <booktitle> In 13th PODS, </booktitle> <year> 1994, </year> <pages> pages 45-55. </pages>
Reference: [Gup94] <author> A. Gupta. </author> <title> Partial Information Based Integrity Constraint Checking. </title> <type> Ph.D. Thesis, </type> <institution> Stanford (CS-TR-95-1534). </institution>
Reference-contexts: Thus, the view is change-reference-maintainable. A similar claim holds for deletions from part but not for insertions into either relation. Instance Specific Partial-reference Maintenance <ref> [GB95, Gup94] </ref> give algorithms that successfully maintain a view for some instances of the database and modification, but not for others.
Reference: [HD92] <author> J. V. Harrison and S. Dietrich. </author> <title> Maintenance of Materialized Views in a Deductive Database: An Update Propagation Approach. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) <ref> [QW91, HD92] </ref>. <p> None of the other algorithms discussed in this section handle the same class of views as the DRed algorithm; the most notable differentiating feature being aggregations. However, some algorithms derive more efficient solutions for special subclasses. The PF (Propagation/Filtration) algorithm <ref> [HD92] </ref>: is very similar to the DRed algorithm, except that it propagates the changes made to the base relations on a relation by relation basis. <p> The rules generated are similar in spirit to those of [GMS93]. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of <ref> [GMS93, HD92] </ref> is not used. Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations.
Reference: [JMS95] <author> H. V. Jagadish, I. S. Mumick, and A. Silberschatz. </author> <title> View maintenance issues in the chronicle data model. </title> <booktitle> In 14th PODS, </booktitle> <pages> pages 113-124, </pages> <year> 1995. </year>
Reference-contexts: Materialized views are useful in new applications such as data warehousing, replication servers, chronicle or data recording systems <ref> [JMS95] </ref>, data visualization, and mobile systems. Integrity constraint checking and query optimization can also benefit from materialized views. What is view maintenance? Just as a cache gets dirty when the data from which it is copied is updated, a materialized view gets dirty whenever the underlying base relations are modified. <p> The instance dimension is not shown here so as to keep the figure manageable. There is no relative ordering between the points on each dimension; they are listed in arbitrary order. Along the language dimension, chronicle algebra <ref> [JMS95] </ref> refers to languages that operate over ordered sequences that may not be stored in the database (see Section 4.3). Along the modification dimension, group updates [GJM94] refers to insertion of several tuples using information derived from a single deleted tuple. <p> Two interesting subproblems here are when the view and all the relations except the modified relation are available, and when the view and modified relation are available. Modified Relation is not Available (Chronicle Views) A chronicle is an ordered sequence of tuples with insertion being the only permissible modification <ref> [JMS95] </ref>. A view over a chronicle, treating the chronicle as a relation, is called a chronicle view. <p> Techniques to specify and maintain such views efficiently are presented in <ref> [JMS95] </ref>. Only Modified Relation is Available (Change-reference Maintainable) Sometimes a view may be maintainable using only the modified base relation and the view, but without accessing other base relations. Different modifications need to be treated differently. <p> The model needs access to the remote databases during queries and thus differs from a typical warehousing model. Chronicle Systems: Banking, retailing, and billing systems deal with a continuous stream of transactional data. This ordered sequence of transactional tuples has been called a chronicle <ref> [JMS95] </ref>. One characteristic of a chronicle is that it can get very large, and it can be beyond the capacity of any database system to even store, far less access, for answering queries. Materialized views provide a way to answer queries over the chronicle without accessing the chronicle. <p> View maintenance techniques are needed to maintain these summaries as new transactions are added to the chronicle, but without accessing the old entries in the chronicle <ref> [JMS95] </ref>. Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in [WS93], where they are called dynamic queries. <p> The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored. The dynamic complexity classes of [PI94] and the incremental maintenance complexity of <ref> [JMS95] </ref> characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. <p> The complexity of view maintenance also needs to be explored. The dynamic complexity classes of [PI94] and the incremental maintenance complexity of <ref> [JMS95] </ref> characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. Jagadish, Leonid Libkin, Dallan Quass, and Jennifer Widom for their insightful comments on the technical and presentation aspects of this paper.
Reference: [KSS87] <author> R. Kowalski, F. Sadri, and P. Soper. </author> <title> Integrity Checking in Deductive Databases. </title> <booktitle> In VLDB, </booktitle> <year> 1987. </year>
Reference: [Kuc91] <author> V. Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <booktitle> In DOOD, LNCS 566, </booktitle> <year> 1991. </year> <month> 17 </month>
Reference-contexts: For nonrecursive views, the DRed algorithm always works better than the PF algorithm. The Kuchenhoff algorithm <ref> [Kuc91] </ref>: derives rules to compute the difference between consecutive database states for a stratified recursive program. The rules generated are similar in spirit to those of [GMS93].
Reference: [LMSS95a] <author> A. Y. Levy and A. O. Mendelzon and Y. Sagiv and D. Srivastava. </author> <title> Answering Queries Using Views. </title> <booktitle> In PODS 1995, </booktitle> <pages> pages 95-104. </pages>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph [DLW95]. Nontraditional Views <ref> [LMSS95a] </ref> extends the DRed algorithm to views that can have nonground tuples. [WDSY91] give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple. <p> A query optimizer can optimize this query to access a materialized view that stores the number of items sold for each item and store, and avoid access to a much larger sales-transactions table. <ref> [RSU95, LMSS95a] </ref> discuss the problem of answering a conjunctive query (SPJ query) given a set of conjunctive view definitions. Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95].
Reference: [LMSS95b] <author> J. Lu, G. Moerkotte, J. Schu, and V. S. Subrahmanian. </author> <title> Efficient maintenance of materialized mediated views. </title> <booktitle> In SIGMOD 1995, </booktitle> <pages> pages 340-351. </pages>
Reference-contexts: The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. <ref> [LMSS95b] </ref> presents another model of data integration. They consider views defined using some remote and some local relations. They materialize the view partially, without accessing the remote relation, by retaining a reference to the remote relation as a constraint in the view tuples.
Reference: [LS93] <author> A.Y. Levy and Y. Sagiv. </author> <title> Queries Independent of Updates. </title> <booktitle> In 19th VLDB, </booktitle> <pages> pages 171-181, </pages> <year> 1993. </year>
Reference-contexts: that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. [BLT86, BCL89] determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog. Further, <ref> [LS93] </ref> can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in [GJM94].
Reference: [LST87] <author> J.W. Lloyd, E. A. Sonenberg, and R. W. Topor. </author> <title> Integrity Constraint Checking in Stratified Databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 331-343, </pages> <year> 1987. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [MPP + 93] <author> B. Mitschang, H. Pirahesh, P. Pistor, B. Lindsay, and N. Sudkamp. </author> <title> SQL/XNF Processing Composite Objects as Abstractions over Relational Data. </title> <booktitle> In Proc. of 9 th IEEE ICDE, </booktitle> <year> 1993. </year>
Reference-contexts: Recursive Algorithms: The algorithms described in Section 3.3 for recursive views also apply to nonrecursive views. 3.2 Outer-Join Views Outer joins are important in domains like data integration and extended relational systems <ref> [MPP + 93] </ref>. View maintenance on outer-join views using the materialized view and all base relations has been discussed in [GJM94]. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views.
Reference: [MS93] <author> I. S. Mumick and O. Shmueli. </author> <title> Finiteness properties of database queries. </title> <booktitle> In Advances in Database Research: Proc. of the 4 th Australian Database Conference, </booktitle> <pages> pages 274-288, </pages> <year> 1993. </year>
Reference-contexts: The counting algorithm thus works by storing the number of alternative derivations, count (t), of each tuple t in the materialized view. This number is derived from the multiplicity of tuple t under duplicate semantics <ref> [Mum91, MS93] </ref>. Given a program T defining a set of views V 1 ; : : :; V k , the counting algorithm uses the differentiation technique of Section 2 to derive a program T . <p> Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in <ref> [MS93, MS94] </ref>. 11 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database states, the view can be self-maintained in response to all instances
Reference: [MS94] <author> I. S. Mumick and O. Shmueli. </author> <title> Universal Finiteness and Satisfiability. </title> <booktitle> In PODS 1994, </booktitle> <pages> pages 190-200. </pages>
Reference-contexts: Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in <ref> [MS93, MS94] </ref>. 11 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database states, the view can be self-maintained in response to all instances
Reference: [Mum91] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA 94305, USA, </address> <year> 1991. </year>
Reference-contexts: The counting algorithm thus works by storing the number of alternative derivations, count (t), of each tuple t in the materialized view. This number is derived from the multiplicity of tuple t under duplicate semantics <ref> [Mum91, MS93] </ref>. Given a program T defining a set of views V 1 ; : : :; V k , the counting algorithm uses the differentiation technique of Section 2 to derive a program T .
Reference: [Nic82] <author> J. M. Nicolas. </author> <title> Logic for Improving Integrity Checking in Relational Data Bases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [NY83] <author> J. M. Nicolas and Yazdanian. </author> <title> An Outline of BDGEN: A Deductive DBMS. </title> <booktitle> In Information Processing, </booktitle> <pages> pages 705-717, </pages> <year> 1983. </year>
Reference-contexts: The counting algorithm of [GKM92] can be used effectively only if every tuple is guaranteed to have a finite number of derivations 1 , and even then the computation of counts can significantly increase the cost of computation. The BDGEN system <ref> [NY83] </ref> uses counts to reflect not all derivations but only certain types of derivations. Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. <p> or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and <ref> [NY83] </ref> presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a
Reference: [Pai84] <author> R. Paige. </author> <title> Applications of finite differencing to database integrity control and query/transaction optimization. </title> <booktitle> In Advances in Database Theory, </booktitle> <pages> pages 170-209, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Also, they compute insertions and deletions separately, without combining them into a single set with positive and negative counts. [Rou91] describes "ViewCaches," materialized views defined using selections and one join, that store only the TIDs of the tuples that join to produce view tuples. Algebraic Differencing: introduced in <ref> [Pai84] </ref> and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations
Reference: [PI94] <author> S. Patnaik and N. Immerman. </author> <title> Dyn-fo: A parallel, dynamic complexity class. </title> <booktitle> In PODS, </booktitle> <year> 1994. </year>
Reference-contexts: The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored. The dynamic complexity classes of <ref> [PI94] </ref> and the incremental maintenance complexity of [JMS95] characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. <p> The complexity of view maintenance also needs to be explored. The dynamic complexity classes of <ref> [PI94] </ref> and the incremental maintenance complexity of [JMS95] characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. Jagadish, Leonid Libkin, Dallan Quass, and Jennifer Widom for their insightful comments on the technical and presentation aspects of this paper.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental Recomputation of Active Relational Expressions. </title> <journal> In IEEE TKDE, </journal> <volume> 3(1991), </volume> <pages> pages 337-341. </pages>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) <ref> [QW91, HD92] </ref>. <p> Algebraic Differencing: introduced in [Pai84] and used subsequently in <ref> [QW91] </ref> for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference. <p> Algebraic Differencing: introduced in [Pai84] and used subsequently in <ref> [QW91] </ref> for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [RSU95] <author> A. Rajaraman, Y. Sagiv, and J. D. Ullman. </author> <title> Answering queries using templates with binding patterns. </title> <booktitle> In PODS, </booktitle> <year> 1995, </year> <pages> pages 105-112. </pages>
Reference-contexts: A query optimizer can optimize this query to access a materialized view that stores the number of items sold for each item and store, and avoid access to a much larger sales-transactions table. <ref> [RSU95, LMSS95a] </ref> discuss the problem of answering a conjunctive query (SPJ query) given a set of conjunctive view definitions. Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95].
Reference: [RC + 95] <author> N. Roussopoulos, C. Chun, S. Kelley, A. Delis, and Y. Papakonstantinou. </author> <title> The ADMS Project: Views "R" Us. </title> <journal> In IEEE Data Engineering Bulletin, Special Issue on Materialized Views and Data Warehousing, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. <ref> [RC + 95] </ref> describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a multi-database environment. The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored.
Reference: [Rou91] <author> N. Roussopoulos. </author> <title> The Incremental Access Method of View Cache: Concept, Algorithms, and Cost Analysis. </title> <booktitle> In ACM-TODS, </booktitle> <volume> 16(3) </volume> <pages> 535-563, </pages> <year> 1991. </year>
Reference-contexts: Also, they compute insertions and deletions separately, without combining them into a single set with positive and negative counts. <ref> [Rou91] </ref> describes "ViewCaches," materialized views defined using selections and one join, that store only the TIDs of the tuples that join to produce view tuples.
Reference: [SI84] <author> O. Shmueli and A. Itai. </author> <title> Maintenance of Views. </title> <booktitle> In SIGMOD 1984, </booktitle> <pages> pages 240-255. </pages>
Reference-contexts: For SQL views counts can be computed at little or no cost above the cost of evaluating the view for both set and duplicate semantics. The counting algorithm works for both set and duplicate semantics, and can be made to work for outer-join views (Section 3.2). Other Counting Algorithms: <ref> [SI84] </ref> maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . [BLT86] use counts just like the counting algorithm, but only to maintain SPJ views.
Reference: [Ull89] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Vol 2. </volume> <publisher> Computer Science Press. </publisher>
Reference-contexts: Query (b) handles the modifications to table S similar to the manner in which query (a) handles the modifications to table R, with similar possible side-effects. The algorithm of [GJM94] handles these side effects. 3.3 Recursive Views Recursive queries or views often are expressed using rules in Datalog <ref> [Ull89] </ref>, and all the work on maintaining recursive views has been done in the context of Datalog.
Reference: [UO92] <author> T. Urpi and A. Olive. </author> <title> A Method for Change Computation in Deductive Databases. </title> <booktitle> In VLDB 1992. </booktitle>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations. The Urpi-Olive algorithm <ref> [UO92] </ref>: for stratified Datalog views derives transition rules showing how each modification to a relation translates into a modification to each derived relation, using existentially quantified subexpressions in Datalog rules. The quantified subexpressions may go through negation, and can be eliminated under certain conditions.
Reference: [WDSY91] <author> O. Wolfson, H. M. Dewan, S. J. Stolfo, and Y. Yemini. </author> <title> Incremental Evaluation of Rules and its Relationship to Parallelism. </title> <booktitle> In SIGMOD 1991, </booktitle> <pages> pages 78-87. </pages>
Reference-contexts: In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph [DLW95]. Nontraditional Views [LMSS95a] extends the DRed algorithm to views that can have nonground tuples. <ref> [WDSY91] </ref> give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple.
Reference: [WS93] <author> C. Williamson and B. Shneiderman. </author> <title> The Dynamic HomeFinder: evaluating Dynamic Queries in a real- estate information exploration system. In Ben Shneiderman, editor, Sparks of Innovation in Human-Computer Interaction. </title> <publisher> Ablex Publishing Corp, </publisher> <year> 1993. </year>
Reference-contexts: Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in <ref> [WS93] </ref>, where they are called dynamic queries. Data 14 archaeology [BST + 93] is a similar application where an archaeologist discovers rules about data by formulating queries, examining the results, and then changing the query iteratively as his/her understanding improves.
Reference: [ZHKF95] <author> G. Zhou, R. Hull, R. King, J-C. Franchitti. </author> <title> Using Object Matching and Materialization to Integrate Heterogeneous Databases. </title> <booktitle> In Proc. of 3 rd Intl. Conf. on Cooperative Info. Sys., </booktitle> <year> 1995, </year> <pages> pp. 4-18. </pages>
Reference-contexts: For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in <ref> [ZHKF95, GJM94] </ref>. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in [ZHKF95]. <p> Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in <ref> [ZHKF95] </ref>. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration. They consider views defined using some remote and some local relations. <p> Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in <ref> [ZHKF95] </ref>. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration. They consider views defined using some remote and some local relations.

Reference: [BLT86] <author> J.A. Blakeley, P.A. Larson, and F.W. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In Proc. of the 1986 ACM SIGMOD Intern. Conference, </booktitle> <pages> pages 61-71, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Other Counting Algorithms: [SI84] maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . <ref> [BLT86] </ref> use counts just like the counting algorithm, but only to maintain SPJ views. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog.
Reference: [CD85] <author> H. Chou and D. DeWitt. </author> <title> An Evaluation of Buffer Management Strategies for Relational Database Systems. </title> <booktitle> In Procs. of the 11th Intl. Conf. on VLDB, </booktitle> <pages> pages 127-141, </pages> <year> 1985. </year>
Reference: [Chr83] <author> S. Christodoulakis. </author> <title> Estimating Record Selectivities. </title> <journal> Inf. Syst., </journal> <volume> 8(2) </volume> <pages> 105-115, </pages> <year> 1983. </year>
Reference: [CR93] <author> C.M. Chen and N. Roussopoulos. </author> <title> Adaptive Database Buffer Allocation Using Query Feedback. </title> <booktitle> In Procs. of the 19th Intl. Conf. on Very Large Data Bases, </booktitle> <year> 1993. </year>
Reference: [CR94a] <author> C.M. Chen and N. Roussopoulos. </author> <title> Adaptive Selectivity Estimation Using Query Feedback. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1994. </year>
Reference: [CR94b] <author> C.M. Chen and N. Roussopoulos. </author> <title> The implementation and Performance Evaluation of the ADMS Query Optimizer: Integrating Query Result Caching and Matching. </title> <booktitle> In Procs. of the 4th Intl. Conf. on Extending Database Technology, </booktitle> <year> 1994. </year>
Reference: [DR92] <author> A. Delis and N. Roussopoulos. </author> <title> Performance and Scalability of Client-Server Database Architectures. </title> <booktitle> In Proc. of the 19th Int. Conference on Very Large Databases, </booktitle> <address> Vancouver, BC, Canada, </address> <month> August </month> <year> 1992. </year>
Reference: [DR93] <author> A. Delis and N. Roussopoulos. </author> <title> Performance Comparison of Three Modern DBMS Architectures. </title> <journal> IEEE-Transactions on Software Engineering, </journal> <volume> 19(2) </volume> <pages> 120-138, </pages> <month> February </month> <year> 1993. </year>
Reference: [DR94] <author> A. Delis and N. Roussopoulos. </author> <title> Management of Updates in the Enhanced Client-Server DBMS. </title> <booktitle> In Proccedings of the 14th IEEE Int. Conference on Distributed Computing Systems, </booktitle> <address> Poznan, Poland, </address> <month> June </month> <year> 1994. </year>
Reference: [Eco89] <author> N. Economou. </author> <title> Multisite Database Access in ADM S. </title> <type> Master's thesis, </type> <institution> University of Maryland, College Park, MD, 1989. Department of Computer Science. </institution>
Reference: [FCL92] <author> M. Franklin, M. Carey, and M. Livny. </author> <title> Local Global Memory Management in Client-Server DBMS Architectures. </title> <booktitle> In Proc. of the 18th Int. Conference on Very Large Data Bases, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference: [Fin82] <author> S. Finkelstein. </author> <title> Common Expression Analysis in Database Applications. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 235-245, </pages> <year> 1982. </year>
Reference: [FNS91] <author> C. Faloutsos, R. T. Ng, and T. Sellis. </author> <title> Predictive Load Control for Flexible Buffer Allocation. </title> <booktitle> In Procs. of the 17th Intl. Conf. on VLDB, </booktitle> <pages> pages 265-274, </pages> <year> 1991. </year>
Reference: [HOT88] <author> W. Hou, G. Ozsoyoglu, and B. K. Taneja. </author> <title> Statistical Estimators for Relational Algebra Expressions. </title> <booktitle> In Procs. of the ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 276-287, </pages> <year> 1988. </year>
Reference: [HS92] <author> P. Haas and A. Swami. </author> <title> Sequential Sampling Procedures for Query Size Estimation. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 341-350, </pages> <address> San Diego, CA, </address> <year> 1992. </year>
Reference: [Ioa93] <author> Y.E. Ioannidis. </author> <title> Universality of Serial Histograms. </title> <booktitle> In Procs. of the 19th Intl. Conf. on VLDB, </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference: [LN90] <author> R. J. Lipton and J. F. Naughton. </author> <title> Practical Selectivity Estimation through Adaptive Sampling. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 1-11, </pages> <address> Atlantic City, NJ, </address> <year> 1990. </year>
Reference: [LY85] <author> P. A. Larson and H. Z. Yang. </author> <title> Computing Queries from Derived Relations. </title> <booktitle> In Procs. of the 11th Intl. Conf. on VLDB, </booktitle> <pages> pages 259-269, </pages> <year> 1985. </year>
Reference: [MD88] <author> M. Muralikrishma and D. DeWitt. </author> <title> Equi-depth Histograms for Estimating Selectivity Factors for Multi-dimensional Queries. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 28-36, </pages> <address> Chicago, Illinois, </address> <year> 1988. </year>
Reference: [NFS91] <author> R. T. Ng, C. Faloutsos, and T. Sellis. </author> <title> Flexible Buffer Allocation Based on Marginal Gains. </title> <booktitle> In Procs. of 1991 ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 387-396, </pages> <year> 1991. </year>
Reference: [Pap94] <author> Y. Papakonstantinou. </author> <title> Computing a Query as a Union of Disjoint Horizontal Fragments. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Maryland, College Park, MD, </institution> <year> 1994. </year> <note> Working Paper. </note>
Reference: [PSC84] <author> G. Piatetsky-Shapiro and C. Connell. </author> <title> Accurate Estimation of the Number of Tuples Satisfying a Condition. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 256-275, </pages> <address> Boston, MA, </address> <year> 1984. </year>
Reference: [RD91] <author> N. Roussopoulos and A. Delis. </author> <title> Modern Client-Server DBMS Architectures. </title> <journal> ACM-SIGMOD Record, </journal> <volume> 20(3) </volume> <pages> 52-61, </pages> <month> September </month> <year> 1991. </year>
Reference: [RES93] <author> N. Roussopoulos, N. Economou, and A. Stamenas. ADMS: </author> <title> A Testbed for Incremental Access Methods. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 5(5) </volume> <pages> 762-774, </pages> <year> 1993. </year>
Reference: [RH80] <author> D.J. Rosenkrantz and H.B. Hunt. </author> <title> Processing Conjunctive Predicates and Queries. </title> <booktitle> In Procs. of the 6th Intl Conf. on VLDB, </booktitle> <year> 1980. </year>
Reference: [RK86a] <author> N. Roussopoulos and H. Kang. </author> <booktitle> Principles and Techniques in the Design of ADM S. Computer, </booktitle> <month> December </month> <year> 1986. </year>
Reference: [RK86b] <author> N. Roussopoulos and Y. Kang. </author> <title> Preliminary Design of ADMS: A Workstation-Mainf rame Integrated Architecture. </title> <booktitle> In Proc. of the 12th Int. Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference: [RL85] <author> N. Roussopoulos and D. Leifker. </author> <title> Direct Spatial Search on Pictorial Databases Using Packed R-trees. </title> <booktitle> In Procs. of 1985 ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Austin, </address> <year> 1985. </year>
Reference: [Rou82] <author> N. Roussopoulos. </author> <title> The Logical Access Path Schema of a Database. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-8(6):563-573, </volume> <year> 1982. </year>
Reference: [Rou91] <author> N. Roussopoulos. </author> <title> The Incremental Access Method of View Cache: Concept, Algorithms, and Cost Analysis. </title> <journal> ACM-Transactions on Database Systems, </journal> <volume> 16(3) </volume> <pages> 535-563, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Also, they compute insertions and deletions separately, without combining them into a single set with positive and negative counts. <ref> [Rou91] </ref> describes "ViewCaches," materialized views defined using selections and one join, that store only the TIDs of the tuples that join to produce view tuples.
Reference: [S + 89] <author> X. Sun et al. </author> <title> Solving Implication Problems in Database Applications. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 185-192, </pages> <year> 1989. </year>
Reference: [SAC + 79] <author> P. Selinger, M. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Data Base System. </title> <booktitle> In SIGMOD-Conference on the Management of Data, </booktitle> <pages> pages 22-34. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1979. </year>
Reference: [SLRD93] <author> W. Sun, Y. Ling, N. Rishe, and Y. Deng. </author> <title> An Instant and Accurate Size Estimation Method for Joins and Selection in a Retrieval-Intensive Environment. </title> <booktitle> In Procs. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 79-88, </pages> <address> Washington, DC, </address> <year> 1993. </year>

Reference: [AHV95] <author> S. Abiteboul, R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference: [ACHK93] <author> Y. Arens, C.Y. Chee, C.N. Hsu, </author> <title> C.A. Knoblock. Retrieving and integrating data from multiple information sources. </title> <journal> Intl. Journal of Intelligent and Cooperative Information Systems, </journal> <volume> 2(2) </volume> <pages> 127-158, </pages> <year> 1993. </year>
Reference: [BDD + 95] <author> O. Boulcema, J. Dalrymple, M. Doherty, J-C. Franchitti, R. Hull, R. King, and G. Zhou. </author> <title> Incorpo--rating active and multi-database-state services into an OSA-compliant interoperability toolkit. The Collected Arcadia Papers, Second Edition. </title> <institution> University of California at Irvine, </institution> <year> 1995. </year>
Reference: [BLT86] <author> J.A. Blakeley, P.-A. Larson, F.W. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> Proc. ACM SIGMOD Symp. on the Management of Data, </booktitle> <pages> 61-71, </pages> <year> 1986. </year>
Reference-contexts: Other Counting Algorithms: [SI84] maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . <ref> [BLT86] </ref> use counts just like the counting algorithm, but only to maintain SPJ views. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog.
Reference: [Cha94] <author> T.-P. Chang. </author> <title> On Incremental Update Propagation Between Object-Based Databases. </title> <type> PhD thesis, </type> <institution> University of Southern California, </institution> <address> Los Angeles, CA, </address> <year> 1994. </year>
Reference: [CH95] <author> T.-P. Chang and R. Hull. </author> <title> On Witnesses and Witness Generators for Object-Based Databases. </title> <booktitle> Proc. of the ACM Symp. on Principles of Database Systems, </booktitle> <pages> 196-207, </pages> <year> 1995. </year>
Reference: [CW91] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> Proc. of Intl. Conf. on Very Large Data Bases, </booktitle> <pages> 577-589, </pages> <year> 1991. </year>
Reference-contexts: They derive two expressions for each view; one to compute the insertions into the view, and another to compute the deletions into the view. 8 The Ceri-Widom algorithm <ref> [CW91] </ref>: derives production rules to maintain selected SQL views - those without duplicates, aggregation, and negation, and those where the view attributes functionally determine the key of the base relation that is updated. <p> or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. <ref> [CW91] </ref> considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system
Reference: [Dal95] <author> J. Dalrymple. </author> <title> Extending Rule Mechanisms for the Construction of Interoperable Systems. </title> <type> PhD thesis, </type> <institution> University of Colorado, Boulder, </institution> <year> 1995. </year>
Reference: [DH84] <author> U. Dayal and H.Y. Hwang. </author> <title> View definition and generalization for database integration in a multi-database system. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-10(6):628-644, </volume> <year> 1984. </year>
Reference: [DHDD95] <author> M. Doherty, R. Hull, M. Derr, J. Durand. </author> <title> On detecting conflict between proposed updates. To appear, </title> <booktitle> Proc. Intl. Workshop on Database Programming Languages, </booktitle> <address> Italy, </address> <month> September, </month> <year> 1995. </year>
Reference: [DHR95] <author> M. Doherty, R. Hull, M. Rupawalla. </author> <booktitle> The Heraclitus[OO] database programming language, </booktitle> <year> 1995. </year> <note> Technical Report in preparation. </note>
Reference: [EK91] <author> F. Eliassen and R. Karlsen. </author> <title> Interoperability and Object Identity. </title> <booktitle> SIGMOD Record 10(4) </booktitle> <pages> 25-29, </pages> <year> 1991. </year>
Reference: [FK93] <author> J. C. Franchitti and R. King. </author> <title> A Language for Composing Heterogeneous, Persistent Applications. </title> <booktitle> Proc. of the Workshop on Interoperability of Database Systems and Database Applications, Fribourg, </booktitle> <address> Switzerland, </address> <month> October 13-14 </month> <year> 1993. </year> <note> Springer-Verlag, LNCS. </note>
Reference: [FRV95] <author> D. Florescu, L. Raschid, P. Valduriez. </author> <title> Using heterogeneous equivalences for query rewriting in multidatabase systems. </title> <booktitle> Proc. of Third Intl. Conf. on Cooperative Information Systems (CoopIS-95), </booktitle> <address> Vienna, Austria, </address> <month> May </month> <year> 1995. </year>
Reference: [FWW + 93] <author> T. Finin, J. Weber, G. Wiederhold, et al. </author> <title> DRAFT Specification of the KQML Agent-Communication Language. </title> <address> June 15, </address> <year> 1993. </year>
Reference: [GHJ + 93] <author> S. Ghandeharizadeh, R. Hull, D. Jacobs, et. al. </author> <title> On implementing a language for specifying active database execution models. </title> <booktitle> Proc. of Intl. Conf. on Very Large Data Bases, </booktitle> <pages> 441-454, </pages> <year> 1993. </year>
Reference: [GHJ94] <author> S. Ghandeharizadeh, R. Hull, and D. Jacobs. Heraclitus[Alg,C]: </author> <title> Elevating deltas to be first-class citizens in a database programming language. </title> <type> Technical Report USC-CS-94-581, </type> <institution> Computer Science Department, Univ. of Southern California, </institution> <year> 1994. </year>
Reference-contexts: or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. <ref> [GHJ94] </ref> does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a multi-database environment.
Reference: [GMS93] <author> A. Gupta, </author> <title> I.S. Mumick, and V.S. Subrahmanian. Maintaining views incrementally. </title> <booktitle> Proc. ACM SIGMOD Symp. on the Management of Data, </booktitle> <pages> 157-166, </pages> <year> 1993. </year>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) [QW91, HD92]. Alternatively, by differently tagging insertions and deletions they can be handled in one pass as in <ref> [GMS93] </ref>. 3 Using Full Information Most work on view maintenance has assumed that all the base relations and the materialized view are available during the maintenance process, and the focus has been on efficient techniques to maintain views expressed in different languages starting from select-project-join views and moving to relational algebra, <p> the language dimension into those applicable to nonrecursive views, those applicable to outer-join views, and those applicable to recursive views. 3.1 Nonrecursive Views We describe the counting algorithm for view maintenance, and then discuss several other view maintenance techniques that have been proposed in the literature. 7 The counting Algorithm <ref> [GMS93] </ref>: applies to SQL views that may or may not have duplicates, and that may be defined using UNION, negation, and aggregation. The basic idea in the counting algorithm is to keep a count of the number of derivations for each view tuple as extra information in the view. <p> We describe the DRed (Deletion and Rederivation) algorithm for view maintenance, and then discuss several other recursive view maintenance techniques that have been proposed in the literature. 9 The DRed Algorithm <ref> [GMS93] </ref>: applies to Datalog or SQL views, including views defined using recursion, UNION, and stratified negation and aggregation. However, SQL views with duplicate semantics cannot be maintained by this algorithm. The DRed algorithm computes changes to the view relations in three steps. <p> For nonrecursive views, the DRed algorithm always works better than the PF algorithm. The Kuchenhoff algorithm [Kuc91]: derives rules to compute the difference between consecutive database states for a stratified recursive program. The rules generated are similar in spirit to those of <ref> [GMS93] </ref>. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of [GMS93, HD92] is not used. <p> The rules generated are similar in spirit to those of [GMS93]. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of <ref> [GMS93, HD92] </ref> is not used. Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations.
Reference: [HJ91] <author> R. Hull and D. Jacobs. </author> <title> Language constructs for programming active databases. </title> <booktitle> Proc. of Intl. Conf. on Very Large Data Bases, </booktitle> <pages> 455-468, </pages> <year> 1991. </year>
Reference: [IK93] <author> W.H. Inmon and C. Kelley. Rdb/VMS: </author> <title> Developing the Data Warehouse. </title> <publisher> QED Publishing Group, </publisher> <address> Boston, Massachussetts, </address> <year> 1993. </year>
Reference: [KAAK93] <author> W. Kent, R. Ahmed, J. Albert, and M. Ketabchi. </author> <title> Object identification in multidatabase systems. </title> <editor> D. Hsiao, E. Neuhold, and R. Sacks-Davis, editors, </editor> <booktitle> Interoperable Database Systems (DS-5) (A-25). </booktitle> <publisher> Elsevier Science Publishers B. V. (North-Holland), </publisher> <year> 1993. </year>
Reference: [WC95] <author> J. Widom and S. Ceri. </author> <title> Active Database Systems: Triggers and Rules for Advanced Database Processing. </title> <publisher> Morgan-Kaufmann, Inc., </publisher> <address> San Francisco, California, </address> <year> 1995. </year>
Reference: [WHW89] <author> S. Widjojo, R. Hull, and D. Wile. </author> <title> Distributed Information Sharing using WorldBase. </title> <journal> IEEE Office Knowledge Engineering, </journal> <volume> 3(2) </volume> <pages> 17-26, </pages> <month> August </month> <year> 1989. </year> <month> 39 </month>
Reference: [WHW90] <author> S. Widjojo, R. Hull, and D. S. Wile. </author> <title> A specificational approach to merging persistent object bases. </title> <editor> Al Dearle, Gail Shaw, and Stanley Zdonik, editors, </editor> <title> Implementing Persistent Object Bases. </title> <publisher> Morgan Kaufmann, </publisher> <month> December </month> <year> 1990. </year>
Reference: [Wie92] <author> G. Wiederhold. </author> <booktitle> Mediators in the architecture of future information systems. IEEE Computer, </booktitle> <pages> 38-49, </pages> <month> March </month> <year> 1992. </year>
Reference: [ZGHW95] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> Proc. ACM SIGMOD Symp. on the Management of Data, </booktitle> <address> San Jose, California, </address> <month> May </month> <year> 1995. </year>

Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 238-247, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference: [2] <author> T. Addyman. WAIS: </author> <title> Strengths, weaknesses, and opportunities. </title> <booktitle> In Proceedings of Information Networking '93, </booktitle> <address> London, UK, </address> <month> May </month> <year> 1993. </year>
Reference: [3] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In Advances in Database Technology|EDBT '92, Lecture Notes in Computer Science 580, </booktitle> <pages> pages 136-151. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> March </month> <year> 1992. </year>
Reference: [4] <author> N. Cercone, M. Morgenstern, A. Sheth, and W. Litwin. </author> <title> Resolving semantic heterogeneity. </title> <booktitle> In Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> February </month> <year> 1990. </year>
Reference: [5] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 577-589, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference: [6] <author> S. Ceri and J. Widom. </author> <title> Managing semantic heterogeneity with production rules and persistent queues. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference: [7] <author> S. Chakravarthy and D. Lomet, </author> <title> editors. Special Issue on Active Databases, </title> <booktitle> IEEE Data Engineering Bullet in 15(4), </booktitle> <month> December </month> <year> 1992. </year>
Reference: [8] <author> A. Courtney, W. Janssen, D. Severson, M. Spreitzer, and F. Wymore. </author> <note> Inter-language unification, release 1.5. Technical Report ISTL-CSA-94-01-01 (Xerox accession number P94-00058), Xerox PARC, </note> <institution> Palo Alto, </institution> <address> CA, </address> <month> May </month> <year> 1994. </year>
Reference: [9] <author> U. Dayal. </author> <title> Active database management systems. </title> <booktitle> In Proceedings of the Third International Conference on Data and Knowledge Bases, </booktitle> <pages> pages 150-169, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1988. </year>
Reference: [10] <author> U. Dayal and H.-Y. Hwang. </author> <title> View definition and generalization for database integration in a multidatabase system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(6) </volume> <pages> 628-645, </pages> <month> November </month> <year> 1984. </year>
Reference: [11] <author> J. Hammer, D. McLeod, and A. </author> <title> Si. Object discovery and unification in federated database systems. </title> <booktitle> In Proceedings of the Workshop on Interoperability of Database Systems and Database Applications, </booktitle> <pages> pages 3-18, </pages> <institution> Swiss Information Society, Fribourg, Switzerland, </institution> <month> October </month> <year> 1993. </year>
Reference: [12] <author> E.N. Hanson and J. Widom. </author> <title> An overview of production rules in database systems. </title> <journal> The Knowledge Engineering Review, </journal> <volume> 8(2) </volume> <pages> 121-143, </pages> <month> June </month> <year> 1993. </year>
Reference: [13] <author> W.H. Inmon. </author> <title> Building the data bridge: the ten critical success factors of building a data warehouse. </title> <booktitle> Database Programming & Design, </booktitle> <year> 1992. </year>
Reference: [14] <author> W.H. Inmon. </author> <title> EIS and the data warehouse: a simple approach to building an effective foundation for EIS. </title> <booktitle> Database Programming & Design, </booktitle> <volume> 5(11) </volume> <pages> 70-73, </pages> <month> November </month> <year> 1992. </year>
Reference: [15] <author> W.H. Inmon and C. Kelley. Rdb/VMS: </author> <title> Developing the Data Warehouse. </title> <publisher> QED Publishing Group, </publisher> <address> Boston, Massachusetts, </address> <year> 1993. </year>
Reference: [16] <author> W. Litwin, L. Mark, and N. Roussopoulos. </author> <title> Interoperability of multiple autonomous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 267-293, </pages> <month> September </month> <year> 1990. </year>
Reference: [17] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In Proceedings of the Eleventh International Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference: [18] <author> A. Sheth and J. Larson. </author> <title> Federated database systems for managing distributed, heterogeneous, and autonomous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <month> September </month> <year> 1990. </year>
Reference: [19] <author> G. Wiederhold. </author> <title> Mediators in the architecture of future information systems. </title> <journal> IEEE Computer, </journal> <volume> 25(3) </volume> <pages> 38-49, </pages> <month> March </month> <year> 1992. </year>
Reference: [20] <author> G. Wiederhold. </author> <title> Intelligent integration of information. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 434-437, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference: [21] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> San Jose, California, </address> <month> May </month> <year> 1995. </year> <institution> 48 IEEE Computer Society 1730 Massachusetts Ave, </institution> <address> NW Washington, D.C. 20036-1903 Non-profit Org. U.S. Postage PAID Silver Spring, MD Permit 1398 </address>
References-found: 134

