URL: http://www.csl.sri.com/dsa/incremental.ps.gz
Refering-URL: http://www.csl.sri.com/dsa/sadl-main.html
Root-URL: 
Title: CORRECT TRANSFORMATION RULES FOR INCREMENTAL DEVELOPMENT OF ARCHITECTURE HIERARCHIES  
Author: R. A. RIEMENSCHNEIDER 
Abstract: In previous papers, my colleagues and I defined what it means to say that an architecture refinement hierarchy is correct, and showed how to prove correctness of refinement steps. This paper builds upon that earlier work by extending the notion of correctness to apply to architecture transformation rules that can be used to incrementally build hierarchies. Perhaps surprisingly, it is not the case that a rule that adds detail to an architectural description at some level of detail is correct only when the addition of detail always produces a correct refinement of the description. There is, nonetheless, a close relationship between proofs that rules are correct and proofs that certain refinement steps are correct. The possibility of defining general techniques for generating correct incremental transformation rules from a correct refinement pattern is explored. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Broy, </author> <title> Compositional refinement of interactive systems, </title> <note> to appear in the Journal of the ACM. (Available on the Web at &lt;http://www.jacm.org/papers/jacm1061.ps&gt;. An earlier version was published as Digital SRC Research Report 89.) </note>
Reference-contexts: A. RIEMENSCHNEIDER The difficulties of finding modes of refinement composition that preserve correct ness has been noted by other researchers. For example, Broy <ref> [1, pp. 3] </ref> writes Traditionally, compositional notions of specification and refinement are considered hard to obtain. : : : Finding compositional specification methods and compositional interaction concepts [for the class of systems dealt with in this paper] is considered a difficult issue.
Reference: 2. <author> M. Moriconi and X. Quan, </author> <title> Correctness and composition of software architectures, </title> <booktitle> Proceedings of ACM SIGSOFT '94: Symposium on foundations of software engineering, </booktitle> <address> New Orleans, LA, </address> <month> December </month> <year> 1994, </year> <pages> pp. 164-174. </pages> <note> (Also available on the Web at &lt;http://www.csl.sri.com/sadl/fswe94.ps.gz&gt;.) </note>
Reference-contexts: For more detail on interpretations, see my earlier paper [5] on how to prove a mapping is a faithful interpretation. 4 R. A. RIEMENSCHNEIDER CORRECT TRANSFORMATION RULES FOR ARCHITECTURES 5 correctness. It is instructive to see why Moriconi and Qian's attempt to work out the formal details <ref> [2, Section 8] </ref> is unsatisfactory. First, their "definition" of I 1 [ I 2 is incomplete.
Reference: 3. <author> M. Moriconi, X. Quan, and R. A. Riemenschneider, </author> <title> Correct architecture refinement, </title> <journal> IEEE transactions on software engineering, </journal> <volume> vol. 21 (1995), </volume> <pages> pp. 356-372. </pages> <note> (Also available on the Web at &lt;http://www.csl.sri.com/sadl/tse95.ps.gz&gt;.) </note>
Reference-contexts: 1. Introduction In previous papers <ref> [3, 5] </ref>, my colleagues and I defined what it means for a refinement step in an architecture hierarchy 1 to be correct and proved the correctness of a refinement pattern that says a dataflow style architectural description consisting of two procedural components connected by a dataflow channel can be implemented as <p> According to our correctness criterion <ref> [3] </ref>, every architectural description in a hierarchy should tell the whole truth | more precisely, the whole truth expressible at the level of abstraction determined by the style of the description | about the architecture. <p> Composition versus Transformation 2.1. Composition. It is easy to see that the source of the problem is the mixing of dataflow style constructs and shared variable style constructs in D 0 1 . In our previous paper <ref> [3] </ref>, we employed a development methodology that avoided such nonhomogeneous architectural descriptions. The basic idea was that every dataflow channel in a specification would be simultaneously replaced by its implementation. <p> See our earlier paper <ref> [3] </ref> for details. <p> For example, one of our earlier papers <ref> [3, Pattern 3] </ref> contains the following refinement for merging shared variables: an archiectural description that matches the pattern 11 @a0: Procedure [@@p00 -&gt; @@p01] @a1: Procedure [@@p10 -&gt; @@p11] @a2: Procedure [@@p20 -&gt; @@p21] @v1: Variable [@t] @v2: Variable [@t] @c0: ASSERTION = Writes (@a0, @v1) @c1: ASSERTION = Reads (@a1,
Reference: 4. <author> M. Moriconi and R. A. Riemenschneider, </author> <title> Introduction to SADL 1.0, </title> <institution> SRI Computer Science Laboratory Technical Report SRI-CSL-97-01, </institution> <month> March </month> <year> 1997. </year> <note> (Available on the web at URL &lt;http://www.csl.sri.com/sadl/tse95.ps.gz&gt;.) </note>
Reference-contexts: The particular patterns used as illustrations were presented by drawing pictures of them, but these pictures have no precise semantics and so the arguments relied on an informal, intuitive understanding of what they meant. In SADL, the formal architectural description language we have developed <ref> [4] </ref>, refinements can be thought of as having the form An architectural description that matches pattern and satisfies constraints can be refined to a description that matches pattern 0 and satisfies constraints 0 .
Reference: 5. <author> R. A. Riemenschneider, </author> <title> A simplified method for establishing the correctness of architectural refinements, </title> <type> SRI Technical Report SRI-CSL-97-??, </type> ?? <year> 1997. </year> <note> (Also available om the Web at &lt;http://www.csl.sri.com/sadl/simplified.ps.gz&gt;.) </note>
Reference-contexts: 1. Introduction In previous papers <ref> [3, 5] </ref>, my colleagues and I defined what it means for a refinement step in an architecture hierarchy 1 to be correct and proved the correctness of a refinement pattern that says a dataflow style architectural description consisting of two procedural components connected by a dataflow channel can be implemented as <p> For more detail on interpretations, see my earlier paper <ref> [5] </ref> on how to prove a mapping is a faithful interpretation. 4 R. A. RIEMENSCHNEIDER CORRECT TRANSFORMATION RULES FOR ARCHITECTURES 5 correctness. It is instructive to see why Moriconi and Qian's attempt to work out the formal details [2, Section 8] is unsatisfactory. <p> Transformation T 2 modifies an existing refinement step, so saying that it is correct means that the modification preserves correctness of the refinement step. In a previous proof of the correctness of the refinement step in Figure 1 <ref> [5, pp. 7-8] </ref>, the interpretation K determined by the extending the following basis to every sentence of the language of D 0 in the standard way was shown to be a faithful interpretation of the theory of the more abstract dataflow style architectural description D 0 in the theory of the <p> See my earlier paper <ref> [5] </ref> for details. 7 It will turn out that [K ; [1 _K ]] does not correspond to T 1 , and that [[K ; [1 _K ]]# 1] does CORRECT TRANSFORMATION RULES FOR ARCHITECTURES 13 4.3. Second approach: modifying the theories.
Reference: 6. <author> W. M. Turski and T. S. E. Maibaum, </author> <title> The specification of computer programs, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA 94025 E-mail address: rar@csl.sri.com </address>
Reference-contexts: Unfortunately, well-known general results on extensibility of interpretations are not applicable in this case. For example, Turski and Maibaum's "Modularization Theorem" <ref> [6, pp. 174] </ref> says that an interpretation of theory fi in theory can always be extended to an interpretation of any conservative extension fi 0 of fi in a conservative extension of .
References-found: 6

