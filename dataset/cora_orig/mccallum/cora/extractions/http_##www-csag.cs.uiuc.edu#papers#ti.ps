URL: http://www-csag.cs.uiuc.edu/papers/ti.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Title: Incremental Inference of Concrete Types  
Author: John Plevyak Andrew A. Chien 
Abstract: Department of Computer Science 1304 W. Springfield Avenue Urbana, IL 61801 fjplevyak,achieng@cs.uiuc.edu Department of Computer Science, University of Illinois Urbana-Champaign Tech Report UIUCDCS-R-93-1829 Abstract Concrete type information is invaluable for program optimization. The determination of concrete types is, in general, a flow sensitive global data flow problem. As a result, its solution is hampered by the very program structures for whose optimization its results are most critical: dynamic dispatch (as in object-oriented programs) and first class functions (including function pointers). Constraint based type inference systems are an effective way of safely approximating concrete types, but their use can be expensive and their results imprecise. We present an incremental constraint based type inference technique for extending the analysis in response to discovered imprecisions. This technique infers concrete types to high precision with a cost proportional to the information obtained. Performance results, precision and running time, are reported for a number of concurrent object-oriented programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Agensen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of SELF: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP '93, </booktitle> <year> 1993. </year>
Reference-contexts: Constraint-based type inference is described by Palsberg and Schwartzbach in [15, 14]. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see <ref> [1] </ref>). However, the problems with precision and cost inherent in a single pass approach are tackled by exploiting specialized knowledge about SELF [2]. The SELF compiler [5] employs a speculative optimization techniques based on runtime tests.
Reference: [2] <author> Ole Agensen. </author> <type> Personal communication, </type> <year> 1993. </year> <title> 10 The Illinois Concert System including this type inference system is available. Interested parties can contact achien@cs.uiuc.edu for more information. </title> <type> 19 </type>
Reference-contexts: Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]). However, the problems with precision and cost inherent in a single pass approach are tackled by exploiting specialized knowledge about SELF <ref> [2] </ref>. The SELF compiler [5] employs a speculative optimization techniques based on runtime tests. These tests select an optimized code sequence from a small number of such sequences speculatively compiled.
Reference: [3] <author> Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Sort typing with con-ditional types. </title> <booktitle> In Twenty First Symposium on Principles of Programming Languages, </booktitle> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: This and virtually all other optimization of object-oriented languages will benefit from the superior information generated by our improved type inference techniques. The constraint based type system of Aiken, Wimmers, and Lakshman <ref> [3] </ref>, adds conditional types unions and intersections to an ML-style type inference allowing the incorporation of flow sensitive information. Our algorithm also shares some features of the closure analysis and binding time analysis phases used in self-applicative partial evaluators [17].
Reference: [4] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, and Robert van Gent. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proceedings of OOPSLA'93, </booktitle> <pages> pages 29-46, </pages> <year> 1993. </year>
Reference-contexts: While a great deal of progress has been made with respect to the inference of type information <ref> [12, 13, 4] </ref>, these inference techniques compute principle types, not concrete types. Concrete types can be used to support program optimization; while principle types are used primarily for reasoning about the type correctness of programs. <p> Use of the type information is touched on in Section 6. Related work is briefly surveyed in Section 7 and the paper is summarized in Section 8. 2 Background Most type checking and inference techniques <ref> [12, 4] </ref> determine types bottom up, using the types of subexpressions to form the types of expressions and finally the type of the program. At each point, a closed form for the program fragment signature is computed.
Reference: [5] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-60, </pages> <year> 1990. </year>
Reference-contexts: Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]). However, the problems with precision and cost inherent in a single pass approach are tackled by exploiting specialized knowledge about SELF [2]. The SELF compiler <ref> [5] </ref> employs a speculative optimization techniques based on runtime tests. These tests select an optimized code sequence from a small number of such sequences speculatively compiled. If the compiler can narrow the type of an expression to a few concrete types, these techniques can be very effective.
Reference: [6] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Thus, in contrast to the general types of other typing techniques, our goal is to find specific type information. To enable such optimizations, we have implemented a concrete type inference algorithm in the Illinois Concert compiler <ref> [6] </ref>.
Reference: [7] <author> Andrew A. Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: Program examples in the running text will be in a syntax derived from [14]. The target language of our implementation and in which the benchmarks are written is the dynamically typed concurrent object-oriented language Concurrent Aggregates <ref> [7, 8] </ref> which includes first class selectors, messages and continuations. The algorithm is very general and can be applied easily to a wide range of languages. Before we begin, let us clarify some terms. We differentiate two types of polymorphism: data and functional. <p> The Concert system includes a compiler and runtime for concurrent object 7 A constant number of recursive calls can be split at each site without affecting termination, however our implementation allows only one recursive call. 15 oriented languages. The front end currently supports the language Concurrent Aggregates (CA) <ref> [7, 8] </ref>, a dynamically typed concurrent object-oriented language with single inheritance as well as first class selectors, continuations, and messages. We have tested the type inference system on more than 20,000 lines of CA code.
Reference: [8] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concurrent aggregates language report 2.0. </title> <note> Available via anonymous ftp from cs.uiuc.edu in /pub/csag, </note> <month> September </month> <year> 1993. </year>
Reference-contexts: Program examples in the running text will be in a syntax derived from [14]. The target language of our implementation and in which the benchmarks are written is the dynamically typed concurrent object-oriented language Concurrent Aggregates <ref> [7, 8] </ref> which includes first class selectors, messages and continuations. The algorithm is very general and can be applied easily to a wide range of languages. Before we begin, let us clarify some terms. We differentiate two types of polymorphism: data and functional. <p> The Concert system includes a compiler and runtime for concurrent object 7 A constant number of recursive calls can be split at each site without affecting termination, however our implementation allows only one recursive call. 15 oriented languages. The front end currently supports the language Concurrent Aggregates (CA) <ref> [7, 8] </ref>, a dynamically typed concurrent object-oriented language with single inheritance as well as first class selectors, continuations, and messages. We have tested the type inference system on more than 20,000 lines of CA code. <p> All test cases were compiled with the standard CA prologue (240 lines of code) and are available along with the language manual <ref> [8] </ref> and the 16 standard prologue from anonymous ftp. 8 The columns are defined as follows. P refers to the number of passes (iterations) which the algorithm required. This number is determined automatically by the algorithm which terminates when it has determined that the best precision has been reached.
Reference: [9] <author> J. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse dataflow evaluation graphs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: In <ref> [9] </ref>, the construction of sparse data flow evaluation graphs is proposed. The idea is to remove data flow nodes whose transfer functions are identity and to forward the results of the others directly to the nodes which use them. <p> Different data structures including constructing templates [14] or using a sparse evaluation graph to remove the replication caused by Static Single Assignment form <ref> [9] </ref> should reduce the gross times. 6 Uses There are many uses for type information both for compilation and program development. For example, the type information provides precise interprocedural control flow, an essential prerequisite to virtually all traditional program analyses.
Reference: [10] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> An efficient method of computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: This number is determined automatically by the algorithm which terminates when it has determined that the best precision has been reached. TVs reports the number of type variables created by the algorithm. Our compiler translates the program into a variation on Static Single Assignment form <ref> [10] </ref> which greatly increases this number for a given program. Tot Cts and Cts refer to the total constraints formed over all passes and the constraints in the final pass respectively.
Reference: [11] <author> J. Graver and R. Johnson. </author> <title> A type system for smalltalk. </title> <booktitle> In Proceedings of POPL, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: upper levels of the matrix library, the more limited replication scheme would only split the methods deeper in the library, selecting amongst the split and optimized algorithm kernels based on the type of a matrix argument. 7 Related Work Type inference in object-oriented languages has been studied for many years <ref> [18, 11] </ref>. Constraint-based type inference is described by Palsberg and Schwartzbach in [15, 14]. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]).
Reference: [12] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: While a great deal of progress has been made with respect to the inference of type information <ref> [12, 13, 4] </ref>, these inference techniques compute principle types, not concrete types. Concrete types can be used to support program optimization; while principle types are used primarily for reasoning about the type correctness of programs. <p> Use of the type information is touched on in Section 6. Related work is briefly surveyed in Section 7 and the paper is summarized in Section 8. 2 Background Most type checking and inference techniques <ref> [12, 4] </ref> determine types bottom up, using the types of subexpressions to form the types of expressions and finally the type of the program. At each point, a closed form for the program fragment signature is computed.
Reference: [13] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In 1993 IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: While a great deal of progress has been made with respect to the inference of type information <ref> [12, 13, 4] </ref>, these inference techniques compute principle types, not concrete types. Concrete types can be used to support program optimization; while principle types are used primarily for reasoning about the type correctness of programs.
Reference: [14] <author> N. Oxhtj, J. Palsberg, and M. Schwartzbach. </author> <title> Making type inference practical. </title> <booktitle> In Proceedings of OOPSLA '92, </booktitle> <year> 1992. </year>
Reference-contexts: Program examples in the running text will be in a syntax derived from <ref> [14] </ref>. The target language of our implementation and in which the benchmarks are written is the dynamically typed concurrent object-oriented language Concurrent Aggregates [7, 8] which includes first class selectors, messages and continuations. The algorithm is very general and can be applied easily to a wide range of languages. <p> We have tested the type inference system on more than 20,000 lines of CA code. The results on a variety of real and synthetic programs appear in Table 1. precise refers to our incremental inference algorithm, palsberg refers to the inference algorithm in <ref> [14] </ref>, and static refers to a basic constraint based inference which allocates exactly one type variable per static program variable. <p> Further, because of the relatively long run times for the static algorithm, we believe the long execution times reflect inefficiency in the implementation, not fundamental limitations of the algorithm. Different data structures including constructing templates <ref> [14] </ref> or using a sparse evaluation graph to remove the replication caused by Static Single Assignment form [9] should reduce the gross times. 6 Uses There are many uses for type information both for compilation and program development. <p> Constraint-based type inference is described by Palsberg and Schwartzbach in <ref> [15, 14] </ref>. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]).
Reference: [15] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of OOPSLA '91, </booktitle> <pages> pages 146-61, </pages> <year> 1991. </year>
Reference-contexts: These constraints are solved by propagation where changes in the input of a node triggers recomputation of the output so as to maintain a continuously updated solution <ref> [15] </ref>. x = newC ! [[x]] fCg x = y ! [[x = y]] [[y]]; x selector a 0 a 1 :::a n ! (8c 2 [[x]]:(c selector p 0 p 1 :::p n 8i n:[[p i ]] [[a i ]])) The basic local constraints reflect local data flow and special <p> Functions class A var b class B var i function createB: ivar return (new B) i: ivar function createA: bvar return (new A) b: bvar main a1 = createA: (createB: 1) a2 = createA: (createB: 1.0) Containers In order to handle polymorphic functions, the type inference algorithm in <ref> [15] </ref> creates separate type variables for each call site at which the function containing the variable was invoked. Likewise, separate type variables are created for the contents of polymorphic containers based on the point at which the dynamic instance of the container was created, its creation point. <p> Constraint-based type inference is described by Palsberg and Schwartzbach in <ref> [15, 14] </ref>. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]).
Reference: [16] <editor> Simon Peyton-Jones. </editor> <booktitle> Implementation of Functional Languages. Prentice-Hall International, </booktitle> <year> 1987. </year> <month> 20 </month>
Reference-contexts: In addition, it can only pass the creation set corresponding to the entry set of its partition. For Selector Values, anonymous function are given tokens, and closures are parameterized by the variables they capture from the surrounding scope <ref> [16] </ref> allowing such variables to be treated as arguments. In addition to the data flow problems, for each type variable there are several important attributes which must be updated: Dependent Invocation Sites The invocation sites for which the type variable is in the dynamic dispatch or function position.
Reference: [17] <author> Bernhard Rytz and Marc Gengler. </author> <title> A polyvariant binding time analysis. </title> <institution> Technical Re--port YALEU/DCS/RR-909, Yale University, Department of Computer Science, </institution> <year> 1992. </year> <booktitle> Proceeding of the 1992 ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulations. </booktitle>
Reference-contexts: The constraint based type system of Aiken, Wimmers, and Lakshman [3], adds conditional types unions and intersections to an ML-style type inference allowing the incorporation of flow sensitive information. Our algorithm also shares some features of the closure analysis and binding time analysis phases used in self-applicative partial evaluators <ref> [17] </ref>. However, both these systems are for languages which are purely functional where the question of types involving assignment does not arise.
Reference: [18] <author> Norihisa Suzuki. </author> <title> Inferring types in smalltalk. </title> <booktitle> In Eigth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: upper levels of the matrix library, the more limited replication scheme would only split the methods deeper in the library, selecting amongst the split and optimized algorithm kernels based on the type of a matrix argument. 7 Related Work Type inference in object-oriented languages has been studied for many years <ref> [18, 11] </ref>. Constraint-based type inference is described by Palsberg and Schwartzbach in [15, 14]. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF [19] (see [1]).
Reference: [19] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of OOPSLA '87, </booktitle> <pages> pages 227-41. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year> <month> 21 </month>
Reference-contexts: Constraint-based type inference is described by Palsberg and Schwartzbach in [15, 14]. The limitations of their algorithm to a single level of discrimination has motivated this research. Recently Agensen has extended the basic one level approach to handle the features of SELF <ref> [19] </ref> (see [1]). However, the problems with precision and cost inherent in a single pass approach are tackled by exploiting specialized knowledge about SELF [2]. The SELF compiler [5] employs a speculative optimization techniques based on runtime tests.
References-found: 19

