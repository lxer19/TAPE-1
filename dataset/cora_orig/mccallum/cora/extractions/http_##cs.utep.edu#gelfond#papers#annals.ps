URL: http://cs.utep.edu/gelfond/papers/annals.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: mgelfond@cs.ep.utexas.edu  
Title: Logic Programming and Reasoning with Incomplete Information  
Author: Michael Gelfond 
Date: January 21, 1994  
Address: El Paso, Texas 79968  
Affiliation: Computer Science Department University of Texas at El Paso  
Abstract: The purpose of this paper is to expand the syntax and semantics of logic programs and disjunctive databases to allow for the correct representation of incomplete information in the presence of multiple extensions. The language of logic programs with classical negation, epistemic disjunction, and negation by failure is further expanded by new modal operators K and M (where for the set of rules T and formula F , KF stands for "F is known to be true by a reasoner with a set of premises T " and MF means " F may be believed to be true" by the same reasoner). Sets of rules in the extended language will be called epistemic specifications. We will define the semantics of epistemic specifications (which expands the semantics of disjunctive databases from [GL91]) and demonstrate their applicability to formalization of various forms of commonsense reasoning. In particular, we suggest a new formalization of the closed world assumption which seems to better correspond to the assumption's intuitive meaning. 
Abstract-found: 1
Intro-found: 1
Reference: [BF87] <author> Nicole Bidoit and Christine Froidevaux. </author> <title> Minimalism subsumes default logic and circumscription. </title> <booktitle> In Proc. of LICS-87, </booktitle> <pages> pages 89-97, </pages> <year> 1987. </year>
Reference-contexts: Reiter [Rei80] and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], <ref> [BF87] </ref>, [GLPT91]. It is more difficult to use these formalisms to model modal operators of epistemic specifications. Autoepistemic logics, which seem to be natural candidates for such modeling, apparently do not work. There are several important differences between them and epistemic specifications two of which are probably most important.
Reference: [BLM91] <author> Chitta Baral, Jorge Lobo, and Jack Minker. Wf3: </author> <title> A semantics for negation in normal disjunctive logic programs. </title> <booktitle> In Proc. of International Symposium on Methodologies of Intelligent Systems, </booktitle> <year> 1991. </year>
Reference-contexts: The next example demonstrates how they can answer more complicated queries. The following story was discussed (in a somewhat different context) in <ref> [BLM91] </ref>. Example 11. Assume that we are preparing for a camping trip and we are deciding what equipment we are going to take on the trip. We would like 26 to bring with us a stove and a blanket.
Reference: [C.89] <author> Sakama C. </author> <title> Possible model semantics for disjunctive databases. </title> <booktitle> In Proc. of the first international conference on deductive and object oriented databases, </booktitle> <pages> pages 1055-1060, </pages> <year> 1989. </year>
Reference-contexts: Some further work in this direction can be found in <ref> [Cha89, C.89] </ref>, etc. In all these approaches however closed world assumption remains a part of the semantics. <p> Let = fP a or P b g. The ECWA answer to a query P a&P b is no, while the closed world answer to P a&P b is unknown. 22 (b) Consider possible world types of semantics <ref> [Cha89, RT88, C.89] </ref> etc. Let = fP a or P b ; P a g.
Reference: [Cha89] <author> Edward Chan. </author> <title> A possible world semantics for non-horn databases. </title> <type> Technical Report CS-89-47, </type> <institution> University of Waterloo, </institution> <year> 1989. </year>
Reference-contexts: Some further work in this direction can be found in <ref> [Cha89, C.89] </ref>, etc. In all these approaches however closed world assumption remains a part of the semantics. <p> In this section we will suggest a form of the closed world assumption which differs from the other proposals and will discuss the suitability of this assumption for knowledge representation. We will start with the following example: Example 10. <ref> [Cha89] </ref>. Suppose we are given the following information: (*) "If a suspect is violent and is a psychopath then the suspect is extremely dangerous. <p> Let = fP a or P b g. The ECWA answer to a query P a&P b is no, while the closed world answer to P a&P b is unknown. 22 (b) Consider possible world types of semantics <ref> [Cha89, RT88, C.89] </ref> etc. Let = fP a or P b ; P a g.
Reference: [Cla78] <author> Keith Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year> <month> 30 </month>
Reference-contexts: 1 Introduction As was demonstrated in recent years, traditional logic programming language provides a powerful tool for knowledge representation. Its main non-monotonic feature negation as failure <ref> [Cla78] </ref> makes it possible to express many interesting types of commonsense knowledge which are not readily expressible in classical logic. Unlike classical logic, however, traditional logic programming does not allow a programmer to directly represent incomplete knowledge about the world.
Reference: [Gel87] <author> Michael Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 207-211, </pages> <year> 1987. </year>
Reference-contexts: Reiter [Rei80] and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance <ref> [Gel87] </ref>, [BF87], [GLPT91]. It is more difficult to use these formalisms to model modal operators of epistemic specifications. Autoepistemic logics, which seem to be natural candidates for such modeling, apparently do not work. There are several important differences between them and epistemic specifications two of which are probably most important.
Reference: [Gel91] <author> Michael Gelfond. </author> <title> Strong introspection. </title> <booktitle> In Proc. AAAI-91, </booktitle> <pages> pages 386-391, </pages> <year> 1991. </year>
Reference-contexts: Therefore, the answer to this question is undetermined, and, by (*), Mike should be interviewed. To formalize this argument our system should have a more powerful introspective ability (termed strong introspection in <ref> [Gel91] </ref>) than the one captured by the notion of answer sets from [GL91]. Roughly speaking instead of looking at only one possible set of beliefs sanctioned by T it should be able to look at all such sets. Remark. <p> We will define the semantics of epistemic specifications (which expands the semantics of disjunctive databases from [GL91]) and demonstrate their applicability to formalization of various forms of commonsense reasoning. The notion of epistemic specification and some of the other material in this paper was first presented in <ref> [Gel91] </ref>. Our definitions are an improvement over those in [Gel91]. 2 Definitions Let us consider a language L 0 consisting of predicate symbols p; q; : : :, object variables, function symbols, connectives &, :, 9, and the modal operators K and M where KF stands for "F is known to <p> The notion of epistemic specification and some of the other material in this paper was first presented in <ref> [Gel91] </ref>. Our definitions are an improvement over those in [Gel91]. 2 Definitions Let us consider a language L 0 consisting of predicate symbols p; q; : : :, object variables, function symbols, connectives &, :, 9, and the modal operators K and M where KF stands for "F is known to be true", and MF stands for "F 6 may
Reference: [GL88] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert Kowalski and Ken-neth Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: These theories (called answer sets, or belief sets) consist of literals and therefore are vivid in the sense of H. Levesque [Lev86]. For extended programs without classical negation their answer sets coincide with stable models from <ref> [GL88] </ref>. In [GL90] we consider primarily well-defined extended logic programs, i.e. extended programs with unique consistent answer sets. The answer such a program returns to a ground query Q 2 is yes, no, or unknown, depending on whether the answer set contains Q, :Q, or neither.
Reference: [GL90] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Logic programs with classical negation. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 579-597, </pages> <year> 1990. </year>
Reference-contexts: The problem of lifting the closed world restriction of logic programming 2 was recently addressed in <ref> [GL90] </ref> 1 where the authors consider "extended" logic programs, that contain classical (or strong) negation : in addition to negation as failure not. <p> These theories (called answer sets, or belief sets) consist of literals and therefore are vivid in the sense of H. Levesque [Lev86]. For extended programs without classical negation their answer sets coincide with stable models from [GL88]. In <ref> [GL90] </ref> we consider primarily well-defined extended logic programs, i.e. extended programs with unique consistent answer sets. The answer such a program returns to a ground query Q 2 is yes, no, or unknown, depending on whether the answer set contains Q, :Q, or neither. <p> to a query Q is yes if every answer set from contains Q, no if every answer set from contains the complement of Q, and unknown otherwise. (The last answer can be split into several more informative answers but above alternatives are sufficient for the purpose of this paper.) In <ref> [GL90] </ref> we argue that for well-defined programs the presence of two types of negation allows one to deal in a natural and convenient way with incomplete information. This, however, is no longer the case if the corresponding programs are not well-defined. <p> The purpose of this paper is to expand the notions of extended logic programs and disjunctive databases to allow for the correct representation of incomplete information in the presence of multiple belief sets. We will start by demonstrating the problem using a modification of the following example from <ref> [GL90] </ref>: Example 1 Consider a collection of rules 1. Eligible (x) HighGPA (x), 2. Eligible (x) Minority (x); FairGPA (x), 3. :Eligible (x) :FairGPA (x); :HighGPA (x), 4. Interview (x) not Eligible (x); not :Eligible (x) used by a certain college for awarding scholarships to its students. <p> The same database viewed as a general disjunctive database answers no to Qb. To produce the same answer epistemic specification should be extended by the closed world assumption for the predicate Q. The same phenomena in the context of general logic programs was discussed in <ref> [GL90] </ref>, where it was shown that such an assumption could be expressed by the rule :Qx not Qx: (4) In the presence of multiple belief sets the situation is more complicated.
Reference: [GL91] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <pages> pages 365-387, </pages> <year> 1991. </year>
Reference-contexts: Such a multiplicity becomes a norm rather than exception if the notion of extended logic program and its answer set semantics is expanded to that of extended disjunctive database <ref> [GL91] </ref> (see also [Prz90] ) | collections of rules of the form: A 1 or : : : or A n B 1 ; :::; B m ; not C 1 ; : : : ; not C k (2) where A's, B's, and C's are atoms p or their "classical" <p> Therefore, the answer to this question is undetermined, and, by (*), Mike should be interviewed. To formalize this argument our system should have a more powerful introspective ability (termed strong introspection in [Gel91]) than the one captured by the notion of answer sets from <ref> [GL91] </ref>. Roughly speaking instead of looking at only one possible set of beliefs sanctioned by T it should be able to look at all such sets. Remark. The situation will not change if (**) is represented by modeling disjunctions in the language of logic programs. <p> For instance, replacing (7) by two rules FairGPA (M ike) not HighGPA (M ike) HighGPA (M ike) not FairGPA (M ike) will not change answer sets of the program. In this paper we extend the syntax of disjunctive databases from <ref> [GL91] </ref> in two directions. Firstly, following [LT84], and [Wag91] we allow the rules to contain other types of formulae in addition to literals. Secondly, and more importantly, we expand the language by a modal operators K and M. Sets of rules in the extended language are called epistemic specifications. <p> Secondly, and more importantly, we expand the language by a modal operators K and M. Sets of rules in the extended language are called epistemic specifications. We will define the semantics of epistemic specifications (which expands the semantics of disjunctive databases from <ref> [GL91] </ref>) and demonstrate their applicability to formalization of various forms of commonsense reasoning. The notion of epistemic specification and some of the other material in this paper was first presented in [Gel91]. <p> A consistent set W Lit is a belief set of an extended disjunctive database iff W + is a belief set of + . Proof. Proof of this Lemma is similar to the proof of Proposition 2 in <ref> [GL91] </ref> and will be left to the reader. 17 Let W and U be sets of ground literals and A be a collection of sets of such literals. <p> It will be interesting to find broader classes of epistemic specifications satisfying conclusion of Proposition 2. The following Corollary demonstrates that for well-defined general logic programs our formalization of closed world assumption coincides with the one from <ref> [GL91] </ref>. More precisely, we have Corollary 3. Let be a consistent general logic program with a unique stable model. <p> Then for every ground query Q in the language of Q is true (f alse) in iff Q is true (f alse) in flfl is true (f alse) in fl . Proof. The first equivalence follows from Proposition 4 of <ref> [GL91] </ref>, while the second is an immediate consequence of Propositions 1 and 2 above. In the remainder of this section we will briefly discuss the relationship between our form of closed world assumption and other forms incorporated in the known semantics of disjunctive databases.
Reference: [GLPT91] <author> Michael Gelfond, Vladimir Lifschitz, Halina Przymusinska, and Miroslaw Truszczynski. </author> <title> Disjunctive defaults. </title> <editor> In James Allen, Richard Fikes, and Erik Sandewall, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. of the Second Int'l Conf., </booktitle> <pages> pages 230-237, </pages> <year> 1991. </year>
Reference-contexts: Reiter [Rei80] and its extension <ref> [GLPT91] </ref>. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91]. It is more difficult to use these formalisms to model modal operators of epistemic specifications. <p> Reiter [Rei80] and its extension <ref> [GLPT91] </ref>. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91]. It is more difficult to use these formalisms to model modal operators of epistemic specifications. Autoepistemic logics, which seem to be natural candidates for such modeling, apparently do not work. There are several important differences between them and epistemic specifications two of which are probably most important.
Reference: [GP86] <author> Michael Gelfond and Halina Przymusinska. </author> <title> Negation as failure: Careful closure procedure. </title> <journal> Artificial Intelligence, </journal> <volume> 30(3) </volume> <pages> 273-287, </pages> <year> 1986. </year>
Reference-contexts: A n B 1 ; : : : ; B m (6) by a formula B 1 & : : : &B m A 1 _ : : : _ A n (7) Recall that Minker's generalized closed world assumption is defined as follows. (We will use the terminology from <ref> [GP86] </ref>.) A disjunction D of ground atoms is called essential w.r.t. theory if j= D and no subdisjunction of D is entailed by . A ground atom is called free for negation in if it does 21 not belong to any clause essential in . <p> Proposition 3. For any positive disjunctive database and any query Q, the GCWA answer to Q coincides with the closed world answer to Q. Proof. First let us recall that, as was proved for a finite theory in [Min82] and for an arbitrary in <ref> [GP86] </ref>, is equal to the set of negations of all ground atoms not belonging to any minimal Herbrand model of .
Reference: [GP91] <author> Michael Gelfond and Halina Przymusinska. </author> <title> Definitions in epis-temic specifications. </title> <editor> In Anil Nerod, Victor Marek, and Subrama-nian V. S., editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proc. of the First Int'l Workshop, </booktitle> <pages> pages 245-259, </pages> <year> 1991. </year>
Reference-contexts: Similar problem arises when default logic is used for the same purpose. A more detailed discussion of this (as well as some ideas about computing world views of epistemic specifications) can be found in <ref> [GP91] </ref>. Acknowledgments I would like to thank Vladimir Lifschitz, Halina Przymusinska, Marek Such-enek, Bonnie Traylor and Thomas Woo for suggestions on a draft of this paper. Special thanks to Teodor Przymusinski whose comments helped to discover an error in the original draft.
Reference: [GPP86] <author> Michael Gelfond, Halina Przymusinska, and Teodor Przymusin-ski. </author> <title> The extended closed world assumption and its relation to parallel circumscription. </title> <booktitle> In Proc. of the fifth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 133-139, </pages> <year> 1986. </year> <month> 31 </month>
Reference-contexts: The following examples demonstrate differences between our semantics and several others. (a) Consider the semantics based on the extended closed world assumption (ECWA) <ref> [GPP86, YH85] </ref>, and its extensions such as perfect models semantics [Prz88], stationary semantics [Prz90], etc. Let = fP a or P b g.
Reference: [KS90] <author> Robert Kowalski and Fariba Sadri. </author> <title> Logic programs with excep-tions. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 598-613, </pages> <year> 1990. </year>
Reference-contexts: The meaning of a formula A _ B is "A is true or B is true" while a rule 1 A similar approach was independently developed and investigated in [PW89]. See also <ref> [KS90] </ref>. 2 Here Q is a literal.
Reference: [Lev86] <author> Hector Levesque. </author> <title> Making believers out of computers. </title> <journal> Artificial Intelligence, </journal> <volume> 30:81 - 108, </volume> <year> 1986. </year>
Reference-contexts: This semantics views the program rules as constraints used by a reasoner associated with the program to build possible theories about the world. These theories (called answer sets, or belief sets) consist of literals and therefore are vivid in the sense of H. Levesque <ref> [Lev86] </ref>. For extended programs without classical negation their answer sets coincide with stable models from [GL88]. In [GL90] we consider primarily well-defined extended logic programs, i.e. extended programs with unique consistent answer sets.
Reference: [Lev90] <author> Hector Levesque. </author> <title> All I know: a study in autoepistemic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 42(2,3):263-310, </volume> <year> 1990. </year>
Reference-contexts: Levesque in <ref> [Lev90] </ref>).
Reference: [LMR92] <author> Jorge Lobo, Jack Minker, and Arcot Rajasekar. </author> <title> Foundations of disjunctive logic programming. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The type of incompleteness expressible in these databases is, however, rather limited since their semantics suggested in [Min82] implicitly assumes a form of closed world assumption. This work was generalized and/or modified by various authors (an overview can be found in [PP90], <ref> [LMR92] </ref>) but most of the approaches still assume the closed world assumption and hence does not allow the representation of such simple forms of incompleteness as missing informations in the database tables, null values, partial definitions, etc.
Reference: [LT84] <author> John Lloyd and Rodney Topor. </author> <title> Making prolog more expressive. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: For instance, replacing (7) by two rules FairGPA (M ike) not HighGPA (M ike) HighGPA (M ike) not FairGPA (M ike) will not change answer sets of the program. In this paper we extend the syntax of disjunctive databases from [GL91] in two directions. Firstly, following <ref> [LT84] </ref>, and [Wag91] we allow the rules to contain other types of formulae in addition to literals. Secondly, and more importantly, we expand the language by a modal operators K and M. Sets of rules in the extended language are called epistemic specifications.
Reference: [McC80] <author> John McCarthy. </author> <title> Circumscription|a form of non-monotonic reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1, </volume> 2):27-39,171-172, 1980. 
Reference-contexts: We suggest to code such statements by the rules of the form Q (x) P (x); not AB (q; p; x); not :Q (x) where AB is an abnormality predicate from <ref> [McC80] </ref> and q and p are object constants corresponding to predicate constants Q and P . This coding can be viewed as a combination of the representation of normative statements in circumscription with the method used in non-monotonic modal logics [McC80, MD80]. It was also advocated in [PCA91]. <p> This coding can be viewed as a combination of the representation of normative statements in circumscription with the method used in non-monotonic modal logics <ref> [McC80, MD80] </ref>. It was also advocated in [PCA91]. For illustration, let us consider database T 1 from Example 10 and expand it by the following information: "As a rule, professors in the computer science department have vax accounts. This rule is not applicable to Mike.
Reference: [MD80] <author> Drew McDermott and Jon Doyle. </author> <title> Nonmonotonic logic I. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):41-72, </volume> <year> 1980. </year>
Reference-contexts: This coding can be viewed as a combination of the representation of normative statements in circumscription with the method used in non-monotonic modal logics <ref> [McC80, MD80] </ref>. It was also advocated in [PCA91]. For illustration, let us consider database T 1 from Example 10 and expand it by the following information: "As a rule, professors in the computer science department have vax accounts. This rule is not applicable to Mike. <p> In our case knowledge base and queries are both epistemic formulae while the underlying logic is nonmonotonic. 4 Appendix In this section we will briefly discuss the relationship between epistemic specifications and some other general purpose nonmonotonic formalisms such as autoepistemic logics <ref> [MD80] </ref>, [Moo85], [MT90], and default logic of R. Reiter [Rei80] and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91].
Reference: [Min82] <author> Jack Minker. </author> <title> On indefinite data bases and the closed world assumption. </title> <booktitle> In Proc. of CADE-82, </booktitle> <pages> pages 292-308, </pages> <year> 1982. </year>
Reference-contexts: The first attempt to lift the syntactic limitation described above is probably due to Jack Minker. In <ref> [Min82] </ref> he considers positive disjunctive databases defined as collections of rules of the form A 1 or : : : or A n B 1 ; :::; B m (1) where A 0 s and B 0 s are atoms. <p> The type of incompleteness expressible in these databases is, however, rather limited since their semantics suggested in <ref> [Min82] </ref> implicitly assumes a form of closed world assumption. <p> This question has been extensively studied in the context of various nonmonotonic formalisms. <ref> [Min82] </ref> gives perhaps the most widely known form of the closed world assumption for positive disjunctive databases called the generalized closed world assumption (GCWA). By now there are many useful generalizations of this assumption expanding the original idea. Most of them tend to interpret disjunction as exclusive. <p> First we will demonstrate that, in the presence of the closed world assumption, epistemic semantics for positive disjunctive databases coincides with the semantics from <ref> [Min82] </ref>. <p> To simplify the notation we will use the same letter Q to denote its epistemic counterpart P (c 1 ) or : : : or P (c n ). According to <ref> [Min82] </ref>, for every query Q, the GCWA answer to Q is yes if Q is true in all models from M, (which will be denoted by M j= Q), no if :Q is true in all such models, and unknown otherwise. <p> Proposition 3. For any positive disjunctive database and any query Q, the GCWA answer to Q coincides with the closed world answer to Q. Proof. First let us recall that, as was proved for a finite theory in <ref> [Min82] </ref> and for an arbitrary in [GP86], is equal to the set of negations of all ground atoms not belonging to any minimal Herbrand model of .
Reference: [Moo85] <author> Robert Moore. </author> <title> Semantical considerations on nonmonotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: In our case knowledge base and queries are both epistemic formulae while the underlying logic is nonmonotonic. 4 Appendix In this section we will briefly discuss the relationship between epistemic specifications and some other general purpose nonmonotonic formalisms such as autoepistemic logics [MD80], <ref> [Moo85] </ref>, [MT90], and default logic of R. Reiter [Rei80] and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91].
Reference: [MT90] <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Modal logic for default reasoning. </title> <note> To appear, </note> <year> 1990. </year>
Reference-contexts: In our case knowledge base and queries are both epistemic formulae while the underlying logic is nonmonotonic. 4 Appendix In this section we will briefly discuss the relationship between epistemic specifications and some other general purpose nonmonotonic formalisms such as autoepistemic logics [MD80], [Moo85], <ref> [MT90] </ref>, and default logic of R. Reiter [Rei80] and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91].
Reference: [PCA91] <author> Luis Pereira, Luis Caires, and Jose Alferes. </author> <title> Hypothetical reasoning with well founded semantics. </title> <booktitle> In Proc. of the 3rd Scandinavian Conference on AI, </booktitle> <year> 1991. </year>
Reference-contexts: This coding can be viewed as a combination of the representation of normative statements in circumscription with the method used in non-monotonic modal logics [McC80, MD80]. It was also advocated in <ref> [PCA91] </ref>. For illustration, let us consider database T 1 from Example 10 and expand it by the following information: "As a rule, professors in the computer science department have vax accounts. This rule is not applicable to Mike.
Reference: [PP90] <author> Halina Przymusinska and Teodor Przymusinski. </author> <title> Semantic issues in deductive databases and logic programs. </title> <editor> In R Manerji, editor, </editor> <booktitle> Formal Techniques in Artificial Intelligence, </booktitle> <pages> pages 321 - 367. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year> <month> 32 </month>
Reference-contexts: The type of incompleteness expressible in these databases is, however, rather limited since their semantics suggested in [Min82] implicitly assumes a form of closed world assumption. This work was generalized and/or modified by various authors (an overview can be found in <ref> [PP90] </ref>, [LMR92]) but most of the approaches still assume the closed world assumption and hence does not allow the representation of such simple forms of incompleteness as missing informations in the database tables, null values, partial definitions, etc.
Reference: [Prz88] <author> Teodor Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: The following examples demonstrate differences between our semantics and several others. (a) Consider the semantics based on the extended closed world assumption (ECWA) [GPP86, YH85], and its extensions such as perfect models semantics <ref> [Prz88] </ref>, stationary semantics [Prz90], etc. Let = fP a or P b g. The ECWA answer to a query P a&P b is no, while the closed world answer to P a&P b is unknown. 22 (b) Consider possible world types of semantics [Cha89, RT88, C.89] etc.
Reference: [Prz90] <author> Teodor Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 459-477, </pages> <year> 1990. </year>
Reference-contexts: Such a multiplicity becomes a norm rather than exception if the notion of extended logic program and its answer set semantics is expanded to that of extended disjunctive database [GL91] (see also <ref> [Prz90] </ref> ) | collections of rules of the form: A 1 or : : : or A n B 1 ; :::; B m ; not C 1 ; : : : ; not C k (2) where A's, B's, and C's are atoms p or their "classical" negations :p. <p> The following examples demonstrate differences between our semantics and several others. (a) Consider the semantics based on the extended closed world assumption (ECWA) [GPP86, YH85], and its extensions such as perfect models semantics [Prz88], stationary semantics <ref> [Prz90] </ref>, etc. Let = fP a or P b g. The ECWA answer to a query P a&P b is no, while the closed world answer to P a&P b is unknown. 22 (b) Consider possible world types of semantics [Cha89, RT88, C.89] etc.
Reference: [PW89] <author> David Pearce and Gerd Wagner. </author> <title> Reasoning with negative information 1 strong negation in logic programming. </title> <type> Technical report, </type> <institution> Gruppe fur Logic, Wissentheorie and Information, Freie Universitat Berlin, </institution> <year> 1989. </year>
Reference-contexts: The meaning of a formula A _ B is "A is true or B is true" while a rule 1 A similar approach was independently developed and investigated in <ref> [PW89] </ref>. See also [KS90]. 2 Here Q is a literal.
Reference: [Rei78] <author> Raymond Reiter. </author> <title> On closed world data bases. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 119-140. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: This happens because the syntax of logic programming does not allow the representation of disjunctive information and because the traditional declarative semantics of logic programming automatically applies the closed world assumption <ref> [Rei78] </ref> to all predicates (i.e. each ground atom that does not follow from the facts included in the program is assumed to be false). <p> Interview (M ike)g Therefore T answers unknown to the query Eligible (M ike) and yes to the query Interview (M ike) which is the intended behavior of the system. 3.2 Closed World Assumption Now we will illustrate how epistemic specifications can be used to formalize the closed world assumption of <ref> [Rei78] </ref> in the presence of disjunctive information. This question has been extensively studied in the context of various nonmonotonic formalisms. [Min82] gives perhaps the most widely known form of the closed world assumption for positive disjunctive databases called the generalized closed world assumption (GCWA). <p> Let = fP a or P b ; P a g. It is easy to see that the closed world answer to a query P b is no, while the answer based on possible world semantics is unknown. 3.3 Unique Name Assumption The unique name assumption <ref> [Rei78] </ref> is normally used in the settings when one can assume that all the relevant information about the equality of individuals has been specified. In this case all pairs of individuals not specified as identical are assumed to be different.
Reference: [Rei80] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year>
Reference-contexts: Reiter <ref> [Rei80] </ref> and its extension [GLPT91]. By now we have a reasonably good understanding of the relationship between these formalisms and special classes of epistemic specifications. For the equivalence results about various subclasses see for instance [Gel87], [BF87], [GLPT91].
Reference: [Rei90] <author> Raymond Reiter. </author> <title> On asking what a database knows. </title> <editor> In John Lloyd, editor, </editor> <booktitle> Computational Logic: Symposium Proceedings, </booktitle> <pages> pages 96-113. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: The main difficulty is related to the lack of universally accepted interpretation of the meaning and the role of integrity constraints in knowledge representation. In this paper we will adopt the view on integrity constraints recently suggested by Reiter in <ref> [Rei90] </ref>. According to Reiter an integrity constraint IC is a statement about the content of the knowledge base T (as opposed to IC being a statement about the world). T satisfies IC iff the answer to IC when viewed as a query to T is yes.
Reference: [RT88] <author> Kenneth Ross and Rodney Topor. </author> <title> Inferring negative information from disjunctive databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4(4) </volume> <pages> 397-424, </pages> <year> 1988. </year>
Reference-contexts: By now there are many useful generalizations of this assumption expanding the original idea. Most of them tend to interpret disjunction as exclusive. For instance, a positive disjunctive database fP a or P b g will answer "No" to a query P a & P b 3 . <ref> [RT88] </ref> noticed that in some applications disjunctive databases with the semantics based on GCWA or its extensions may lead to unintuitive conclusions, and attempted to remedy the problem by weakening the corresponding assumptions. Some further work in this direction can be found in [Cha89, C.89], etc. <p> Let = fP a or P b g. The ECWA answer to a query P a&P b is no, while the closed world answer to P a&P b is unknown. 22 (b) Consider possible world types of semantics <ref> [Cha89, RT88, C.89] </ref> etc. Let = fP a or P b ; P a g.
Reference: [Wag91] <author> Gerd Wagner. </author> <title> Database needs two kinds of negation. </title> <booktitle> In Proc. of MFDBS-91, (Lecture Notes in Computer Science, </booktitle> <volume> 495), </volume> <year> 1991. </year>
Reference-contexts: For instance, replacing (7) by two rules FairGPA (M ike) not HighGPA (M ike) HighGPA (M ike) not FairGPA (M ike) will not change answer sets of the program. In this paper we extend the syntax of disjunctive databases from [GL91] in two directions. Firstly, following [LT84], and <ref> [Wag91] </ref> we allow the rules to contain other types of formulae in addition to literals. Secondly, and more importantly, we expand the language by a modal operators K and M. Sets of rules in the extended language are called epistemic specifications.
Reference: [YH85] <author> L. Yahya and A Henschen. </author> <title> Deduction in non-horn databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(2) </volume> <pages> 141-160, </pages> <year> 1985. </year> <month> 33 </month>
Reference-contexts: The following examples demonstrate differences between our semantics and several others. (a) Consider the semantics based on the extended closed world assumption (ECWA) <ref> [GPP86, YH85] </ref>, and its extensions such as perfect models semantics [Prz88], stationary semantics [Prz90], etc. Let = fP a or P b g.
References-found: 35

