URL: ftp://ftp.cs.utexas.edu/pub/predator/rosetta.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: Rosetta: A Generator of Data Language Compilers  
Author: E. E. Villarreal Don Batory 
Date: April 4, 1996  
Address: San Luis Obispo, CA 93407  Austin, TX 78712  
Affiliation: Computer Science Department Cal Poly State University  Department of Computer Sciences The University of Texas at Austin  
Abstract: A data language is a declarative language that enables database users to access and manipulate data. There are families of related data languages; each family member is targeted for a particular application. Unfortunately, building compilers for such languages is largely an ad hoc process; there are no tools and design methods that allow programmers to leverage the design and code of compilers for similar languages, or to simplify the evolution of existing languages to include more features. Rosetta is a generator of relational data language compilers that demonstrates practical solutions to these problems. We explain how domain analysis identifies primitive building blocks of these compilers, and how grammar-based definitions (a la GenVoca) of the legal compositions of these blocks yields compact and easily-evolvable specifications of data languages. Rosetta automatically transforms such specifications into compilers. Experiences with Rosetta are discussed.
Abstract-found: 1
Intro-found: 1
Reference: [BBG + 88] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise. </author> <title> Genesis: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 1711-1730, </pages> <year> 1988. </year>
Reference-contexts: The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral [Gut89], Postgres [SK91], Probe [MD90], and Starburst [HFLP89]). DBMS toolkits, such as Exodus [CDV87] and Genesis <ref> [BBG + 88] </ref>, are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components. Among Genesis components are those that implement different data languages.
Reference: [BG96] <author> D. Batory and B.J. Geraci. </author> <title> Validating component compositions in software system generators. </title> <booktitle> In International Conference on Software Reuse, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: A software system or program is defined as a composition of components, called a type equation. The set of all syntactically and semantically correct type equations (i.e., software systems that can be generated) is expressed as an attribute grammar <ref> [BG96] </ref>. As mentioned earlier, a data language compiler is itself a generator. It translates data language statements into programs that perform the intended actions of that statement. Rosetta catalogs are realms, and operator trees (i.e., data language programs) are type equations.
Reference: [BO92] <author> D. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Rosetta exploits these two concepts to deliver data language extensibility through software building blocks. Rosetta is a GenVoca generator <ref> [BO92] </ref>; it relies on a grammar-based specification to define the legal combinations of building blocks. The syntax that is used to invoke a particular combination (and thus define the actions of a specific data language statement) is specified by instantiating parameters of these blocks. <p> Software system generators is a subdiscipline of architectures, where components are designed to be plug-compatible and interoperable so that customized 15 software systems can be produced quickly through component composition. Rosetta is an example of a GenVoca generator <ref> [BO92] </ref>. A GenVoca domain model is a set of libraries (called realms) of plug-compatible components. A software system or program is defined as a composition of components, called a type equation.
Reference: [CDV87] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A data model and query language for EXODUS. </title> <type> Technical Report CS Technical Report 734, </type> <institution> University of Wisconsin, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: Extensible DBMSs offer some support for data language extensibility. The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral [Gut89], Postgres [SK91], Probe [MD90], and Starburst [HFLP89]). DBMS toolkits, such as Exodus <ref> [CDV87] </ref> and Genesis [BBG + 88], are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components. Among Genesis components are those that implement different data languages.
Reference: [CHHP91] <author> J. Cordy, C. Halpern-Hamu, and E. Promislow. TXL: </author> <title> A rapid prototyping system for programming language dialects. </title> <booktitle> Computer Languages, </booktitle> <pages> pages 97-107, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Among Genesis components are those that implement different data languages. However, these components (data language compilers) must be hand-written; like Exodus, there is no specific tool support for building customized data languages. Extensible Programming Languages. Language extensibility can be achieved using preprocessors. TXL <ref> [CHHP91] </ref> can extend any imperative language for which a compiler and a complete syntactic description of the base language are available. TXL maps extensions into the base language; however, it also allows extensions to reference library operators which augment the functionality of the base language.
Reference: [Dat87] <author> C. J. Date. </author> <title> A Guide to Ingres, chapter 4. </title> <publisher> Addison Wesley Publishing Company, Inc., </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Families of functionally and syntactically similar languages are prevalent today because languages have a history of development. The family or domain of non-object-oriented imperative programming languages (e.g., Pascal [JW78], Algol [ISO72], C [KR78], etc.) is one example; the domain of relational data languages (e.g., SQL [vdL89], Quel <ref> [Dat87] </ref>, TQuel [Sno87]) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research.
Reference: [DS91] <author> C. Donnelly and R. Stallman. </author> <title> BISON The YACC-Compatible Parser Generator, </title> <month> December </month> <year> 1991. </year> <note> on-line documentation for Bison Version 1.16. </note>
Reference-contexts: Thus, the specification G L of L defines the set of operator trees that can be expressed by the language and the syntax that invokes specific trees. Our approach to specifying languages is different than that of typical syntax-directed compiler tools, such as lex/yacc [Joh86] and flex/bison <ref> [DS91] </ref>. Our approach is semantics-directed: we define the language's semantics (i.e., operator trees that can be produced) first and specify syntax last, rather than the reverse. The next section illustrates these ideas on the domain of elementary calculator languages.
Reference: [GHL + 92] <author> R. Gray, V. Heuring, S. Levi, A. Sloane, and W. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <pages> pages 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: TXL [CHHP91] can extend any imperative language for which a compiler and a complete syntactic description of the base language are available. TXL maps extensions into the base language; however, it also allows extensions to reference library operators which augment the functionality of the base language. Eli <ref> [GHL + 92] </ref> is an example of a compiler generator. It is an expert system that controls off-the-shelf tools like lex and yacc. Specifying a compiler to Eli consists of supplying specification files which contain information used for lexical analysis and parsing, semantic analysis, and code generation.
Reference: [Gut89] <author> R. Guting. </author> <title> Gral: An extensible relational database system for geometric applications. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 33-44, </pages> <year> 1989. </year>
Reference-contexts: Extensible Database Systems. Extensible DBMSs offer some support for data language extensibility. The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral <ref> [Gut89] </ref>, Postgres [SK91], Probe [MD90], and Starburst [HFLP89]). DBMS toolkits, such as Exodus [CDV87] and Genesis [BBG + 88], are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components.
Reference: [Hen77] <author> G. Hendrix. </author> <title> The LIFER manual|a guide to building practical natural language interfaces. </title> <type> Technical Report Technical Note 138, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1977. </year>
Reference-contexts: Rosetta is related to IP in that they share the idea that a backplane of operations can support many languages. Natural Language Processing. LIFER <ref> [Hen77] </ref> is a general package of tools which facilitates the rapid addition of natural language interfaces to existing software systems. The similarity of LIFER to Rosetta is the triggering of an operator when an input text pattern is recognized.
Reference: [HFLP89] <author> L. Haas, J. Freytag, G. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 377-388, </pages> <month> May </month> <year> 1989. </year> <title> also, </title> <type> IBM Almaden Tech Report RJ 6610 (63921) 12/21/88. </type>
Reference-contexts: Extensible Database Systems. Extensible DBMSs offer some support for data language extensibility. The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral [Gut89], Postgres [SK91], Probe [MD90], and Starburst <ref> [HFLP89] </ref>). DBMS toolkits, such as Exodus [CDV87] and Genesis [BBG + 88], are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components. Among Genesis components are those that implement different data languages.
Reference: [ISO72] <author> ISO. </author> <title> ISO Recommendation R1538, </title> <booktitle> Programming Language ALGOL, first edition, </booktitle> <month> March </month> <year> 1972. </year>
Reference-contexts: 1 Introduction Families of functionally and syntactically similar languages are prevalent today because languages have a history of development. The family or domain of non-object-oriented imperative programming languages (e.g., Pascal [JW78], Algol <ref> [ISO72] </ref>, C [KR78], etc.) is one example; the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research.
Reference: [Joh86] <author> S. Johnson. </author> <title> Yacc: Yet another compiler compiler. In UNIX Programmer's Manual: </title> <type> Supplementary Documents 1. </type> <institution> University of California, Berkeley, </institution> <year> 1986. </year>
Reference-contexts: Thus, the specification G L of L defines the set of operator trees that can be expressed by the language and the syntax that invokes specific trees. Our approach to specifying languages is different than that of typical syntax-directed compiler tools, such as lex/yacc <ref> [Joh86] </ref> and flex/bison [DS91]. Our approach is semantics-directed: we define the language's semantics (i.e., operator trees that can be produced) first and specify syntax last, rather than the reverse. The next section illustrates these ideas on the domain of elementary calculator languages.
Reference: [JW78] <author> K. Jensen and N. Wirth. </author> <title> Pascal: User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction Families of functionally and syntactically similar languages are prevalent today because languages have a history of development. The family or domain of non-object-oriented imperative programming languages (e.g., Pascal <ref> [JW78] </ref>, Algol [ISO72], C [KR78], etc.) is one example; the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research.
Reference: [KR78] <author> B. Kernighan and D. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1978. </year>
Reference-contexts: 1 Introduction Families of functionally and syntactically similar languages are prevalent today because languages have a history of development. The family or domain of non-object-oriented imperative programming languages (e.g., Pascal [JW78], Algol [ISO72], C <ref> [KR78] </ref>, etc.) is one example; the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research.
Reference: [MD90] <author> F. Manola and U. Dayal. PDM: </author> <title> An object-oriented data model. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object Oriented Database Systems, chapter 3.4. </booktitle> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Extensible Database Systems. Extensible DBMSs offer some support for data language extensibility. The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral [Gut89], Postgres [SK91], Probe <ref> [MD90] </ref>, and Starburst [HFLP89]). DBMS toolkits, such as Exodus [CDV87] and Genesis [BBG + 88], are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components. Among Genesis components are those that implement different data languages.
Reference: [RKB88] <author> M. Roth, H. Korth, and D. Batory. SQL/NF: </author> <title> A query language for :1NF relational databases. </title> <journal> Information Systems, </journal> <volume> 12(1) </volume> <pages> 99-114, </pages> <year> 1988. </year>
Reference-contexts: We selected SQL and Quel because these languages are historically significant and for their continuing popularity in industry and academia. The other three languages are derivatives of SQL and Quel which support alternative data models: SQL/NF <ref> [RKB88] </ref> is a data language for Non First Normal Form (:1NF) relations while TSQL2 [Sno94] and TQuel [Sno87] support temporal data models. Statistics from our experiments are summarized in Table 7. We began by defining a Rosetta specification for SQL, and from there we evolved specifications for other data languages.
Reference: [Sal95] <author> J. Salasin. </author> <title> Evolutionary design of large complex software. </title> <type> ARPA BAA 95-40, </type> <institution> Advanced Research Projects Agency, </institution> <year> 1995. </year>
Reference-contexts: Fewer still are implemented. Database practitioners demand that researchers go beyond the proposal stage to have hands-on experience evaluating their languages. Tools and methodologies that enable building language families (or evolving existing languages) inexpensively and quickly are nonexistent and are sorely needed <ref> [Sal95] </ref>. Our system, Rosetta, is a generator of data language compilers that addresses precisely these needs of database researchers. In this paper, we explain the two software engineering concepts on which Rosetta is based.
Reference: [Sim95] <author> C. Simonyi. </author> <title> The death of computer languages, the birth of intentional programming. </title> <booktitle> In 28th Annual International Seminar on the Teaching of Computing Science at University Level The Future of Software. </booktitle> <institution> University of Newcastle upon Tyne, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Multiple specification files are necessary, where each is written using its own special syntax with no uniformity among them. IP is an extensible language/compiler that is being developed at Microsoft Research <ref> [Sim95] </ref>. IP's interface is a language-neutral structure editor, which takes programmers input and directly represents source code as semantic trees. To view a program (e.g., during editing) an unparser converts semantic trees to text. Additional semantic nodes can be added to IP, so language extensibility is straightforward.
Reference: [SK91] <author> M. Stonebraker and G. Kemnitz. </author> <title> The Postgres next-generation database management system. </title> <journal> Communications of the ACM, </journal> <pages> pages 78-93, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Extensible Database Systems. Extensible DBMSs offer some support for data language extensibility. The usual approach is to make data language parsers table-driven, thus limited (but useful) sets of features (e.g., user-written ADTs) can be added easily (see Gral [Gut89], Postgres <ref> [SK91] </ref>, Probe [MD90], and Starburst [HFLP89]). DBMS toolkits, such as Exodus [CDV87] and Genesis [BBG + 88], are software design and development environments for building customized DBMSs. Genesis is a GenVoca generator that can assemble customized DBMSs from components. Among Genesis components are those that implement different data languages.
Reference: [Sno87] <author> R. Snodgrass. </author> <title> The temporal query language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The family or domain of non-object-oriented imperative programming languages (e.g., Pascal [JW78], Algol [ISO72], C [KR78], etc.) is one example; the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel <ref> [Sno87] </ref>) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research. <p> Quel aggregation is more general: different aggregations operate on the same tuples, but each may specify its own grouping. Non-traditional data languages are SQL and Quel with application-specific extensions. For example, the temporal data languages TQuel <ref> [Sno87] </ref> and TSQL2 [Sno94] share several temporal data types such as events (points in time) and time intervals. There are functionalities that TQuel has that TSQL2 doesn't have (e.g., the coalescing of tuples with overlapping time intervals), and vice versa. Data languages are often built from scratch. <p> The other three languages are derivatives of SQL and Quel which support alternative data models: SQL/NF [RKB88] is a data language for Non First Normal Form (:1NF) relations while TSQL2 [Sno94] and TQuel <ref> [Sno87] </ref> support temporal data models. Statistics from our experiments are summarized in Table 7. We began by defining a Rosetta specification for SQL, and from there we evolved specifications for other data languages.
Reference: [Sno94] <author> R. Snodgrass. </author> <title> TSQL2 language specification. </title> <booktitle> SIGMOD Record, </booktitle> <pages> pages 65-86, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Quel aggregation is more general: different aggregations operate on the same tuples, but each may specify its own grouping. Non-traditional data languages are SQL and Quel with application-specific extensions. For example, the temporal data languages TQuel [Sno87] and TSQL2 <ref> [Sno94] </ref> share several temporal data types such as events (points in time) and time intervals. There are functionalities that TQuel has that TSQL2 doesn't have (e.g., the coalescing of tuples with overlapping time intervals), and vice versa. Data languages are often built from scratch. <p> The other three languages are derivatives of SQL and Quel which support alternative data models: SQL/NF [RKB88] is a data language for Non First Normal Form (:1NF) relations while TSQL2 <ref> [Sno94] </ref> and TQuel [Sno87] support temporal data models. Statistics from our experiments are summarized in Table 7. We began by defining a Rosetta specification for SQL, and from there we evolved specifications for other data languages.
Reference: [vdL89] <author> R. van der Lans. </author> <title> The SQL Standard. </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Families of functionally and syntactically similar languages are prevalent today because languages have a history of development. The family or domain of non-object-oriented imperative programming languages (e.g., Pascal [JW78], Algol [ISO72], C [KR78], etc.) is one example; the domain of relational data languages (e.g., SQL <ref> [vdL89] </ref>, Quel [Dat87], TQuel [Sno87]) is another. Clearly, there will always be families of related languages, if only because no single language suits all situations. This is particularly evident in contemporary database research.
Reference: [Vil94] <author> E. E. Villarreal. </author> <title> Automated Compiler Generation for Extensible Data Languages. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1994. </year> <month> 19 </month>
Reference-contexts: Generally, cycle signatures are included in recursive subcatalogs (e.g., T ! f 1 (ff : T ) j : : : ;) which perform sophisticated conversions of syntax trees to operator trees. A full discussion of the rewrite () directive and cycle subcatalogs appears in <ref> [Vil94] </ref>. Context Variables. Often, values for operator parameters can be precisely determined from information that has already been parsed. Rather than redundantly specifying such information in data language statements, previously collected information can be placed in a named, global storage area called a context. <p> Thus, the post-action of the first condition that is satisfied is evaluated. If the signature of that condition is recursive, condition testing begins anew with the first condition; otherwise, cycling terminates. Implementation of the cycle catalog is quite complex; for a full discussion, see <ref> [Vil94] </ref>. 12 5 Results and Experiences To validate Rosetta, we modeled five data languages. We selected SQL and Quel because these languages are historically significant and for their continuing popularity in industry and academia.
References-found: 24

