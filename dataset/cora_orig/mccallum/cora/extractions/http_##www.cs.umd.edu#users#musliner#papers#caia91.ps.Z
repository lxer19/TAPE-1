URL: http://www.cs.umd.edu/users/musliner/papers/caia91.ps.Z
Refering-URL: http://www.cs.umd.edu/users/musliner/
Root-URL: 
Title: Execution Monitoring and Recovery Planning with Time  
Author: David J. Musliner Edmund H. Durfee Kang G. Shin 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: Focusing on Allen and Koomen's temporal planning scheme [1], this paper characterizes the possible locations for failure during plan execution. By observing the interval collapse criterion during plan generation, the planner is able to integrate the planning of goal-directed actions and execution verification actions. This allows the planner to schedule sensor usage and reason about sensing and data processing delays. We also present a simple and robust recovery planning scheme which inserts corrective steps into the original plan. We generate purely inserted recovery plans efficiently, without destroying the original plan and without unnecessary temporal inferencing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. F. Allen and J. A. Koomen, </author> <title> "Planning Using a Temporal World Model," </title> <booktitle> in Proc. Int'l Joint Conf. on Artificial Intelligence, </booktitle> <pages> pp. 741-747, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction To work in the real world, an AI system must often interact with a dynamic, time-constrained environment. Several planning systems have recognized the need to deal explicitly with deadlines, scheduled events, and actions that take time <ref> [1, 9, 12] </ref>. However, since real-world domains cannot be modeled perfectly, a system that predicts the results of planned actions in a simulated world must be able to detect and recover from discrepancies between its expected and actual state during execution. <p> The WM uses Koomen's TIMELOGIC system to implement Allen's interval temporal logic <ref> [1, 7] </ref>. In addition to the relational constraints which Allen defined to indicate relative order between intervals, TIME-LOGIC supports durational constraints indicating relative magnitude between intervals. Our WM code associates world data with intervals and provides a data indexing scheme. <p> Our planning system implements Allen and Koomen's algorithm <ref> [1] </ref>, using constraint-based interval temporal logic to generate complex plans involv lines connect equal interval endpoints. ing multiple agents, overlapping actions, and explicit time constraints like deadlines. Interval constraints also permit a "minimal commitment on order" strategy, so that temporal orderings are postponed as long as possible. <p> This behavior is the only way to remove a goal from the stack, and corresponds to Allen and Koomen's "interval collapse" <ref> [1] </ref>. If no interval collapse is possible, we must plan a step to achieve the goal, adding its postconditions to the WM and pushing its preconditions onto the goal stack.
Reference: [2] <author> J. A. Ambros-Ingerson and S. Steel, </author> <title> "Integrating Planning, Execution and Monitoring," </title> <booktitle> in Proc. Nat'l Conf. on Artificial Intelligence, </booktitle> <pages> pp. 83-88, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Our execution monitoring and replanning techniques are described in the context of the planning and execution system shown in Figure 1. We emphasize the temporal aspects of execution monitoring which are not addressed by previous integrated and reactive systems <ref> [2, 5, 11] </ref>. Examples will be drawn from a blocks-world domain in which a robot (R) performs the fine-grain actions Pick-Up, Move-Over, and Put-Down on three blocks (A, B, C) and one table (T ). Figure 2 summarizes a simple temporal plan to stack A on B. <p> Using the temporal information in our plan representation, we must balance the frequency of monitoring various conditions against the sensor resource limitations. 3.3 Taking Verification Time into Account One aspect of verification which other systems <ref> [2, 3] </ref> did not consider is the time cost of the monitoring actions themselves: sensing and processing sensed data can take significant time. Inserted verification actions can prolong the duration of a plan so that it no longer meets deadlines.
Reference: [3] <author> R. J. Doyle, D. J. Atkinson, and R. S. Doshi, </author> <title> "Generating Perception Requests and Expectations to Verify the Execution of Plans," </title> <booktitle> in Proc. Nat'l Conf. on Artificial Intelligence, </booktitle> <pages> pp. 81-88, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Recursing on this algorithm via an iterative control scheme gives the requisite operator-subgoaling, depth-first search. 3 Execution Monitoring Limited sensing and/or processing abilities may make it impossible to verify all of the expectations expressed by a plan <ref> [3, 9] </ref>. <p> Doyle, Atkinson, and Doshi noted that only postconditions which are used to satisfy preconditions are on the critical path representing the dependencies between actions <ref> [3] </ref>. Unfortunately, their state-based representation makes identifying these dependencies costly. Our temporal planning formulation makes the conditions on the critical path very easy to locate automatically: only those conditions involved in interval collapses must be verified. <p> However, conditions which have significant duration should be confirmed again before they are used as preconditions of later actions, since they may have been violated by an intervening unexpected event <ref> [3] </ref>. Even this double verification approach is undesirable if significant time elapses between the two verification actions, because unexpected conditions may not be detected quickly. For example, consider a robot which must grasp an object and move it thirty feet. <p> Using the temporal information in our plan representation, we must balance the frequency of monitoring various conditions against the sensor resource limitations. 3.3 Taking Verification Time into Account One aspect of verification which other systems <ref> [2, 3] </ref> did not consider is the time cost of the monitoring actions themselves: sensing and processing sensed data can take significant time. Inserted verification actions can prolong the duration of a plan so that it no longer meets deadlines. <p> Inserted verification actions can prolong the duration of a plan so that it no longer meets deadlines. Therefore, verification actions should be of concern to the planner itself, not relegated to a separate postprocessor as in the GRIPE and SAN systems <ref> [3, 4] </ref>. Just as regular plan steps use robots over significant time intervals, verification actions use sensors over time intervals. We have modified the basic temporal planning system to plan monitoring actions and take verification time into account. The system sensors are explicitly represented in the WM.
Reference: [4] <author> E. Gat et al., </author> <title> "Path Planning and Execution Monitoring for a Planetary Rover," </title> <booktitle> in Proc. IEEE Conf. on Robotics and Automation, </booktitle> <year> 1990. </year>
Reference-contexts: Inserted verification actions can prolong the duration of a plan so that it no longer meets deadlines. Therefore, verification actions should be of concern to the planner itself, not relegated to a separate postprocessor as in the GRIPE and SAN systems <ref> [3, 4] </ref>. Just as regular plan steps use robots over significant time intervals, verification actions use sensors over time intervals. We have modified the basic temporal planning system to plan monitoring actions and take verification time into account. The system sensors are explicitly represented in the WM.
Reference: [5] <author> M. P. Georgeff and A. L. Lansky, </author> <title> "Reactive Reasoning and Planning," </title> <booktitle> in Proc. Nat'l Conf. on Artificial Intelligence, </booktitle> <pages> pp. 677-682, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Our execution monitoring and replanning techniques are described in the context of the planning and execution system shown in Figure 1. We emphasize the temporal aspects of execution monitoring which are not addressed by previous integrated and reactive systems <ref> [2, 5, 11] </ref>. Examples will be drawn from a blocks-world domain in which a robot (R) performs the fine-grain actions Pick-Up, Move-Over, and Put-Down on three blocks (A, B, C) and one table (T ). Figure 2 summarizes a simple temporal plan to stack A on B.
Reference: [6] <author> M. Gini and G. Gini, </author> <title> "Towards Automatic Error Recovery in Robot Programs," </title> <booktitle> in Proc. Int'l Joint Conf. on Artificial Intelligence, </booktitle> <pages> pp. 821-823, </pages> <year> 1983. </year>
Reference-contexts: Figure 6 shows an example of a purely inserted recovery plan, corresponding to the replan request in Figure 5. The recovery plan is inserted after the failure, moving C off of B and rejoining the plan where it was disrupted. Gini and Gini describe a similar recovery insertion technique <ref> [6] </ref>, but their system only fires hand-coded recovery rules, and thus lacks the generality which our recovery method achieves by using the planner. We generate purely inserted recovery plans in three steps: 1.
Reference: [7] <author> J. A. Koomen, </author> <title> "The TIMELOGIC Temporal Reasoning System," </title> <institution> in University of Rochester Computer Science Department Technical Report 231, </institution> <year> 1989. </year>
Reference-contexts: The WM uses Koomen's TIMELOGIC system to implement Allen's interval temporal logic <ref> [1, 7] </ref>. In addition to the relational constraints which Allen defined to indicate relative order between intervals, TIME-LOGIC supports durational constraints indicating relative magnitude between intervals. Our WM code associates world data with intervals and provides a data indexing scheme.
Reference: [8] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Unlike the single and double verification strategies discussed in Section 3.2, our planner can exploit the temporal representation to schedule periodic verification actions for these persistent conditions. Sharing the limited sensor resources among the verification actions will require a sophisticated periodic task scheduling algorithm <ref> [8] </ref>. This algorithm must balance the frequency with which various concurrent conditions are monitored against the probability and recovery cost of an execution error. In its current form, our approach to execution monitoring has one potential disadvantage: plans that cannot be verified because of sensor limitations are simply not produced.
Reference: [9] <author> D. P. Miller, </author> <title> Planning by Search Through Simulations, </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1985. </year>
Reference-contexts: 1 Introduction To work in the real world, an AI system must often interact with a dynamic, time-constrained environment. Several planning systems have recognized the need to deal explicitly with deadlines, scheduled events, and actions that take time <ref> [1, 9, 12] </ref>. However, since real-world domains cannot be modeled perfectly, a system that predicts the results of planned actions in a simulated world must be able to detect and recover from discrepancies between its expected and actual state during execution. <p> Recursing on this algorithm via an iterative control scheme gives the requisite operator-subgoaling, depth-first search. 3 Execution Monitoring Limited sensing and/or processing abilities may make it impossible to verify all of the expectations expressed by a plan <ref> [3, 9] </ref>.
Reference: [10] <author> H. J. Porta, </author> <title> "Dynamic Replanning," </title> <booktitle> in Proc. Second Annual Workshop on Robotics and Expert Systems, </booktitle> <pages> pp. 109-115, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: By retaining all of the future section of the original plan, we avoid destroying the work done in previous planning cycles. Thus, the insertion method minimizes the disruption of potentially large plans, making it more efficient than recovery techniques which retain little or none of the original plan <ref> [10] </ref>. Retaining the old plan also avoids the difficulty of removing sections of the plan which depend on violated conditions. Backward chaining planners create plans from the goal back to the initial state, so the first steps to be executed are the ones most recently planned. <p> Thus chronological backtracking would begin by trying to remove plan steps which might already have (request-replan :violated-condition ((B UNDER NIL) INTERVAL18) :unexpected-conditions ((C ON B) (B UNDER C)) :last-action (Vis-Confirm (B UNDER NIL))) ance of C on B. been executed <ref> [10] </ref>. Dependency-directed backtracking and case-based reasoning methods address some of these difficulties, but removing information that depends on a violated condition can be costly because it may force the system to re-derive previous plan information.
Reference: [11] <author> M. J. Schoppers, </author> <title> "Universal Plans for Reactive Robots in Unpredictable Environments," </title> <booktitle> in Proc. Int'l Joint Conf. on Artificial Intelligence, </booktitle> <pages> pp. 1039-1046, </pages> <year> 1987. </year>
Reference-contexts: Our execution monitoring and replanning techniques are described in the context of the planning and execution system shown in Figure 1. We emphasize the temporal aspects of execution monitoring which are not addressed by previous integrated and reactive systems <ref> [2, 5, 11] </ref>. Examples will be drawn from a blocks-world domain in which a robot (R) performs the fine-grain actions Pick-Up, Move-Over, and Put-Down on three blocks (A, B, C) and one table (T ). Figure 2 summarizes a simple temporal plan to stack A on B.
Reference: [12] <author> S. A. Vere, </author> <title> "Planning in Time: Windows and Durations for Activities and Goals," </title> <journal> IEEE Trans. Pattern Analysis and Machine Intelligence, </journal> <volume> vol. PAMI-5, no. 3, </volume> <pages> pp. 246-267, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction To work in the real world, an AI system must often interact with a dynamic, time-constrained environment. Several planning systems have recognized the need to deal explicitly with deadlines, scheduled events, and actions that take time <ref> [1, 9, 12] </ref>. However, since real-world domains cannot be modeled perfectly, a system that predicts the results of planned actions in a simulated world must be able to detect and recover from discrepancies between its expected and actual state during execution.
References-found: 12

