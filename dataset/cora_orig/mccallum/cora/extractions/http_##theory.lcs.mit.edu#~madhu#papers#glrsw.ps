URL: http://theory.lcs.mit.edu/~madhu/papers/glrsw.ps
Refering-URL: http://theory.lcs.mit.edu/~madhu/papers.html
Root-URL: 
Title: Self-Testing/Correcting for Polynomials and for Approximate Functions to self-correcting. behaves in a more adversarial manner
Author: Peter Gemmell Richard Lipton Ronitt Rubinfeld Madhu Sudan Avi Wigderson 
Affiliation: IBM Almaden. -Hebrew University and Princeton University.  
Note: Princeton University. Supported in part by NSF Grant No. DCR 8420948. Princeton University. Supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), NSF-STC88-09648. U.C. Berkeley. Supported in part by NSF Grant No. CCR 88-96202. Part of this work was done while this author was visiting  Partially supported by the Wolfson Research Awards administered by the Israel Academy of Sciences and Humanities. 1 [12] independently introduces a notion which is essentially equivalent  
Abstract: The study of self-testing/correcting programs was introduced in [8] in order to allow one to use program P to compute function f without trusting that P works correctly. A self-tester for f estimates the fraction of x for which P (x) = f(x); and a self-corrector for f takes a program that is correct on most inputs and turns it into a program that is correct on every input with high probability 1 . Both access P only as a black-box and in some precise way are not allowed to compute the function f. Self-correcting is usually easy when the function has the random self-reducibility property. One class of such functions that has this property is the class of multivariate polynomials over finite fields [4] [12]. We extend this result in two directions. First, we show that polynomials are random self-reducible over more general domains: specifically, over the rationals and over noncommutative rings. Second, we show that one can get self-correctors even when the program satisfies weaker conditions, i.e. when the program has more errors, or when the program Self-testing is a much harder task. Previously it was known how to self-test for a few special examples of functions, such as the class of linear functions. We show that one can self-test the whole class of polynomial functions over Z p for prime p. We initiate the study of self-testing (and self-correcting) programs which only approximately compute f . This setting captures in particular the digital computation of real valued functions. We present a rigorous framework and obtain the first results in this area: namely that the class of linear functions, the log function and floating point exponentiation can be self-tested. All of the above functions also have self-correctors. fl U.C. Berkeley. Supported by NSF Grant No. CCR 88-13632
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Babai, L., </author> <title> "Trading Group Theory for Randomness", </title> <booktitle> Proc. 17th ACM Symposium on Theory of Computing, </booktitle> <year> 1985, </year> <pages> pp. 421-429. </pages>
Reference: [2] <author> Babai, L., </author> <title> "Local expansion of vertex-transitive graphs and random generation of finite groups", </title> <institution> University of Chicago TR90-31, </institution> <month> October </month> <year> 16,1990. </year>
Reference-contexts: Note that here uniform generation is trivial. In general, we know only a few more examples where uniform generation is possible. For any finite group, given by generators, almost uniform generation is possible by the recent Monte Carlo algorithm of <ref> [2] </ref>, but whether this result extends to the group algebra is open.
Reference: [3] <author> Babai, L., Fortnow, L., Lund, C., </author> <title> "Non-Deterministic Exponential Time has Two-Prover Interactive Protocols", </title> <booktitle> Proceedings of the 31st Annual Symposium on Foundations of Computer Science,, </booktitle> <year> 1990. </year>
Reference-contexts: This simple fact turned out to be a key ingredient in two recent results in complexity theory, mainly IP=PSPACE [14][18] and MIP=NEXPTIME <ref> [3] </ref>. Self-correcting is usually easy when the function has the random self-reducibility property [8][12]. <p> The rest of the proof of the theorem is as in [4][12]. 2.1.2 Fixed Point Arithmetic Our second theorem concerns computation over domains that are not as nice as finite fields. The only similar result we know appears in <ref> [3] </ref>. Motivated by the fact that every boolean function has a multilinear representation with small integer coefficients, they considered R = Z, D c = Z 2 n , D t = D s = Z 10d and showed Theorem 3 ([3]) Z d n (D c ) is 1 2d
Reference: [4] <author> Beaver, D., Feigenbaum, J., </author> <title> "Hiding Instance in Mul-tioracle Queries", </title> <note> STACS 1990. </note>
Reference-contexts: The interesting issues are of course for what rings and domains this is possible, how small should * be, and what is the complexity of the corrector program C, separating its actual computation and the number of calls to the black box P . The results of <ref> [4] </ref> [12] can be compressed to: Theorem 1 ([4][12]) If F is a finite field, jF j &gt; d + 1, then for every n, F d n is 1 3d+3 resilient with O (d) calls to P .
Reference: [5] <author> Blum, M., </author> <title> "Designing programs to check their work", </title> <note> Submitted to CACM. </note>
Reference: [6] <author> Blum, M., Kannan, S., </author> <title> "Program correctness checking ... and the design of programs that check their work", </title> <booktitle> Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <year> 1989. </year>
Reference-contexts: Furthermore, all require only a small multiplicative overhead over the running time of P and are different, simpler and faster than any correct program for f in a precise sense defined in <ref> [6] </ref>. Section 2 is devoted to self-correcting polynomial functions, and Section 3 is devoted to the self-testing of polynomial functions. <p> Lemma 15 For all k &gt; 0, Pr [disc (x) 1+ 5 2 k 0] &gt; 1 p Proof: Let i be the smallest value of k such that Pr <ref> [(1 + 5 2 k ) &lt; disc (x) &lt; 6] </ref> &gt; 2k p Z m j (1 + 5 2 k ) &lt; disc (x) &lt; 6g. Consider the set S 0 = f (x; y)jx; y 2 S; and disc (x) + disc (y) disc (x + y)g.
Reference: [7] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Program Result Checking Against Adaptive Programs and in Cryptographic Settings", </title> <booktitle> DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <year> 1989. </year> <month> 10 </month>
Reference-contexts: Here we address the case where the program is not a function, but an adversary A. Under the assumption that there are more than one independent copies of the program (noncommunicating adversaries), <ref> [7] </ref> show how to get checkers for any function that has a checker in the original model. Here we address the case of a single adversary A whose only limitation is space. The adversary can apply different programs depending on his memory state, which can be affected by previous queries.
Reference: [8] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Self--Testing/Correcting with Applications to Numerical Problems," </title> <booktitle> Proc. 22th ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year>
Reference-contexts: The details are left to the reader. 3 Self-Testing Polynomials Self-testing is a much harder task than self-correcting. In <ref> [8] </ref> it is shown how to get self-testers for the two special cases of any function that is downward self-reducible in addition to being random self-reducible, and any function that is linear. In this section we show that the much richer class of all polynomial functions can be self-tested. <p> In this section we show that the much richer class of all polynomial functions can be self-tested. As in <ref> [8] </ref>, our testers are of a nontraditional form: the tester is given a short specification of the function in the form of properties that the function must have, and ver ifies that these properties "usually" hold. <p> If the number of variables in the original multivariate polynomial is relatively small, this is more difficult than computing the polynomial function from scratch, and therefore is not different than the program in the sense defined by <ref> [8] </ref>. We now present the proof of Theorem 8 for the special case of univariate polynomials of degree d over Z p and when * O (1=d 2 ). <p> For y 2 A define h (y) = disc (y). For other values of y, pick x; z 2 A such that x+z = y and define h (y) = h (x)+h (z). It can be shown, by techniques similar to those in <ref> [8] </ref>, that h so defined has the property that 8y; Pr x [disc (y +x) 2 disc (x) + h (y)] &gt; 1 2 p *.
Reference: [9] <author> Carter, L., Wegman, M., </author> <title> "Universal Hash Functions", </title> <journal> Journal of Comp. and Sys. Sci. </journal> <month> 18 </month> <year> (1979) </year> <month> 143-154. </month>
Reference-contexts: When the choice of a field is ours, we have: Corollary 4 In polynomial time, we can achieve resiliency to any adversary that is polynomial space bounded! Proof: [of Theorem 7] Let H = fh : U ! Zg be a family of universal hash functions <ref> [9] </ref> from a domain U to range Z. This means that for any u; u 0 2 U , z; z 0 2 Z and random h 2 R H, Pr [h (u) = z; h (u 0 ) = z 0 = 1=jZj 2 .
Reference: [10] <author> Cleve, R., Luby, </author> <title> M.,"A Note on Self-Testing/ Correcting Methods for Trigonometric Functions", </title> <institution> International Computer Science Institute Technical Report TR-90-032, </institution> <month> July, </month> <year> 1990. </year>
Reference: [11] <author> Coppersmith, D., </author> <type> personal communication. </type>
Reference-contexts: We show that using the theory of error correcting codes [17], constant resiliency can be achieved. This the orem was proved independently, using similar techniques by Don Coppersmith <ref> [11] </ref>. Theorem 5 If F is a finite field, and for some m, 3d + 1 &lt; m, m divides jF j 1, then for every n, F d n is 1=9-resilient with O (m) calls to P .
Reference: [12] <author> Lipton, R., </author> <title> "New directions in testing", </title> <booktitle> Proceeding of DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <year> 1989. </year>
Reference-contexts: Rather than trust that P works correctly, a self-testing program for f ([8]) verifies that program P is correct on most inputs, and a self-correcting program ([8] <ref> [12] </ref>) for f takes a program P that is correct on most inputs and uses it to compute f correctly on every input (with high probability). <p> The interesting issues are of course for what rings and domains this is possible, how small should * be, and what is the complexity of the corrector program C, separating its actual computation and the number of calls to the black box P . The results of [4] <ref> [12] </ref> can be compressed to: Theorem 1 ([4][12]) If F is a finite field, jF j &gt; d + 1, then for every n, F d n is 1 3d+3 resilient with O (d) calls to P .
Reference: [13] <author> Lund, C., </author> <title> "The Power of Interaction", </title> <institution> University of Chicago Technical Report 91-01, </institution> <month> January 14, </month> <year> 1991. </year>
Reference: [14] <author> Lund, C., Fortnow, L., Karloff, H., Nisan, N., </author> <title> "Algebraic Methods for Interactive Proof Systems", </title> <booktitle> Proceedings of the 31st Annual Symposium on Foundations of Computer Science,, </booktitle> <year> 1990. </year>
Reference: [15] <author> Mansour, Y., Nisan, N., Tiwari, P., </author> <title> "The Computational Complexity of Universal Hashing", </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year>
Reference-contexts: Then, Pr [h (u) 2 B (h)jS (h)] * + 2jU j 1=4 . Proof: We use Lemma 10 of <ref> [15] </ref> and simple algebra to get: = i=1 (1=m) + max fi:jS i jm 2 jUjg Pr [h (u) 2 B i ] * + 2jU j 1=4 We used m = jU j 1=4 and the [15] lemma for a subset of hash functions of density at least jU j <p> Proof: We use Lemma 10 of <ref> [15] </ref> and simple algebra to get: = i=1 (1=m) + max fi:jS i jm 2 jUjg Pr [h (u) 2 B i ] * + 2jU j 1=4 We used m = jU j 1=4 and the [15] lemma for a subset of hash functions of density at least jU j 1=2 . Now we can fit our algorithm and the space s bounded adversary into this framework.
Reference: [16] <author> Nisan, N., </author> <title> "Psuedorandom Generators for Space-Bounded Computation", </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year>
Reference: [17] <author> Peterson, </author> <title> W.W., Weldon, E.J., Error Correcting Codes, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address>
Reference-contexts: The claim follows by the choice of L. 2.2 Programs with Weaker Constraints 2.2.1 Resiliency Note that the resiliency in Theorem 1 degrades with the degree. We show that using the theory of error correcting codes <ref> [17] </ref>, constant resiliency can be achieved. This the orem was proved independently, using similar techniques by Don Coppersmith [11]. <p> The queries that C makes are fP (x + ! i r)g m1 i=0 , This sequence differs from ff (x + ! i r)g m1 i=0 in at most m=3 places with probability 2=3. As the second sequence is a codeword in the generalized BCH code <ref> [17] </ref>, it can be recovered from the first efficiently, and then C (x) can be computed again by interpolation.
Reference: [18] <author> Shamir, Adi, "IP=PSPACE", </author> <booktitle> Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference: [19] <author> Szegedy, Mario, </author> <type> manuscript, </type> <month> January </month> <year> 1991. </year>
Reference: [20] <author> Van Der Waerden, </author> <title> B.L., </title> <journal> Algebra, </journal> <volume> Vol. 1, </volume> <publisher> Frederick Ungar Publishing Co., Inc., </publisher> <pages> pp. 86-91, </pages> <year> 1970. </year> <month> 11 </month>
Reference-contexts: Furthermore P d+1 i=0 ff i f (x + i t) can be computed in O (d 2 ) time using only additions and comparisons by the method of successive differences in <ref> [20] </ref>. 2 Theorem 2 If a random element of R can be uniformly generated, and jC (R) " R fl j d + 1, then for every n, R d n is 1=(2d)-resilient with O (d) calls to P . <p> P i i p 1 p i = p 1 .) Lemma 9 For all x; t 2 Z p , if ffi 1 2 (d+2) 2 , then P d+1 i=0 ff i g (x + i fl t) = 0 (and thus g is a degree d polynomial <ref> [20] </ref>).
References-found: 20

