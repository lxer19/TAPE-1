URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-96-33.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~juergen/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fbrauburgerjgieslg@inferenzsysteme.informatik.th-darmstadt.de  
Title: Termination Analysis for Partial Functions  
Author: Jurgen Brauburger and Jurgen Giesl 
Address: Alexanderstr. 10, 64283 Darmstadt, Germany  
Affiliation: FB Informatik, TH Darmstadt,  
Abstract: This paper deals with automated termination analysis for partial functional programs, i.e. for functional programs which do not terminate for each input. We present a method to determine their domains (resp. non-trivial subsets of their domains) automatically. More precisely, for each functional program a termination predicate algorithm is synthesized, which only returns true for inputs where the program is terminating. To ease subsequent reasoning about the generated termina tion predicates we also present a procedure for their simplification. 
Abstract-found: 1
Intro-found: 1
Reference: [BG96] <author> J. Brauburger & J. Giesl. </author> <title> Termination Analysis for Partial Functions. </title> <booktitle> In Proceedings of the Third International Static Analysis Symposium, </booktitle> <publisher> LNCS, </publisher> <address> Aachen, Germany, </address> <year> 1996. </year>
Reference-contexts: But while in [Man74] termination predicates have to be provided by the user, in this paper we present a technique to synthesize them automatically. ? Technical Report IBN 96/33, Technische Hochschule Darmstadt. This is an extended version of a paper <ref> [BG96] </ref> which appeared in the Proceedings of the Third International Static Analysis Symposium, Aachen, Germany, LNCS, Springer-Verlag, 1996. This work was supported by the Deutsche Forschungsgemeinschaft under grant no. Wa 652/7-1 as part of the focus program "Deduktion". 1 Instead of "termination predicates" Manna uses the notion of "input predicates".
Reference: [Bi + 86] <author> S. Biundo, B. Hummel, D. Hutter & C. Walther. </author> <title> The Karlsruhe Induction Theorem Proving System. Pr. </title> <booktitle> 8th CADE, </booktitle> <publisher> LNCS 230, Oxford, </publisher> <address> England, </address> <year> 1986. </year>
Reference-contexts: subsumption formula 1 ! 2 can be verified, then our simplification procedure replaces the term 2 by true. (Subsequently of course, in a conjunction the term true may be eliminated.) For the automated verification of subsumption formulas an induction theorem proving system is used (e.g. one of those described in <ref> [BM79, Bi + 86, Bu + 90, Wal94a] </ref>).
Reference: [BM79] <author> R. S. Boyer & J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. <p> To ease subsequent reasoning about termination predicates in the following sections we introduce a procedure to simplify the generated termination predicate algorithms which consists of four steps. 5.1 Application of Induction Lemmata First, the well-known induction lemma method by R. S. Boyer and J S. Moore <ref> [BM79] </ref> is used to eliminate (some of) the inequalities jr fl j &lt; jx fl j (which ensure that recursive calls are measure decreasing) from the termination predicate algorithms. Elimination of these inequalities simplifies the algorithms considerably and often enables the execution of subsequent simplification steps. <p> subsumption formula 1 ! 2 can be verified, then our simplification procedure replaces the term 2 by true. (Subsequently of course, in a conjunction the term true may be eliminated.) For the automated verification of subsumption formulas an induction theorem proving system is used (e.g. one of those described in <ref> [BM79, Bi + 86, Bu + 90, Wal94a] </ref>). <p> Therefore the procedure can also be combined with methods for the automated generation of suitable measure functions (e.g. the one we presented in [Gie95a, Gie95c]). For example, by using the measures suggested by this method, for all 5 82 algorithms from the database of <ref> [BM79] </ref> our procedure synthesizes termination predicates which always return true (i.e. in this way (absolute) termination of all these algorithms is proved automatically).
Reference: [BM88] <author> R. S. Boyer & J S. Moore. </author> <title> The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 117-172, </pages> <year> 1988. </year>
Reference-contexts: However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. Therefore these methods cannot be used to analyze the termination behaviour of partial functional programs, i.e. of programs which do not terminate for all inputs <ref> [BM88] </ref>.
Reference: [Bu + 90] <author> A. Bundy, F. van Harmelen, C. Horn & A. Smaill. </author> <title> The oyster-clam System. </title> <booktitle> In Proc. 10th CADE, </booktitle> <publisher> LNAI 449, </publisher> <address> Kaiserslautern, Germany, </address> <year> 1990. </year>
Reference-contexts: subsumption formula 1 ! 2 can be verified, then our simplification procedure replaces the term 2 by true. (Subsequently of course, in a conjunction the term true may be eliminated.) For the automated verification of subsumption formulas an induction theorem proving system is used (e.g. one of those described in <ref> [BM79, Bi + 86, Bu + 90, Wal94a] </ref>).
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of Rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1, </volume> 2):69-115, 1987. 
Reference-contexts: 1 Introduction Termination of algorithms is a central problem in software development and formal methods for termination analysis are essential for program verification. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (for surveys see e.g. <ref> [Der87, Ste95] </ref>) and of logic programs (e.g. [UV88, Plu90, SD94]), in this paper we focus on functional programs. Up to now all methods for automated termination analysis of functional programs (e.g. [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c]) aim to prove that a program terminates for each input.
Reference: [Gie95a] <author> J. Giesl. </author> <title> Generating Polynomial Orderings for Termination Proofs. Pr. </title> <booktitle> 6th Int. Conf. </booktitle> <address> Rewr. </address> <publisher> Tech. & App., LNCS 914, </publisher> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: The presented procedure for the generation of termination predicates works for any given measure function j:j. Therefore the procedure can also be combined with methods for the automated generation of suitable measure functions (e.g. the one we presented in <ref> [Gie95a, Gie95c] </ref>). For example, by using the measures suggested by this method, for all 5 82 algorithms from the database of [BM79] our procedure synthesizes termination predicates which always return true (i.e. in this way (absolute) termination of all these algorithms is proved automatically).
Reference: [Gie95b] <author> J. Giesl. </author> <title> Automated Termination Proofs with Measure Functions. </title> <booktitle> In Proc. 19th Annual German Conf. on AI, </booktitle> <publisher> LNAI 981, </publisher> <address> Bielefeld, Germany, </address> <year> 1995. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. <p> However, C. Walther presented a method to generate a certain class of induction lemmata for the size measure function j:j # automatically [Wal94b] and we recently generalized his approach towards measure functions based on arbitrary polynomial norms <ref> [Gie95b] </ref>. For instance, the induction lemma needed in the following example can be synthesized by Walther's and our method. While Boyer and Moore use induction lemmata for absolute termination proofs, we will now illustrate their use for the simplification of termination predicate algorithms. <p> Then the procedure eliminates subsumed terms and recursive calls. Finally, cases are eliminated by replacing conditionals by their results if possible. This simplification procedure for termination predicates works automatically. It is based on a method for the synthesis of induction lemmata <ref> [Wal94b, Gie95b] </ref> and it uses an induction theorem prover to verify the subsumption, recursion elimination, and case elimination formulas (which often is a simple task). 6 Conclusion We have presented a method to determine the domains (resp. non-trivial sub-domains) of partial functions automatically.
Reference: [Gie95c] <author> J. Giesl. </author> <title> Termination Analysis for Functional Programs using Term Order-ings. Pr. </title> <booktitle> 2nd Int. Stat. Analysis Symp., LNCS 983, </booktitle> <address> Glasgow, Scotland, </address> <year> 1995. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. <p> The presented procedure for the generation of termination predicates works for any given measure function j:j. Therefore the procedure can also be combined with methods for the automated generation of suitable measure functions (e.g. the one we presented in <ref> [Gie95a, Gie95c] </ref>). For example, by using the measures suggested by this method, for all 5 82 algorithms from the database of [BM79] our procedure synthesizes termination predicates which always return true (i.e. in this way (absolute) termination of all these algorithms is proved automatically).
Reference: [Gie96] <author> J. Giesl. </author> <title> Termination of Nested and Mutually Recursive Algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <note> 1996. To appear. </note>
Reference-contexts: Subsequently we introduced a procedure for the simplification of these generated termination predicate algorithms which also works automatically. The presented approach can be used for polymorphic types, too, and an extension to mutual recursion is possible in the same way as suggested in <ref> [Gie96] </ref> for absolute termination proofs. Termination analysis can also be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. [NN95].
Reference: [Hen80] <author> P. Henderson. </author> <title> Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1980. </year>
Reference-contexts: Furthermore, with our approach it is also possible to perform termination 5 As mentioned in [Wal94b] one algorithm (greatest.factor) must be slightly modified. 14 analysis for imperative programs: When translating an imperative program into a functional one, usually each while-loop is transformed into a partial function, cf. <ref> [Hen80] </ref>. Now the termination predicates for these partial "loop functions" can be used to prove termination of the whole imperative program. Acknowledgements.
Reference: [Hol91] <author> C. K. Holst. </author> <title> Finiteness Analysis. </title> <booktitle> In Proc. 5th ACM Conf. Functional Prog. Languages & Comp. Architecture, LNCS 523, </booktitle> <address> Cambridge, MA, USA, </address> <year> 1991. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable.
Reference: [Man74] <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: Therefore these methods cannot be used to analyze the termination behaviour of partial functional programs, i.e. of programs which do not terminate for all inputs [BM88]. In this paper we automate Manna's approach for termination analysis of "partial programs" <ref> [Man74] </ref>: For every algorithm defining a function f there has to be a termination predicate 1 f which specifies the "admissible input" of f (i.e. evaluation of f must terminate for each input admitted by the termination predicate). But while in [Man74] termination predicates have to be provided by the user, <p> automate Manna's approach for termination analysis of "partial programs" <ref> [Man74] </ref>: For every algorithm defining a function f there has to be a termination predicate 1 f which specifies the "admissible input" of f (i.e. evaluation of f must terminate for each input admitted by the termination predicate). But while in [Man74] termination predicates have to be provided by the user, in this paper we present a technique to synthesize them automatically. ? Technical Report IBN 96/33, Technische Hochschule Darmstadt. <p> For that purpose we have automated 13 the approach for termination analysis suggested by Manna <ref> [Man74] </ref>. Our analy-sis uses termination predicates which represent conditions that are sufficient for the termination of the algorithm under consideration. Based on sufficient requirements for termination predicates we have developed a procedure for the automated synthesis of termination predicate algorithms.
Reference: [NN95] <author> F. Nielson & H. R. Nielson. </author> <title> Termination Analysis based on Operational Semantics. </title> <type> Technical Report, </type> <institution> Aarhus University, Denmark, </institution> <year> 1995. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. <p> The presented approach can be used for polymorphic types, too, and an extension to mutual recursion is possible in the same way as suggested in [Gie96] for absolute termination proofs. Termination analysis can also be extended to higher-order functions by inspecting the decrease of their first-order arguments, cf. <ref> [NN95] </ref>. To determine non-trivial subdomains of higher-order functions which are not always terminating, in general one does not only need a termination predicate for each function f but one also has to generate termination predicates for the (higher-order) results of each function.
Reference: [Plu90] <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs. </title> <publisher> LNAI 446, Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: While most work on the automation of termination proofs has been done in the areas of term rewriting systems (for surveys see e.g. [Der87, Ste95]) and of logic programs (e.g. <ref> [UV88, Plu90, SD94] </ref>), in this paper we focus on functional programs. Up to now all methods for automated termination analysis of functional programs (e.g. [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c]) aim to prove that a program terminates for each input.
Reference: [SD94] <author> D. De Schreye & S. Decorte. </author> <title> Termination of Logic Programs: The NeverEnding Story. </title> <journal> Journal of Logic Programming 19,20:199-260, </journal> <year> 1994. </year>
Reference-contexts: While most work on the automation of termination proofs has been done in the areas of term rewriting systems (for surveys see e.g. [Der87, Ste95]) and of logic programs (e.g. <ref> [UV88, Plu90, SD94] </ref>), in this paper we focus on functional programs. Up to now all methods for automated termination analysis of functional programs (e.g. [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c]) aim to prove that a program terminates for each input.
Reference: [Ste95] <author> J. Steinbach. </author> <title> Simplification Orderings: History of Results. </title> <journal> Fundamenta In-formaticae 24 </journal> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Termination of algorithms is a central problem in software development and formal methods for termination analysis are essential for program verification. While most work on the automation of termination proofs has been done in the areas of term rewriting systems (for surveys see e.g. <ref> [Der87, Ste95] </ref>) and of logic programs (e.g. [UV88, Plu90, SD94]), in this paper we focus on functional programs. Up to now all methods for automated termination analysis of functional programs (e.g. [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c]) aim to prove that a program terminates for each input.
Reference: [UV88] <author> J. D. Ullman & A. van Gelder. </author> <title> Efficient Tests for Top-Down Termination of Logical Rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year>
Reference-contexts: While most work on the automation of termination proofs has been done in the areas of term rewriting systems (for surveys see e.g. [Der87, Ste95]) and of logic programs (e.g. <ref> [UV88, Plu90, SD94] </ref>), in this paper we focus on functional programs. Up to now all methods for automated termination analysis of functional programs (e.g. [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c]) aim to prove that a program terminates for each input.
Reference: [Wal88] <author> C. Walther. </author> <title> Argument-Bounded Algorithms as a Basis for Automated Termination Proofs. </title> <booktitle> In Proc. 9th CADE, LNCS 310, </booktitle> <address> Argonne, IL, </address> <year> 1988. </year>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable.
Reference: [Wal94a] <author> C. Walther. </author> <title> Mathematical Induction. </title> <editor> In D. M. Gabbay, C. J. Hogger, and J. A. Robinson (eds.), </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> vol. 2, </volume> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: subsumption formula 1 ! 2 can be verified, then our simplification procedure replaces the term 2 by true. (Subsequently of course, in a conjunction the term true may be eliminated.) For the automated verification of subsumption formulas an induction theorem proving system is used (e.g. one of those described in <ref> [BM79, Bi + 86, Bu + 90, Wal94a] </ref>).
Reference: [Wal94b] <author> C. Walther. </author> <title> On Proving the Termination of Algorithms by Machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year> <month> 43 </month>
Reference-contexts: Up to now all methods for automated termination analysis of functional programs (e.g. <ref> [BM79, Wal88, Hol91, Wal94b, NN95, Gie95b, Gie95c] </ref>) aim to prove that a program terminates for each input. However, if the termination proof fails then these methods provide no means to find a (sub-)domain where termination is provable. <p> However, C. Walther presented a method to generate a certain class of induction lemmata for the size measure function j:j # automatically <ref> [Wal94b] </ref> and we recently generalized his approach towards measure functions based on arbitrary polynomial norms [Gie95b]. For instance, the induction lemma needed in the following example can be synthesized by Walther's and our method. <p> According to <ref> [Wal94b] </ref> we call formulas like (4) and (5) subsumption formulas. <p> Now we eliminate the recursive call of quotient according to the recursion elimination technique of Walther <ref> [Wal94b] </ref>. If we can verify that evaluation of a recursive call f (r fl ) always yields the same result (i.e. it always yields true or it always yields false) then we can replace the recursive call f (r fl ) by this result. <p> Then the procedure eliminates subsumed terms and recursive calls. Finally, cases are eliminated by replacing conditionals by their results if possible. This simplification procedure for termination predicates works automatically. It is based on a method for the synthesis of induction lemmata <ref> [Wal94b, Gie95b] </ref> and it uses an induction theorem prover to verify the subsumption, recursion elimination, and case elimination formulas (which often is a simple task). 6 Conclusion We have presented a method to determine the domains (resp. non-trivial sub-domains) of partial functions automatically. <p> Furthermore, with our approach it is also possible to perform termination 5 As mentioned in <ref> [Wal94b] </ref> one algorithm (greatest.factor) must be slightly modified. 14 analysis for imperative programs: When translating an imperative program into a functional one, usually each while-loop is transformed into a partial function, cf. [Hen80].
References-found: 21

