URL: http://www.cs.toronto.edu/~david/papers-ilps94.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: fdavid,chomicki,rogersg@cis.ksu.edu  
Title: Datalog with Integer Periodicity Constraints  
Author: David Toman, Jan Chomicki, and David S. Rogers 
Address: KS-66506  
Affiliation: Dept. of Comp. and Info. Sci. Kansas State University, Manhattan,  
Abstract: This paper introduces a generalization of Datalog based on the notion of integer periodicity constraints. A closed form evaluation procedure running in PTIME for this class of constraints is developed. The periodicity constraints are then combined with integer (gap-)order constraints and an evaluation procedure for the combination is developed. A general method for combining different classes of constraints in the framework of Datalog is also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baudinet, M., Chomicki, J., Wolper, P. </author> <title> Temporal Deductive Databases. In Temporal Databases: Theory, Design, And Implementation, Tansel, </title> <editor> A. et al. (editors). </editor> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: 1 Introduction Generalized databases <ref> [1, 10, 12] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint) tuples. A number of query languages over such databases have been studied. <p> Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases (where the time component is usually isomorphic to integers). The constraints are used to represent possibly infinite sets of time points <ref> [1, 10, 11] </ref>. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases [8]. Example 1.1 A simple example of a Datalog program that uses integer constraints is a database of plane connections between cities. <p> Is there a limited version of negation that can be included in the language without this penalty? Note that for periodicity constraints alone this is not a problem: the constraint of the form x 6 k y + c can be introduced without any problems. Expressiveness. In <ref> [1] </ref> the expressiveness of a number of deductive and constraint query languages is discussed. However, only monadic programs are considered. It is interesting to see whether the expressiveness of query languages defined in this paper can be also formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets.
Reference: [2] <author> Baudinet, M., Nezette, M., Wolper P. </author> <title> On the Representation of Infinite Temporal Data and Queries. </title> <booktitle> 10th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 280-290, </pages> <year> 1991. </year>
Reference-contexts: In particular, order constraints are not expressible in it. Also, the unary successor symbol is used in the deductive layer on top of the database. Our approach allows a representation of infinite relations to be stored directly into the database. Another extension of Datalog was proposed in <ref> [2] </ref>. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, [10, 11] can't handle recursion, [4, 5] can't handle ordering, and [2] does not <p> proposed in <ref> [2] </ref>. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, [10, 11] can't handle recursion, [4, 5] can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows. Section 2 gives the definition of a finite representation of periodicity constraints together with the operations needed for bottom-up evaluation.
Reference: [3] <author> Chandra, A. K. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 156-178, </pages> <year> 1982. </year>
Reference-contexts: The evaluation for order constraints is based on [13, 14]. Also a general method for incorporating various classes of constraints into Datalog is studied. A generally accepted measure of performance of a bottom-up evaluation procedure is data complexity <ref> [3, 15] </ref>, which measures the complexity of answering a fixed query w.r.t. the size of the database (the size of the underlying database usually dominates the size of the query by several orders of magnitude). The proposed bottom-up evaluation procedure has polynomial data complexity.
Reference: [4] <author> Chomicki, J., Imielinski, T. </author> <title> Temporal Deductive Databases and Infinite Objects. </title> <booktitle> Proc. 7th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 61-73, </pages> <year> 1988. </year>
Reference-contexts: This arrangement provides a potentially more general framework which could be adapted to combinations of other constraint languages. Another approach comes from the area of temporal databases. In <ref> [4, 5] </ref> Datalog was extended with a limited use of a successor function (the use was restricted to a single distinguished argument in each literal). This made it possible to represent infinite periodic sets of integers using Horn rules. <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, [10, 11] can't handle recursion, <ref> [4, 5] </ref> can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows.
Reference: [5] <author> Chomicki, J., Imielinski, T. </author> <title> Finite Representation of Infinite Query Answers, </title> <journal> In ACM Transactions on Database Systems, </journal> <pages> pp. 181-223, (18) 2, </pages> <year> 1993. </year>
Reference-contexts: This arrangement provides a potentially more general framework which could be adapted to combinations of other constraint languages. Another approach comes from the area of temporal databases. In <ref> [4, 5] </ref> Datalog was extended with a limited use of a successor function (the use was restricted to a single distinguished argument in each literal). This made it possible to represent infinite periodic sets of integers using Horn rules. <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, [10, 11] can't handle recursion, <ref> [4, 5] </ref> can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows.
Reference: [6] <author> Enderton, H. B. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference: [7] <author> Hardy, G. H. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <year> 1979. </year>
Reference-contexts: To combine constraints over the same variables we use the following proposition <ref> [7] </ref>: Proposition 2.4 (Chinese Remainder Theorem) Let x k 1 (y+c 1 ) and x k 2 (y + c 2 ).
Reference: [8] <author> Jensen, C. S., Snodgrass, R. </author> <title> Temporal Specialization and Generalization. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1993. </year>
Reference-contexts: The constraints are used to represent possibly infinite sets of time points [1, 10, 11]. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases <ref> [8] </ref>. Example 1.1 A simple example of a Datalog program that uses integer constraints is a database of plane connections between cities.
Reference: [9] <author> Jaffar, J., Lassez, J. L. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp 111-119, </pages> <year> 1987. </year>
Reference-contexts: In this paper we study generalized Datalog programs (function-free logic programs) that operate on constraint tuples in the place of ground atoms. This idea comes from constraint logic programming <ref> [9] </ref> and allows declarative specification of problems not solvable using the standard Datalog framework (e.g., reasoning about infinite periodic sets of integers).
Reference: [10] <author> Kabanza, F., Stevenne, J-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <booktitle> In 9th ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction Generalized databases <ref> [1, 10, 12] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint) tuples. A number of query languages over such databases have been studied. <p> Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases (where the time component is usually isomorphic to integers). The constraints are used to represent possibly infinite sets of time points <ref> [1, 10, 11] </ref>. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases [8]. Example 1.1 A simple example of a Datalog program that uses integer constraints is a database of plane connections between cities. <p> The proposed bottom-up evaluation procedure has polynomial data complexity. There are other proposals that introduce classes of infinite integer relations to query languages. Datalog with (gap-)order constraints was introduced in [13]. In <ref> [10, 11] </ref>, relational calculus over generalized relational databases with order constraints and linear repeating points was studied. (A linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint.) But the proposed approach was <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, <ref> [10, 11] </ref> can't handle recursion, [4, 5] can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows. <p> It is easy to see, that the variable y was successfully eliminated and the resulting constraint is a disjunction of conjunctions of periodicity and gap-order constraints. This idea is used for the projection operation needed in the TP ;&lt; operator (a similar idea was used in <ref> [10, 11] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit normalization (in the sense of [10, 11]) of constraint tuples). Algorithm 4.6 (Projection) Let G be a periodicity graph and H be a gap-graph. <p> This idea is used for the projection operation needed in the TP ;&lt; operator (a similar idea was used in <ref> [10, 11] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit normalization (in the sense of [10, 11]) of constraint tuples). Algorithm 4.6 (Projection) Let G be a periodicity graph and H be a gap-graph. Let y be a node in both G and H.
Reference: [11] <author> Kabanza, F., Stevenne, J-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> Journal of Computer and System Sciences, </journal> <note> 1994 (in print). </note>
Reference-contexts: Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases (where the time component is usually isomorphic to integers). The constraints are used to represent possibly infinite sets of time points <ref> [1, 10, 11] </ref>. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases [8]. Example 1.1 A simple example of a Datalog program that uses integer constraints is a database of plane connections between cities. <p> The proposed bottom-up evaluation procedure has polynomial data complexity. There are other proposals that introduce classes of infinite integer relations to query languages. Datalog with (gap-)order constraints was introduced in [13]. In <ref> [10, 11] </ref>, relational calculus over generalized relational databases with order constraints and linear repeating points was studied. (A linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint.) But the proposed approach was <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: [13, 14] can't handle periodicity constraints, <ref> [10, 11] </ref> can't handle recursion, [4, 5] can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows. <p> It is easy to see, that the variable y was successfully eliminated and the resulting constraint is a disjunction of conjunctions of periodicity and gap-order constraints. This idea is used for the projection operation needed in the TP ;&lt; operator (a similar idea was used in <ref> [10, 11] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit normalization (in the sense of [10, 11]) of constraint tuples). Algorithm 4.6 (Projection) Let G be a periodicity graph and H be a gap-graph. <p> This idea is used for the projection operation needed in the TP ;&lt; operator (a similar idea was used in <ref> [10, 11] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit normalization (in the sense of [10, 11]) of constraint tuples). Algorithm 4.6 (Projection) Let G be a periodicity graph and H be a gap-graph. Let y be a node in both G and H.
Reference: [12] <author> Kanellakis, P. C., Kuper, G. M., Revesz, P.Z. </author> <title> Constraint Query Languages, </title> <booktitle> Proc. 9th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 299-313, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Generalized databases <ref> [1, 10, 12] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint) tuples. A number of query languages over such databases have been studied. <p> However, only monadic programs are considered. It is interesting to see whether the expressiveness of query languages defined in this paper can be also formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets. In this respect they differ from most common constraint languages. <ref> [12] </ref> describe how to adapt interval management techniques to constraint databases. But this works only for convex sets. Thus periodicity constraints call for new storage management techniques.
Reference: [13] <author> Revesz, P. Z. </author> <title> A Closed Form for Datalog Queries with Integer Order. </title> <booktitle> Proc. 3rd International Conference on Database Theory, </booktitle> <pages> pp 187-201, </pages> <publisher> Springer-Verlag LNCS 470, </publisher> <year> 1990. </year>
Reference-contexts: The main contribution of this paper is the definition of a closed form bottom-up evaluation procedure for Datalog programs with integer periodicity and order constraints. This language can be used as a simple but very expressive query language over generalized databases. The evaluation for order constraints is based on <ref> [13, 14] </ref>. Also a general method for incorporating various classes of constraints into Datalog is studied. <p> The proposed bottom-up evaluation procedure has polynomial data complexity. There are other proposals that introduce classes of infinite integer relations to query languages. Datalog with (gap-)order constraints was introduced in <ref> [13] </ref>. <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: <ref> [13, 14] </ref> can't handle periodicity constraints, [10, 11] can't handle recursion, [4, 5] can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows. <p> In this section we consider the possibilities of combining different classes of constraints over the same domain (in our case integers). 4.1 Gap-order constraints First we combine the constraint language developed so far with Datalog &lt;Z (Datalog with gap-order constraints) <ref> [13, 14] </ref>. Definition 4.1 (Gap-order constraint) Let u; l be integers, c be a nonnegative integer, and x; y; : : : be variables over integers. <p> Then a finite conjunction of formulas of the form l &lt; x, x &lt; u, and x + c &lt; y is called a gap-order constraint. Conjunctions of gap-order constraints can be efficiently represented using gap graphs <ref> [13] </ref> (directed acyclic graphs where the nodes represent the variables and the lower and the upper bound of the constraints, and the edges represent the gaps, i.e., the minimal integer distances between the nodes). In this representation we also have all the needed operations for closed form bottom-up evaluation. <p> Fortunately Theorem 4.4 Consistency checking of a conjunction of a periodicity graph cons-tructed only from simple constraints and a gap graph can be computed in PTIME. P r o o f: By generalization of the consistency checking procedure given in <ref> [13] </ref>; the algorithm computes the length of every path from the lower to the upper bound of the gap-graph by adding the gap sizes on the edges of the path. <p> Lemma 4.10 Let P be a Datalog Z;&lt;Z program. Then (TP i (;) and &lt; (TP i &lt; (;) Corollary 4.11 The bottom-up evaluation of any Datalog Z;&lt;Z program terminates. P r o o f: Immediate from Lemma 4.10 and termination of the bottom-up evaluation procedure for Datalog &lt;Z <ref> [13] </ref>. To show polynomial tuple recognition procedure for Datalog Z;&lt;Z programs we use the same technique: the tuple recognition will then run in PTIME (follows from Theorem 3.1 and complexity of the TEST algorithm in [13]) 2 . 4.2 Equality constraints So far we haven't mentioned the most natural class of <p> f: Immediate from Lemma 4.10 and termination of the bottom-up evaluation procedure for Datalog &lt;Z <ref> [13] </ref>. To show polynomial tuple recognition procedure for Datalog Z;&lt;Z programs we use the same technique: the tuple recognition will then run in PTIME (follows from Theorem 3.1 and complexity of the TEST algorithm in [13]) 2 . 4.2 Equality constraints So far we haven't mentioned the most natural class of constraints|the equality constraints, which are needed to include the "standard" Datalog over integers. In [13] the equality constraints are handled by adding extra information to the gap-graph. <p> technique: the tuple recognition will then run in PTIME (follows from Theorem 3.1 and complexity of the TEST algorithm in <ref> [13] </ref>) 2 . 4.2 Equality constraints So far we haven't mentioned the most natural class of constraints|the equality constraints, which are needed to include the "standard" Datalog over integers. In [13] the equality constraints are handled by adding extra information to the gap-graph. In the case of Datalog Z it can be done the same way (in all cases we need some mechanism to represent a single constraint of the form x = y).
Reference: [14] <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)-Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: The main contribution of this paper is the definition of a closed form bottom-up evaluation procedure for Datalog programs with integer periodicity and order constraints. This language can be used as a simple but very expressive query language over generalized databases. The evaluation for order constraints is based on <ref> [13, 14] </ref>. Also a general method for incorporating various classes of constraints into Datalog is studied. <p> Another extension of Datalog was proposed in [2]. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive|termination of query evaluation in this language cannot be guaranteed. Summarizing: <ref> [13, 14] </ref> can't handle periodicity constraints, [10, 11] can't handle recursion, [4, 5] can't handle ordering, and [2] does not guarantee termination. Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows. <p> In this section we consider the possibilities of combining different classes of constraints over the same domain (in our case integers). 4.1 Gap-order constraints First we combine the constraint language developed so far with Datalog &lt;Z (Datalog with gap-order constraints) <ref> [13, 14] </ref>. Definition 4.1 (Gap-order constraint) Let u; l be integers, c be a nonnegative integer, and x; y; : : : be variables over integers.
Reference: [15] <author> Vardi, M. Y. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In ACM SIGACT Symposium on Theory of Computing, </booktitle> <pages> pp 137-146, </pages> <year> 1982. </year>
Reference-contexts: The evaluation for order constraints is based on [13, 14]. Also a general method for incorporating various classes of constraints into Datalog is studied. A generally accepted measure of performance of a bottom-up evaluation procedure is data complexity <ref> [3, 15] </ref>, which measures the complexity of answering a fixed query w.r.t. the size of the database (the size of the underlying database usually dominates the size of the query by several orders of magnitude). The proposed bottom-up evaluation procedure has polynomial data complexity.
Reference: [16] <author> Williams, H. P. </author> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> In Journal of Combinatorial Theory (A) 21, </journal> <pages> pp 118-123, </pages> <year> 1976. </year>
Reference-contexts: We also use the consistency check from Theorem 4.4. But the most complex operation| the quantifier elimination|has to take care of the interactions of periodicity constraints with gap-order constraints <ref> [16] </ref>.
References-found: 16

