URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/tr-94-069.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/
Root-URL: http://www.icsi.berkeley.edu
Email: (whetten@cs.berkeley.edu)  (tmont@cerc.wvu.edu)  (kaplan@cs.uiuc.edu)  
Title: A HIGH PERFORMANCE TOTALLY ORDERED MULTICAST PROTOCOL  
Author: Brian Whetten, Todd Montgomery, Simon Kaplan, 
Keyword: Congestion control, internetworking, distributed network algorithms, reliable multicast  
Address: Berkeley  West Virginia University  Champaign-Urbana  
Affiliation: University of California at  University of Illinois at  
Abstract: This paper presents the Reliable Multicast Protocol (RMP). RMP provides a totally ordered, reliable, atomic multicast service on top of an unreliable multicast datagram service such as IP Multicasting. RMP is fully and symmetrically distributed so that no site bears an undue portion of the communication load. RMP provides a wide range of guarantees, from unreliable delivery to totally ordered delivery, to K-resilient, majority resilient, and totally resilient atomic delivery. These QoS guarantees are selectable on a per packet basis. RMP provides many communication options, including virtual synchrony, a publisher/subscriber model of message delivery, a client/server model of delivery, an implicit naming service, mutually exclusive handlers for messages, and mutually exclusive locks. It has commonly been held that a large performance penalty must be paid in order to implement total ordering -RMP discounts this. On SparcStation5's on a 1250 KB/sec Ethernet, RMP provides totally ordered packet delivery to one destination at 1070 KB/sec throughput and with 4.0 ms packet latency. The performance stays roughly constant independent of the number of destinations. For two or more destinations on a LAN, RMP provides higher throughput than any protocol that does not use multicast or broadcast. 
Abstract-found: 1
Intro-found: 1
Reference: [ADKM91] <author> Y. Amir, D. Dolev, S. Kramer and D. Malki. "Transis: </author> <title> A Communication Subsystem for High Availability." </title> <institution> Technical Report CS9113 , Hebrew University of Jerusalem, </institution> <month> Nov. </month> <year> 1991. </year>
Reference: [AFM92] <author> S. Armstrong, A. Freier, K. Marzullo. </author> <title> "Multicast Transport Protocol". </title> <month> RFC1301 . (February, </month> <year> 1992). </year>
Reference-contexts: For example, for the ToTo protocol to send to a group of 8 destinations under heavy, periodic load from all sources (the best case), the latency is 23.8 ms. This increases to 114.1 ms for lightly loaded poisson sources. The Multicast Transport Protocol (MTP) <ref> [AFM92] </ref> is an example of an asymmetric reliable multicast protocol. One site is the communication master which grants "tokens" to group members to allow them to send data. These tokens provide both flow control and total ordering of messages.
Reference: [AMSM92] <author> D. A. Agarwal, P. M. Melliar-Smith, and L. E. Moser. "Totem: </author> <title> A protocol for message ordering in a wide 100 500 900 1300 Number of Destinations KB /s e c Throughput Non-Multicast Maximum MBUS I 0 2 4 1 2 3 4 5 6 7 8 Number of Destinations Lat en cy (m il li sec on ds ) 19 area network." </title> <booktitle> Proceedings of the First ISMM International Conference on Computer Communications and Networks (San Diego, </booktitle> <address> CA, </address> <month> June </month> <year> 1992). </year> <pages> pp. 1-5. </pages>
Reference-contexts: It provides both total ordering of messages and reliable multicast, but has very limited scalability, since all packets must be routed through a central point, and duplicate copies sent to each destination. The Totem protocol <ref> [AMSM92] </ref> is perhaps closest to RMP in its approach, and has reported similar throughput levels to RMP under heavy load. It also uses a rotating token ring approach, but only provides for a single ring for each broadcast domain.
Reference: [ARP93] <author> R. Aiello, E. Pagani, G. P. Rossi, </author> <title> "Design of a Reliable Multicast Protocol". </title> <booktitle> Proceedings of IEEE INFOCOM '93 (San Francisco, </booktitle> <month> March </month> <year> 1993). </year> <pages> pp. 75-81. </pages>
Reference: [APR93] <author> R. Aiello, G. P. Rossi, E. Pagani. </author> <title> "Casual Ordering in Reliable Group Communications." </title> <booktitle> Proceedings of ACM SIGCOMM '93 (San Francisco, </booktitle> <month> Sept. </month> <year> 1993). </year> <pages> pp. 106-115. </pages>
Reference: [BLNS82] <author> A. Birrell, R. Levin, R. Needham, M. Schroeder. "Grapevine: </author> <title> An exercise in distributed computing." </title> <journal> Communications of the ACM , 25, </journal> <volume> 4, </volume> <month> April </month> <year> 1982. </year> <pages> pp. 260-274. </pages>
Reference-contexts: The membership of a group will usually change over time. A given list of the members of a group is called a membership view. A membership view is always created by a single RMP process, and is identified by a membership view ID. Similarly to Grapevine <ref> [BLNS82] </ref>, a membership view ID consists of an ID that is unique across the breadth of the internetwork concatenated with a counter that is unique across the maximum TTL for that ID. <p> RMP supports both of these addressing models, and supports both the peer group model of communication and the the clientserver model of communication. Protocols such as TCP and UDP require explicit naming of the destinations of communication, while systems such as Grapevine <ref> [BLNS82] </ref> and the MessageBus [Carroll93] allow implicit naming through a publisher/subscriber model of communication.
Reference: [BSS91] <author> K. Birman, A. Schiper, P. Stephenson. </author> <title> "Lightweight Causal and Atomic Group Multicast." </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 9, </volume> <month> 3 (Aug. </month> <year> 1991). </year> <pages> pp. 272-314. </pages>
Reference-contexts: It can also efficiently provide delivery of packets in both total and causal order, using causal ordering as defined in [Lamp78]. Totally ordered delivery also provides virtual synchrony, as first defined by the ISIS project <ref> [BSS91] </ref>. Virtual synchrony guarantees that when new members join or leave a group these operations appear to be atomic, so that the sets of messages delivered before and after each membership change are consistent across all sites. <p> In addition, because it only allows a single sender to transmit at a time it will provide lower throughput over longer latency networks. To alleviate this problem they have proposed, but not implemented, gateways to link multiple broadcast domains together. The ISIS system <ref> [BSS91] </ref>, [Birman93] is one of the pioneering protocols in this field. It provides causal ordering and, if desired, total ordering of messages on top of a reliable multicast protocol. The reliable multicast protocol requires separate acknowledgments from each destination, which limits performance. <p> Totally ordered packets are also causally ordered, as per Lamport's definition [Lamp78]. ISIS first defined the notion of virtual synchrony <ref> [BSS91] </ref>, [Birman93]. Virtual synchrony often allows a distributed application to execute as if its communication was synchronous, when it is actually asynchronous. The key requirement for virtual synchrony is that all sites see the same set of messages before and after a group membership change.
Reference: [BiCl94] <author> K. Birman, T. Clark. </author> <title> "Performance of the Isis Distributed Computing Toolkit." </title> <type> Technical Report TR-94-1432, </type> <institution> Dept. of Computer Science, Cornell University. </institution>
Reference-contexts: This belief has come about in large part due to the experiences researchers have had with the early versions of ISIS, which for a long time was the only system of this type available. ISIS has since become much faster 3 <ref> [BiCl94] </ref>, but the misconception remains. Experience with RMP belies this concept. RMP was tested on 8 SparcStation5's on a 10 Mb/sec (1250 KB/sec) Ethernet. In this environment, the throughput to a single destination is 1070 KB/sec, or 86% of the network capacity. <p> While we have not yet been able to make fair comparisons to other protocols, the data that we have shows that the latency of protocols that do not take advantage of hardware multicast also scales linearly as a function of N <ref> [BiCl94] </ref>. We have also performed some tests of RMP over internetworks. One test was over a dedicated mbone connected between West Virginia University and the University of Illinois at Champaign-Urbana, and another was over two Ethernets connected by a gateway.
Reference: [Birman93] <author> K. Birman. </author> <title> "The Process Group Approach to Reliable Distributed Computing." </title> <journal> Communications of the ACM. </journal> <month> December, </month> <year> 1993, </year> <month> 36,12. </month> <pages> pp. 37-53. </pages>
Reference-contexts: In addition, because it only allows a single sender to transmit at a time it will provide lower throughput over longer latency networks. To alleviate this problem they have proposed, but not implemented, gateways to link multiple broadcast domains together. The ISIS system [BSS91], <ref> [Birman93] </ref> is one of the pioneering protocols in this field. It provides causal ordering and, if desired, total ordering of messages on top of a reliable multicast protocol. The reliable multicast protocol requires separate acknowledgments from each destination, which limits performance. <p> Totally ordered packets are also causally ordered, as per Lamport's definition [Lamp78]. ISIS first defined the notion of virtual synchrony [BSS91], <ref> [Birman93] </ref>. Virtual synchrony often allows a distributed application to execute as if its communication was synchronous, when it is actually asynchronous. The key requirement for virtual synchrony is that all sites see the same set of messages before and after a group membership change.
Reference: [CaMo94] <author> J. Callahan, T. Montgomery. </author> <title> "A Decentralized Software Bus based on IP Multicasting." </title> <booktitle> Proceedings of Third Workshop on Enabling Technologies: Infrastructure For Collaborative Enterprises , Morgantown, </booktitle> <address> WV, </address> <month> April 17-19, </month> <year> 1994, </year> <pages> pp. 65-69. </pages>
Reference-contexts: Other instances of these software buses are Polylith [Purtilo85] and MultiBus <ref> [CaMo94] </ref>. // Avoid "Silly Window" effect if (A &lt; MIN_PACKET && A &lt; W) Delay sending packet until an ACK is received // Send up to 1/2 of the window at a time S = min (P, W/2); // Send at least MIN_PACKET bytes S = max (S, MIN_PACKET); // Can
Reference: [Carroll93] <author> Alan Carroll. "ConversationBuilder: </author> <title> A Collaborative Erector Set." </title> <type> Ph.D. </type> <institution> Thesis , Department of Computer Science, University of Illinois, </institution> <year> 1993. </year>
Reference-contexts: Because of these problems, the RMP algorithm uses a combination of these two 4 approaches. The basic algorithm is based on the ideas of the protocol originally done by Chang and Maxemchuk [ChMa84], [ChMa83]. The MBusI <ref> [Carroll93] </ref> was the original motivation for RMP. It provides a central server through which clients connect with TCP/IP streams, and an easy to use interface designed to ease the implementation of CSCW applications. <p> RMP supports both of these addressing models, and supports both the peer group model of communication and the the clientserver model of communication. Protocols such as TCP and UDP require explicit naming of the destinations of communication, while systems such as Grapevine [BLNS82] and the MessageBus <ref> [Carroll93] </ref> allow implicit naming through a publisher/subscriber model of communication. <p> Numerous "software buses" have been implemented recently, which are designed to make applications which do group communication much easier to program. RMP was originally designed as the transport layer for one of these buses, the MessageBus <ref> [Carroll93] </ref>, and supports these types of systems very well.
Reference: [ChMa83] <author> J. M. Chang and N. F. Maxemchuk. </author> <title> "A Broadcast Protocol for Broadcast Networks." </title> <booktitle> Proceedings of GLOBCOM (Dec. </booktitle> <year> 1983). </year>
Reference-contexts: This paper presents the architecture of the Reliable Multicast Protocol (RMP). RMP provides a reliable multicast service on top of unreliable datagram services such as IP and IP Multicasting. RMP is based on the token ring technique originally proposed by J. M. Chang and N. F. Maxemchuk in <ref> [ChMa83] </ref> and [ChMa84]. This CM protocol provides totally ordered atomic broadcast to a single group of broadcast clients on a LAN. <p> Because of these problems, the RMP algorithm uses a combination of these two 4 approaches. The basic algorithm is based on the ideas of the protocol originally done by Chang and Maxemchuk [ChMa84], <ref> [ChMa83] </ref>. The MBusI [Carroll93] was the original motivation for RMP. It provides a central server through which clients connect with TCP/IP streams, and an easy to use interface designed to ease the implementation of CSCW applications.
Reference: [Chang84] <author> J. M. Chang. </author> <title> "Simplifying Distributed Database Systems Design by Using a Broadcast Network." </title> <booktitle> Proceedings of SIGMOD (June 1984). </booktitle> <pages> pp. 223-233. </pages>
Reference-contexts: 1 Introduction Totally ordered, reliable broadcast and multicast protocols have existed for quite some time [ChMa84], and provide a powerful tool for programming distributed systems and distributed databases <ref> [Chang84] </ref>. New applications such as Computer Supported Cooperative Work (CSCW) programs, groupware systems and shared tools can also benefit greatly from this service. In the past, these protocols have had problems with performance, efficiency, and/or scalability.
Reference: [ChMa84] <author> J. M. Chang and N. F. Maxemchuk. </author> <title> "Reliable Broadcast Protocols." </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 2, </volume> <month> 3 (Aug. </month> <year> 1984). </year> <pages> pp. 251-273. </pages>
Reference-contexts: 1 Introduction Totally ordered, reliable broadcast and multicast protocols have existed for quite some time <ref> [ChMa84] </ref>, and provide a powerful tool for programming distributed systems and distributed databases [Chang84]. New applications such as Computer Supported Cooperative Work (CSCW) programs, groupware systems and shared tools can also benefit greatly from this service. In the past, these protocols have had problems with performance, efficiency, and/or scalability. <p> RMP provides a reliable multicast service on top of unreliable datagram services such as IP and IP Multicasting. RMP is based on the token ring technique originally proposed by J. M. Chang and N. F. Maxemchuk in [ChMa83] and <ref> [ChMa84] </ref>. This CM protocol provides totally ordered atomic broadcast to a single group of broadcast clients on a LAN. <p> Because of these problems, the RMP algorithm uses a combination of these two 4 approaches. The basic algorithm is based on the ideas of the protocol originally done by Chang and Maxemchuk <ref> [ChMa84] </ref>, [ChMa83]. The MBusI [Carroll93] was the original motivation for RMP. It provides a central server through which clients connect with TCP/IP streams, and an easy to use interface designed to ease the implementation of CSCW applications. <p> As the error rate increases, the number of packets sent increases, but it is always lower than that required with positive acknowledgments for groups of three or more sites including the sender <ref> [ChMa84] </ref>. We have tested RMP under a variety of cases. The most extensive tests were done on a set of 9 SparcStation2's and SparcStation5's on a lightly loaded 10 Mb/sec Ethernet. Unless otherwise noted, totally ordered packets were used for all tests.
Reference: [ChZw85] <author> D.R. Cheriton and W. Zwaenepoel. </author> <title> "Distributed Process Groups in the V-Kernel." </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 3, </volume> <month> 2 (May </month> <year> 1985). </year> <pages> pp. 77-107. </pages>
Reference: [CrPa88] <author> J. Crowcroft, K. Paliwoda. </author> <title> "A Multicast Transport Protocol". </title> <booktitle> Proceedings of ACM SIGCOMM '88. </booktitle> <pages> pp. 247-256. </pages>
Reference-contexts: These tokens provide both flow control and total ordering of messages. This causes over dependency on the master, which limits both reliability and performance. MTP also relies exclusively on NACKs for error recovery, which limits reliability and requires extreme amounts of buffer space. The protocol by Crowcroft and Paliwoda <ref> [CrPa88] </ref> is one of the first protocols to propose reliable multicast over an internetwork which supports hardware multicast. The protocol provides different levels of reliability guarantees, and uses positive acknowledgments from all destinations for reliability.
Reference: [Deering89] <author> S. Deering. </author> <title> "Host Extensions for IP Multicasting". </title> <address> STD 5. RFC1112. </address> <month> (August </month> <year> 1989). </year>
Reference-contexts: In part, this concept resulted from the fact that in the past multicasts had to be implemented as a series of unicasts to each destination. Recent developments such as the IP Multicasting standard <ref> [Deering89] </ref> now allow a multicast datagram to be sent to multiple destinations over an internetwork. In the case where all destinations are on the same LAN, one multicast packet to all of them costs the same as a unicast packet to just one.
Reference: [DKM93] <author> D. Dolev, S. Kramer, D. Malki. </author> <title> "Early Delivery Totally Ordered Multicast in Asynchronous Environments." </title> <booktitle> 23rd Annual International Symposium on Fault-Tolerant Computing (FTCS). </booktitle> <address> (Toulouse, France, </address> <month> June, </month> <year> 1993). </year> <pages> pp. 544-553. </pages>
Reference-contexts: To solve this problem, RMP offers four levels of fault-tolerant guarantees: atomic delivery within paritions, K-resilient atomic between partitions, agreed delivery between partitions, and safe delivery between partitions. The exact semantics of agreed and safe delivery are defined in <ref> [DKM93] </ref>. All of these guarantees rely on a method of failure detection based on timeouts. If communication to one or more group members fails for an extended period of time (say 15-30 seconds), the RMP failure membership algorithm will remove them from the group.
Reference: [Jacob88] <author> V. Jacobson. </author> <title> "Congestion Avoidance and Control." </title> <booktitle> Proceedings of ACM SIGCOMM '88 Symp (Sept. </booktitle> <year> 1988). </year> <pages> pp. 314-329. </pages>
Reference: [JHC94] <author> P. Jain, N. Hutchinson, and S. Chanson. </author> <title> "A Framework or the Non-Monolithic Implementation of Protocols in the x-kernel." </title> <booktitle> Proceedings of USENIX High Speed Networking (August 1994). </booktitle> <pages> pp. 13-30. </pages>
Reference-contexts: There are numerous pros and cons to each approach, so RMP does not enforce either approach. Traditional protocols have been implemented as monolithic entities in the kernel. This is motivated primarily out of concerns for security and performance. However, as pointed out by <ref> [JHC94] </ref>, [MaBe93], and [TNML93], userspace implementations can be more easily modified and customized, are easier to debug and experiment with, are more easily ported between different platforms, and can increase the performance of protocols, especially when run on a multiprocessor. [TNML93] shows that it is possible to implement protocols in userspace
Reference: [KTHB89] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummel, H. E. Bal. </author> <title> "An Efficient Reliable Broadcast Protocol." </title> <journal> Operating Systems Review. </journal> <volume> 23, </volume> <month> 4 (Oct. </month> <year> 1989), </year> <pages> pp. 5-19. </pages>
Reference: [Lamp78] <author> L. Lamport. </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System." </title> <journal> Communications of the ACM. </journal> <volume> 21, </volume> <pages> 7 </pages>
Reference-contexts: In addition to unreliable and reliable but unordered quality of service (QoS) levels, RMP can provide atomic, reliably delivery of packets ordered with respect to each source. It can also efficiently provide delivery of packets in both total and causal order, using causal ordering as defined in <ref> [Lamp78] </ref>. Totally ordered delivery also provides virtual synchrony, as first defined by the ISIS project [BSS91]. <p> This QoS is equivalent to running a TCP socket from each source into a central bus which serializes the packets and then sends them out through a separate TCP socket to each destination. Totally ordered packets are also causally ordered, as per Lamport's definition <ref> [Lamp78] </ref>. ISIS first defined the notion of virtual synchrony [BSS91], [Birman93]. Virtual synchrony often allows a distributed application to execute as if its communication was synchronous, when it is actually asynchronous.
Reference: [LuGl90] <author> S. W. Luan and V. D. Gligor. </author> <title> "A Fault Tolerant Protocol For Atomic Broadcast." </title> <journal> IEEE Transactions on Parallel and Distributed Systems. </journal> <volume> 1, </volume> <month> 3 (July </month> <year> 1990). </year> <pages> pp. 271-285. </pages>
Reference: [MaBe93] <author> C. Maeda and B. Bershad. </author> <title> "Protocol Service Decomposition for High-Performance Networking." </title> <booktitle> Proceedings of 14th ACM Symposium on Operating Systems Principles , December 1993. </booktitle>
Reference-contexts: There are numerous pros and cons to each approach, so RMP does not enforce either approach. Traditional protocols have been implemented as monolithic entities in the kernel. This is motivated primarily out of concerns for security and performance. However, as pointed out by [JHC94], <ref> [MaBe93] </ref>, and [TNML93], userspace implementations can be more easily modified and customized, are easier to debug and experiment with, are more easily ported between different platforms, and can increase the performance of protocols, especially when run on a multiprocessor. [TNML93] shows that it is possible to implement protocols in userspace that
Reference: [MaCh84] <author> N. F. Maxemchuk and J. M. Chang. </author> <title> "Analysis of the Messages Transmitted in a Broadcast Protocol." </title> <booktitle> Proceedings of the International Computer Conference (Amsterdam, </booktitle> <month> May </month> <year> 1984). </year> <pages> pp. 1263-1267. </pages>
Reference-contexts: The multi-RPC algorithm uses Non Member Data packets and Non Member ACK packets. Flow control and congestion control is based on ACK packets and NACK packets. 10 4.2 Basic delivery algorithm The basic delivery algorithm is very similar to that first proposed in <ref> [MaCh84] </ref>, although RMP allows multiple data packets to be timestamped with a single ACK. The basic algorithm primarily uses NACKs for reliable delivery, and uses a single ACK per packet or set of packets to provide total ordering and stability of packets.
Reference: [MeBo76] <author> R. M. Metcalf. and D. R. Boggs. </author> <title> "Ethernet: Distributed Packet Switching for Local Computer Networks." </title> <journal> Communications of the ACM. </journal> <volume> 19, </volume> <month> 7 (July </month> <year> 1976). </year> <pages> pp. 395-404. </pages>
Reference: [MMA90] <author> P. M. Meillar-Smith, L. E. Moser, V. Agrawala. </author> <title> "Broadcast Protocols for Distributed Systems." </title> <journal> IEEE Transactions on Parallel and Distributed Systems. </journal> <volume> 1, </volume> <month> 1 (Jan. </month> <year> 1990). </year> <pages> pp. 17-25. </pages>
Reference: [PEA94] <author> S. Pejhan, A. Eleftheriadis, D. Anastassiou. </author> <title> "Distributed Multicast Address Management in the Global Internet." </title> <journal> Submitted to IEEE Journal on Selected Areas in Communication on March 1, </journal> <year> 1994. </year>
Reference-contexts: The mapping of group names to IP Multicast address, port, TTL- tuples may either be handled by an external multicast address allocation authority such as <ref> [PEA94] </ref>, or it may be handled by RMP. The default mapping policy uses a hash function to turn the text string into one of a range of multicast addresses (a subset of the class D IP address space, currently 24 bits) and a 15 bits of a port number.
Reference: [PBS89] <author> L. L. Peterson, N. C. Buchholz, R.D. Schlichting. </author> <title> "Preserving and Using Context Information in Interprocess Communication". </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> 7, </volume> <month> 3 (Aug. </month> <year> 1989). </year> <pages> pp. 217-246. 20 </pages>
Reference-contexts: A new system that provides causal ordering on top of IP Multicasting has been implemented which is much more efficient than the old system [Clark94], and we hope to compare RMP and this new protocol soon. The Psync protocol <ref> [PBS89] </ref> is an ingenious protocol that uses piggybacked ACKs to provide causal ordering of messages and detection of dropped packets. However, both it and the similar Trans [MSMA90] and Lansis [ADKM93] protocols require that all of the members of the group regularly transmit messages.
Reference: [Purtilo85] <author> J. Purtilo. </author> <title> "Polylith: An Environment to Support Management of Tool Interfaces." </title> <booktitle> ACM SIGPLAN Symposium on Language Issues in Programming Environments , Seattle, </booktitle> <address> WA, </address> <month> June 25-28, </month> <year> 1985. </year> <pages> pp. 12-18. </pages>
Reference-contexts: Other instances of these software buses are Polylith <ref> [Purtilo85] </ref> and MultiBus [CaMo94]. // Avoid "Silly Window" effect if (A &lt; MIN_PACKET && A &lt; W) Delay sending packet until an ACK is received // Send up to 1/2 of the window at a time S = min (P, W/2); // Send at least MIN_PACKET bytes S = max (S,
Reference: [RaLi93] <author> K. Ravindran and X. T. Lin. </author> <title> "Structural Complexity and Execution Efficiency of Distributed Application Protocols." </title> <booktitle> Proceedings of ACM SIGCOMM '93. </booktitle> <address> (San Francisco, </address> <month> Sept. </month> <year> 1993). </year> <pages> pp. 160-169. </pages>
Reference-contexts: In the past, these protocols have had problems with performance, efficiency, and/or scalability. It has become a widespread belief that these are inherent problems with a totally ordered reliable multicast protocol <ref> [RaLi93] </ref>. In part, this concept resulted from the fact that in the past multicasts had to be implemented as a series of unicasts to each destination. Recent developments such as the IP Multicasting standard [Deering89] now allow a multicast datagram to be sent to multiple destinations over an internetwork.
Reference: [TNML93] <author> C. Thekkath, T. Nguyen, E. Moy, and E. Lazowska. </author> <title> "Implementing Network Protocols at User Level." </title> <journal> IEEE/ACM Transactions on Networking , 1(5), </journal> <year> 1993. </year> <pages> pp. 554-565. </pages>
Reference-contexts: There are numerous pros and cons to each approach, so RMP does not enforce either approach. Traditional protocols have been implemented as monolithic entities in the kernel. This is motivated primarily out of concerns for security and performance. However, as pointed out by [JHC94], [MaBe93], and <ref> [TNML93] </ref>, userspace implementations can be more easily modified and customized, are easier to debug and experiment with, are more easily ported between different platforms, and can increase the performance of protocols, especially when run on a multiprocessor. [TNML93] shows that it is possible to implement protocols in userspace that actually have <p> However, as pointed out by [JHC94], [MaBe93], and <ref> [TNML93] </ref>, userspace implementations can be more easily modified and customized, are easier to debug and experiment with, are more easily ported between different platforms, and can increase the performance of protocols, especially when run on a multiprocessor. [TNML93] shows that it is possible to implement protocols in userspace that actually have better performance than kernel space implementatinos. Numerous "software buses" have been implemented recently, which are designed to make applications which do group communication much easier to program.
Reference: [Verissmo92] <author> Verissmo. "xAMp: </author> <title> A Multi-primitive Group Communications Service. </title> <booktitle> Proceedings of the 11th Symposium on Reliable Distributed Computing. </booktitle>
Reference: [WhStFe94] <author> B. Whetten, S. Steinberg, and D. Ferrari. </author> <title> "The Packet Starvation Effect in CSMA/CD LANs and a Solution". </title> <booktitle> Proceedings of IEEE Local Computer Networks Conference (Minneapolis, </booktitle> <address> Minnesota, </address> <month> Oct. </month> <year> 1994). </year>
Reference-contexts: Three runs were made in each test and the results were averaged together. While we do not show the standard deviations, they were quite small for all of the cases except for 4 and 8 senders, where the Packet Starvation Effect <ref> [WhStFe94] </ref> was causing the Ethernet to drop a significant portion of the packets sent. Under this case, the network has an extremely high standard deviation in latency, so consistent results are not possible without extremely long runs. of group members. Aggregate throughput is the throughput the user sees.
References-found: 34

