URL: http://actor.cs.vt.edu/~vanmetre/symphony/papers/AshishThesis.ps
Refering-URL: http://actor.cs.vt.edu/~vanmetre/symphony/papers.html
Root-URL: http://www.cs.vt.edu
Title: Symphony: A Java-based Composition and Manipulation Framework for Distributed Legacy Resources  
Author: by Ashish Bimalkumar Shah c flAshish Bimalkumar Shah and VPI SU Calvin Ribbens Clifford Shaffer 
Degree: Thesis submitted to the faculty of the  in partial fulfillment of the requirements for the degree of MASTER OF SCIENCE in  APPROVED: Dennis Kafura, Chairman  
Date: 1998  30th March, 1998  
Affiliation: Virginia Polytechnic Institute and State University  Computer Science and Applications  Blacksburg, Virginia  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> John Ambrosiano, Steve Fines and Mladen Vouk. </author> <booktitle> Problem-Solving Environments in the Year 2000 and Beyond, </booktitle> <year> 1995. </year>
Reference-contexts: In fact, hardly any existing PSE or PSE-like system includes many of the features described above. 1 Chapter 1. Introduction 2 Problem solving environments have predominantly focused on science and engineering applications <ref> [1, 17] </ref>. In this thesis too, the term PSE will be interpreted with this application domain in mind.
Reference: [2] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1996. </year>
Reference-contexts: The goal of developing a composing environment for building collections of distributed legacy resources fits naturally with the paradigm of composing and customizing re-usable software components, where each different type of legacy resource is represented by a separate software component. The Java programming language <ref> [2] </ref> and the JavaBeans component architecture [33] were used to implement the desired system. Sun's JavaBeans specification is an Application Programming Interface (API) that enables developers to write components called beans in Java. Platform independence comes as an added benefit of using Java which is an architecture neutral programming language. <p> Finally, Section 2.4 discusses some emerging Java-based distributed computing systems that are aimed at the problem solving environments community. 2.1 Java Sun Microsystems' Java programming language, initially popularized as an Internet programming language, has quickly transformed itself into a full-fledged computing platform <ref> [2, 35] </ref>. Java is a object-oriented, multi-threaded and architecture-neutral programming language. It achieves architecture-neutrality by introducing the Java virtual machine (JVM) that provides an additional software layer between Java programs and the underlying operating system. Java programs are compiled to bytecodes which can be interpreted by the JVM.
Reference: [3] <author> Dimple Bhatia, Vanco Burzevski, Maja Camuseva, Geoffrey Fox, Wojtek Furmanski and Girish Premchandran. </author> <title> Webflow a visual programming paradigm for web/java based coarse grain distributed computing. </title> <journal> Concurrency: Practice and Experience, </journal> <pages> pages 555-577, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: WebWork proposes the development of high-performance applications that make use of the Internet's wealth of computing resources, by creating and utilizing compute servers throughout the Internet. WebFlow is a general-purpose Web based visual programming environment for coarse-grained distributed computing <ref> [3] </ref>. A distributed computation is represented by a set of channel-connected Java modules. Each WebFlow module must implement a Module API.
Reference: [4] <author> Kraig Brockschmidt. Inside OLE. Microsoft Presss, </author> <year> 1995. </year>
Reference-contexts: The JavaBeans specification defines a component architecture for building portable, platform neutral software components called beans which can be visually manipulated in builder tools [33]. Beans are platform independent in the sense that they can be plugged into existing component architectures such as Microsoft's OLE/COM <ref> [4, 18] </ref>, Apple's OpenDoc [8], and Netscape's Liveconnect [14] using standard bridges. A beans builder tool maintains a palette of beans. The user can select any bean from the palette, drop it into a workspace, modify it's appearance and behavior and define its interaction with other beans.
Reference: [5] <author> Henri Casanova, Jack Dongarra and Keith Moore. </author> <title> Network Enabled Solvers and the Net-Solve Project. </title> <journal> SIAM News, Society for Industrial and Applied Mathematics, </journal> <month> January-February </month> <year> 1998. </year>
Reference-contexts: Chapter 2. Background 20 2.3.3 NetSolve NetSolve is a system that provides high-level APIs and interfaces to scientific software libraries for solving computational science problems in a reliable, fault-tolerant environment on distributed and heterogeneous computing resources <ref> [5] </ref>. It provides an environment that integrates computation, data gathering, data storage, and resource management. Each separate numerical library on a compute server can be described using the NetSolve descriptive language in a machine-independent way. Calls are made to the actual library routines through this descriptive language interface.
Reference: [6] <author> K. Mani Chandy, Adam Rifkin, Paolo Sivilotti, Jacob Mandelson, Matthew Richard-son, Wesley Tanaka and Luke Weisman. </author> <title> A world-wide distributed system using java and the internet. </title> <booktitle> In Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 11-18, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: to legacy applications without requiring any modifications to these applications. 2.4.2 The Infospheres Infrastructure The Infospheres Infrastructure, being developed at Caltech by Chandy et. al is a distributed system framework implemented in Java that provides mechanisms for programmers to develop distributed system components from which distributed applications can be created <ref> [6, 7, 26] </ref>. It provides a variety of messaging models, including asynchronous, synchronous, and remote procedure/method calls and a variety of distributed system services, including local and global naming, object instance control, object persistence, and others. The components in this distributed system are termed as processes.
Reference: [7] <author> K. Mani Chandy, Joseph Kiniry, Adam Rifkin and Daniel Zimmerman. </author> <title> A Framework for Structured Distributed Object Computing. </title> <type> Technical Report 256-80, </type> <year> 1997. </year>
Reference-contexts: to legacy applications without requiring any modifications to these applications. 2.4.2 The Infospheres Infrastructure The Infospheres Infrastructure, being developed at Caltech by Chandy et. al is a distributed system framework implemented in Java that provides mechanisms for programmers to develop distributed system components from which distributed applications can be created <ref> [6, 7, 26] </ref>. It provides a variety of messaging models, including asynchronous, synchronous, and remote procedure/method calls and a variety of distributed system services, including local and global naming, object instance control, object persistence, and others. The components in this distributed system are termed as processes.
Reference: [8] <author> Jesse Feiler and Anthony Meadow. </author> <title> Essential OpenDoc. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1996. </year>
Reference-contexts: The JavaBeans specification defines a component architecture for building portable, platform neutral software components called beans which can be visually manipulated in builder tools [33]. Beans are platform independent in the sense that they can be plugged into existing component architectures such as Microsoft's OLE/COM [4, 18], Apple's OpenDoc <ref> [8] </ref>, and Netscape's Liveconnect [14] using standard bridges. A beans builder tool maintains a palette of beans. The user can select any bean from the palette, drop it into a workspace, modify it's appearance and behavior and define its interaction with other beans.
Reference: [9] <author> Geoffrey Fox and Wojtek Furmanski. </author> <title> Towards web/java-based high performance distributed computing an evolving virtual machine. </title> <booktitle> In Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 308-317, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: The second framework proposed by Chandy et. al explores the use of Java as a means for building distributed systems that execute throughout the Internet. 2.4.1 WebFlow WebFlow is part of an ongoing project called WebWork at Syracuse University's Northeast Parallel Architectures Center (NPAC) <ref> [10, 9] </ref>. WebWork proposes the development of high-performance applications that make use of the Internet's wealth of computing resources, by creating and utilizing compute servers throughout the Internet. WebFlow is a general-purpose Web based visual programming environment for coarse-grained distributed computing [3].
Reference: [10] <author> Geoffrey Fox and Wojtek Furmanski. Petaops and exaops: </author> <title> Supercomputing on the web. </title> <booktitle> IEEE Internet Computing, </booktitle> <pages> pages 38-46, </pages> <year> 1997. </year> <note> 123 REFERENCES 124 </note>
Reference-contexts: The second framework proposed by Chandy et. al explores the use of Java as a means for building distributed systems that execute throughout the Internet. 2.4.1 WebFlow WebFlow is part of an ongoing project called WebWork at Syracuse University's Northeast Parallel Architectures Center (NPAC) <ref> [10, 9] </ref>. WebWork proposes the development of high-performance applications that make use of the Internet's wealth of computing resources, by creating and utilizing compute servers throughout the Internet. WebFlow is a general-purpose Web based visual programming environment for coarse-grained distributed computing [3].
Reference: [11] <author> Efstratois Gallopoulos, Elias Houstis and John Rice. </author> <title> Computer as a Thinker/Doer: Problem Solving Environments for Computational Sciences. </title> <journal> IEEE Computational Science and Engineering, </journal> <pages> pages 11-23, </pages> <year> 1994. </year>
Reference-contexts: Some properties shared by all PSEs are that they allow a user to formulate a problem solution in a language suitable for the target class of problems and to view or assess the correctness of the solution through analysis or visualization tools <ref> [11] </ref>. Depending on the problem domain, different features are desired in a PSE.
Reference: [12] <author> E. Houstis, J. Rice, S. Weerawarana, A. Catlin, P. Papachiou, K.-W. Wang and M. Gaitatzes. </author> <title> Parallel ELLPACK: A Problem-Solving Environment for PDE Based Applications on Multicomputer Platforms. </title> <journal> ACM Transactions on Mathematical Software, </journal> <note> (To Appear) 1998. </note>
Reference-contexts: Consider the example of Parallel ELLPACK (//ELLPACK), which is a problem solving environment for partial differential equations (PDEs) <ref> [12] </ref>. The //ELLPACK system consists of about one million lines of C, Lisp, and Fortran code. It's easy to see how complex it must be just to install a copy of the PSE on a new machine. <p> Javamatic does not provide such extensibility. Chapter 2. Background 19 2.3.2 Web //ELLPACK: Remote Access to a Problem Solving Environment Web //ELLPACK facilitates remote access to the //ELLPACK problem solving environment for solving partial differential equation (PDE) problems <ref> [23, 12] </ref>. //ELLPACK is a PSE for solving PDE problems on high performance computing platforms as well as a development environment for building new PDE solvers or PDE components. A GUI assists users in specifying the PDE problem and the solution algorithm and for analyzing computed solutions.
Reference: [13] <author> Philip Isenhour. </author> <title> Sieve: A Java-Based Framework for Collaborative Component Composition. </title> <type> Master's thesis, </type> <institution> Virginia Tech, Blacksburg, VA, </institution> <year> 1998. </year>
Reference-contexts: of the beans architecture code-named "Glasgow" [33], will open up a new set of capabilities for bean aggregation which enable this capability. 2.2.2 Collaborative Component Composition with Sieve Sieve provides a JavaBeans-based shared workspace where multiple users can collaboratively add, edit, and link components to build a network of components <ref> [13] </ref>. It provides an ability for existing JavaBeans-based applications that adhere to standard beans mechanisms to be used in a collaborative manner, or to build completely new applications to take advantage of Sieve's real-time interactive collaboration. <p> Finally, Section 4.6 and 4.7 describe the implementation of the Symphony beans and Section 4.8 shows how a new bean can be added to the framework and how Symphony beans were adapted for collaborative composition in Sieve <ref> [13] </ref>. 4.1 Design Goals The Symphony framework consists of a set of beans which can be connected together by the user to form meta-programs. <p> Execute the 'make' command in order to compile the class files for the newly created beans and add them to the Symphony.jar file. 4.8.2 Collaborative Composition in Sieve This section describes how the Symphony beans were adapted for collaborative composition the Sieve <ref> [13] </ref> environment. As described in Section 2.2.2, Sieve provides a JavaBeans-based shared workspace where multiple users can collaboratively add, edit, and link components to build a network of components. <p> A new type of bean which allows adding of on-screen annotations and associating them with meta-program beans can be useful for documenting the meta-program. Sieve, for example, provides users with a capability to annotate the workspace by using lines, arrows and text <ref> [13] </ref>. Another functionality that could be useful is the ability to embed URLs in annotations which when clicked would open the URLs in a browser window. The Browser bean can be used for this purpose.
Reference: [14] <author> Lori Leonardo. </author> <title> Using Netscape Liveconnect. QUE Education and Training, </title> <year> 1997. </year>
Reference-contexts: Beans are platform independent in the sense that they can be plugged into existing component architectures such as Microsoft's OLE/COM [4, 18], Apple's OpenDoc [8], and Netscape's Liveconnect <ref> [14] </ref> using standard bridges. A beans builder tool maintains a palette of beans. The user can select any bean from the palette, drop it into a workspace, modify it's appearance and behavior and define its interaction with other beans. Beans are used to compose applets or applications.
Reference: [15] <author> Robert Orfali, Dan Harkey and Jeri Edwards. </author> <title> The Essential Distributed Objects Survival Guide. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1996. </year>
Reference-contexts: Cheap, personalized applications can be built by composing and customizing generic, "off-the-shelf" components. The software framework that allows composition and manipulation of these components is called a component architecture. Different components interact using standard client/server interaction models such as event notifications <ref> [15] </ref>. The goal of developing a composing environment for building collections of distributed legacy resources fits naturally with the paradigm of composing and customizing re-usable software components, where each different type of legacy resource is represented by a separate software component. <p> Chapter 2. Background 13 2.1.1 The JavaBeans Component Architecture As defined by Orfali et. al, a component is a stand alone software object that is not bound to a particular program, platform, language, operating system or implementation <ref> [15] </ref>. It does not constitute a complete application by itself, but can be used to build cheap, personalized applications. Components reduce the cost and complexity of software development by enabling software reuse through write-once run-anywhere capability. Different components interact using platform-neutral, client/server interaction models such as event notifications. <p> Examples include Borland's JBuilder [21], SunSoft's Java Workshop [36], and IBM's Visual Age for Java [25]. 2.1.2 Java Remote Method Invocation Mechanism A distributed object is a software component that is independent of the operating system and hardware architecture used for implementation <ref> [15] </ref>. It may be located anywhere on the network and can provide services to remote as well as local clients via method invocations. Java provides the Remote Method Invocation (RMI) API for creating and accessing distributed objects [31].
Reference: [16] <author> Constantinos Phanouriou and Marc Abrams. </author> <title> Transforming Command-line Driven Systems to Web Applications. </title> <booktitle> In Proceedings of the Sixth International World Wide Web Conference, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: Background 18 obtaining accounts on the remote servers, logging in, setting up the required software for execution, and manually collecting the results. 2.3.1 Javamatic: Web Interface to Command-line Applications Javamatic is a system for providing a Web-based interface to a remote command-line application <ref> [16] </ref>. It was developed at Virginia Tech by Abrams et.al. The Javamatic architecture consists of the interface client and the interface server.
Reference: [17] <author> John Rice and Ronald Boisvert. </author> <title> From Scientific Software Libraries to Problem-Solving Environments. </title> <journal> IEEE Computational Science and Engineering, </journal> <pages> pages 44-53, </pages> <year> 1996. </year>
Reference-contexts: In fact, hardly any existing PSE or PSE-like system includes many of the features described above. 1 Chapter 1. Introduction 2 Problem solving environments have predominantly focused on science and engineering applications <ref> [1, 17] </ref>. In this thesis too, the term PSE will be interpreted with this application domain in mind.
Reference: [18] <author> Dale Rogerson. </author> <title> Inside COM. </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference-contexts: The JavaBeans specification defines a component architecture for building portable, platform neutral software components called beans which can be visually manipulated in builder tools [33]. Beans are platform independent in the sense that they can be plugged into existing component architectures such as Microsoft's OLE/COM <ref> [4, 18] </ref>, Apple's OpenDoc [8], and Netscape's Liveconnect [14] using standard bridges. A beans builder tool maintains a palette of beans. The user can select any bean from the palette, drop it into a workspace, modify it's appearance and behavior and define its interaction with other beans.
Reference: [19] <author> Jon Siegel. </author> <title> CORBA Fundamentals and Programming. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1996. </year>
Reference-contexts: give sample code to illustrate the steps. 3.6.1 Producer Beans The Producer bean can be extended to implement a variety of beans, such as beans that solicit input data from the user, beans that obtain data from remote databases, and beans that interact with remote compute servers implemented using CORBA <ref> [19] </ref> or RMI [31]. The manner in which the data is produced or obtained by the bean is left to the discretion of the programmer. The only requirement is the data be presented in a byte stream represented by a java.io.InputStream object which can be read from.
Reference: [20] <author> Craig Upson, Thomas Faulhaber, David Kamins, Davin Laidlaw, David Schlegel, Jeffrey Vroom, Robert Gurwitz, and Andries van Dam. </author> <title> The Application Visualization System: a Computational Environment for Scientific Visualization. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 30-42, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The data-flow paradigm was chosen as a way of describing relationships between components and specifying the execution sequence of related executable components. This paradigm has been popularized by visualization systems such as AVS <ref> [20] </ref> and Khoros [27]. A visual program is described as a directed graph, where each node represents an operator or function and each directed arc represents a path over which data flows. <p> Much of the design for Symphony's data-flow model draws from numerous earlier data-flow based systems such as Khoros [27] and AVS <ref> [20] </ref>.
Reference: [21] <institution> Borland International, Inc. Borland JBuilder Home Page. </institution> <address> URL: http://www.borland.- com/jbuilder, </address> <year> 1998. </year>
Reference-contexts: Although Symphony beans were developed and tested in the BeanBox environment, they can be used in any builder tool that supports beans. Most of the commercially available Java development environments provide support for beans. Examples include Borland's JBuilder <ref> [21] </ref>, SunSoft's Java Workshop [36], and IBM's Visual Age for Java [25]. 2.1.2 Java Remote Method Invocation Mechanism A distributed object is a software component that is independent of the operating system and hardware architecture used for implementation [15].
Reference: [22] <institution> Department of Computer Science, Virginia Tech. Research in Problem Solving Environments at Virginia Tech. </institution> <address> URL: http://www.cs.vt.edu/ pse/, </address> <year> 1998. </year>
Reference-contexts: The rest of the methods in the bean are similar to those in the Producer and Consumer beans. 3.7 Meta-Program Example This section describes a sample meta-program based on the Radio Frequency Pressing (RFP) simulation developed at the Department of Wood Science and Forest Products at Virginia Tech <ref> [22] </ref>. This system simulates heat and mass transfer in wood when subject to power input by an alternating electric field.
Reference: [23] <institution> Department of Computer Sciences, Purdue University. </institution> <month> Web//Ellpack: </month> <title> A Networked Computing Service on the World Wide Web. </title> <type> Technical Report CSD TR-96-011, </type> <year> 1996. </year>
Reference-contexts: Javamatic does not provide such extensibility. Chapter 2. Background 19 2.3.2 Web //ELLPACK: Remote Access to a Problem Solving Environment Web //ELLPACK facilitates remote access to the //ELLPACK problem solving environment for solving partial differential equation (PDE) problems <ref> [23, 12] </ref>. //ELLPACK is a PSE for solving PDE problems on high performance computing platforms as well as a development environment for building new PDE solvers or PDE components. A GUI assists users in specifying the PDE problem and the solution algorithm and for analyzing computed solutions.
Reference: [24] <institution> Department of Computer Sciences, Purdue University. </institution> <note> Problem Solving Environments. URL: http://www.cs.purdue.edu/research/cse/pses/, 1998. REFERENCES 125 </note>
Reference-contexts: The need for a PSE increases with the complexity and heterogeneity of the application. 1.1 Problem Statement Most existing PSEs are focused on providing problem-solving facilities for narrow application domains, such as solving partial differential equations (PDEs), data visualization, numerical analysis and others <ref> [24] </ref>. These PSEs are built around software libraries which are either modified or rewritten to adapt to the architecture of the PSE. Although these PSEs function very well in their own domain, they do not attempt to provide a generic framework for solving general-purpose science and engineering problems. <p> Some PSEs also allow users to create a problem description in terms of the various tools used during the problem-solving process and corresponding data and control flow patterns which Chapter 1. Introduction 6 link the tools <ref> [24] </ref>. Such an integrated collection of tools may be defined as a meta-program. Formally, a meta-program is a set of linked program and data components implemented as a data-flow graph that defines how each program accepts data from previous computation and produces data for further processing.
Reference: [25] <author> IBM Corporation. </author> <title> IBM Visual Age for Java. </title> <address> URL: http://www.software.ibm.com/- ad/vajava/, </address> <year> 1998. </year>
Reference-contexts: Although Symphony beans were developed and tested in the BeanBox environment, they can be used in any builder tool that supports beans. Most of the commercially available Java development environments provide support for beans. Examples include Borland's JBuilder [21], SunSoft's Java Workshop [36], and IBM's Visual Age for Java <ref> [25] </ref>. 2.1.2 Java Remote Method Invocation Mechanism A distributed object is a software component that is independent of the operating system and hardware architecture used for implementation [15]. It may be located anywhere on the network and can provide services to remote as well as local clients via method invocations.
Reference: [26] <institution> The Infospheres Research Group. </institution> <note> The Infospheres Infrastructure User Guide. URL: http://www.infospheres.caltech.edu/, 1998. </note>
Reference-contexts: to legacy applications without requiring any modifications to these applications. 2.4.2 The Infospheres Infrastructure The Infospheres Infrastructure, being developed at Caltech by Chandy et. al is a distributed system framework implemented in Java that provides mechanisms for programmers to develop distributed system components from which distributed applications can be created <ref> [6, 7, 26] </ref>. It provides a variety of messaging models, including asynchronous, synchronous, and remote procedure/method calls and a variety of distributed system services, including local and global naming, object instance control, object persistence, and others. The components in this distributed system are termed as processes.
Reference: [27] <institution> Khoral Research, Inc. </institution> <note> What is khoros? URL: http://www.khoral.com/khoros/- whatis.html, </note> <year> 1998. </year>
Reference-contexts: The data-flow paradigm was chosen as a way of describing relationships between components and specifying the execution sequence of related executable components. This paradigm has been popularized by visualization systems such as AVS [20] and Khoros <ref> [27] </ref>. A visual program is described as a directed graph, where each node represents an operator or function and each directed arc represents a path over which data flows. The environment provides a workspace where resource modules may be instantiated, connected, and customized to form the data-flow network. <p> Much of the design for Symphony's data-flow model draws from numerous earlier data-flow based systems such as Khoros <ref> [27] </ref> and AVS [20]. <p> composing visual programs, and Sieve, a Java-based framework that is focused on collaborative component composition. 2.2.1 Visual Programming in Khoros Khoros is a image processing system that provides tools for signal and surface plotting, image display and editing, image animation, geometry and volume rendering, and several other image processing tasks <ref> [27] </ref>. In image processing, pixels are often processed by a set of separate filters, each with a different convolution or image-understanding algorithm. Khoros provides a visual programming environment called Cantata for specifying the flow of data to create a program for image-processing. <p> Currently, Symphony follows a pure data-flow model where there is no provision for specifying control flow except for what is implicit in the data flow. It would be useful to have control-flow operators such as those available in Khoros <ref> [27] </ref>. Examples include, if-then-else operators and loop control operators. Middleware Layer Symphony uses a two layer architecture where the client layer interacts directly with servers that access resources.
Reference: [28] <author> Sun Microsystems, Inc. </author> <title> Java Core Reflection API and Specification. </title> <note> URL: http://www.- javasoft.com/products/jdk/1.1/docs/guide/reflection/spec/java-reflectionTOC.doc.- html, </note> <year> 1997. </year>
Reference-contexts: GUI components communicate using a platform-neutral event mechanism. The reflection API enables a Java program to query a Java class or object about it's structure (methods, attributes, constructors, events) at run-time <ref> [28] </ref>. Object serialization supports the encoding of objects and the objects reachable from them into a stream of bytes and the complimentary reconstruction of the object graph from the stream [29]. It can be used for storing Java objects in a persistent state and reviving them whenever necessary.
Reference: [29] <author> Sun Microsystems, Inc. </author> <title> Java Object Serialization Specification. </title> <address> URL: http://www.- javasoft.com/products/jdk/1.1/docs/guide/serialization/spec/serialTOC.doc.html, </address> <year> 1997. </year>
Reference-contexts: Object serialization supports the encoding of objects and the objects reachable from them into a stream of bytes and the complimentary reconstruction of the object graph from the stream <ref> [29] </ref>. It can be used for storing Java objects in a persistent state and reviving them whenever necessary. It can also be used for communication via sockets. The default encoding of objects protects private and transient data and supports evolution of classes. Symphony uses Java libraries in the following ways. <p> Chapter 3. Using Symphony 31 The BeanBox uses object serialization to save and restore the current contents of the workspace (the beans in the workspace, their state, and connections) <ref> [29] </ref>. On selecting the File ! Save menu item in the BeanBox, a file dialog box appears, which can be used to save the current workspace to a named file. <p> The manner in which the customizer is implemented, the user would have to press the "Apply Customization" button after typing in the new property value for the change to take effect. 4.2.5 Persistence The builder tool can save the beans along-with their connections in persistent state using Java object serialization <ref> [29] </ref>. Serialization is the process of saving in persistent storage, the internal state of a Java object along with the associated graph of objects. Deserialization is the reverse process of constructing an object from the serialized description. A bean is made persistent by implementing the java.io.Serializable interface. The Chapter 4.
Reference: [30] <author> Sun Microsystems, Inc. </author> <title> Java AWT: Delegation Event Model. </title> <address> URL: http://www.- javasoft.com/products/jdk/1.1/docs/guide/awt/designspec/events.html, </address> <year> 1997. </year>
Reference-contexts: The event mechanism provides a client/server, application independent form of communication. Traditionally, events have been used for common tasks such as delivering notifications of mouse and keyboard actions in window system toolkits. The JavaBeans event mechanism derives from the event model used by the Java Abstract Windowing Toolkit (AWT) <ref> [30] </ref>. Events are a way for a source bean to notify listener beans that something of interest has happened. Events are generated by event sources and sent to event listener objects by making Java method invocations.
Reference: [31] <author> Sun Microsystems, Inc. </author> <title> Java Remote Method Invocation Specification. </title> <note> URL: http://- www.javasoft.com/products/jdk/1.1/docs/guide/rmi/spec/rmiTOC.doc.html, 1997. </note>
Reference-contexts: It may be located anywhere on the network and can provide services to remote as well as local clients via method invocations. Java provides the Remote Method Invocation (RMI) API for creating and accessing distributed objects <ref> [31] </ref>. The RMI mechanism lets programmers create Java objects whose methods can be invoked from another virtual machine, potentially executing on a remote host machine. RMI is the object-oriented counterpart of remote procedure calls (RPC) in the procedural programming world. <p> to illustrate the steps. 3.6.1 Producer Beans The Producer bean can be extended to implement a variety of beans, such as beans that solicit input data from the user, beans that obtain data from remote databases, and beans that interact with remote compute servers implemented using CORBA [19] or RMI <ref> [31] </ref>. The manner in which the data is produced or obtained by the bean is left to the discretion of the programmer. The only requirement is the data be presented in a byte stream represented by a java.io.InputStream object which can be read from. <p> The Process object can also be used to check the exit value from the program and to stop it while it's running, if necessary. 4.5.2 Implementing the Symphony Server This sub-section explains the fundamentals of the Java RMI mechanism and describes the implementation of the Symphony server using RMI <ref> [31] </ref>. Traditionally, socket-based communication has been used in designing client/server systems. Sockets require the client and server to engage in an application-level protocol for encoding and decoding messages exchanged between them.
Reference: [32] <author> Sun Microsystems, Inc. </author> <title> Manifest Format. </title> <address> URL: http://www.javasoft.com/products/- jdk/1.1/docs/guide/jar/manifest.html, </address> <year> 1997. </year>
Reference-contexts: It should not, however, store references to external beans. 4.2.6 Packaging JavaBeans can be packaged in JAR (Java ARchive) files. A JAR file is a ZIP format archive file that may optionally have a Manifest file <ref> [32] </ref>. The JAR file may contain .class files, serialized beans, help files in HTML format, and resources (images, audio, text). The Manifest file describes the contents of a JAR file and can be used to indicate which classes in the JAR file constitute beans.
Reference: [33] <author> Sun Microsystems, Inc. </author> <title> The JavaBeans (tm) API Specification. </title> <address> URL: http://www.- javasoft.com/beans/docs/beans.101.pdf, </address> <year> 1997. </year>
Reference-contexts: The Java programming language [2] and the JavaBeans component architecture <ref> [33] </ref> were used to implement the desired system. Sun's JavaBeans specification is an Application Programming Interface (API) that enables developers to write components called beans in Java. Platform independence comes as an added benefit of using Java which is an architecture neutral programming language. <p> The underlying software framework that enables this functionality and provides the facilities required for it is called a component architecture. The JavaBeans specification defines a component architecture for building portable, platform neutral software components called beans which can be visually manipulated in builder tools <ref> [33] </ref>. Beans are platform independent in the sense that they can be plugged into existing component architectures such as Microsoft's OLE/COM [4, 18], Apple's OpenDoc [8], and Netscape's Liveconnect [14] using standard bridges. A beans builder tool maintains a palette of beans. <p> Cantata allows workspaces to be saved as stand-alone applications which can be executed from the command-line. This is not yet possible in Symphony because of the limitations of the current JavaBeans architecture. It is expected that the next version of the beans architecture code-named "Glasgow" <ref> [33] </ref>, will open up a new set of capabilities for bean aggregation which enable this capability. 2.2.2 Collaborative Component Composition with Sieve Sieve provides a JavaBeans-based shared workspace where multiple users can collaboratively add, edit, and link components to build a network of components [13]. <p> Although Symphony beans were developed and tested using BeanBox, Sun's reference im 25 Chapter 3. Using Symphony 26 plementation of a beans container, they can be manipulated or executed inside any JavaBeans container that conforms to the JavaBeans specification <ref> [33] </ref>. All Symphony beans conform to Sun's JavaBeans API Specification 1.01 and thus can be used in most commercially available bean containers. A beans container may either be a beans builder tool like BeanBox or an environment which only allows a set of serialized beans to be loaded and executed. <p> However, a bean implementation includes substantial machinery for creating a connection between two beans, implementing the data-flow, handling events generated during meta-program operations, and other related functions. Also, the beans have to be programmed in accordance to the JavaBeans API specification <ref> [33] </ref>. Thus, implementing a new type of Symphony bean is not a simple task for the casual Java programmer. To simplify the creation of new bean types, Symphony provides a set of abstract beans which hide the details of the Symphony event model and execution protocol. <p> A bean is a Java class that follows certain design patterns and method naming conventions to publish its properties, methods and events <ref> [33] </ref>. While a bean is not a complete application, it can be composed with other beans to form applications.
Reference: [34] <author> Sun Microsystems, Inc. </author> <title> Java Development Kit 1.1.x. </title> <address> URL: http://www.javasoft.com/- products/jdk/1.1/, </address> <year> 1998. </year>
Reference-contexts: It implements an automatic garbage collection mechanism which frees the developer of the burden of explicit memory management and also provides automatic array bounds checking. The Java development kit (JDK) comes with a large number of pre-defined class libraries which provide support for a wide range of computing tasks <ref> [34] </ref>. The specific standard libraries (also termed as Application Programming Interfaces [APIs] or packages) that are important to this discussion are the ones which provide support for user-interfaces, networking, file and stream I/O, distributed computation, object serialization and reflection, and the JavaBeans component architecture.
Reference: [35] <institution> Sun Microsystems, Inc. Java Home Page. </institution> <note> URL: http://www.javasoft.com/, 1998. </note>
Reference-contexts: Finally, Section 2.4 discusses some emerging Java-based distributed computing systems that are aimed at the problem solving environments community. 2.1 Java Sun Microsystems' Java programming language, initially popularized as an Internet programming language, has quickly transformed itself into a full-fledged computing platform <ref> [2, 35] </ref>. Java is a object-oriented, multi-threaded and architecture-neutral programming language. It achieves architecture-neutrality by introducing the Java virtual machine (JVM) that provides an additional software layer between Java programs and the underlying operating system. Java programs are compiled to bytecodes which can be interpreted by the JVM.
Reference: [36] <author> Sun Microsystems, Inc. </author> <title> Java Workshop 2.0. </title> <address> URL: http://www.sun.com/workshop/- java, </address> <year> 1998. </year>
Reference-contexts: Although Symphony beans were developed and tested in the BeanBox environment, they can be used in any builder tool that supports beans. Most of the commercially available Java development environments provide support for beans. Examples include Borland's JBuilder [21], SunSoft's Java Workshop <ref> [36] </ref>, and IBM's Visual Age for Java [25]. 2.1.2 Java Remote Method Invocation Mechanism A distributed object is a software component that is independent of the operating system and hardware architecture used for implementation [15].
Reference: [37] <author> Sun Microsystems, Inc. </author> <title> The Beans Development Kit. </title> <address> URL: http://www.javasoft.com /beans/software/bdk download.html, </address> <year> 1998. </year>
Reference-contexts: Beans support introspection in two ways: by adhering to special naming conventions for the class methods and by providing an explicit bean information class. Sun provides a Beans Development Kit (BDK) which includes a reference builder tool, called BeanBox <ref> [37] </ref>. The BeanBox provides a rectangular workspace in which beans instantiated from a tool box can be manipulated and composed. It allows customization of a bean's properties through standard property editors or through the bean customizer, if one is provided.
Reference: [38] <author> Sun Microsystems, Inc. </author> <title> The JavaBeans (tm) Tutorial. </title> <address> URL: http://www.javasoft.- com/beans/docs/Tutorial-Nov97.pdf, </address> <year> 1998. </year>
Reference-contexts: It also describes important BeanBox operations at a higher level in terms of the steps required for composing a meta-program <ref> [38] </ref>. When started, the BeanBox application displays three windows: The tool box, the BeanBox workspace window, and the property sheet as depicted by Fig. 3.1. Two modifications have been made to the BeanBox provided by Sun purely for aesthetic purposes. <p> The BeanBox provides a user interface for connecting beans through these two mechanisms. In Symphony, only event connections are important. Details about linking beans through bound properties can be found in the JavaBeans tutorial <ref> [38] </ref>. A particular bean can generate a variety of events depending on the bean type and purpose. For example, the most important event generated by a button bean is the action event, which is generated when the button is pushed.

References-found: 38

