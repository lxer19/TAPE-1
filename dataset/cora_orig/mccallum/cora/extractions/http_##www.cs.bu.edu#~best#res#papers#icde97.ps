URL: http://www.cs.bu.edu/~best/res/papers/icde97.ps
Refering-URL: http://cs-www.bu.edu/faculty/best/res/Home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: sanjoy@cs.uvm.edu  best@cs.bu.edu  
Title: Pinwheel Scheduling for Fault-tolerant Broadcast Disks in Real-time Database Systems  
Author: Sanjoy Baruah Azer Bestavros 
Affiliation: The University of Vermont Department of Computer Science  Boston University Computer Science Department  
Note: Proceedings of ICDE'97: The IEEE InternationalConference on Data Engineering, April 1997, Birmingham, England.  
Abstract: The design of programs for broadcast disks which incorporate real-time and fault-tolerance requirements is considered. A generalized model for real-time fault-tolerant broadcast disks is defined. It is shown that designing programs for broadcast disks specified in this model is closely related to the scheduling of pinwheel task systems. Some new results in pinwheel scheduling theory are derived, which facilitate the efficient generation of real-time fault-tolerant broadcast disk programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Acharya, R. Alonso, M. Franklin, and S. Zdonik. </author> <title> Broadcast disks: Data management for asymmetric communications environments. </title> <booktitle> In Proceedings of ACM SIGMOD conference, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: On the client side, this hierarchy gives rise to cache management and prefetching issues (e.g., cache replacement strategies to improve the hit ratio or reduce miss penalty). In [2], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management <ref> [1] </ref>, client-initiated prefetching to improve the communication latency for database access systems [4], and techniques for disseminating updates [3].
Reference: [2] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Dissemination-based data delivery using broadcast disks. </title> <journal> IEEE Personal Communications, </journal> <volume> 2(6), </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency). On the client side, this hierarchy gives rise to cache management and prefetching issues (e.g., cache replacement strategies to improve the hit ratio or reduce miss penalty). In <ref> [2] </ref>, Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems [4], and techniques for disseminating updates [3]. <p> Therefore, bc (i; 2; [5; 6; 6]) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition. Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice <p> Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice conjunct of pinwheel conditions pc (i; 1; 2) ^ pc (i 0 ; 2; 3) ^ map (i; i 0 ), which has a density of 1=2 + 1=3 = 0:8333. 5.
Reference: [3] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Disseminating updates on broadcast disks. </title> <booktitle> In Proceedings of VLDB'96: The 1996 International Conference on Very Large Databases, </booktitle> <address> India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: In [2], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems [4], and techniques for disseminating updates <ref> [3] </ref>. <p> Therefore, bc (i; 2; [5; 6; 6]) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition. Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice <p> Example 6 bc (i; 1; <ref> [2; 3] </ref>) pc (i; 1; 2) ^ pc (i; 2; 3). By R2, pc (i; 2; 3) ) pc (i; 1; 2); therefore, pc (i; 2; 3), with a density of 0:6667, is an equivalent nice pinwheel condition. Applying TR2 directly to bc (i; 1; [2; 3]) would yield the nice conjunct of pinwheel conditions pc (i; 1; 2) ^ pc (i 0 ; 2; 3) ^ map (i; i 0 ), which has a density of 1=2 + 1=3 = 0:8333. 5.
Reference: [4] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Prefetching from a broadcast disk. </title> <booktitle> In Proceedings of ICDE'96: The 1996 International Conference on Data Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: In [2], Acharya, Franklin and Zdonik discuss Bdisks organization issues, including client cache management [1], client-initiated prefetching to improve the communication latency for database access systems <ref> [4] </ref>, and techniques for disseminating updates [3].
Reference: [5] <author> S. Baruah and A. Bestavros. </author> <title> Pinwheel scheduling for fault-tolerant broadcast disks in real-time database systems. </title> <type> Technical Report TR-1996-023, </type> <institution> Computer Science Department, Boston University, </institution> <year> 1996. </year>
Reference-contexts: R5 pc (i; a; b) ^ pc (i; na; nb x) ( pc (i; a; b) ^ (Proofs may be found in <ref> [5] </ref>) In Figure 6, we present some rules for manipulating pinwheel conditions. In each, we have some condition on the LHS that is implied by some (hopefully, more useful) condition on the RHS. We may use these rules to obtain some fairly useful generic transformations, which are formally proved in [5]: <p> <ref> [5] </ref>) In Figure 6, we present some rules for manipulating pinwheel conditions. In each, we have some condition on the LHS that is implied by some (hopefully, more useful) condition on the RHS. We may use these rules to obtain some fairly useful generic transformations, which are formally proved in [5]: Transformation rule 1 (TR1) bc (i; m i ; ~ d i ) ( pc (i; 1; min f d i % Transformation rule 2 (TR2) bc (i; m i ; ~ d i ) ( pc (i; m i ; d i ) (1) ^ pc (i 2 ; <p> f (m i + j)=d (j) i g is a lower bound on the density of any pinwheel condition (or nice conjunct of pinwheel conditions) that may imply bc (i; m i ; ~ d i ). (This bound may not be actually achievable | for example, bc (i; 2; <ref> [5; 7] </ref>) is not implied by any nice conjunct of pinwheel conditions of density 3=7). We refer to max j0 f (m i + j)=d (j) i g as the density lower bound of broadcast file condition bc (i; m i ; ~ d i ). <p> Example 5 When d (j) (j+1) i , rule R0 may be used to rid of one conjunct. Thus, bc (i; 2; <ref> [5; ; 6] </ref>) pc (i; 2; 5) ^ pc (i; 3; 6) ^ pc (i; 4; 6), which simplifies to pc (i; 2; 5) ^ pc (i; 4; 6). <p> By R1, pc (i; 2; 3) ) pc (i; 4; 6); by R0, pc (i; 2; 3) ) pc (i; 2; 5). Therefore, bc (i; 2; <ref> [5; 6; 6] </ref>) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition.
Reference: [6] <author> A. Bestavros. SETH: </author> <title> A VLSI chip for the real-time information dispersal and retrieval for security and fault-tolerance. </title> <booktitle> In Proceedings of ICPP'90, The 1990 International Conference on Parallel Processing, </booktitle> <address> Chicago, Illinois, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The process of processing F is called the dispersal of F , whereas the process of retrieving F by collecting m of its pieces is called the reconstruction of F . Both the dispersal and reconstruction operations can be performed in real-time <ref> [6] </ref>. <p> The first specifies the data item to which the block belongs (e.g., this is page 3 of object Z). The 1 For more details, we refer the reader to the papers by Rabin [23] and Bestavros <ref> [6] </ref> on IDA implementation. 2 Another alternative is to broadcast a directory (or index [18]) at the beginning of each broadcast period. <p> Example 5 When d (j) (j+1) i , rule R0 may be used to rid of one conjunct. Thus, bc (i; 2; <ref> [5; ; 6] </ref>) pc (i; 2; 5) ^ pc (i; 3; 6) ^ pc (i; 4; 6), which simplifies to pc (i; 2; 5) ^ pc (i; 4; 6). <p> By R1, pc (i; 2; 3) ) pc (i; 4; 6); by R0, pc (i; 2; 3) ) pc (i; 2; 5). Therefore, bc (i; 2; <ref> [5; 6; 6] </ref>) ( pc (i; 2; 3). Observe that this is an optimal transformation, in that the density of this nice pinwheel condition is equal to the density lower bound of the broadcast condition.
Reference: [7] <author> A. Bestavros. </author> <title> An adaptive information dispersal algorithm for time-critical reliable communication. </title> <editor> In I. Frisch, M. Malek, and S. Panwar, editors, </editor> <title> Network Management and Control, Volume II. </title> <publisher> Plenum Publishing Corporation, </publisher> <address> New York, New York, </address> <year> 1994. </year>
Reference-contexts: The IDA approach is different in that redundancy is added uniformly; there is simply no distinction between data and parity. It is this feature that makes it possible to scale the amount of redundancy used in IDA. Indeed, this is the basis for the adaptive IDA (AIDA) <ref> [7] </ref>. Using AIDA, a bandwidth allocation operation is inserted after the dispersal operation but prior to transmission as shown in Figure 3. This bandwidth allocation step allows the system to scale the amount of redundancy used in the transmission. <p> f (m i + j)=d (j) i g is a lower bound on the density of any pinwheel condition (or nice conjunct of pinwheel conditions) that may imply bc (i; m i ; ~ d i ). (This bound may not be actually achievable | for example, bc (i; 2; <ref> [5; 7] </ref>) is not implied by any nice conjunct of pinwheel conditions of density 3=7). We refer to max j0 f (m i + j)=d (j) i g as the density lower bound of broadcast file condition bc (i; m i ; ~ d i ).
Reference: [8] <author> A. Bestavros. </author> <title> AIDA-based real-time fault-tolerant broadcast disks. </title> <booktitle> In Proceedings of RTAS'96: The 1996 IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Boston, Massachusetts, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: First, we show that the problem of designing real-time Bdisk programs is intimately linked to the pinwheel scheduling problem [14], and make use of this link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in <ref> [8] </ref>), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. Next, we present a more general model for real-time fault-tolerant Bdisks that subsumes the simple model presented in [8]. <p> link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in <ref> [8] </ref>), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. Next, we present a more general model for real-time fault-tolerant Bdisks that subsumes the simple model presented in [8]. We derive a pinwheel algebra|some simple rules for manipulating pinwheel conditions|and demonstrate through examples how these rules may be used to efficiently construct broadcast programs for generalized fault-tolerant real-time Bdisks. The rest of this paper is organized as follows. <p> The rest of this paper is organized as follows. In Section 2, we discuss the basics of AIDA-based organization of Bdisks for timeliness and fault tolerance as proposed in <ref> [8] </ref>. In Section 3, we review pinwheel scheduling theory, and describe how AIDA-based Bdisks are related to pinwheel systems. In Section 4, we introduce the concept of generalized real-time fault-tolerant Bdisks, and describe pinwheel-based procedures for organizing data on such disks. 2. <p> This broadcast period may be very long since the broadcast disk may include thousands of other blocks, which the server must transmit before getting back to the block in question. For real-time systems, such a delay may result in missing critical timing constraints. In <ref> [8] </ref>, Bestavros proposed the use of AIDA to mask (or otherwise minimize) the impact of such failures in a real-time environment. AIDA is a technique for dynamic bandwidth allocation, which makes use of minimal, controlled redundancy to guarantee timeliness and fault-tolerance up to any degree of confidence. <p> The examples below illustrate how rules R0-R3 and R5 may be sometimes used to simplify the conjunct of pinwheel conditions obtained by the application of transformation rules TR1 and TR2. Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0. <p> Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0.
Reference: [9] <author> A. Bestavros and S. Nagy. </author> <title> Value-cognizant admission control for rtdbs. </title> <booktitle> In Proceedings of RTSS'96: The 16 th IEEE Real-Time System Symposium, </booktitle> <address> Washington, DC, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: For example, the constraint would only be 6; 000 msecs for the data item recording the position of a tank with a velocity of 60 km/hour. Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control <ref> [9] </ref>, con-currency control, transaction scheduling [22], recovery [16], and bounded imprecision [25, 26]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure. <p> The examples below illustrate how rules R0-R3 and R5 may be sometimes used to simplify the conjunct of pinwheel conditions obtained by the application of transformation rules TR1 and TR2. Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0. <p> Example 4 F i has m i = 4, and ~ d i = <ref> [8; 9] </ref>. This is represented by bc (i; 4; [8; 9]), and has a density lower bound of 0:5556. By Rule TR1, this is implied by pc (i; 1; 1), which has a density of 1:0.
Reference: [10] <author> M. Y. Chan and F. Chin. </author> <title> Schedulers for the pinwheel problem based on double-integer reduction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(6) </volume> <pages> 755-768, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: When the number of tasks is not restricted, Holte et al [14] have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. Chan and Chin <ref> [11, 10] </ref> have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 [10]. <p> Chan and Chin [11, 10] have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 <ref> [10] </ref>. Pinwheel Scheduling for Bdisks Suppose that a broadcast file F i is specified by a size m i 2 N in blocks and a latency T i 2 N in seconds. <p> Since the algorithm of Chan and Chin <ref> [10] </ref> can schedule any pinwheel task system with density at most 7=10, a bandwidth B = 10 n X m i ' is sufficient for this purpose; since P n m i T i is clearly necessary, this represents a reasonably efficient upper bound, in that at most 43% extra bandwidth <p> Furthermore, this upper bound is easily and efficiently realised | given this much bandwidth, the scheduling algorithm of Chan and Chin <ref> [10] </ref> can be used to determine the actual layout of blocks on the Bdisk. The fault-tolerance case when up to r faults must be tolerated is similarly handled. <p> Obtaining Broadcast Programs for Generalized Bdisks Recall that Chan and Chin <ref> [10] </ref> have designed an algorithm for scheduling any system of pinwheel tasks that has a density of at most 0:7. <p> this algorithm determines a P satisfying pc (1; a 1 ; b 1 ) ^ pc (2; a 2 ; b 2 ) ^ : : : ^ pc (n; a n ; b n ); provided ( P n An important observation about this algorithm of Chan and Chin <ref> [10] </ref> is that it can only schedule pinwheel task systems where each task is constrained by a single pinwheel condition. That is, we do not have any i such that both pc (i; a; b) and pc (i; a 0 ; b 0 ) must be satisfied. <p> In order to do so, we must be able to convert a conjunct of pinwheel conditions on a single task into either a single pinwheel condition, or to a conjunct of pinwheel conditions on several tasks, such that these new conditions imply the original ones. Since the test of <ref> [10] </ref> is density-based, we would like to be able to perform such a conversion while causing the minimum possible increase in the density of the system.
Reference: [11] <author> M. Y. Chan and F. Chin. </author> <title> Schedulers for larger classes of pinwheel instances. </title> <journal> Algorithmica, </journal> <volume> 9 </volume> <pages> 425-462, </pages> <year> 1993. </year>
Reference-contexts: When the number of tasks is not restricted, Holte et al [14] have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. Chan and Chin <ref> [11, 10] </ref> have significantly improved this result, designing a series of algorithms with successively better density bounds, culminating finally in one that can schedule any pinwheel system with a density at most 7=10 [10].
Reference: [12] <author> G. Gibson, L. Hellerstein, R. Karp, R. Katz, and D. Patterson. </author> <title> Coding techniques for handling failures in large disk arrays. </title> <type> Technical Report UCB/CSD 88/477, </type> <institution> Computer Science Division, University of Cal-ifornia, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: Adaptive IDA In most fault-tolerant redundancy-injecting communication protocols, redundancy is injected in the form of parity blocks, which are only used for error detection and/or correction purposes <ref> [12] </ref>. The IDA approach is different in that redundancy is added uniformly; there is simply no distinction between data and parity. It is this feature that makes it possible to scale the amount of redundancy used in IDA. Indeed, this is the basis for the adaptive IDA (AIDA) [7].
Reference: [13] <author> D. Gifford. </author> <title> Ploychannel systems for mass digital communication. </title> <journal> Communications of the ACM, </journal> <volume> 33, </volume> <month> Febru-ary </month> <year> 1990. </year>
Reference-contexts: by continuously and repeatedly broadcasting data to clients, thus in effect making the broadcast channel act as a set of disks (hence the term "Broadcast Disks") from which clients could fetch data "as it goes by." Work on Bdisks is different from previous work in both wired and wireless networks <ref> [13, 17] </ref> in that several sources of data are multiplexed and broadcast to clients, thus creating a hierarchy of Bdisks with different sizes and speeds. On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency).
Reference: [14] <author> R. Holte, A. Mok, L. Rosier, I. Tulchinsky, and D. Varvel. </author> <title> The pinwheel: A real-time scheduling problem. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on System Science, </booktitle> <pages> pages 693-702, </pages> <address> Kailua-Kona, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: This research: The contributions of this paper are twofold. First, we show that the problem of designing real-time Bdisk programs is intimately linked to the pinwheel scheduling problem <ref> [14] </ref>, and make use of this link to (1) derive upper bounds on the bandwidth requirements for real-time fault-tolerant Bdisks (corresponding to the lower bounds in [8]), and (2) obtain efficient algorithms for designing fault-tolerant real-time Bdisk programs. <p> In the remainder of this paper, we discuss the use of pinwheel scheduling to achieve such uniform distribution. 3. Pinwheel Task Systems Pinwheel task systems were introduced by Holte et al. <ref> [14] </ref>, in the context of o*ine scheduling for satellite-based communication. <p> When the number of tasks is not restricted, Holte et al <ref> [14] </ref> have a simple and elegant algorithm for scheduling any pinwheel task system with density at most one-half. <p> Given F 1 ; F 2 ; : : : ; F n , the problem of determining minimum bandwidth (in blocks/sec) reduces to determining the smallest B 2 N such that the system of pinwheel tasks <ref> [14] </ref> f (1; m 1 ; BT 1 ); (2; m 2 ; BT 2 ); : : : ; (n; m n ; BT n )g can be scheduled.
Reference: [15] <author> R. Holte, L. Rosier, I. Tulchinsky, and D. Varvel. </author> <title> Pinwheel scheduling with two distinct numbers. </title> <journal> Theoretical Computer Science, </journal> <volume> 100(1) </volume> <pages> 105-135, </pages> <year> 1992. </year>
Reference-contexts: The issue of designing efficient scheduling algorithms for pinwheel task systms has been the subject of much research. Holte et al <ref> [15] </ref> presented an algorithm which schedules any pinwheel task system of two tasks with density at most one.
Reference: [16] <author> J. Huang and L. Gruenwald. </author> <title> An update-frequency-valid-interval partition checkpoint technique for real-time main memory databases. </title> <booktitle> In Proceedings of RTDB'96: The 1996 Workshop on Real-Time Databases, </booktitle> <pages> pages 135-143, </pages> <address> Newport Beach, California, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [9], con-currency control, transaction scheduling [22], recovery <ref> [16] </ref>, and bounded imprecision [25, 26]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [17] <author> T. Imielinski and B. Badrinath. </author> <title> Mobile wireless computing: Challenges in data management. </title> <journal> Communications of the ACM, </journal> <volume> 37, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: by continuously and repeatedly broadcasting data to clients, thus in effect making the broadcast channel act as a set of disks (hence the term "Broadcast Disks") from which clients could fetch data "as it goes by." Work on Bdisks is different from previous work in both wired and wireless networks <ref> [13, 17] </ref> in that several sources of data are multiplexed and broadcast to clients, thus creating a hierarchy of Bdisks with different sizes and speeds. On the server side, this hierarchy gives rise to memory management issues (e.g., allocation of data to Bdisks based on priority/urgency).
Reference: [18] <author> T. Imielinski, S. Viswanathan, and B. Badrinath. </author> <title> Energy efficient indexing on air. </title> <booktitle> In Proceedings of ACM SIGMOD Conference, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The 1 For more details, we refer the reader to the papers by Rabin [23] and Bestavros [6] on IDA implementation. 2 Another alternative is to broadcast a directory (or index <ref> [18] </ref>) at the beginning of each broadcast period.
Reference: [19] <author> IVHS America. </author> <title> IVHS architecture development program: </title> <type> Interim status report, </type> <month> April </month> <year> 1994. </year>
Reference-contexts: IVHS systems allow for automated route guidance and automated rerouting around traffic incidents by allowing the mobile vehicle software to query and react to changes in IVHS databases <ref> [20, 19] </ref>. Other examples include wearable computers for soldiers in the battlefield and computerized cable boxes for future interactive TV networks and video-on-demand. Such systems are characterized by the significant discrepancy between the downstream communication capacity from servers (e.g.
Reference: [20] <author> R. Jurgen. </author> <title> Smart cars and highways go global. </title> <journal> IEEE Spectrum, </journal> <pages> pages 26-37, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: IVHS systems allow for automated route guidance and automated rerouting around traffic incidents by allowing the mobile vehicle software to query and react to changes in IVHS databases <ref> [20, 19] </ref>. Other examples include wearable computers for soldiers in the battlefield and computerized cable boxes for future interactive TV networks and video-on-demand. Such systems are characterized by the significant discrepancy between the downstream communication capacity from servers (e.g.
Reference: [21] <author> S. S. Lin and K. J. Lin. </author> <title> Pinwheel scheduling with three distinct numbers. </title> <booktitle> In Proceedings of the EuroMi-cro Workshop on Real-Time Systems, </booktitle> <address> Vaesteraas, Swe-den, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The issue of designing efficient scheduling algorithms for pinwheel task systms has been the subject of much research. Holte et al [15] presented an algorithm which schedules any pinwheel task system of two tasks with density at most one. Lin & Lin <ref> [21] </ref> have designed an algorithm which schedules any pinwheel task system of three tasks with a density at most five-sixth's (this algorithm is optimal in the sense that, as the third example pinwheel task system in Example 1 shows, there are three-task systems with density 5=6 + * that are infeasible,
Reference: [22] <author> Ozgur Ulusoy and A. Buchmann. </author> <title> Exploiting main memory dbms features to improve real-time concur-rency protocols. </title> <journal> ACM SIGMOD Record, </journal> <volume> 25(1), </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [9], con-currency control, transaction scheduling <ref> [22] </ref>, recovery [16], and bounded imprecision [25, 26]. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [23] <author> M. O. Rabin. </author> <title> Efficient dispersal of information for security, load balancing and fault tolerance. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 36(2) </volume> <pages> 335-348, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: AIDA is a technique for dynamic bandwidth allocation, which makes use of minimal, controlled redundancy to guarantee timeliness and fault-tolerance up to any degree of confidence. AIDA is an elaboration on the Information Dispersal Algorithm of Rabin <ref> [23] </ref>. 2.1. Information Dispersal and Retrieval Let F represent the original data object (hereinafter referred to as the file) to be communicated (or retrieved). Furthermore, assume that file F is to be communicated by sending N independent transmissions. <p> The first specifies the data item to which the block belongs (e.g., this is page 3 of object Z). The 1 For more details, we refer the reader to the papers by Rabin <ref> [23] </ref> and Bestavros [6] on IDA implementation. 2 Another alternative is to broadcast a directory (or index [18]) at the beginning of each broadcast period.
Reference: [24] <author> K. Ramamritham. </author> <title> Real-time databases. </title> <journal> International journal of Distributed and Parallel Databases, </journal> <volume> 1(2), </volume> <year> 1993. </year>
Reference-contexts: Problems that arise when timing and reliability constraints are imposed on the system were not considered. Real-time considerations: There are many reasons for subjecting Bdisk data retrieval to timing constraints. Perhaps the most compelling is due to the absolute temporal consistency constraints <ref> [24] </ref> that may be imposed on data objects.
Reference: [25] <author> W.-K. Shih, J. Liu, and J.-Y. Chung. </author> <title> Algorithms for scheduling imprecise computations with timing constraints. </title> <journal> SIAM journal of Computing, </journal> <month> July </month> <year> 1991. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [9], con-currency control, transaction scheduling [22], recovery [16], and bounded imprecision <ref> [25, 26] </ref>. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [26] <author> V. F. Wolfe, L. C. DiPippo, and J. K. Black. </author> <title> Supporting concurrency, timing constraints and imprecision in objects. </title> <type> Technical Report TR94-230, </type> <institution> University of Rhode Island, Computer Science Department, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Other reasons for imposing timing constraints on data retrieval from a Bdisk are due to the requirements of database protocols for admission control [9], con-currency control, transaction scheduling [22], recovery [16], and bounded imprecision <ref> [25, 26] </ref>. The real-time constraints imposed on Bdisks protocols become even more pressing when issues of fault-tolerance are to be considered. Current Bdisks protocols assume that the broadcast infrastructure is not prone to failure.
Reference: [27] <author> S. Zdonik, M. Franklin, R. Alonso, and S. Acharya. </author> <booktitle> Are `disks in the air' just pie in the sky? In Proceedings of the IEEE Workshop on Mobile Computing Systems and Applications, </booktitle> <address> Santa Cruz, CA, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Broadcast Disks: The concept of Broadcast Disks (Bdisks) was introduced by Zdonik et al. <ref> [27] </ref> as a mechanism that uses communication bandwidth to emulate a storage device (or a memory hierarchy in general) for mobile clients of a database system.
References-found: 27

