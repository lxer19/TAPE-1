URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-711.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr700.html
Root-URL: 
Title: Subclassing  
Author: Raymie Stata 
Date: April 1997  
Note: Modularity in the Presence of  
Abstract: Massachusetts Institute of Technology Laboratory for Computer Science Technical Report 711 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi95] <author> M. Abadi and L. Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> ECOOP '95 Proceedings (Aarhus, </booktitle> <address> Denmark, </address> <month> Aug. </month> <year> 1995). </year> <booktitle> Published as LNCS 952, </booktitle> <pages> pages 145-67. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <month> Aug., </month> <year> 1995. </year>
Reference-contexts: This pursuit has lead to the recognition that "[code] inheritance is not subtyping" [Cook90], and that flexible subclassing requires special consideration (see, e.g., <ref> [Abadi95] </ref> and [Fisher95]). 94 CHAPTER 8. CONCLUSION An important connection between our work and work on kernel languages is the separation of subtyping and subclassing. This separation, central to our own work, was first fully developed in the context of kernel languages.
Reference: [America91] <author> P. </author> <title> America. Designing an object-oriented programming language with be-havioural subtyping. </title> <booktitle> Foundations of Obj.-Orien. Lang. (Noordwijkerhout, The Nether-lands, May/June 1990). Published as LNCS 489, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, they do not address the problems raised in trying to specify specialization interfaces. Related to this work is work on specifications and behavioral subtype relations for type hierarchies <ref> [Leavens89, America91, Liskov94] </ref>. We borrowed heavily from this work, especially the work of Liskov and Wing [Liskov94]. But again, none of this work addresses specialization interfaces, including Leavens' more recent work on Larch/C++ [Cheon94]. An active area of work is on kernel languages.
Reference: [Atkinson92] <author> B. Atkinson. </author> <title> Panel: reuse|truth or fiction. </title> <booktitle> OOPSLA '92 Conf. Proceedings (Vancouver, </booktitle> <month> Oct. </month> <year> 1992). </year> <journal> Published as SIGPLAN Notices, </journal> <volume> 27(10) </volume> <pages> 41-2. </pages> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Further, as pointed out in Chapter 1, current documentation does not tell specializers what they need to know to build subclasses. Recognizing this reality, most vendors ship the source code of their class libraries <ref> [Atkinson92] </ref>. When customers look at source code, they become dependent on implementation details that vendors may want to change, so vendors become hamstrung when improving implementations, and customers have to worry about new versions invalidating their code. The ideas in this report can improve documentation in a number of ways.
Reference: [Birrell91] <author> A. D. Birrell, J. V. Guttag, J. J. Horning, and R. Levin. </author> <title> Thread synchronization: a formal specification. </title> <booktitle> In Systems Programming with Modula-3, </booktitle> <pages> pages 119-29. </pages> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: It remains to be seen whether true, operational specifications are needed, or whether declarative specifications with an operational flavor will work (see, e.g., the use of "actions" in <ref> [Birrell91] </ref>). As mentioned above, a number of books describe full methodologies for object-oriented programming, but none of these methodologies pay as close attention designing specialization interfaces as we have. Thus, an obvious next step is to use the ideas in this report to improve the treatment of specialization interfaces.
Reference: [Booch94] <author> G. Booch. </author> <title> Object-Oriented Analysis and Design, with Applications, 2nd ed. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <year> 1994. </year>
Reference-contexts: We call these smaller classes mixins, after the 79 80 CHAPTER 7. MULTIPLE INHERITANCE process of "mixing" them together to form larger classes. ("Mixin" was first coined in the Flavors community [Weinreb81], but our use follows <ref> [Booch94] </ref>.) The first section below describes how mixins can be supported in Java with only minimal language changes. The next section explains how a simplified subset of the specification and verification techniques of the previous chapters applies directly to mixins. <p> However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable methods). Many text books cover object-oriented design (e.g., [Rumbaugh91], <ref> [Booch94] </ref>). However, none consider the design of specialization interfaces. [Kiczales91] and [Kiczales92] present principles and advice for designing specialization interfaces, but they concentrate on layered control abstractions and do not discuss class components, abstract representations or representation categories. <p> The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], <ref> [Booch94] </ref>, [Taligent94], 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]). A mixin is distinguished from other partial classes by the intent of its designers. <p> It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], <ref> [Booch94] </ref>, [Taligent94], 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]). A mixin is distinguished from other partial classes by the intent of its designers. A typical, partial class is like a mostly completed puzzle, with deferred methods representing a few missing pieces.
Reference: [Borland94] <author> Borland ObjectWindows Programmer's Guide, </author> <title> version 2.5. Borland, </title> <publisher> Inc., </publisher> <address> Scotts Valley, CA, </address> <year> 1994. </year>
Reference-contexts: In existing programming methodologies, classes are treated as the unit of modularity. As a result, documentation for class libraries draws abstraction barriers around entire classes (see, e.g., <ref> [Borland94] </ref> and [Microsoft94]). This is fine for instantiators, clients whose code manipulates instances of a class. However, specializers, clients who create subclasses, use method override to replace parts of classes, and thus interact with classes at a finer granularity. For specializers, classes are too coarse a unit of modularity.
Reference: [Bracha90] <author> G. Bracha and W. Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> ECOOP/OOPSLA '90 Conf. Proceedings (Ottawa, </booktitle> <address> Canada, </address> <month> Oct. </month> <year> 1990). </year> <journal> Published as SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 303-11. </pages> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., [Keene88], <ref> [Bracha90] </ref>, [Booch94], [Taligent94], 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]). A mixin is distinguished from other partial classes by the intent of its designers.
Reference: [Brown91] <author> M. R. Brown and G. Nelson. </author> <title> I/O streams: abstract types, real programs. </title> <booktitle> In Systems Programming with Modula-3, </booktitle> <pages> pages 130-69. </pages> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: An example of deferred state is given in Fig. 2.2. This figure presents a partial implementation of Rd ("reader"), a character input stream inspired by the Modula-3 library <ref> [Brown91] </ref>. Different subclasses of Rd read characters from different sources, e.g., the source of FileRd is disk files, while the source of SocketRd is network connections.
Reference: [Bruce96] <author> K. Bruce, L. Cardelli, G. Castagna, The Hopkins Object Group, G. Leavens, and B. Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Obj. Sys., </journal> <note> 1996. (To appear.). </note>
Reference-contexts: When done through methods, accesses of the state of an overridable component will still work as expected when subclasses replace the component. Binary methods, generally a problem (see, e.g., [Liskov93] and <ref> [Bruce96] </ref>), must be treated with care. A binary method of class C is a method that takes one or more arguments of type C in addition to this. In most languages, the code in binary C's methods has privileged access to all arguments of type C, not just to this.
Reference: [Castagna95] <author> G. Castagna and G. T. Leavens. </author> <title> Foundations of object-oriented languages: 2nd workshop report. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(2) </volume> <pages> 5-11. </pages> <publisher> ACM Press, </publisher> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: This work aims at finding the lambda-calculus of object-oriented programming, i.e., a tiny language kernel that embodies the essence of object-oriented programming. Currently, there are four major approaches (a survey of three can be found in [Wadler94], and the fourth is presented in <ref> [Castagna95] </ref>). The focus of this work has been on type systems that eliminate "message not understood" errors without giving up too much of the flexibility of untyped object systems.
Reference: [Cheon94] <author> Y. Cheon and G. T. Leavens. </author> <title> A quick overview of Larch/C++. </title> <journal> JOOP., </journal> <volume> 7(6) </volume> <pages> 39-49. </pages> <address> SIGS, </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Related to this work is work on specifications and behavioral subtype relations for type hierarchies [Leavens89, America91, Liskov94]. We borrowed heavily from this work, especially the work of Liskov and Wing [Liskov94]. But again, none of this work addresses specialization interfaces, including Leavens' more recent work on Larch/C++ <ref> [Cheon94] </ref>. An active area of work is on kernel languages. This work aims at finding the lambda-calculus of object-oriented programming, i.e., a tiny language kernel that embodies the essence of object-oriented programming.
Reference: [Cook90] <author> W. R. Cook, W. L. Hill, and P. S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> Proc. 17th POPL (San Francisco, </booktitle> <address> CA, </address> <month> Jan. </month> <year> 1990), </year> <pages> pages 125-35. </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1990. </year> <note> 97 98 BIBLIOGRAPHY </note>
Reference-contexts: The focus of this work has been on type systems that eliminate "message not understood" errors without giving up too much of the flexibility of untyped object systems. This pursuit has lead to the recognition that "[code] inheritance is not subtyping" <ref> [Cook90] </ref>, and that flexible subclassing requires special consideration (see, e.g., [Abadi95] and [Fisher95]). 94 CHAPTER 8. CONCLUSION An important connection between our work and work on kernel languages is the separation of subtyping and subclassing.
Reference: [Dahl92] <author> O.-J. Dahl. </author> <title> Verifiable Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: We verify that a component is correct using standard data refinement procedures ([Hoare72], [Liskov86], <ref> [Dahl92] </ref>) adapted to ensure independence. This section describes this adaptation. It starts with an overview of our approach, discusses the mechanics, and ends with an example.
Reference: [Day95] <author> M. Day, R. Gruber, B. Liskov, and A. Myers. </author> <title> Subtypes vs. where clauses: constraining parametric polymorphism. </title> <booktitle> OOPSLA '95 Conf. Proceedings (Austin, TX). Published as ACM SIGPLAN Notices, </booktitle> <volume> 30(10) </volume> <pages> 156-68. </pages> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1995. </year>
Reference: [Detlefs96] <author> D. L. Detlefs. </author> <title> An overview of the extended static checking system. </title> <booktitle> Proc. the Workshop on Formal Methods in Softw. </booktitle> <address> Practice (San Diego, CA). </address> <note> Published as SIG-SOFT. ACM, </note> <month> Jan. </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Formal verification, where it is possible, greatly improves confidence in the correctness of code. Even where verification against full specifications is not cost-effective, verification against partial specifications has proven useful <ref> [Detlefs96] </ref>. The second reason to pursue formal specifications and verification is that it helps us evaluate our informal results. By formalizing our informal techniques in a manner that is sound and elegant, we increase our confidence in the soundness of and, more generally, in the "goodness" of the informal techniques. <p> This extra formality has proven useful for generating verification conditions in the Extended Static Checker <ref> [Detlefs96] </ref>. Our work is more general than [Leino95].
Reference: [Edwards96] <author> S. H. Edwards. </author> <title> Representation inheritance: a safe form of "white box" code inheritance. </title> <booktitle> Proc. the Fourth Intl Conf. on Softw. Reuse (Washingtond, </booktitle> <address> DC., </address> <month> Apr., </month> <year> 1996), </year> <pages> pages 195-204. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <month> Apr. </month> <year> 1996. </year> <note> (To appear.). </note>
Reference: [Evans96] <author> D. Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> ACM SIGPLAN 1996 PLDI (Philadelphia, </booktitle> <address> PA., </address> <month> May </month> <year> 1996), </year> <note> page ACM., </note> <month> May </month> <year> 1996. </year>
Reference-contexts: An alternative is to use comment-embedded annotations to support overridable class components and to do checking with a tool that works beside the compiler. This alternative approach is taken by LCLint to support data abstraction in C <ref> [Evans96] </ref>. Except for the discussion on optimization, the discussion below applies equally to both approaches. 6.4.1 A construct for overridable components Support for overridable class component requires just a small amount of syntax. What is needed is a construct in class definitions for grouping declarations of methods and instance variables.
Reference: [Fisher95] <author> K. Fisher and J. C. Mitchell. </author> <title> A delegation-based object calculus with subtyp-ing. </title> <booktitle> Fundamentals of Computation Theory: Proc. 10th Intl Conf., FCT '95 (Dresden, </booktitle> <address> Germany, </address> <month> Aug. </month> <year> 1995). </year> <booktitle> Published as LNCS 965, </booktitle> <pages> pages 42-61. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: This pursuit has lead to the recognition that "[code] inheritance is not subtyping" [Cook90], and that flexible subclassing requires special consideration (see, e.g., [Abadi95] and <ref> [Fisher95] </ref>). 94 CHAPTER 8. CONCLUSION An important connection between our work and work on kernel languages is the separation of subtyping and subclassing. This separation, central to our own work, was first fully developed in the context of kernel languages.
Reference: [Goldberg89] <author> A. Goldberg and D. Robinson. </author> <title> Smalltalk-80: The Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <year> 1989. </year>
Reference-contexts: EXTENSIBLE SPECIALIZATION SPECIFICATIONS 59 Fig. 5.2 gives IntCollection, a partial class for building integer collections. This class is inspired by the Collection class in the Smalltalk library <ref> [Goldberg89] </ref>. This class provides code for about two dozen methods common to collection classes, such as membership-testing, adding and removing multiple members from an array, and so-on. Subclasses provide their own implementation for the elements component and can inherit these two dozen methods.
Reference: [Gosling96] <author> J. Gosling and F. Yellin. </author> <title> The Java Application Programming Interface Volume 2: Window Toolkit and Applets. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <month> May, </month> <year> 1996. </year> <note> (To appear.). </note>
Reference-contexts: This leads to libraries that do not use interfaces very aggressively. For example, if the VObject hierarchy was done in Java, then, for code sharing purposes, EvtHandler would be a Java class, meaning the entire VObject hierarchy would consist of Java classes. Java's own GUI class library <ref> [Gosling96] </ref> uses classes high in the type hierarchy, and as a result it makes very little use of interfaces. With mixins, interfaces can be pushed deeper in the type hierarchy. For example, in Fig. 7.7b, EvtHandler and other types with (interface) next to their names would be defined using interfaces.
Reference: [Guttag93] <author> J. V. Guttag and J. J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: As one tries to increase the precision of informal documentation, it tends to get long-winded and, as a result, confusing. Formal specifications, on the other hand, are simultaneously precise, clear, and concise. In addition, formal specifications can be mechanically checked both for syntax and for certain semantic "goodness" properties <ref> [Guttag93] </ref>, helping designers to catch mistakes. Formal verification, where it is possible, greatly improves confidence in the correctness of code. Even where verification against full specifications is not cost-effective, verification against partial specifications has proven useful [Detlefs96]. <p> el) f Modifies: this Ensures: this post = insert (el; this pre ) g public boolean contains (int el) f Ensures: result = el 2 this pre g ..other methods elided g Our object specifications use Larch Shared Language (LSL) traits to define sorts and function symbols used in specifications <ref> [Guttag93] </ref>. IntSetISpec in Fig. 4.1 uses the trait Set. The Set trait is given in Fig. 4.2. The Set trait first gives signatures for insert, delete, and other common functions on sets. Next, it asserts axioms that define these functions. <p> To verify addElement, one needs the instance specification for IntVector given in Fig. 4.9, which in turn uses the LSL Sequence sort from <ref> [Guttag93] </ref>. A full verification is not presented here, just enough to illustrate the use of V i to verify method components. To verify addElement, one must define A add , the subabstraction function for its components. <p> For example, most collection libraries have a collection type that is a supertype of all other collection types, and specifying this type raises the same issue. The issue also arises in the context of designing LSL handbooks, collections of LSL traits defining related sorts <ref> [Guttag93] </ref>. Below we propose a solution that seems promising for specifying both the instance and specialization specifications of classes. However, the important point here is the identification of the general problem as it pertains to specifying classes.
Reference: [Harrison93] <author> W. Harrison and H. Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> OOPSLA '93 Conf. Proceedings (Washington, </booktitle> <address> DC, </address> <month> Oct. </month> <year> 1993). </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 411-27. </pages> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: In essence, this report does just that: it figures out how to think about abstract state in the context of subclassing. As other approaches to data abstraction are introduced, e.g., object-based [Ungar91], role-based [VanHilst96], and subject-oriented <ref> [Harrison93] </ref> programming, the issue of abstract state will have to be revisited again.
Reference: [Hoare72] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 273-81. </pages> <publisher> Springer-Verlag, </publisher> <year> 1972. </year>
Reference-contexts: Object specifications describe the behavior of objects. The object specification documenting a class describes the behavior of direct instances of the class. (Documenting classes by describing their instances is nothing new and goes back at least to <ref> [Hoare72] </ref>.) IntSetISpec, an example object specification for IntSet, is given in Fig. 2.1. This is an informal specification, using the notation from [Liskov86] (formal specifications are described in Chapter 4). <p> With mixins, there is no notion of "replacing" parts of modules, there is only the simpler notion of fitting parts together. 8.3 Related work The idea of documenting data abstractions in terms of abstract- rather than concrete state has a long history going back at least to <ref> [Hoare72] </ref>. This existing work forms the foundation of the specification techniques presented in Chapters 2 and 4, but it does not address the issues that arise in the context of subclassing. There are a number of object-oriented specification languages [Lano93]. <p> Little work has been done on verification of specialization interfaces. Our own work is based on the traditional approach to verifying data abstractions, which goes back again to <ref> [Hoare72] </ref>. Leaven's work on verification [Leavens89] considers verification of programs in the presense of behavioral subtyping, but it does not consider verification of specialization interfaces.
Reference: [Holzle93] <author> U. Holzle. </author> <title> Integrating independently-developed components in object-oriented languages. </title> <booktitle> ECOOP '93 Proceedings (Kaiserslautern, </booktitle> <address> Germany, </address> <month> July </month> <year> 1993). </year> <note> Published as LNCS 707, pages 36-56. Springer-Verlag, </note> <year> 1993. </year>
Reference: [Javabeta95] <author> Sun Microsystems, Inc. </author> <title> The Java Language Specification (1.0 Beta), </title> <address> 30 Oct. </address> <year> 1995. </year>
Reference-contexts: Solid lines stand for subtyping, and dashed lines for subclassing Mixins can be added to the syntax of Java with only a slight modification of the grammar in <ref> [Javabeta95] </ref>: class declaration ! class modifiers class identifier h super i h interfaces i class body mixin declaration ! mixin identifier h super i h interfaces i class body super ! mixins mixin fl mixin ! identifier j identifier hide f identifier list g Java's existing class declaration non-terminal does not
Reference: [Kapur88] <author> D. Kapur and M. Srivas. </author> <title> Computability and implementability issues in abstract data types. </title> <journal> Sci. of Comp. Prog., </journal> <volume> 10(1) </volume> <pages> 33-63. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: This makes it impossible to change to a more efficient representation, and it makes it impossible to make the field overridable, which would let subclasses provide optimized representations. 6.3.3 Picking accessors for components Sufficiency of interfaces is an old issue in the design of data abstractions <ref> [Kapur88] </ref>. A sufficient interface is one that provides enough functionality to allow effective access to objects; an insufficient interface is one whose methods make it hard or impossible to manipulate objects. Sufficiency is also an issue in the specialization interface, but at a finer level of granularity.
Reference: [Keene88] <author> S. E. Keene. </author> <title> Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <year> 1988. </year> <note> BIBLIOGRAPHY 99 </note>
Reference-contexts: The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., <ref> [Keene88] </ref>, [Bracha90], [Booch94], [Taligent94], 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]).
Reference: [Kiczales91] <author> G. Kiczales, J. des Rivieres, and D. G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Although control abstractions are beyond the scope of this report, no realistic discussion of the design of specialization interfaces can completely ignore them. This section briefly describes control abstractions and discusses how they interact with class components. (A detailed discussion of control abstractions can be found in <ref> [Kiczales91] </ref>.) A control abstraction is a method whose behavior can be customized by overriding methods that it calls. Control abstractions are final or overridable methods containing algorithms in which key details are embodied by calls to deferred and overridable methods called spe 6.3. <p> However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable methods). Many text books cover object-oriented design (e.g., [Rumbaugh91], [Booch94]). However, none consider the design of specialization interfaces. <ref> [Kiczales91] </ref> and [Kiczales92] present principles and advice for designing specialization interfaces, but they concentrate on layered control abstractions and do not discuss class components, abstract representations or representation categories.
Reference: [Kiczales92] <author> G. Kiczales and J. Lamping. </author> <title> Issues in the design and specification of class libraries. </title> <booktitle> OOPSLA '92 Conf. Proceedings (Vancouver, </booktitle> <month> Oct. </month> <year> 1992). </year> <note> Published as SIG-PLAN Notices, 27(10) 435-51. ACM, </note> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable methods). Many text books cover object-oriented design (e.g., [Rumbaugh91], [Booch94]). However, none consider the design of specialization interfaces. [Kiczales91] and <ref> [Kiczales92] </ref> present principles and advice for designing specialization interfaces, but they concentrate on layered control abstractions and do not discuss class components, abstract representations or representation categories. <p> An area that needs further work is specifications for control abstractions. As suggested in <ref> [Kiczales92] </ref>, formal specifications of control abstractions may require a more operational flavor than the specifications used in this report, e.g., specifications that explain the behavior of a method in terms of invocations of other methods.
Reference: [LaLonde91] <author> W. R. LaLonde and J. R. Pugh. </author> <title> Inside Smalltalk, Volume II. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The superview and subviews fields contain the view hierarchy. The observers field is unique to the ET++ library. The observers field contains a list of objects registered to receive notification when a VObject changes; it is motivated by the change-propagation mechanism in the SmallTalk Model-View-Controller paradigm <ref> [LaLonde91] </ref>. Field Openstep ET++ geometry final, encapsulated final, exposed nextResponder final, encapsulated deferred superview final, encapsulated final, encapsulated subviews final, encapsulated overridable observers | overridable Table 6.2: Abstract-state fields of two view classes. 6.1.
Reference: [Lamping93] <author> J. Lamping. </author> <title> Typing the specialization interface. </title> <booktitle> OOPSLA '93 Conf. Proceedings (Washington, </booktitle> <address> DC. </address> <month> Oct. </month> <year> 1993). </year> <journal> Published as SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 201-14. </pages> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Control abstractions go back to Simula, where they are part of the programming lore (see, e.g., [Pooley87]). <ref> [Lamping93] </ref> presents static checking for control abstractions. [Lamping93] anticipates the idea of class components, but it fails to distinguish them from control abstractions. Lamping's later paper on checking specialization interfaces [Lamping94] deals purely with control abstractions. <p> Control abstractions go back to Simula, where they are part of the programming lore (see, e.g., [Pooley87]). <ref> [Lamping93] </ref> presents static checking for control abstractions. [Lamping93] anticipates the idea of class components, but it fails to distinguish them from control abstractions. Lamping's later paper on checking specialization interfaces [Lamping94] deals purely with control abstractions.
Reference: [Lamping94] <author> J. Lamping and M. Abadi. </author> <title> Methods as assertions. </title> <booktitle> ECOOP '94 Proceedings (Bologna, </booktitle> <address> Italy, </address> <month> July </month> <year> 1994). </year> <note> Published as LNCS 821, pages 60-80. Springer-Verlag, </note> <year> 1994. </year>
Reference-contexts: Control abstractions go back to Simula, where they are part of the programming lore (see, e.g., [Pooley87]). [Lamping93] presents static checking for control abstractions. [Lamping93] anticipates the idea of class components, but it fails to distinguish them from control abstractions. Lamping's later paper on checking specialization interfaces <ref> [Lamping94] </ref> deals purely with control abstractions. The Standard Template Library of C++ [Musser96] makes extensive use of control abstractions; interestingly, in the STL, extensibility is provided by parametric polymorphism rather than by subtype polymorphic. The term "mixin" was first coined in the Flavors community [Weinreb81].
Reference: [Lano93] <author> K. Lano and H. Haughton, </author> <title> editors. Object-Oriented Specification Case Studies. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: This existing work forms the foundation of the specification techniques presented in Chapters 2 and 4, but it does not address the issues that arise in the context of subclassing. There are a number of object-oriented specification languages <ref> [Lano93] </ref>. These languages are "object-oriented" in the sense of adding object-oriented features like subtyping and specification inheritance to specification languages like Z [Spivey92]. However, they do not address the problems raised in trying to specify specialization interfaces.
Reference: [Leavens89] <author> G. T. Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> PhD thesis, </type> <note> published as Technical report MIT-LCS-TR-439. </note> <institution> Lab. for Comp. Science, MIT, </institution> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: However, they do not address the problems raised in trying to specify specialization interfaces. Related to this work is work on specifications and behavioral subtype relations for type hierarchies <ref> [Leavens89, America91, Liskov94] </ref>. We borrowed heavily from this work, especially the work of Liskov and Wing [Liskov94]. But again, none of this work addresses specialization interfaces, including Leavens' more recent work on Larch/C++ [Cheon94]. An active area of work is on kernel languages. <p> Little work has been done on verification of specialization interfaces. Our own work is based on the traditional approach to verifying data abstractions, which goes back again to [Hoare72]. Leaven's work on verification <ref> [Leavens89] </ref> considers verification of programs in the presense of behavioral subtyping, but it does not consider verification of specialization interfaces.
Reference: [Leino95] <author> K. R. M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <note> published as Technical report CS-TR-95-03. </note> <institution> California Inst. of Techn., Pasadena, </institution> <address> CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The modifies clause requires that only this is modified. This is true, but we must assume no "representation exposure," i.e., that changes to els affect only this and no other objects (c.f., <ref> [Schaffert81, Leino95] </ref>). Showing that addElement preserves its invariant means assuming this pre :c toSet (this pre :els) and proving: this post :c toSet (this post :els) Informally, the invariant is preserved because addElement does not change c and at most adds an element to els. <p> Our own work is based on the traditional approach to verifying data abstractions, which goes back again to [Hoare72]. Leaven's work on verification [Leavens89] considers verification of programs in the presense of behavioral subtyping, but it does not consider verification of specialization interfaces. Rustan Leino's report <ref> [Leino95] </ref>, which presents modular verification techniques for object-oriented programs, does consider verification in the presence of subclassing. [Leino95] is more formal than our work and includes a soundness proof for a restricted verification problem. This extra formality has proven useful for generating verification conditions in the Extended Static Checker [Detlefs96]. <p> Leaven's work on verification [Leavens89] considers verification of programs in the presense of behavioral subtyping, but it does not consider verification of specialization interfaces. Rustan Leino's report <ref> [Leino95] </ref>, which presents modular verification techniques for object-oriented programs, does consider verification in the presence of subclassing. [Leino95] is more formal than our work and includes a soundness proof for a restricted verification problem. This extra formality has proven useful for generating verification conditions in the Extended Static Checker [Detlefs96]. Our work is more general than [Leino95]. <p> for object-oriented programs, does consider verification in the presence of subclassing. <ref> [Leino95] </ref> is more formal than our work and includes a soundness proof for a restricted verification problem. This extra formality has proven useful for generating verification conditions in the Extended Static Checker [Detlefs96]. Our work is more general than [Leino95]. The generality of our work is compatible with Leino's work and could inform extensions to that work. [Leino95] considers a language model in which subtyping and subclassing are combined, where we consider a more general language model. [Leino95] supports only final and deferred abstract-state fields, while we consider overridable fields <p> This extra formality has proven useful for generating verification conditions in the Extended Static Checker [Detlefs96]. Our work is more general than <ref> [Leino95] </ref>. The generality of our work is compatible with Leino's work and could inform extensions to that work. [Leino95] considers a language model in which subtyping and subclassing are combined, where we consider a more general language model. [Leino95] supports only final and deferred abstract-state fields, while we consider overridable fields as well. [Leino95] allows only one specification per method, i.e., subclasses inheriting a method also inherit a specification <p> Our work is more general than <ref> [Leino95] </ref>. The generality of our work is compatible with Leino's work and could inform extensions to that work. [Leino95] considers a language model in which subtyping and subclassing are combined, where we consider a more general language model. [Leino95] supports only final and deferred abstract-state fields, while we consider overridable fields as well. [Leino95] allows only one specification per method, i.e., subclasses inheriting a method also inherit a specification for that method. This restriction makes it harder for subclasses to refine the behavior of methods (although [Leino95] does allow <p> of our work is compatible with Leino's work and could inform extensions to that work. <ref> [Leino95] </ref> considers a language model in which subtyping and subclassing are combined, where we consider a more general language model. [Leino95] supports only final and deferred abstract-state fields, while we consider overridable fields as well. [Leino95] allows only one specification per method, i.e., subclasses inheriting a method also inherit a specification for that method. This restriction makes it harder for subclasses to refine the behavior of methods (although [Leino95] does allow indirect refinement by allowing refinement of the abstraction functions that define abstract-state fields). <p> language model. <ref> [Leino95] </ref> supports only final and deferred abstract-state fields, while we consider overridable fields as well. [Leino95] allows only one specification per method, i.e., subclasses inheriting a method also inherit a specification for that method. This restriction makes it harder for subclasses to refine the behavior of methods (although [Leino95] does allow indirect refinement by allowing refinement of the abstraction functions that define abstract-state fields). This restriction makes it hard to hide specialization details from instantiators, and it rules-out having separate assumed and particular specifications for overridable methods. [Leino95] is more general in that it supports arbitrary numbers of interfaces <p> it harder for subclasses to refine the behavior of methods (although <ref> [Leino95] </ref> does allow indirect refinement by allowing refinement of the abstraction functions that define abstract-state fields). This restriction makes it hard to hide specialization details from instantiators, and it rules-out having separate assumed and particular specifications for overridable methods. [Leino95] is more general in that it supports arbitrary numbers of interfaces to classes while we support only two (instance and specialization interfaces). However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable <p> This restriction makes it hard to hide specialization details from instantiators, and it rules-out having separate assumed and particular specifications for overridable methods. <ref> [Leino95] </ref> is more general in that it supports arbitrary numbers of interfaces to classes while we support only two (instance and specialization interfaces). However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable methods). Many text books cover object-oriented design (e.g., [Rumbaugh91], [Booch94]).
Reference: [Lewis95] <author> T. Lewis. </author> <title> Object-Oriented Application Frameworks. </title> <publisher> Manning Publications, Co., </publisher> <address> Greenwich, CT, </address> <year> 1995. </year>
Reference: [Liskov86] <author> B. Liskov and J. Guttag. </author> <title> Abstraction and specification in program development. </title> <publisher> MIT Press/McGraw-Hill Book Co., </publisher> <year> 1977. </year>
Reference-contexts: This is an informal specification, using the notation from <ref> [Liskov86] </ref> (formal specifications are described in Chapter 4). IntSetISpec illustrates the two basic parts found in all object specifications: the abstract state, which describes the state of objects, and the method specifications, which describe the behavior of the methods of objects. 9 10 CHAPTER 2. <p> In short, instance variables representing overridable state should only be accessed for this and not for other arguments. For all of its arguments, a binary method can safely access the instance variables representing final state. 3.2.3 Assuming invariants Invariants are important in reasoning about the correctness of method code <ref> [Liskov86] </ref>. For example, the code of removeElement (Fig. 1.2) assumes no duplicates in this.els, i.e., that 22 CHAPTER 3. VALIDATING CLASSES no element appears in this.els twice. The code of contains assumes that an element of the cache is also an element of elements. <p> We verify that a component is correct using standard data refinement procedures ([Hoare72], <ref> [Liskov86] </ref>, [Dahl92]) adapted to ensure independence. This section describes this adaptation. It starts with an overview of our approach, discusses the mechanics, and ends with an example. <p> The methods of component i are verified using V i according to standard refinement procedures (see, e.g., <ref> [Liskov86] </ref>). Where the code of methods make calls to other methods, the specifications of the called methods are used to reason about the calls. The special case of i = lf, i.e., verifying the component of local, final state, is a bit simpler than the general case.
Reference: [Liskov93] <author> B. Liskov. </author> <title> A history of Clu. </title> <booktitle> 2nd History of Prog. Lang. Conf. </booktitle> <address> (preprints) (Cambridge, MA. </address> <month> Apr. </month> <year> 1993). </year> <journal> Published as SIGPLAN Notices, </journal> <volume> 28(3) </volume> <pages> 133-47. </pages> <publisher> ACM, </publisher> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: When done through methods, accesses of the state of an overridable component will still work as expected when subclasses replace the component. Binary methods, generally a problem (see, e.g., <ref> [Liskov93] </ref> and [Bruce96]), must be treated with care. A binary method of class C is a method that takes one or more arguments of type C in addition to this.
Reference: [Liskov94] <author> B. Liskov and J. M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 16(6) </volume> <pages> 1811-41. </pages> <publisher> ACM, </publisher> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Similarly, removeElement must preserve the invariant even though it is not part of the explicit post-condition of removeElement. Invariants are just one of many different kinds of information that might be put into object specification. Other examples include constraints for establishing history properties <ref> [Liskov94] </ref> or complexity information for bounding algorithms [Musser96]. We highlight invariants because, as discussed in the next section, they are particularly important in the context of specialization interfaces. <p> The term supertype is used because object specifications are used to document object types. A behavioral supertype is a "more general" specification, i.e., it describes more objects. The behavioral subtype is "more specific." Behavioral subtyping is discussed in detail in <ref> [Liskov94] </ref>; formal rules for behavioral subtyping are given in Sec. 4.1.2. For the purposes of this section, a simple rule suffices: a subtype must have a more detailed view of an object than its behavioral supertypes do. This has three 28 CHAPTER 3. <p> That is, they cannot be established by inspecting the constructors and public methods to see if the invariant is preserved. This problem can be fixed by making instance invariants part of specialization specifications, just like invariants must be made part of object specifications in the presense of subtyping <ref> [Liskov94] </ref>. That is, a specialization specification is now an object specification, a division of labor, and an instance invariant. <p> Sec. 4.6 ends this chapter by discussing specification and verification of constructors. 33 34 CHAPTER 4. FORMAL SPECIFICATION AND VERIFICATION 4.1 Formal object specifications This report assumes the specification model for objects described in <ref> [Liskov94] </ref>. Like many models, this model assumes that program states include an environment that maps variables to object identifiers and a store that maps object identifiers to values. State is the the space of program states. <p> As this example indicates, we use separate name spaces for sorts and for classes. 4.1.2 Behavioral subtyping This report assumes the behavioral subtype relationship defined in <ref> [Liskov94] </ref>. One object specification is a behavioral subtype of another if all objects described by the first specification are also described by the second. <p> However, they do not address the problems raised in trying to specify specialization interfaces. Related to this work is work on specifications and behavioral subtype relations for type hierarchies <ref> [Leavens89, America91, Liskov94] </ref>. We borrowed heavily from this work, especially the work of Liskov and Wing [Liskov94]. But again, none of this work addresses specialization interfaces, including Leavens' more recent work on Larch/C++ [Cheon94]. An active area of work is on kernel languages. <p> However, they do not address the problems raised in trying to specify specialization interfaces. Related to this work is work on specifications and behavioral subtype relations for type hierarchies [Leavens89, America91, Liskov94]. We borrowed heavily from this work, especially the work of Liskov and Wing <ref> [Liskov94] </ref>. But again, none of this work addresses specialization interfaces, including Leavens' more recent work on Larch/C++ [Cheon94]. An active area of work is on kernel languages. This work aims at finding the lambda-calculus of object-oriented programming, i.e., a tiny language kernel that embodies the essence of object-oriented programming.
Reference: [Microsoft94] <editor> Microsoft Visual C++ Volume Two: </editor> <title> Programming with MFC and Win32, version 2.0. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1994. </year>
Reference-contexts: In existing programming methodologies, classes are treated as the unit of modularity. As a result, documentation for class libraries draws abstraction barriers around entire classes (see, e.g., [Borland94] and <ref> [Microsoft94] </ref>). This is fine for instantiators, clients whose code manipulates instances of a class. However, specializers, clients who create subclasses, use method override to replace parts of classes, and thus interact with classes at a finer granularity. For specializers, classes are too coarse a unit of modularity. <p> This allows the use of multiple subtyping deeper in the type hierarchy. For example, a class OLEVObject could be a subtype of both VObject and OLEObject (where OLEObject would be an interface for a Microsoft OLE-compliant object <ref> [Microsoft94] </ref>). As this example indicates, pushing interfaces deeper into type hierarchies may also have some advantages when it comes to object-oriented, client-server programming standards.
Reference: [Musser96] <author> D. R. Musser and A. Saini. </author> <title> STL Tutorial and Reference Guide: C++ Programming with the Standard Template Library. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <year> 1996. </year>
Reference-contexts: Invariants are just one of many different kinds of information that might be put into object specification. Other examples include constraints for establishing history properties [Liskov94] or complexity information for bounding algorithms <ref> [Musser96] </ref>. We highlight invariants because, as discussed in the next section, they are particularly important in the context of specialization interfaces. For simplicity, we ignore other kinds of information that could be included in object specifications, but our results can be extended to handle additional information. <p> Lamping's later paper on checking specialization interfaces [Lamping94] deals purely with control abstractions. The Standard Template Library of C++ <ref> [Musser96] </ref> makes extensive use of control abstractions; interestingly, in the STL, extensibility is provided by parametric polymorphism rather than by subtype polymorphic. The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], [Booch94], [Taligent94], 8.4.
Reference: [Next94] <institution> Next Computer, Inc. Openstep Specification, </institution> <month> Oct., </month> <year> 1994. </year> <note> Available via anonymous FTP at ftp.next.com in pub/OpenStepSpec. 100 BIBLIOGRAPHY </note>
Reference-contexts: Mouse-click events are directed to the lowest view in the view hierarchy containing the click; other input events, such as keystrokes and commands generated by menus, are directed to the view that currently has the input focus. We compare and contrast the view classes in two GUI libraries, Openstep <ref> [Next94] </ref> and ET++ [Weinand95]. We consider both to be well-designed libraries, an opinion that has been seconded in the literature (e.g., [Holzle93],[Lewis95]). Openstep and ET++ are similar in their class hierarchies and in the general functionality of various classes. However, the details of their specialization specifications are different.
Reference: [Pooley87] <author> R. J. Pooley. </author> <title> An Introduction to Programming in SIMULA. </title> <publisher> Blackwell Scientific Publications, Oxford, </publisher> <year> 1987. </year>
Reference-contexts: Control abstractions go back to Simula, where they are part of the programming lore (see, e.g., <ref> [Pooley87] </ref>). [Lamping93] presents static checking for control abstractions. [Lamping93] anticipates the idea of class components, but it fails to distinguish them from control abstractions. Lamping's later paper on checking specialization interfaces [Lamping94] deals purely with control abstractions.
Reference: [Pressman92] <author> R. S. Pressman. </author> <title> Software Engineering: a Practitioner's Approach, 3rd edition. </title> <publisher> McGraw Hill, Inc., </publisher> <year> 1992. </year>
Reference: [Rumbaugh91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: However, [Leino95] does not recognize as we do that specializers need different kinds of information (e.g., representation categories for abstract-state fields, both assumed and actual specifications for overridable methods). Many text books cover object-oriented design (e.g., <ref> [Rumbaugh91] </ref>, [Booch94]). However, none consider the design of specialization interfaces. [Kiczales91] and [Kiczales92] present principles and advice for designing specialization interfaces, but they concentrate on layered control abstractions and do not discuss class components, abstract representations or representation categories.
Reference: [Schaffert81] <author> J. C. Schaffert. </author> <title> Specification and Verification of Programs using Data Abstraction and Sharing. </title> <type> PhD thesis. </type> <institution> MIT, </institution> <year> 1981. </year>
Reference-contexts: The modifies clause requires that only this is modified. This is true, but we must assume no "representation exposure," i.e., that changes to els affect only this and no other objects (c.f., <ref> [Schaffert81, Leino95] </ref>). Showing that addElement preserves its invariant means assuming this pre :c toSet (this pre :els) and proving: this post :c toSet (this post :els) Informally, the invariant is preserved because addElement does not change c and at most adds an element to els.
Reference: [Snyder87] <author> A. Snyder. </author> <title> Inheritance and the development of encapsulated software components. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 163-88. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Multiple inheritance is different. There are few large, successful libraries that make aggressive use of multiple code inheritance. Thus, while for single inheritance we were inspired by today's best designs, there are no such starting points for multiple inheritance. Also, as discussed in <ref> [Snyder87] </ref>, the multiple inheritance models of most languages are inherently non-modular. Thus, we cannot even start with a standard language model. Rather than start with conventional language and design assumptions, this chapter starts with the ideas of the previous chapters, ideas on the design, documentation, and validation of specialization interfaces. <p> This makes the multiple-inheritance semantics of C++ unsuitable to mixin-style programming (although a clever use of templates ([VanHilst96]) can yield the desired semantics). When a class inherits the same mixin through multiple paths, the class incorporates two copies of the mixin. This rule embodies the "tree inheritance" approach of <ref> [Snyder87] </ref>. In our example (Fig. 7.4), D and E both inherit from mixin F. As a result, C inherits the 7.2. SPECIFICATION AND VERIFICATION 85 methods and instance-variables of F twice.
Reference: [Spivey92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: There are a number of object-oriented specification languages [Lano93]. These languages are "object-oriented" in the sense of adding object-oriented features like subtyping and specification inheritance to specification languages like Z <ref> [Spivey92] </ref>. However, they do not address the problems raised in trying to specify specialization interfaces. Related to this work is work on specifications and behavioral subtype relations for type hierarchies [Leavens89, America91, Liskov94]. We borrowed heavily from this work, especially the work of Liskov and Wing [Liskov94].
Reference: [Steyaert95] <author> P. Steyaert and W. De Meuter. </author> <title> A marriage of class- and object-based inheritance without unwanted children. </title> <booktitle> ECOOP '95 Proceedings (July 1995), </booktitle> <pages> pages 127-43. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference: [Stroustrup91] <author> B. Stroustrup. </author> <title> The C++ Programming Language, 2nd edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Only final methods can be hidden. Second, the access control of inherited methods can be changed is with access declarations. An access declaration declares are subclass declarations that declare new (stronger) levels of access control for inherited methods (c.f. C++ access declarations, <ref> [Stroustrup91] </ref>). 82 CHAPTER 7.
Reference: [Taligent94] <author> Taligent. </author> <title> Taligent's Guide to Designing Programs: Well-Mannered Object-Oriented Design in C++, The Taligent Reference Library. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA and London, UK, </address> <year> 1994. </year>
Reference-contexts: The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], [Booch94], <ref> [Taligent94] </ref>, 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]). A mixin is distinguished from other partial classes by the intent of its designers.
Reference: [ThetaWeb95] <author> B. Liskov, D. Curtis, M. Day, S. Ghemawat, R. Gruber, P. Johnson, and A. Myers. </author> <title> Theta reference manual. </title> <publisher> MIT LCS, </publisher> <address> PMG memo 88, </address> <month> Feb. </month> <year> 1995. </year> <note> http://www.pmg.lcs.mit.edu/Theta.html. </note>
Reference-contexts: In languages like Java and Theta 7.4. SUMMARY 89 <ref> [ThetaWeb95] </ref> that have modules for defining object types apart from classes, such a multiple inheritance mechanism is easy to add. In the mixin style of design, classes become smaller and more focused.
Reference: [Ungar91] <author> D. Ungar and R. B. Smith. </author> <title> Self: the power of simplicity. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 187-205. </pages> <publisher> Kluwer Academic Publishers, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: In essence, this report does just that: it figures out how to think about abstract state in the context of subclassing. As other approaches to data abstraction are introduced, e.g., object-based <ref> [Ungar91] </ref>, role-based [VanHilst96], and subject-oriented [Harrison93] programming, the issue of abstract state will have to be revisited again.
Reference: [VanHilst96] <author> M. VanHilst and D. Notkin. </author> <title> Using C++ templates to implement role-based designs. </title> <booktitle> Intl Symp. on Object Technologies for Advanced Softw. </booktitle> <address> '96 (Kanazawa, Japan, </address> <month> Mar. </month> <year> 1996), </year> <month> Mar. </month> <year> 1996. </year> <note> (To appear.). </note>
Reference-contexts: The term "mixin" was first coined in the Flavors community [Weinreb81]. It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], [Booch94], [Taligent94], 8.4. FUTURE WORK 95 <ref> [VanHilst96] </ref>. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]). A mixin is distinguished from other partial classes by the intent of its designers. <p> In essence, this report does just that: it figures out how to think about abstract state in the context of subclassing. As other approaches to data abstraction are introduced, e.g., object-based [Ungar91], role-based <ref> [VanHilst96] </ref>, and subject-oriented [Harrison93] programming, the issue of abstract state will have to be revisited again.
Reference: [Wadler94] <author> P. Wadler (ed.). </author> <title> Type systems for object-oriented programming: </title> <journal> special issue of Journal of Functional Programming. J. of Func. Prog., </journal> <volume> 4(2) </volume> <pages> 125-283. </pages> <publisher> Cambridge Univ. Press, </publisher> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: An active area of work is on kernel languages. This work aims at finding the lambda-calculus of object-oriented programming, i.e., a tiny language kernel that embodies the essence of object-oriented programming. Currently, there are four major approaches (a survey of three can be found in <ref> [Wadler94] </ref>, and the fourth is presented in [Castagna95]). The focus of this work has been on type systems that eliminate "message not understood" errors without giving up too much of the flexibility of untyped object systems.
Reference: [Weinand95] <author> A. Weinand and E. </author> <title> Gamma. ET++: a portable, homogeneous class library and application framework. </title> <booktitle> In Object-Oriented Application Frameworks, </booktitle> <pages> pages 154-94. </pages> <publisher> Manning Publications, Co., </publisher> <address> Greenwhich, CT., </address> <year> 1995. </year>
Reference-contexts: In languages like this, good design practice requires that the instance specifications of all subclasses of C be behavioral subtypes of the instance specification of C. For example, code similar to the following appears in the ET++ View class (ET++ is a GUI framework <ref> [Weinand95] </ref>): public ViewStretcher createStretcher () f DocView dv = this.getDocView (); if (dv == null) return CreateViewStretcher (this); else return CreateViewStretcherWithRect (this, dv.contentRect ()); g; The code of createStretcher passes this as an argument to other routines. <p> We compare and contrast the view classes in two GUI libraries, Openstep [Next94] and ET++ <ref> [Weinand95] </ref>. We consider both to be well-designed libraries, an opinion that has been seconded in the literature (e.g., [Holzle93],[Lewis95]). Openstep and ET++ are similar in their class hierarchies and in the general functionality of various classes. However, the details of their specialization specifications are different.
Reference: [Weinreb81] <author> D. Weinreb and D. Moon. </author> <title> Lisp Machine Manual, 4th Ed. </title> <type> Symbolics, </type> <institution> Inc./MIT AI. Lab., </institution> <year> 1981. </year>
Reference-contexts: We call these smaller classes mixins, after the 79 80 CHAPTER 7. MULTIPLE INHERITANCE process of "mixing" them together to form larger classes. ("Mixin" was first coined in the Flavors community <ref> [Weinreb81] </ref>, but our use follows [Booch94].) The first section below describes how mixins can be supported in Java with only minimal language changes. The next section explains how a simplified subset of the specification and verification techniques of the previous chapters applies directly to mixins. <p> The Standard Template Library of C++ [Musser96] makes extensive use of control abstractions; interestingly, in the STL, extensibility is provided by parametric polymorphism rather than by subtype polymorphic. The term "mixin" was first coined in the Flavors community <ref> [Weinreb81] </ref>. It has been used in a number of contexts; see, e.g., [Keene88], [Bracha90], [Booch94], [Taligent94], 8.4. FUTURE WORK 95 [VanHilst96]. In the context of multiple-inheritance languages like C++, a mixin is a partial class that implements a small part of the functionality of a larger class (see [Booch94]).
References-found: 57

