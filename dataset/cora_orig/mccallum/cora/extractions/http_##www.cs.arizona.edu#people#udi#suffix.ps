URL: http://www.cs.arizona.edu/people/udi/suffix.ps
Refering-URL: http://glimpse.cs.arizona.edu/udi.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Suffix arrays: A new method for on-line string searches  
Author: Udi Manber Gene Myers 
Date: May 1989 Revised August 1991  
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science University of Arizona  
Abstract: A new and conceptually simple data structure, called a suffix array, for on-line string searches is introduced in this paper. Constructing and querying suffix arrays is reduced to a sort and search paradigm that employs novel algorithms. The main advantage of suffix arrays over suffix trees is that, in practice, they use three to five times less space. From a complexity standpoint, suffix arrays permit on-line string searches of the type, ``Is W a substring of A?'' to be answered in time O(P + log N), where P is the length of W and N is the length of A, which is competitive with (and in some cases slightly better than) suffix trees. The only drawback is that in those instances where the underlying alphabet is finite and small, suffix trees can be constructed in O(N) time in the worst case, versus O(N log N) time for suffix arrays. However, we give an augmented algorithm that, regardless of the alphabet size, constructs suffix arrays in O(N) expected time, albeit with lesser space efficiency. We believe that suffix arrays will prove to be better in practice than suffix trees for many applications. 
Abstract-found: 1
Intro-found: 1
Reference: [Apo85] <author> Apostolico, A., </author> <title> ``The myriad virtues of subword trees,'' Combinatorial Algorithms on Words (A. </title> <editor> Apostolico & Z. Galil, eds.), </editor> <booktitle> NATO ASI Series F: Computer and System Sciences, </booktitle> <volume> Vol. 12, </volume> <publisher> Springer-Verlag (1985), </publisher> <pages> 85-96. </pages>
Reference-contexts: Suffix trees can also be constructed in time O (N) with O (P) time for a query, but this requires O (N| S| ) space, which renders this method impractical in many applications. Suffix trees have been studied and used extensively. A survey paper by Apostolico <ref> [Apo85] </ref> cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse [BBE85], generalized to on-line construction [MR80, BB86], real-time construction of some features is possible [Sli80], and suffix trees have been parallelized [AIL88].
Reference: [AIL88] <author> Apostolico, A., C. Iliopoulos, G. Landau, B. Schieber, and U. Vishkin, </author> <title> ``Parallel construction of a suffix tree with applications,'' </title> <journal> Algorithmica, </journal> <volume> 3 (1988), </volume> <pages> 347-366. </pages>
Reference-contexts: A survey paper by Apostolico [Apo85] cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse [BBE85], generalized to on-line construction [MR80, BB86], real-time construction of some features is possible [Sli80], and suffix trees have been parallelized <ref> [AIL88] </ref>. Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching [Mye86, LV89, CL90], and string comparison [EH86].
Reference: [AP83] <author> Apostolico, A. </author> <title> and F.P. Preparata, ``Optimal off-line detection of repetitions in a string,'' </title> <booktitle> Theoretical Computer Science 22 (1983), </booktitle> <pages> 297-315. </pages>
Reference-contexts: Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string <ref> [AP83] </ref>, computing substring statistics [AP85], approximate string matching [Mye86, LV89, CL90], and string comparison [EH86]. They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86].
Reference: [AP85] <author> Apostolico, A. </author> <title> and F.P. Preparata, ``Structural properties of the string statistics problem,'' </title> <journal> Journal of Computer and System Science 31 (1985), </journal> <pages> 394-411. </pages>
Reference-contexts: Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics <ref> [AP85] </ref>, approximate string matching [Mye86, LV89, CL90], and string comparison [EH86]. They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86].
Reference: [BL89] <author> Baer, J. and Y. Lin, </author> <title> ``Improving quicksort performance with a codeword data structure,'' </title> <journal> IEEE Trans. Software Eng. </journal> <volume> 15, 5 (1989), </volume> <pages> 622-631. </pages>
Reference-contexts: To build a suffix array (but not its lcp information) one could simply apply any string sorting algorithm such as the O (Nlog N) expected-time algorithm of Baer and Lin <ref> [BL89] </ref>. But such an approach fails to take advantage of the fact that we are sorting a collection of related suffixes. We present an algorithm for constructing a suffix array and its lcp information with 3N integers 3 and O (N log N) time in the worst case.
Reference: [BG91] <author> Baeza-Yates, R. and G. Gonnet, </author> <title> ``All-against-all sequence matching,'' Private communication, </title> <note> manuscript in preparation. </note>
Reference-contexts: Suffix arrays have also been used as a basis for a sublinear approximate matching algorithm [My90] and for performing all pairwise comparisons between sequences in a protein sequence database <ref> [BG91] </ref>. The paper is organized as follows. In Section 2, we present the search algorithm under the assumption that the suffix array and the lcp information have been computed. In Section 3, we show how to construct the sorted suffix array.
Reference: [BB86] <author> Blumer, J. and A. Blumer, </author> <title> ``On-line construction of a complete inverted file,'' </title> <institution> UCSC-CRL-86-11, Dept. of Computer Science, University of Colorado (1986). </institution>
Reference-contexts: Suffix trees have been studied and used extensively. A survey paper by Apostolico [Apo85] cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse [BBE85], generalized to on-line construction <ref> [MR80, BB86] </ref>, real-time construction of some features is possible [Sli80], and suffix trees have been parallelized [AIL88].
Reference: [BBE85] <author> Blumer, J., Blumer, A., Ehrenfeucht, E., Haussler, D., Chen, M.T., and J. Seiferas, </author> <title> ``The smallest automaton recognizing the subwords of a text,'' </title> <booktitle> Theoretical Computer Science 40, </booktitle> <year> (1985) </year> <month> 31-35. </month>
Reference-contexts: Suffix trees have been studied and used extensively. A survey paper by Apostolico [Apo85] cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse <ref> [BBE85] </ref>, generalized to on-line construction [MR80, BB86], real-time construction of some features is possible [Sli80], and suffix trees have been parallelized [AIL88].
Reference: [Car75] <author> Cardenas, </author> <title> A.F., ``Analysis and performance of inverted data base structures,'' </title> <journal> Comm. of the ACM 18, </journal> <volume> 5 (1975), </volume> <pages> 253-263. </pages>
Reference-contexts: They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices <ref> [Car75] </ref>, and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching. In this paper, we present a new data structure, called the suffix array [MM90], that is basically a sorted list of all the suffixes of A.
Reference: [CHM86] <author> Clift, B., Haussler, D., McConnell, R., Schneider, T.D., and G.D. Stormo, </author> <title> ``Sequence landscapes,'' </title> <journal> Nucleic Acids Research 4, </journal> <volume> 1 (1986), </volume> <pages> 141-158. </pages>
Reference-contexts: They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences <ref> [CHM86] </ref>. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching. In this paper, we present a new data structure, called the suffix array [MM90], that is basically a sorted list of all the suffixes of A.
Reference: [EH86] <author> Ehrenfeucht, A. and D. Haussler, </author> <title> ``A new distance metric on strings computable in linear time,'' </title> <journal> Discrete Applied Math. </journal> <month> 40 </month> <year> (1988). </year>
Reference-contexts: Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching [Mye86, LV89, CL90], and string comparison <ref> [EH86] </ref>. They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching.
Reference: [FWM84] <author> Fraser, C., Wendt, A., and E.W. Myers, </author> <title> ``Analyzing and compressing assembly code,'' </title> <booktitle> Proceedings of the SIGPLAN Symposium on Compiler Construction (1984), </booktitle> <pages> 117-121. </pages>
Reference-contexts: They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code <ref> [FWM84] </ref>, inverted indices [Car75], and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching. In this paper, we present a new data structure, called the suffix array [MM90], that is basically a sorted list of all the suffixes of A.
Reference: [Gal85] <author> Galil, Z., </author> <title> ``Open problems in stringology,'' Combinatorial Algorithms on Words (A. </title> <editor> Apostol-ico and Z. Galil, eds.), </editor> <booktitle> NATO ASI Series F: Computer and System Sciences, </booktitle> <volume> Vol. 12, </volume> <publisher> Springer-Verlag (1985), </publisher> <pages> 1-8. </pages>
Reference: [Go89] <author> Gonnet G., </author> <title> Private communication. </title>
Reference-contexts: In fact, we recently found that the basic concept of suffix arrays (sans the lcp and a provable efficient algorithm) has been used in the Oxford English Dictionary (OED) project at the University of Waterloo <ref> [Go89] </ref>. Suffix arrays have also been used as a basis for a sublinear approximate matching algorithm [My90] and for performing all pairwise comparisons between sequences in a protein sequence database [BG91]. The paper is organized as follows.
Reference: [HT84] <author> Harel, D. and R.E. Tarjan, </author> <title> ``Fast algorithms for finding nearest common ancestors,'' </title> <journal> SIAM Journal on Computing 13 (1984), </journal> <pages> 338-355. </pages>
Reference-contexts: Given the sort history produced by the sort, we determine the lcp of A p and A q as follows. First we find the nearest common ancestor (nca) of suffixes A p and A q in the sort history using an O ( 1) time nca algorithm <ref> [HT84, SV88] </ref>. The stage number H associated with this ancestor tells us that lcp (A p , A q ) = H + lcp (A p + H , A q + H ) [H, 2H - 1].
Reference: [KGO83] <author> Karlin S., Ghandour G., Ost F., Tavare S., and L. J. Korn, </author> <title> ``New approaches for computer analysis of nucleic acid sequences,'' </title> <booktitle> Proc. </booktitle> <institution> Natl. Acad. Sci. </institution> <address> USA, 80, </address> <month> (September </month> <year> 1983), </year> <pages> 5660-5664. </pages>
Reference-contexts: This claim is true under the assumption that all strings of length N are equally likely and exploits the fact that for such strings, the expected length of the longest repeated substring is O (log N/ log | S| ) <ref> [KGO83] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 While the suffix array and lcp information occupy 2N integers, another N integers are needed during their construction. <p> We assume that all N-symbol strings are equally likely 7 . Under this input distribution, the expected length of the longest repeated substring has been shown to be 2log | S| N + O (1) <ref> [KGO83] </ref>. This fact provides the central leverage for all the results that follow. Note that it immediately implies that, in the expected case, Pos will be completely sorted after O (log log N) stages, and the sorting algorithm of Section 3 thus takes O (Nlog log N) expected time.
Reference: [KMR72] <author> Karp, R. M., R. E. Miller, and A. L. Rosenberg, </author> <title> ``Rapid identification of repeated patterns in strings, trees and arrays,'' </title> <booktitle> Fourth Annual ACM Symposium on Theory of Computing, </booktitle> <month> (May </month> <year> 1972), </year> <pages> 125-136. </pages>
Reference-contexts: We will show how to sort the elements in each H-bucket to produce the 2H -order in O (N) time. Our sorting algorithm uses similar ideas to those in <ref> [KMR72] </ref>. Let A i and A j be two suffixes belonging to the same bucket after the H th step; that is, A i = H A j . We need to compare A i and A j according to the next H symbols.
Reference: [LV89] <author> Landau, G. M., and U. Vishkin, </author> <title> ``Fast parallel and serial approximate string matching,'' </title> <journal> Journal of Algorithms, </journal> <volume> 10 (1989), </volume> <pages> 157-169. </pages>
Reference-contexts: Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching <ref> [Mye86, LV89, CL90] </ref>, and string comparison [EH86]. They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching.
Reference: [McC76] <author> McCreight, </author> <title> E.M., ``A space-economical suffix tree construction algorithm,'' </title> <journal> Journal of the ACM 23 (1976), </journal> <pages> 262-272. </pages>
Reference-contexts: The Suffix tree is a data structure that admits efficient on-line string searches. A suffix tree for a text A of length N over an alphabet S can be built in O (N log | S| ) time and O (N) space <ref> [Wei73, McC76] </ref>. Suffix trees permit on-line string searches of the type, ``Is W a substring of A?'' to be answered in O (P log | S| ) time, where P is the length of W.
Reference: [MM90] <author> Manber, U., and E.W. Myers, </author> <title> ``Suffix Arrays: A New Method for On-Line String Searches,'' </title> <booktitle> First ACM-SIAM Symposium on Discrete Algorithms (January 1990), </booktitle> <pages> 319-327. </pages>
Reference-contexts: Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching. In this paper, we present a new data structure, called the suffix array <ref> [MM90] </ref>, that is basically a sorted list of all the suffixes of A.
Reference: [MR80] <author> Majster, M.E., and A. Reiser, </author> <title> ``Efficient on-line construction and correction of position trees, </title> <journal> SIAM Journal on Computing 9, </journal> <volume> 4 (1980), </volume> <pages> 785-807. </pages>
Reference-contexts: Suffix trees have been studied and used extensively. A survey paper by Apostolico [Apo85] cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse [BBE85], generalized to on-line construction <ref> [MR80, BB86] </ref>, real-time construction of some features is possible [Sli80], and suffix trees have been parallelized [AIL88].
Reference: [Mye86] <author> Myers, </author> <title> E.W., ``Incremental alignment algorithms and their applications,'' </title> <type> Technical Report TR86-22, </type> <institution> Dept. of Computer Science, University of Arizona, </institution> <address> Tucson, AZ 85725. </address>
Reference-contexts: Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching <ref> [Mye86, LV89, CL90] </ref>, and string comparison [EH86]. They have also been used to address other types of problems such as text compression [RPE81], compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching.
Reference: [My90] <author> Myers, </author> <title> E.W., ``A sublinear algorithm for approximate keyword searching,'' </title> <type> Technical Report TR90-25, </type> <institution> Dept. of Computer Science, University of Arizona, </institution> <address> Tucson, AZ 85725. </address>
Reference-contexts: Suffix arrays have also been used as a basis for a sublinear approximate matching algorithm <ref> [My90] </ref> and for performing all pairwise comparisons between sequences in a protein sequence database [BG91]. The paper is organized as follows. In Section 2, we present the search algorithm under the assumption that the suffix array and the lcp information have been computed.
Reference: [Ro82] <author> Rodeh, M., </author> <title> ``A fast test for unique decipherability based on suffix tree,'' </title> <journal> IEEE Trans. Inf. Theory 28, </journal> <volume> 4 (1982), </volume> <pages> 648-651. </pages>
Reference-contexts: We present an algorithm for constructing a suffix array and its lcp information with 3N integers 3 and O (N log N) time in the worst case. Time could be saved by constructing a suffix tree first, and then building the array with a traversal of the tree <ref> [Ro82] </ref> and the lcp information with constant-time nearest ancestor queries [SV88] on the tree. But this will require more space. Moreover, the algorithms for direct construction are interesting in their own right.
Reference: [RPE81] <author> Rodeh, M., Pratt, V.R., and S. </author> <title> Even, ``Linear algorithm for data compression via string matching,'' </title> <journal> Journal of the ACM 28, </journal> <volume> 1 (1981), </volume> <pages> 16-24. </pages>
Reference-contexts: They have also been used to address other types of problems such as text compression <ref> [RPE81] </ref>, compressing assembly code [FWM84], inverted indices [Car75], and analyzing genetic sequences [CHM86]. Galil [Ga85] lists a number of open problems concerning suffix trees and on-line string searching.
Reference: [Sli80] <author> Slisenko, </author> <title> A.O., ``Detection of periodicities and string-matching in real time,'' </title> <journal> Journal of Soviet Mathematics 22, </journal> <note> 3 (1983), 1316-1387; translated from Zpiski Nauchnykh Seminarov 15 Leningradskogo Otdeleniya Matematicheskogo Instituta im. V.A. Steklova AN SSSR, </note> <month> 105 </month> <year> (1980), </year> <pages> 62-173. </pages>
Reference-contexts: A survey paper by Apostolico [Apo85] cites over forty references. Suffix trees have been refined from tries to minimum state finite automaton for the text and its reverse [BBE85], generalized to on-line construction [MR80, BB86], real-time construction of some features is possible <ref> [Sli80] </ref>, and suffix trees have been parallelized [AIL88]. Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring [Wei73], finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching [Mye86, LV89, CL90], and string comparison [EH86].
Reference: [SV88] <author> Schieber, B., and U. Vishkin, </author> <title> ``On finding lowest common ancestors: Simplification and paral-lelization,'' </title> <journal> SIAM Journal on Computing, </journal> <month> 17 (December </month> <year> 1988), </year> <pages> pp. 1253-1262. </pages>
Reference-contexts: Time could be saved by constructing a suffix tree first, and then building the array with a traversal of the tree [Ro82] and the lcp information with constant-time nearest ancestor queries <ref> [SV88] </ref> on the tree. But this will require more space. Moreover, the algorithms for direct construction are interesting in their own right. Our approach distills the nature of a suffix tree to its barest essence: A sorted array coupled with another to accelerate the search. <p> The nca of leaves i and j can be found in O (log N) time by simply walking from the leaves to the root of the tree (it can be done in constant time using a more complicated data structure <ref> [SV88] </ref>, but it is not necessary here). Let P be the set of vertices on the path from i to nca (i, j) excluding nca (i, j), and let Q be the similar path for leaf j. <p> Given the sort history produced by the sort, we determine the lcp of A p and A q as follows. First we find the nearest common ancestor (nca) of suffixes A p and A q in the sort history using an O ( 1) time nca algorithm <ref> [HT84, SV88] </ref>. The stage number H associated with this ancestor tells us that lcp (A p , A q ) = H + lcp (A p + H , A q + H ) [H, 2H - 1].
Reference: [Vui80] <author> Vuillemin, J., </author> <title> ``A unified look at data structures,'' </title> <journal> Comm. of the ACM, </journal> <volume> 23, </volume> <month> 4 (April </month> <year> 1980), </year> <pages> 229-239. </pages>
Reference-contexts: We will describe this data structure, which we call an interval tree, after we firmly establish our basic approach (interval trees are similar to the Cartesian trees of Vuillemin <ref> [Vui80] </ref>). We define height (i) = lcp (A Pos [i - 1] , A Pos [i] ), 1 i N - 1, where Pos is the final sorted order of the suffixes. These N - 1 height values are computed in an array Hgt [i].
Reference: [Wei73] <author> Weiner, P., </author> <title> ``Linear pattern matching algorithm,'' </title> <booktitle> Proc. 14th IEEE Symposium on Switching and Automata Theory (1973), </booktitle> <pages> 1-11. 16 </pages>
Reference-contexts: The Suffix tree is a data structure that admits efficient on-line string searches. A suffix tree for a text A of length N over an alphabet S can be built in O (N log | S| ) time and O (N) space <ref> [Wei73, McC76] </ref>. Suffix trees permit on-line string searches of the type, ``Is W a substring of A?'' to be answered in O (P log | S| ) time, where P is the length of W. <p> Suffix trees have been applied to fundamental string problems such as finding the longest repeated substring <ref> [Wei73] </ref>, finding all squares or repetitions in a string [AP83], computing substring statistics [AP85], approximate string matching [Mye86, LV89, CL90], and string comparison [EH86].
References-found: 29

