URL: ftp://ftp.eecs.umich.edu/groups/gasm/kerberos.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: Giampaolo.Bella@cl.cam.ac.uk)  riccobene@dipmat.unict.it)  
Title: Formal Analysis of the Kerberos Authentication System  
Author: Giampaolo Bella Elvinia Riccobene 
Address: New Museums Site Pembroke Street CB2 3QG Cambridge (UK)  Viale A.Doria, 6 I-95125 Catania (ITALY)  
Affiliation: (Computer Laboratory, University of Cambridge  (Dipartimento di Matematica, Universita di Catania  
Abstract: The Gurevich's Abstract State Machine formalism is used to specify the well known Kerberos Authentication System based on the Needham-Schroeder authentication protocol. A complete model of the system is reached through stepwise refinements of ASMs, and is used as a basis both to discover the minimum assumptions to guarantee the correctness of the system and to analyse its security weaknesses. Each refined model comes together with a correctness refinement theorem. Key Words: Formal Methods, Security, Protocol specification, Refinement, Protocol verification, Key distribution protocol, Gurevich's Abstract State Machine, Kerberos. Category: C.2.2, D 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi, Needham 96] <author> Abadi, M., Needham, </author> <title> R.: </title> <journal> "Prudent engineering practice for cryptographic protocols"; IEEE Transactions on Software Engineering (1996), </journal> <volume> 22(1), </volume> <pages> 6-15. </pages>
Reference: [Anderson 95] <author> Anderson, R.: </author> <title> "Why cryptosystems fail"; Communications of the ACM (1994), </title> <booktitle> 37(11), </booktitle> <pages> 32-40. </pages>
Reference-contexts: A protocol should be correct, i.e. it should allow authorised users from gaining the services they require, and hopefully secure, i.e. it should prevent any unauthorised user to get access to any service. Unfortunately, unlike the former notion, security "... is not a simple Boolean predicate" <ref> [Anderson 95] </ref>. Today, after thirty years of networking, researchers have proved many properties of Journal of Universal Computer Science, vol. 3, no. 12 (1997), 1337-1381 submitted: 20/11/96, accepted: 22/6/97, appeared: 28/12/97 Springer Pub. Co. different protocols, but claims like `this protocol is secure' are still difficult to make.
Reference: [Bella, Paulson 97] <author> Bella, G., Paulson, </author> <title> L.C.: "Using Isabelle to Prove Properties of the Kerberos Authentication System"; in Proc. </title> <booktitle> DIMACS Workshop on Design and Formal Verification of Security Protocols (1997). </booktitle>
Reference-contexts: To our knowledge, this is the first attempt to get a formal specification of the whole Kerberos architecture, and we believe that our work might serve as a basis for both implementation and further tool-assisted analyses. As a matter of fact, the work of <ref> [Bella, Paulson 97] </ref> is based on our specification. The specification of the whole architecture comes together with the proofs of correctness under reasonable regularity conditions, and the description of a real hostile environment.
Reference: [Bellare, Rogaway 95] <author> Bellare, M., Rogaway, P.: </author> <title> "Provably Secure Session Key Distribution The Three Party Case"; Proc. </title> <booktitle> STOCS 1995, </booktitle> <publisher> ACM Press (1995), </publisher> <pages> 57-66. </pages>
Reference: [Bellovin, Merritt 90] <author> Bellovin, S.M., Merritt, M.: </author> <title> "Limitations of the Kerberos authentication system"; Computer Comm. </title> <journal> Review (1990), </journal> <volume> 20(5), </volume> <pages> 119-132. </pages>
Reference-contexts: The accidental loss of a session key is supposed to be overcome by the presence of timestamps [Denning, Sacco 81]. Nevertheless, Kerberos still seems to suffer from some limitations <ref> [Bellovin, Merritt 90] </ref>, which were partially corrected in the last version, Version 5, and are highlighted here. <p> On the other hand, many have taken into account too weak, unrealistic attackers. A tradeoff is needed. The following capabilities seem the most reasonable <ref> [Bellovin, Merritt 90] </ref>.
Reference: [Bolignano 96] <author> Bolignano, D.: </author> <title> "An approach to the formal verification of cryptographic protocols"; in Third ACM Conference on Computer and Communication Security, </title> <publisher> ACM Press (1996), </publisher> <pages> 106-118. </pages>
Reference-contexts: To tackle them, the use of formal methods has recently had good results ([Bellare, Rogaway 95], [Burrows et al. 90], [Lowe 96a], <ref> [Bolignano 96] </ref>, [Paulson 96], etc.). This paper shows how the Gurevich's Abstract State Machine (ASM in brief) formalism can model a complex protocol like Kerberos, and allow us to reason about its properties.
Reference: [Borger 95a] <author> Borger, E.: </author> <title> "Specification and Validation Methods", </title> <publisher> Oxford University Press (1994). </publisher>
Reference: [Borger 95b] <author> Borger, E.: </author> <title> "Why Use Evolving Algebras for Hardware and Software Engineering?"; in M. </title> <editor> Bartosek, J. Staudek, J. Wiedermann (Eds.): </editor> <booktitle> Proc. </booktitle> <address> SOFSEM'95, </address> <publisher> Springer LNCS 1012 (1995), </publisher> <pages> 236-271. </pages> <note> 1380 Bella G., </note> <author> Riccobene E.: </author> <title> Formal Analysis of the Kerberos Authentication System </title>
Reference-contexts: Each model is a distributed Gurevich's Abstract State Machine. The basic definitions of this framework can be found in [Section 3.1], while for the mathematical foundation we refer to <ref> [Gurevich 95, Borger 95b] </ref>. The first model, MessagePassing, describes the message exchange layout between agents and considers only one client process. Elements like tickets and authenticators are considered as atomic objects provided by monitored functions. It gives the guidelines of the protocol.
Reference: [Borger, Mearelli 97] <author> Borger, E., Mearelli, L.: </author> <title> "Integrating ASMs into the Software Development Life Cycle"; in J.UCS (1997), </title> <booktitle> 3(5), </booktitle> <pages> 603-665. </pages>
Reference-contexts: A function in the signature of A is called controlled if it is updated by (and only by) a transition rule in Prog, otherwise, if its values come by modifications of the environment, it is called monitored (see <ref> [Borger, Mearelli 97] </ref>). The symbol S denotes the reduct of the state S to the controlled functions.
Reference: [Burrows et al. 90] <author> Burrows, M., Abadi, M., Needham, R.: </author> <title> "A Logic for Authentication"; ACM Transaction on Computer Systems, </title> <booktitle> 8,1(1990), </booktitle> <pages> 18-35. </pages>
Reference-contexts: Although errors might arise at the implementation level, when writing the compilable code for a protocol, the flaws which are more difficult to detect seem to be hidden at the design level. To tackle them, the use of formal methods has recently had good results ([Bellare, Rogaway 95], <ref> [Burrows et al. 90] </ref>, [Lowe 96a], [Bolignano 96], [Paulson 96], etc.). This paper shows how the Gurevich's Abstract State Machine (ASM in brief) formalism can model a complex protocol like Kerberos, and allow us to reason about its properties. <p> The specification of the whole architecture comes together with the proofs of correctness under reasonable regularity conditions, and the description of a real hostile environment. These features make our specification more reliable than the theoretical work of <ref> [Burrows et al. 90] </ref> and of [Schumann 97], and more realistic than the work of [Mitchell et al. 97], which is based on a very idealised version of Kerberos without timestamps, and suffer from the intrinsic limits of state enumeration. The paper is organised as follows.
Reference: [Denning, Sacco 81] <author> Denning, D.E., Sacco, G.M.: </author> <title> "Timestamps in key distribution protocols"; Comm. </title> <journal> of ACM (1981), </journal> <volume> 24(8), </volume> <pages> 533-536. </pages>
Reference-contexts: The accidental loss of a session key is supposed to be overcome by the presence of timestamps <ref> [Denning, Sacco 81] </ref>. Nevertheless, Kerberos still seems to suffer from some limitations [Bellovin, Merritt 90], which were partially corrected in the last version, Version 5, and are highlighted here.
Reference: [Gurevich 95] <author> Gurevich, Y.: </author> <title> "Evolving Algebras 1993: Lipari Guide"; in E. </title> <editor> Borger (Ed.): </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press (1995). </publisher>
Reference-contexts: Each model is a distributed Gurevich's Abstract State Machine. The basic definitions of this framework can be found in [Section 3.1], while for the mathematical foundation we refer to <ref> [Gurevich 95, Borger 95b] </ref>. The first model, MessagePassing, describes the message exchange layout between agents and considers only one client process. Elements like tickets and authenticators are considered as atomic objects provided by monitored functions. It gives the guidelines of the protocol. <p> Each refined model comes together with a refinement theorem. 3.1 Gurevich's Abstract State Machines We assume that the reader is familiar with the semantics of the Abstract State Machine defined in <ref> [Gurevich 95] </ref>, and we quote here only the essential definitions. A Gurevich's Abstract State Machine A is defined by a program Prog - consisting of a finite number of transition rules and a (class of) initial state (s) S 0 . <p> The partially ordered run, defined in <ref> [Gurevich 95] </ref>, is the most general definition of run for a distributed ASM. In order to prove properties on a partially ordered run, the attention may be restricted to a linearisation of it, which is, in turn, a sequential run (see [Gurevich 95] for more explanations). <p> The partially ordered run, defined in <ref> [Gurevich 95] </ref>, is the most general definition of run for a distributed ASM. In order to prove properties on a partially ordered run, the attention may be restricted to a linearisation of it, which is, in turn, a sequential run (see [Gurevich 95] for more explanations). In the context of a distributed ASM, the functions are better classified from a specific agent's point of view.
Reference: [Lowe 96a] <author> Lowe, G.: "SPLICEnAS: </author> <title> A case study in using to detect errors in security protocols"; Technical Report, </title> <institution> Oxford University Computing Laboratory (1996). </institution>
Reference-contexts: To tackle them, the use of formal methods has recently had good results ([Bellare, Rogaway 95], [Burrows et al. 90], <ref> [Lowe 96a] </ref>, [Bolignano 96], [Paulson 96], etc.). This paper shows how the Gurevich's Abstract State Machine (ASM in brief) formalism can model a complex protocol like Kerberos, and allow us to reason about its properties. <p> This approach might work well, but could also, e.g., cause overloading problems to state-enumeration methods (as pointed out in <ref> [Lowe 96a, Paulson 96] </ref>), or prove to be unplausible. On the other hand, many have taken into account too weak, unrealistic attackers. A tradeoff is needed. The following capabilities seem the most reasonable [Bellovin, Merritt 90].
Reference: [Lowe 96b] <author> Lowe, G.: </author> <title> "Breaking and fixing the Needham-Schroeder public-key protocol using CSP and FDR"; in T. </title> <editor> Margaria and B. Steffen (Eds.): </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems (1996), Second International Workshop, </booktitle> <volume> TACAS '96, LNCS 1055, </volume> <pages> 147-166. </pages>
Reference-contexts: Although protocols are generally made up of a few messages sent on the network, they can hide terribly subtle errors. It is not unusual for errors to be discovered on protocols that have been used for years (e.g. see <ref> [Lowe 96b] </ref>). Protocol errors ". . . are unlikely to be detected in normal operations. The need for techniques to verify the correctness of such protocols is great . . . " [Needham, Schroeder 78].
Reference: [Miller et al. 89] <author> Miller, S.P., Neuman, J.I., Schiller, J.I., Saltzer, J.H.: </author> <title> "Kerberos Authentication and Authorisation System"; Project Athena Techical Plan, Section E.2.1, </title> <publisher> MIT (1989), </publisher> <pages> 1-36. </pages>
Reference-contexts: Liveness conditions and proofs of correctness are presented in [Section 3.4]; [Section 4] concerns the external threats, and [Section 5] concludes the paper. 1338 Bella G., Riccobene E.: Formal Analysis of the Kerberos Authentication System 2 Kerberos Kerberos <ref> [Miller et al. 89] </ref> was developed in the mid eighties as part of project Athena at MIT. <p> Based on the [Needham, Schroeder 78] key distribution protocol modified with the addition of timestamps [Voydock, Kent 83], Kerberos relies exclusively on private-key (also called conventional) encryption, rather than public-key encryption. In this paper we refer to the original Kerberos, Version 4 <ref> [Miller et al. 89] </ref>, which is the most widely used. 2.1 How Kerberos Works In [Fig. 1], we can see the complete layout of the Kerberos architecture. <p> Thus, in Fun (C) expired is a monitored predicate which is true on a key K if and only if the copy of K saved in the memory of the server that generates it, has expired. Such a differentiation comes from a lack of detail in <ref> [Miller et al. 89] </ref>, which is better explained in the next section. <p> Therefore, the function ExtractTs is rewritten by ts. The function BuildAuth is refined as follows: BuildAuth (C, K (C,S )) = encrypt ( fC, address (C ), CT g, K (C,S )) Authenticators expire after a short time of a few minutes <ref> [Miller et al. 89] </ref>, so that we introduce the suitable parameter DeltaAuth: REAL, upper bound on the lifetime of an authenticator. On reception of a message from C, S has to authenticate C using as credentials the ticket and the authenticator found inside the message. <p> C checks that the message received from KAS and TGS is recent by the predicate CheckValid (CryptedMssg, mark) which is true when CryptedMssg is recent. We need now to formalise this concept of "recent message" which is not stated more precisely in <ref> [Miller et al. 89] </ref>'s informal description. Our model assumes the underlying communication protocol to be reliable (if agent X sends agent Y message mssg, Y receives mssg with no alterations). <p> The lifetime of the session key inside the messages sent to C in both the rules seems redundant information to the authors. In fact, it is not clear in <ref> [Miller et al. 89] </ref> how C might use such information to check the expiration time of a session key. This is why expired is still a monitored predicate in Fun (C). The test on the password in rule GetAuthentication is done in more than one step.
Reference: [Mitchell et al. 97] <author> Mitchell, J.C., Mitchell, M., Stern, U.: </author> <title> "Automated Analysis of Cryptographic Protocols Using Murphi"; IEEE Symposium on Security and Privacy (1997), </title> <type> 141-151. </type>
Reference-contexts: These features make our specification more reliable than the theoretical work of [Burrows et al. 90] and of [Schumann 97], and more realistic than the work of <ref> [Mitchell et al. 97] </ref>, which is based on a very idealised version of Kerberos without timestamps, and suffer from the intrinsic limits of state enumeration. The paper is organised as follows.
Reference: [Needham, Schroeder 78] <author> Needham, R., Schroeder, M.: </author> <title> "Using encryption for authentication in large networks of computers"; Communication of the ACM, </title> <booktitle> 21,12 (1978), </booktitle> <pages> 993-999. </pages>
Reference-contexts: Protocol errors ". . . are unlikely to be detected in normal operations. The need for techniques to verify the correctness of such protocols is great . . . " <ref> [Needham, Schroeder 78] </ref>. A protocol should be correct, i.e. it should allow authorised users from gaining the services they require, and hopefully secure, i.e. it should prevent any unauthorised user to get access to any service. <p> The Kerberos Authentication System is based on the Needham and Schroeder authentication protocol, which seems to be secure under the naive assumption that no session keys may ever be compromised <ref> [Needham, Schroeder 78] </ref>. The accidental loss of a session key is supposed to be overcome by the presence of timestamps [Denning, Sacco 81]. Nevertheless, Kerberos still seems to suffer from some limitations [Bellovin, Merritt 90], which were partially corrected in the last version, Version 5, and are highlighted here. <p> Based on the <ref> [Needham, Schroeder 78] </ref> key distribution protocol modified with the addition of timestamps [Voydock, Kent 83], Kerberos relies exclusively on private-key (also called conventional) encryption, rather than public-key encryption.
Reference: [Neuman, Ts'o 94] <author> Neuman, </author> <title> B.C., Ts'o, T: "Kerberos: An authentication service for computer network"; IEEE Communication Magazine, </title> <booktitle> 32,9 (1994), </booktitle> <pages> 33-39. </pages>
Reference: [Paulson 96] <author> Paulson, </author> <title> L.C.: "Proving properties of security protocols by induction"; Technical Report No.409, </title> <institution> Cambridge University Computer Laboratory (1996). </institution>
Reference-contexts: To tackle them, the use of formal methods has recently had good results ([Bellare, Rogaway 95], [Burrows et al. 90], [Lowe 96a], [Bolignano 96], <ref> [Paulson 96] </ref>, etc.). This paper shows how the Gurevich's Abstract State Machine (ASM in brief) formalism can model a complex protocol like Kerberos, and allow us to reason about its properties. <p> This approach might work well, but could also, e.g., cause overloading problems to state-enumeration methods (as pointed out in <ref> [Lowe 96a, Paulson 96] </ref>), or prove to be unplausible. On the other hand, many have taken into account too weak, unrealistic attackers. A tradeoff is needed. The following capabilities seem the most reasonable [Bellovin, Merritt 90].
Reference: [Schumann 97] <author> Schumann, J.: </author> <title> "Automatic Verification of Cryptographic Protocols with Setheo", </title> <booktitle> in Proc. CADE97 Workshop of Automated Theorem Proving in Software Engineering (1997). </booktitle>
Reference-contexts: The specification of the whole architecture comes together with the proofs of correctness under reasonable regularity conditions, and the description of a real hostile environment. These features make our specification more reliable than the theoretical work of [Burrows et al. 90] and of <ref> [Schumann 97] </ref>, and more realistic than the work of [Mitchell et al. 97], which is based on a very idealised version of Kerberos without timestamps, and suffer from the intrinsic limits of state enumeration. The paper is organised as follows.
Reference: [Stalling 95] <author> Stalling, </author> <title> W.S.: "Network and Internetwork Security Principles and Practice", </title> <publisher> Prentice Hall (1995). </publisher>
Reference: [Stevens 90] <author> Stevens, W.R.: </author> <title> "UNIX Network Programming", </title> <publisher> PTR Prentice Hall (1990). </publisher>
Reference: [Voydock, Kent 83] <author> Voydock, V.L., Kent, S.T.: </author> <title> "Security mechanisms in high-level network protocols"; Computing Surveys 15 (1983), </title> <note> 135-171. </note> <author> 1381Bella G., Riccobene E.: </author> <title> Formal Analysis of the Kerberos Authentication System </title>
Reference-contexts: Based on the [Needham, Schroeder 78] key distribution protocol modified with the addition of timestamps <ref> [Voydock, Kent 83] </ref>, Kerberos relies exclusively on private-key (also called conventional) encryption, rather than public-key encryption. <p> In this context, we use the term spy to refer to a network user whose target is accessing a network resource without using her identity, i.e. user identifier and password. For a complete treatment of the concept of spy, see <ref> [Voydock, Kent 83] </ref>. 4.1 The spy To specify a spy's operation, first of all one has to answer the following questions.
References-found: 23

