URL: http://www.csl.sri.com/~gong/papers/secure-causality.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs93.html
Root-URL: 
Title: Preventing Denial and Forgery of Causal Relationships in Distributed Systems  
Author: Michael Reiter Li Gong 
Address: Upson Hall  333 Ravenswood Avenue Ithaca, New York 14853 Menlo Park, California 94025  
Affiliation: Department of Computer Science SRI International  Computer Science Laboratory Cornell University  
Abstract: In a distributed system, it is often important to detect the causal relationships between events, where event e 1 is causally before event e 2 if e 1 happened before e 2 and could possibly have affected the occurrence of e 2 . In this paper we argue that detecting causal relationships among events can be important for security, in the sense that it may be essential to the correct implementation of a security policy that a process be able to determine if two events are causally related, and if so, how. We formulate attacks on causality in terms of causal denial and forgery, formalize possible security goals with respect to causality, and present simple algorithms to attain these goals in some situations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and M. R. Tuttle. </author> <title> A semantics for a logic of authentication. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 201-216, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: For example, consider the following use of causality to detect freshness, a property studied extensively by the security community. A message is fresh in a run of a protocol if its contents have not appeared in another message sent before this run of the protocol began <ref> [5, 1] </ref>. One way to detect freshness is to use causality: if a message can be verified to be causally after a fresh message, then it too should be considered fresh. One common technique for detecting freshness, namely challenge-response interactions [11], is an instance of this method.
Reference: [2] <author> K. P. Birman, R. Cooper, and B. Gleeson. </author> <title> Design alternatives for process group membership and multicast. </title> <type> Technical Report 91-1257, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Decem-ber </month> <year> 1991. </year>
Reference-contexts: This causal order can be seen as an extension of FIFO order to a setting with multiple senders and receivers, and is especially useful in systems that exploit asynchronous communication for performance <ref> [2] </ref>. Here we argue that detecting causal relationships among events can also be important for security, in that it may be essential to the implementation of a security policy that a process be able to determine if two events are causally related, and if so, how.
Reference: [3] <author> K. P. Birman and T. A. Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: than they are created. 6.2 The piggybacking algorithm Our second algorithm for satisfying F if the sender of m 1 is correct is based on a piggybacking technique that, to our knowledge, was first used in an early version of the Isis system to detect causal relationships in benign settings <ref> [3] </ref>. This algorithm is more costly than that in section 6.1.
Reference: [4] <author> K. P. Birman, A. Schiper, and P. Stephen-son. </author> <title> Lightweight causal and atomic group multi-cast. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., <ref> [12, 7, 17, 4, 8] </ref>). For instance, several systems implement communication primitives that deliver messages in an order consistent with the causal relationships among the messages (i.e., among the events in which the messages were sent). <p> Then, because if m 1 is received before m 2 then m 2 is received after m 1 , C (m 2 ; m 1 ) is false. 2 This approach, sometimes called the conservative approach, has been used by several systems to detect causal relationships in benign environments (e.g., <ref> [17, 4] </ref>). It is especially attractive in our setting because a correct process can singlehandedly prevent corrupt processes from "backdating" their messages 2 A further condition is required if multicast communication is used (see [4]). <p> It is especially attractive in our setting because a correct process can singlehandedly prevent corrupt processes from "backdating" their messages 2 A further condition is required if multicast communication is used (see <ref> [4] </ref>). However, as stated in section 2, we restrict ourselves in this paper to point-to-point communication. 3 These acknowledgements could be viewed as introducing additional causal relationships. <p> One approach is implemented in the Isis system, which uses a version of the conservative protocol adapted for mul-ticast communication <ref> [4, 14] </ref>. In Isis, a trusted, fault-tolerant service called the failure detector declares processes faulty when they appear so, thus removing them from the system view [15]. <p> The primary weakness of this algorithm is its ability to scale. As n becomes large, signed vector times-tamps could consume significant network bandwidth. Techniques similar to some of those described in <ref> [4] </ref> for compressing timestamps in benign systems are appropriate for use in our system model but will not be discussed here. A second threat to scale is that the cost of computing and verifying signatures could be significant if n is large. <p> Such determinations are necessary if, e.g., P must deliver received messages to an application in an order consistent with the causal relationships among them (e.g., <ref> [17, 4] </ref>). The algorithms of section 5 ensure that all causally prior messages have been received if all such messages are sent by correct processes, although this does not necessarily hold if a causally prior message is sent by a corrupt process.
Reference: [5] <author> M. Burrows, M. Abadi, and R. Needham. </author> <title> A logic of authentication. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: For example, consider the following use of causality to detect freshness, a property studied extensively by the security community. A message is fresh in a run of a protocol if its contents have not appeared in another message sent before this run of the protocol began <ref> [5, 1] </ref>. One way to detect freshness is to use causality: if a message can be verified to be causally after a fresh message, then it too should be considered fresh. One common technique for detecting freshness, namely challenge-response interactions [11], is an instance of this method.
Reference: [6] <author> J. A. Goguen and J. Meseguer. </author> <title> Security policies and security models. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 11-20, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: That is, in previous works, causal relationships have been viewed as something to be avoided in order to achieve noninterference <ref> [6] </ref>. In contrast, we claim that because of the fundamental role of causality in distributed systems, the accurate detection (but not elimination) of causal relationships can be crucial to security in distributed systems.
Reference: [7] <author> M. P. Herlihy and J. M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., <ref> [12, 7, 17, 4, 8] </ref>). For instance, several systems implement communication primitives that deliver messages in an order consistent with the causal relationships among the messages (i.e., among the events in which the messages were sent).
Reference: [8] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghe-mawat. </author> <title> Providing high availability using lazy replication. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 10(4) </volume> <pages> 360-391, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., <ref> [12, 7, 17, 4, 8] </ref>). For instance, several systems implement communication primitives that deliver messages in an order consistent with the causal relationships among the messages (i.e., among the events in which the messages were sent).
Reference: [9] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: 1 Introduction In a distributed system, it is often important to detect the causal relationships between events, where event e 1 is causally before event e 2 if e 1 happened before e 2 and could possibly have affected the occurrence of e 2 <ref> [9] </ref>. Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., [12, 7, 17, 4, 8]). <p> Thus, for simplicity we treat only point-to-point communication here. 3 Definition of causality We use the notion of causality formulated by Lam-port in <ref> [9] </ref>. As described in section 1, one event is causally before another if it could have affected that other event. More precisely, suppose we define the "one-step" causality relation ; as the smallest relation satisfying the following conditions: 1. <p> Information m so signed is denoted fmg K i . 6.1 Signed vector timestamps Our first algorithm originates from a technique introduced in Lamport's paper on causality <ref> [9] </ref>, where he described an algorithm using logical clocks to detect causal relationships among messages (in benign environments).
Reference: [10] <author> F. Mattern. </author> <title> Virtual time and global states in distributed systems. </title> <booktitle> In Proceedings of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevier Science Publishers B. V. (North-Holland), </publisher> <year> 1989. </year>
Reference-contexts: Later, however, several researchers (e.g., <ref> [10] </ref>) extended the notion of logical clocks to that of vector clocks and defined a new relation "" on them so that the converse condition could also be satisfied: T2: For any events e 1 and e 2 , if t i [e 1 ] t j [e 2 ], then <p> In the algorithm in <ref> [10] </ref>, each process P i maintains a vector clock t i = ht 1 i ; t 2 i i, where n is the total number of processes in the system and for each k 2 f1; : : :; ng, t k i is a nonnegative integer.
Reference: [11] <author> R. M. Needham and M. D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: Thus, this technique is similar to the use of nonce identifiers <ref> [11] </ref>, in that causal relationships are established by the presence of "new," unpredictable, and verifiable values (i.e., the signed components) in messages. However, our algorithm is more general because any process can verify each value, and not just the process that issued it. <p> One way to detect freshness is to use causality: if a message can be verified to be causally after a fresh message, then it too should be considered fresh. One common technique for detecting freshness, namely challenge-response interactions <ref> [11] </ref>, is an instance of this method. In this technique, P challenges Q with a new, unpredictable nonce identifier, which Q must include in its response to P .
Reference: [12] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., <ref> [12, 7, 17, 4, 8] </ref>). For instance, several systems implement communication primitives that deliver messages in an order consistent with the causal relationships among the messages (i.e., among the events in which the messages were sent).
Reference: [13] <author> M. K. Reiter and K. P. Birman. </author> <title> How to securely replicate services. </title> <type> Technical Report 92-1287, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: That is, all communication would cease if the causality server failed, and the corruption of the causality server would compromise the ability of any correct process to detect causal relationships. These problems can be addressed using known replication techniques (e.g., <ref> [17, 13] </ref>), albeit at an additional cost to performance. 5.2 The conservative approach An alternative approach to the use of a causality server is for each process P to delay sending a mes sage to its destination until all messages that P previously sent to other destinations have been received at
Reference: [14] <author> M. K. Reiter, K. P. Birman, and L. Gong. </author> <title> Integrating security in a group oriented distributed system. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 18-32, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: In contrast, we claim that because of the fundamental role of causality in distributed systems, the accurate detection (but not elimination) of causal relationships can be crucial to security in distributed systems. This was first illustrated in <ref> [14] </ref> by the following example of "insider trading": suppose that a trader issues a request to a trading service to purchase shares of stock, and then as a result of an (indirect or direct) interaction with another trader, the other trader infers that this request has been made. <p> In this paper we formalize possible security goals with respect to causality and present simple algorithms to attain these goals in some situations. This work is a major generalization and improvement of the discussion of causality in <ref> [14] </ref>, in two ways. First, this work presents a general framework in which attacks on causality can be examined; in this framework, we were able to identify attacks that are not considered in [14]. Second, we present new algorithms to counter these attacks. <p> This work is a major generalization and improvement of the discussion of causality in <ref> [14] </ref>, in two ways. First, this work presents a general framework in which attacks on causality can be examined; in this framework, we were able to identify attacks that are not considered in [14]. Second, we present new algorithms to counter these attacks. The remainder of this paper is structured as follows. In section 2, we describe the assumptions that we make about the system. In section 3, we formally define the notion of causality. <p> One approach is implemented in the Isis system, which uses a version of the conservative protocol adapted for mul-ticast communication <ref> [4, 14] </ref>. In Isis, a trusted, fault-tolerant service called the failure detector declares processes faulty when they appear so, thus removing them from the system view [15]. <p> We have presented two algorithms for preventing denial and two algorithms for preventing or limiting forgery in some situations. We initially became aware of the importance of detecting causality in hostile environments during another research effort directed at building secure distributed systems <ref> [14] </ref>. As part of that effort, a variant of the conservative protocol of section 5.2 has been implemented. One area for future work is the implementation of other algorithms so that comparisons between them can be made in real systems.
Reference: [15] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-351, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: One approach is implemented in the Isis system, which uses a version of the conservative protocol adapted for mul-ticast communication [4, 14]. In Isis, a trusted, fault-tolerant service called the failure detector declares processes faulty when they appear so, thus removing them from the system view <ref> [15] </ref>. The result is that a process that attempts denial-of-service attacks by refusing to acknowledge messages will eventually be considered faulty and ignored by all correct processes in the system.
Reference: [16] <author> R. L. Rivest. </author> <title> The MD4 message digest algorithm. </title> <editor> In A. J. Menezes and S. A. Vanstone, editors, </editor> <booktitle> Advances in Cryptology|CRYPTO '90 Proceedings, Lecture Notes in Computer Science 537, </booktitle> <pages> pages 303-311. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A third improvement (that is incompatible with the second) uses message digests to limit the size of piggybacked messages. A message digest algorithm (e.g., <ref> [16] </ref>) produces a fixed length message digest from an input of arbitrary length, in such a way that it is com-putationally infeasible to produce any input having a prespecified target message digest, or to produce two inputs having the same message digest.
Reference: [17] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Causality has been recognized as fundamental to distributed computing and forms the basis for event orderings in many distributed systems and distributed service implementations (e.g., <ref> [12, 7, 17, 4, 8] </ref>). For instance, several systems implement communication primitives that deliver messages in an order consistent with the causal relationships among the messages (i.e., among the events in which the messages were sent). <p> For instance, consider a service that allocates a distributed resource to processes in an order consistent with the causal relationships among their requests <ref> [17] </ref>. If such a service is to be fair in a hostile setting, it must be able to detect causal relationships accurately, despite attempts of dishonest processes to wrongfully make their requests appear causally prior to other requests. <p> We also assume that channels between correct processes provide FIFO delivery using, e.g., a standard sequence number mechanism [19]. Many algorithms used to detect causality in benign environments utilize assumptions of synchronized clocks or bounded message transmission delays (e.g., <ref> [17] </ref>). However, we do not assume that correct processes maintain synchronized clocks, or that message transmission times between correct processes or execution speeds of correct processes are bounded. That is, the system is totally asynchronous. <p> That is, all communication would cease if the causality server failed, and the corruption of the causality server would compromise the ability of any correct process to detect causal relationships. These problems can be addressed using known replication techniques (e.g., <ref> [17, 13] </ref>), albeit at an additional cost to performance. 5.2 The conservative approach An alternative approach to the use of a causality server is for each process P to delay sending a mes sage to its destination until all messages that P previously sent to other destinations have been received at <p> Then, because if m 1 is received before m 2 then m 2 is received after m 1 , C (m 2 ; m 1 ) is false. 2 This approach, sometimes called the conservative approach, has been used by several systems to detect causal relationships in benign environments (e.g., <ref> [17, 4] </ref>). It is especially attractive in our setting because a correct process can singlehandedly prevent corrupt processes from "backdating" their messages 2 A further condition is required if multicast communication is used (see [4]). <p> Such determinations are necessary if, e.g., P must deliver received messages to an application in an order consistent with the causal relationships among them (e.g., <ref> [17, 4] </ref>). The algorithms of section 5 ensure that all causally prior messages have been received if all such messages are sent by correct processes, although this does not necessarily hold if a causally prior message is sent by a corrupt process.
Reference: [18] <author> S. Smith. </author> <title> Secure clocks for partial order time. </title> <type> Ph.D. thesis proposal, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1991. </year> <note> An excerpt from this proposal was published as: </note> <author> S. Smith and J. D. Tygar. </author> <title> Signed vector times-tamps: A secure protocol for partial order time. </title> <type> Techical Report CMU-CS-93-116, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Febru-ary </month> <year> 1993. </year>
Reference-contexts: In a private communication in February 1993, Doug Tygar informed us that Sean Smith independently developed a protocol similar to that of section 6.1 of this paper, in his work on secure clocks for partial order time <ref> [18] </ref>.
Reference: [19] <author> V. L. Voydock and S. T. Kent. </author> <title> Security mechanisms in high-level network protocols. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(2) </volume> <pages> 135-171, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: In addition, all communication between corrupt processes is modeled with explicit sends and receives, regardless of its actual form (e.g., signals via a covert channel). We also assume that channels between correct processes provide FIFO delivery using, e.g., a standard sequence number mechanism <ref> [19] </ref>. Many algorithms used to detect causality in benign environments utilize assumptions of synchronized clocks or bounded message transmission delays (e.g., [17]). However, we do not assume that correct processes maintain synchronized clocks, or that message transmission times between correct processes or execution speeds of correct processes are bounded.
References-found: 19

