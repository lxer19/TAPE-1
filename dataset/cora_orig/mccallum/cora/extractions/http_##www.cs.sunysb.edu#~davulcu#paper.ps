URL: http://www.cs.sunysb.edu/~davulcu/paper.ps
Refering-URL: http://www.cs.sunysb.edu/~davulcu/
Root-URL: http://www.cs.sunysb.edu
Email: davulcu@cs.sunysb.edu  kifer@cs.sunysb.edu  cram@cs.sunysb.edu  ram@cs.sunysb.edu  
Title: Logic Based Modeling and Analysis of Workflows (Extended Abstract)  
Author: Hasan Davulcu Michael Kifer C.R. Ramakrishnan I.V. Ramakrishnan 
Affiliation: SUNY at Stony Brook  SUNY at Stony Brook  SUNY at Stony Brook  SUNY at Stony Brook  
Abstract: We propose Concurrent Transaction Logic (CT R) as the language for specifying, analyzing, and scheduling of workflows. We show that both local and global properties of workflows can be naturally represented as CT R formulas and reasoning can be done with the use of the proof theory and the semantics of this logic. We describe a transformation that leads to an efficient algorithm for scheduling workflows in the presence of global temporal constraints, which leads to decision procedures for dealing with several safety related properties such as whether every valid execution of the workflow satisfies a particular property or whether a workflow execution is consistent with some given global constraints on the ordering of events in a workflow. We also provide tight complexity results on the running times of these algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alonso, D. Agrawal, A. El Abbadi, M. Kamath, R. Gunthor, and C. Mohan. </author> <title> Advanced transaction models in workflow contexts. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [2] <author> G Alonso, D. Agrawal, A. El Abbadi, and C. Mohan. </author> <title> Functionality and limitations of current workflow management systems. </title> <note> In IEEE-Expert (to appear in a special issue on Cooperative Information Systems), </note> <year> 1997. </year>
Reference-contexts: Ideally, they should also help the user in analysis and reasoning about complex business processes. It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics <ref> [18, 2] </ref>. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic [5, 4, 6, 7]. Workflow representation frameworks.
Reference: [3] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <year> 1993. </year>
Reference-contexts: Passive schedulers receive sequences of events from an external source, such as a workflow or a transaction manager, and validate that these sequences satisfy all global constraints (possibly after reordering some events in the sequences). Several such schedulers are described in <ref> [26, 3, 19] </ref>. <p> In contrast, the event scheduler of [27] has quadratic complexity. Thus, while expanding the effort on consistency checking (which needs to be done anyway), we compile the original specifications into a form that lets us find allowable schedules much more efficiently than with the passive approaches of <ref> [27, 3, 19] </ref> (It should be noted that, these latter algorithms do not do consistency checks). 5 Compiling Constraints into the Control Flow Graph We define the process of compiling the constraints in CONST R into unique-event goals by starting with simple events and extending the transformation to more complex ones. <p> In contrast, process scheduling using the standard toolkit of process algebras and temporal logic requires automata that are exponential in the size of the original graph. Workflow modeling. We have already discussed formalisms used for passive workflow scheduling <ref> [26, 27, 3, 19] </ref>. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic [14] or process algebras [23] can also be used for modeling workflows.
Reference: [4] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2]. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic <ref> [5, 4, 6, 7] </ref>. Workflow representation frameworks. <p> Due to space limitation, we cannot discuss the model theory of the logic or its proof theory. Instead, we rely on the procedural reading of CT R statements. 2 A thorough treatment of the main aspects of Transaction Logic appears in <ref> [6, 5, 4] </ref>. A fairly detailed, yet informal introduction can be found in [21]. <p> This process of building CT R programs from the ground up is very natural and powerful. The reader is referred to <ref> [4, 5, 6] </ref> for concrete examples. Now we can explain how the various workflow activities (e.g., the symbols a, b, c, etc., in (1)) appear to CT R.
Reference: [5] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <type> Unpublished manuscript. </type>
Reference-contexts: It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2]. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic <ref> [5, 4, 6, 7] </ref>. Workflow representation frameworks. <p> There are many reasons for this choice. First, control flow graphs with transition conditions can be easily and naturally represented in CT R. Second, [7] shows that triggers are easy to represent as well. Finally, <ref> [5] </ref> contains an extensive discussion of the temporal capabilities of CT R. In particular, the entire algebra of constraints described in [26] is isomorphic to a small subset of the propositional Transaction Logic. <p> Due to space limitation, we cannot discuss the model theory of the logic or its proof theory. Instead, we rely on the procedural reading of CT R statements. 2 A thorough treatment of the main aspects of Transaction Logic appears in <ref> [6, 5, 4] </ref>. A fairly detailed, yet informal introduction can be found in [21]. <p> This process of building CT R programs from the ground up is very natural and powerful. The reader is referred to <ref> [4, 5, 6] </ref> for concrete examples. Now we can explain how the various workflow activities (e.g., the symbols a, b, c, etc., in (1)) appear to CT R. <p> Transaction Logic can express a wide variety of temporal constraints <ref> [5] </ref>, but here we focus on a relatively simple algebra of constraints, which we denote by CONST R. CONST R is as expressive as Singh's Event Algebra [27].
Reference: [6] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2]. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic <ref> [5, 4, 6, 7] </ref>. Workflow representation frameworks. <p> Logic-based formalism. In this paper, we base our approach on Concurrent Transaction Logic <ref> [6] </ref> (abbr., CT R). There are many reasons for this choice. First, control flow graphs with transition conditions can be easily and naturally represented in CT R. Second, [7] shows that triggers are easy to represent as well. <p> Due to space limitation, we cannot discuss the model theory of the logic or its proof theory. Instead, we rely on the procedural reading of CT R statements. 2 A thorough treatment of the main aspects of Transaction Logic appears in <ref> [6, 5, 4] </ref>. A fairly detailed, yet informal introduction can be found in [21]. <p> If a constraint violation is detected, a new execution path must be tried out. In contrast, the concurrent-Horn fragment of CT R is efficiently implementable, and there exist an SLD-style proof procedure that proves concurrent-Horn formulas and executes them at the same time <ref> [6] </ref>. The efficiency gap between concurrent-Horn execution and constrained execution is the main motivation for our results. In logical terms, we show that, for a large class of constraints, formulas of the form ConcurrentHornGoal ^ Constraints have an equivalent concurrent-Horn form ( which, therefore, does not use the connective ^). <p> This process of building CT R programs from the ground up is very natural and powerful. The reader is referred to <ref> [4, 5, 6] </ref> for concrete examples. Now we can explain how the various workflow activities (e.g., the symbols a, b, c, etc., in (1)) appear to CT R. <p> The actions send and receive are easily expressed in CT R (see <ref> [6] </ref>) and their semantics is what one would expect of such synchronization primitives: receive (~) is true if and only if send (~) has been previously executed.
Reference: [7] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2]. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic <ref> [5, 4, 6, 7] </ref>. Workflow representation frameworks. <p> For instance, like the graphs, triggers cannot be used to specify global task dependencies, and they are not sufficiently expressive when it comes to representing alternatives in workflow execution (depicted as "OR" nodes in Figure 1). In fact, it follows from a result in <ref> [7] </ref> that triggers with so-called "immediate" execution semantics can be represented using control flow graphs, and this result can be adapted to triggers with the "eventual" execution semantics as well. <p> Logic-based formalism. In this paper, we base our approach on Concurrent Transaction Logic [6] (abbr., CT R). There are many reasons for this choice. First, control flow graphs with transition conditions can be easily and naturally represented in CT R. Second, <ref> [7] </ref> shows that triggers are easy to represent as well. Finally, [5] contains an extensive discussion of the temporal capabilities of CT R. In particular, the entire algebra of constraints described in [26] is isomorphic to a small subset of the propositional Transaction Logic.
Reference: [8] <author> O. Bukhres and E. Kueshn, Eds. </author> <title> Special issue on software support for work flow management. </title> <journal> Distributed and Parallel Databases|An International Journal, </journal> <volume> 3(2), </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: An activity in a workflow might be performed by a human, a device, or a program.Workflow management systems provide a framework for capturing the interaction among the activities in a workflow and are recognized as a new paradigm for integrating disparate systems, including legacy systems <ref> [20, 8] </ref>. Ideally, they should also help the user in analysis and reasoning about complex business processes. It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2].
Reference: [9] <author> Edmund M. Clarke, E. Allen Emerson, and A. Prasad Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> In ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <pages> pages 244-263, </pages> <year> 1986. </year>
Reference-contexts: This should be contrasted with the use of the algebras and temporal logic for specifying workflows, model-checking for their verification, and automata for scheduling. Second, the use of CT R has enabled us to find more efficient verification algorithms. Indeed, standard model checking techniques <ref> [9] </ref> used for verification are worst-case exponential in the size of the control flow graph. This is often referred to as the state-explosion problem.
Reference: [10] <institution> Workflow Management Coalition. Terminology and glossary. </institution> <type> Technical Report (WFMC-TC-1011), </type> <institution> Work-flow Management Coalition, </institution> <address> Brussels, </address> <year> 1996. </year>
Reference-contexts: When the task at the tail of an arc completes, the task at the head can begin only if the corresponding transition condition evaluates to true. The Workflow Management Coalition <ref> [10] </ref> identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities [12, 17, 15, 25, 28, 1, 13].
Reference: [11] <author> U. Dayal, M. Hsu, and R. Ladin. </author> <title> Organizing long-running activities with triggers and transactions. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility <ref> [11] </ref>. However, this method is not as general as control flow graphs. For instance, like the graphs, triggers cannot be used to specify global task dependencies, and they are not sufficiently expressive when it comes to representing alternatives in workflow execution (depicted as "OR" nodes in Figure 1).
Reference: [12] <author> A. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewcz. </author> <title> A multi database transaction model for interbase. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <year> 1990. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [13] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [14] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: Workflow modeling. We have already discussed formalisms used for passive workflow scheduling [26, 27, 3, 19]. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic <ref> [14] </ref> or process algebras [23] can also be used for modeling workflows. However, we believe that our results show that CT R provides a much simpler and uniform way to both describe and reason about workflows. 7 Conclusion We presented a logic-based formalism for specifying, verifying, and executing workflows.
Reference: [15] <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11]. <p> Our techniques assumes the unique-event property for workflow graphs. Hence this property has to be relaxed to handle work flows with loops. Failure semantics. Failure atomicity is built into CT R semantics. However, more complex workflows require more advanced failure semantics, such as compensation <ref> [15] </ref>. Some such semantics can be expressed using the possibility operator of CT R, 3. Work is in progress on extending our framework to handle other failure semantics. Acknowledgements. The authors would like to thank Tony Bonner for the helpful comments on a draft of this paper.
Reference: [16] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman and Company, </publisher> <address> San Francisco, CA, </address> <year> 1978. </year>
Reference-contexts: Let G be a concurrent goal and C CONST R be a set of constraints. Then determining whether G ^C is executable in CT R is NP-complete. The NP-hardness proof is by reduction to satisfiability of propositional logic <ref> [16] </ref>. That the decision problem is in NP follows from the fact that given an arbitrary sequence of events the satisfiability of a set of constraints and a unique-event control flow graph is decidable in polynomial time. A similar result has been previously obtained in [24].
Reference: [17] <author> D. Georgakopoulos, M. Hornick, P. Krychniak, and F. Manola. </author> <title> Specification and management of extended transactions in a programmable transaction environment. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <address> Houston, TX, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [18] <author> D. Georgakopoulos, M. Hornick, and A. Sheth. </author> <title> An overview of workflow management: From process modeling to infrastructure for automation. </title> <journal> Journal on Distributed and Parallel Database Systems, </journal> <volume> 3(2) </volume> <pages> 119-153, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Ideally, they should also help the user in analysis and reasoning about complex business processes. It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics <ref> [18, 2] </ref>. In this paper, we develop a novel framework for specifying, analyzing and executing workflows based on Transaction Logic [5, 4, 6, 7]. Workflow representation frameworks.
Reference: [19] <author> R. Gunthor. </author> <title> Extended transaction processing based on dependency rules. </title> <booktitle> In Proceedings of the RIDE-IMS Workshop, </booktitle> <year> 1993. </year>
Reference-contexts: Passive schedulers receive sequences of events from an external source, such as a workflow or a transaction manager, and validate that these sequences satisfy all global constraints (possibly after reordering some events in the sequences). Several such schedulers are described in <ref> [26, 3, 19] </ref>. <p> In contrast, the event scheduler of [27] has quadratic complexity. Thus, while expanding the effort on consistency checking (which needs to be done anyway), we compile the original specifications into a form that lets us find allowable schedules much more efficiently than with the passive approaches of <ref> [27, 3, 19] </ref> (It should be noted that, these latter algorithms do not do consistency checks). 5 Compiling Constraints into the Control Flow Graph We define the process of compiling the constraints in CONST R into unique-event goals by starting with simple events and extending the transformation to more complex ones. <p> In contrast, process scheduling using the standard toolkit of process algebras and temporal logic requires automata that are exponential in the size of the original graph. Workflow modeling. We have already discussed formalisms used for passive workflow scheduling <ref> [26, 27, 3, 19] </ref>. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic [14] or process algebras [23] can also be used for modeling workflows.
Reference: [20] <author> M. Hsu, </author> <title> Ed. </title> <journal> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 18(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: An activity in a workflow might be performed by a human, a device, or a program.Workflow management systems provide a framework for capturing the interaction among the activities in a workflow and are recognized as a new paradigm for integrating disparate systems, including legacy systems <ref> [20, 8] </ref>. Ideally, they should also help the user in analysis and reasoning about complex business processes. It has been realized that analysis and reasoning about workflows requires a formal specification model with a well defined semantics [18, 2].
Reference: [21] <author> M. Kifer. </author> <title> Transaction logic for the busy workflow professional. </title> <type> Unpublished manuscript, </type> <month> August </month> <year> 1996. </year>
Reference-contexts: Instead, we rely on the procedural reading of CT R statements. 2 A thorough treatment of the main aspects of Transaction Logic appears in [6, 5, 4]. A fairly detailed, yet informal introduction can be found in <ref> [21] </ref>.
Reference: [22] <author> J. Klein. </author> <title> Advanced rule-driven transaction management. </title> <booktitle> In IEEE COMPCON. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: In [26, 27], Singh describes an algebra of temporal constraints, which is believed to cover all useful global dependencies that might arise in workflow systems. For instance, this algebra includes Klein's constraints <ref> [22] </ref>, which commonly occur in workflow specifications 1 . This algebra is sufficiently expressive for modeling control flow graphs that have no transition conditions attached to arcs. <p> This is known as Klein's order constraint <ref> [22] </ref>. * :Of _ (Oe Of ) | if event f has occurred, then event e must have occurred some time prior to that; * :Oe _ Of | if event e occurs, then f must also occur (before or after e). This is known as Klein's existence constraint [22]. <p> constraint <ref> [22] </ref>. * :Of _ (Oe Of ) | if event f has occurred, then event e must have occurred some time prior to that; * :Oe _ Of | if event e occurs, then f must also occur (before or after e). This is known as Klein's existence constraint [22]. Note that Definition 3.2 does not explicitly state that CONST R is closed under negation. Nevertheless, we can show that it is. Proposition 3.3 (Splitting Serial Constraints).
Reference: [23] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Workflow modeling. We have already discussed formalisms used for passive workflow scheduling [26, 27, 3, 19]. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic [14] or process algebras <ref> [23] </ref> can also be used for modeling workflows. However, we believe that our results show that CT R provides a much simpler and uniform way to both describe and reason about workflows. 7 Conclusion We presented a logic-based formalism for specifying, verifying, and executing workflows.
Reference: [24] <author> M.E. Orlowska, J. Rajapakse, and A.H.M. ter Hofstede. </author> <title> Verification problems in conceptual workflow specifications. </title> <booktitle> In Intl. Conference on Conceptual Modelling, volume 1157 of Lecture Notes in Computer Science, </booktitle> <address> Cot-tbus, Germany, 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: That the decision problem is in NP follows from the fact that given an arbitrary sequence of events the satisfiability of a set of constraints and a unique-event control flow graph is decidable in polynomial time. A similar result has been previously obtained in <ref> [24] </ref>. However, their NP-completeness result is based on synchronizer - constraints. Each synchronizer corresponds to a combination of an existence constraint 5 and an order constraint 6 in our formalism.
Reference: [25] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> In Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [26] <author> M.P. Singh. </author> <title> Semantical considerations on workflows: An algebra for intertask dependencies. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September 6-8 </month> <year> 1995. </year>
Reference-contexts: In <ref> [26, 27] </ref>, Singh describes an algebra of temporal constraints, which is believed to cover all useful global dependencies that might arise in workflow systems. For instance, this algebra includes Klein's constraints [22], which commonly occur in workflow specifications 1 . <p> First, control flow graphs with transition conditions can be easily and naturally represented in CT R. Second, [7] shows that triggers are easy to represent as well. Finally, [5] contains an extensive discussion of the temporal capabilities of CT R. In particular, the entire algebra of constraints described in <ref> [26] </ref> is isomorphic to a small subset of the propositional Transaction Logic. Hence CT R provides us with a unifying formalism that subsumes all of the three popular workflow specification frameworks described above. <p> Passive schedulers receive sequences of events from an external source, such as a workflow or a transaction manager, and validate that these sequences satisfy all global constraints (possibly after reordering some events in the sequences). Several such schedulers are described in <ref> [26, 3, 19] </ref>. <p> In contrast, process scheduling using the standard toolkit of process algebras and temporal logic requires automata that are exponential in the size of the original graph. Workflow modeling. We have already discussed formalisms used for passive workflow scheduling <ref> [26, 27, 3, 19] </ref>. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic [14] or process algebras [23] can also be used for modeling workflows.
Reference: [27] <author> M.P. Singh. </author> <title> Synthesizing distributed constrained events from transactional workflow specifications. </title> <booktitle> In Proceedings of 12-th IEEE Intl. Conference on Data Engineering, </booktitle> <pages> pages 616-623, </pages> <address> New Orleans, LA, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: In <ref> [26, 27] </ref>, Singh describes an algebra of temporal constraints, which is believed to cover all useful global dependencies that might arise in workflow systems. For instance, this algebra includes Klein's constraints [22], which commonly occur in workflow specifications 1 . <p> In practical terms, therefore, this means that there is an efficient workflow scheduling strategy and, moreover, this strategy can be determined at "design time" of the workflow (as opposed to run-time scheduling of <ref> [27] </ref>). Elementary updates. We complete our informal introduc tion to CT R by explaining how execution of (some) formulas may actually change the underlying database state. Most of the machinery has already been introduced (albeit very informally). What is missing is the notion of elementary updates. <p> Transaction Logic can express a wide variety of temporal constraints [5], but here we focus on a relatively simple algebra of constraints, which we denote by CONST R. CONST R is as expressive as Singh's Event Algebra <ref> [27] </ref>. Using these constraints we can specify that one task must start before some other task, that the execution of one task causes some other task to be executed or not executed, etc. <p> In contrast, the event scheduler of <ref> [27] </ref> has quadratic complexity. <p> In contrast, the event scheduler of [27] has quadratic complexity. Thus, while expanding the effort on consistency checking (which needs to be done anyway), we compile the original specifications into a form that lets us find allowable schedules much more efficiently than with the passive approaches of <ref> [27, 3, 19] </ref> (It should be noted that, these latter algorithms do not do consistency checks). 5 Compiling Constraints into the Control Flow Graph We define the process of compiling the constraints in CONST R into unique-event goals by starting with simple events and extending the transformation to more complex ones. <p> In contrast, process scheduling using the standard toolkit of process algebras and temporal logic requires automata that are exponential in the size of the original graph. Workflow modeling. We have already discussed formalisms used for passive workflow scheduling <ref> [26, 27, 3, 19] </ref>. In addition, general purpose process specification formalisms such as Petri-nets, state charts [29], temporal logic [14] or process algebras [23] can also be used for modeling workflows.
Reference: [28] <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <booktitle> In [13], chapter 7, </booktitle> <pages> pages 220-263. </pages> <year> 1992. </year>
Reference-contexts: The Workflow Management Coalition [10] identifies additional controls, such as loops and sub-workflows. Various researchers have also suggested other types of controls, including alternative execution and compensation for failed activities <ref> [12, 17, 15, 25, 28, 1, 13] </ref>. However, control flow graphs have one obvious limitation: they cannot be used to specify global dependencies between workflow tasks, such as those expressed as global constraints on the right-hand side of Figure 1. Defining workflows using triggers is yet another possibility [11].
Reference: [29] <author> Dirk Wodtke and Gerhard Weikum. </author> <title> A formal foundation for distributed workflow execution based on state charts. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 230-246, </pages> <year> 1997. </year>
Reference-contexts: Workflow modeling. We have already discussed formalisms used for passive workflow scheduling [26, 27, 3, 19]. In addition, general purpose process specification formalisms such as Petri-nets, state charts <ref> [29] </ref>, temporal logic [14] or process algebras [23] can also be used for modeling workflows.
References-found: 29

