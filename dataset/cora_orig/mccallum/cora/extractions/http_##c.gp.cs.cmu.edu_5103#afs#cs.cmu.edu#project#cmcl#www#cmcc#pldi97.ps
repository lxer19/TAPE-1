URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/cmcl/www/cmcc/pldi97.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/cmcl/www/cmcc/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Call-Cost Directed Register Allocation  
Author: Guei-Yuan Lueh and Thomas Gross 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Choosing the right kind of register for a live range plays a major role in eliminating the register-allocation overhead when the compiled function is frequently executed or function calls are on the most frequently executed paths. Picking the wrong kind of register for a live range incurs a high penalty that may dominate the total overhead of register allocation. In this paper, we present three improvements, storage-class analysis, benefit-driven simplification, and preference decision that are effective in selecting the right kind of register for a live range. Then we compare an enhanced Chaitin-style register allocator (with these three improvements) with priority-based and optimistic coloring. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai, T. Gross, and G. Y. Lueh. </author> <title> Code reuse in an optimizing compiler. </title> <booktitle> In Proc. SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 51-68. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: In this paper, we discuss how to deal with this aspect and also provide an empirical evaluation (including an evaluation of optimistic and priority-based coloring). All performance data have been gathered with the cmcc optimizing C compiler <ref> [1] </ref>. In Section 2, we briefly review the register allocation framework of this compiler, to lay the foundation for a comparison of various coloring approaches. Then we introduce three improvements (Sections 4 - 6). Section 8 contrasts the effect of these improvements with optimistic coloring. <p> That is, if an improvement is added to some parts of register allocation (e.g., the construction of the interference graph) then all register allocators can benefit from the improvement. We briefly summarize our framework for register allocation <ref> [1] </ref>; there are these phases: graph construction, live-range coalescing, color ordering, color assignment, graph re construction 1 , spill-code insertion, and shu*e-code insertion (as illustrated by Figure 1). This register-allocation structure allows us to model a wide range of register allocation approaches.
Reference: [2] <author> D. Bernstein, D. Q. Goldin, M. C. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proc. ACM SIGPLAN '89 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 258-263. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics <ref> [17, 2, 5] </ref> or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12].
Reference: [3] <author> P. Briggs. </author> <type> Personal communication, </type> <year> 1996. </year>
Reference-contexts: This model extends Chaitin-style coloring to explicitly model the calling convention. According to Briggs <ref> [3] </ref>, this model also extends hierarchical coloring (as described for the Tera compiler [6]). Based on the main components, we name this cost model "CBH" (for Chaitin/Briggs-Hierarchical coloring). Although the CBH cost model has been adopted by prior researchers, there is no published report of the model's effectiveness.
Reference: [4] <author> P. Briggs, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proc. ACM SIG-PLAN'89 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 275-284. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: It assigns colors to the live ranges in the reverse order in which the live ranges were removed during simplification. Chaitin's algorithm provides a conceptually simple way to pack live ranges into registers; it forms the basis of many practical register allocators. However, this algorithm (or optimistic coloring <ref> [4] </ref>) does not address how to deal with an important aspect of compilation, the calling convention. In this paper, we discuss how to deal with this aspect and also provide an empirical evaluation (including an evaluation of optimistic and priority-based coloring). <p> Table 1 shows how the register allocation framework can model various register-allocation approaches. Chaitin-style [7], priority-based [8] 2 and optimistic coloring <ref> [4] </ref> construct the interference graph for a function. Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. <p> For the ear and eqntott programs, improved Chaitin-style coloring reduces the register overhead by a factor of 45 and 66 (i.e, with the base register allocator, there are 45 (66) times as many overhead operations as required by the improved Chaitin-style coloring). 8 Optimistic versus non-optimistic Optimistic coloring <ref> [4] </ref> delays spilling decisions for live ranges until the live ranges actually fail to find legal colors. Optimistic coloring aggressively tries to find colors for those otherwise spilled live ranges.
Reference: [5] <author> P. Briggs, K. D. Cooper, and L. Torczon. </author> <title> Rematerialization. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 311-321. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics <ref> [17, 2, 5] </ref> or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12].
Reference: [6] <author> D. Callahan and B. Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proc. ACM SIGPLAN'91 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. <p> This model extends Chaitin-style coloring to explicitly model the calling convention. According to Briggs [3], this model also extends hierarchical coloring (as described for the Tera compiler <ref> [6] </ref>). Based on the main components, we name this cost model "CBH" (for Chaitin/Briggs-Hierarchical coloring). Although the CBH cost model has been adopted by prior researchers, there is no published report of the model's effectiveness. The comparison of this section serves three purposes.
Reference: [7] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <month> January </month> <year> 1981. </year> <note> alvinn ear gcc li matrix300 nasa7 </note>
Reference-contexts: Simplification is based on the observation that if a vertex V has degree &lt; N , then the color-assignment phase guarantees to find a color for V , because at least one legal color remains regardless what colors are assigned to V 's neighbors <ref> [7] </ref>. This process of removing Effort sponsored by the Advanced Research Projects Agency and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-96-1-0287. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. <p> S keeps spilled live ranges. If the color-ordering phase decides to spill live ranges, or the color-assignment phase fails to find legal colors for live ranges, those spilled live ranges are added to S. Table 1 shows how the register allocation framework can model various register-allocation approaches. Chaitin-style <ref> [7] </ref>, priority-based [8] 2 and optimistic coloring [4] construct the interference graph for a function. Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function.
Reference: [8] <author> F. C. Chow and J. L. Hennessy. </author> <title> A priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Prog. Lang. Syst., </journal> <volume> 12 </volume> <pages> 501-535, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: If the color-ordering phase decides to spill live ranges, or the color-assignment phase fails to find legal colors for live ranges, those spilled live ranges are added to S. Table 1 shows how the register allocation framework can model various register-allocation approaches. Chaitin-style [7], priority-based <ref> [8] </ref> 2 and optimistic coloring [4] construct the interference graph for a function. Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. <p> Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. <p> Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally <ref> [8, 9, 18] </ref> or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. <p> They are similar to the priority function of <ref> [8] </ref>, except the benefits are not normalized by the size of the live ranges. During the color-assignment phase, the selection of the kind of register to use is based on these two functions. <p> Now we can view C as a priority-based color stack; the higher position a live range on C, the more likely the live range has more freedom with regard to picking registers. Hence register allocation based on this color stack is now similar to priority-based coloring <ref> [8] </ref>. In other words, benefit-driven simplification unifies the priority-based approach with simplification-based register allocation, and we revisit this aspect in Section 9. benef it caller and benef it callee form the foundation of our experiments to investigate different strategies to order unconstrained live ranges during simplification. <p> As the number of registers increases, optimistic coloring has less influence and improved Chaitin-style coloring picks up, so we see the enhancement due to improved Chaitin-style coloring. 9 Priority-based versus Chaitin-style The use of a benefit function to sort live ranges invites a comparison with priority-based coloring <ref> [8] </ref>. At first sight, Chaitin-style coloring and priority-based coloring appear to have little in common. Priority-based coloring assigns registers to live ranges based on a priority function and splits a live range lr when no legal register exists for lr. <p> Based on the two conditions, we use max (benefit caller (lr);benefit callee (lr)) size (lr) as the priority function for priority-based coloring. size (lr) is the number of basic blocks that lr contains. This priority function is the same as the one used in <ref> [8] </ref>. The spilling heuristic of Chaitin-style coloring and optimistic coloring is spill cost (lr) degree (lr) . The heuris tic tends to spill live ranges that have low spill cost and high degree. The priority function and the spilling heuristic are alike. <p> The remaining live ranges are pushed onto C from the least priority to the highest priority. Chow uses the same approach <ref> [8] </ref>. * sorting unconstrained: Unconstrained live ranges are not pushed onto C in a priority fashion if we simply remove unconstrained live ranges. That is, the kind of register that a higher-priority live range wants is possibly taken away by lower-priority live ranges. <p> Once alvinn nasa7 fpppp gcc doduc espresso a callee-save register is spilled, the callee-save register can then be assigned to live ranges. This is similar to the way Chow handles callee-save registers <ref> [8] </ref>. That is, the first live range that uses a callee-save register pays the callee-save cost. We compare CBH with improved Chaitin-style coloring. To allow an easy comparison of the new figures with Figure 6, we use the same base line.
Reference: [9] <author> F.C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 85-94. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally <ref> [8, 9, 18] </ref> or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. <p> Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally <ref> [21, 9, 20, 19] </ref>; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. This step improves compilation time. 2 The priority-based coloring that we implement is Chow's priority-based coloring without live range splitting.
Reference: [10] <author> R. Cohn and P.G. Lowney. </author> <title> Hot cold optimization of large Windows/NT applications. </title> <booktitle> In Proc. Micro 29. ACM, </booktitle> <year> 1996. </year>
Reference-contexts: Second, giving the register allocator more registers may actually worsen the register allocation cost because some live ranges may now reside in the registers whose call overheads introduce more memory accesses than the spill cost of the live ranges. Cohn and Lowney <ref> [10] </ref> measured the dynamic call cost for various Windows/NT applications and SPEC programs. For more than half of the programs, the call cost is 10% - 25% of their execution time. <p> For more than half of the programs, the call cost is 10% - 25% of their execution time. If the register allocation does not take the call cost into consideration, the call overhead introduced by the register allocation may end up on the hot part of the program <ref> [10] </ref>. 4 Storage-class analysis A live range can reside in one of these storage classes (assuming that registers are divided into caller-save and callee-save registers): * memory, * a caller-save register, or * a callee-save register. Each storage class has an associated cost.
Reference: [11] <author> S. Freudenberger and J. Ruttenberg. </author> <title> Phase ordering of register allocation and instruction scheduling. </title> <editor> In R. Giegerich and S. L. Graham, editors, </editor> <title> Code Generation Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 146-170. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [12] <author> S. M. Kurlander and C. N. Fischer. </author> <title> Zero-cost range splitting. </title> <booktitle> In Proc. ACM SIGPLAN '94 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 257-265. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [13] <author> G. Lueh, T. Gross, and A. Adl-Tabatabai. </author> <title> Global register allocation based on graph fusion. </title> <booktitle> In Proc. '96 Workshop on Languages and Compilers for Parallel Computing, page to appear, </booktitle> <address> San Jose, CA, Aug 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Table 1 shows how the register allocation framework can model various register-allocation approaches. Chaitin-style [7], priority-based [8] 2 and optimistic coloring [4] construct the interference graph for a function. Fusion-style coloring <ref> [13] </ref> identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. <p> This step improves compilation time. 2 The priority-based coloring that we implement is Chow's priority-based coloring without live range splitting. The influence of live range splitting on register overhead operations is beyond the scope of this paper; see <ref> [13] </ref> for details. Register allocation Phases Chaitin style Priority based Optimistic Fusion style Graph construction function function function region (spill+split) Graph reconstruction X X X X Coalescing X X X X Color ordering simp. (spill) priority simp. simp.
Reference: [14] <author> G. Y. Lueh. </author> <title> Fusion-Based Register Allocation. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1997. </year>
Reference-contexts: The bigger this number, the less overhead is there in the improved version. SC, BS and PR stand for Storage-Class analysis, Benefit-driven Simplification and PReference, respectively. We can classify the SPEC92 programs (compiled using profile information) into 4 classes. (See <ref> [14] </ref> for the data for the programs that are not shown here. Also, the issue of dynamic versus static information is discussed there as well.) * Each optimization contributes a significant fraction of improvement. Examples are nasa7 and ear (shown in Figure 6). <p> Hence, we choose the sorting approach as the priority function for priority-based register allocation. When we compare improved Chaitin-style coloring with priority-based coloring, we can classify the SPEC92 programs based on the results into 3 classes. See <ref> [14] </ref> for the data of the programs that are not shown here and a detailed comparison of the three heuristics. * Both priority-based and improved Chaitin-style coloring are doing equally well. Examples are alvinn, eqntott, gcc, and li.
Reference: [15] <author> W.G. Morris. Ccg: </author> <title> A prototype coagulating code generator. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 45-58. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [16] <author> C. Norris and L. L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proc. ACM SIGPLAN '94 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 266-277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [17] <author> T. A. Proebsting and C. N. Fischer. </author> <title> Probablistic register allocation. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 300-310. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics <ref> [17, 2, 5] </ref> or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. <p> Fusion-style coloring [13] identifies regions, constructs the interference graph for each region, and then fuses graphs together to get the interference graph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost <ref> [8, 6, 17, 16, 11, 15, 12] </ref>. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [18] <author> O. Waddell R.G. Burger and R.K. Dybvig. </author> <title> Register allocation using lazy saves, eager restores, and greedy shu*ing. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 130-138. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally <ref> [8, 9, 18] </ref> or inter-procedurally [21, 9, 20, 19]; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch.
Reference: [19] <author> V. Santhanam and D. Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 28-39. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally <ref> [21, 9, 20, 19] </ref>; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. This step improves compilation time. 2 The priority-based coloring that we implement is Chow's priority-based coloring without live range splitting.
Reference: [20] <author> P.A. Steenkiste and J.L. Hennessy. </author> <title> A simple interproce-dural register allocation algorithm and its effectiveness for lisp. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 1-32, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally <ref> [21, 9, 20, 19] </ref>; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. This step improves compilation time. 2 The priority-based coloring that we implement is Chow's priority-based coloring without live range splitting.
Reference: [21] <author> D. W. Wall. </author> <title> Global register allocation at link time. </title> <booktitle> In Proc. ACM SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <address> Palo Alto, </address> <month> June </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: Several strategies have been proposed to improve spilling heuristics [17, 2, 5] or to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 12]. Other approaches have also attempted to reduce call cost intra-procedurally [8, 9, 18] or inter-procedurally <ref> [21, 9, 20, 19] </ref>; however these approaches are complimentary to the work presented here. 1 Graph reconstruction modifies the existing interference graph instead of rebuilding it from scratch. This step improves compilation time. 2 The priority-based coloring that we implement is Chow's priority-based coloring without live range splitting.
References-found: 21

