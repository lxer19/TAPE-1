URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-003.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: rsj,su@cis.ufl.edu  
Title: A Graph-based Transaction Model for Active Databases and its Parallel Implementation  
Author: Ramamohanrao Jawadi Stanley Y.W. Su 
Address: Gainesville, FL 32611  
Affiliation: Database Systems Research and Development Center Department of Computer and Information Sciences University of Florida,  
Abstract: Databases coupled with active rules, which are known as active databases are becoming increasingly popular because of their added features that for supporting a wide spectrum of applications. The need for user-defined control over the rule execution order, particularly in parallel rule execution models, is well recognized in both AI and DB rule systems. In database rule systems, ideally, the rule execution should be uniformly integrated with the transaction execution framework. In active databases, little attention has been given to the provision of expressive control constructs for rule execution and their uniform integration with the transaction model. In this paper, we provide several control constructs which can be used to control the parallel execution of rules. These constructs are translated to a directed acyclic graph representing the control flow among the rules. To merge the graph-based rules with the database transactions uniformly, we introduce a graph-based transaction model that can naturally model complex structures among database operations and rules. While we follow the standard serializability as a correctness criterion for the concurrent execution of transactions, a new correctness criterion which involves the control flow among the rules, is introduced for concurrent execution of rules within a transaction. Two different con-currency control methods are presented for concurrent and correct execution of rules with user-defined control structures. In addition, we discuss the design and implementation of a parallel active database server which supports the proposed rule control and graph-based transaction model. The server has been implemented and tested on a shared-nothing multiprocessor architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rakesh Agrawal, Roberta Cochrane, and Bruce Lindsay. </author> <title> On maintaining priorities in a production rule system. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager [27]. Regarding the first problem, several active systems including POSTGRES [47], Ariel [23] and Starburst <ref> [50, 1] </ref> provide user-defined priorities to control the execution order. However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. <p> Ceri [6] proposes several locking protocols for parallel and distributed execution of rules maintaining the user-defined priorities for Starburst. Since in Starburst priority system, a total order is established among the rules using a combination of user-defined and default priorities <ref> [1] </ref>, making the system deterministic at the same time reducing the scope for potential inter-rule parallelism. Our approach gives the user control over the rule execution order in one hand and exploits the parallelism among independent rules in the other hand.
Reference: [2] <author> Paul Attie, Munindar Singh, Marek Rusinkiewicz, and Amit Sheth. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Proc. 19th Int'l Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [3] <author> C. Beeri and Tivo Milo. </author> <title> A model for active object oriented database. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation). HiPAC [27], Beeri <ref> [3] </ref>, Raschid [38] and Starburst [6] are some of the works that use nested transactions to support the concurrent execution of rules. Starburst supports only trigger time after and all the triggered rules are executed at the end of the top-level transaction as subtransactions.
Reference: [4] <author> A. Buchmann, M. Tamer Ozsu, et al. </author> <title> Database Transaction Models for advanced applications, chapter A transaction model for active distributed object systems, </title> <address> pages 123-158. </address> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [5] <author> Michael J. Carey, Rajiv Jauhari, and Miron Livny. </author> <title> On transaction boundaries in active databases: A performance perspective. </title> <journal> IEEE Trans. Knowledge Data Eng., </journal> <volume> 3(3), </volume> <month> September </month> <year> 1991. </year>
Reference: [6] <author> S. Ceri and J. Widom. </author> <title> Production rules in parallel and distributed database environments. </title> <booktitle> In Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, </address> <year> 1992. </year>
Reference-contexts: Note that we are modeling only the trigger times but not the triggering operations. Therefore our approach can model rules with powerful events also. Furthermore, it is general enough to have rules executed at arbitrary points 3 of a transaction's life time as it is suggested in <ref> [6] </ref>. A TG can capture the control flow among all the tasks that constitute a transaction. <p> HiPAC [8] integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model [34, 27]. Other works that support parallel execution of rules in database environments include <ref> [6, 39] </ref>. In [39], Raschid defines a correctness criterion for concurrent execution of rules in database environments. The semantic relationships of the rules are analyzed for establishing an execution order among interfering rules and also it is made sure that the condition remains true when the action is executed. <p> The main disadvantage with the above systems is lack of user--defined control over rule execution. Ceri <ref> [6] </ref> proposes several locking protocols for parallel and distributed execution of rules maintaining the user-defined priorities for Starburst. <p> The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation). HiPAC [27], Beeri [3], Raschid [38] and Starburst <ref> [6] </ref> are some of the works that use nested transactions to support the concurrent execution of rules. Starburst supports only trigger time after and all the triggered rules are executed at the end of the top-level transaction as subtransactions. However, in [6] it is mentioned that their approach is extensible to <p> HiPAC [27], Beeri [3], Raschid [38] and Starburst <ref> [6] </ref> are some of the works that use nested transactions to support the concurrent execution of rules. Starburst supports only trigger time after and all the triggered rules are executed at the end of the top-level transaction as subtransactions. However, in [6] it is mentioned that their approach is extensible to make any point of transaction life-time as trigger time. HiPAC and Beeri provide variety of trigger times for rules which include immediate, deferred and detached 8 .
Reference: [7] <author> S. Chakravarthy and D. Mishra. </author> <title> An event specification language (snoop) for active databases and its detection. </title> <type> Technical Report UF-CIS TR-91-23, </type> <institution> Database Systems R&D Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Some research is <ref> [7, 19] </ref> focused on developing powerful event specification languages in which a variety of trigger operations can be defined. Note that we are modeling only the trigger times but not the triggering operations. Therefore our approach can model rules with powerful events also.
Reference: [8] <author> Sharma Chakravarthy et al. Hipac: </author> <title> A research project in active, time-constrained database management. </title> <type> Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. On the other hand, HiPAC <ref> [8] </ref> and Raschid's work [39] support parallel firing of rules but do not provide any control over the rule execution order. <p> If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems [47, 23] would linearly expand itself to include the triggered rules [51] as shown in Figure 2. In the nested transaction model (NTM) <ref> [34, 8, 38] </ref>, the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. The reason is, in the NTM, a transaction is viewed as a composition of an independent set of subtransactions. <p> Also the above works are in the context of AI and do not discuss the integration of the parallel rule execution model with that of transactions which is essential for database rule systems. HiPAC <ref> [8] </ref> integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model [34, 27]. Other works that support parallel execution of rules in database environments include [6, 39].
Reference: [9] <author> Prashant V. Cherukuri. </author> <title> A Task Manager for Parallel Rule Execution in Multi-processor Environments. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1993. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) <ref> [20, 33, 9] </ref>. <p> A detailed discussion on the recovery techniques is out of the scope of this paper. 4 Implementation on a Shared-nothing Architecture The proposed transaction model has been implemented as part of the OSAM*.KBMS/P <ref> [20, 9, 33] </ref> project which is being carried out at the Database Systems R&D Center, University of Florida. A DB server has been implemented on nCUBE2 a high-performance parallel computer with shared-nothing architecture. The architecture of the system is shown in Figure 8 where C1,C2,...Cn are clients.
Reference: [10] <author> Panos K. Chrysanthis and Krithi Ramamritham. </author> <title> Database Transaction Models for advanced applications, </title> <booktitle> chapter ACTA: The SAGA Continues, </booktitle> <pages> pages 349-398. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year> <month> 24 </month>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [11] <author> Thomas H. Cormen, Chales E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algo--rithms. </title> <publisher> McGraw Hill Book Company, </publisher> <year> 1990. </year>
Reference-contexts: For example, for the TG shown in Figure 4.a, any of the orders t1!t2!t3!t4!t5 or t1!t3!t2!t4!t5 is correct. To be more general, the parallel execution of the tasks of a TG is correct when it is equivalent to some topological order <ref> [11] </ref> of the tasks. Since the above correctness criterion requires a topological serial order rather than an arbitrary serial order, we shall call it topological serializability. Although the topological serializability prevents the tasks to execute in a complete parallel fashion, there is a scope for intra-transaction parallelism.
Reference: [12] <author> C.T. Davies. </author> <title> Recovery semantics of a db/dc system. </title> <booktitle> In Proc. of ACM national conference, </booktitle> <year> 1973. </year>
Reference-contexts: A transaction graph (TG) consists of a set of tasks in a DAG form as shown in Figure 4.a. In this figure, boxes represent the spheres of control <ref> [12] </ref> and the directed edges represent the control flow. This can be shown in a tree form as depicted in Figure 4.b where thick lines represent "contains" relationship similar to an NTM tree and dashed lines represent the control flow among the subtransactions.
Reference: [13] <author> U. Dayal, B. Blaustein, A. Buchmann, S. Chakravarthy, et al. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: An event is a combination of two components namely trigger time and trigger operation. The trigger time specifies when the triggered rule should be executed 2 They are referred to as coupling modes in some literature <ref> [13] </ref> 6 relative to a trigger operation.
Reference: [14] <author> Oscar Diaz, Norman Paton, and Peter Gray. </author> <title> Rule management in object oriented databases: A uniform approach. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference: [15] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in Database Systems. </title> <journal> Communications of the ACM 19, </journal> <volume> 10(11), </volume> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: The second scheme exploits maximum parallelism if the tasks are operating on disjoint sets of data. 3.1 Correctness Criterion In our model, at the transaction-level, the correctness criterion for parallel execution of several TGs is the standard serializability <ref> [15] </ref> which states that the interleaved (concurrent) execution of several TGs is correct when it is equivalent to an execution in some serial order. Within the transaction, the control flow among the tasks plays a role in defining the 9 correctness.
Reference: [16] <author> Opher Etzion. </author> <title> Pardes-a data-driven oriented active database model. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 22(1) </volume> <pages> 7-14, </pages> <year> 1993. </year>
Reference: [17] <author> Charles L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> July </month> <year> 1981. </year>
Reference-contexts: The rule execution models of POSTGRES [47], Ariel [23], Starburst [50], RDL1 [44], OPS5 <ref> [17] </ref> support explicit control over the rule execution 7 , however, in these systems, only one rule is fired at a time which is not ideal in a parallel environment. To avoid this problem, several parallel rule execution models have been proposed [27, 41, 40, 28, 45, 30, 31].
Reference: [18] <author> N. H. Gehani and H. V. Jagadish. </author> <title> Ode as an Active Database: Constraints and Triggers. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 327-336, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> Sep. </month> <year> 1991. </year>
Reference: [19] <author> N. H. Gehani, H. V. Jagadish, and O. Shmueli. </author> <title> Event Specification in an Object-Oriented Database. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <pages> pages 81-90, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Some research is <ref> [7, 19] </ref> focused on developing powerful event specification languages in which a variety of trigger operations can be defined. Note that we are modeling only the trigger times but not the triggering operations. Therefore our approach can model rules with powerful events also.
Reference: [20] <author> Arun Gopalan. </author> <title> Transaction Management and Recovery in a Disributed Object-Oriented Database System. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1992. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) <ref> [20, 33, 9] </ref>. <p> A detailed discussion on the recovery techniques is out of the scope of this paper. 4 Implementation on a Shared-nothing Architecture The proposed transaction model has been implemented as part of the OSAM*.KBMS/P <ref> [20, 9, 33] </ref> project which is being carried out at the Database Systems R&D Center, University of Florida. A DB server has been implemented on nCUBE2 a high-performance parallel computer with shared-nothing architecture. The architecture of the system is shown in Figure 8 where C1,C2,...Cn are clients.
Reference: [21] <author> T. Haerder and A. Reuter. </author> <title> Principles of transaction oriented database recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4) </volume> <pages> 287-318, </pages> <month> Dec </month> <year> 1983. </year>
Reference-contexts: Our work is different from the advanced transaction models presented in [4, 49, 42, 25, 10, 2] due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties <ref> [21] </ref> which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes for the parallel and interleaved execution of several graph-based transactions and rules based on the semantics of the proposed control structure,
Reference: [22] <author> T. Haerder and K. Rothermal. </author> <title> Concepts for transaction recovery in nested transactions. </title> <booktitle> Proceedings of SIGMOD, </booktitle> <volume> 12(2), </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: All the successor tasks are also aborted and the locks are released. The theorem that proves the correctness of the above locking scheme is given in Theorem 3 of the Appendix. The recovery of the graph-based transactions can be done using the standard recovery methods used for NTM <ref> [35, 22] </ref>. The only difference is that, when a set of tasks are being undone, they need to follow the reverse of the topological order. <p> Several other transaction models including [10, 49, 42, 4, 25, 2] have advanced control structure for transactions. However our transaction model is different in that it maintains the traditional ACID properties <ref> [22] </ref>, incorporates the control semantics of active rules and their trigger times, and it is designed for and implemented on a shared-nothing parallel architecture. 6 Conclusions A transaction model with a more general control structure represented by a DAG has been introduced to capture the control semantics of active database transactions.
Reference: [23] <author> Eric N. Hanson. </author> <title> An initial report on the design of Ariel: a DBMS with an integrated production rule system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager [27]. Regarding the first problem, several active systems including POSTGRES [47], Ariel <ref> [23] </ref> and Starburst [50, 1] provide user-defined priorities to control the execution order. However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. <p> If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems <ref> [47, 23] </ref> would linearly expand itself to include the triggered rules [51] as shown in Figure 2. In the nested transaction model (NTM) [34, 8, 38], the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. <p> The rule execution models of POSTGRES [47], Ariel <ref> [23] </ref>, Starburst [50], RDL1 [44], OPS5 [17] support explicit control over the rule execution 7 , however, in these systems, only one rule is fired at a time which is not ideal in a parallel environment. <p> While we discuss the strategies for executing multiple rules in parallel, in [26], it is discussed how a rule can be further decomposed into sub-rules and can be executed concurrently. 5.2 Transaction Model and Trigger Times POSTGRES [47], Ariel <ref> [23] </ref> use flat transaction model in which the triggered actions are incorporated by linear expansion of the transaction [51]. The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation).
Reference: [24] <author> Eric N. Hanson and Jennifer Widom. </author> <title> Advances in Databases and Artificial Intelligence, chapter Rule Processing in Active Database Systems. </title> <publisher> JAI Press, </publisher> <year> 1992. </year>
Reference: [25] <author> Sandra Heiler, Sara Haradhvala, Stanley Zdonik, Barbara Blaustein, and Arnon Rosen-thal. </author> <title> Database Transaction Models for advanced applications, chapter A flexible framework for transaction management in engineering environments, </title> <address> pages 87-122. </address> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [26] <author> Ing-Miin Hsu, Mukesh Singhal, and Ming T. Liu. </author> <title> Distributed rule processing in active databases. </title> <booktitle> In Data Engineering, </booktitle> <year> 1992. </year> <month> 25 </month>
Reference-contexts: In addition, the rule serializability is maintained automatically using the DB locking scheme. While we discuss the strategies for executing multiple rules in parallel, in <ref> [26] </ref>, it is discussed how a rule can be further decomposed into sub-rules and can be executed concurrently. 5.2 Transaction Model and Trigger Times POSTGRES [47], Ariel [23] use flat transaction model in which the triggered actions are incorporated by linear expansion of the transaction [51].
Reference: [27] <author> M. Hsu, R. Ladin, and D. McCarthy. </author> <title> An execution model for active database man-agement systems. </title> <booktitle> In Proceedings of the 3rd International Conference on Data and Knowledge Bases, </booktitle> <pages> pages 171-179, </pages> <year> 1988. </year>
Reference-contexts: In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager <ref> [27] </ref>. Regarding the first problem, several active systems including POSTGRES [47], Ariel [23] and Starburst [50, 1] provide user-defined priorities to control the execution order. <p> In active databases, rules and transactions are closely related in the sense that rules are treated as a part of the triggering transactions in most of the situations or they act as separate transactions <ref> [27] </ref>. The transaction control structure of an active system can be much more complex than a linear or hierarchical control structure because of the nested triggering of rules and the control relationship among rules can be expressed by a network structure. <p> In case of after as the trigger time, in addition to the control structure, the triggering order of the after rules 5 is also captured. Although HiPAC does not capture the triggering order, the importance of such order is mentioned in <ref> [27] </ref>. In the above example, if the trigger time is after, the rule graph is coupled to the triggering transaction as shown in Figure 7.b. The triggered rules are treated as subtransactions of the top-level transaction and they are attached just before the commit node. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. <p> HiPAC [8] integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model <ref> [34, 27] </ref>. Other works that support parallel execution of rules in database environments include [6, 39]. In [39], Raschid defines a correctness criterion for concurrent execution of rules in database environments. <p> The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation). HiPAC <ref> [27] </ref>, Beeri [3], Raschid [38] and Starburst [6] are some of the works that use nested transactions to support the concurrent execution of rules. Starburst supports only trigger time after and all the triggered rules are executed at the end of the top-level transaction as subtransactions.
Reference: [28] <author> T. Ishida. </author> <title> Parallel rule firing in production systems. </title> <journal> IEEE Trans. Knowledge Data Eng., </journal> <volume> 3(1), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors [30]. Several AI researchers have worked on the execution semantics of such parallel firing systems <ref> [41, 45, 28, 30] </ref>. Two important problems have been identified in such systems [40]: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. <p> In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. On the other hand, in <ref> [40, 28] </ref>, serializable execution of rules is guaranteed (by the static analysis of the rules) but user-defined control over rules is not supported.
Reference: [29] <author> G. Kiernan, C. deMaindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference: [30] <author> Steve Kuo and Dan Moldovan. </author> <title> Implementation of multiple rule firing production systems on hypercube. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 383-394, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors <ref> [30] </ref>. Several AI researchers have worked on the execution semantics of such parallel firing systems [41, 45, 28, 30]. Two important problems have been identified in such systems [40]: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. <p> In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors [30]. Several AI researchers have worked on the execution semantics of such parallel firing systems <ref> [41, 45, 28, 30] </ref>. Two important problems have been identified in such systems [40]: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. <p> To avoid this problem, several parallel rule execution models have been proposed [27, 41, 40, 28, 45, 30, 31]. In <ref> [30, 45] </ref>, several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs.
Reference: [31] <author> Steve Kuo, Dan Moldovan, and Seungho Cha. </author> <title> Control in Production Systems with Multiple Rule Firings. </title> <type> Technical Report PKPL 90-10, </type> <institution> Parallel Knowledge Processing Lab., U. of Southern California, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs.
Reference: [32] <author> H. Lam, S.Y.W. Su, et al. GTOOLS: </author> <title> An Active Graphical User Interface Toolset for an Object-oriented KBMS. </title> <journal> International Journal of Computer Science and Engineering, </journal> <year> 1991. </year>
Reference-contexts: All the clients which are SUN workstations, are connected to the server by an inter-connection network. A client contains window-based graphical user interfaces which have advanced features to edit TGs, rule graphs, queries and database schema containing classes and associations <ref> [32] </ref>. The server processes the transactions asynchronously and queues are used to hold the messages which can be transactions, tasks or acknowledgments, that are received at each node. The underlying data model for this parallel system is OSAM*/P an extension of the object-oriented data model OSAM* [48].
Reference: [33] <author> Qiang Li. </author> <title> Design and Implementation of a Parallel Object-Oriented Query Processor for OSAM*.KBMS/P. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1993. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) <ref> [20, 33, 9] </ref>. <p> A detailed discussion on the recovery techniques is out of the scope of this paper. 4 Implementation on a Shared-nothing Architecture The proposed transaction model has been implemented as part of the OSAM*.KBMS/P <ref> [20, 9, 33] </ref> project which is being carried out at the Database Systems R&D Center, University of Florida. A DB server has been implemented on nCUBE2 a high-performance parallel computer with shared-nothing architecture. The architecture of the system is shown in Figure 8 where C1,C2,...Cn are clients.
Reference: [34] <author> Elliot Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1985. </year>
Reference-contexts: If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems [47, 23] would linearly expand itself to include the triggered rules [51] as shown in Figure 2. In the nested transaction model (NTM) <ref> [34, 8, 38] </ref>, the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. The reason is, in the NTM, a transaction is viewed as a composition of an independent set of subtransactions. <p> HiPAC [8] integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model <ref> [34, 27] </ref>. Other works that support parallel execution of rules in database environments include [6, 39]. In [39], Raschid defines a correctness criterion for concurrent execution of rules in database environments.
Reference: [35] <author> Elliot Moss. </author> <title> Log-based recovery for nested transactions. </title> <booktitle> In Proc. 13th Int'l Conf. on Very Large Data Bases, </booktitle> <year> 1987. </year>
Reference-contexts: All the successor tasks are also aborted and the locks are released. The theorem that proves the correctness of the above locking scheme is given in Theorem 3 of the Appendix. The recovery of the graph-based transactions can be done using the standard recovery methods used for NTM <ref> [35, 22] </ref>. The only difference is that, when a set of tasks are being undone, they need to follow the reverse of the topological order.
Reference: [36] <author> J. Moss. </author> <title> Nested Transactions: An Approach To Reliable Distributed Computing. </title> <institution> MIT Laboratory for Computer Science, MIT/LCS/TR-260, </institution> <year> 1981. </year>
Reference-contexts: This approach identifies the control flow violations by characterizing the task relationships. Two 6 The first version of these rules appeared in <ref> [36] </ref> 13 tasks t1, t2 in a control graph are related in one of the following ways: i) t1 is a successor of t2, ii) t1 is a predecessor of t2, iii) t1 and t2 are independent of each other.
Reference: [37] <author> L. Raschid and S.Y.W. Su. </author> <title> A transaction oriented mechanism to control processing in a knowledge base management system. </title> <booktitle> In Proc. of the 2nd Intl Conf on Expert Database Systems, </booktitle> <year> 1988. </year>
Reference: [38] <author> Louiqa Raschid, Timos Sellis, and Alexis Delis. </author> <title> On the concurrent execution of production rules in a database implementation. </title> <type> Technical Report UMIACS-TR-91-125, </type> <institution> University of Maryland, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems [47, 23] would linearly expand itself to include the triggered rules [51] as shown in Figure 2. In the nested transaction model (NTM) <ref> [34, 8, 38] </ref>, the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. The reason is, in the NTM, a transaction is viewed as a composition of an independent set of subtransactions. <p> The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation). HiPAC [27], Beeri [3], Raschid <ref> [38] </ref> and Starburst [6] are some of the works that use nested transactions to support the concurrent execution of rules. Starburst supports only trigger time after and all the triggered rules are executed at the end of the top-level transaction as subtransactions.
Reference: [39] <author> Louiqa Raschid, Timos Sellis, and Alexis Delis. </author> <title> A simulation-based study on the concurrent execution of rules in a database environment. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 20(1), </volume> <month> Jan </month> <year> 1994. </year>
Reference-contexts: However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. On the other hand, HiPAC [8] and Raschid's work <ref> [39] </ref> support parallel firing of rules but do not provide any control over the rule execution order. For parallel active databases, there is a need for a parallel rule system that s supports the parallel firing of rules as well as provides the user-control over rule execution. <p> HiPAC [8] integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model [34, 27]. Other works that support parallel execution of rules in database environments include <ref> [6, 39] </ref>. In [39], Raschid defines a correctness criterion for concurrent execution of rules in database environments. The semantic relationships of the rules are analyzed for establishing an execution order among interfering rules and also it is made sure that the condition remains true when the action is executed. <p> HiPAC [8] integrates the parallel rule execution model with that of transactions. The rules are modeled as subtransactions and the serializability among rules is guaranteed by the underlying nested transaction model [34, 27]. Other works that support parallel execution of rules in database environments include [6, 39]. In <ref> [39] </ref>, Raschid defines a correctness criterion for concurrent execution of rules in database environments. The semantic relationships of the rules are analyzed for establishing an execution order among interfering rules and also it is made sure that the condition remains true when the action is executed.
Reference: [40] <author> James G. Schmolze. </author> <title> Guaranteeing serializable results in synchronous parallel production systems. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 348-365, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors [30]. Several AI researchers have worked on the execution semantics of such parallel firing systems [41, 45, 28, 30]. Two important problems have been identified in such systems <ref> [40] </ref>: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager [27]. <p> However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems <ref> [40] </ref>. On the other hand, HiPAC [8] and Raschid's work [39] support parallel firing of rules but do not provide any control over the rule execution order. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. <p> In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. On the other hand, in <ref> [40, 28] </ref>, serializable execution of rules is guaranteed (by the static analysis of the rules) but user-defined control over rules is not supported.
Reference: [41] <author> James G. Schmolze and Suraj Goel. </author> <title> A parallel asynchronous distributed production system. </title> <booktitle> In Proceedings of the 8th National Conference on Artificial Intelligence, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors [30]. Several AI researchers have worked on the execution semantics of such parallel firing systems <ref> [41, 45, 28, 30] </ref>. Two important problems have been identified in such systems [40]: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs.
Reference: [42] <author> Amit P. Sheth, Marek Rsinkiewicz, and George Karabatis. </author> <title> Database Transaction Models for advanced applications, chapter Using Polytransactions to manage interdependent data, </title> <address> pages 555-582. </address> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [43] <author> Yuh-Ming Shyy and Stanley Y.W. Su. </author> <title> K: A high-level knowledge base programming language for advanced database applications. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: The trigger time specifies when the triggered rule should be executed 2 They are referred to as coupling modes in some literature [13] 6 relative to a trigger operation. For example, the following trigger times can be specified in our OSAM*'s rule specification language <ref> [43] </ref>: i) before: the rule is executed before the trigger operation, ii) immediately-after: the rule is executed immediately after the operation, iii) after: the rule is executed just before the commit time and iv) parallel: the rule is executed as a separate transaction.
Reference: [44] <author> E. Simon, J. Kiernan, and C. deMaindreville. </author> <title> Implementing high level active rules on top of a relational dbms. </title> <booktitle> In Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, </address> <year> 1992. </year>
Reference-contexts: Also, the control constructs provided by RDL1 <ref> [44] </ref> ( sequence,disjunct,saturate) have the same disadvantage. For example, the control flow graph shown in Figure 1 cannot be expressed using the two mentioned approaches because rules r2, r3 synchronize at r5. A set of rules with a graph-based control structure is called a rule graph. <p> The rule execution models of POSTGRES [47], Ariel [23], Starburst [50], RDL1 <ref> [44] </ref>, OPS5 [17] support explicit control over the rule execution 7 , however, in these systems, only one rule is fired at a time which is not ideal in a parallel environment.
Reference: [45] <author> Salvatore J. Stolfo et al. Parulel: </author> <title> Parallel rule processing using meta-rules for redaction. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 366-382, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In active systems, since multiple rules can trigger simultaneously, they can be executed in parallel on different processors [30]. Several AI researchers have worked on the execution semantics of such parallel firing systems <ref> [41, 45, 28, 30] </ref>. Two important problems have been identified in such systems [40]: i) controlling the execution order of rules, ii) guaranteeing the serializable execution of rules. <p> To avoid this problem, several parallel rule execution models have been proposed <ref> [27, 41, 40, 28, 45, 30, 31] </ref>. In [30, 45], several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs. <p> To avoid this problem, several parallel rule execution models have been proposed [27, 41, 40, 28, 45, 30, 31]. In <ref> [30, 45] </ref>, several control constructs are provided to control the parallel execution of rules but they do not guarantee serializable execution of rules. It is the responsibility of the rule programmer to maintain the serializability using the control constructs.
Reference: [46] <author> M. Stonebraker, L. A. Rowe, and M. Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> IEEE Trans. Knowledge Data Eng., </journal> <volume> 2(1) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference: [47] <author> Michael Stonebraker, Eric Hanson, and Spiros Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager [27]. Regarding the first problem, several active systems including POSTGRES <ref> [47] </ref>, Ariel [23] and Starburst [50, 1] provide user-defined priorities to control the execution order. However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. <p> If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems <ref> [47, 23] </ref> would linearly expand itself to include the triggered rules [51] as shown in Figure 2. In the nested transaction model (NTM) [34, 8, 38], the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. <p> The rule execution models of POSTGRES <ref> [47] </ref>, Ariel [23], Starburst [50], RDL1 [44], OPS5 [17] support explicit control over the rule execution 7 , however, in these systems, only one rule is fired at a time which is not ideal in a parallel environment. <p> While we discuss the strategies for executing multiple rules in parallel, in [26], it is discussed how a rule can be further decomposed into sub-rules and can be executed concurrently. 5.2 Transaction Model and Trigger Times POSTGRES <ref> [47] </ref>, Ariel [23] use flat transaction model in which the triggered actions are incorporated by linear expansion of the transaction [51]. The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation).
Reference: [48] <author> S. Y. W. Su, V. Krishnamurthy, and H. Lam. </author> <title> An object-oriented semantic association model (OSAM*). </title> <editor> In S. Kumara, A. L. Soyster, and R. L. Kashyap, editors, </editor> <booktitle> Artificial Intelligence: Manufacturing Theory and Practice, </booktitle> <pages> pages 463-494. </pages> <institution> Institute of Industrial Engineers, Industrial Engineering and Management Press, </institution> <year> 1989. </year>
Reference-contexts: The server processes the transactions asynchronously and queues are used to hold the messages which can be transactions, tasks or acknowledgments, that are received at each node. The underlying data model for this parallel system is OSAM*/P an extension of the object-oriented data model OSAM* <ref> [48] </ref>. In OSAM*.KBMS/P, a database application is defined by a set of classes and their various types of associations.
Reference: [49] <author> Helmut Wachter and Andreas Reuter. </author> <title> Database Transaction Models for advanced applications, </title> <booktitle> chapter THE ConTract MODEL, </booktitle> <pages> pages 219-264. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Thus, the parallel rule execution model is uniformly integrated with that of transactions. Finally, we describe the design and implementation of an integrated parallel active database server for a shared-nothing multiprocessor system (nCUBE2) [20, 33, 9]. Our work is different from the advanced transaction models presented in <ref> [4, 49, 42, 25, 10, 2] </ref> due to the following reasons: i) the proposed graph-based model maintains the traditional ACID properties [21] which are useful in most applications for maintaining consistency and are difficult to be enforced in application programs, ii) we propose a new correctness criterion and concurrency control schemes <p> Also, our graph-based model is upward compatible with NTM in the sense that the applications developed for NTM are directly supported by graph-based transaction model. Several other transaction models including <ref> [10, 49, 42, 4, 25, 2] </ref> have advanced control structure for transactions.
Reference: [50] <author> Jennifer Widom, Roberta J. Cochrane, and Bruce G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <year> 1991. </year>
Reference-contexts: In database systems, the second problem can be easily solved by viewing rules as database tasks, for which the serializability is automatically enforced by a database transaction manager [27]. Regarding the first problem, several active systems including POSTGRES [47], Ariel [23] and Starburst <ref> [50, 1] </ref> provide user-defined priorities to control the execution order. However these rule systems are sequential in the sense that only one rule (with the highest priority) is fired at a time which is a performance bottleneck in parallel rule systems [40]. <p> The rule execution models of POSTGRES [47], Ariel [23], Starburst <ref> [50] </ref>, RDL1 [44], OPS5 [17] support explicit control over the rule execution 7 , however, in these systems, only one rule is fired at a time which is not ideal in a parallel environment.
Reference: [51] <author> Daniel Rios Zertuche and Alejandro P. Buchmann. </author> <title> Execution models for active database systems: A comparison. </title> <type> Technical Report TM-0238-01-90-165, </type> <institution> GTE Laboratories, </institution> <month> Jan-uary </month> <year> 1990. </year> <month> 27 </month>
Reference-contexts: If a transaction T triggers a set of rules fr1,r2,r3,r4,r5g, a flat transaction model used in active systems [47, 23] would linearly expand itself to include the triggered rules <ref> [51] </ref> as shown in Figure 2. In the nested transaction model (NTM) [34, 8, 38], the rules are viewed as subtransactions of T as shown in Figure 3. NTM does not capture the control structure among the rules. <p> multiple rules in parallel, in [26], it is discussed how a rule can be further decomposed into sub-rules and can be executed concurrently. 5.2 Transaction Model and Trigger Times POSTGRES [47], Ariel [23] use flat transaction model in which the triggered actions are incorporated by linear expansion of the transaction <ref> [51] </ref>. The triggered actions they are executed immediately. In POSTGRES, triggered actions can occur on demand also (by lazy evaluation). HiPAC [27], Beeri [3], Raschid [38] and Starburst [6] are some of the works that use nested transactions to support the concurrent execution of rules.
References-found: 51

