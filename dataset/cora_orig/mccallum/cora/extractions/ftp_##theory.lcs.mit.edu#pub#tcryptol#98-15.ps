URL: ftp://theory.lcs.mit.edu/pub/tcryptol/98-15.ps
Refering-URL: http://theory.lcs.mit.edu/~tcryptol/1998/98-15.html
Root-URL: 
Title: More on Proofs of Knowledge  
Author: Shai Halevi Silvio Micali 
Keyword: Proofs of knowledge, prover feasibility.  
Date: May 4, 1998  
Abstract: The notion of proofs of knowledge is central to cryptographic protocols, and many definitions for it have been proposed. In this work we explore a different facet of this notion, not addressed by prior definitions. Specifically, prior definitions concentrate on capturing the properties of the verifier, and do not pay much attention to the properties of the prover. Our new definition is strictly stronger than previous ones, and captures new and desirable properties. In particular, it guarantees prover feasibility, that is, it guarantees that the time spent by the prover in a proof of knowledge is comparable to that it spends in an "extraction" of this knowledge. Our definition also enables one to consider meaningfully the case of a single, specific prover.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Goldreich and M. Bellare, </author> <title> "On Defining Proofs of Knowledge". </title> <booktitle> In Advances in Cryptology: CRYPTO '92,, Lecture Notes in Computer Science, </booktitle> <volume> volume 740, </volume> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <pages> Pages 390-420 </pages>
Reference-contexts: These weaknesses were observed and corrected in a later work of Bellare and Goldreich <ref> [1] </ref>. Although this last definition captures many important aspects of proofs of knowledge, we argue below that there are still other aspects which are not addressed by it. In this paper we exhibit one such aspect and propose to strengthen previous definitions so as to capture it. <p> Nonetheless, previous definitions of proofs-of-knowledge were formulated in a way which did not enabled us to make this distinction. We note that this is no accident. Indeed, previous definitions were explicitly formulated to capture only the properties of the verifier. In particular, the definition in <ref> [1] </ref> goes as far as defining a proof of knowledge only in terms of the verifier. In this paper, we argue that by adding the `same distribution' constraint, we enforce desirable properties of the prover as well. An important example is the prover-feasibility property, which is discussed below. Prover Feasibility. <p> We require that, if the canonical way of proving knowledge (i.e., P ) is followed, then one can convince V all the time. There is, however, a probability that a cheating prover may convince V without actually having any knowledge about the common input x. Following <ref> [1] </ref>, we refer to this probability as the error probability of the proof of knowledge system, and denote it by ". More generally, a (possibly cheating) prover P 0 may have some probability p of convincing V . <p> That is, each of P; V; K in the definition above is given another input 1 k , and we require that the error be at most 2 k . We chose the above weaker formulation to be consistent with previous definitions in the literature. 2. Following <ref> [1] </ref>, we too define the validity condition only for strings x such that R (x) 6= ;. The reader is referred to [1] for a discussion of this choice. 3.1 The case of a specific prover. <p> We chose the above weaker formulation to be consistent with previous definitions in the literature. 2. Following <ref> [1] </ref>, we too define the validity condition only for strings x such that R (x) 6= ;. The reader is referred to [1] for a discussion of this choice. 3.1 The case of a specific prover. One advantage of the above definition is that it enables us to talk about the extent in which the verifier's view of a conversation with a specific prover demonstrates knowledge of a secret. <p> To avoid confusion we refer to their notion as a liberal proof of knowledge. 5.1 The Bellare-Goldreich Definition Casting their definition in our syntax we get Definition 4: <ref> [1] </ref>: An interactive Turing-machine V is a knowledge-verifier for a binary relation R with error " if it satisfies the following Completeness There exists an interactive Turing machine P (the "legitimate prover") such that for all (x; y) 2 R, Pr [acceptfP (x; y) $ V (x)g] = 1.
Reference: [2] <author> U. Feige and A. Fiat and A. Shamir. </author> <title> "Zero-knowledge proofs of identity". </title> <journal> In Journal of Cryptology, </journal> <volume> 1(2), </volume> <year> 1988. </year> <pages> Pages 77-94 </pages>
Reference-contexts: Proofs of knowledge have since played a crucial role in cryptographic protocols, and ever since their intuitive introduction [6] [3], there have been several attempts to provide them with an adequate formalization. The first such attempts <ref> [4, 2, 8] </ref> did not address some possible scenarios (most notably, the case where the verifier is convinced with probability which is not non-negligible, and the case where the prover is not restricted to probabilistic-polynomial-time). These weaknesses were observed and corrected in a later work of Bellare and Goldreich [1].
Reference: [3] <author> M.J. Fischer, S. Micali and C. Rackoff, </author> <title> "A Secure Protocol for Oblivious Transfer (Extended Abstract)" In Journal of Cryptology, </title> <type> 9(3), </type> <year> 1996. </year> <note> Pages 191-195 (first presented in Eurocrypt '84). </note>
Reference-contexts: Clearly, one such way would be exhibiting the secret in question, However, the notion becomes interesting (and hard to formalize properly!) when the secret is not directly revealed. Proofs of knowledge have since played a crucial role in cryptographic protocols, and ever since their intuitive introduction [6] <ref> [3] </ref>, there have been several attempts to provide them with an adequate formalization.
Reference: [4] <author> U. Feige and A. Shamir. </author> <title> "Witness indistinguishable and witness hiding protocols". </title> <booktitle> In Proc. of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year> <pages> Pages 416-426 </pages>
Reference-contexts: Proofs of knowledge have since played a crucial role in cryptographic protocols, and ever since their intuitive introduction [6] [3], there have been several attempts to provide them with an adequate formalization. The first such attempts <ref> [4, 2, 8] </ref> did not address some possible scenarios (most notably, the case where the verifier is convinced with probability which is not non-negligible, and the case where the prover is not restricted to probabilistic-polynomial-time). These weaknesses were observed and corrected in a later work of Bellare and Goldreich [1].
Reference: [5] <author> O. Goldreich, S. Goldwasser and S. Micali. </author> <title> How to Construct Random Functions. </title> <journal> In Journal of the ACM, </journal> <volume> Vol. 33, no. 4, </volume> <year> 1986, </year> <pages> pp. 792-807 9 </pages>
Reference: [6] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> "The knowledge complexity of interactive proof systems". </title> <journal> In SIAM Journal on Computing, </journal> <volume> 18(1), </volume> <year> 1989. </year> <note> Pages 186-208 (Preliminary version appeared in Proc. of the 17th Annual ACM Symposium on Theory of Computing, </note> <year> 1985. </year> <pages> Pages 291-304) </pages>
Reference-contexts: Clearly, one such way would be exhibiting the secret in question, However, the notion becomes interesting (and hard to formalize properly!) when the secret is not directly revealed. Proofs of knowledge have since played a crucial role in cryptographic protocols, and ever since their intuitive introduction <ref> [6] </ref> [3], there have been several attempts to provide them with an adequate formalization. <p> Interactive Turing Machines. We rely on the intuitive notion of an interactive Turing-machine (ITM) as a machine which can send and receive messages during its computation. The reader is referred to <ref> [6] </ref> for a more formal definition. A pair of interactive Turing machine (P; V ) defines a protocol in the usual way. For convenience, given our application, we refer to the first machine in this pair as the "Prover" and to the second machine as the "Verifier". Transcripts and Views.
Reference: [7] <author> O. Goldreich, S. Micali and A. Wigderson, </author> <title> "Proofs that Yield Nothing but their Validity or All Languages in NP Have Zero-Knowledge Proof Systems", </title> <journal> Journal of the ACM, </journal> <volume> vol. 38, no. 1, </volume> <year> 1991, </year> <pages> pp. 691-729. </pages>
Reference: [8] <author> M. Tompa and H. Woll. </author> <title> "Random self-reducibility and zero knowledge interactive proofs of possession of information". </title> <note> In Technical report CS92-244, </note> <institution> Univ. of California at San-Diego, </institution> <year> 1992. </year> <note> (Preliminary version appeared in 28th Annual Symposium on Foundations of Computer Science, IEEE, </note> <year> 1987. </year> <pages> Pages 472-482) 10 </pages>
Reference-contexts: Proofs of knowledge have since played a crucial role in cryptographic protocols, and ever since their intuitive introduction [6] [3], there have been several attempts to provide them with an adequate formalization. The first such attempts <ref> [4, 2, 8] </ref> did not address some possible scenarios (most notably, the case where the verifier is convinced with probability which is not non-negligible, and the case where the prover is not restricted to probabilistic-polynomial-time). These weaknesses were observed and corrected in a later work of Bellare and Goldreich [1].
References-found: 8

