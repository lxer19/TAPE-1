URL: http://www.cse.ogi.edu/~jl/Papers/pointed.ps
Refering-URL: http://www.cse.ogi.edu/~jl/biblio-functional.html
Root-URL: http://www.cse.ogi.edu
Phone: 2  
Title: Parametricity and Unboxing with Unpointed Types  
Author: John Launchbury and Ross Paterson 
Address: P.O. Box 91000, Portland, OR 97291-1000, USA  College, London SW7, UK  
Affiliation: 1 Oregon Graduate Institute,  Department of Computing, Imperial  
Abstract: In lazy functional languages, ? is typically an element of every type. While this provides great flexibility, it also comes at a cost. In this paper we explore the consequences of allowing unpointed types in a lazy functional language like Haskell. We use the type (and class) system to keep track of pointedness, and show the consequences for parametricity and for controlling evaluation order and unboxing.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Andrew A. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: If evaluation of the argument terminates, it will have performed a lift. Now ext can immediately (tail-) call its function argument, passing it the explicit value that had just been returned. This evaluation scheme is reminiscent of the continuation-passing style that is rather effective for call-by-value computations <ref> [1] </ref>.
Reference: 2. <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: CPOs also combine very well with the rest of domain theory, so long as recursive-domain equations (and recursive values likewise) are restricted. We shall give a brief account here; details may be found in standard texts <ref> [12, 2] </ref>, The first thing to note is that the category is still cartesian closed.
Reference: 3. <author> Fritz Henglein and J. Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In 21st ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 213-226, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: There has been a lot of recent work on minimizing the boxing and unboxing of values that arises in this way <ref> [7, 3, 14] </ref>. Finally, in lazy languages, arguments are not to be evaluated until it is known that their results are required, so arguments are passed as pointers to computations (so-called call-by-need).
Reference: 4. <author> Brian T. Howard. </author> <title> Inductive, projective, and pointed types. </title> <booktitle> In ACM Int. Conf. on Functional Programming, </booktitle> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: We have benefited from discussions with Erik Meijer, and the paper has been improved by feedback from Tim Sheard, Andrew Tolmack and Andrew Moran. After writing this paper, we became aware of the work of Brian Howard <ref> [4] </ref>, who uses an equivalent treatment of lifting and pointed types to describe a language in which initial, final and retractive types co-exist.
Reference: 5. <editor> Paul Hudak, Simon Peyton Jones, Philip Wadler, et al. </editor> <title> Report on the programming language Haskell, a non-strict purely functional language (Version 1.2). </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(5), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Ever since Scott and others showed how to use pointed CPOs (i.e. with bottoms) to give meaning to general recursion, both over values (including functions), and over types themselves, functional languages seem to have been wedded to the concept. Languages like Haskell <ref> [5] </ref> model types by appropriate CPOs and, because non-terminating computations can happen at any type, all the CPOs are pointed. This gives significant flexibility. In particular, values of any type may be defined using recursion. 1.1 Parametricity There are associated costs, however.
Reference: 6. <author> Stefan Kaes. </author> <title> Parametric overloading in polymorphic programming languages. </title> <booktitle> In 2nd European Symp. on Programming, volume 300 of Lecture Notes in Computer Science, </booktitle> <pages> pages 131-144. </pages> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: Also note that lifted types and Pointed types are not the same thing. All lifted types are Pointed but, while products of Pointed types are Pointed, they are not lifted. With these definitions and rules, the Pointed restrictions are inferred by the usual Haskell algorithm <ref> [6, 16] </ref>. Functions that analyse a lifted type are defined using ext, and thus have a Pointed result. For example, suppose that the type of lifted integers Int is defined to be Int # ? , where Int # is the type representing the (unlifted) set of integers.
Reference: 7. <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In 19th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: There has been a lot of recent work on minimizing the boxing and unboxing of values that arises in this way <ref> [7, 3, 14] </ref>. Finally, in lazy languages, arguments are not to be evaluated until it is known that their results are required, so arguments are passed as pointers to computations (so-called call-by-need).
Reference: 8. <author> Ross Paterson. </author> <title> Compiling laziness using projections, </title> <month> October </month> <year> 1995. </year> <note> Draft. </note>
Reference-contexts: For example, the image of the head-strict projection on lists of integers is exactly the lists of unboxed integers. With explicit lifting, this may be formalized by factoring projections as embedding-projection pairs, as is done in a related paper <ref> [8] </ref>. 7 Recursive Type Definitions To complete the picture of the interaction between Pointed constraints and the features of a typical functional language, we now consider recursively defined types. The semantics of these types is customarily described using a colimit construction [13].
Reference: 9. <author> Simon L. Peyton Jones and John Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: First, parametricity is repaired and returns to its former glory. When recursion is not used, there is no strictness side-condition on the theorems. Secondly, unpointed types can be used to control both evaluation order and unboxing of values, subsuming earlier work by Peyton Jones and Launchbury <ref> [9] </ref>. 2 Pointed and Unpointed Domains Domain theory was developed originally in order to provide solutions to recursive domain equations. Such solutions are needed to model the untyped -calculus, but also for recursively-defined data types in languages like Haskell and ML. <p> All the reasoning ability from the forgoing is still entirely valid. However, we will claim that the semantically clean language we have presented is also ideal for the expression of such low-level concerns as sequencing and unboxing. Peyton Jones and Launchbury <ref> [9] </ref> present a closely related system, with the intention of describing when a value may be passed unboxed. <p> Operationally this is just right: the value may be stored unboxed. If the value has already been evaluated, then it cannot possibly be ?, so does not need to live in a pointed domain. This relationship was first explored by Peyton Jones and Launchbury <ref> [9] </ref>. They introduce a class of unboxed types corresponding to our unlifted types, some primitive (e.g. unboxed integers), and others defined by the user using unboxed data type declarations. Also as here, they model these types using unpointed domains. However, the big difference comes in the semantics of functions.
Reference: 10. <author> Andrew M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <note> to appear, </note> <year> 1996. </year>
Reference-contexts: The following result is standard. Proposition 2. In any model satisfying the axioms of Fig. 2, the actions on relations preserve identity relations. An action that preserves identity relations is said to be unitary <ref> [10] </ref>, or to have the Identity Extension Property [11]. We can also add other base types, in particular flat integers, etc, with their re lational action being an identity relation on that type. <p> Then the categorical colimit construction yields a Pointed type F , with a pair of isomorphisms in F : F F ! F The interesting case is where the recursive type has parameters. The following treatment follows Pitts <ref> [10] </ref>. However, instead of assuming all types and relations are pointed, we shall use the Pointed constraint to keep track of exactly which types are required to be pointed in Pitts's proofs. To sketch the general situation, we shall assume a single recursive type with one parameter. <p> To sketch the general situation, we shall assume a single recursive type with one parameter. The extension to mutual recursion and more parameters is straightforward. To obtain the most general types <ref> [10] </ref>, we first separate neg-ative and positive occurrences of each variable, replacing each with a pair of variables. Suppose F ff ff + fi fi + is a type constructor, with ff and fi occurring negatively, and ff + and fi + occurring positively. <p> The proofs of Pitts <ref> [10] </ref> are easily extended to establish that for any such F and for any ff + satisfying C, the recursive type F ff ff + exists and is Pointed.
Reference: 11. <author> John C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <booktitle> In Information Processing 83, </booktitle> <pages> pages 513-523. </pages> <publisher> Elsevier, </publisher> <year> 1983. </year>
Reference-contexts: Similarly, the general parametricity theorems that follow from polymorphic types (popularized by Wadler as "Theorems for Free" [15]) are rather weaker than in the pure simply-typed -calculus. Parametricity was introduced by Reynolds to express the limits on behaviour that polymorphism induces <ref> [11] </ref>. For example, a function that has the type 8 ff: ff ! ff can do nothing interesting to its argument: it can only return it. <p> The following result is standard. Proposition 2. In any model satisfying the axioms of Fig. 2, the actions on relations preserve identity relations. An action that preserves identity relations is said to be unitary [10], or to have the Identity Extension Property <ref> [11] </ref>. We can also add other base types, in particular flat integers, etc, with their re lational action being an identity relation on that type. Then as a consequence of this proposition, the relational interpretations of the types of primitive monomor-phic constants will be theorems. <p> In the relational interpretations of such types, free type variables 3 may stand for any relation between any tuple of domains. The parametricity theorem <ref> [11] </ref> states that if all the constants satisfy the relational interpretation, then so do all -expressions built from them. For example, suppose n is a -expression with type 8 ff: (ff ! ff) ! ff ! ff.
Reference: 12. <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: CPOs also combine very well with the rest of domain theory, so long as recursive-domain equations (and recursive values likewise) are restricted. We shall give a brief account here; details may be found in standard texts <ref> [12, 2] </ref>, The first thing to note is that the category is still cartesian closed.
Reference: 13. <author> Mike B. Smyth and Gordon D. Plotkin. </author> <title> The category-theoretic solution of recursive domain equations. </title> <journal> SIAM Journal on Computing, </journal> <volume> 11(4) </volume> <pages> 761-783, </pages> <year> 1982. </year>
Reference-contexts: The semantics of these types is customarily described using a colimit construction <ref> [13] </ref>. That is, to construct the fixed point of a type constructor F , one constructs the sequence of domains corresponding to 1l; F 1l; F (F 1l); : : : with each domain embedded in the next.
Reference: 14. <author> Peter J. Thiemann. </author> <title> Unboxed values and polymorphic typing revisited. </title> <booktitle> In Conf. on Functional Programming Languages and Computer Architecture'95, </booktitle> <pages> pages 24-35, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: There has been a lot of recent work on minimizing the boxing and unboxing of values that arises in this way <ref> [7, 3, 14] </ref>. Finally, in lazy languages, arguments are not to be evaluated until it is known that their results are required, so arguments are passed as pointers to computations (so-called call-by-need).
Reference: 15. <editor> Philip Wadler. </editor> <booktitle> Theorems for free! In 4th Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 347-359. </pages> <publisher> IFIP, </publisher> <year> 1989. </year>
Reference-contexts: When reasoning about programs, one must also allow for the possibility of non-termination, even if a function is in fact total. Similarly, the general parametricity theorems that follow from polymorphic types (popularized by Wadler as "Theorems for Free" <ref> [15] </ref>) are rather weaker than in the pure simply-typed -calculus. Parametricity was introduced by Reynolds to express the limits on behaviour that polymorphism induces [11]. For example, a function that has the type 8 ff: ff ! ff can do nothing interesting to its argument: it can only return it.
Reference: 16. <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> In 16th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference-contexts: Also note that lifted types and Pointed types are not the same thing. All lifted types are Pointed but, while products of Pointed types are Pointed, they are not lifted. With these definitions and rules, the Pointed restrictions are inferred by the usual Haskell algorithm <ref> [6, 16] </ref>. Functions that analyse a lifted type are defined using ext, and thus have a Pointed result. For example, suppose that the type of lifted integers Int is defined to be Int # ? , where Int # is the type representing the (unlifted) set of integers.
Reference: 17. <author> Philip Wadler and John Hughes. </author> <title> Projections for strictness analysis. </title> <booktitle> In Conf. on Functional Programming Languages and Computer Architecture, volume 274 of Lecture Notes in Computer Science, </booktitle> <address> Portland, OR, </address> <year> 1987. </year>
Reference-contexts: If we had tried to avoid the final lifting on the result, the type checker would object as we are using recursion|the result type must be Pointed. 6.5 Projection-based Strictness Analysis Our explicit treatment of lifting is also suitable for exploiting the results of projection-based strictness analysis <ref> [17] </ref>. For example, the image of the head-strict projection on lists of integers is exactly the lists of unboxed integers.
References-found: 17

