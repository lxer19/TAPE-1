URL: http://www.cs.uoregon.edu/~sabry/papers/reasoning-popl-sub.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Title: Reasoning with Continuations III: A Complete Calculus of Control  
Author: Amr Sabry Matthias Felleisen 
Note: Summary  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: The -calculus is the simple and elegant, yet powerful basis for the semantic manipulation of functional programs by programmers and programming tools (compilers, optimizers, semantics-based editors) alike. The theory provides a simple system for evaluating programs in a symbolic manner; the typed version is a complete system of program equality for the pure core language. Felleisen et al. [6, 9, 8] and Talcott [24, 25] have recently developed extensions of the -calculus for reasoning about languages with powerful control operators, the v -C-calculus and the first-order logic IOCC, respectively, but they did not address the issue of completeness. The central result of this paper is an extension of the v -C-calculus for a complete set of control operators and a correspondence theorem between the new theory and the fi-calculus. Technically, the theorem shows that the two calculi prove the same equations with respect to the well-known continuation-passing style translation (and its inverse), which is the standard tool for defining control operators via translation into a functional language. As a corollary, the calculus proves all program equivalences between terms over the pure language extended with control operators. We believe that this work has important consequences for the direct-style compilation of programming languages with control operators. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Appel, A. and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Proc. 16th July 28, 1992 - 09 : 54 DRAFT 11 ACM Symposium on Principles of Programming Languages (1982), </booktitle> <pages> pp. 242-254. 293-302. </pages>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation <ref> [1, 21, 23] </ref>, partial evaluators perform better on CPS programs [3], and abstract interpreters can extract more information from CPS programs [14, 15]. However, the CPS formalism has its disadvantage.
Reference: [2] <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics, revised ed. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The set of terms M is generated inductively over an infinite set of variables, Vars: 1 M ::= V j (M M ) (Terms) V ::= x j (x:M ) (Values) x 2 Vars We adopt Barendregt's <ref> [2, ch 2,3] </ref> notation and terminology for this syntax. In particular, we use the standard definitions of free and bound variables, substitution, contexts (terms with holes) and work with the quotient of fl under ff-equivalence. The semantics of the language is a partial function, eval , from programs to answers. <p> We refer to this extension as fi v v A where A = ffi lift ; fi g. The calculi fi v v A and fi satisfy a correspondence theorem similar to the correspondence between the -calculus and Combinatory Logic <ref> [2, ch 7] </ref>. Theorem 2.1 (Correspondence [20]) Let M; N 2 fl and P; Q 2 cps (fl).
Reference: [3] <author> Consel C. and O. Danvy. </author> <title> For a better support of static data flow. </title> <booktitle> In Proc. of Functional Languages and Computer Architecture (Cambridge, </booktitle> <address> MA, </address> <year> 1991), </year> <pages> pp. 496-519. </pages>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation [1, 21, 23], partial evaluators perform better on CPS programs <ref> [3] </ref>, and abstract interpreters can extract more information from CPS programs [14, 15]. However, the CPS formalism has its disadvantage. It is a global transformation that re-structures the entire program, increases its size considerably, and makes it mostly unreadable for the programmer.
Reference: [4] <author> Danvy, O. and A. Filinski. </author> <title> Representing control: A study of the CPS transformation. </title> <type> Tech. Rep. </type> <institution> CIS-91-2, Kansas State University, </institution> <year> 1991. </year>
Reference-contexts: In order to adopt Correspondence Theorem 2.1, it is necessary to identify reductions 2 Steele [23] and Danvy/Filinski <ref> [4] </ref> have similar compactifying CPS transformations but this is not an issue in this paper. <p> We refer to the prompt in the first case as the lazy prompt because its subexpression may not be evaluated, and refer to the other prompt as the strict prompt. The classic semantics for control delimiters <ref> [4, 6] </ref> corresponds to the strict prompt. However, meta-theorems are, as always, easier to formulate and prove for the by-name version.
Reference: [5] <author> Danvy, O. and J. L. Lawall. </author> <title> Back to Direct Style II: First-class continuations. </title> <booktitle> In Proc. 1992 ACM Conference on Lisp and Functional Programming (1992). </booktitle>
Reference-contexts: The inverse of an answer W is an expression that aborts with the value that corresponds to W . To map the term k:K to the source language, we extend the function U in Figure 2 using an idea of Danvy and Lawall <ref> [5] </ref>. 3 Finally, as the last line in the inverse transformation shows, all continuations are explicitly invoked. In order to adopt Correspondence Theorem 2.1, it is necessary to identify reductions 2 Steele [23] and Danvy/Filinski [4] have similar compactifying CPS transformations but this is not an issue in this paper. <p> Although Talcott is not motivated by the notion of completeness nor by denotational models, her equational subtheory turns out to be equivalent to our calculus and is therefore complete by Theorem 4.4. The development of the "direct style" transformation <ref> [5] </ref> provides an alternative reasoning system in which programs are mapped to CPS form, analyzed, and then un-translated. Because both the CPS transformation and its inverse are global transformations, this approach is expensive and inefficient.
Reference: [6] <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages (1988), </booktitle> <pages> pp. 180-190. </pages>
Reference-contexts: The main technical result of this paper is the development of a theory for reasoning about control abstractions that proves all the equations in the CPS framework and also proves all program equivalences between recursion-free terms. The theory is an extension of the v -C-calculus <ref> [6, 9, 8] </ref> that completely characterizes the operational behavior of callcc and A in the presence of control delimiters. <p> July 28, 1992 - 09 : 54 DRAFT 7 3.2 A complete set of axioms for # The last control facility that fully abstract denotational CPS models can express is the ability to delimit control actions. We extend the source language with such a facility, the prompt expression <ref> [6] </ref>: (# M ). Intuitively, the prompt treats its subexpression as a complete program by evaluating it in the initial continuation, forwarding the result to the current continuation. <p> We refer to the prompt in the first case as the lazy prompt because its subexpression may not be evaluated, and refer to the other prompt as the strict prompt. The classic semantics for control delimiters <ref> [4, 6] </ref> corresponds to the strict prompt. However, meta-theorems are, as always, easier to formulate and prove for the by-name version. <p> The rest follows from Theorem 4.3. 5 Related Work Our work must be compared to the two prominent theories for reasoning about languages with control operators: the v -C-calculus <ref> [6, 9, 8] </ref> and the theory IOCC [24, 25]. The v -C-calculus is an equational theory that approximates our calculus. The theory includes enough axioms to reason about the evaluation of programs but is incomplete with respect to the CPS transformation and with respect to semantic models.
Reference: [7] <author> Felleisen, M. and D.P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. </title> <booktitle> In Formal Description of Programming Concepts III (Amsterdam, </booktitle> <year> 1986), </year> <editor> M. Wirsing, Ed., </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <pages> pp. 193-217. </pages>
Reference-contexts: A program is a term with no free variables, and an answer is a member of the syntactic category of values. The operational specification of the function eval relies on the notion of evaluation contexts <ref> [7] </ref>. Informally, an evaluation context is the context surrounding the current instruction during the evaluation of the program, i.e., the evaluation context is a syntactic representation of the continuation.
Reference: [8] <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Tech. Rep. 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci., </institution> <year> 1991, </year> <note> to appear. </note>
Reference-contexts: The main technical result of this paper is the development of a theory for reasoning about control abstractions that proves all the equations in the CPS framework and also proves all program equivalences between recursion-free terms. The theory is an extension of the v -C-calculus <ref> [6, 9, 8] </ref> that completely characterizes the operational behavior of callcc and A in the presence of control delimiters. <p> The rest follows from Theorem 4.3. 5 Related Work Our work must be compared to the two prominent theories for reasoning about languages with control operators: the v -C-calculus <ref> [6, 9, 8] </ref> and the theory IOCC [24, 25]. The v -C-calculus is an equational theory that approximates our calculus. The theory includes enough axioms to reason about the evaluation of programs but is incomplete with respect to the CPS transformation and with respect to semantic models.
Reference: [9] <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Comput. Sci. </journal> <volume> 52, </volume> <month> 3 </month> <year> (1987), </year> <month> 205-237. </month> <title> Preliminary version: Reasoning with Continuations, </title> <booktitle> in Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: The main technical result of this paper is the development of a theory for reasoning about control abstractions that proves all the equations in the CPS framework and also proves all program equivalences between recursion-free terms. The theory is an extension of the v -C-calculus <ref> [6, 9, 8] </ref> that completely characterizes the operational behavior of callcc and A in the presence of control delimiters. <p> The rest follows from Theorem 4.3. 5 Related Work Our work must be compared to the two prominent theories for reasoning about languages with control operators: the v -C-calculus <ref> [6, 9, 8] </ref> and the theory IOCC [24, 25]. The v -C-calculus is an equational theory that approximates our calculus. The theory includes enough axioms to reason about the evaluation of programs but is incomplete with respect to the CPS transformation and with respect to semantic models.
Reference: [10] <author> Griffin, T. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Proc. 17th ACM Symposium on Principles of Programming Languages (1990), </booktitle> <pages> pp. 47-58. </pages>
Reference-contexts: Let M; N 2 fl t c , then fi v v ACP ` M = N if and only if M and N are call-by-value observationally equivalent in PCF contexts 6 augmented with callcc, A, the lazy prompt, and pif. 5 This theorem provides an alternative proof for Griffin's <ref> [10] </ref> Weak Normalization Theorem for the v - C-calculus.
Reference: [11] <author> Haynes, C.T., D.P. Friedman, and M. Wand. </author> <title> Obtaining coroutines from continuations. </title> <note> Journal of Computer Languages (Pergamon Press) 11, </note> <month> 3/4 </month> <year> (1986), </year> <pages> 143-153. </pages>
Reference-contexts: The programs implement a coroutine facility using first-class continuations. The left program, due to Haynes, Friedman, and Wand <ref> [11] </ref>, is the result of clear and well-understood design steps but is far more complicated than necessary. The initialization part of the coroutine is non-trivial: it involves capturing a continuation and an artificial use of the function resume that assigns the proper value to the local control state (LCS ).
Reference: [12] <author> Hieb R., R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation (1990), </booktitle> <pages> pp. 66-77. </pages>
Reference-contexts: The consequences for direct-style compilers like Chez Scheme <ref> [12] </ref> are clear: They can use the conventional compilation techniques on their inputs and still collect and use all the information that a CPS-based compiler would be able to deduce.
Reference: [13] <author> Meyer, A.R. and M. Wand. </author> <title> Continuation semantics in typed lambda-calculi. </title> <booktitle> Proc. Workshop Logics of Programs (1985), </booktitle> <pages> 219-224. </pages> <booktitle> Lecture Notes in Computer Science 193, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg. </address>
Reference-contexts: The CPS type structure in Figure 7 is the Meyer/Wand <ref> [13] </ref> structure (after reversing the July 28, 1992 - 09 : 54 DRAFT 9 order of arguments to procedures). The set of answers includes only values of ground type .
Reference: [14] <author> Muylaert-Filho, A. J. and G. L. Burn. </author> <title> Continuation semantics and abstract interpretation. </title> <type> Unpublished manuscript, </type> <institution> Imperial College of Science, </institution> <address> London, </address> <year> 1992. </year> <month> July 28, </month> <note> 1992 - 09 : 54 DRAFT 12 </note>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation [1, 21, 23], partial evaluators perform better on CPS programs [3], and abstract interpreters can extract more information from CPS programs <ref> [14, 15] </ref>. However, the CPS formalism has its disadvantage. It is a global transformation that re-structures the entire program, increases its size considerably, and makes it mostly unreadable for the programmer. Our goal is to capture the expressive power of the CPS formalism in a variant of the -calculus. <p> The main result of this analysis is the development of a canonical theory for reasoning about the evaluation, optimization, and implementation of control abstractions in call-by-value languages. In the meantime, we also received a paper by Muylaert-Filho and Burn <ref> [14] </ref>, which claims that programs in continuation-passing style are more informative with respect to abstract interpretations. In this context, it is interesting to see that the reductions of our calculus increase the information content of programs with respect to abstract interpretation.
Reference: [15] <author> Nielson, F. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Inf. </journal> <volume> 18 (1982), </volume> <pages> 265-287. </pages>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation [1, 21, 23], partial evaluators perform better on CPS programs [3], and abstract interpreters can extract more information from CPS programs <ref> [14, 15] </ref>. However, the CPS formalism has its disadvantage. It is a global transformation that re-structures the entire program, increases its size considerably, and makes it mostly unreadable for the programmer. Our goal is to capture the expressive power of the CPS formalism in a variant of the -calculus.
Reference: [16] <author> Plotkin, G.D. </author> <title> Completeness for the continuous type frame. </title> <type> Unpublished manuscript. </type>
Reference-contexts: Proof Sketch. By the correspondence theorem, fi ` C k [[M ]] = C k [[N ]]. Since the latter terms are also simply typed terms, the full continuous type frame satisfies the equation C k [[M ]] = C k [[N ]] <ref> [16] </ref>. The result follows because the two denotational models define the same semantics. Finally, the calculus fi v v ACP corresponds to a restriction of the call-by-value observational equivalence that accounts for control operations.
Reference: [17] <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Comput. Sci. </journal> <volume> 1 (1975), </volume> <pages> 125-159. </pages>
Reference-contexts: The CPS transformation maps the language fl to a proper subset of itself. The evaluation of the resulting CPS terms is indifferent to the call-by-value or call-by-name strategies <ref> [17, 19] </ref>. Therefore, both the -calculus (see Figure 2) and the v -calculus are suitable theories for reasoning about the equivalence of CPS procedures. In general, the -calculus is preferred because it is a larger theory.
Reference: [18] <author> Plotkin, G.D. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Comput. Sci. </journal> <volume> 5 (1977), </volume> <pages> 223-255. </pages>
Reference-contexts: The problem of Strong Normalization for v -C-calculus (or for our new calculus) remains open since reductions in the source language do not necessarily translate to reductions on the CPS side. 6 PCF terms include numerals, add1, sub1, conditionals, and a recursion operator <ref> [18] </ref>. July 28, 1992 - 09 : 54 DRAFT 10 Proof Sketch. By modifying the full abstraction proof of Sitaram and Felleisen [22], we prove that the CPS continuous frame model satisfies M = N if only if M and N are observationally equivalent.
Reference: [19] <author> Reynolds, </author> <title> J.C. Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proc. ACM Annual Conference (1972), </booktitle> <pages> pp. 717-740. </pages>
Reference-contexts: The CPS transformation maps the language fl to a proper subset of itself. The evaluation of the resulting CPS terms is indifferent to the call-by-value or call-by-name strategies <ref> [17, 19] </ref>. Therefore, both the -calculus (see Figure 2) and the v -calculus are suitable theories for reasoning about the equivalence of CPS procedures. In general, the -calculus is preferred because it is a larger theory.
Reference: [20] <author> Sabry, A. and M. Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (1992), </booktitle> <pages> pp. 288-298. </pages>
Reference-contexts: This derivation establishes that the two programs are observationally indistinguishable. The main steps of the transformation are in the appendix. The next section introduces basic concepts and summarizes our previous work about the connection between a pure call-by-value language and its image under the CPS transformation <ref> [20] </ref>. In the third section, we extend the source language with the control operators: callcc and A, and control delimiters. For each extension, we identify a set of reductions that captures the effect of fi-reductions on CPS terms. In Section 4, we address the issue of semantic completeness. <p> In general, the -calculus is preferred because it is a larger theory. July 28, 1992 - 09 : 54 DRAFT 4 The CPS transformation in Figure 2 produces compact outputs that are provably equal to the outputs of the traditional Fischer/Reynolds CPS transformation <ref> [20] </ref>. 2 The set of CPS terms that results from this transformation is the language cps (fl) (see Figure 2). This set is closed under all possible fi reductions and thus includes all the relevant CPS terms. <p> We refer to this extension as fi v v A where A = ffi lift ; fi g. The calculi fi v v A and fi satisfy a correspondence theorem similar to the correspondence between the -calculus and Combinatory Logic [2, ch 7]. Theorem 2.1 (Correspondence <ref> [20] </ref>) Let M; N 2 fl and P; Q 2 cps (fl).
Reference: [21] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation <ref> [1, 21, 23] </ref>, partial evaluators perform better on CPS programs [3], and abstract interpreters can extract more information from CPS programs [14, 15]. However, the CPS formalism has its disadvantage.
Reference: [22] <author> Sitaram, D. and M. Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 161-175. </pages>
Reference-contexts: We consider two aspects of the expressive power of CPS: the control operators that are definable within the CPS framework, and the equational axioms that govern the behavior of these operators. Sitaram and Felleisen <ref> [22] </ref> address the first aspect by analyzing CPS models. They establish that abort (A), call-with-current-continuation (callcc), and control delimiters represent a complete set of control operators. Pragmatically, these control operators can concisely express a wide variety of control abstractions such as error exits, jumps, backtracking, coroutines, and exception handling. <p> Then, 1. fi v v A ` M = C 1 [[C k [[M ]]]]. 3. fi v v A ` M = N iff fi ` C k [[M ]] = C k [[N ]]. 3 The Control Extensions The analysis of mathematical CPS models <ref> [22] </ref> shows that these models can essentially express continuation capture (callcc), error exits (A), and control delimiters (#). The first subsection deals with the first two of these operators, which are more widely used and less problematic than control delimiters. <p> (Continuations) a ::= (Answers) The typed CPS language: CPS t P a ::= x a j (K -!a W -) a j (K a!a P a ) a K ::= k j (x -:P a ) -!a j (W 1 ! 2 K 1 ) 2 and their usual types <ref> [22] </ref>. To apply the correspondence theorem to these typed languages, it is necessary to prove that the CPS transformation and its inverse preserve the typability of the terms. <p> July 28, 1992 - 09 : 54 DRAFT 10 Proof Sketch. By modifying the full abstraction proof of Sitaram and Felleisen <ref> [22] </ref>, we prove that the CPS continuous frame model satisfies M = N if only if M and N are observationally equivalent.
Reference: [23] <author> Steele, G.L., Jr. RABBIT: </author> <title> A compiler for SCHEME. </title> <type> Memo 474, </type> <institution> MIT AI Lab, </institution> <year> 1978. </year>
Reference-contexts: 1 The Expressive Power of CPS The continuation-passing style (CPS) transformation constitutes an essential component of many program analysis tools. Apparently, compilers benefit from the CPS intermediate representation <ref> [1, 21, 23] </ref>, partial evaluators perform better on CPS programs [3], and abstract interpreters can extract more information from CPS programs [14, 15]. However, the CPS formalism has its disadvantage. <p> In order to adopt Correspondence Theorem 2.1, it is necessary to identify reductions 2 Steele <ref> [23] </ref> and Danvy/Filinski [4] have similar compactifying CPS transformations but this is not an issue in this paper.
Reference: [24] <author> Talcott, C. </author> <title> The Essence of Rum|A Theory of the Intensional and Extensional Aspects of Lisp-type Computation. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1985. </year>
Reference-contexts: The rest follows from Theorem 4.3. 5 Related Work Our work must be compared to the two prominent theories for reasoning about languages with control operators: the v -C-calculus [6, 9, 8] and the theory IOCC <ref> [24, 25] </ref>. The v -C-calculus is an equational theory that approximates our calculus. The theory includes enough axioms to reason about the evaluation of programs but is incomplete with respect to the CPS transformation and with respect to semantic models.
Reference: [25] <author> Talcott, C. </author> <title> A theory for program and data specification. </title> <booktitle> In Proc. Design and implementation of Symbolic Computation Systems, </booktitle> <address> DISCO'90 (Berlin, </address> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science 429, </booktitle> <pages> pp. 91-100. </pages> <note> To appear in Theor. </note> <institution> Comput. Sci. </institution> <year> 1992. </year>
Reference-contexts: The rest follows from Theorem 4.3. 5 Related Work Our work must be compared to the two prominent theories for reasoning about languages with control operators: the v -C-calculus [6, 9, 8] and the theory IOCC <ref> [24, 25] </ref>. The v -C-calculus is an equational theory that approximates our calculus. The theory includes enough axioms to reason about the evaluation of programs but is incomplete with respect to the CPS transformation and with respect to semantic models.
References-found: 25

