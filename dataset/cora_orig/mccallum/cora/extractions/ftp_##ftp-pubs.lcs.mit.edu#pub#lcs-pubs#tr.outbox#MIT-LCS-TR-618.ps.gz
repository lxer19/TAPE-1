URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-618.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Observing "True" Concurrency  
Author: by Lalita Jategaonkar Albert R. Meyer 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy at the  Signature of Author  Certified by  Professor of Engineering Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology  
Date: (1989)  (1989)  September 1993  1993  July 30, 1993  
Affiliation: S.B., Electrical Engineering and Computer Science Massachusetts Institute of Technology  S.M., Electrical Engineering and Computer Science Massachusetts Institute of Technology  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  Hitachi America  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. Aceto and U. Engberg. </author> <title> Failure semantics for a simple process language with refinement. </title> <type> Technical report, </type> <institution> INRIA, Sophia-Antipolis, </institution> <year> 1991. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> Furthermore, since r 00 3.2. SOME COMPOSITIONAL SEMANTICS FOR WT NETS AND OPERATORS 41 is a run of N , all places in the preset of transition r [w [k + 1]] must be marked after the run r [w <ref> [1] </ref>] : : :r [w [k]]. The definition of static concurrency implies that no firing of transition r [w [k]] can add any tokens to the preset of transition r [w [k +1]]; thus, transition r [w [k +1]] must be enabled after the run r [w [1]] : : :r <p> run r [w <ref> [1] </ref>] : : :r [w [k]]. The definition of static concurrency implies that no firing of transition r [w [k]] can add any tokens to the preset of transition r [w [k +1]]; thus, transition r [w [k +1]] must be enabled after the run r [w [1]] : : :r [w [k 1]] as well. Conversely, all places in the preset of transition r [w [k]] must be marked after the run r [w [1]] : : :r [w [k 1]]. <p> the preset of transition r [w [k +1]]; thus, transition r [w [k +1]] must be enabled after the run r [w <ref> [1] </ref>] : : :r [w [k 1]] as well. Conversely, all places in the preset of transition r [w [k]] must be marked after the run r [w [1]] : : :r [w [k 1]]. The definition of static concurrency implies that no firing of transition r [w [k + 1]] can remove any tokens from the preset of r [w [k]]; thus, r [w [k]] must be enabled after the run r [w [1]] : : :r [w <p> the run r [w <ref> [1] </ref>] : : :r [w [k 1]]. The definition of static concurrency implies that no firing of transition r [w [k + 1]] can remove any tokens from the preset of r [w [k]]; thus, r [w [k]] must be enabled after the run r [w [1]] : : :r [w [k 1]]r [w [k + 1]] as well. It then follows easily that r [w [1]] : : :r [w [k 1]]r [w [k + 1]]r [w [k]] is a run of N reaching the same final marking as the run r [w [1]] : : <p> of transition r [w [k + 1]] can remove any tokens from the preset of r [w [k]]; thus, r [w [k]] must be enabled after the run r [w <ref> [1] </ref>] : : :r [w [k 1]]r [w [k + 1]] as well. It then follows easily that r [w [1]] : : :r [w [k 1]]r [w [k + 1]]r [w [k]] is a run of N reaching the same final marking as the run r [w [1]] : : :r [w [k1]]r [w [k]]r [w [k+1]], from which the lemma follows easily. <p> r [w <ref> [1] </ref>] : : :r [w [k 1]]r [w [k + 1]] as well. It then follows easily that r [w [1]] : : :r [w [k 1]]r [w [k + 1]]r [w [k]] is a run of N reaching the same final marking as the run r [w [1]] : : :r [w [k1]]r [w [k]]r [w [k+1]], from which the lemma follows easily. Our definition of "pomset-failures" is a natural generalization of (sequential) "failures" in that it associates "failure sets" to finite pomsets. <p> We then obtain r 00 by "padding" v with sequences w i of hidden transition-occurrences of r 0 ; each composite sequence w 1 : : : w i will contain exactly the hidden transition-occurrences of r 0 that are necessary for the v <ref> [1] </ref>; : : : ; v [i] to fire. In order to define the w i , we first define z i , for 1 i k, to be the ascending sequence of indices of the "remaining" hidden transition-occurrences that causally precede r 0 [I (vis r (i))].
Reference: [2] <author> L. Aceto and M. Hennessy. </author> <title> Towards action-refinement in process algebras. </title> <booktitle> In Proceedings, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 138-145. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> ig z k+1 = the ascending sequence over the set fj jr 0 j : r 0 [j] is a hidden transition and j 6&lt; q 0 I (vis r (n)) for all n kg We then define r 00 to be the sequence w 1 v [1]w 2 v <ref> [2] </ref> : : : v [k]w k+1 , where each w i is the sequence of transition-occurrences of r 0 corresponding to z i ; that is, jw i j = jz i j and w i [n] = r 0 [z i [n]] for all 1 n jz i j.
Reference: [3] <author> L. Aceto and M. Hennessy. </author> <title> Adding action refinement to a finite process algebra. </title> <booktitle> In Proceedings of ICALP '91, Volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 506-519, </pages> <year> 1991. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> Chapter 7 Other Results, Open Problems, and Future Work There is not yet a consensus on what an action refinement operator should be. For example, our action refinement operator and that of [47] are tuned to a CSP-style synchronization-with-restriction, while those of <ref> [3, 20] </ref> are tuned to a CCS-style synchronization-by-hiding-complementary-actions. In this regard, an action-refinement theory closely related to ours has been proposed by Hennessy [20]. His theory incorporates an interesting, and in certain respects more powerful, action refinement operation, and he has compositionality and full abstraction results similar to ours.
Reference: [4] <author> C. Alvarez, B. J., J. Gabarro, and M. </author> <title> Santa. Parallel complexity in the design and analysis of concurrent systems. </title> <booktitle> In Proceedings of PARLE '91, Volume 505 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 288-303, </pages> <year> 1991. </year>
Reference-contexts: elements are definable as the meanings of WT Nets, and all of our operators are continuous functions. 1.3 Deciding True Concurrency Equivalences The decision problem for finite-state concurrent processes under a variety of interleaving semantics has been widely studied in the literature, and the computation complexity has been tightly characterized <ref> [4, 26, 29, 34, 36] </ref>. In contrast, there have been essentially no results on the complexity of the decision problems for true concurrency equivalences on finite-state concurrent processes, and little is even known about the decidability of these equivalences. <p> ACTION REFINEMENT Chapter 6 Deciding True Concurrency Equivalences 6.1 Introduction The computational complexity of the equivalence problem for nondeterministic finite-state automata under a variety of standard process semantics has been tightly characterized. In particular, trace equivalence and failure equivalence [8] are pspace-complete [26], while bisimulation [30] is ptime-complete <ref> [4, 26] </ref>. It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete [29, 34] and bisimulation of these nets is dexptime-complete [36].
Reference: [5] <author> E. Best, R. Devillers, A. Kiehn, and L. Pomello. </author> <title> Concurrent bisimulations in Petri Nets. </title> <journal> Acta Inf., </journal> <volume> 28 </volume> <pages> 231-264, </pages> <year> 1991. </year>
Reference-contexts: One of the main results of this thesis is that pomset-trace equivalence is decidable for finite 1-safe Petri Nets, and is, in fact, complete for expspace. Furthermore, we show that the decision problem for history-preserving bisimulation <ref> [5, 35, 39, 44, 46] </ref> on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler [46] to be decidable; however, he left open its complexity. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation <ref> [5, 35, 39, 50, 46] </ref> and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation <ref> [5, 35, 39, 50, 46] </ref> Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime <p> HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. We begin by defining history-preserving bisimulation on nets. Our definition induces the same equivalence as that of <ref> [5, 35, 39, 50, 46] </ref>. Definition 6.3.1 A set H of triples of the form (r; r 0 ; f ) is a history-preserving bisimulation between nets N and N 0 iff 1.
Reference: [6] <author> G. Boudol and I. Castellani. </author> <title> On the semantics of concurrency: Partial orders and transition systems. </title> <booktitle> In Proceedings of TAPSOFT '87, Volume 249 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 123-137, </pages> <year> 1987. </year>
Reference-contexts: 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation <ref> [6] </ref> dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime decision procedure for history-preserving bisimulation. <p> We now define pomset-bisimulation. Our definition induces the same equivalence as that of <ref> [6, 39, 50] </ref>. Definition 6.3.5 A set P of pairs of the form (M; M 0 ) is a pomset-bisimulation between nets N and N 0 iff 1.
Reference: [7] <author> S. Brookes. </author> <title> A Model for Communicating Systems. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1984. </year>
Reference-contexts: Except for the parallel composition operators, all of our net operations are closely related to the corresponding CCS/CSP operators on labeled transition systems (lts's), cf. <ref> [7, 30] </ref>. In particular: 2.2. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence [19, 30] and failures equivalence <ref> [7, 8, 9, 21] </ref>. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions.
Reference: [8] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> J. ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: In particular, the state machines of Figure 1-2 are distinguished by all the state-machine based process equivalences in the literature, including bisimulation equivalence (CCS) [30], partial-trace equivalence, failures equivalence (CSP) <ref> [8, 9] </ref>, and Hennessy's Testing-equivalence [19], an elegant experimental justification for partial-traces and failures. We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. <p> Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. In particular, his semantics consists of "interval pomset-failures": namely, pomset-traces with a certain "interval" order, paired with "failure sets" <ref> [8, 9, 21] </ref>. Vogler's elegant insight is that pomset-failures are not compositional for split refinements, since these refinements reveal "failure sets" of nets when transitions have "half-fired": that is, when all tokens have been removed from the preset of the transition but no tokens have been added to the postset. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence [19, 30] and failures equivalence <ref> [7, 8, 9, 21] </ref>. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions. <p> SEMANTICS OF WELL-TERMINATING NETS We then define: split (a;a + ;a ) (p) def = fsplit (a;a + ;a ;H) (p) : H fx 2 max (p) : l p (x) = agg Our definition of k A on pomsets generalizes that of <ref> [8, 21] </ref> on sequences of actions. In particular, we are careful to prohibit synchronizations between pairs of actions that introduce too many ordering constraints and hence violate anti-symmetry of the partial orders. <p> We prove the case for hiding on D MUST Act , from which the proof for CCS-style parallel composition follows easily. The proof for hiding is a generalization of that in <ref> [8] </ref> for failures semantics, and uses the following lemma: Lemma 4.2.18 Let hq; D q i be a pomset-divergence over a finite alphabet Act, let a 2 Act, and let P DS = fhp n ; D n i : n 0g be an infinite set of pomset-divergences such that hp <p> ACTION REFINEMENT Chapter 6 Deciding True Concurrency Equivalences 6.1 Introduction The computational complexity of the equivalence problem for nondeterministic finite-state automata under a variety of standard process semantics has been tightly characterized. In particular, trace equivalence and failure equivalence <ref> [8] </ref> are pspace-complete [26], while bisimulation [30] is ptime-complete [4, 26].
Reference: [9] <author> S. D. Brookes and A. W. Roscoe. </author> <title> An improved failures model for communicating processes. </title> <booktitle> In Seminar on Concurrency, Volume 197 of Lecture Notes in Computer Science, </booktitle> <pages> pages 281-305, </pages> <year> 1984. </year>
Reference-contexts: In particular, the state machines of Figure 1-2 are distinguished by all the state-machine based process equivalences in the literature, including bisimulation equivalence (CCS) [30], partial-trace equivalence, failures equivalence (CSP) <ref> [8, 9] </ref>, and Hennessy's Testing-equivalence [19], an elegant experimental justification for partial-traces and failures. We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. <p> In a seminal paper [47], Vogler has developed a semantics for labeled, 1-safe Petri Nets that is compositional for certain simple "split" and "choice" refinements, and indeed is fully abstract for failures semantics <ref> [9] </ref> and Hennessy's must-experiments [19]. Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. [9, 19, 21, 30]). <p> Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. <ref> [9, 19, 21, 30] </ref>). Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. <p> Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. In particular, his semantics consists of "interval pomset-failures": namely, pomset-traces with a certain "interval" order, paired with "failure sets" <ref> [8, 9, 21] </ref>. Vogler's elegant insight is that pomset-failures are not compositional for split refinements, since these refinements reveal "failure sets" of nets when transitions have "half-fired": that is, when all tokens have been removed from the preset of the transition but no tokens have been added to the postset. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence [19, 30] and failures equivalence <ref> [7, 8, 9, 21] </ref>. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions. <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures <ref> [9] </ref> Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace <p> Trace equivalence of finite-state automata is checkable in space proportional to the size of the automata [26], while bisimulation equivalence is checkable in ptime [26], as are delay bisimulation and branching bisimulation [17]. The decision procedure for divergence-respecting failures equivalence <ref> [9] </ref> of finite-state automata is a straightforward generalization of Kannelakis&Smolka's pspace decision procedure for divergence-blind failures equivalence.
Reference: [10] <author> L. Castellano, G. De Michelis, and L. Pomello. </author> <title> Concurrency vs. interleaving: an instructive example. </title> <journal> Bulletin of the European Association of Theoretical Computer Science, </journal> <volume> 31 </volume> <pages> 12-15, </pages> <year> 1987. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> It is well-known <ref> [10] </ref> that these equivalences, including partial traces, failures, bisim-ulation, and Testing-equivalence, are not compositional for even very simple forms of action refinement on Petri Nets, including those whose only effect is to "split" actions into two parts. <p> Proof. It follows easily from Definition 3.1.3 and Proposition 3.1.4 that if any two divergence-free WT Nets are trace inequivalent then they are may-inequivalent, must-inequivalent, and Testing-inequivalent. To prove the proposition, we repeat the example given in <ref> [10] </ref>, and illustrated in Figure 3-1. It is easy to show that hN 1 ; Acti and hN 2 ; Acti of Figure 3-1 are Testing-equivalent.
Reference: [11] <author> A. Chandra and L. Stockmeyer. </author> <title> Alternation. </title> <booktitle> In Proceedings of the Seventeenth Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 98-108, </pages> <year> 1976. </year>
Reference-contexts: Proof. Let A be an alternating Turing Machine that, for some polynomial p, uses p (n) space on input of size n. A well-known property of polynomial-space alternating Turing Machines is that every computation halts in deterministic time exponential in the size of the input <ref> [11, 27] </ref>. Let p 0 (n) be so large that 2 p 0 (n) exceeds the time bound of A on input of size n, and let be the finite tape alphabet of A. <p> LOWER BOUNDS 147 It is well-known that the class of problems decidable in polynomial space by alternating Turing Machines is the same as the class of problems decidable in deterministic exponential time by ordinary Turing Machines <ref> [11, 27] </ref>. We then have as a simple corollary of this fact and Theorem 6.5.7: Theorem 6.5.8 Bisimulation of finite nets is dexptime-hard. We now show the lower bounds for the remaining equivalences listed in Table 6.1.
Reference: [12] <author> F. Cherief and P. Schnoebelen. </author> <title> t -bisimulations and full abstraction for the refinement of actions. </title> <journal> Information Processing Letters, </journal> <volume> 40 </volume> <pages> 219-222, </pages> <year> 1991. </year> <note> 151 152 BIBLIOGRAPHY </note>
Reference-contexts: We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. Moreover, trace equivalence, failures equivalence, Testing-equivalence, and intuitively simple variations of bisimulation, notably delay bisimula-tion and branching bisimulation <ref> [12, 13, 43] </ref> are sound techniques for reasoning about action refinement on purely sequential processes. However, since all of these equivalences identify concurrent actions with interleaved actions, none of them are sound for reasoning about action refinement on concurrent processes.
Reference: [13] <author> R. Devillers. </author> <title> Maximality preserving bisimulation. </title> <journal> Theor. Comput. Sci., </journal> <volume> 102(1) </volume> <pages> 165-184, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. Moreover, trace equivalence, failures equivalence, Testing-equivalence, and intuitively simple variations of bisimulation, notably delay bisimula-tion and branching bisimulation <ref> [12, 13, 43] </ref> are sound techniques for reasoning about action refinement on purely sequential processes. However, since all of these equivalences identify concurrent actions with interleaved actions, none of them are sound for reasoning about action refinement on concurrent processes. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation <ref> [13, 50] </ref> for finite 1-safe Petri nets; however, their complexity remained open. <p> ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation <ref> [13] </ref> Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime decision procedure for history-preserving bisimulation. <p> The desired upper bound then follows by Theorem 6.4.1. Using the decision procedure for history-preserving bisimulation, a similar result holds for maximality-preserving bisimulation <ref> [13] </ref>: Theorem 6.4.5 For finite nets that may contain hidden transitions, the maximality-preserving bisimulation problem can be decided in deterministic time exponential in the number of places and transitions in the nets. Proof.
Reference: [14] <author> P. Fishburn. </author> <title> Intransitive indifference with unequal indifference intervals. </title> <journal> Journal of Mathematical Psychology, </journal> <volume> 7 </volume> <pages> 144-149, </pages> <year> 1970. </year>
Reference-contexts: A pomset p is an interval pomset iff p is an interval ordering. It is well-known (cf. <ref> [14] </ref>) that: Lemma 3.3.2 ([14]) Every interval ordering, p , is order-isomorphic to a set of intervals of the real line, where by definition, (interval w) &lt; (interval x) iff every point in (interval w) strictly precedes every point in (interval x). 68 CHAPTER 3.
Reference: [15] <author> U. Goltz. </author> <title> CCS and Petri nets. </title> <type> Technical report, </type> <institution> GMD, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: = post N 1 (t) post P ((fl; t)) = post N 2 (t) l P ((t 1 ; t 2 )) = l N 1 (t 1 ) l P ((fl; t)) = l N 2 (t) Start P = Start N 1 [ Start N 2 Similar to <ref> [15] </ref>, we also have a CCS-style parallel composition operator j, where two nets are placed in parallel and are allowed to perform hidden synchronizations on all complemen tary actions a; a; however, they must (visibly) synchronize on the p action. Our definition is illustrated in Figure 2-5. <p> As discussed in [42], one technical complication arises due to initially marked places that have incoming transitions, and in general, we apply a start-unwinding operator on nets before doing the above construction. Our start-unwinding operator, illustrated in Figure 2-8, is essentially the same as that of <ref> [15, 42] </ref> and produces a net that is "essentially the same" 1 as the original net, except that all initially marked places have empty presets. The "start-unwound" net is identical to the original net whenever all initially marked places of the original net have empty presets.
Reference: [16] <author> R. Gorrieri. </author> <title> Refinement, Atomicity, and Transactions for Process Description Languages. </title> <type> PhD thesis, </type> <institution> University of Pisa, </institution> <year> 1991. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions.
Reference: [17] <author> J. Groote and F. Vaandrager. </author> <title> An efficient algorithm for branching bisimulation and stuttering equivalence. </title> <booktitle> In Proceedings of ICALP '90, </booktitle> <year> 1990. </year>
Reference-contexts: Trace equivalence of finite-state automata is checkable in space proportional to the size of the automata [26], while bisimulation equivalence is checkable in ptime [26], as are delay bisimulation and branching bisimulation <ref> [17] </ref>. The decision procedure for divergence-respecting failures equivalence [9] of finite-state automata is a straightforward generalization of Kannelakis&Smolka's pspace decision procedure for divergence-blind failures equivalence.
Reference: [18] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <booktitle> Series on Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year> <pages> 419 pp. </pages>
Reference-contexts: In order to prove these properties, we give an abstract characterization of each of our spaces of process meanings. These results together provide a semantic foundation for inductive (fixed-point) reasoning about recursively-defined processes in the standard manner (cf. <ref> [18, 19] </ref>). We also prove in this chapter that all our semantic domains are algebraic cpo's, in the sense that all elements are fully determined by the compact (finitely-specified) elements that approximate them. Furthermore, all compact elements of these cpo's are definable as the meanings of WT Nets. <p> These results, although technically rather hard, are important because they guarantee that our full abstraction results from Chapter 3 will continue to hold for recursively-defined processes. 4.1 Standard Definitions We begin with some standard definitions about algebraic complete partial orders and continuous functions, cf., <ref> [18, 19] </ref>. Definition 4.1.1 A partial order is a pair hD; v D i, where D is a set and v D is a binary relation on D that is reflexive, anti-symmetric, and transitive. <p> It is called the least fixed point if, in addition, x v D y for every fixed point y of f . The following well-known theorem ensures that complete partial orders and continuous functions support fixed point reasoning about recursively-defined processes, cf., <ref> [18, 19] </ref> for the proof. Theorem 4.1.4 (standard) Let hD; v D i be a cpo and let f : D!D be a continuous function. <p> Then D MAY Act , D MUST Act , and D TEST Act are algebraic cpo's. The theorem is a simple consequence of the definition of compact elements, Lemma 4.2.11, and Lemma 4.2.12 (cf. <ref> [18] </ref>). 90 CHAPTER 4. <p> Proof. Let hP T; Acti be a compact element of D MAY Act . As a simple consequence of Lemma 4.2.12 and the definition of compactness (cf. <ref> [18] </ref>), hP T; Acti is a finite candidate of D MAY Act . Thus, P T is finite set of pomsets over Act. <p> Proof. Let hP F; P D; Acti be a compact element of D MUST Act . As a simple consequence of Lemma 4.2.12 and the definition of compactness (cf. <ref> [18] </ref>), hP F; P D; Acti is a finite candidate of D MUST Act . <p> Proof. Let hhP T; Acti; hP F; P D; Actii be a compact element of D TEST Act . As a simple consequence of Lemma 4.2.12 and the definition of compactness (cf. <ref> [18] </ref>), hhP T; Acti; hP F; P D; Actii is a finite candidate of D TEST Act . Thus, hP T; Acti is a finite candidate of D MAY Act and hP F; P D; Acti is a finite candidate of D MUST Act . <p> We now have: Theorem 4.3.10 Let Act be a finite alphabet containing p Act ffl; gg [ f ; flg. Then D MUST-split-fl Act 0 and D TEST-split-fl Act;Act 0 are algebraic cpo's. The theorem is a simple consequence of Lemma 4.3.8 and Lemma 4.3.9 (cf. <ref> [18] </ref>). We now show that all compact elements are definable as the meanings of WT Nets: Theorem 4.3.11 Let Act be a finite alphabet containing p 0 Act ffl; gg [ f ; flg. <p> Proof. For the first case, let hP F; P D; Act 0 i be a compact element of D MUST Act . As a simple consequence of Lemma 4.3.9 and the definition of compactness (cf. <ref> [18] </ref>), hP F; P D; Act 0 i is a finite candidate of D MUST-split-fl Act 0 . <p> Then D MAY-intvl Act , D MUST-intvl-fl Act 0 , and D TEST-intvl-fl Act;Act 0 are algebraic cpo's. The theorem is a simple consequence of the definition of compact elements and Lemma 4.4.7 and Lemma 4.4.8 (cf. <ref> [18] </ref>). Theorem 4.4.10 Let Act be a finite alphabet containing p Act ffl; gg [ f ; flg. For every compact element hP T; Acti 2 D MAY-intvl Act , there is some WT Net hN 1 ; Acti with [[hN 1 ; Acti]] MAY intvl = hP T; Acti.
Reference: [19] <author> M. C. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <booktitle> Series on Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year> <pages> 272 pp. </pages>
Reference-contexts: In particular, the state machines of Figure 1-2 are distinguished by all the state-machine based process equivalences in the literature, including bisimulation equivalence (CCS) [30], partial-trace equivalence, failures equivalence (CSP) [8, 9], and Hennessy's Testing-equivalence <ref> [19] </ref>, an elegant experimental justification for partial-traces and failures. We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. <p> In a seminal paper [47], Vogler has developed a semantics for labeled, 1-safe Petri Nets that is compositional for certain simple "split" and "choice" refinements, and indeed is fully abstract for failures semantics [9] and Hennessy's must-experiments <ref> [19] </ref>. Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. [9, 19, 21, 30]). <p> Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. <ref> [9, 19, 21, 30] </ref>). Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. <p> We describe a similar fully abstract semantics, [[]] MAY intvl , for may-equivalence <ref> [19] </ref> based on "pomset-traces"; the may- and must-semantics together provide a fully abstract semantics for Testing Equivalence [19]. Our semantics greatly simplify Vogler's representation by avoiding "half-fired" events; fur thermore, keeping track of concurrent divergences simplifies the closure operations and yields compositionality of the [[]] MUST split-fl semantics. <p> We describe a similar fully abstract semantics, [[]] MAY intvl , for may-equivalence <ref> [19] </ref> based on "pomset-traces"; the may- and must-semantics together provide a fully abstract semantics for Testing Equivalence [19]. Our semantics greatly simplify Vogler's representation by avoiding "half-fired" events; fur thermore, keeping track of concurrent divergences simplifies the closure operations and yields compositionality of the [[]] MUST split-fl semantics. This generalizes Vogler's results and solves the open problem mentioned earlier. <p> In order to view WT Nets as an operational model for CCS and CSP, we will find it useful to represent the behavior of nets as labeled transition systems. The following definition is standard and is essentially taken verbatim from <ref> [19] </ref>. Definition 2.1.4 A labeled transition system (lts) is a triple hS; Act; !; s init i, where * S is a set of states containing s init . * Act is a set of labels. 2.2. <p> Chapter 3 Semantics of Well-Terminating Nets 3.1 Testing Equivalence This chapter develops some semantics for WT Nets that are compositional for all the WT Net operators presented in Chapter 2 and are respectively adequate for may-equivalence, must-equivalence, and Testing Equivalence <ref> [19] </ref>. Some fully abstract versions of these semantics are then presented. Definition 3.1.1 A semantics, [[]], assigning to any process, P , a meaning, [[P ]], is compositional for an operator on processes if semantic equality is a congruence for the operator, i.e., the operator preserves semantic equality. <p> We presume that the reader is familiar with the experiment-based theory of may-equivalence, must-equivalence, and Testing equivalence on labeled transition systems developed in <ref> [19] </ref>. In order to keep this thesis relatively self-contained, we repeat the basic definitions here. The idea behind experiment-based testing is that experimenters are given the ability to interact with processes in a way that affects both the process and the experimenter. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence <ref> [19, 30] </ref> and failures equivalence [7, 8, 9, 21]. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions. <p> The proof is a straightforward generalization of that in <ref> [19] </ref> and is left to the reader. As shown in [19], may-equivalence, must-equivalence, and Testing-equivalence are compositional for all the standard CCS/CSP operators on labeled transition systems. Furthermore, they are compositional for (the natural definition of) choice refinements on labeled transition systems. <p> The proof is a straightforward generalization of that in <ref> [19] </ref> and is left to the reader. As shown in [19], may-equivalence, must-equivalence, and Testing-equivalence are compositional for all the standard CCS/CSP operators on labeled transition systems. Furthermore, they are compositional for (the natural definition of) choice refinements on labeled transition systems. <p> Similar properties hold for WT Nets: Proposition 3.1.5 may-equivalence, must-equivalence, and Testing-equivalence on WT Nets are compositional for all our CCS/CSP-style operators, choice refinements, and alphabet expansion and shrinking. The proof is analogous to that of <ref> [19] </ref> and is omitted. Since labeled transition systems are inherently sequential, these equivalences are also compositional for (the natural definition of) split refinements on labeled transition systems. <p> Thus, it is an immediate consequence of Theorem 3.3.11 and the definitions of the semantics that [[]] MAY , [[]] MUST split-fl , and [[]] TEST split-fl cannot be fully abstract. In addition to process equivalence under experiments, Hennessy <ref> [19] </ref> presents a natural form of may-, must-, or Testing-approximation, in which a process, p, is said to may-approximate 3.3. <p> In order to prove these properties, we give an abstract characterization of each of our spaces of process meanings. These results together provide a semantic foundation for inductive (fixed-point) reasoning about recursively-defined processes in the standard manner (cf. <ref> [18, 19] </ref>). We also prove in this chapter that all our semantic domains are algebraic cpo's, in the sense that all elements are fully determined by the compact (finitely-specified) elements that approximate them. Furthermore, all compact elements of these cpo's are definable as the meanings of WT Nets. <p> These results, although technically rather hard, are important because they guarantee that our full abstraction results from Chapter 3 will continue to hold for recursively-defined processes. 4.1 Standard Definitions We begin with some standard definitions about algebraic complete partial orders and continuous functions, cf., <ref> [18, 19] </ref>. Definition 4.1.1 A partial order is a pair hD; v D i, where D is a set and v D is a binary relation on D that is reflexive, anti-symmetric, and transitive. <p> It is called the least fixed point if, in addition, x v D y for every fixed point y of f . The following well-known theorem ensures that complete partial orders and continuous functions support fixed point reasoning about recursively-defined processes, cf., <ref> [18, 19] </ref> for the proof. Theorem 4.1.4 (standard) Let hD; v D i be a cpo and let f : D!D be a continuous function.
Reference: [20] <author> M. C. Hennessy. </author> <title> Concurrent testing of processes. </title> <booktitle> In Proceedings of CONCUR '92, Volume 630 of Lecture Notes in Computer Science, </booktitle> <pages> pages 94-107, </pages> <year> 1992. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> Chapter 7 Other Results, Open Problems, and Future Work There is not yet a consensus on what an action refinement operator should be. For example, our action refinement operator and that of [47] are tuned to a CSP-style synchronization-with-restriction, while those of <ref> [3, 20] </ref> are tuned to a CCS-style synchronization-by-hiding-complementary-actions. In this regard, an action-refinement theory closely related to ours has been proposed by Hennessy [20]. His theory incorporates an interesting, and in certain respects more powerful, action refinement operation, and he has compositionality and full abstraction results similar to ours. <p> For example, our action refinement operator and that of [47] are tuned to a CSP-style synchronization-with-restriction, while those of [3, 20] are tuned to a CCS-style synchronization-by-hiding-complementary-actions. In this regard, an action-refinement theory closely related to ours has been proposed by Hennessy <ref> [20] </ref>. His theory incorporates an interesting, and in certain respects more powerful, action refinement operation, and he has compositionality and full abstraction results similar to ours.
Reference: [21] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1985. </year> <pages> 256 pp. </pages>
Reference-contexts: Introduction In concurrent process theory, processes are often represented by state machines and Petri Nets. State machines, by definition, have no explicit representation of concurrency, and they identify concurrent actions with sequential, interleaved actions. Process theories based on state machines, exemplified by Milner's CCS [30] and Hoare's CSP <ref> [21] </ref>, typically have associated combinators for composing large processes from smaller components, compositional techniques for reasoning about processes through reasoning about their components, sound and complete techniques for reasoning about process equivalence, and algorithms for deciding equivalence of finite-state processes. <p> Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. <ref> [9, 19, 21, 30] </ref>). Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. <p> Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. In particular, his semantics consists of "interval pomset-failures": namely, pomset-traces with a certain "interval" order, paired with "failure sets" <ref> [8, 9, 21] </ref>. Vogler's elegant insight is that pomset-failures are not compositional for split refinements, since these refinements reveal "failure sets" of nets when transitions have "half-fired": that is, when all tokens have been removed from the preset of the transition but no tokens have been added to the postset. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence [19, 30] and failures equivalence <ref> [7, 8, 9, 21] </ref>. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions. <p> SEMANTICS OF WELL-TERMINATING NETS We then define: split (a;a + ;a ) (p) def = fsplit (a;a + ;a ;H) (p) : H fx 2 max (p) : l p (x) = agg Our definition of k A on pomsets generalizes that of <ref> [8, 21] </ref> on sequences of actions. In particular, we are careful to prohibit synchronizations between pairs of actions that introduce too many ordering constraints and hence violate anti-symmetry of the partial orders.
Reference: [22] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages, and computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: It is easy to construct another finite-state automaton, of essentially the same size, recognizing the runs of N . So N v pt N 0 iff these automata recognize the same language. But language equivalence is checkable in space proportional to the size of the automata <ref> [22] </ref>. 6.2.2 Nets with Hidden Transitions We now show how the results above extend to nets which may contain hidden transitions. We begin by modifying our definition of "synchronous" to take account of hidden transitions. This new definition will coincide with Definition 6.2.5 for nets without hidden transitions. <p> Proof. Since, language equivalence of automata with "-moves is decidable in space proportional to the size of the automata <ref> [22] </ref>, the proof of the theorem is identical to that of Theorem 6.2.18, except that it uses Lemma 6.2.20 and Corollary 6.2.32. 6.3. HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. <p> So (M; M 0 ) 2 P i+1 iff each of the two appropriate pairs of automata recognize the same language. Since language equivalence is checkable in space proportional to the size of the automata <ref> [22] </ref>, each P i can be computed in space exponential in the size of N and N 0 , and hence so can P k . 6.4.
Reference: [23] <author> L. Jategaonkar and A. R. Meyer. </author> <title> Testing equivalence for Petri nets with action refinement. </title> <booktitle> In Proceedings of CONCUR '92, Volume 630 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 17-31, </pages> <year> 1992. </year>
Reference-contexts: This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces <ref> [23, 47] </ref> Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces <ref> [23, 39, 47] </ref> Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces <ref> [23, 47] </ref> Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, <p> The decision procedures for most of the other true concurrency equivalences in Table 6.1 then follow from reductions to the corresponding interleaving equivalences, which are part of known full abstraction proofs <ref> [23, 25, 47, 49] </ref>. Theorem 6.4.2 For finite nets that may contain hidden transitions, the step-trace equivalence problem and the step-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets. <p> Proof. By known full abstraction results <ref> [23, 47] </ref>, there is a context C [] built from split and choice refinements such that nets N and N 0 are interval-pomset-trace equivalent or interval-pomset-failures equivalent iff the nets C [N ] and C [N 0 ] are respectively trace equivalent or failures equivalent. <p> Each of these nets will have exactly one -labeled transition, and the post-set of this transition will be empty. The translation, net, uses net operators defined in <ref> [23] </ref>; we do not repeat the definitions here. However, we slightly modify the internal choice operator presented there to ensure that the resulting nets always have exactly one p -labeled transition. <p> An open problem is the decidability and complexity of augmentation-closed pomset-trace equivalence. Another open problem that we regard as especially significant is the decidability and complexity of our earlier general pomset-failures semantics <ref> [23] </ref>, which keeps track of concurrent divergences. We are currently working to extend our methods to handle these cases. Chapter 7 Other Results, Open Problems, and Future Work There is not yet a consensus on what an action refinement operator should be.
Reference: [24] <author> L. Jategaonkar and A. R. Meyer. </author> <title> Deciding true concurrency equivalences on finite safe nets. </title> <booktitle> In Proceedings of ICALP '93, Volume 700 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 519-531, </pages> <year> 1993. </year>
Reference: [25] <author> L. Jategaonkar and A. R. Meyer. </author> <title> Self-synchronization of concurrent processes. </title> <booktitle> In Proceedings of LICS '93, </booktitle> <pages> pages 409-417, </pages> <year> 1993. </year>
Reference-contexts: We use a similar partial order, but instead of places, we find it technically smoother to keep track of the partial ordering between the most-recent firings of transitions. This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: <p> DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation <ref> [25, 39] </ref> Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper <p> The decision procedures for most of the other true concurrency equivalences in Table 6.1 then follow from reductions to the corresponding interleaving equivalences, which are part of known full abstraction proofs <ref> [23, 25, 47, 49] </ref>. Theorem 6.4.2 For finite nets that may contain hidden transitions, the step-trace equivalence problem and the step-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets. <p> Furthermore, the step-bisimulation problem can be decided in deterministic time exponential in the number of places and transitions in the nets. Proof. By a known full abstraction result <ref> [25] </ref>, there is a context C [] involving only a self-synchronization operator [25] such that nets N and N 0 are step-trace, step-failures, or step-bisimulation equivalent iff the nets C [N ] and C [N 0 ] are respectively trace equivalent, failures equivalent, or bisimulation equivalent. <p> Furthermore, the step-bisimulation problem can be decided in deterministic time exponential in the number of places and transitions in the nets. Proof. By a known full abstraction result <ref> [25] </ref>, there is a context C [] involving only a self-synchronization operator [25] such that nets N and N 0 are step-trace, step-failures, or step-bisimulation equivalent iff the nets C [N ] and C [N 0 ] are respectively trace equivalent, failures equivalent, or bisimulation equivalent. <p> As a result, Hennessy forbids some simple action refinements like (a j b)[a:=c; b:=c]. We have explored the connection between Hennessy's and our theories of action refinement in <ref> [25] </ref>. In particular, [25] presents a new operator of self-synchronization, which allows concurrent transitions within a process to synchronize, and shows that self-synchronization provides a tight connection between our action refinement operator and Hennessy's communicating action refinement operator. <p> As a result, Hennessy forbids some simple action refinements like (a j b)[a:=c; b:=c]. We have explored the connection between Hennessy's and our theories of action refinement in <ref> [25] </ref>. In particular, [25] presents a new operator of self-synchronization, which allows concurrent transitions within a process to synchronize, and shows that self-synchronization provides a tight connection between our action refinement operator and Hennessy's communicating action refinement operator. Furthermore, self-synchronization can detect "steps" of concurrent actions, and hence non-interleaving semantics are not compositional.
Reference: [26] <author> P. Kannelakis and S. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Inf. Comput., </journal> <volume> 86(1) </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference-contexts: elements are definable as the meanings of WT Nets, and all of our operators are continuous functions. 1.3 Deciding True Concurrency Equivalences The decision problem for finite-state concurrent processes under a variety of interleaving semantics has been widely studied in the literature, and the computation complexity has been tightly characterized <ref> [4, 26, 29, 34, 36] </ref>. In contrast, there have been essentially no results on the complexity of the decision problems for true concurrency equivalences on finite-state concurrent processes, and little is even known about the decidability of these equivalences. <p> ACTION REFINEMENT Chapter 6 Deciding True Concurrency Equivalences 6.1 Introduction The computational complexity of the equivalence problem for nondeterministic finite-state automata under a variety of standard process semantics has been tightly characterized. In particular, trace equivalence and failure equivalence [8] are pspace-complete <ref> [26] </ref>, while bisimulation [30] is ptime-complete [4, 26]. <p> ACTION REFINEMENT Chapter 6 Deciding True Concurrency Equivalences 6.1 Introduction The computational complexity of the equivalence problem for nondeterministic finite-state automata under a variety of standard process semantics has been tightly characterized. In particular, trace equivalence and failure equivalence [8] are pspace-complete [26], while bisimulation [30] is ptime-complete <ref> [4, 26] </ref>. It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete [29, 34] and bisimulation of these nets is dexptime-complete [36]. <p> We observe that k is easily bounded by an exponential in the sizes of N and N 0 . It is also easy to check that G k can be computed in dexptime in the size of N and N 0 (using a transitive closure technique as in <ref> [26] </ref> to calculate the existence of a *-pair-sequence w). <p> DECIDING OTHER TRUE CONCURRENCY EQUIVALENCES 139 6.4 Deciding Other True Concurrency Equivalences Since the transition system of a net is a finite-state automaton, the decision procedures for the interleaving trace, failure and bisimulation equivalences for nets follow directly from the results of Kanellakis&Smolka <ref> [26] </ref> for finite-state automata. <p> By definition, the finite nets are trace, failures, or bisimulation equivalent iff these finite-state automata with "-moves are respectively trace, failures, or bisimulation equivalent. Trace equivalence of finite-state automata is checkable in space proportional to the size of the automata <ref> [26] </ref>, while bisimulation equivalence is checkable in ptime [26], as are delay bisimulation and branching bisimulation [17]. The decision procedure for divergence-respecting failures equivalence [9] of finite-state automata is a straightforward generalization of Kannelakis&Smolka's pspace decision procedure for divergence-blind failures equivalence. <p> By definition, the finite nets are trace, failures, or bisimulation equivalent iff these finite-state automata with "-moves are respectively trace, failures, or bisimulation equivalent. Trace equivalence of finite-state automata is checkable in space proportional to the size of the automata <ref> [26] </ref>, while bisimulation equivalence is checkable in ptime [26], as are delay bisimulation and branching bisimulation [17]. The decision procedure for divergence-respecting failures equivalence [9] of finite-state automata is a straightforward generalization of Kannelakis&Smolka's pspace decision procedure for divergence-blind failures equivalence. <p> We then have as a corollary: Theorem 6.5.4 For finite nets without hidden transitions, trace equivalence is expspace-hard. Using these results, we obtain a lower-bound for failures equivalence; the proof is very similar to that of Kanellakis&Smolka <ref> [26] </ref> for finite-state automata. Theorem 6.5.5 For finite nets without hidden transitions, trace equivalence is polynomial time reducible to failures equivalence. Proof. <p> N 1 and N 2 are trace equivalent iff N 00 1 and N 00 2 are failures equivalent; the proof is identical to that of Kanellakis&Smolka <ref> [26] </ref> and is omitted. This is a polynomial-time reduction from trace equivalence to failures equivalence. We then have as a corollary: Theorem 6.5.6 Failures equivalence of finite nets is expspace-hard.
Reference: [27] <author> D. Kozen. </author> <title> On parallelism in turing machines. </title> <booktitle> In Proceedings of the Seventeenth Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 89-97, </pages> <year> 1976. </year>
Reference-contexts: Proof. Let A be an alternating Turing Machine that, for some polynomial p, uses p (n) space on input of size n. A well-known property of polynomial-space alternating Turing Machines is that every computation halts in deterministic time exponential in the size of the input <ref> [11, 27] </ref>. Let p 0 (n) be so large that 2 p 0 (n) exceeds the time bound of A on input of size n, and let be the finite tape alphabet of A. <p> LOWER BOUNDS 147 It is well-known that the class of problems decidable in polynomial space by alternating Turing Machines is the same as the class of problems decidable in deterministic exponential time by ordinary Turing Machines <ref> [11, 27] </ref>. We then have as a simple corollary of this fact and Theorem 6.5.7: Theorem 6.5.8 Bisimulation of finite nets is dexptime-hard. We now show the lower bounds for the remaining equivalences listed in Table 6.1.
Reference: [28] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <pages> 427 pp. </pages>
Reference-contexts: However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] and "changes of granularity" <ref> [28, 31] </ref>. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions.
Reference: [29] <author> A. J. Mayer and L. J. Stockmeyer. </author> <title> The complexity of word problems this time with interleaving. </title> <type> Technical report, </type> <institution> IBM Research Division, Almaden Research Center, </institution> <address> San Jose, CA, </address> <month> Sept. </month> <year> 1992. </year> <note> BIBLIOGRAPHY 153 </note>
Reference-contexts: elements are definable as the meanings of WT Nets, and all of our operators are continuous functions. 1.3 Deciding True Concurrency Equivalences The decision problem for finite-state concurrent processes under a variety of interleaving semantics has been widely studied in the literature, and the computation complexity has been tightly characterized <ref> [4, 26, 29, 34, 36] </ref>. In contrast, there have been essentially no results on the complexity of the decision problems for true concurrency equivalences on finite-state concurrent processes, and little is even known about the decidability of these equivalences. <p> The same approach also gives a dexptime decision procedure for history-preserving bisimulation. Our lower bounds for these true concurrency equivalences follow easily by reductions from the corresponding interleaving equivalences <ref> [29, 34, 36] </ref>. Our methods also yield tight complexity bounds for about a dozen other true concurrency equivalences, several of which resolve open problems in the literature. 1.4 Outline of the Thesis Chapter 2 presents our class of Well-Terminating Nets together with split refinements, choice refinements, and our CCS/CSP operators. <p> It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete <ref> [29, 34] </ref> and bisimulation of these nets is dexptime-complete [36]. The known results for "true" concurrency equivalences are much more limited. <p> Our lower bounds for these true concurrency equivalences follow easily from reductions from the corresponding interleaving equivalences, whose lower bounds in turn essentially follow from the results of <ref> [29, 34, 36] </ref>. We thus obtain a tight bound of expspace-completeness for pomset-trace equivalence. Likewise, we obtain dexptime-completeness for history-preserving bisimulation and maximality-preserving bisimulation, settling questions left open by Vogler [46, 48]. Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1. <p> The theorem is then a simple consequence of Theorem 6.3.6. 6.5 Lower Bounds The lower bounds for trace equivalence and bisimulation essentially follow from previous results of Mayer&Stockmeyer on Mazurkiewicz nets and regular expressions with interleaving. In particular, Mayer&Stockmeyer <ref> [29] </ref> have shown the expspace-hardness of deciding whether the language of a regular expression with interleaving is fl . Our expspace lower bound for trace equivalence of finite 1-safe Petri nets follows by a polynomial-time reduction.
Reference: [30] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1989. </year>
Reference-contexts: Introduction In concurrent process theory, processes are often represented by state machines and Petri Nets. State machines, by definition, have no explicit representation of concurrency, and they identify concurrent actions with sequential, interleaved actions. Process theories based on state machines, exemplified by Milner's CCS <ref> [30] </ref> and Hoare's CSP [21], typically have associated combinators for composing large processes from smaller components, compositional techniques for reasoning about processes through reasoning about their components, sound and complete techniques for reasoning about process equivalence, and algorithms for deciding equivalence of finite-state processes. <p> Thus, the state machine model is inherently inadequate for describing even the simplest forms of action refinement on concurrent processes. In particular, the state machines of Figure 1-2 are distinguished by all the state-machine based process equivalences in the literature, including bisimulation equivalence (CCS) <ref> [30] </ref>, partial-trace equivalence, failures equivalence (CSP) [8, 9], and Hennessy's Testing-equivalence [19], an elegant experimental justification for partial-traces and failures. We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. <p> Furthermore, his semantics supports a full process theory involving CSP-style parallel process composition-with-communication, hiding, deadlock, and divergences (cf. <ref> [9, 19, 21, 30] </ref>). Vogler's semantics is based on "pomset-traces," which are a generalization of ordinary traces, i.e., sequences of visible actions, to multi-sets of actions partially ordered to reflect causality and concurrency. <p> Except for the parallel composition operators, all of our net operations are closely related to the corresponding CCS/CSP operators on labeled transition systems (lts's), cf. <ref> [7, 30] </ref>. In particular: 2.2. <p> The details are left to the reader. Since strong bisimulation is a congruence with respect to + M (cf. <ref> [30] </ref>), the presence of C together with the above fact about start-unwinding immediately implies that lts (hN 1 ; Acti) + M lts (hN 2 ; Acti) is strongly bisimilar to the lts of hN 1 ; Acti + M hN 2 ; Acti. <p> We assume without loss of generality that for any WT Net, hN; Acti, the special actions 1 and ! are not in Act. For technical simplicity, we will work with an alternate formulation of these equivalences, namely, partial trace equivalence <ref> [19, 30] </ref> and failures equivalence [7, 8, 9, 21]. In order to keep this thesis relatively self-contained, we repeat the definitions here: Definition 3.1.3 Let T S be a labeled transition system, hS; Act [ ft g; !; s init i, where Act is a set of visible actions. <p> We note that hN 1 ; Acti is not a sequential net, since the a-labeled and b-labeled transitions can fire concurrently. It is well-known that trace-inequivalent lts's cannot be strongly bisimilar (cf. <ref> [30] </ref>). Since the labeled transitions systems of hN 1 ; Acti and hN 2 ; Acti of Figure 3-1 are strongly bisimilar, the same example shows that no interleaving semantics (that lies in between trace equivalence and strong bisimulation) can be compositional for split refinements on arbitrary WT Nets. <p> ACTION REFINEMENT Chapter 6 Deciding True Concurrency Equivalences 6.1 Introduction The computational complexity of the equivalence problem for nondeterministic finite-state automata under a variety of standard process semantics has been tightly characterized. In particular, trace equivalence and failure equivalence [8] are pspace-complete [26], while bisimulation <ref> [30] </ref> is ptime-complete [4, 26]. It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete [29, 34] and bisimulation of these nets is dexptime-complete [36]. <p> DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation <ref> [30] </ref> Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple <p> Since the labeled transition system of net (A x ) is essentially isomorphic to the labeled transition system of A on x, A must accept x. Recalling our assumptions on A, the other direction follows by a simple induction on i , where i is an i-step bisimulation (cf. <ref> [30] </ref>). This is a polynomial-time reduction from the acceptance problem for polynomial-space alternating Turing Machines to bisimulation of finite nets. 146 CHAPTER 6.
Reference: [31] <author> R. Milner. </author> <title> Action structures. </title> <type> Technical report, </type> <institution> University of Edinburgh, UK, </institution> <year> 1992. </year>
Reference-contexts: However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] and "changes of granularity" <ref> [28, 31] </ref>. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions.
Reference: [32] <author> M. Nielsen, U. Engberg, and K. S. Larsen. </author> <title> Fully abstract models for a process language with refinement. In Linear Time, Branching Time, and Partial Order in Logics and Models of Concurrency, </title> <booktitle> Volume 354 of Lecture Notes in Computer Science, </booktitle> <pages> pages 523-548, </pages> <year> 1988. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> Namely, single experimenters can only detect differences between pomsets with interval orderings <ref> [32, 47] </ref>. We repeat the definition here: Definition 3.3.1 A partial order is is an interval ordering iff whenever both w &lt; x and y &lt; z, then either w &lt; z or y &lt; x. A pomset p is an interval pomset iff p is an interval ordering.
Reference: [33] <author> L. Pomello. </author> <title> Some equivalence notions for concurrent systems: An overview. </title> <booktitle> In Advances in Petri Nets, Volume 222 of Lecture Notes in Computer Science, </booktitle> <pages> pages 381-400, </pages> <year> 1985. </year>
Reference-contexts: We also write s v =) to mean that there exists a s 0 such that s =) s 0 . The following definition is essentially standard (cf. <ref> [33] </ref>): Definition 2.1.5 The labeled transition system of a WT Net hN; Acti, written lts (hN; Acti), is the labeled transition system over Act [ ft g whose states are the reachable markings of N and whose labeled transitions correspond to firings of single transitions of N .
Reference: [34] <author> A. Rabinovich. </author> <title> Checking equivalences between concurrent systems of finite agents. </title> <booktitle> In Proceedings of ICALP '92, Volume 379 of the Lecture Series in Computer Science, </booktitle> <pages> pages 696-707, </pages> <year> 1992. </year>
Reference-contexts: elements are definable as the meanings of WT Nets, and all of our operators are continuous functions. 1.3 Deciding True Concurrency Equivalences The decision problem for finite-state concurrent processes under a variety of interleaving semantics has been widely studied in the literature, and the computation complexity has been tightly characterized <ref> [4, 26, 29, 34, 36] </ref>. In contrast, there have been essentially no results on the complexity of the decision problems for true concurrency equivalences on finite-state concurrent processes, and little is even known about the decidability of these equivalences. <p> The same approach also gives a dexptime decision procedure for history-preserving bisimulation. Our lower bounds for these true concurrency equivalences follow easily by reductions from the corresponding interleaving equivalences <ref> [29, 34, 36] </ref>. Our methods also yield tight complexity bounds for about a dozen other true concurrency equivalences, several of which resolve open problems in the literature. 1.4 Outline of the Thesis Chapter 2 presents our class of Well-Terminating Nets together with split refinements, choice refinements, and our CCS/CSP operators. <p> It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete <ref> [29, 34] </ref> and bisimulation of these nets is dexptime-complete [36]. The known results for "true" concurrency equivalences are much more limited. <p> Our lower bounds for these true concurrency equivalences follow easily from reductions from the corresponding interleaving equivalences, whose lower bounds in turn essentially follow from the results of <ref> [29, 34, 36] </ref>. We thus obtain a tight bound of expspace-completeness for pomset-trace equivalence. Likewise, we obtain dexptime-completeness for history-preserving bisimulation and maximality-preserving bisimulation, settling questions left open by Vogler [46, 48]. Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1.
Reference: [35] <author> A. Rabinovich and B. Trakhtenbrot. </author> <title> Behavior structures and nets of processes. </title> <journal> Fundamenta Informaticae, </journal> <volume> 11(4) </volume> <pages> 357-404, </pages> <year> 1988. </year>
Reference-contexts: One of the main results of this thesis is that pomset-trace equivalence is decidable for finite 1-safe Petri Nets, and is, in fact, complete for expspace. Furthermore, we show that the decision problem for history-preserving bisimulation <ref> [5, 35, 39, 44, 46] </ref> on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler [46] to be decidable; however, he left open its complexity. <p> In particular, trace equivalence and failure equivalence [8] are pspace-complete [26], while bisimulation [30] is ptime-complete [4, 26]. It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines <ref> [35] </ref>: namely, trace equivalence and failure equivalence of these nets are expspace-complete [29, 34] and bisimulation of these nets is dexptime-complete [36]. The known results for "true" concurrency equivalences are much more limited. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation <ref> [5, 35, 39, 50, 46] </ref> and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation <ref> [5, 35, 39, 50, 46] </ref> Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime <p> HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. We begin by defining history-preserving bisimulation on nets. Our definition induces the same equivalence as that of <ref> [5, 35, 39, 50, 46] </ref>. Definition 6.3.1 A set H of triples of the form (r; r 0 ; f ) is a history-preserving bisimulation between nets N and N 0 iff 1.
Reference: [36] <author> L. Stockmeyer, </author> <month> Jan. </month> <year> 1992. </year> <note> Unpublished notes. </note>
Reference-contexts: elements are definable as the meanings of WT Nets, and all of our operators are continuous functions. 1.3 Deciding True Concurrency Equivalences The decision problem for finite-state concurrent processes under a variety of interleaving semantics has been widely studied in the literature, and the computation complexity has been tightly characterized <ref> [4, 26, 29, 34, 36] </ref>. In contrast, there have been essentially no results on the complexity of the decision problems for true concurrency equivalences on finite-state concurrent processes, and little is even known about the decidability of these equivalences. <p> The same approach also gives a dexptime decision procedure for history-preserving bisimulation. Our lower bounds for these true concurrency equivalences follow easily by reductions from the corresponding interleaving equivalences <ref> [29, 34, 36] </ref>. Our methods also yield tight complexity bounds for about a dozen other true concurrency equivalences, several of which resolve open problems in the literature. 1.4 Outline of the Thesis Chapter 2 presents our class of Well-Terminating Nets together with split refinements, choice refinements, and our CCS/CSP operators. <p> It has been shown recently that these equivalence problems are exponentially harder for automata presented as finite "Mazurkiewicz nets" of synchronized state-machines [35]: namely, trace equivalence and failure equivalence of these nets are expspace-complete [29, 34] and bisimulation of these nets is dexptime-complete <ref> [36] </ref>. The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Our lower bounds for these true concurrency equivalences follow easily from reductions from the corresponding interleaving equivalences, whose lower bounds in turn essentially follow from the results of <ref> [29, 34, 36] </ref>. We thus obtain a tight bound of expspace-completeness for pomset-trace equivalence. Likewise, we obtain dexptime-completeness for history-preserving bisimulation and maximality-preserving bisimulation, settling questions left open by Vogler [46, 48]. Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1. <p> This is a polynomial-time reduction from trace equivalence to failures equivalence. We then have as a corollary: Theorem 6.5.6 Failures equivalence of finite nets is expspace-hard. Our proof of a dexptime lower bound for bisimulation is a simple adaptation of Stock-meyer's result <ref> [36] </ref> for Mazurkiewicz nets: namely, we reduce the acceptance problem for 144 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES polynomial-space Alternating Turing Machines to the bisimulation problem for finite 1-safe Petri nets.
Reference: [37] <author> D. Taubner and W. Vogler. </author> <title> Step failures semantics and a complete proof system. </title> <journal> Acta Inf., </journal> <volume> 27(2) </volume> <pages> 125-156, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: We use a similar partial order, but instead of places, we find it technically smoother to keep track of the partial ordering between the most-recent firings of transitions. This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1:
Reference: [38] <author> F. Vaandrager, </author> <year> 1991. </year> <title> Private communication. </title>
Reference-contexts: Proof. For the proof for split refinements, let hN 1 ; Acti and hN 2 ; Acti be the nets illustrated in Figure 3-4, and let Act = fa; a + ; a ; bg; this example is due to Frits Vaan-drager <ref> [38] </ref>. It is straightforward to show that [[hN 1 ; Acti]] MUST = [[hN 2 ; Acti]] MUST and that [[hN 1 ; Acti]] TEST = [[hN 2 ; Acti]] TEST .
Reference: [39] <author> R. van Glabbeek and U. Goltz. </author> <title> Equivalence notions for concurrent systems and refinement of actions. </title> <booktitle> In Proceedings of MFCS '89, Volume 379 of the Lecture Series in Computer Science, </booktitle> <pages> pages 237-248, </pages> <year> 1989. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> One of the main results of this thesis is that pomset-trace equivalence is decidable for finite 1-safe Petri Nets, and is, in fact, complete for expspace. Furthermore, we show that the decision problem for history-preserving bisimulation <ref> [5, 35, 39, 44, 46] </ref> on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler [46] to be decidable; however, he left open its complexity. <p> Then hP; Acti = start-unwind (hN; Acti) is defined as: S P = S N ] f (fl; s) : s 2 Start-cyclic N g 1 The resulting net is strongly history-preserving bisimilar <ref> [39] </ref> to the original net. 2.2. <p> As is discussed in <ref> [39, 49] </ref>, it is necessary keep track of "pomsets", which generalize linear sequences of actions to multi-sets of actions partially ordered to reflect causality and concurrency. 3.2 Some Compositional Semantics for WT Nets and Operators We begin with the standard notions of pomsets. 3.2. <p> In fact, there is an even tighter relationship between them, namely, these nets are equivalent up to a weaker form of history-preserving bisimulation <ref> [39] </ref> which treats t -moves as hidden and respects concurrent divergences. We omit the definition here since it is not necessary in our development. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation <ref> [5, 35, 39, 50, 46] </ref> and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Vogler [46, 48] has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. Decidability of such a basic true concurrency property as pomset-trace equivalence <ref> [39] </ref> appears not to have been known. (An ordinary trace is a linear sequence of visible actions; pomset-traces generalize these to multi-sets of actions partially ordered to reflect causality and concurrency.) In contrast to trace equivalence, the decidability of pomset-trace equivalence for finite nets does not obviously reduce to equivalence of <p> We use a similar partial order, but instead of places, we find it technically smoother to keep track of the partial ordering between the most-recent firings of transitions. This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces <ref> [23, 39, 47] </ref> Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces <ref> [25, 37, 39] </ref> Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe <p> DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation <ref> [25, 39] </ref> Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper <p> CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same <p> Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation <ref> [5, 35, 39, 50, 46] </ref> Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime <p> HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. We begin by defining history-preserving bisimulation on nets. Our definition induces the same equivalence as that of <ref> [5, 35, 39, 50, 46] </ref>. Definition 6.3.1 A set H of triples of the form (r; r 0 ; f ) is a history-preserving bisimulation between nets N and N 0 iff 1. <p> We now define pomset-bisimulation. Our definition induces the same equivalence as that of <ref> [6, 39, 50] </ref>. Definition 6.3.5 A set P of pairs of the form (M; M 0 ) is a pomset-bisimulation between nets N and N 0 iff 1. <p> The proof then follows easily by Theorem 6.4.1. Vogler [49] has shown that the interval-pomset equivalences coincide with the ST-equivalences <ref> [39, 42] </ref>. We have as an immediate consequence: Theorem 6.4.4 For finite nets that may contain hidden transitions, the ST-trace equivalence problem and the ST-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets.
Reference: [40] <author> R. van Glabbeek and U. Goltz. </author> <title> Partial order semantics for refinement of actions neither necessary nor sufficient but appropriate when used with care. </title> <journal> Bulletin of the European Association of Theoretical Computer Science, </journal> <volume> 38 </volume> <pages> 154-163, </pages> <year> 1989. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions.
Reference: [41] <author> R. van Glabbeek and U. Goltz. </author> <title> Refinement of actions in causality based models. In Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> Proceedings of REX Workshop '89, Volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 267-300, </pages> <year> 1989. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> The identity for + M follows easily from the definitions of start-unwinding and action refinement. Our definition of refinement generalizes the definitions of refinement given by Vogler [47] and van Glabbeek/Goltz <ref> [41] </ref> in the sense that our refined net is [[]] TEST split-fl -equivalent to their nets. In fact, there is an even tighter relationship between them, namely, these nets are equivalent up to a weaker form of history-preserving bisimulation [39] which treats t -moves as hidden and respects concurrent divergences.
Reference: [42] <author> R. van Glabbeek and F. Vaandrager. </author> <title> Petri net models for algebraic theories of concurrency. </title> <booktitle> In Proceedings of PARLE '87, Volume 259 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 224-242, </pages> <year> 1987. </year>
Reference-contexts: We note that this causes all the p -labeled transitions to be in conflict, as desired. The resulting net is given in Figure 2-7. As discussed in <ref> [42] </ref>, one technical complication arises due to initially marked places that have incoming transitions, and in general, we apply a start-unwinding operator on nets before doing the above construction. <p> As discussed in [42], one technical complication arises due to initially marked places that have incoming transitions, and in general, we apply a start-unwinding operator on nets before doing the above construction. Our start-unwinding operator, illustrated in Figure 2-8, is essentially the same as that of <ref> [15, 42] </ref> and produces a net that is "essentially the same" 1 as the original net, except that all initially marked places have empty presets. The "start-unwound" net is identical to the original net whenever all initially marked places of the original net have empty presets. <p> The pomset-traces of a WT Net hN; Acti are the set of visible (q) such that q is a finite pomset run of N , cf. Figure 3-2. It is well known (cf. <ref> [42] </ref>) that there is a uniquely determined final marking associated with each finite pomset run of a net; this is the marking reached after sequentially firing the events of the run in any order that is consistent with its partial order. <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe <p> CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces <ref> [39, 42] </ref> expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same <p> The proof then follows easily by Theorem 6.4.1. Vogler [49] has shown that the interval-pomset equivalences coincide with the ST-equivalences <ref> [39, 42] </ref>. We have as an immediate consequence: Theorem 6.4.4 For finite nets that may contain hidden transitions, the ST-trace equivalence problem and the ST-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets.
Reference: [43] <author> R. van Glabbeek and P. Weijland. </author> <title> Branching time and abstraction in bisimulation semantics. </title> <journal> Information Processing Letters, </journal> <volume> 89 </volume> <pages> 613-618, </pages> <year> 1989. </year>
Reference-contexts: We remark that the operation of refining transitions in a state-machine does model action refinement of purely sequential processes. Moreover, trace equivalence, failures equivalence, Testing-equivalence, and intuitively simple variations of bisimulation, notably delay bisimula-tion and branching bisimulation <ref> [12, 13, 43] </ref> are sound techniques for reasoning about action refinement on purely sequential processes. However, since all of these equivalences identify concurrent actions with interleaved actions, none of them are sound for reasoning about action refinement on concurrent processes. <p> DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation <ref> [43] </ref> Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this <p> DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation <ref> [43] </ref> Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an <p> Proof. Delay bisimulation and branching bisimulation coincide with bisimulation for nets without hidden transitions <ref> [43] </ref>. The lower bound for delay bisimulation and branching bisimulation is thus a simple consequence of Theorem 6.5.8. All the other lower bounds follow immediately from Theorems 6.5.4, 6.5.6, 6.5.8, and 6.5.9.
Reference: [44] <author> W. Vogler. </author> <title> Bisimulation and action refinement. </title> <booktitle> In Proceedings of STACS '91, Volume 480 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 309-321, </pages> <year> 1991. </year>
Reference-contexts: One of the main results of this thesis is that pomset-trace equivalence is decidable for finite 1-safe Petri Nets, and is, in fact, complete for expspace. Furthermore, we show that the decision problem for history-preserving bisimulation <ref> [5, 35, 39, 44, 46] </ref> on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler [46] to be decidable; however, he left open its complexity.
Reference: [45] <author> W. Vogler. </author> <title> Bisimulation and action refinement. </title> <type> Technical report, </type> <institution> Technische Universitat Munchen, </institution> <year> 1991. </year> <note> 154 BIBLIOGRAPHY </note>
Reference-contexts: In particular, our expspace-completeness results for ST-traces and ST-failures solve problems left open by Vogler [49], who had earlier proved the decidabil-ity of these equivalences. Furthermore, our decidability results for pomset-bisimulation and pomset-ST-bisimulation settle questions alluded to by Vogler <ref> [45] </ref>. This chapter is organized as follows. Section 6.2 describes our alternate characterization of pomset-trace equivalence, together with an expspace decision procedure. Similar analyses 1 For expository purposes, we refer to bounds of the form 2 O (n k ) for fixed k as exponential in n. <p> Proof. Let C [] be the net context involving split and choice refinements given in the proof of Theorem 6.4.3. Then by a proof similar to that of <ref> [45] </ref>, nets N and N 0 are maximality-preserving bisimilar iff the nets C [N ] and C [N 0 ] are history-preserving bisimilar. The theorem 6.5. LOWER BOUNDS 141 is then a simple consequence of Theorem 6.3.4. <p> Proof. Let C [] be the net context involving split and choice refinements given in the proof of Theorem 6.4.3. Then by a proof similar to that of <ref> [45] </ref>, nets N and N 0 are pomset-ST-bisimilar iff the nets C [N ] and C [N 0 ] are pomset-bisimilar.
Reference: [46] <author> W. Vogler. </author> <title> Deciding history preserving bisimulation. </title> <booktitle> In Proceedings of ICALP '91, Volume 510 of the Lecture Notes in Computer Science, </booktitle> <pages> pages 495-505, </pages> <year> 1991. </year>
Reference-contexts: One of the main results of this thesis is that pomset-trace equivalence is decidable for finite 1-safe Petri Nets, and is, in fact, complete for expspace. Furthermore, we show that the decision problem for history-preserving bisimulation <ref> [5, 35, 39, 44, 46] </ref> on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler [46] to be decidable; however, he left open its complexity. <p> Furthermore, we show that the decision problem for history-preserving bisimulation [5, 35, 39, 44, 46] on finite 1-safe Petri nets is complete for dexptime. History-preserving bisimulation had earlier been shown by Vogler <ref> [46] </ref> to be decidable; however, he left open its complexity. In contrast to interleaving equivalences, the decidability of pomset-trace equivalence for finite nets does not obviously reduce to equivalence of finite automata. <p> This chapter is self-contained, and hence repeats some earlier definitions. Chapter 7 concludes with a discussion of some further results, open problems, and future work. Chapter 2 Well-Terminating Nets and Operations 2.1 Well-Terminating Nets Throughout this thesis, we use the standard definitions (cf. <ref> [46] </ref>) of Petri Nets and their operational behavior. <p> The known results for "true" concurrency equivalences are much more limited. Vogler <ref> [46, 48] </ref> has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation <ref> [5, 35, 39, 50, 46] </ref> and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Hence instead of searching for a suitable equivalence relation on the finite set of net markings, one has to consider equivalence relations on a potentially infinite set of pomset traces and final markings. A similar difficulty appears in deciding whether finite nets are history-preserving bisimilar, which Vogler <ref> [46, 48] </ref> overcomes by maintaining, instead of an entire pomset history, a partial order on the fixed set of places of the nets that reflects "most-recent" firings. <p> Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation <ref> [5, 35, 39, 50, 46] </ref> Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime <p> We thus obtain a tight bound of expspace-completeness for pomset-trace equivalence. Likewise, we obtain dexptime-completeness for history-preserving bisimulation and maximality-preserving bisimulation, settling questions left open by Vogler <ref> [46, 48] </ref>. Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1. In particular, our expspace-completeness results for ST-traces and ST-failures solve problems left open by Vogler [49], who had earlier proved the decidabil-ity of these equivalences. <p> Section 6.5 gives lower bounds for all these equivalences. A discussion of some open problems appears in Section 6.6. 6.2 Deciding Pomset-Trace Equivalence Throughout this chapter, we use the term nets to refer to marked, 1-safe Petri Nets <ref> [46] </ref> whose transitions have labels from a fixed set Act [ft g, where Act is a set of "visible actions" and t 62 Act is the "hidden action." A transition is visible (hidden) iff its label is visible (hidden). The runs of a net are its finite firing sequences [46]. <p> Nets <ref> [46] </ref> whose transitions have labels from a fixed set Act [ft g, where Act is a set of "visible actions" and t 62 Act is the "hidden action." A transition is visible (hidden) iff its label is visible (hidden). The runs of a net are its finite firing sequences [46]. A net is finite iff it has a finite number of places and transitions; the size of a net is the total number of its places and transitions. Definition 6.2.1 A pomset is a labeled partial order. <p> HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. We begin by defining history-preserving bisimulation on nets. Our definition induces the same equivalence as that of <ref> [5, 35, 39, 50, 46] </ref>. Definition 6.3.1 A set H of triples of the form (r; r 0 ; f ) is a history-preserving bisimulation between nets N and N 0 iff 1. <p> Vogler <ref> [46, 48] </ref> has given an alternate characterization of history-preserving bisimulation based on partially ordered sets of places, together with a decidability result. We give an alternate proof based on the approach presented in Section 6.2.
Reference: [47] <author> W. Vogler. </author> <title> Failures semantics based on interval semiwords is a congruence for refinement. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 139-162, </pages> <year> 1991. </year>
Reference-contexts: These elegant properties have led to automatic verification techniques and tools such as model checkers. However, as is well-known, the state machine approach is inherently inadequate for describing action refinement, the operation of refining atomic actions in a concurrent process, which suggests aspects of top-down "modular" development <ref> [1, 2, 3, 10, 16, 20, 32, 39, 40, 41, 47] </ref> and "changes of granularity" [28, 31]. This limitation is a direct result of the identification of concurrent actions with sequential, interleaved actions. <p> It is well-known [10] that these equivalences, including partial traces, failures, bisim-ulation, and Testing-equivalence, are not compositional for even very simple forms of action refinement on Petri Nets, including those whose only effect is to "split" actions into two parts. In a seminal paper <ref> [47] </ref>, Vogler has developed a semantics for labeled, 1-safe Petri Nets that is compositional for certain simple "split" and "choice" refinements, and indeed is fully abstract for failures semantics [9] and Hennessy's must-experiments [19]. <p> Furthermore, as Vogler points out, his "general pomset" semantics for divergent nets, i.e., the intermediate semantics obtained before restricting to interval orders, is not compositional for split and choice refinements, and he states and leaves open <ref> [47, 49] </ref> the 14 CHAPTER 1. INTRODUCTION problem of identifying such a semantics that is compositional. As a consequence, his closure operations become rather technically complicated. <p> This operator places two nets in parallel and requires them to synchronize on all actions in the set L [ f p g. In particular, the non-communicating parallel composition operator is definable as k ; . Our definition is essentially the same as <ref> [47] </ref>, and is illustrated in Figure 2-4. Definition 2.2.9 Let hN 1 ; Acti; hN 2 ; Acti be WT Nets with disjoint sets of places and transi tions and with a common alphabet, Act. <p> In particular, suppose we modify the definition of pomset-divergences, hp; Di, so that D must be a singleton set. Then the redefined [[]] MUST split-fl semantics based on this modified version of pomset-divergences will not be compositional for parallel composition, which was the difficulty faced by Vogler <ref> [47, 49] </ref>. Our [[]] MUST split-fl semantics avoids this difficulty by keeping track of concurrent divergences, and resolves an open problem posed in [49]. <p> Namely, single experimenters can only detect differences between pomsets with interval orderings <ref> [32, 47] </ref>. We repeat the definition here: Definition 3.3.1 A partial order is is an interval ordering iff whenever both w &lt; x and y &lt; z, then either w &lt; z or y &lt; x. A pomset p is an interval pomset iff p is an interval ordering. <p> The identity for + M follows easily from the definitions of start-unwinding and action refinement. Our definition of refinement generalizes the definitions of refinement given by Vogler <ref> [47] </ref> and van Glabbeek/Goltz [41] in the sense that our refined net is [[]] TEST split-fl -equivalent to their nets. <p> As discussed in the Introduction, this is in contrast to the semantics of <ref> [47] </ref>, which is not compositional for nets as action refinement operators. Theorem 5.2.7 [[]] MAY , [[]] MUST split-fl , and [[]] TEST split-fl are compositional for RWT Nets as targets and operators of action refinement. Proof. <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces <ref> [23, 47] </ref> Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces <ref> [23, 39, 47] </ref> Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] <p> This idea leads to a decision procedure 119 120 CHAPTER 6. DECIDING TRUE CONCURRENCY EQUIVALENCES Class Equivalence Complexity Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces <ref> [23, 47] </ref> Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, <p> The decision procedures for most of the other true concurrency equivalences in Table 6.1 then follow from reductions to the corresponding interleaving equivalences, which are part of known full abstraction proofs <ref> [23, 25, 47, 49] </ref>. Theorem 6.4.2 For finite nets that may contain hidden transitions, the step-trace equivalence problem and the step-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets. <p> Proof. By known full abstraction results <ref> [23, 47] </ref>, there is a context C [] built from split and choice refinements such that nets N and N 0 are interval-pomset-trace equivalent or interval-pomset-failures equivalent iff the nets C [N ] and C [N 0 ] are respectively trace equivalent or failures equivalent. <p> We are currently working to extend our methods to handle these cases. Chapter 7 Other Results, Open Problems, and Future Work There is not yet a consensus on what an action refinement operator should be. For example, our action refinement operator and that of <ref> [47] </ref> are tuned to a CSP-style synchronization-with-restriction, while those of [3, 20] are tuned to a CCS-style synchronization-by-hiding-complementary-actions. In this regard, an action-refinement theory closely related to ours has been proposed by Hennessy [20].
Reference: [48] <author> W. Vogler. </author> <title> Generalized om-bisimulation. </title> <type> Technical report, </type> <institution> Technische Universitat Munchen, </institution> <year> 1991. </year>
Reference-contexts: The known results for "true" concurrency equivalences are much more limited. Vogler <ref> [46, 48] </ref> has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> Hence instead of searching for a suitable equivalence relation on the finite set of net markings, one has to consider equivalence relations on a potentially infinite set of pomset traces and final markings. A similar difficulty appears in deciding whether finite nets are history-preserving bisimilar, which Vogler <ref> [46, 48] </ref> overcomes by maintaining, instead of an entire pomset history, a partial order on the fixed set of places of the nets that reflects "most-recent" firings. <p> We thus obtain a tight bound of expspace-completeness for pomset-trace equivalence. Likewise, we obtain dexptime-completeness for history-preserving bisimulation and maximality-preserving bisimulation, settling questions left open by Vogler <ref> [46, 48] </ref>. Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1. In particular, our expspace-completeness results for ST-traces and ST-failures solve problems left open by Vogler [49], who had earlier proved the decidabil-ity of these equivalences. <p> Vogler <ref> [46, 48] </ref> has given an alternate characterization of history-preserving bisimulation based on partially ordered sets of places, together with a decidability result. We give an alternate proof based on the approach presented in Section 6.2.
Reference: [49] <author> W. Vogler. </author> <title> Is partial order semantics necessary for action refinement? Technical report, </title> <institution> Technische Universitat Munchen, </institution> <year> 1991. </year>
Reference-contexts: Furthermore, as Vogler points out, his "general pomset" semantics for divergent nets, i.e., the intermediate semantics obtained before restricting to interval orders, is not compositional for split and choice refinements, and he states and leaves open <ref> [47, 49] </ref> the 14 CHAPTER 1. INTRODUCTION problem of identifying such a semantics that is compositional. As a consequence, his closure operations become rather technically complicated. <p> As is discussed in <ref> [39, 49] </ref>, it is necessary keep track of "pomsets", which generalize linear sequences of actions to multi-sets of actions partially ordered to reflect causality and concurrency. 3.2 Some Compositional Semantics for WT Nets and Operators We begin with the standard notions of pomsets. 3.2. <p> In particular, suppose we modify the definition of pomset-divergences, hp; Di, so that D must be a singleton set. Then the redefined [[]] MUST split-fl semantics based on this modified version of pomset-divergences will not be compositional for parallel composition, which was the difficulty faced by Vogler <ref> [47, 49] </ref>. Our [[]] MUST split-fl semantics avoids this difficulty by keeping track of concurrent divergences, and resolves an open problem posed in [49]. <p> Our [[]] MUST split-fl semantics avoids this difficulty by keeping track of concurrent divergences, and resolves an open problem posed in <ref> [49] </ref>. The difficulty with keeping track of only single divergences is illustrated in redefined [[]] MUST split-fl semantics and that hN 3 ; Acti and hN 4 ; Acti have the same meanings under the redefined [[]] MUST split-fl semantics, where Act = fa; b; c; dg. <p> Our methods also yield tight complexity bounds for several other true concurrency equivalences, summarized in Table 6.1. In particular, our expspace-completeness results for ST-traces and ST-failures solve problems left open by Vogler <ref> [49] </ref>, who had earlier proved the decidabil-ity of these equivalences. Furthermore, our decidability results for pomset-bisimulation and pomset-ST-bisimulation settle questions alluded to by Vogler [45]. This chapter is organized as follows. Section 6.2 describes our alternate characterization of pomset-trace equivalence, together with an expspace decision procedure. <p> The decision procedures for most of the other true concurrency equivalences in Table 6.1 then follow from reductions to the corresponding interleaving equivalences, which are part of known full abstraction proofs <ref> [23, 25, 47, 49] </ref>. Theorem 6.4.2 For finite nets that may contain hidden transitions, the step-trace equivalence problem and the step-failure equivalence problem can be decided in space exponential in the number of places and transitions in the nets. <p> The proof then follows easily by Theorem 6.4.1. Vogler <ref> [49] </ref> has shown that the interval-pomset equivalences coincide with the ST-equivalences [39, 42].
Reference: [50] <author> W. Vogler. </author> <title> Bisimulation and action refinement. </title> <journal> Theor. Comput. Sci., </journal> <volume> 114 </volume> <pages> 173-200, </pages> <year> 1993. </year>
Reference-contexts: The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation <ref> [5, 35, 39, 50, 46] </ref> and maximality-preserving bisimulation [13, 50] for finite 1-safe Petri nets; however, their complexity remained open. <p> The known results for "true" concurrency equivalences are much more limited. Vogler [46, 48] has shown the decidability of history-preserving bisimulation [5, 35, 39, 50, 46] and maximality-preserving bisimulation <ref> [13, 50] </ref> for finite 1-safe Petri nets; however, their complexity remained open. <p> Traces Step-traces [25, 37, 39] Traces ST-traces [39, 42] expspace-complete Interval-pomset-traces [23, 47] Pomset-traces [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation <ref> [5, 35, 39, 50, 46] </ref> Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation [50] dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime <p> [23, 39, 47] Failures [9] Step-failures [25, 37, 39] Failures/ ST-failures [39, 42] expspace-complete divergences Interval-pomset-failures [23, 47] Bisimulation [30] Delay bisimulation [43] Branching bisimulation [43] Step-bisimulation [25, 39] Bisimulation ST-bisimulation [39, 42] dexptime-complete History-preserving Bisimulation [5, 35, 39, 50, 46] Maximality-preserving-bisimulation [13] Pomset-bisimulation [6] dexptime-hard and in expspace Pomset-ST-bisimulation <ref> [50] </ref> dexptime-hard and in expspace Table 6.1: Complexity results for finite 1-safe Petri Nets for pomset-trace equivalence, and a simple analysis of this procedure yields an expspace upper bound. 1 The same approach also gives a dexptime decision procedure for history-preserving bisimulation. <p> HISTORY-PRESERVING BISIMULATION AND POMSET-BISIMULATION 135 6.3 History-Preserving Bisimulation and Pomset-Bisimulation In this section, we assume that all nets may contain t -labeled transitions. We begin by defining history-preserving bisimulation on nets. Our definition induces the same equivalence as that of <ref> [5, 35, 39, 50, 46] </ref>. Definition 6.3.1 A set H of triples of the form (r; r 0 ; f ) is a history-preserving bisimulation between nets N and N 0 iff 1. <p> We now define pomset-bisimulation. Our definition induces the same equivalence as that of <ref> [6, 39, 50] </ref>. Definition 6.3.5 A set P of pairs of the form (M; M 0 ) is a pomset-bisimulation between nets N and N 0 iff 1. <p> The theorem 6.5. LOWER BOUNDS 141 is then a simple consequence of Theorem 6.3.4. Lastly, our decision procedure for pomset-bisimulation yields one for pomset-ST-bisimulation <ref> [50] </ref>: Theorem 6.4.6 For finite nets that may contain hidden transitions, the pomset-ST-bisimulation problem can be decided in space exponential in the number of places and transitions in the nets. Proof. Let C [] be the net context involving split and choice refinements given in the proof of Theorem 6.4.3.
References-found: 50

