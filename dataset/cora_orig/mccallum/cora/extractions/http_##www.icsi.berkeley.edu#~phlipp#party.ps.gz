URL: http://www.icsi.berkeley.edu/~phlipp/party.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~phlipp/phlipp.publ.html
Root-URL: http://www.icsi.berkeley.edu
Email: phlipp@ira.uka.de  
Title: JavaParty Transparent Remote Objects in Java straightforward mechanisms for parallel programming on distributed memory machines,
Author: Michael Philippsen and Matthias Zenger 
Date: 1225-1242, November 1997.  
Note: In: Concurrency: Practice Experience, Volume 9, Number 11, pp.  Unfortunately, Java does not provide elegant and  
Address: Germany  
Affiliation: University of Karlsruhe,  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas E. Anderson, David E. Culler, and David A. Pat-terson. </author> <title> A Case for NOW (Network of Workstations). </title> <journal> IEEE Micro, </journal> <volume> 15(1) </volume> <pages> 54-64, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Currently several projects are under way that achieve increased bandwidth, reduced latency, and better reliability within workstation clusters <ref> [1, 2, 21] </ref>. These projects will fill the gaps between desktop SMPs, parallel computers, and Internet-based meta computing. A similar gap can be noticed on the software side.
Reference: [2] <author> Nanette J. Boden, Danny Cohen, Robert E. Felderman, Alan E. Kulawik, Charles L. Seitz, Jarov N. Seizovic, and Wen-King Su. Myrinet: </author> <title> A Gigabit-per-Second Local Area Network. </title> <journal> IEEE Micro, </journal> <volume> 15(1) </volume> <pages> 29-36, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Currently several projects are under way that achieve increased bandwidth, reduced latency, and better reliability within workstation clusters <ref> [1, 2, 21] </ref>. These projects will fill the gaps between desktop SMPs, parallel computers, and Internet-based meta computing. A similar gap can be noticed on the software side.
Reference: [3] <author> J. Clearbout and B. Biondi. </author> <title> Geophysics in object-oriented numerics (GOON): Informal conference. In Stan-ford Exploration Project Report No. </title> <type> 93. </type> <month> October </month> <year> 1996. </year> <note> http://sepwww.stanford.edu/sep. </note>
Reference-contexts: Several projects are under way that either use the JavaParty platform or improve it. The projects some of which are supported by the DFG, Germany's national science foundation include a data-intensive geophysical application (in cooperation with the Stanford Exploration Project <ref> [3] </ref>), a data mining project, real-time vehicle tracking in traffic scenes, and locality optimization and improvement of the underlying communication libraries. In section 2 we discuss the features of JavaParty.
Reference: [4] <author> John T. Feo, </author> <title> editor. A Comparative Study of Parallel Programming Languages: The Salishan Problems. </title> <publisher> Elsevier Science Publishers, Holland, </publisher> <year> 1992. </year>
Reference-contexts: The runtime system is based on load-balancing and network partitioning algorithms. Currently replication is not considered, although it could easily be added, at least for static variables and methods. 3 JavaParty versus Sockets and RMI For benchmarking purposes, we implemented some of the Salishan Problems <ref> [4] </ref> four times: in sequential Java, in Java with explicit socket communication, in Java with RMI, and in JavaParty.
Reference: [5] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1994. </year>
Reference-contexts: To achieve location transparency, JavaParty offers distribution strategies that are used when new objects are created. Distribution strategies are implemented in the runtime system using the "strategy" design pattern <ref> [5] </ref>; they can thus be selected and changed at runtime. Compiler analysis (or a well-informed programmer) can insert code that directs the strategy's placement decision. In addition to distribution strategies for object creation, the runtime system monitors the interaction of remote objects and the induced communication paths.
Reference: [6] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Among the essential features that made Java <ref> [6] </ref> popular are (a) the availability of portable Internet communication APIs [7], like for example socket communication, and (b) the fact that threads and synchronization mechanisms are part of the language [14].
Reference: [7] <author> James Gosling, Frank Yellin, </author> <title> and The Java Team. The Java Application Programming Interface, volume 1 Core Packages. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Among the essential features that made Java [6] popular are (a) the availability of portable Internet communication APIs <ref> [7] </ref>, like for example socket communication, and (b) the fact that threads and synchronization mechanisms are part of the language [14].
Reference: [8] <author> Satoshi Hirano. </author> <title> Horb the magic carpet for network computing. </title> <note> http://ring.etl.go.jp/openlab/horb/, 1996. </note>
Reference-contexts: There are several alternatives: CORBA offers multilingual elements and is therefore not closely coupled to Java. Therefore, use of CORBA would require us to implement a lot of functionality that is already provided with RMI, e.g., a distributed garbage collector. "Horb" <ref> [8] </ref> is similar to RMI and offers a CORBA-like distributed environment. Hence, the results of the comparison of JavaParty versus RMI apply to Horb as well.
Reference: [9] <author> Susan Flynn Hummel, Ton Ngo, and Harini Srinivasan. </author> <title> SPMD programming in Java. </title> <journal> Concurrency: Practice and Experience, </journal> <month> June </month> <year> 1997. </year> <month> 9 </month>
Reference-contexts: Although thread based parallelism is available in Java some researchers consider it inappropriate and lacking in expressive power. Some research groups therefore added data parallelism to Java <ref> [9] </ref> others added multiple paradigms [11, 13]. Some of these systems require additional machine dependent libraries or non-portable Java virtual machines. In contrast to those, JavaParty remains as close to Java as possible and runs in any standard Java environment. JavaParty currently does not offer any means for data parallelism.
Reference: [10] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> Febru-ary </month> <year> 1988. </year>
Reference-contexts: The positive effects of object migration have for example been studied in the Emerald project <ref> [10] </ref>. The JavaParty group currently studies the integration thereof into compile-time and run-time optimization. None of the systems mentioned above offers object migration. * Target platform.
Reference: [11] <author> L. V. Kale, Milind Bhandarkar, and Terry Wilmarth. </author> <title> Design and implementation of parallel Java with global object space. </title> <booktitle> In Proc. of Conf. on Distributed Processing Technology and Applications, </booktitle> <address> Las Vegas, Nevada, </address> <year> 1997. </year>
Reference-contexts: Although thread based parallelism is available in Java some researchers consider it inappropriate and lacking in expressive power. Some research groups therefore added data parallelism to Java [9] others added multiple paradigms <ref> [11, 13] </ref>. Some of these systems require additional machine dependent libraries or non-portable Java virtual machines. In contrast to those, JavaParty remains as close to Java as possible and runs in any standard Java environment. JavaParty currently does not offer any means for data parallelism.
Reference: [12] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> In Proc. 1994 Winter Usenix Conf., </booktitle> <pages> pages 115-131, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Whereas JavaParty uses the standard network to access Bytecode files, ROJ ships Bytecode. By shipping Bytecode, a single resulting Bytecode file is sufficient instead of ten. "Java/DSM" [22] is an implementation of Java on top of the Treadmarks distributed shared memory system <ref> [12] </ref>. Java/DSM requires special implementations of the Java virtual machine since objects must be allocated on the heap. In addition, Java/DSM has to struggle with heterogeneous environments which are already solved by our RMI approach.
Reference: [13] <author> Pascale Launay and Jean-Louis Pazat. </author> <title> Integration of control and data parallelism in an object oriented language. </title> <booktitle> In Proc. of 6th Workshop on Compilers for Parallel Computers (CPC'96), </booktitle> <address> Aachen, Germany, </address> <month> December 11-13, </month> <year> 1996. </year>
Reference-contexts: Although thread based parallelism is available in Java some researchers consider it inappropriate and lacking in expressive power. Some research groups therefore added data parallelism to Java [9] others added multiple paradigms <ref> [11, 13] </ref>. Some of these systems require additional machine dependent libraries or non-portable Java virtual machines. In contrast to those, JavaParty remains as close to Java as possible and runs in any standard Java environment. JavaParty currently does not offer any means for data parallelism.
Reference: [14] <author> Doug Lea. </author> <title> Concurrent Programming in Java Design Principles and Patterns. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Among the essential features that made Java [6] popular are (a) the availability of portable Internet communication APIs [7], like for example socket communication, and (b) the fact that threads and synchronization mechanisms are part of the language <ref> [14] </ref>. Java's threads allow for portable parallel programming within the bounds of shared memory; if the hardware offers several processors, (in theory) a threaded application can gain speed. 1 For wide area client-server applications, the communication libraries offer a good set of tools for implementing arbitrary communication protocols.
Reference: [15] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. </title> <editor> In Gul Agha, Peter Wegner, and Aki-nori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 107-150. </pages> <publisher> MIT Press Cambridge, </publisher> <address> Massachusetts, London, England, </address> <year> 1993. </year>
Reference-contexts: Most of the other languages are used to do research in concurrency coordination constructs. Threads and explicit synchronization as used in Java and Java-Party are not optimal for object-oriented languages because this approach suffers from various types of inheritance anomaly <ref> [15] </ref>. 5 JavaParty has several advantages that most of the well known COOLs do not have: Since JavaParty is almost identical to Java, it can immediately be used by an army of Java programmers whereas other COOLs often are difficult to learn.
Reference: [16] <author> Nataraj Nagaratnam and Arvind Srinivasan. </author> <title> Remote objects in Java. </title> <booktitle> In IASTED Intl. Conf. on Networks, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: We refrained from implementing our own basic communication platform because we want JavaParty to instantly run on all major platforms. * Other remote Java objects. We know of two other systems that try to implement transparent remote objects in Java. In contrast to JavaParty, "Remote Objects in Java" (ROJ) <ref> [16] </ref> introduces a new keyword remotenew that must be used to create objects on a specific remote host. The programmer is in charge of object placement. Since objects cannot migrate there is no way to enhance and exploit locality. The new keyword is mapped to a new Bytecode opcode.
Reference: [17] <author> Martin Odersky and Michael Philippsen. </author> <note> Espresso Grinder. http://wwwipd.ira.uka.de/~espresso, 1996. </note>
Reference-contexts: Moreover, there are no mechanisms in RMI to migrate objects and thus to increase locality on purpose. Section 4 presents in detail how JavaParty imple ments migration and exploits locality. 4 Design and Implementation We have implemented JavaParty as a pre-processing phase into our Java compilers EspressoGrinder <ref> [17] </ref> and Pizza [18]. Both Java compilers are freely available and have thousands of non-commercial and commercial users world wide. Alternatively, the JavaParty transformation can be used stand-alone to generate regular Java code that is then fed through any Java compiler, e.g., javac.
Reference: [18] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Proc. 24th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Section 4 presents in detail how JavaParty imple ments migration and exploits locality. 4 Design and Implementation We have implemented JavaParty as a pre-processing phase into our Java compilers EspressoGrinder [17] and Pizza <ref> [18] </ref>. Both Java compilers are freely available and have thousands of non-commercial and commercial users world wide. Alternatively, the JavaParty transformation can be used stand-alone to generate regular Java code that is then fed through any Java compiler, e.g., javac.
Reference: [19] <author> Michael Philippsen. </author> <title> Imperative concurrent object-oriented languages. </title> <type> Technical Report TR-95-050, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Finally, for separate compilation and the interaction of remote classes with non-remote classes during semantic analysis, we need an additional helper class B.local that is only used during compilation. 5 Related Work * Concurrent object-oriented languages. From over a hundred existing imperative concurrent object-oriented languages (COOL) surveyed in <ref> [19] </ref> more than half do not consider problems of distribution and locality at all.
Reference: [20] <author> Sun Microsystems Inc., </author> <title> Mountain View, CA. Java Remote Method Invocation Specification, </title> <type> beta draft, </type> <year> 1996. </year>
Reference-contexts: If the intended protocol can be reduced to method invocations on remote Java objects, then RMI <ref> [20] </ref> can be used. With RMI, Java objects that reside on different hosts can be used in a CORBA-like fashion, i.e., remote object references provided by a name server are bound to local variables. Then, methods can be called on those remote objects.
Reference: [21] <author> Thomas M. Warschko, Joachim M. Blum, and Walter F. Tichy. </author> <title> The ParaStation Project: Using Workstations as Building Blocks for Parallel Computing. </title> <booktitle> In Intl. Conf. on Parallel and Distributed Processing, Techniques and Applications (PDPTA'96), </booktitle> <pages> pages 375-386, </pages> <address> Sunnyvale, CA, </address> <month> August 9-11, </month> <year> 1996. </year>
Reference-contexts: Currently several projects are under way that achieve increased bandwidth, reduced latency, and better reliability within workstation clusters <ref> [1, 2, 21] </ref>. These projects will fill the gaps between desktop SMPs, parallel computers, and Internet-based meta computing. A similar gap can be noticed on the software side. <p> Although in principle a JavaParty can include any number and type of workstations, high network latencies and low network speeds restrict the usefulness of traditional networks. Better runtimes can be achieved with special interconnection hardware. 3 Our current JavaParty implementation runs in a ParaStation network <ref> [21] </ref>, where TCP/IP-like sockets deliver 15 MByte/s for small-packet point-to-point communication with 3.4 s latency. JavaParty is a two purpose platform. It serves as a programming environment for cluster applications and it is a basis for computer science research in optimization techniques to improve locality and reduce communication time.
Reference: [22] <author> Weimin Yu and Alan Cox. Java/DSM: </author> <title> A platform for heterogeneous computing. </title> <note> This issue, 1997. 10 </note>
Reference-contexts: An interesting idea is that ROJ does not rely on a common file system. Whereas JavaParty uses the standard network to access Bytecode files, ROJ ships Bytecode. By shipping Bytecode, a single resulting Bytecode file is sufficient instead of ten. "Java/DSM" <ref> [22] </ref> is an implementation of Java on top of the Treadmarks distributed shared memory system [12]. Java/DSM requires special implementations of the Java virtual machine since objects must be allocated on the heap. In addition, Java/DSM has to struggle with heterogeneous environments which are already solved by our RMI approach.
References-found: 22

